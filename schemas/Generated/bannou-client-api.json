{
  "openapi": "3.0.3",
  "info": {
    "title": "Bannou Client API",
    "description": "Consolidated client-facing API schema for Bannou services.\n\nThis schema contains all endpoints accessible to game clients (anonymous, user,\nauthenticated, developer roles). Admin-only endpoints are excluded.\n\nGenerated by generate-client-schema.py from individual service schemas.\n\n## WebSocket Binary Protocol\n\nAll endpoints can be accessed via the WebSocket binary protocol:\n- Request header: 31 bytes (flags, channel, sequence, serviceGuid, messageId)\n- Response header: 16 bytes (flags, channel, sequence, messageId, responseCode)\n- Payload: JSON (UTF-8 encoded)\n\nSee the x-bannou-protocol extension for protocol details.",
    "version": "1.0.0",
    "contact": {
      "name": "Bannou Development Team"
    }
  },
  "servers": [
    {
      "url": "http://localhost:5012",
      "description": "Local development server"
    }
  ],
  "x-bannou-protocol": {
    "requestHeaderSize": 31,
    "responseHeaderSize": 16,
    "headerLayout": {
      "request": [
        {
          "offset": 0,
          "size": 1,
          "field": "flags",
          "type": "uint8"
        },
        {
          "offset": 1,
          "size": 2,
          "field": "channel",
          "type": "uint16_be"
        },
        {
          "offset": 3,
          "size": 4,
          "field": "sequence",
          "type": "uint32_be"
        },
        {
          "offset": 7,
          "size": 16,
          "field": "serviceGuid",
          "type": "guid_rfc4122"
        },
        {
          "offset": 23,
          "size": 8,
          "field": "messageId",
          "type": "uint64_be"
        }
      ],
      "response": [
        {
          "offset": 0,
          "size": 1,
          "field": "flags",
          "type": "uint8"
        },
        {
          "offset": 1,
          "size": 2,
          "field": "channel",
          "type": "uint16_be"
        },
        {
          "offset": 3,
          "size": 4,
          "field": "sequence",
          "type": "uint32_be"
        },
        {
          "offset": 7,
          "size": 8,
          "field": "messageId",
          "type": "uint64_be"
        },
        {
          "offset": 15,
          "size": 1,
          "field": "responseCode",
          "type": "uint8"
        }
      ]
    },
    "messageFlags": {
      "None": 0,
      "Binary": 1,
      "Encrypted": 2,
      "Compressed": 4,
      "HighPriority": 8,
      "Event": 16,
      "Client": 32,
      "Response": 64,
      "Meta": 128
    },
    "responseCodes": {
      "OK": 0,
      "RequestError": 10,
      "RequestTooLarge": 11,
      "TooManyRequests": 12,
      "InvalidRequestChannel": 13,
      "Unauthorized": 20,
      "ServiceNotFound": 30,
      "ClientNotFound": 31,
      "MessageNotFound": 32,
      "BroadcastNotAllowed": 40,
      "Service_BadRequest": 50,
      "Service_NotFound": 51,
      "Service_Unauthorized": 52,
      "Service_Conflict": 53,
      "Service_InternalServerError": 60,
      "ShortcutExpired": 70,
      "ShortcutTargetNotFound": 71,
      "ShortcutRevoked": 72
    }
  },
  "paths": {
    "/account/profile/update": {
      "post": {
        "summary": "Update account profile",
        "operationId": "updateProfile",
        "tags": [
          "Profile Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateProfileRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Profile updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountResponse"
                }
              }
            }
          },
          "404": {
            "description": "Account not found"
          }
        }
      }
    },
    "/account/password/update": {
      "post": {
        "summary": "Update account password hash",
        "operationId": "updatePasswordHash",
        "tags": [
          "Account Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdatePasswordRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Password hash updated successfully"
          },
          "404": {
            "description": "Account not found"
          }
        }
      }
    },
    "/account/verification/update": {
      "post": {
        "summary": "Update email verification status",
        "operationId": "updateVerificationStatus",
        "tags": [
          "Account Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateVerificationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Verification status updated successfully"
          },
          "404": {
            "description": "Account not found"
          }
        }
      }
    },
    "/achievement/definition/create": {
      "post": {
        "summary": "Create a new achievement definition",
        "description": "Create a new achievement with specified criteria and platform mappings.\nDeveloper-only endpoint.\n",
        "operationId": "createAchievementDefinition",
        "tags": [
          "Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateAchievementDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Achievement created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AchievementDefinitionResponse"
                }
              }
            }
          },
          "409": {
            "description": "Achievement with this ID already exists"
          }
        }
      }
    },
    "/achievement/definition/list": {
      "post": {
        "summary": "List achievement definitions",
        "description": "List achievements for a game service with optional platform filtering.",
        "operationId": "listAchievementDefinitions",
        "tags": [
          "Definitions"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListAchievementDefinitionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Achievement definitions retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListAchievementDefinitionsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/achievement/definition/update": {
      "post": {
        "summary": "Update achievement definition",
        "description": "Update properties of an existing achievement.\nDeveloper-only endpoint.\n",
        "operationId": "updateAchievementDefinition",
        "tags": [
          "Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateAchievementDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Achievement updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AchievementDefinitionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Achievement not found"
          }
        }
      }
    },
    "/achievement/definition/delete": {
      "post": {
        "summary": "Delete achievement definition",
        "description": "Delete an achievement. Earned instances are preserved in history.\nDeveloper-only endpoint.\n",
        "operationId": "deleteAchievementDefinition",
        "tags": [
          "Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteAchievementDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Achievement deleted successfully"
          },
          "404": {
            "description": "Achievement not found"
          }
        }
      }
    },
    "/achievement/progress/get": {
      "post": {
        "summary": "Get entity's achievement progress",
        "description": "Get progress for an entity across all achievements or a specific one.",
        "operationId": "getAchievementProgress",
        "tags": [
          "Progress"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetAchievementProgressRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Progress retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AchievementProgressResponse"
                }
              }
            }
          }
        }
      }
    },
    "/achievement/list-unlocked": {
      "post": {
        "summary": "List unlocked achievements",
        "description": "Get all achievements unlocked by an entity.",
        "operationId": "listUnlockedAchievements",
        "tags": [
          "Progress"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListUnlockedAchievementsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Unlocked achievements retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListUnlockedAchievementsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/template/create": {
      "post": {
        "operationId": "CreateActorTemplate",
        "summary": "Create an actor template (category definition)",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateActorTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActorTemplateResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/template/update": {
      "post": {
        "operationId": "UpdateActorTemplate",
        "summary": "Update an actor template",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateActorTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActorTemplateResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/template/delete": {
      "post": {
        "operationId": "DeleteActorTemplate",
        "summary": "Delete an actor template",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteActorTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteActorTemplateResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/spawn": {
      "post": {
        "operationId": "SpawnActor",
        "summary": "Spawn a new actor from a template",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SpawnActorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Actor spawned successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActorInstanceResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/stop": {
      "post": {
        "operationId": "StopActor",
        "summary": "Stop a running actor",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StopActorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Actor stopped successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StopActorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/inject-perception": {
      "post": {
        "operationId": "InjectPerception",
        "summary": "Inject a perception event into an actor's queue (testing)",
        "description": "Injects a perception event directly into the actor's perception queue\nfor testing purposes. Useful for testing actor behavior without a\nfull game server setup.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InjectPerceptionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Perception injected successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InjectPerceptionResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/encounter/start": {
      "post": {
        "operationId": "StartEncounter",
        "summary": "Start an encounter managed by an Event Brain actor",
        "description": "Initializes an encounter with the specified participants. The Event Brain actor\nwill coordinate the encounter, sending instructions to participant NPC Brain actors\nvia their character perception channels.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StartEncounterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounter started successfully"
          }
        }
      }
    },
    "/actor/encounter/update-phase": {
      "post": {
        "operationId": "UpdateEncounterPhase",
        "summary": "Update the phase of an active encounter",
        "description": "Updates the phase of an encounter being managed by an Event Brain actor.\nPhase changes are logged and can trigger behavior changes in participant actors.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateEncounterPhaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounter phase updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateEncounterPhaseResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/encounter/end": {
      "post": {
        "operationId": "EndEncounter",
        "summary": "End an active encounter",
        "description": "Ends an encounter being managed by an Event Brain actor. This clears the\nencounter state and allows the actor to manage a new encounter.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EndEncounterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounter ended successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EndEncounterResponse"
                }
              }
            }
          }
        }
      }
    },
    "/assets/upload/request": {
      "post": {
        "summary": "Request upload URL for a new asset",
        "description": "Generate a pre-signed URL for uploading a new asset directly to storage.\nFor large files (>50MB), returns multipart upload configuration.\n",
        "operationId": "requestUpload",
        "tags": [
          "Assets"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UploadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Upload URL generated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (filename, size, or content_type)"
          },
          "401": {
            "description": "Not authenticated"
          },
          "403": {
            "description": "Insufficient permissions"
          }
        }
      }
    },
    "/assets/upload/complete": {
      "post": {
        "summary": "Mark upload as complete, trigger processing",
        "description": "Called after the client has uploaded the file to the pre-signed URL.\nTriggers the asset processing pipeline (texture conversion, model validation, etc.)\nand emits completion events via WebSocket.\n",
        "operationId": "completeUpload",
        "tags": [
          "Assets"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompleteUploadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Asset created, processing started",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetMetadata"
                }
              }
            }
          },
          "400": {
            "description": "Invalid upload_id or missing parts for multipart"
          },
          "404": {
            "description": "Upload session not found or expired"
          }
        }
      }
    },
    "/assets/get": {
      "post": {
        "summary": "Get asset metadata and download URL",
        "description": "Retrieve asset metadata and generate a pre-signed download URL.\nSpecify version to download a specific version, or omit for latest.\n",
        "operationId": "getAsset",
        "tags": [
          "Assets"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetAssetRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Asset metadata with download URL",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetWithDownloadUrl"
                }
              }
            }
          },
          "404": {
            "description": "Asset not found"
          }
        }
      }
    },
    "/assets/list-versions": {
      "post": {
        "summary": "List all versions of an asset",
        "description": "Retrieve version history for an asset with pagination.\nIncludes version IDs, creation timestamps, and archive status.\n",
        "operationId": "listAssetVersions",
        "tags": [
          "Assets"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListVersionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of asset versions",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetVersionList"
                }
              }
            }
          },
          "404": {
            "description": "Asset not found"
          }
        }
      }
    },
    "/assets/search": {
      "post": {
        "summary": "Search assets by tags, type, or realm",
        "description": "Search assets using various filters with pagination.\nAll filters are optional and combine with AND logic.\n",
        "operationId": "searchAssets",
        "tags": [
          "Assets"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AssetSearchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Matching assets",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetSearchResult"
                }
              }
            }
          }
        }
      }
    },
    "/bundles/create": {
      "post": {
        "summary": "Create asset bundle from multiple assets",
        "description": "Create a .bannou bundle containing multiple assets.\nFor large bundles, processing is delegated to the processing pool.\nCompletion notification sent via WebSocket event.\n",
        "operationId": "createBundle",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateBundleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bundle created immediately (small bundles)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateBundleResponse"
                }
              }
            }
          },
          "202": {
            "description": "Bundle creation queued (large bundles)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateBundleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid asset_ids or bundle_id"
          }
        }
      }
    },
    "/bundles/get": {
      "post": {
        "summary": "Get bundle manifest and download URL",
        "description": "Retrieve bundle metadata and generate a pre-signed download URL.\nSupports both native .bannou format and ZIP conversion (cached).\n",
        "operationId": "getBundle",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetBundleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bundle manifest with download URL",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BundleWithDownloadUrl"
                }
              }
            }
          },
          "404": {
            "description": "Bundle not found"
          }
        }
      }
    },
    "/bundles/upload/request": {
      "post": {
        "summary": "Request upload URL for a pre-made bundle",
        "description": "Upload a pre-built bundle (.bannou or .zip format).\nAfter upload, the bundle undergoes validation before registration.\n",
        "operationId": "requestBundleUpload",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BundleUploadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Upload URL generated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid filename or size"
          }
        }
      }
    },
    "/bundles/metabundle/create": {
      "post": {
        "summary": "Create metabundle from source bundles",
        "description": "Compose a metabundle by extracting and repackaging assets from multiple\nsource bundles. The resulting metabundle is a complete physical copy with\nprovenance metadata tracking the source bundles.\n\nAssets are deduplicated by content hash. If the same asset ID exists in\nmultiple source bundles with different content hashes, the request fails\nwith conflict details.\n",
        "operationId": "createMetabundle",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateMetabundleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Metabundle created or queued for creation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateMetabundleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or asset conflicts detected"
          },
          "404": {
            "description": "One or more source bundles not found"
          },
          "409": {
            "description": "Metabundle ID already exists"
          }
        }
      }
    },
    "/bundles/job/status": {
      "post": {
        "summary": "Get async metabundle job status",
        "description": "Poll the status of an async metabundle creation job.\nUse the jobId returned from createMetabundle when status was 'queued'.\n\nClients can either poll this endpoint or wait for the\nMetabundleCreationCompleteEvent via WebSocket for completion notification.\n",
        "operationId": "getJobStatus",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetJobStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Job status retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetJobStatusResponse"
                }
              }
            }
          },
          "404": {
            "description": "Job not found or expired"
          }
        }
      }
    },
    "/bundles/job/cancel": {
      "post": {
        "summary": "Cancel an async metabundle job",
        "description": "Cancel a pending or processing metabundle creation job.\nJobs that are already completed (ready or failed) cannot be cancelled.\n\nSuccessfully cancelled jobs will emit a MetabundleCreationCompleteEvent\nwith status 'cancelled' via WebSocket.\n",
        "operationId": "cancelJob",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CancelJobRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Job cancellation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CancelJobResponse"
                }
              }
            }
          },
          "404": {
            "description": "Job not found or expired"
          },
          "409": {
            "description": "Job cannot be cancelled (already completed)"
          }
        }
      }
    },
    "/bundles/resolve": {
      "post": {
        "summary": "Compute optimal bundles for requested assets",
        "description": "Given a list of asset IDs, compute the optimal set of bundles to download\nto obtain all requested assets with minimal transfers.\n\nThe algorithm uses greedy set-cover optimization:\n1. Find all bundles containing requested assets\n2. Select bundles that cover the most uncovered assets\n3. Prefer metabundles when coverage is equal (tie-breaker)\n4. Include standalone assets for any remaining unresolved IDs\n\nReturns pre-signed download URLs for all selected bundles and assets.\n",
        "operationId": "resolveBundles",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResolveBundlesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Resolution complete with download URLs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResolveBundlesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          }
        }
      }
    },
    "/bundles/query/by-asset": {
      "post": {
        "summary": "Find all bundles containing a specific asset",
        "description": "Query the reverse index to find all bundles (source and metabundle)\nthat contain a specific asset ID. Useful for understanding asset\ndistribution and debugging resolution issues.\n",
        "operationId": "queryBundlesByAsset",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryBundlesByAssetRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bundles containing the asset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryBundlesByAssetResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          }
        }
      }
    },
    "/bundles/update": {
      "post": {
        "summary": "Update bundle metadata",
        "description": "Update metadata for an existing bundle (name, description, tags).\nDoes not modify bundle contents - for that, create a new bundle.\n\nIncrements the bundle version and records the change in version history.\nOnly the bundle owner or admin can update.\n",
        "operationId": "updateBundle",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateBundleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bundle updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateBundleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Not authorized to update this bundle"
          },
          "404": {
            "description": "Bundle not found or deleted"
          }
        }
      }
    },
    "/bundles/delete": {
      "post": {
        "summary": "Soft-delete a bundle",
        "description": "Soft-delete a bundle, marking it as deleted but retaining data\nfor the configured retention period (default 30 days).\n\nDeleted bundles are excluded from resolution and queries by default.\nUse permanent=true for immediate, unrecoverable deletion (admin only).\n\nOnly the bundle owner or admin can delete.\n",
        "operationId": "deleteBundle",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteBundleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bundle deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteBundleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Not authorized to delete this bundle"
          },
          "404": {
            "description": "Bundle not found"
          }
        }
      }
    },
    "/bundles/restore": {
      "post": {
        "summary": "Restore a soft-deleted bundle",
        "description": "Restore a bundle that was soft-deleted, making it active again.\nCan only restore bundles within their retention period.\n\nOnly the bundle owner or admin can restore.\n",
        "operationId": "restoreBundle",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RestoreBundleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bundle restored successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RestoreBundleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or bundle not in deleted state"
          },
          "403": {
            "description": "Not authorized to restore this bundle"
          },
          "404": {
            "description": "Bundle not found or permanently deleted"
          },
          "410": {
            "description": "Bundle retention period has expired"
          }
        }
      }
    },
    "/bundles/query": {
      "post": {
        "summary": "Query bundles with advanced filters",
        "description": "Query bundles with flexible filtering options including:\n- Tag matching (exact, exists, not exists)\n- Status filtering (active, deleted)\n- Date range filtering\n- Name search (contains)\n- Owner filtering\n- Realm and bundle type filtering\n\nSupports pagination and sorting.\n",
        "operationId": "queryBundles",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryBundlesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Query results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryBundlesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid query parameters"
          }
        }
      }
    },
    "/bundles/list-versions": {
      "post": {
        "summary": "List version history for a bundle",
        "description": "Get the version history for a bundle, showing all metadata changes\nover time. Each version record includes:\n- Version number\n- When the change was made\n- Who made the change\n- What changed\n- Optional reason for the change\n\nThe current version's full metadata snapshot is always included.\n",
        "operationId": "listBundleVersions",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListBundleVersionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Version history",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListBundleVersionsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Bundle not found"
          }
        }
      }
    },
    "/assets/bulk-get": {
      "post": {
        "summary": "Batch asset metadata lookup",
        "description": "Retrieve metadata for multiple assets in a single request.\nOptionally includes pre-signed download URLs.\nMaximum 100 asset IDs per request.\n",
        "operationId": "bulkGetAssets",
        "tags": [
          "Assets"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BulkGetAssetsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Asset metadata retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkGetAssetsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or too many asset IDs"
          }
        }
      }
    },
    "/auth/login": {
      "post": {
        "summary": "Login with email/password",
        "operationId": "login",
        "tags": [
          "Authentication"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Login successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthResponse"
                }
              }
            }
          },
          "401": {
            "description": "Invalid credentials"
          },
          "429": {
            "description": "Too many login attempts"
          }
        }
      }
    },
    "/auth/register": {
      "post": {
        "summary": "Register new user account",
        "operationId": "register",
        "tags": [
          "Authentication"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegisterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Registration successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisterResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request data"
          },
          "409": {
            "description": "Username already exists"
          }
        }
      }
    },
    "/auth/oauth/{provider}/init": {
      "get": {
        "summary": "Initialize OAuth2 flow (browser redirect)",
        "description": "Browser-facing endpoint for initiating OAuth flows. The user's browser navigates\nto this URL directly, which then redirects to the OAuth provider.\n\n**Note**: This endpoint uses GET with path parameters because it's a browser\nredirect flow, not a WebSocket-routed API call.\n",
        "operationId": "initOAuth",
        "tags": [
          "OAuth"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "provider",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/Provider"
            }
          },
          {
            "name": "redirectUri",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uri"
            }
          },
          {
            "name": "state",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "302": {
            "description": "Redirect to OAuth provider"
          }
        },
        "x-manual-implementation": true
      }
    },
    "/auth/oauth/{provider}/callback": {
      "post": {
        "summary": "Complete OAuth2 flow (browser redirect callback)",
        "description": "Browser-facing callback endpoint for OAuth providers. The OAuth provider redirects\nthe user's browser back to this URL after authentication.\n\n**Note**: This endpoint uses path parameters because the callback URL is registered\nwith OAuth providers and cannot be changed without updating provider configurations.\n",
        "operationId": "completeOAuth",
        "tags": [
          "OAuth"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "provider",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/Provider"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OAuthCallbackRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OAuth authentication successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/auth/steam/verify": {
      "post": {
        "summary": "Verify Steam Session Ticket",
        "description": "Validates a Steam Session Ticket obtained from the game client via ISteamUser::GetAuthTicketForWebApi().\nThe server validates the ticket with Steam's Web API and retrieves the SteamID from Steam's response.\nNEVER trust client-provided SteamID - it must come from Steam's authenticated response.\n",
        "operationId": "verifySteamAuth",
        "tags": [
          "Steam"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SteamVerifyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Steam authentication successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthResponse"
                }
              }
            }
          },
          "401": {
            "description": "Invalid or expired Steam ticket"
          },
          "500": {
            "description": "Steam API unavailable or internal error"
          }
        }
      }
    },
    "/auth/refresh": {
      "post": {
        "summary": "Refresh access token",
        "operationId": "refreshToken",
        "tags": [
          "Tokens"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "jwt",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Current JWT access token for refresh",
            "x-from-authorization": "bearer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RefreshRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Token refreshed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/auth/validate": {
      "post": {
        "summary": "Validate access token",
        "operationId": "validateToken",
        "tags": [
          "Tokens"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "jwt",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "JWT access token for validation",
            "x-from-authorization": "bearer"
          }
        ],
        "responses": {
          "200": {
            "description": "Token is valid",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidateTokenResponse"
                }
              }
            }
          },
          "401": {
            "description": "Invalid or missing token"
          },
          "403": {
            "description": "Token expired or malformed"
          }
        }
      }
    },
    "/auth/logout": {
      "post": {
        "summary": "Logout and invalidate tokens",
        "operationId": "logout",
        "tags": [
          "Authentication"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "jwt",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "JWT access token for session identification",
            "x-from-authorization": "bearer"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LogoutRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Logged out successfully"
          }
        }
      }
    },
    "/auth/sessions/list": {
      "post": {
        "summary": "Get active sessions for account",
        "operationId": "getSessions",
        "tags": [
          "Sessions"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "jwt",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "JWT access token for session identification",
            "x-from-authorization": "bearer"
          }
        ],
        "responses": {
          "200": {
            "description": "Active sessions retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SessionsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/auth/sessions/terminate": {
      "post": {
        "summary": "Terminate specific session",
        "operationId": "terminateSession",
        "tags": [
          "Sessions"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "jwt",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "JWT access token for session identification",
            "x-from-authorization": "bearer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TerminateSessionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Session terminated"
          },
          "404": {
            "description": "Session not found"
          }
        }
      }
    },
    "/auth/password/reset": {
      "post": {
        "summary": "Request password reset",
        "operationId": "requestPasswordReset",
        "tags": [
          "Password"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PasswordResetRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Reset email sent if account exists"
          }
        }
      }
    },
    "/auth/password/confirm": {
      "post": {
        "summary": "Confirm password reset with token",
        "operationId": "confirmPasswordReset",
        "tags": [
          "Password"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PasswordResetConfirmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Password reset successfully"
          }
        }
      }
    },
    "/auth/providers": {
      "post": {
        "summary": "List available authentication providers",
        "description": "Returns a list of available OAuth and authentication providers based on server configuration.\nProviders are only listed if their client credentials are configured.\nSteam authentication uses session tickets, not OAuth, but is included for completeness.\n",
        "operationId": "listProviders",
        "tags": [
          "Authentication"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "responses": {
          "200": {
            "description": "List of available providers",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProvidersResponse"
                }
              }
            }
          }
        }
      }
    },
    "/compile": {
      "post": {
        "summary": "Compile ABML behavior definition",
        "description": "Compiles a YAML-based ABML behavior definition into executable behavior trees.\nHandles stackable behavior sets, cultural adaptations, and context variable resolution.\n",
        "operationId": "CompileAbmlBehavior",
        "tags": [
          "ABML"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/yaml": {
              "schema": {
                "type": "string",
                "description": "Raw ABML YAML content"
              },
              "example": "version: \"1.0.0\"\nmetadata:\n  id: \"blacksmith_daily_routine\"\n  category: \"profession\"\n  priority: 60\n  description: \"Daily routine for a master blacksmith NPC\"\n\ncontext:\n  variables:\n    energy_level: \"${npc.stats.energy}\"\n    skill_level: \"${npc.skills.blacksmithing}\"\n    shop_reputation: \"${npc.reputation.local}\"\n\n  services:\n    - name: \"crafting_service\"\n      required: true\n    - name: \"economy_service\"\n      required: true\n\nbehaviors:\n  morning_startup:\n    triggers:\n      - time_range: \"06:00-09:00\"\n      - condition: \"${context.energy_level > 0.7}\"\n    actions:\n      - wake_up:\n          animation: \"stretch_and_yawn\"\n          duration: 3\n          energy_cost: -0.05\n"
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompileBehaviorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "ABML behavior compiled successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CompileBehaviorResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid ABML definition or compilation error"
          },
          "403": {
            "description": "Forbidden - insufficient permissions"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/validate": {
      "post": {
        "summary": "Validate ABML definition",
        "description": "Validates ABML YAML against schema and checks for semantic correctness.\nIncludes context variable validation and service dependency checking.\n",
        "operationId": "ValidateAbml",
        "tags": [
          "Validation"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/yaml": {
              "schema": {
                "type": "string",
                "description": "Raw ABML YAML content to validate"
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ValidateAbmlRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Validation completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidateAbmlResponse"
                }
              }
            }
          }
        }
      }
    },
    "/cache/get": {
      "post": {
        "summary": "Get cached compiled behavior",
        "description": "Retrieves a previously compiled behavior from the cache.\nUsed for performance optimization in high-frequency behavior execution.\n",
        "operationId": "GetCachedBehavior",
        "tags": [
          "Cache"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCachedBehaviorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cached behavior retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CachedBehaviorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Behavior not found in cache"
          }
        }
      }
    },
    "/cache/invalidate": {
      "post": {
        "summary": "Invalidate cached behavior",
        "description": "Removes a behavior from the cache, forcing recompilation on next access.\nUsed when behavior definitions are updated.\n",
        "operationId": "InvalidateCachedBehavior",
        "tags": [
          "Cache"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InvalidateCacheRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cache invalidated successfully"
          },
          "404": {
            "description": "Behavior not found in cache"
          }
        }
      }
    },
    "/goap/plan": {
      "post": {
        "summary": "Generate GOAP plan",
        "description": "Generates a GOAP plan to achieve a goal from the current world state.\nUses A* search to find the optimal sequence of actions.\n",
        "operationId": "GenerateGoapPlan",
        "tags": [
          "GOAP"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoapPlanRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Plan generated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GoapPlanResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or planning failed"
          }
        }
      }
    },
    "/goap/validate-plan": {
      "post": {
        "summary": "Validate existing GOAP plan",
        "description": "Validates an existing GOAP plan against the current world state.\nReturns whether the plan is still valid or needs replanning.\n",
        "operationId": "ValidateGoapPlan",
        "tags": [
          "GOAP"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ValidateGoapPlanRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Plan validation completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidateGoapPlanResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          }
        }
      }
    },
    "/character/get": {
      "post": {
        "summary": "Get character by ID",
        "operationId": "getCharacter",
        "tags": [
          "Character Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCharacterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Character retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CharacterResponse"
                }
              }
            }
          },
          "404": {
            "description": "Character not found"
          }
        }
      }
    },
    "/character/list": {
      "post": {
        "summary": "List characters with filtering",
        "operationId": "listCharacters",
        "tags": [
          "Character Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListCharactersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Characters retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CharacterListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character/get-enriched": {
      "post": {
        "summary": "Get character with optional related data (personality, backstory, family)",
        "description": "Retrieves a character with optional include flags for related data.\nUse this endpoint when you need aggregated character data from multiple services.\nEach included dataset is fetched from its respective service.\n",
        "operationId": "getEnrichedCharacter",
        "tags": [
          "Character Lookup"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEnrichedCharacterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Character retrieved with requested includes",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EnrichedCharacterResponse"
                }
              }
            }
          },
          "404": {
            "description": "Character not found"
          }
        }
      }
    },
    "/character/get-archive": {
      "post": {
        "summary": "Get compressed archive data for a character",
        "operationId": "getCharacterArchive",
        "tags": [
          "Character Compression"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCharacterArchiveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Archive retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CharacterArchive"
                }
              }
            }
          },
          "404": {
            "description": "Archive not found (character may not be compressed yet)"
          }
        }
      }
    },
    "/character/by-realm": {
      "post": {
        "summary": "Get all characters in a realm (primary query pattern)",
        "operationId": "getCharactersByRealm",
        "tags": [
          "Character Lookup"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCharactersByRealmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Characters retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CharacterListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-encounter/type/get": {
      "post": {
        "summary": "Get encounter type by code",
        "operationId": "getEncounterType",
        "tags": [
          "Encounter Type Management"
        ],
        "description": "Retrieve an encounter type by its unique code.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEncounterTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounter type retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EncounterTypeResponse"
                }
              }
            }
          },
          "404": {
            "description": "Encounter type not found"
          }
        }
      }
    },
    "/character-encounter/type/list": {
      "post": {
        "summary": "List all encounter types",
        "operationId": "listEncounterTypes",
        "tags": [
          "Encounter Type Management"
        ],
        "description": "Retrieve all encounter types including built-in and custom types.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListEncounterTypesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounter types retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EncounterTypeListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-encounter/query/by-character": {
      "post": {
        "summary": "Get character's encounters (paginated)",
        "operationId": "queryByCharacter",
        "tags": [
          "Queries"
        ],
        "description": "Retrieves all encounters for a character with optional filtering.\nMemory decay is applied lazily on access.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryByCharacterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounters retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EncounterListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-encounter/query/between": {
      "post": {
        "summary": "Get encounters between two characters",
        "operationId": "queryBetween",
        "tags": [
          "Queries"
        ],
        "description": "Retrieves all encounters between two specific characters.\nUseful for relationship history and dialogue context.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryBetweenRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounters retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EncounterListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-encounter/query/by-location": {
      "post": {
        "summary": "Recent encounters at location",
        "operationId": "queryByLocation",
        "tags": [
          "Queries"
        ],
        "description": "Retrieves recent encounters at a specific location.\nUseful for scene context and area history.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryByLocationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounters retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EncounterListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-encounter/has-met": {
      "post": {
        "summary": "Quick check if two characters have met",
        "operationId": "hasMet",
        "tags": [
          "Queries"
        ],
        "description": "Fast boolean check for whether two characters have any recorded encounters.\nDoes not apply memory decay or return encounter details.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HasMetRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Check completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HasMetResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-encounter/get-sentiment": {
      "post": {
        "summary": "Aggregate sentiment toward another character",
        "operationId": "getSentiment",
        "tags": [
          "Queries"
        ],
        "description": "Calculates the aggregate sentiment a character has toward another based\non all their encounters. Memory strength is factored into the calculation.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSentimentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Sentiment calculated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SentimentResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-encounter/get-perspective": {
      "post": {
        "summary": "Get character's view of encounter",
        "operationId": "getPerspective",
        "tags": [
          "Perspectives"
        ],
        "description": "Retrieves a specific character's perspective on an encounter.\nIncludes emotional impact, sentiment shift, and memory strength.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetPerspectiveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Perspective retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PerspectiveResponse"
                }
              }
            }
          },
          "404": {
            "description": "Perspective not found"
          }
        }
      }
    },
    "/character-history/get-participation": {
      "post": {
        "summary": "Get all historical events a character participated in",
        "operationId": "getParticipation",
        "tags": [
          "Historical Events"
        ],
        "description": "Retrieves all historical event participation records for a character.\nSupports filtering by event category and minimum significance.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetParticipationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Participation records retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ParticipationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-history/get-event-participants": {
      "post": {
        "summary": "Get all characters who participated in a historical event",
        "operationId": "getEventParticipants",
        "tags": [
          "Historical Events"
        ],
        "description": "Retrieves all characters who participated in a specific historical event.\nUseful for generating event summaries or finding related characters.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEventParticipantsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Participants retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ParticipationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-history/get-backstory": {
      "post": {
        "summary": "Get machine-readable backstory elements for behavior system",
        "operationId": "getBackstory",
        "tags": [
          "Backstory"
        ],
        "description": "Retrieves structured backstory elements for a character. These elements\nare machine-readable key-value pairs used by the behavior system for\ndecision-making, not narrative text for players.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetBackstoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Backstory retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackstoryResponse"
                }
              }
            }
          },
          "404": {
            "description": "No backstory defined for this character"
          }
        }
      }
    },
    "/character-personality/get": {
      "post": {
        "summary": "Get personality for a character",
        "operationId": "getPersonality",
        "tags": [
          "Personality Management"
        ],
        "description": "Retrieves the personality profile for a character. Returns 404 if no\npersonality has been defined for this character.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetPersonalityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Personality retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PersonalityResponse"
                }
              }
            }
          },
          "404": {
            "description": "No personality defined for this character"
          }
        }
      }
    },
    "/character-personality/get-combat": {
      "post": {
        "summary": "Get combat preferences for a character",
        "operationId": "getCombatPreferences",
        "tags": [
          "Combat Preferences"
        ],
        "description": "Retrieves the combat preferences for a character. Combat preferences\ninfluence tactical decisions in the behavior system, including engagement\nstyle, positioning, and retreat conditions.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCombatPreferencesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Combat preferences retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CombatPreferencesResponse"
                }
              }
            }
          },
          "404": {
            "description": "No combat preferences defined for this character"
          }
        }
      }
    },
    "/client-capabilities": {
      "post": {
        "summary": "Get client capability manifest (GUID \u2192 API mappings)",
        "operationId": "getClientCapabilities",
        "tags": [
          "Client Capabilities"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "description": "Returns the capability manifest for the authenticated client's session.\nMaps client-salted GUIDs to available API endpoints based on the client's\ncurrent permissions and session state.\n\n**Security**: Each client receives unique GUIDs for the same API endpoints.\nThis prevents cross-session exploitation and enables per-client rate limiting.\n\n**Dynamic Updates**: Capabilities may change during a session when:\n- Role changes occur (admin promotion, etc.)\n- Subscription status changes\n- Session state transitions\n\nClients should listen for capability update events via WebSocket to stay current.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetClientCapabilitiesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Client capabilities retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClientCapabilitiesResponse"
                }
              }
            }
          },
          "401": {
            "description": "Not authenticated - requires valid session"
          },
          "500": {
            "description": "Error retrieving capabilities"
          }
        }
      }
    },
    "/contract/template/get": {
      "post": {
        "operationId": "getContractTemplate",
        "tags": [
          "Templates"
        ],
        "summary": "Get template by ID or code",
        "description": "Retrieves a contract template by its unique ID or code.\nAt least one of templateId or code must be provided.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetContractTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Neither templateId nor code provided"
          },
          "404": {
            "description": "Template not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/template/list": {
      "post": {
        "operationId": "listContractTemplates",
        "tags": [
          "Templates"
        ],
        "summary": "List templates with filters",
        "description": "Lists contract templates with optional filtering by realm, active status,\nand search term.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListContractTemplatesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Templates retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListContractTemplatesResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/create": {
      "post": {
        "operationId": "createContractInstance",
        "tags": [
          "Instances"
        ],
        "summary": "Create contract instance from template",
        "description": "Creates a new contract instance from a template. The instance starts\nin 'draft' status and must be proposed to parties before activation.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateContractInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Instance created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (missing required parties, invalid terms)"
          },
          "404": {
            "description": "Template not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/propose": {
      "post": {
        "operationId": "proposeContractInstance",
        "tags": [
          "Instances"
        ],
        "summary": "Propose contract to parties (starts consent flow)",
        "description": "Moves a draft contract to 'proposed' status and notifies parties.\nParties must consent before the contract becomes active.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProposeContractInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Contract proposed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Contract not in draft status"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/consent": {
      "post": {
        "operationId": "consentToContract",
        "tags": [
          "Instances"
        ],
        "summary": "Party consents to contract",
        "description": "Records a party's consent to a proposed contract. When all required\nparties consent, the contract moves to 'accepted' then 'active' status.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConsentToContractRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Consent recorded successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Party not part of this contract or already consented"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/get": {
      "post": {
        "operationId": "getContractInstance",
        "tags": [
          "Instances"
        ],
        "summary": "Get instance by ID",
        "description": "Retrieves a contract instance by its unique ID.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetContractInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Instance retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractInstanceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Instance not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/query": {
      "post": {
        "operationId": "queryContractInstances",
        "tags": [
          "Instances"
        ],
        "summary": "Query instances by party, template, status",
        "description": "Queries contract instances with various filters. At least one filter\nmust be provided.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryContractInstancesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Instances retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryContractInstancesResponse"
                }
              }
            }
          },
          "400": {
            "description": "No filter criteria provided"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/terminate": {
      "post": {
        "operationId": "terminateContractInstance",
        "tags": [
          "Instances"
        ],
        "summary": "Request early termination",
        "description": "Requests early termination of an active contract. Depending on the\ncontract's termination policy, this may require mutual consent or\nincur penalties.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TerminateContractInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Termination processed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Contract cannot be terminated (policy violation)"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/get-status": {
      "post": {
        "operationId": "getContractInstanceStatus",
        "tags": [
          "Instances"
        ],
        "summary": "Get current status and milestone progress",
        "description": "Gets the current status of a contract including milestone progress,\npending consents, and any active breaches.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetContractInstanceStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Status retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractInstanceStatusResponse"
                }
              }
            }
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/milestone/complete": {
      "post": {
        "operationId": "completeMilestone",
        "tags": [
          "Milestones"
        ],
        "summary": "External system reports milestone completed",
        "description": "Called by external systems to report that a milestone's conditions\nhave been met. Triggers onComplete prebound APIs and may advance\ncontract status.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompleteMilestoneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Milestone completed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MilestoneResponse"
                }
              }
            }
          },
          "400": {
            "description": "Milestone not in valid state for completion"
          },
          "404": {
            "description": "Contract or milestone not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/milestone/fail": {
      "post": {
        "operationId": "failMilestone",
        "tags": [
          "Milestones"
        ],
        "summary": "External system reports milestone failed",
        "description": "Called by external systems to report that a milestone has failed\n(e.g., deadline passed, conditions cannot be met). Triggers onExpire\nprebound APIs and may record a breach.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FailMilestoneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Milestone failure recorded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MilestoneResponse"
                }
              }
            }
          },
          "400": {
            "description": "Milestone not in valid state for failure"
          },
          "404": {
            "description": "Contract or milestone not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/milestone/get": {
      "post": {
        "operationId": "getMilestone",
        "tags": [
          "Milestones"
        ],
        "summary": "Get milestone details and status",
        "description": "Gets the current state of a specific milestone.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetMilestoneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Milestone retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MilestoneResponse"
                }
              }
            }
          },
          "404": {
            "description": "Contract or milestone not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/breach/report": {
      "post": {
        "operationId": "reportBreach",
        "tags": [
          "Breaches"
        ],
        "summary": "Report a contract breach",
        "description": "Reports a breach of contract terms. This can be called by parties\nor external systems. The breach enters a grace period for cure\nif configured.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReportBreachRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Breach reported successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BreachResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid breach report"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/breach/cure": {
      "post": {
        "operationId": "cureBreach",
        "tags": [
          "Breaches"
        ],
        "summary": "Mark breach as cured (system/admin action)",
        "description": "Marks a breach as cured within the grace period. This prevents\nconsequences from being applied. Called by systems that verify\nthe breach has been remedied.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CureBreachRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Breach cured successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BreachResponse"
                }
              }
            }
          },
          "400": {
            "description": "Breach not in curable state"
          },
          "404": {
            "description": "Breach not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/breach/get": {
      "post": {
        "operationId": "getBreach",
        "tags": [
          "Breaches"
        ],
        "summary": "Get breach details",
        "description": "Retrieves details of a specific breach record.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetBreachRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Breach retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BreachResponse"
                }
              }
            }
          },
          "404": {
            "description": "Breach not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/metadata/update": {
      "post": {
        "operationId": "updateContractMetadata",
        "tags": [
          "Metadata"
        ],
        "summary": "Update game metadata on instance",
        "description": "Updates game-specific metadata on a contract instance without\ntouching contract state. Used by higher-level systems (quests, etc.)\nto store additional context.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateContractMetadataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Metadata updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractMetadataResponse"
                }
              }
            }
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/metadata/get": {
      "post": {
        "operationId": "getContractMetadata",
        "tags": [
          "Metadata"
        ],
        "summary": "Get game metadata",
        "description": "Retrieves game-specific metadata from a contract instance.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetContractMetadataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Metadata retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractMetadataResponse"
                }
              }
            }
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/check-constraint": {
      "post": {
        "operationId": "checkContractConstraint",
        "tags": [
          "Constraints"
        ],
        "summary": "Check if entity can take action given contracts",
        "description": "Checks whether an entity's proposed action would violate any\nactive contract constraints (exclusivity, non-compete, territory, etc.).\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CheckConstraintRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Constraint check completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckConstraintResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/query-active": {
      "post": {
        "operationId": "queryActiveContracts",
        "tags": [
          "Constraints"
        ],
        "summary": "Query active contracts for entity",
        "description": "Returns all active contracts where the specified entity is a party.\nUseful for displaying current obligations in UI.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryActiveContractsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Active contracts retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryActiveContractsResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/lock": {
      "post": {
        "operationId": "lockContract",
        "tags": [
          "Guardian"
        ],
        "summary": "Lock contract under guardian custody",
        "description": "Locks a contract under guardian custody (e.g., escrow). A locked contract\ncannot be modified, terminated, or have parties transferred except by the\nguardian. Requires the contract template to have `transferable: true`.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LockContractRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Contract locked successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LockContractResponse"
                }
              }
            }
          },
          "400": {
            "description": "Contract not transferable"
          },
          "404": {
            "description": "Contract not found"
          },
          "409": {
            "description": "Contract already locked"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/unlock": {
      "post": {
        "operationId": "unlockContract",
        "tags": [
          "Guardian"
        ],
        "summary": "Unlock contract from guardian custody",
        "description": "Unlocks a contract from guardian custody. Only the current guardian can\nunlock a contract. Called on escrow refund to restore contract to original state.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnlockContractRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Contract unlocked successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnlockContractResponse"
                }
              }
            }
          },
          "403": {
            "description": "Not the current guardian"
          },
          "404": {
            "description": "Contract not found or not locked"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/transfer-party": {
      "post": {
        "operationId": "transferContractParty",
        "tags": [
          "Guardian"
        ],
        "summary": "Transfer party role to new entity",
        "description": "Transfers a party role to a new entity. Used by escrow to reassign contract\nroles on release (e.g., transfer landlord role to new property owner).\nContract must be locked and caller must be the guardian.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransferContractPartyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Party transferred successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransferContractPartyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Party not found in contract"
          },
          "403": {
            "description": "Not the current guardian or contract not locked"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/clause-type/list": {
      "post": {
        "operationId": "listClauseTypes",
        "tags": [
          "ClauseTypes"
        ],
        "summary": "List all registered clause types",
        "description": "Lists all registered clause types including built-in types and\ncustom-registered types.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListClauseTypesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Clause types listed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListClauseTypesResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/set-template-values": {
      "post": {
        "operationId": "setContractTemplateValues",
        "tags": [
          "Execution"
        ],
        "summary": "Set template values on contract instance",
        "description": "Sets template values on a contract instance. Called by escrow when binding\na contract to an escrow agreement. Template values are used for variable\nsubstitution in clause handlers (e.g., wallet IDs, container IDs).\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetTemplateValuesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template values set successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SetTemplateValuesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid template key format"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/check-asset-requirements": {
      "post": {
        "operationId": "checkAssetRequirements",
        "tags": [
          "Execution"
        ],
        "summary": "Check if asset requirement clauses are satisfied",
        "description": "Checks if all asset requirement clauses are satisfied. Uses template values\n(e.g., PartyA_EscrowWalletId) to query actual balances in escrow wallets/containers\nvia the registered clause type handlers.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CheckAssetRequirementsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Asset requirements checked",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckAssetRequirementsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Template values not set"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/execute": {
      "post": {
        "operationId": "executeContract",
        "tags": [
          "Execution"
        ],
        "summary": "Execute all contract clauses (idempotent)",
        "description": "Executes all contract distribution clauses - distribute assets per clauses,\ncollect fees, mark contract as executed. This is idempotent - calling twice\nreturns the same result without re-executing. Contract must be in fulfilled\nstatus and all template values must be set.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteContractRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Contract executed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExecuteContractResponse"
                }
              }
            }
          },
          "400": {
            "description": "Contract not in fulfilled status or template values missing"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/definition/get": {
      "post": {
        "operationId": "getCurrencyDefinition",
        "tags": [
          "Currency Definition"
        ],
        "summary": "Get currency definition by ID or code",
        "description": "Retrieves a currency definition by its unique ID or code.\nAt least one of definitionId or code must be provided.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCurrencyDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Currency definition retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CurrencyDefinitionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Neither definitionId nor code provided"
          },
          "404": {
            "description": "Currency definition not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/definition/list": {
      "post": {
        "operationId": "listCurrencyDefinitions",
        "tags": [
          "Currency Definition"
        ],
        "summary": "List currency definitions with filters",
        "description": "Lists currency definitions with optional filtering by realm, scope,\nactive status, and base currency flag.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListCurrencyDefinitionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Currency definitions retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListCurrencyDefinitionsResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/wallet/create": {
      "post": {
        "operationId": "createWallet",
        "tags": [
          "Wallet"
        ],
        "summary": "Create a new wallet for an owner",
        "description": "Creates a new wallet for a polymorphic owner (account, character, NPC, guild, etc.).\nEach owner+ownerType+realm combination can have at most one wallet.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateWalletRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Wallet created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WalletResponse"
                }
              }
            }
          },
          "409": {
            "description": "Wallet already exists for this owner/realm"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/wallet/get": {
      "post": {
        "operationId": "getWallet",
        "tags": [
          "Wallet"
        ],
        "summary": "Get wallet by ID or owner",
        "description": "Retrieves a wallet by its ID, or by owner+ownerType+realm combination.\nReturns the wallet with all non-zero balances.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetWalletRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Wallet retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WalletWithBalancesResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/wallet/get-or-create": {
      "post": {
        "operationId": "getOrCreateWallet",
        "tags": [
          "Wallet"
        ],
        "summary": "Get existing wallet or create if not exists",
        "description": "Retrieves a wallet if it exists, otherwise creates a new one.\nUpsert pattern for convenience.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetOrCreateWalletRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Wallet retrieved or created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetOrCreateWalletResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/balance/get": {
      "post": {
        "operationId": "getBalance",
        "tags": [
          "Balance"
        ],
        "summary": "Get balance for a specific currency in a wallet",
        "description": "Retrieves the current balance for a specific currency in a wallet.\nIn lazy autogain mode, this may trigger autogain calculation and emit events.\nReturns earn cap info and autogain info when applicable.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetBalanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Balance retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetBalanceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet or currency not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/balance/batch-get": {
      "post": {
        "operationId": "batchGetBalances",
        "tags": [
          "Balance"
        ],
        "summary": "Get multiple balances in one call",
        "description": "Retrieves balances for multiple wallet+currency combinations.\nAutogain is applied where applicable.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchGetBalancesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Balances retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchGetBalancesResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/credit": {
      "post": {
        "operationId": "creditCurrency",
        "tags": [
          "Balance"
        ],
        "summary": "Credit currency to a wallet (faucet operation)",
        "description": "Credits currency to a wallet. This is a faucet operation (currency enters the system).\nEnforces earn caps, wallet caps, and global supply caps. Requires idempotency key.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreditCurrencyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Currency credited successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreditCurrencyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid transaction type or amount"
          },
          "404": {
            "description": "Wallet or currency not found"
          },
          "409": {
            "description": "Idempotency key already used"
          },
          "422": {
            "description": "Earn cap or supply cap exceeded"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/debit": {
      "post": {
        "operationId": "debitCurrency",
        "tags": [
          "Balance"
        ],
        "summary": "Debit currency from a wallet (sink operation)",
        "description": "Debits currency from a wallet. This is a sink operation (currency exits the system).\nChecks for sufficient funds unless negative balance is allowed.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DebitCurrencyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Currency debited successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DebitCurrencyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid transaction type or amount"
          },
          "404": {
            "description": "Wallet or currency not found"
          },
          "422": {
            "description": "Insufficient funds"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/transfer": {
      "post": {
        "operationId": "transferCurrency",
        "tags": [
          "Balance"
        ],
        "summary": "Transfer currency between wallets",
        "description": "Transfers currency from one wallet to another. Validates transferability,\nrealm compatibility, and sufficient funds.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransferCurrencyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transfer completed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransferCurrencyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or currency not transferable"
          },
          "404": {
            "description": "Wallet or currency not found"
          },
          "422": {
            "description": "Insufficient funds or cross-realm not allowed"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/batch-credit": {
      "post": {
        "operationId": "batchCreditCurrency",
        "tags": [
          "Balance"
        ],
        "summary": "Credit multiple wallets in one call",
        "description": "Credits currency to multiple wallets in one call. Each operation is independent;\nfailures do not rollback others. For atomic multi-wallet operations, use lib-escrow.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchCreditRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Batch credit processed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchCreditResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/convert/calculate": {
      "post": {
        "operationId": "calculateConversion",
        "tags": [
          "Conversion"
        ],
        "summary": "Calculate conversion without executing",
        "description": "Previews a currency conversion calculation without executing it.\nUses base currency exchange rates to compute the effective rate.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CalculateConversionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Conversion calculated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CalculateConversionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Currency not found"
          },
          "422": {
            "description": "No base currency or missing exchange rate"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/convert/execute": {
      "post": {
        "operationId": "executeConversion",
        "tags": [
          "Conversion"
        ],
        "summary": "Execute currency conversion in a wallet",
        "description": "Executes a currency conversion within a single wallet. Debits the source\ncurrency and credits the target currency at the computed exchange rate.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteConversionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Conversion executed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExecuteConversionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet or currency not found"
          },
          "422": {
            "description": "Insufficient funds or missing exchange rate"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/exchange-rate/get": {
      "post": {
        "operationId": "getExchangeRate",
        "tags": [
          "Conversion"
        ],
        "summary": "Get exchange rate between two currencies",
        "description": "Retrieves the exchange rate between two currencies using the base currency\nas an intermediary.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetExchangeRateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Exchange rate retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetExchangeRateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Currency not found"
          },
          "422": {
            "description": "No base currency or missing exchange rate"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/transaction/get": {
      "post": {
        "operationId": "getTransaction",
        "tags": [
          "Transaction History"
        ],
        "summary": "Get a transaction by ID",
        "description": "Retrieves a single transaction record by its unique ID.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetTransactionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transaction retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Transaction not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/transaction/history": {
      "post": {
        "operationId": "getTransactionHistory",
        "tags": [
          "Transaction History"
        ],
        "summary": "Get paginated transaction history for a wallet",
        "description": "Retrieves transaction history for a wallet with optional filters\nby currency, transaction type, and date range.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetTransactionHistoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transaction history retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetTransactionHistoryResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/transaction/by-reference": {
      "post": {
        "operationId": "getTransactionsByReference",
        "tags": [
          "Transaction History"
        ],
        "summary": "Get transactions by reference type and ID",
        "description": "Retrieves all transactions linked to a specific reference (quest, auction,\nescrow, etc.).\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetTransactionsByReferenceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transactions retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetTransactionsByReferenceResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/stats/global-supply": {
      "post": {
        "operationId": "getGlobalSupply",
        "tags": [
          "Analytics"
        ],
        "summary": "Get global supply statistics for a currency",
        "description": "Returns aggregate supply statistics including total supply, circulation,\nescrow amounts, and lifetime mint/burn totals.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetGlobalSupplyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Supply statistics retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetGlobalSupplyResponse"
                }
              }
            }
          },
          "404": {
            "description": "Currency not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/escrow/deposit": {
      "post": {
        "operationId": "escrowDeposit",
        "tags": [
          "Escrow Integration"
        ],
        "summary": "Debit wallet for escrow deposit",
        "description": "Called by lib-escrow when a party deposits currency into an escrow agreement.\nImmediately debits the wallet (no lock tracking needed - escrow owns the funds).\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EscrowDepositRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Escrow deposit processed (wallet debited)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowDepositResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet or currency not found"
          },
          "422": {
            "description": "Insufficient funds or wallet frozen"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/escrow/release": {
      "post": {
        "operationId": "escrowRelease",
        "tags": [
          "Escrow Integration"
        ],
        "summary": "Credit recipient on escrow completion",
        "description": "Called by lib-escrow when an escrow agreement completes successfully.\nCredits the recipient wallet with the released funds.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EscrowReleaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Escrow release processed (recipient credited)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowReleaseResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet or currency not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/escrow/refund": {
      "post": {
        "operationId": "escrowRefund",
        "tags": [
          "Escrow Integration"
        ],
        "summary": "Credit depositor on escrow refund",
        "description": "Called by lib-escrow when an escrow agreement is cancelled or refunded.\nCredits the original depositor wallet with the refunded funds.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EscrowRefundRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Escrow refund processed (depositor credited)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowRefundResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet or currency not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/hold/create": {
      "post": {
        "operationId": "createHold",
        "tags": [
          "Authorization Hold"
        ],
        "summary": "Create an authorization hold (reserve funds)",
        "description": "Creates an authorization hold that reserves funds without debiting.\nThe held amount reduces the effective balance but does not leave the wallet.\nUsed for pre-auth scenarios (dining, gas, hotels) where final amount may differ.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateHoldRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Hold created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HoldResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet or currency not found"
          },
          "422": {
            "description": "Insufficient effective balance for hold"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/hold/capture": {
      "post": {
        "operationId": "captureHold",
        "tags": [
          "Authorization Hold"
        ],
        "summary": "Capture held funds (debit final amount)",
        "description": "Captures an active hold by debiting the final amount (which may be less than\nor equal to the held amount). Any difference is released back to available balance.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CaptureHoldRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Hold captured successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CaptureHoldResponse"
                }
              }
            }
          },
          "400": {
            "description": "Hold is not in active status or capture amount exceeds hold"
          },
          "404": {
            "description": "Hold not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/hold/release": {
      "post": {
        "operationId": "releaseHold",
        "tags": [
          "Authorization Hold"
        ],
        "summary": "Release held funds (make available again)",
        "description": "Releases an active hold, making all held funds available again.\nNo debit occurs.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReleaseHoldRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Hold released successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HoldResponse"
                }
              }
            }
          },
          "400": {
            "description": "Hold is not in active status"
          },
          "404": {
            "description": "Hold not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/hold/get": {
      "post": {
        "operationId": "getHold",
        "tags": [
          "Authorization Hold"
        ],
        "summary": "Get hold status and details",
        "description": "Retrieves the current status and details of an authorization hold.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetHoldRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Hold retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HoldResponse"
                }
              }
            }
          },
          "404": {
            "description": "Hold not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/documentation/query": {
      "post": {
        "operationId": "queryDocumentation",
        "summary": "Natural language documentation search",
        "description": "Search documentation using natural language queries.\nReturns the most relevant documents with voice-friendly summaries.\n",
        "tags": [
          "Search"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryDocumentationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Search results with voice-friendly summaries",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDocumentationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/documentation/get": {
      "post": {
        "operationId": "getDocument",
        "summary": "Get specific document by ID or slug",
        "description": "Retrieve a specific document by its unique identifier or slug.\nReturns full content with metadata.\n",
        "tags": [
          "Documents"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetDocumentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Document content",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetDocumentResponse"
                }
              }
            }
          },
          "404": {
            "description": "Document not found"
          }
        }
      }
    },
    "/documentation/search": {
      "post": {
        "operationId": "searchDocumentation",
        "summary": "Full-text keyword search",
        "description": "Search documentation using exact keyword matching.\nFaster than semantic search but less flexible.\n",
        "tags": [
          "Search"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchDocumentationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Matching documents",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchDocumentationResponse"
                }
              }
            }
          }
        }
      }
    },
    "/documentation/list": {
      "post": {
        "operationId": "listDocuments",
        "summary": "List documents by category",
        "description": "List all documents in a specific category or all categories.\nSupports pagination for large result sets.\n",
        "tags": [
          "Documents"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListDocumentsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Document list",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListDocumentsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/documentation/suggest": {
      "post": {
        "operationId": "suggestRelatedTopics",
        "summary": "Get related topics and follow-up suggestions",
        "description": "Given a topic or document ID, returns related topics the user\nmight want to explore. Useful for conversational AI flow.\n",
        "tags": [
          "Search"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SuggestRelatedRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Related topics",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuggestRelatedResponse"
                }
              }
            }
          }
        }
      }
    },
    "/documentation/repo/bind": {
      "post": {
        "operationId": "bindRepository",
        "summary": "Bind a git repository to a documentation namespace",
        "description": "Bind a git repository URL to a documentation namespace.\nThe namespace will be exclusively managed by the repository - manual edits will be blocked.\nTriggers initial sync after binding.\n",
        "tags": [
          "Repository"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BindRepositoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Repository binding created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BindRepositoryResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (malformed URL, invalid branch)"
          },
          "409": {
            "description": "Namespace already bound to a repository"
          }
        }
      }
    },
    "/documentation/repo/sync": {
      "post": {
        "operationId": "syncRepository",
        "summary": "Manually trigger repository sync",
        "description": "Manually trigger synchronization of a bound repository.\nIf force=true, performs full re-sync regardless of commit hash.\n",
        "tags": [
          "Repository"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SyncRepositoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Sync completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyncRepositoryResponse"
                }
              }
            }
          },
          "404": {
            "description": "No binding found for namespace"
          },
          "409": {
            "description": "Sync already in progress"
          }
        }
      }
    },
    "/documentation/repo/status": {
      "post": {
        "operationId": "getRepositoryStatus",
        "summary": "Get repository binding status",
        "description": "Get current status of a repository binding including sync state and statistics.\n",
        "tags": [
          "Repository"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RepositoryStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Repository binding status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RepositoryStatusResponse"
                }
              }
            }
          },
          "404": {
            "description": "No binding found for namespace"
          }
        }
      }
    },
    "/documentation/repo/list": {
      "post": {
        "operationId": "listRepositoryBindings",
        "summary": "List all repository bindings",
        "description": "List all repository bindings with optional filtering by status.\n",
        "tags": [
          "Repository"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRepositoryBindingsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of repository bindings",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListRepositoryBindingsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/documentation/repo/update": {
      "post": {
        "operationId": "updateRepositoryBinding",
        "summary": "Update repository binding configuration",
        "description": "Update sync settings, file patterns, category mappings, or archive configuration.\n",
        "tags": [
          "Repository"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateRepositoryBindingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Repository binding updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateRepositoryBindingResponse"
                }
              }
            }
          },
          "404": {
            "description": "No binding found for namespace"
          }
        }
      }
    },
    "/documentation/repo/archive/create": {
      "post": {
        "operationId": "createDocumentationArchive",
        "summary": "Create documentation archive",
        "description": "Create a .bannou bundle archive of all documents in a namespace.\nArchives are stored via Asset Service.\n",
        "tags": [
          "Archive"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateArchiveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Archive created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateArchiveResponse"
                }
              }
            }
          },
          "404": {
            "description": "Namespace not found"
          }
        }
      }
    },
    "/documentation/repo/archive/list": {
      "post": {
        "operationId": "listDocumentationArchives",
        "summary": "List documentation archives",
        "description": "List all archives for a namespace.\n",
        "tags": [
          "Archive"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListArchivesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of archives",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListArchivesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/create": {
      "post": {
        "operationId": "createEscrow",
        "tags": [
          "Lifecycle"
        ],
        "summary": "Create a new escrow agreement",
        "description": "Create a new escrow agreement. For each party, creates a dedicated escrow wallet\nand container (owned by escrow entity). Issues deposit tokens and returns ALL\ntokens to the creating service, which is responsible for distributing them to\nparties through appropriate channels. Sets template values on bound contract.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateEscrowRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Escrow created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateEscrowResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/get": {
      "post": {
        "operationId": "getEscrow",
        "tags": [
          "Lifecycle"
        ],
        "summary": "Get escrow details",
        "description": "Get escrow agreement details by ID.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEscrowRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Escrow details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetEscrowResponse"
                }
              }
            }
          },
          "404": {
            "description": "Escrow not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/list": {
      "post": {
        "operationId": "listEscrows",
        "tags": [
          "Lifecycle"
        ],
        "summary": "List escrows for a party",
        "description": "List escrow agreements with filtering options.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListEscrowsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of escrows",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListEscrowsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/deposit": {
      "post": {
        "operationId": "deposit",
        "tags": [
          "Deposits"
        ],
        "summary": "Deposit assets into escrow",
        "description": "Deposit assets into escrow. Transfers currency from party's own wallet to that\nparty's escrow wallet. Moves items from party's own container to that party's\nescrow container. Locks contracts with escrow as guardian.\nRejects soulbound/non-tradeable items. After each deposit, queries bound contract\nto check if all asset requirements are satisfied.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DepositRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Deposit successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepositResponse"
                }
              }
            }
          },
          "400": {
            "description": "Deposit failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/deposit/validate": {
      "post": {
        "operationId": "validateDeposit",
        "tags": [
          "Deposits"
        ],
        "summary": "Validate a deposit without executing",
        "description": "Validate a deposit without executing (dry run).",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ValidateDepositRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Validation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidateDepositResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/deposit/status": {
      "post": {
        "operationId": "getDepositStatus",
        "tags": [
          "Deposits"
        ],
        "summary": "Get deposit status for a party",
        "description": "Get deposit status for a party in an escrow.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetDepositStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Deposit status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetDepositStatusResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/consent": {
      "post": {
        "operationId": "recordConsent",
        "tags": [
          "Consent"
        ],
        "summary": "Record party consent",
        "description": "Record party consent for release, refund, or re-affirmation.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConsentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Consent recorded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConsentResponse"
                }
              }
            }
          },
          "400": {
            "description": "Consent failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/consent/status": {
      "post": {
        "operationId": "getConsentStatus",
        "tags": [
          "Consent"
        ],
        "summary": "Get consent status for escrow",
        "description": "Get consent status for all parties in an escrow.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetConsentStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Consent status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetConsentStatusResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/release": {
      "post": {
        "operationId": "release",
        "tags": [
          "Completion"
        ],
        "summary": "Trigger release",
        "description": "Trigger release (for trusted modes or after consent).\nIf boundContractId is set, checks contract status first (must be fulfilled).\nRuns finalization flow before releasing remaining assets.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReleaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Release result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReleaseResponse"
                }
              }
            }
          },
          "400": {
            "description": "Release failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/refund": {
      "post": {
        "operationId": "refund",
        "tags": [
          "Completion"
        ],
        "summary": "Trigger refund",
        "description": "Trigger refund (for trusted modes or consent).",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RefundRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Refund result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RefundResponse"
                }
              }
            }
          },
          "400": {
            "description": "Refund failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/cancel": {
      "post": {
        "operationId": "cancel",
        "tags": [
          "Completion"
        ],
        "summary": "Cancel escrow before fully funded",
        "description": "Cancel escrow before fully funded, refunding any deposits.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CancelRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cancel result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CancelResponse"
                }
              }
            }
          },
          "400": {
            "description": "Cancel failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/dispute": {
      "post": {
        "operationId": "dispute",
        "tags": [
          "Completion"
        ],
        "summary": "Raise a dispute on funded escrow",
        "description": "Raise a dispute on a funded escrow.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DisputeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Dispute raised",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DisputeResponse"
                }
              }
            }
          },
          "400": {
            "description": "Dispute failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/resolve": {
      "post": {
        "operationId": "resolve",
        "tags": [
          "Arbiter"
        ],
        "summary": "Arbiter resolves disputed escrow",
        "description": "Arbiter resolves a disputed escrow.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResolveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Resolution result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResolveResponse"
                }
              }
            }
          },
          "400": {
            "description": "Resolution failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/verify-condition": {
      "post": {
        "operationId": "verifyCondition",
        "tags": [
          "Condition"
        ],
        "summary": "Verify condition for conditional escrow",
        "description": "Verify condition for conditional escrow (non-contract path).\nFor escrows with boundContractId, use contract milestones instead.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VerifyConditionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Verification result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VerifyConditionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Verification failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/reaffirm": {
      "post": {
        "operationId": "reaffirm",
        "tags": [
          "Validation"
        ],
        "summary": "Re-affirm after validation failure",
        "description": "Re-affirm after validation failure (party accepts changed state).",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReaffirmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Reaffirmation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReaffirmResponse"
                }
              }
            }
          },
          "400": {
            "description": "Reaffirmation failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/game-service/services/list": {
      "post": {
        "summary": "List all registered game services",
        "description": "Returns all game services, optionally filtered by active status.",
        "operationId": "listServices",
        "tags": [
          "Game Service Registry"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListServicesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Services retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListServicesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/game-service/services/get": {
      "post": {
        "summary": "Get service by ID or stub name",
        "description": "Retrieves a single service by either serviceId (GUID) or stubName.",
        "operationId": "getService",
        "tags": [
          "Game Service Registry"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetServiceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Service retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceInfo"
                }
              }
            }
          },
          "404": {
            "description": "Service not found"
          }
        }
      }
    },
    "/sessions/get": {
      "post": {
        "summary": "Get game session details",
        "description": "Get details of the current game session the user has joined.",
        "operationId": "getGameSession",
        "tags": [
          "Game Sessions"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "game-session": "in_game"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetGameSessionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Game session retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GameSessionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Game session not found"
          }
        }
      }
    },
    "/sessions/leave": {
      "post": {
        "summary": "Leave a game session",
        "operationId": "leaveGameSession",
        "tags": [
          "Game Sessions"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "game-session": "in_game"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LeaveGameSessionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successfully left game session"
          },
          "404": {
            "description": "Game session not found"
          }
        }
      }
    },
    "/sessions/chat": {
      "post": {
        "summary": "Send chat message to game session",
        "operationId": "sendChatMessage",
        "tags": [
          "Game Chat"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "game-session": "in_game"
            }
          }
        ],
        "x-rate-limit": {
          "requestsPerMinute": 60,
          "burstLimit": 10
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatMessageRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Chat message sent successfully"
          },
          "404": {
            "description": "Game session not found"
          }
        }
      }
    },
    "/sessions/actions": {
      "post": {
        "summary": "Perform game action (enhanced permissions after joining)",
        "operationId": "performGameAction",
        "tags": [
          "Game Actions"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "game-session": "in_game"
            }
          }
        ],
        "x-rate-limit": {
          "requestsPerMinute": 120,
          "burstLimit": 20
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GameActionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Game action performed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GameActionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Game session not found"
          },
          "400": {
            "description": "Invalid game action"
          }
        }
      }
    },
    "/sessions/leave-session": {
      "post": {
        "summary": "Leave a specific game session by ID",
        "description": "Leave a game session by its session ID. This is the session-specific alternative\nto /sessions/leave which uses gameType. Useful for matchmade sessions.\n",
        "operationId": "leaveGameSessionById",
        "tags": [
          "Game Sessions"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "game-session": "in_game"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LeaveGameSessionByIdRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successfully left game session"
          },
          "404": {
            "description": "Game session not found or player not in session"
          }
        }
      }
    },
    "/inventory/container/create": {
      "post": {
        "operationId": "createContainer",
        "tags": [
          "Container"
        ],
        "summary": "Create a new container",
        "description": "Creates a new container with the specified constraint model and capacity.\nContainer types are game-defined strings (e.g., \"inventory\", \"bank\", \"equipment_slot\").\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateContainerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Container created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContainerResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (validation error)"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/inventory/container/get": {
      "post": {
        "operationId": "getContainer",
        "tags": [
          "Container"
        ],
        "summary": "Get container with contents",
        "description": "Retrieves a container by ID, optionally including its contents.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetContainerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Container retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContainerWithContentsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Container not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/container/get-or-create": {
      "post": {
        "operationId": "getOrCreateContainer",
        "tags": [
          "Container"
        ],
        "summary": "Get container or create if not exists",
        "description": "Enables lazy container creation for character inventories.\nIf a container doesn't exist for the owner/type combination, creates it\nwith the specified defaults.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetOrCreateContainerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Container retrieved or created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContainerResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/inventory/container/list": {
      "post": {
        "operationId": "listContainers",
        "tags": [
          "Container"
        ],
        "summary": "List containers for owner",
        "description": "Returns all containers owned by the specified entity.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListContainersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Containers retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListContainersResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/container/update": {
      "post": {
        "operationId": "updateContainer",
        "tags": [
          "Container"
        ],
        "summary": "Update container properties",
        "description": "Updates mutable container properties like capacity limits and filtering.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateContainerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Container updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContainerResponse"
                }
              }
            }
          },
          "404": {
            "description": "Container not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/inventory/add": {
      "post": {
        "operationId": "addItemToContainer",
        "tags": [
          "Inventory Operations"
        ],
        "summary": "Add item to container",
        "description": "Adds an item instance to a container. Validates container constraints\n(slots, weight, grid, category filters). For stackable items, may\nmerge with existing stacks.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddItemRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item added successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddItemResponse"
                }
              }
            }
          },
          "400": {
            "description": "Constraint violation (full, overweight, wrong category)"
          },
          "404": {
            "description": "Container or item not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/inventory/remove": {
      "post": {
        "operationId": "removeItemFromContainer",
        "tags": [
          "Inventory Operations"
        ],
        "summary": "Remove item from container",
        "description": "Removes an item from its container. The item still exists but has no\ncontainer assignment. Use destroy via lib-item to permanently delete.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RemoveItemRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item removed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RemoveItemResponse"
                }
              }
            }
          },
          "404": {
            "description": "Item not found in specified container"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/inventory/move": {
      "post": {
        "operationId": "moveItem",
        "tags": [
          "Inventory Operations"
        ],
        "summary": "Move item to different slot or container",
        "description": "Moves an item within the same container (slot change) or to a different\ncontainer. Validates destination constraints. For equipment slots, this\neffectively equips/unequips items.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MoveItemRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item moved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MoveItemResponse"
                }
              }
            }
          },
          "400": {
            "description": "Constraint violation at destination"
          },
          "404": {
            "description": "Item or container not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/transfer": {
      "post": {
        "operationId": "transferItem",
        "tags": [
          "Inventory Operations"
        ],
        "summary": "Transfer item to different owner",
        "description": "Transfers an item to a container owned by a different entity.\nUsed for trades, gifts, and loot distribution.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransferItemRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item transferred successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransferItemResponse"
                }
              }
            }
          },
          "400": {
            "description": "Item is bound or not tradeable"
          },
          "404": {
            "description": "Item or container not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/inventory/split": {
      "post": {
        "operationId": "splitStack",
        "tags": [
          "Inventory Operations"
        ],
        "summary": "Split stack into two",
        "description": "Splits a stack of items into two stacks. The original stack keeps the\nremainder, and a new stack is created with the split quantity.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SplitStackRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Stack split successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SplitStackResponse"
                }
              }
            }
          },
          "400": {
            "description": "Cannot split unique items or invalid quantity"
          },
          "404": {
            "description": "Item not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/merge": {
      "post": {
        "operationId": "mergeStacks",
        "tags": [
          "Inventory Operations"
        ],
        "summary": "Merge two stacks",
        "description": "Merges two stacks of the same item template. The source stack is\ndestroyed and its quantity added to the target stack.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MergeStacksRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Stacks merged successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MergeStacksResponse"
                }
              }
            }
          },
          "400": {
            "description": "Items are not the same template or target would exceed max stack"
          },
          "404": {
            "description": "Item not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/query": {
      "post": {
        "operationId": "queryItems",
        "tags": [
          "Inventory Queries"
        ],
        "summary": "Find items across containers",
        "description": "Searches for items across all containers owned by an entity.\nCan filter by template, category, tags, and other criteria.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryItemsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Items found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryItemsResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/count": {
      "post": {
        "operationId": "countItems",
        "tags": [
          "Inventory Queries"
        ],
        "summary": "Count items of a template",
        "description": "Counts total quantity of a specific item template across containers.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CountItemsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Count completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CountItemsResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/has": {
      "post": {
        "operationId": "hasItems",
        "tags": [
          "Inventory Queries"
        ],
        "summary": "Check if entity has required items",
        "description": "Checks if an entity has the required quantities of specified items.\nUsed for crafting and quest requirements validation.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HasItemsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Check completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HasItemsResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/find-space": {
      "post": {
        "operationId": "findSpace",
        "tags": [
          "Inventory Queries"
        ],
        "summary": "Find where item would fit",
        "description": "Finds available space for an item in the owner's containers.\nReturns candidate containers and slots where the item could be placed.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FindSpaceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Space search completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FindSpaceResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/item/template/create": {
      "post": {
        "operationId": "createItemTemplate",
        "tags": [
          "Item Template"
        ],
        "summary": "Create a new item template",
        "description": "Creates a new item definition for a game. Code, gameId, quantityModel, and scope\nare immutable after creation.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateItemTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item template created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (validation error)"
          },
          "409": {
            "description": "Code already exists for this gameId"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/item/template/get": {
      "post": {
        "operationId": "getItemTemplate",
        "tags": [
          "Item Template"
        ],
        "summary": "Get item template by ID or code",
        "description": "Retrieves an item template by its unique ID or by code+gameId combination.\nAt least one of templateId or (code + gameId) must be provided.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetItemTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item template retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Neither templateId nor code+gameId provided"
          },
          "404": {
            "description": "Item template not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/item/template/list": {
      "post": {
        "operationId": "listItemTemplates",
        "tags": [
          "Item Template"
        ],
        "summary": "List item templates with filters",
        "description": "Lists item templates with optional filtering by gameId, category, tags,\nrarity, scope, and active status.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListItemTemplatesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item templates retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListItemTemplatesResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/item/template/update": {
      "post": {
        "operationId": "updateItemTemplate",
        "tags": [
          "Item Template"
        ],
        "summary": "Update mutable fields of an item template",
        "description": "Updates mutable fields of an item template. Code, gameId, quantityModel, and scope\nare immutable after creation and cannot be changed.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateItemTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item template updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Attempted to change immutable field"
          },
          "404": {
            "description": "Item template not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/item/instance/create": {
      "post": {
        "operationId": "createItemInstance",
        "tags": [
          "Item Instance"
        ],
        "summary": "Create a new item instance",
        "description": "Creates a new item instance from a template. The instance must be placed\nin a container (containerId required). Use lib-inventory's /inventory/add\nfor most use cases - this endpoint is for low-level instance creation.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateItemInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item instance created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (validation error)"
          },
          "404": {
            "description": "Template not found"
          },
          "409": {
            "description": "Template is deprecated"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/item/instance/get": {
      "post": {
        "operationId": "getItemInstance",
        "tags": [
          "Item Instance"
        ],
        "summary": "Get item instance by ID",
        "description": "Retrieves an item instance by its unique ID.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetItemInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item instance retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemInstanceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Item instance not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/item/instance/modify": {
      "post": {
        "operationId": "modifyItemInstance",
        "tags": [
          "Item Instance"
        ],
        "summary": "Modify item instance state",
        "description": "Modifies an item instance's mutable state: durability, custom stats,\ncustom name, and metadata. Cannot modify bound items unless admin.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ModifyItemInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item instance modified successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid modification (e.g., negative durability)"
          },
          "404": {
            "description": "Item instance not found"
          },
          "409": {
            "description": "Item is corrupted/mirrored and cannot be modified"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/item/instance/bind": {
      "post": {
        "operationId": "bindItemInstance",
        "tags": [
          "Item Instance"
        ],
        "summary": "Bind item to character",
        "description": "Binds an item instance to a character. The bind type must be allowed by\nthe template's soulboundType. Once bound, the item cannot be traded.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BindItemInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item instance bound successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Item cannot be bound (template doesn't allow binding)"
          },
          "404": {
            "description": "Item instance not found"
          },
          "409": {
            "description": "Item already bound"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/item/instance/destroy": {
      "post": {
        "operationId": "destroyItemInstance",
        "tags": [
          "Item Instance"
        ],
        "summary": "Destroy item instance",
        "description": "Permanently destroys an item instance. The reason is recorded for audit.\nCannot destroy bound items unless admin or reason is 'admin'.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DestroyItemInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item instance destroyed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DestroyItemInstanceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Item instance not found"
          },
          "409": {
            "description": "Item is bound and cannot be destroyed"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/item/instance/list-by-container": {
      "post": {
        "operationId": "listItemsByContainer",
        "tags": [
          "Item Query"
        ],
        "summary": "List items in a container",
        "description": "Returns all item instances in the specified container.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListItemsByContainerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Items retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListItemsResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/item/instance/batch-get": {
      "post": {
        "operationId": "batchGetItemInstances",
        "tags": [
          "Item Query"
        ],
        "summary": "Get multiple item instances by ID",
        "description": "Retrieves multiple item instances in a single request.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchGetItemInstancesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Items retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchGetItemInstancesResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/leaderboard/definition/create": {
      "post": {
        "summary": "Create a new leaderboard definition",
        "description": "Create a new leaderboard with specified properties.\nDeveloper-only endpoint for setting up game leaderboards.\n",
        "operationId": "createLeaderboardDefinition",
        "tags": [
          "Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateLeaderboardDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Leaderboard created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LeaderboardDefinitionResponse"
                }
              }
            }
          },
          "409": {
            "description": "Leaderboard with this ID already exists"
          }
        }
      }
    },
    "/leaderboard/definition/update": {
      "post": {
        "summary": "Update leaderboard definition",
        "description": "Update properties of an existing leaderboard.\nDeveloper-only endpoint.\n",
        "operationId": "updateLeaderboardDefinition",
        "tags": [
          "Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateLeaderboardDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Leaderboard updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LeaderboardDefinitionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Leaderboard not found"
          }
        }
      }
    },
    "/leaderboard/definition/delete": {
      "post": {
        "summary": "Delete leaderboard definition",
        "description": "Delete a leaderboard and all its scores.\nDeveloper-only endpoint. This action is irreversible.\n",
        "operationId": "deleteLeaderboardDefinition",
        "tags": [
          "Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteLeaderboardDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Leaderboard deleted successfully"
          },
          "404": {
            "description": "Leaderboard not found"
          }
        }
      }
    },
    "/leaderboard/rank/get": {
      "post": {
        "summary": "Get entity's rank",
        "description": "Get the current rank and score for a specific entity.",
        "operationId": "getEntityRank",
        "tags": [
          "Rankings"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEntityRankRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Rank retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityRankResponse"
                }
              }
            }
          },
          "404": {
            "description": "Entity not found on leaderboard"
          }
        }
      }
    },
    "/leaderboard/rank/top": {
      "post": {
        "summary": "Get top entries",
        "description": "Get the top N entries on a leaderboard.",
        "operationId": "getTopRanks",
        "tags": [
          "Rankings"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetTopRanksRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Top ranks retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LeaderboardEntriesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/leaderboard/rank/around": {
      "post": {
        "summary": "Get entries around entity",
        "description": "Get leaderboard entries surrounding a specific entity.\nUseful for showing a player's position with nearby competitors.\n",
        "operationId": "getRanksAround",
        "tags": [
          "Rankings"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRanksAroundRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Ranks retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LeaderboardEntriesResponse"
                }
              }
            }
          },
          "404": {
            "description": "Entity not found on leaderboard"
          }
        }
      }
    },
    "/leaderboard/season/get": {
      "post": {
        "summary": "Get current season info",
        "description": "Get information about the current or a specific past season.",
        "operationId": "getSeason",
        "tags": [
          "Seasons"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSeasonRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Season info retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeasonResponse"
                }
              }
            }
          },
          "404": {
            "description": "Season not found"
          }
        }
      }
    },
    "/location/get": {
      "post": {
        "summary": "Get location by ID",
        "operationId": "getLocation",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetLocationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Location retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationResponse"
                }
              }
            }
          },
          "404": {
            "description": "Location not found"
          }
        }
      }
    },
    "/location/get-by-code": {
      "post": {
        "summary": "Get location by code and realm",
        "description": "Retrieve a location using its unique code within a specific realm",
        "operationId": "getLocationByCode",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetLocationByCodeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Location retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationResponse"
                }
              }
            }
          },
          "404": {
            "description": "Location not found"
          }
        }
      }
    },
    "/location/list": {
      "post": {
        "summary": "List locations with filtering",
        "description": "Retrieve locations with optional realm, parent, and type filtering",
        "operationId": "listLocations",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListLocationsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Locations retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/location/list-by-realm": {
      "post": {
        "summary": "List all locations in a realm (primary query pattern)",
        "description": "Returns all locations within a specific realm, optionally filtered by\nlocation type and parent. This is the primary access pattern for\nrealm-scoped location queries.\n",
        "operationId": "listLocationsByRealm",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListLocationsByRealmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Locations retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/location/list-by-parent": {
      "post": {
        "summary": "Get child locations for a parent location",
        "description": "Retrieve all locations that have the specified location as their parent.\nUseful for getting all cities in a region, all buildings in a city, etc.\n",
        "operationId": "listLocationsByParent",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListLocationsByParentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Child locations retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Parent location not found"
          }
        }
      }
    },
    "/location/list-root": {
      "post": {
        "summary": "Get root locations in a realm",
        "description": "Returns all top-level locations in a realm (locations with no parent).\nThese are typically regions or major areas within the realm.\n",
        "operationId": "listRootLocations",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRootLocationsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Root locations retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/location/get-ancestors": {
      "post": {
        "summary": "Get all ancestors of a location",
        "description": "Returns the full ancestry chain from the specified location up to the\nroot location (parentLocationId=null). For example, for a specific building\nmight return [district, city, region].\n",
        "operationId": "getLocationAncestors",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetLocationAncestorsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Ancestors retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Location not found"
          }
        }
      }
    },
    "/location/get-descendants": {
      "post": {
        "summary": "Get all descendants of a location",
        "description": "Returns all locations that are descendants of the specified location\n(direct children, grandchildren, etc.). Useful for finding all places\nwithin a region or city.\n",
        "operationId": "getLocationDescendants",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetLocationDescendantsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Descendants retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Location not found"
          }
        }
      }
    },
    "/location/exists": {
      "post": {
        "summary": "Check if location exists and is active",
        "description": "Fast validation endpoint for other services to check location validity.\nReturns true if location exists and is not deprecated, false otherwise.\n",
        "operationId": "locationExists",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LocationExistsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Validation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationExistsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/mapping/request-snapshot": {
      "post": {
        "summary": "Request full snapshot for cold start",
        "description": "Consumers use this when starting up to get initial state.\nReturns current snapshot of requested region/kinds.\nFor very large maps, payloadRef points to lib-asset storage.\n",
        "operationId": "requestSnapshot",
        "tags": [
          "Runtime"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestSnapshotRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Snapshot returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RequestSnapshotResponse"
                }
              }
            }
          },
          "404": {
            "description": "Region not found"
          }
        }
      }
    },
    "/mapping/query/point": {
      "post": {
        "summary": "Query map data at a specific point",
        "description": "Returns all map data at a point across requested kinds.\nUsed by behavior stacks for contextual decisions.\nOptionally includes objects within radius.\n",
        "operationId": "queryPoint",
        "tags": [
          "Query"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryPointRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Query results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryPointResponse"
                }
              }
            }
          }
        }
      }
    },
    "/mapping/query/bounds": {
      "post": {
        "summary": "Query map data within bounds",
        "description": "Returns map data within a bounding box.\nFor event actors needing region overview.\nLimited to maxObjects per kind.\n",
        "operationId": "queryBounds",
        "tags": [
          "Query"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryBoundsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Query results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryBoundsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/mapping/query/objects-by-type": {
      "post": {
        "summary": "Find all objects of a type in region",
        "description": "Returns all objects matching an objectType filter.\nFor event actors asking \"where are all the boulder clusters?\"\n",
        "operationId": "queryObjectsByType",
        "tags": [
          "Query"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryObjectsByTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Matching objects",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryObjectsByTypeResponse"
                }
              }
            }
          }
        }
      }
    },
    "/mapping/query/affordance": {
      "post": {
        "summary": "Find locations that afford a specific action or scene type",
        "description": "Affordance queries answer \"where can I do X?\" by combining\nmultiple map kinds and applying game-specific scoring logic.\n\nUsed by Event Brain for procedural scene orchestration:\n- \"Find ambush locations\"\n- \"Find dramatic reveal spots\"\n- \"Find sheltered rest areas\"\n\nWell-known types have predefined scoring; use affordanceType=custom\nwith customAffordance for novel scenarios.\n",
        "operationId": "queryAffordance",
        "tags": [
          "Query"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AffordanceQueryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scored locations",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AffordanceQueryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/mapping/authoring/checkout": {
      "post": {
        "summary": "Acquire exclusive edit lock for design-time editing",
        "description": "For level editors and design tools only.\nGame servers do NOT use this - they use create-channel for implicit authority.\nReturns authority token for publishing edits.\n",
        "operationId": "checkoutForAuthoring",
        "tags": [
          "Authoring"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthoringCheckoutRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Checkout successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthoringCheckoutResponse"
                }
              }
            }
          },
          "409": {
            "description": "Already checked out by another editor"
          }
        }
      }
    },
    "/mapping/authoring/commit": {
      "post": {
        "summary": "Commit design-time changes",
        "description": "Commits pending changes and releases the checkout lock.\nOptionally includes a commit message for history.\n",
        "operationId": "commitAuthoring",
        "tags": [
          "Authoring"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthoringCommitRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Changes committed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthoringCommitResponse"
                }
              }
            }
          },
          "403": {
            "description": "Invalid checkout token"
          }
        }
      }
    },
    "/mapping/authoring/release": {
      "post": {
        "summary": "Release authoring checkout without committing",
        "description": "Discards pending changes and releases the checkout lock.\nUse when abandoning edits.\n",
        "operationId": "releaseAuthoring",
        "tags": [
          "Authoring"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthoringReleaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Checkout released",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthoringReleaseResponse"
                }
              }
            }
          }
        }
      }
    },
    "/mapping/definition/create": {
      "post": {
        "summary": "Create a map definition template",
        "description": "Creates a new map definition (template) that describes the structure\nof a region. Definitions are templates that can be used to bootstrap\nchannels with predefined layer configurations.\n",
        "operationId": "createDefinition",
        "tags": [
          "Definition"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Definition created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MapDefinition"
                }
              }
            }
          },
          "409": {
            "description": "Definition with this name already exists"
          }
        }
      }
    },
    "/mapping/definition/get": {
      "post": {
        "summary": "Get a map definition by ID",
        "description": "Returns the full map definition including all layer configurations.",
        "operationId": "getDefinition",
        "tags": [
          "Definition"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Definition found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MapDefinition"
                }
              }
            }
          },
          "404": {
            "description": "Definition not found"
          }
        }
      }
    },
    "/mapping/definition/list": {
      "post": {
        "summary": "List map definitions with optional filters",
        "description": "Returns a paginated list of map definitions.",
        "operationId": "listDefinitions",
        "tags": [
          "Definition"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListDefinitionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Definitions list",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListDefinitionsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/mapping/definition/update": {
      "post": {
        "summary": "Update a map definition",
        "description": "Updates an existing map definition. Cannot change the definition ID.\nLayer configurations can be modified.\n",
        "operationId": "updateDefinition",
        "tags": [
          "Definition"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Definition updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MapDefinition"
                }
              }
            }
          },
          "404": {
            "description": "Definition not found"
          }
        }
      }
    },
    "/matchmaking/queue/list": {
      "post": {
        "summary": "List available matchmaking queues",
        "description": "List all available matchmaking queues that players can join.\nReturns queue configuration details including skill settings.\n",
        "operationId": "listQueues",
        "tags": [
          "Queues"
        ],
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "x-rate-limit": {
          "requestsPerMinute": 30,
          "requestsPerHour": 500
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListQueuesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Queues retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListQueuesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/matchmaking/queue/get": {
      "post": {
        "summary": "Get queue details",
        "description": "Get detailed configuration for a specific matchmaking queue.\n",
        "operationId": "getQueue",
        "tags": [
          "Queues"
        ],
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetQueueRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Queue details retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueueResponse"
                }
              }
            }
          },
          "404": {
            "description": "Queue not found"
          }
        }
      }
    },
    "/matchmaking/join": {
      "post": {
        "summary": "Join matchmaking queue",
        "description": "Join a matchmaking queue with specified properties and query.\nCreates a matchmaking ticket and begins searching for compatible players.\nReturns immediately after ticket creation. Match results are delivered\nvia WebSocket push events.\n",
        "operationId": "joinMatchmaking",
        "tags": [
          "Matchmaking"
        ],
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "x-rate-limit": {
          "requestsPerMinute": 10,
          "requestsPerHour": 100
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/JoinMatchmakingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successfully joined matchmaking queue",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JoinMatchmakingResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid query syntax or properties"
          },
          "409": {
            "description": "Already in queue, queue limit reached, or exclusive group conflict"
          }
        }
      }
    },
    "/matchmaking/leave": {
      "post": {
        "summary": "Leave matchmaking queue",
        "description": "Leave a matchmaking queue and cancel the ticket.\nOnly available when actively in a queue (shortcut/prebound).\n",
        "operationId": "leaveMatchmaking",
        "tags": [
          "Matchmaking"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "matchmaking": "in_queue"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LeaveMatchmakingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successfully left matchmaking queue"
          },
          "404": {
            "description": "Ticket not found or not in queue"
          }
        }
      }
    },
    "/matchmaking/status": {
      "post": {
        "summary": "Get matchmaking status",
        "description": "Get current matchmaking status for the player's active ticket.\nOnly available when actively in a queue (shortcut/prebound).\n",
        "operationId": "getMatchmakingStatus",
        "tags": [
          "Matchmaking"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "matchmaking": "in_queue"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetMatchmakingStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Status retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MatchmakingStatusResponse"
                }
              }
            }
          },
          "404": {
            "description": "No active matchmaking ticket"
          }
        }
      }
    },
    "/matchmaking/accept": {
      "post": {
        "summary": "Accept a formed match",
        "description": "Accept a match that has been formed. Only available when a match\nis pending acceptance (shortcut/prebound after match formation).\nAll players must accept within the timeout for the match to start.\n",
        "operationId": "acceptMatch",
        "tags": [
          "Matchmaking"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "matchmaking": "match_pending"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AcceptMatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Match acceptance recorded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptMatchResponse"
                }
              }
            }
          },
          "404": {
            "description": "No pending match or already processed"
          }
        }
      }
    },
    "/matchmaking/decline": {
      "post": {
        "summary": "Decline a formed match",
        "description": "Decline a match that has been formed. Only available when a match\nis pending acceptance (shortcut/prebound after match formation).\nDeclining cancels the match for all participants.\n",
        "operationId": "declineMatch",
        "tags": [
          "Matchmaking"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "matchmaking": "match_pending"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeclineMatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Match declined"
          },
          "404": {
            "description": "No pending match or already processed"
          }
        }
      }
    },
    "/matchmaking/stats": {
      "post": {
        "summary": "Get queue statistics",
        "description": "Get operational statistics for matchmaking queues.\nIncludes queue depths, average wait times, and match rates.\n",
        "operationId": "getMatchmakingStats",
        "tags": [
          "Statistics"
        ],
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetMatchmakingStatsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Statistics retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MatchmakingStatsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/music/generate": {
      "post": {
        "summary": "Generate composition from style and constraints",
        "description": "Generates a complete musical composition using the specified style definition\nand compositional constraints. Returns MIDI-JSON format output.\n",
        "operationId": "GenerateComposition",
        "tags": [
          "Generation"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenerateCompositionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Composition generated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateCompositionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or generation constraints"
          },
          "404": {
            "description": "Style not found"
          }
        }
      }
    },
    "/music/validate": {
      "post": {
        "summary": "Validate MIDI-JSON structure",
        "description": "Validates a MIDI-JSON structure for correctness including note ranges,\ntiming, and format compliance.\n",
        "operationId": "ValidateMidiJson",
        "tags": [
          "Validation"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ValidateMidiJsonRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Validation completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidateMidiJsonResponse"
                }
              }
            }
          }
        }
      }
    },
    "/music/style/get": {
      "post": {
        "summary": "Get style definition",
        "description": "Retrieves a style definition by ID or name. Styles define mode preferences,\ninterval rules, form templates, and genre-specific parameters.\n",
        "operationId": "GetStyle",
        "tags": [
          "Styles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetStyleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Style retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StyleDefinitionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Style not found"
          }
        }
      }
    },
    "/music/style/list": {
      "post": {
        "summary": "List available styles",
        "description": "Lists all available style definitions with optional filtering by category.\n",
        "operationId": "ListStyles",
        "tags": [
          "Styles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListStylesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Styles listed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListStylesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/music/theory/progression": {
      "post": {
        "summary": "Generate chord progression",
        "description": "Generates a chord progression using harmonic function theory.\nSupports multiple harmonic styles including functional harmony,\nmodal interchange, and jazz voicings.\n",
        "operationId": "GenerateProgression",
        "tags": [
          "Theory"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenerateProgressionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Progression generated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateProgressionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          }
        }
      }
    },
    "/music/theory/melody": {
      "post": {
        "summary": "Generate melody over harmony",
        "description": "Generates a melodic line over a chord progression using contour rules,\ninterval preferences, and rhythmic patterns from the specified style.\n",
        "operationId": "GenerateMelody",
        "tags": [
          "Theory"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenerateMelodyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Melody generated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateMelodyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          }
        }
      }
    },
    "/music/theory/voice-lead": {
      "post": {
        "summary": "Apply voice leading to chords",
        "description": "Applies voice leading rules to a chord sequence, ensuring smooth\npart-writing according to traditional or style-specific rules.\n",
        "operationId": "ApplyVoiceLeading",
        "tags": [
          "Theory"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VoiceLeadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Voice leading applied successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VoiceLeadResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          }
        }
      }
    },
    "/realm/get": {
      "post": {
        "summary": "Get realm by ID",
        "operationId": "getRealm",
        "tags": [
          "Realm"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRealmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Realm retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmResponse"
                }
              }
            }
          },
          "404": {
            "description": "Realm not found"
          }
        }
      }
    },
    "/realm/get-by-code": {
      "post": {
        "summary": "Get realm by code",
        "description": "Retrieve a realm using its unique code (e.g., \"OMEGA\", \"ARCADIA\", \"FANTASIA\")",
        "operationId": "getRealmByCode",
        "tags": [
          "Realm"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRealmByCodeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Realm retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmResponse"
                }
              }
            }
          },
          "404": {
            "description": "Realm not found"
          }
        }
      }
    },
    "/realm/list": {
      "post": {
        "summary": "List all realms",
        "description": "Retrieve all realms with optional filtering",
        "operationId": "listRealms",
        "tags": [
          "Realm"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRealmsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Realms retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/realm/exists": {
      "post": {
        "summary": "Check if realm exists and is active",
        "description": "Fast validation endpoint for other services to check realm validity.\nReturns true if realm exists and is not deprecated, false otherwise.\n",
        "operationId": "realmExists",
        "tags": [
          "Realm"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RealmExistsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Validation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmExistsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/realm-history/get-participation": {
      "post": {
        "summary": "Get all historical events a realm participated in",
        "operationId": "getRealmParticipation",
        "tags": [
          "Historical Events"
        ],
        "description": "Retrieves all historical event participation records for a realm.\nSupports filtering by event category and minimum impact.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRealmParticipationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Participation records retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmParticipationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/realm-history/get-event-participants": {
      "post": {
        "summary": "Get all realms that participated in a historical event",
        "operationId": "getRealmEventParticipants",
        "tags": [
          "Historical Events"
        ],
        "description": "Retrieves all realms that participated in a specific historical event.\nUseful for generating event summaries or finding related realms.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRealmEventParticipantsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Participants retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmParticipationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/realm-history/get-lore": {
      "post": {
        "summary": "Get machine-readable lore elements for behavior system",
        "operationId": "getRealmLore",
        "tags": [
          "Lore"
        ],
        "description": "Retrieves structured lore elements for a realm. These elements\nare machine-readable key-value pairs used by the behavior system for\ndecision-making, not narrative text for players.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRealmLoreRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Lore retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmLoreResponse"
                }
              }
            }
          },
          "404": {
            "description": "No lore defined for this realm"
          }
        }
      }
    },
    "/relationship/get": {
      "post": {
        "operationId": "getRelationship",
        "tags": [
          "Relationship Management"
        ],
        "summary": "Get a relationship by ID",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRelationshipRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Relationship retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipResponse"
                }
              }
            }
          },
          "404": {
            "description": "Relationship not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/relationship/list-by-entity": {
      "post": {
        "operationId": "listRelationshipsByEntity",
        "tags": [
          "Relationship Management"
        ],
        "summary": "List all relationships for an entity",
        "description": "Returns all relationships where the specified entity is either\nentity1 or entity2. Supports filtering by relationship type,\nother entity type, and whether to include ended relationships.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRelationshipsByEntityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Relationships retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipListResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/relationship/get-between": {
      "post": {
        "operationId": "getRelationshipsBetween",
        "tags": [
          "Relationship Management"
        ],
        "summary": "Get all relationships between two specific entities",
        "description": "Returns all relationships that exist between two specific entities,\nregardless of which is entity1 or entity2.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRelationshipsBetweenRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Relationships retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipListResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/relationship/list-by-type": {
      "post": {
        "operationId": "listRelationshipsByType",
        "tags": [
          "Relationship Management"
        ],
        "summary": "List all relationships of a specific type",
        "description": "Returns all relationships that use a specific relationship type.\nUseful for finding all \"FRIEND\" relationships, for example.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRelationshipsByTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Relationships retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipListResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/relationship-type/get": {
      "post": {
        "summary": "Get relationship type by ID",
        "operationId": "getRelationshipType",
        "tags": [
          "RelationshipType"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRelationshipTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Relationship type retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipTypeResponse"
                }
              }
            }
          },
          "404": {
            "description": "Relationship type not found"
          }
        }
      }
    },
    "/relationship-type/get-by-code": {
      "post": {
        "summary": "Get relationship type by code",
        "description": "Retrieve a relationship type using its unique code (e.g., \"SON\", \"MOTHER\", \"FRIEND\")",
        "operationId": "getRelationshipTypeByCode",
        "tags": [
          "RelationshipType"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRelationshipTypeByCodeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Relationship type retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipTypeResponse"
                }
              }
            }
          },
          "404": {
            "description": "Relationship type not found"
          }
        }
      }
    },
    "/relationship-type/list": {
      "post": {
        "summary": "List all relationship types",
        "description": "Retrieve all relationship types with optional hierarchy filtering",
        "operationId": "listRelationshipTypes",
        "tags": [
          "RelationshipType"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRelationshipTypesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Relationship types retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipTypeListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/relationship-type/get-children": {
      "post": {
        "summary": "Get child types for a parent type",
        "description": "Retrieve all relationship types that have the specified type as their parent",
        "operationId": "getChildRelationshipTypes",
        "tags": [
          "RelationshipType"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetChildRelationshipTypesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Child relationship types retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipTypeListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Parent relationship type not found"
          }
        }
      }
    },
    "/relationship-type/matches-hierarchy": {
      "post": {
        "summary": "Check if type matches ancestor in hierarchy",
        "description": "Checks if a relationship type matches or descends from an ancestor type.\nFor example, \"SON\" matches \"CHILD\" because CHILD is an ancestor of SON.\nThis enables queries like \"find all CHILD relationships\" to match SON, DAUGHTER, etc.\n",
        "operationId": "matchesHierarchy",
        "tags": [
          "RelationshipType"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MatchesHierarchyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Hierarchy match result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MatchesHierarchyResponse"
                }
              }
            }
          },
          "404": {
            "description": "One or both relationship types not found"
          }
        }
      }
    },
    "/relationship-type/get-ancestors": {
      "post": {
        "summary": "Get all ancestors of a relationship type",
        "description": "Returns the full ancestry chain from the specified type up to the root.\nFor example, for \"SON\" might return [\"CHILD\", \"FAMILY\"].\n",
        "operationId": "getAncestors",
        "tags": [
          "RelationshipType"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetAncestorsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Ancestors retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipTypeListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Relationship type not found"
          }
        }
      }
    },
    "/save-load/slot/create": {
      "post": {
        "tags": [
          "Slots"
        ],
        "operationId": "CreateSlot",
        "summary": "Create or configure a save slot",
        "description": "Creates a new save slot or updates configuration of an existing slot.\nSlots are auto-created on first save, but pre-creation allows setting\ncustom configuration (max versions, retention policy, etc.).\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateSlotRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Slot created or updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlotResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "409": {
            "description": "Slot already exists with different owner"
          }
        }
      }
    },
    "/save-load/slot/get": {
      "post": {
        "tags": [
          "Slots"
        ],
        "operationId": "GetSlot",
        "summary": "Get slot metadata",
        "description": "Returns slot configuration and version summary.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSlotRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Slot found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlotResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot not found"
          }
        }
      }
    },
    "/save-load/slot/list": {
      "post": {
        "tags": [
          "Slots"
        ],
        "operationId": "ListSlots",
        "summary": "List slots for owner",
        "description": "Returns all slots owned by the specified entity.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSlotsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Slots listed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSlotsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/save-load/slot/delete": {
      "post": {
        "tags": [
          "Slots"
        ],
        "operationId": "DeleteSlot",
        "summary": "Delete slot and all versions",
        "description": "Permanently deletes a slot and all save versions within it.\nThis is irreversible. Requires owner access or admin role.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteSlotRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Slot deleted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteSlotResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot not found"
          },
          "403": {
            "description": "Not authorized to delete this slot"
          }
        }
      }
    },
    "/save-load/slot/rename": {
      "post": {
        "tags": [
          "Slots"
        ],
        "operationId": "RenameSlot",
        "summary": "Rename a save slot",
        "description": "Renames an existing slot without affecting its versions or data.\nThe new name must not already exist for this owner.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RenameSlotRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Slot renamed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlotResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot not found"
          },
          "409": {
            "description": "Target name already exists"
          }
        }
      }
    },
    "/save-load/save": {
      "post": {
        "tags": [
          "Saves"
        ],
        "operationId": "Save",
        "summary": "Save data to slot",
        "description": "Creates a new version in the specified slot with the provided data.\nIf the slot doesn't exist, it's auto-created with default configuration.\n\nLarge saves (>1MB by default) are automatically compressed.\nRolling version cleanup is applied based on slot configuration.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SaveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Save successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SaveResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or data validation failed"
          },
          "413": {
            "description": "Save data exceeds maximum size limit"
          },
          "403": {
            "description": "Not authorized to save to this slot"
          }
        }
      }
    },
    "/save-load/load": {
      "post": {
        "tags": [
          "Saves"
        ],
        "operationId": "Load",
        "summary": "Load data from slot",
        "description": "Retrieves save data from the specified slot. By default, loads the\nlatest version. Optionally specify a version number or checkpoint name.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Load successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LoadResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          },
          "403": {
            "description": "Not authorized to load from this slot"
          }
        }
      }
    },
    "/save-load/save-delta": {
      "post": {
        "tags": [
          "Saves"
        ],
        "operationId": "SaveDelta",
        "summary": "Save incremental changes from base version",
        "description": "Creates a new version by applying a delta (patch) to a base version.\nSignificantly reduces storage for large saves with small incremental changes.\n\nUses JSON Patch (RFC 6902) by default. The implementation is designed to\nallow swapping to binary diff algorithms (bsdiff/xdelta) if needed for\nspecific use cases (e.g., binary game state).\n\nDelta versions store only the patch; full data is reconstructed on load.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SaveDeltaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Delta save successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SaveDeltaResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid delta or base version not found"
          },
          "409": {
            "description": "Base version has been deleted (cannot apply delta)"
          },
          "413": {
            "description": "Delta too large (consider full save instead)"
          }
        }
      }
    },
    "/save-load/load-with-deltas": {
      "post": {
        "tags": [
          "Saves"
        ],
        "operationId": "LoadWithDeltas",
        "summary": "Load save reconstructing from delta chain",
        "description": "Loads save data, automatically reconstructing from delta chain if needed.\nReturns the full reconstructed data, not the raw delta.\n\nFor performance, the service may cache reconstructed data or collapse\ndelta chains during background cleanup.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Load successful (reconstructed if delta)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LoadResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          },
          "422": {
            "description": "Delta chain broken (base version missing)"
          }
        }
      }
    },
    "/save-load/collapse-deltas": {
      "post": {
        "tags": [
          "Saves"
        ],
        "operationId": "CollapseDeltas",
        "summary": "Collapse delta chain into full snapshot",
        "description": "Collapses a chain of delta versions into a single full snapshot.\nUseful for reducing load latency or before deleting base versions.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CollapseDeltasRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Delta chain collapsed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SaveResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          }
        }
      }
    },
    "/save-load/version/list": {
      "post": {
        "tags": [
          "Versions"
        ],
        "operationId": "ListVersions",
        "summary": "List versions in slot",
        "description": "Returns all versions in a slot with metadata.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListVersionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Versions listed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListVersionsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot not found"
          }
        }
      }
    },
    "/save-load/version/pin": {
      "post": {
        "tags": [
          "Versions"
        ],
        "operationId": "PinVersion",
        "summary": "Pin a version as checkpoint",
        "description": "Pins a specific version, excluding it from rolling cleanup.\nOptionally assigns a checkpoint name for easy retrieval.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PinVersionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Version pinned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VersionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          }
        }
      }
    },
    "/save-load/version/unpin": {
      "post": {
        "tags": [
          "Versions"
        ],
        "operationId": "UnpinVersion",
        "summary": "Unpin a version",
        "description": "Removes pin from a version, making it eligible for rolling cleanup.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnpinVersionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Version unpinned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VersionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          }
        }
      }
    },
    "/save-load/version/delete": {
      "post": {
        "tags": [
          "Versions"
        ],
        "operationId": "DeleteVersion",
        "summary": "Delete specific version",
        "description": "Permanently deletes a specific version from a slot.\nCannot delete pinned versions; unpin first.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteVersionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Version deleted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteVersionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          },
          "409": {
            "description": "Cannot delete pinned version"
          }
        }
      }
    },
    "/save-load/query": {
      "post": {
        "tags": [
          "Query"
        ],
        "operationId": "QuerySaves",
        "summary": "Query saves with filters",
        "description": "Search and filter saves across slots. Supports filtering by owner,\ncategory, date range, metadata, and more. Paginated results.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QuerySavesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Query results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuerySavesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/save-load/copy": {
      "post": {
        "tags": [
          "Transfer"
        ],
        "operationId": "CopySave",
        "summary": "Copy save to different slot or owner",
        "description": "Copies a save version to a different slot or owner.\nCan copy to same owner (different slot) or different owner (with admin).\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CopySaveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Save copied",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SaveResponse"
                }
              }
            }
          },
          "404": {
            "description": "Source slot or version not found"
          },
          "403": {
            "description": "Not authorized to copy to target"
          }
        }
      }
    },
    "/save-load/export": {
      "post": {
        "tags": [
          "Transfer"
        ],
        "operationId": "ExportSaves",
        "summary": "Export saves for backup/portability",
        "description": "Exports one or more slots with all versions as a downloadable archive.\nReturns a pre-signed URL to download the export bundle.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExportSavesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Export prepared",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExportSavesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/save-load/verify": {
      "post": {
        "tags": [
          "Validation"
        ],
        "operationId": "VerifyIntegrity",
        "summary": "Verify save data integrity",
        "description": "Verifies the integrity of stored save data by comparing content hash\nagainst the stored SHA-256 hash. Detects corruption or tampering.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VerifyIntegrityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Verification result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VerifyIntegrityResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          }
        }
      }
    },
    "/save-load/version/promote": {
      "post": {
        "tags": [
          "Versions"
        ],
        "operationId": "PromoteVersion",
        "summary": "Promote old version to latest",
        "description": "Creates a new version from an existing older version, effectively\n\"promoting\" it to be the latest. Useful for rollback scenarios.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromoteVersionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Version promoted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SaveResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          }
        }
      }
    },
    "/save-load/migrate": {
      "post": {
        "tags": [
          "Migration"
        ],
        "operationId": "MigrateSave",
        "summary": "Migrate save to new schema version",
        "description": "Applies migration handlers to upgrade a save from one schema version\nto another. Creates a new version with the migrated data.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MigrateSaveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Migration successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MigrateSaveResponse"
                }
              }
            }
          },
          "400": {
            "description": "Migration failed or no path exists"
          },
          "404": {
            "description": "Save not found"
          }
        }
      }
    },
    "/save-load/schema/register": {
      "post": {
        "tags": [
          "Migration"
        ],
        "operationId": "RegisterSchema",
        "summary": "Register a save data schema",
        "description": "Registers a JSON schema for validation of save data.\nOptionally includes migration handlers from previous versions.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegisterSchemaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Schema registered",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SchemaResponse"
                }
              }
            }
          }
        }
      }
    },
    "/save-load/schema/list": {
      "post": {
        "tags": [
          "Migration"
        ],
        "operationId": "ListSchemas",
        "summary": "List registered schemas",
        "description": "Returns all registered schemas for a game/namespace.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSchemasRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Schemas listed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSchemasResponse"
                }
              }
            }
          }
        }
      }
    },
    "/scene/create": {
      "post": {
        "summary": "Create a new scene document",
        "description": "Creates a new scene document and stores it in lib-asset.\nPublishes scene.created event on success.\nReturns Conflict if a scene with the same sceneId already exists.\n",
        "operationId": "createScene",
        "tags": [
          "Scene"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateSceneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scene created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SceneResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid scene structure (validation failed)"
          },
          "409": {
            "description": "Scene with this sceneId already exists"
          }
        }
      }
    },
    "/scene/get": {
      "post": {
        "summary": "Retrieve a scene by ID",
        "description": "Retrieves a scene document. Optionally resolves nested scene references\nup to a configurable depth.\n",
        "operationId": "getScene",
        "tags": [
          "Scene"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSceneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scene retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetSceneResponse"
                }
              }
            }
          },
          "404": {
            "description": "Scene not found"
          }
        }
      }
    },
    "/scene/list": {
      "post": {
        "summary": "List scenes with filtering",
        "description": "Lists scenes matching the provided filters. Supports pagination.\nResults are ordered by updatedAt descending (most recent first).\n",
        "operationId": "listScenes",
        "tags": [
          "Scene"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListScenesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scenes listed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListScenesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/scene/update": {
      "post": {
        "summary": "Update a scene document",
        "description": "Updates an existing scene document. Scene must not be checked out by\nanother user. Increments the PATCH version automatically.\nPublishes scene.updated event on success.\n",
        "operationId": "updateScene",
        "tags": [
          "Scene"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateSceneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scene updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SceneResponse"
                }
              }
            }
          },
          "404": {
            "description": "Scene not found"
          },
          "409": {
            "description": "Scene is checked out by another user"
          },
          "400": {
            "description": "Invalid scene structure"
          }
        }
      }
    },
    "/scene/delete": {
      "post": {
        "summary": "Delete a scene",
        "description": "Soft-deletes a scene. The scene data remains recoverable via lib-asset\nfor approximately 30 days. Cannot delete if other scenes reference this one.\nPublishes scene.deleted event on success.\n",
        "operationId": "deleteScene",
        "tags": [
          "Scene"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteSceneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scene deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteSceneResponse"
                }
              }
            }
          },
          "404": {
            "description": "Scene not found"
          },
          "409": {
            "description": "Cannot delete - other scenes reference this scene"
          }
        }
      }
    },
    "/scene/validate": {
      "post": {
        "summary": "Validate a scene structure",
        "description": "Validates a scene document without saving it. Checks structural validity\nand optionally applies game-specific validation rules.\n",
        "operationId": "validateScene",
        "tags": [
          "Scene"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ValidateSceneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Validation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationResult"
                }
              }
            }
          }
        }
      }
    },
    "/scene/checkout": {
      "post": {
        "summary": "Lock a scene for editing",
        "description": "Acquires an exclusive lock on the scene for editing.\nReturns a checkout token required for commit.\nLock expires after TTL if not extended via heartbeat.\n",
        "operationId": "checkoutScene",
        "tags": [
          "Versioning"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CheckoutRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Checkout successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckoutResponse"
                }
              }
            }
          },
          "404": {
            "description": "Scene not found"
          },
          "409": {
            "description": "Scene already checked out by another user"
          }
        }
      }
    },
    "/scene/commit": {
      "post": {
        "summary": "Save changes and release lock",
        "description": "Commits the changes made during checkout, increments version,\nand releases the lock. Publishes scene.committed event.\n",
        "operationId": "commitScene",
        "tags": [
          "Versioning"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CommitRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Commit successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CommitResponse"
                }
              }
            }
          },
          "403": {
            "description": "Invalid checkout token"
          },
          "409": {
            "description": "Checkout expired"
          }
        }
      }
    },
    "/scene/discard": {
      "post": {
        "summary": "Release lock without saving changes",
        "description": "Discards any changes and releases the checkout lock.\nScene remains at its pre-checkout version.\n",
        "operationId": "discardCheckout",
        "tags": [
          "Versioning"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DiscardRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Discard successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DiscardResponse"
                }
              }
            }
          },
          "403": {
            "description": "Invalid checkout token"
          }
        }
      }
    },
    "/scene/heartbeat": {
      "post": {
        "summary": "Extend checkout lock TTL",
        "description": "Extends the checkout lock TTL. Should be called periodically\nduring editing to prevent lock expiration.\n",
        "operationId": "heartbeatCheckout",
        "tags": [
          "Versioning"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HeartbeatRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Lock extended",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HeartbeatResponse"
                }
              }
            }
          },
          "403": {
            "description": "Invalid checkout token"
          },
          "409": {
            "description": "Checkout expired"
          }
        }
      }
    },
    "/scene/history": {
      "post": {
        "summary": "Get version history for a scene",
        "description": "Returns the version history for a scene, up to the configured\nretention limit per gameId.\n",
        "operationId": "getSceneHistory",
        "tags": [
          "Versioning"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HistoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "History retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HistoryResponse"
                }
              }
            }
          },
          "404": {
            "description": "Scene not found"
          }
        }
      }
    },
    "/scene/get-validation-rules": {
      "post": {
        "summary": "Get validation rules for a gameId+sceneType",
        "description": "Retrieves the registered validation rules for a specific\ngameId and sceneType combination.\n",
        "operationId": "getValidationRules",
        "tags": [
          "Validation"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetValidationRulesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Rules retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetValidationRulesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/scene/search": {
      "post": {
        "summary": "Full-text search across scenes",
        "description": "Searches scene names, descriptions, tags, and node names\nfor matching content.\n",
        "operationId": "searchScenes",
        "tags": [
          "Query"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchScenesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchScenesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/scene/find-references": {
      "post": {
        "summary": "Find scenes that reference a given scene",
        "description": "Returns all scenes that contain reference nodes pointing\nto the specified scene.\n",
        "operationId": "findReferences",
        "tags": [
          "Query"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FindReferencesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Referencing scenes found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FindReferencesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/scene/find-asset-usage": {
      "post": {
        "summary": "Find scenes using a specific asset",
        "description": "Returns all scenes containing nodes that reference\na specific asset ID.\n",
        "operationId": "findAssetUsage",
        "tags": [
          "Query"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FindAssetUsageRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Asset usage found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FindAssetUsageResponse"
                }
              }
            }
          }
        }
      }
    },
    "/scene/duplicate": {
      "post": {
        "summary": "Duplicate a scene with a new ID",
        "description": "Creates a copy of a scene with a new sceneId and name.\nAll node IDs are regenerated. Version resets to 1.0.0.\n",
        "operationId": "duplicateScene",
        "tags": [
          "Scene"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DuplicateSceneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scene duplicated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SceneResponse"
                }
              }
            }
          },
          "404": {
            "description": "Source scene not found"
          }
        }
      }
    },
    "/species/get": {
      "post": {
        "summary": "Get species by ID",
        "operationId": "getSpecies",
        "tags": [
          "Species"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSpeciesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Species retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpeciesResponse"
                }
              }
            }
          },
          "404": {
            "description": "Species not found"
          }
        }
      }
    },
    "/species/get-by-code": {
      "post": {
        "summary": "Get species by code",
        "description": "Retrieve a species using its unique code (e.g., \"HUMAN\", \"ELF\", \"DWARF\")",
        "operationId": "getSpeciesByCode",
        "tags": [
          "Species"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSpeciesByCodeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Species retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpeciesResponse"
                }
              }
            }
          },
          "404": {
            "description": "Species not found"
          }
        }
      }
    },
    "/species/list": {
      "post": {
        "summary": "List all species",
        "description": "Retrieve all species with optional realm filtering",
        "operationId": "listSpecies",
        "tags": [
          "Species"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSpeciesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Species retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpeciesListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/species/list-by-realm": {
      "post": {
        "summary": "List species available in a realm",
        "description": "Retrieve all species that are available in a specific realm",
        "operationId": "listSpeciesByRealm",
        "tags": [
          "Species"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSpeciesByRealmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Species retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpeciesListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Realm not found"
          }
        }
      }
    },
    "/subscription/account/list": {
      "post": {
        "summary": "Get subscriptions for an account",
        "description": "Returns all subscriptions for a given account, with optional filtering.",
        "operationId": "getAccountSubscriptions",
        "tags": [
          "Subscription Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetAccountSubscriptionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Subscriptions retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/subscription/get": {
      "post": {
        "summary": "Get a specific subscription by ID",
        "operationId": "getSubscription",
        "tags": [
          "Subscription Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSubscriptionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Subscription retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionInfo"
                }
              }
            }
          },
          "404": {
            "description": "Subscription not found"
          }
        }
      }
    },
    "/subscription/cancel": {
      "post": {
        "summary": "Cancel a subscription",
        "description": "Cancels a subscription. Users can cancel their own subscriptions,\nadmins can cancel any subscription.\n",
        "operationId": "cancelSubscription",
        "tags": [
          "Subscription Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CancelSubscriptionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Subscription cancelled successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionInfo"
                }
              }
            }
          },
          "404": {
            "description": "Subscription not found"
          },
          "403": {
            "description": "Not authorized to cancel this subscription"
          }
        }
      }
    },
    "/voice/peer/answer": {
      "post": {
        "summary": "Send SDP answer to complete WebRTC handshake",
        "description": "Called by clients after receiving a VoicePeerJoinedEvent containing an SDP offer.\nThe client generates an SDP answer and sends it via this endpoint.\nThe answering peer is notified via VoicePeerUpdatedEvent.\n\n**Access Control**: This endpoint requires the `voice:ringing` state, which is\nautomatically set by the Voice service when a VoicePeerJoinedEvent is sent to the client.\nThe state is cleared after the answer is processed or times out.\n",
        "operationId": "answerPeer",
        "tags": [
          "Voice Peers"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "voice": "ringing"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AnswerPeerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "SDP answer processed, peer notified"
          },
          "404": {
            "description": "Peer or room not found"
          },
          "403": {
            "description": "Not in voice:ringing state (no pending offers)"
          }
        }
      }
    },
    "/website/status": {
      "get": {
        "summary": "Get website status and version",
        "operationId": "getStatus",
        "tags": [
          "Status"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "responses": {
          "200": {
            "description": "Website service status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatusResponse"
                }
              }
            }
          }
        }
      }
    },
    "/website/content/{slug}": {
      "get": {
        "summary": "Get dynamic page content from CMS",
        "operationId": "getPageContent",
        "tags": [
          "Content"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "slug",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "pattern": "^[a-z0-9-]+$"
            },
            "description": "Page slug identifier"
          }
        ],
        "responses": {
          "200": {
            "description": "Page content retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PageContent"
                }
              }
            }
          },
          "404": {
            "description": "Page not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/website/news": {
      "get": {
        "summary": "Get latest news and announcements",
        "operationId": "getNews",
        "tags": [
          "Content"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 50,
              "default": 10
            },
            "description": "Number of news items to return"
          },
          {
            "name": "offset",
            "in": "query",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            },
            "description": "Pagination offset"
          }
        ],
        "responses": {
          "200": {
            "description": "News items retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NewsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/website/server-status": {
      "get": {
        "summary": "Get game server status for all realms",
        "operationId": "getServerStatus",
        "tags": [
          "Status"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "responses": {
          "200": {
            "description": "Server status information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerStatusResponse"
                }
              }
            }
          }
        }
      }
    },
    "/website/downloads": {
      "get": {
        "summary": "Get download links for game clients",
        "operationId": "getDownloads",
        "tags": [
          "Downloads"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "platform",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "windows",
                "macos",
                "linux"
              ]
            },
            "description": "Filter by platform"
          }
        ],
        "responses": {
          "200": {
            "description": "Download links retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DownloadsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/website/contact": {
      "post": {
        "summary": "Submit contact form",
        "operationId": "submitContact",
        "tags": [
          "Contact"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ContactRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Contact form submitted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContactResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid form data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "429": {
            "description": "Too many requests",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/website/account/profile": {
      "get": {
        "summary": "Get account profile for logged-in user",
        "operationId": "getAccountProfile",
        "tags": [
          "Account"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "Account profile retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountProfile"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/website/account/characters": {
      "get": {
        "summary": "Get character list for logged-in user",
        "operationId": "getAccountCharacters",
        "tags": [
          "Account"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "Character list retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CharacterListResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/website/cms/pages": {
      "get": {
        "summary": "List all CMS pages",
        "operationId": "listPages",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "includeUnpublished",
            "in": "query",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Page list retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PageMetadata"
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create new CMS page",
        "operationId": "createPage",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PageContent"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Page created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PageContent"
                }
              }
            }
          }
        }
      }
    },
    "/website/cms/pages/{slug}": {
      "put": {
        "summary": "Update CMS page",
        "operationId": "updatePage",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "slug",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PageContent"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Page updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PageContent"
                }
              }
            }
          }
        }
      },
      "delete": {
        "summary": "Delete CMS page",
        "operationId": "deletePage",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "slug",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Page deleted"
          }
        }
      }
    },
    "/website/cms/site-settings": {
      "get": {
        "summary": "Get site configuration",
        "operationId": "getSiteSettings",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "responses": {
          "200": {
            "description": "Site settings retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SiteSettings"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update site configuration",
        "operationId": "updateSiteSettings",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SiteSettings"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Settings updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SiteSettings"
                }
              }
            }
          }
        }
      }
    },
    "/website/cms/theme": {
      "get": {
        "summary": "Get current theme configuration",
        "operationId": "getTheme",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "responses": {
          "200": {
            "description": "Theme configuration retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ThemeConfig"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update theme configuration",
        "operationId": "updateTheme",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ThemeConfig"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Theme updated"
          }
        }
      }
    },
    "/website/account/subscription": {
      "get": {
        "summary": "Get subscription status",
        "operationId": "getSubscription",
        "tags": [
          "Account"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "Subscription information retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AcceptMatchRequest": {
        "type": "object",
        "description": "Request to accept a formed match",
        "additionalProperties": false,
        "required": [
          "webSocketSessionId",
          "accountId",
          "matchId"
        ],
        "properties": {
          "webSocketSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player"
          },
          "matchId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the match to accept"
          }
        }
      },
      "AcceptMatchResponse": {
        "type": "object",
        "description": "Response after accepting a match",
        "additionalProperties": false,
        "required": [
          "matchId",
          "allAccepted"
        ],
        "properties": {
          "matchId": {
            "type": "string",
            "format": "uuid",
            "description": "Match identifier"
          },
          "allAccepted": {
            "type": "boolean",
            "description": "Whether all players have accepted"
          },
          "acceptedCount": {
            "type": "integer",
            "nullable": true,
            "description": "Number of players who have accepted"
          },
          "totalCount": {
            "type": "integer",
            "nullable": true,
            "description": "Total players who need to accept"
          },
          "gameSessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game session ID (set when all players accept)"
          }
        }
      },
      "AccountProfile": {
        "description": "User account information displayed on the website profile page",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "accountId",
          "email",
          "createdAt"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the account"
          },
          "email": {
            "type": "string",
            "format": "email",
            "description": "Email address associated with the account"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "User-chosen display name"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Date and time when the account was created"
          },
          "lastLogin": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Date and time of the last successful login"
          },
          "characterSlots": {
            "type": "integer",
            "description": "Total number of character slots available"
          },
          "usedSlots": {
            "type": "integer",
            "description": "Number of character slots currently in use"
          }
        }
      },
      "AccountResponse": {
        "type": "object",
        "description": "Account information response",
        "additionalProperties": false,
        "required": [
          "accountId",
          "email",
          "createdAt",
          "emailVerified",
          "roles"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the account"
          },
          "email": {
            "type": "string",
            "format": "email",
            "description": "Email address associated with the account"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Display name for the account"
          },
          "passwordHash": {
            "type": "string",
            "nullable": true,
            "description": "BCrypt hashed password for authentication"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the account was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Timestamp when the account was last updated"
          },
          "emailVerified": {
            "type": "boolean",
            "description": "Whether the email address has been verified"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of roles assigned to the account"
          },
          "authMethods": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AuthMethodInfo"
            },
            "description": "List of authentication methods linked to the account"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Custom metadata associated with the account"
          }
        }
      },
      "AchievementDefinitionResponse": {
        "type": "object",
        "description": "Achievement definition details",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "achievementId",
          "displayName",
          "description",
          "achievementType",
          "points",
          "isActive",
          "createdAt"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning game service"
          },
          "achievementId": {
            "type": "string",
            "description": "Unique identifier"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "description": "How to earn this achievement"
          },
          "hiddenDescription": {
            "type": "string",
            "nullable": true,
            "description": "Description for hidden achievements"
          },
          "achievementType": {
            "$ref": "#/components/schemas/AchievementType",
            "description": "Classification of the achievement"
          },
          "entityTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityType"
            },
            "description": "Allowed entity types"
          },
          "progressTarget": {
            "type": "integer",
            "nullable": true,
            "description": "Target for progressive achievements"
          },
          "points": {
            "type": "integer",
            "description": "Point value"
          },
          "iconUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "Achievement icon URL"
          },
          "platforms": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Platform"
            },
            "description": "Available platforms"
          },
          "platformIds": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Platform-specific IDs"
          },
          "prerequisites": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Required achievements"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether achievement is earnable"
          },
          "earnedCount": {
            "type": "integer",
            "format": "int64",
            "description": "How many entities have earned this"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the achievement was created"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional metadata"
          }
        }
      },
      "AchievementProgress": {
        "type": "object",
        "description": "Progress toward a single achievement",
        "additionalProperties": false,
        "required": [
          "achievementId",
          "isUnlocked"
        ],
        "properties": {
          "achievementId": {
            "type": "string",
            "description": "Achievement identifier"
          },
          "displayName": {
            "type": "string",
            "description": "Achievement display name"
          },
          "currentProgress": {
            "type": "integer",
            "nullable": true,
            "description": "Current progress (for progressive)"
          },
          "targetProgress": {
            "type": "integer",
            "nullable": true,
            "description": "Target progress (for progressive)"
          },
          "percentComplete": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Completion percentage (0-100)"
          },
          "isUnlocked": {
            "type": "boolean",
            "description": "Whether achievement is unlocked"
          },
          "unlockedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When achievement was unlocked"
          }
        }
      },
      "AchievementProgressResponse": {
        "type": "object",
        "description": "Achievement progress for an entity",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "progress"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type that owns this progress summary"
          },
          "progress": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AchievementProgress"
            },
            "description": "Progress for each achievement"
          },
          "totalPoints": {
            "type": "integer",
            "description": "Total points from unlocked achievements"
          },
          "unlockedCount": {
            "type": "integer",
            "description": "Number of unlocked achievements"
          }
        }
      },
      "AchievementType": {
        "type": "string",
        "description": "Type of achievement",
        "enum": [
          "standard",
          "progressive",
          "hidden",
          "secret"
        ]
      },
      "ActorCapabilities": {
        "type": "object",
        "description": "Actor-specific capabilities that affect affordance evaluation.\nSame location may afford different actions to different actor types.\n",
        "properties": {
          "size": {
            "$ref": "#/components/schemas/ActorSize",
            "description": "Affects cover requirements and passage width"
          },
          "height": {
            "type": "number",
            "description": "Actor height in meters (affects cover, sightlines)",
            "nullable": true
          },
          "canClimb": {
            "type": "boolean",
            "default": false,
            "description": "Can reach elevated positions"
          },
          "canSwim": {
            "type": "boolean",
            "default": false,
            "description": "Includes water-based positions"
          },
          "canFly": {
            "type": "boolean",
            "default": false,
            "description": "Includes aerial positions"
          },
          "perceptionRange": {
            "type": "number",
            "description": "Affects sightline distance requirements",
            "nullable": true
          },
          "movementSpeed": {
            "type": "number",
            "description": "Affects escape route viability calculations",
            "nullable": true
          },
          "stealthRating": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "Affects ambush/hidden_path affordance scoring",
            "nullable": true
          }
        }
      },
      "ActorInstanceResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response containing actor instance details",
        "required": [
          "actorId",
          "templateId",
          "category",
          "status",
          "startedAt",
          "loopIterations"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "Unique actor identifier"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template this actor was instantiated from"
          },
          "category": {
            "type": "string",
            "description": "Actor category from template"
          },
          "nodeId": {
            "type": "string",
            "nullable": true,
            "description": "Pool node running this actor (null in bannou mode)"
          },
          "nodeAppId": {
            "type": "string",
            "nullable": true,
            "description": "Pool node's app-id for direct messaging"
          },
          "status": {
            "description": "Current actor lifecycle state",
            "$ref": "#/components/schemas/ActorStatus"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Associated character ID (for NPC brains)"
          },
          "startedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the actor started running"
          },
          "lastHeartbeat": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last heartbeat timestamp from the actor"
          },
          "loopIterations": {
            "type": "integer",
            "format": "int64",
            "description": "Number of behavior loop iterations executed"
          }
        }
      },
      "ActorSize": {
        "type": "string",
        "description": "Size classification affecting cover requirements and passage width",
        "enum": [
          "tiny",
          "small",
          "medium",
          "large",
          "huge"
        ],
        "default": "medium"
      },
      "ActorStatus": {
        "type": "string",
        "enum": [
          "pending",
          "starting",
          "running",
          "paused",
          "stopping",
          "stopped",
          "error"
        ],
        "description": "Current actor lifecycle state"
      },
      "ActorTemplateResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response containing actor template details",
        "required": [
          "templateId",
          "category",
          "behaviorRef",
          "tickIntervalMs",
          "autoSaveIntervalSeconds",
          "maxInstancesPerNode",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique template identifier"
          },
          "category": {
            "type": "string",
            "description": "Category identifier"
          },
          "behaviorRef": {
            "type": "string",
            "description": "Reference to behavior in lib-assets"
          },
          "configuration": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Default configuration passed to behavior execution"
          },
          "autoSpawn": {
            "description": "Auto-spawn configuration for instantiate-on-access",
            "nullable": true,
            "$ref": "#/components/schemas/AutoSpawnConfig"
          },
          "tickIntervalMs": {
            "type": "integer",
            "description": "Milliseconds between behavior loop iterations"
          },
          "autoSaveIntervalSeconds": {
            "type": "integer",
            "description": "Seconds between automatic state saves"
          },
          "maxInstancesPerNode": {
            "type": "integer",
            "description": "Maximum actors of this category per pool node"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the template was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the template was last updated"
          }
        }
      },
      "AddItemRequest": {
        "type": "object",
        "description": "Request to add item to container",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "containerId"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance ID to add"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Target container ID"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Specific slot (auto-assign if null)"
          },
          "slotX": {
            "type": "integer",
            "nullable": true,
            "description": "Grid X position"
          },
          "slotY": {
            "type": "integer",
            "nullable": true,
            "description": "Grid Y position"
          },
          "rotated": {
            "type": "boolean",
            "nullable": true,
            "description": "Rotate in grid"
          },
          "autoStack": {
            "type": "boolean",
            "default": true,
            "description": "Auto-merge with existing stacks"
          }
        }
      },
      "AddItemResponse": {
        "type": "object",
        "description": "Response after adding item",
        "additionalProperties": false,
        "required": [
          "success",
          "instanceId",
          "containerId"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether add succeeded"
          },
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Added item ID"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container ID"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Assigned slot"
          },
          "slotX": {
            "type": "integer",
            "nullable": true,
            "description": "Assigned X position"
          },
          "slotY": {
            "type": "integer",
            "nullable": true,
            "description": "Assigned Y position"
          },
          "mergedWithInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Instance merged into if stacked"
          }
        }
      },
      "Affordance": {
        "type": "object",
        "description": "Describes a capability or interaction mode for a node.\nUsed by AI systems to understand what actions are possible and by\ncharacter controllers for contextual animations.\n",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/AffordanceType",
            "description": "The type of affordance"
          },
          "parameters": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Type-specific parameters. Examples:\n- sittable: { height: 0.5, facing: [0,0,1] }\n- door: { openAngle: 90, locked: false }\n- container: { capacity: 10, itemTypes: [\"weapon\", \"consumable\"] }\n"
          }
        }
      },
      "AffordanceFreshness": {
        "type": "string",
        "description": "Controls caching behavior for affordance queries",
        "enum": [
          "fresh",
          "cached",
          "aggressive_cache"
        ],
        "default": "cached"
      },
      "AffordanceLocation": {
        "type": "object",
        "description": "A location that affords the requested action",
        "properties": {
          "position": {
            "$ref": "#/components/schemas/Position3D",
            "description": "Location position"
          },
          "bounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Area bounds if affordance spans an area",
            "nullable": true
          },
          "score": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "How well this location affords the action (0-1)"
          },
          "features": {
            "type": "object",
            "additionalProperties": true,
            "description": "What makes this location suitable.\nExample: { \"cover_rating\": 0.8, \"sightlines\": [\"north\"], \"terrain\": \"rocky\" }\n",
            "nullable": true
          },
          "objectIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Map objects contributing to this affordance",
            "nullable": true
          }
        }
      },
      "AffordanceQueryMetadata": {
        "type": "object",
        "description": "Metadata about the affordance query execution",
        "properties": {
          "kindsSearched": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Map kinds that were queried",
            "nullable": true
          },
          "objectsEvaluated": {
            "type": "integer",
            "description": "Number of candidate objects evaluated"
          },
          "candidatesGenerated": {
            "type": "integer",
            "description": "Number of candidate positions generated"
          },
          "searchDurationMs": {
            "type": "integer",
            "description": "Query execution time in milliseconds"
          },
          "cacheHit": {
            "type": "boolean",
            "description": "Whether results came from cache"
          }
        }
      },
      "AffordanceQueryRequest": {
        "type": "object",
        "description": "Query for locations that afford a specific action",
        "required": [
          "regionId",
          "affordanceType"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region to search"
          },
          "affordanceType": {
            "$ref": "#/components/schemas/AffordanceType",
            "description": "Type of affordance to search for"
          },
          "customAffordance": {
            "$ref": "#/components/schemas/CustomAffordance",
            "description": "Custom affordance definition (when affordanceType=custom)",
            "nullable": true
          },
          "bounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Optional bounds to search within",
            "nullable": true
          },
          "maxResults": {
            "type": "integer",
            "default": 10,
            "maximum": 100,
            "description": "Maximum locations to return"
          },
          "minScore": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "default": 0.5,
            "description": "Minimum affordance score to include"
          },
          "participantCount": {
            "type": "integer",
            "description": "Expected participants (affects space requirements)",
            "nullable": true
          },
          "excludePositions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Position3D"
            },
            "description": "Positions to exclude (e.g., player's current location)",
            "nullable": true
          },
          "actorCapabilities": {
            "$ref": "#/components/schemas/ActorCapabilities",
            "description": "Actor capabilities affecting evaluation",
            "nullable": true
          },
          "freshness": {
            "$ref": "#/components/schemas/AffordanceFreshness",
            "description": "Cache freshness level"
          },
          "maxAgeSeconds": {
            "type": "integer",
            "minimum": 0,
            "maximum": 3600,
            "description": "Max age of cached results (for cached/aggressive_cache)",
            "nullable": true
          }
        }
      },
      "AffordanceQueryResponse": {
        "type": "object",
        "description": "Affordance query results",
        "properties": {
          "locations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AffordanceLocation"
            },
            "description": "Scored locations (highest score first)"
          },
          "queryMetadata": {
            "$ref": "#/components/schemas/AffordanceQueryMetadata",
            "description": "Metadata about query execution (optional)",
            "nullable": true
          }
        }
      },
      "AffordanceType": {
        "type": "string",
        "description": "Well-known affordance types with predefined scoring logic.\nUse 'custom' for novel affordance definitions.\n",
        "enum": [
          "ambush",
          "shelter",
          "vista",
          "choke_point",
          "gathering_spot",
          "dramatic_reveal",
          "hidden_path",
          "defensible_position",
          "custom"
        ]
      },
      "Analytics": {
        "description": "Analytics and tracking configuration for website visitor metrics",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "googleAnalyticsId": {
            "type": "string",
            "nullable": true,
            "description": "Google Analytics tracking ID"
          },
          "otherTrackers": {
            "type": "object",
            "additionalProperties": true,
            "description": "Configuration for other analytics trackers"
          }
        }
      },
      "AnswerPeerRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to send an SDP answer to complete a WebRTC handshake.\nSent by clients after receiving a VoicePeerJoinedEvent with an SDP offer.\n",
        "required": [
          "roomId",
          "senderSessionId",
          "targetSessionId",
          "sdpAnswer"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Voice room ID"
          },
          "senderSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Session ID of the answering peer (caller of this endpoint)"
          },
          "targetSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Session ID of the peer whose offer we're answering"
          },
          "sdpAnswer": {
            "type": "string",
            "description": "SDP answer generated by this client's WebRTC stack"
          },
          "iceCandidates": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "ICE candidates for NAT traversal (can be trickled later)"
          }
        }
      },
      "ArchiveInfo": {
        "description": "Archive metadata including size and document count",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "archiveId",
          "namespace",
          "createdAt"
        ],
        "properties": {
          "archiveId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the archive"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace the archive belongs to"
          },
          "bundleAssetId": {
            "type": "string",
            "format": "uuid",
            "description": "Asset ID in Asset Service"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Description of the archive"
          },
          "documentCount": {
            "type": "integer",
            "description": "Number of documents in the archive"
          },
          "sizeBytes": {
            "type": "integer",
            "description": "Total size of the archive in bytes"
          },
          "commitHash": {
            "type": "string",
            "nullable": true,
            "description": "Git commit hash if namespace was bound at archive time"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the archive was created"
          },
          "owner": {
            "type": "string",
            "description": "Owner of this archive. NOT a session ID.\nContains either an accountId (UUID format) for user-initiated archives\nor a service name for service-initiated archives.\n"
          }
        }
      },
      "AssetConflict": {
        "type": "object",
        "additionalProperties": false,
        "description": "Describes a conflict when the same asset ID has different content hashes",
        "required": [
          "assetId",
          "conflictingBundles"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "The conflicting asset identifier"
          },
          "conflictingBundles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConflictingBundleEntry"
            },
            "description": "Bundles with conflicting versions of this asset"
          }
        }
      },
      "AssetMetadata": {
        "type": "object",
        "additionalProperties": false,
        "description": "Complete asset metadata including system-generated fields",
        "required": [
          "assetId",
          "contentHash",
          "filename",
          "contentType",
          "size",
          "assetType",
          "realm",
          "tags",
          "processingStatus",
          "isArchived",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Unique asset identifier"
          },
          "contentHash": {
            "type": "string",
            "description": "SHA256 hash of file contents"
          },
          "filename": {
            "type": "string",
            "description": "Original filename"
          },
          "contentType": {
            "type": "string",
            "description": "MIME content type"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "File size in bytes"
          },
          "assetType": {
            "$ref": "#/components/schemas/AssetType",
            "description": "Type classification for the asset"
          },
          "realm": {
            "$ref": "#/components/schemas/Realm",
            "description": "Game realm the asset belongs to"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Searchable tags for the asset"
          },
          "processingStatus": {
            "$ref": "#/components/schemas/ProcessingStatus",
            "description": "Current status of asset processing pipeline"
          },
          "isArchived": {
            "type": "boolean",
            "description": "Whether the asset is in cold/archival storage",
            "default": false
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the asset was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the asset was last updated"
          }
        }
      },
      "AssetMetadataInput": {
        "type": "object",
        "additionalProperties": false,
        "description": "User-provided metadata for asset categorization",
        "properties": {
          "assetType": {
            "$ref": "#/components/schemas/AssetType",
            "description": "Type classification for the asset"
          },
          "realm": {
            "$ref": "#/components/schemas/Realm",
            "description": "Game realm the asset belongs to"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Searchable tags for the asset"
          }
        }
      },
      "AssetReference": {
        "type": "object",
        "description": "Reference to an asset in lib-asset",
        "required": [
          "assetId"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional bundle containing the asset"
          },
          "assetId": {
            "type": "string",
            "format": "uuid",
            "description": "Asset identifier in lib-asset"
          },
          "variantId": {
            "type": "string",
            "nullable": true,
            "description": "Variant identifier (consumer interprets meaning)"
          }
        }
      },
      "AssetRequirementInfo": {
        "type": "object",
        "description": "Information about a required asset",
        "additionalProperties": false,
        "required": [
          "type",
          "code",
          "amount"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Asset type (currency, item, item_stack)"
          },
          "code": {
            "type": "string",
            "description": "Currency code or item template code"
          },
          "amount": {
            "type": "number",
            "description": "Amount or quantity required"
          }
        }
      },
      "AssetSearchRequest": {
        "description": "Search criteria for filtering assets with pagination",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "assetType",
          "realm"
        ],
        "properties": {
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by tags (assets must have all specified tags) (null to skip tag filtering)"
          },
          "assetType": {
            "$ref": "#/components/schemas/AssetType",
            "description": "Filter by asset type"
          },
          "realm": {
            "$ref": "#/components/schemas/Realm",
            "description": "Filter by game realm"
          },
          "contentType": {
            "type": "string",
            "nullable": true,
            "description": "MIME content type filter (null to skip content type filtering)"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Maximum number of results to return"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Number of results to skip for pagination"
          }
        }
      },
      "AssetSearchResult": {
        "description": "Paginated results from an asset search query",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "assets",
          "total",
          "limit",
          "offset"
        ],
        "properties": {
          "assets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetMetadata"
            },
            "description": "List of matching assets"
          },
          "total": {
            "type": "integer",
            "description": "Total number of matching assets"
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of results returned per page"
          },
          "offset": {
            "type": "integer",
            "description": "Number of results skipped"
          }
        }
      },
      "AssetSlot": {
        "type": "object",
        "description": "Defines acceptable asset types for procedural swapping at this node.\nUsed by procedural generation systems to substitute assets while\nmaintaining scene coherence.\n",
        "required": [
          "slotType"
        ],
        "properties": {
          "slotType": {
            "type": "string",
            "description": "Category of acceptable assets.\nExamples: chair, table, wall_art, floor_lamp\n"
          },
          "acceptsTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tags that acceptable assets must have.\nUsed for filtering when selecting random variations.\n"
          },
          "defaultAsset": {
            "$ref": "#/components/schemas/AssetReference",
            "nullable": true,
            "description": "Default asset if no specific asset is bound"
          },
          "variations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReference"
            },
            "description": "Pre-approved asset variations for random selection.\nProcedural systems pick from this list rather than searching all assets.\n"
          }
        }
      },
      "AssetType": {
        "type": "string",
        "enum": [
          "texture",
          "model",
          "audio",
          "behavior",
          "bundle",
          "prefab",
          "other"
        ],
        "description": "Type classification for assets"
      },
      "AssetUsageInfo": {
        "type": "object",
        "description": "Information about asset usage",
        "required": [
          "sceneId",
          "sceneName",
          "nodeId",
          "nodeRefId"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene using the asset"
          },
          "sceneName": {
            "type": "string",
            "description": "Scene name"
          },
          "nodeId": {
            "type": "string",
            "format": "uuid",
            "description": "Node using the asset"
          },
          "nodeRefId": {
            "type": "string",
            "description": "refId of the node"
          },
          "nodeName": {
            "type": "string",
            "description": "Node name"
          },
          "nodeType": {
            "$ref": "#/components/schemas/NodeType",
            "description": "Type of the node"
          }
        }
      },
      "AssetVersion": {
        "description": "Metadata for a specific version of an asset",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "versionId",
          "createdAt",
          "size",
          "isArchived"
        ],
        "properties": {
          "versionId": {
            "type": "string",
            "description": "Unique version identifier"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when this version was created"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "File size in bytes for this version"
          },
          "isArchived": {
            "type": "boolean",
            "description": "Whether this version is in cold storage"
          }
        }
      },
      "AssetVersionList": {
        "description": "Paginated list of asset versions",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "assetId",
          "versions",
          "total",
          "limit",
          "offset"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Asset identifier"
          },
          "versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetVersion"
            },
            "description": "List of asset versions"
          },
          "total": {
            "type": "integer",
            "description": "Total number of versions available"
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of versions returned per page"
          },
          "offset": {
            "type": "integer",
            "description": "Number of versions skipped"
          }
        }
      },
      "AssetWithDownloadUrl": {
        "description": "Asset metadata with optional pre-signed download URL",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "assetId",
          "versionId",
          "size",
          "contentHash",
          "contentType",
          "metadata"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Unique asset identifier"
          },
          "versionId": {
            "type": "string",
            "description": "Version identifier for this specific asset version"
          },
          "downloadUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "Pre-signed download URL (only populated when requested)"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the download URL expires (only populated when requested)"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "File size in bytes"
          },
          "contentHash": {
            "type": "string",
            "description": "SHA256 hash of file contents"
          },
          "contentType": {
            "type": "string",
            "description": "MIME content type"
          },
          "metadata": {
            "$ref": "#/components/schemas/AssetMetadata",
            "description": "Complete asset metadata"
          }
        }
      },
      "AttachmentPoint": {
        "type": "object",
        "description": "A predefined location where child objects can be attached.\nUsed for decorating furniture, walls, and other objects with accessories.\nExample: A wall may have attachment points for paintings, shelves, or light fixtures.\n",
        "required": [
          "name",
          "localTransform"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Unique name for this attachment point within the node.\nExamples: wall_hook_left, shelf_1, lamp_socket\n"
          },
          "localTransform": {
            "$ref": "#/components/schemas/Transform",
            "description": "Position and orientation relative to the owning node"
          },
          "acceptsTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tags of assets that can attach here.\nExamples: wall_decoration, picture_frame, plant\n"
          },
          "defaultAsset": {
            "$ref": "#/components/schemas/AssetReference",
            "nullable": true,
            "description": "Default asset to display if no specific attachment is specified"
          },
          "attachedNodeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of the node currently attached at this point (runtime state)"
          }
        }
      },
      "AuthMethodInfo": {
        "type": "object",
        "description": "Information about a linked authentication method",
        "additionalProperties": false,
        "required": [
          "provider",
          "linkedAt"
        ],
        "properties": {
          "methodId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Unique identifier for the authentication method"
          },
          "provider": {
            "$ref": "#/components/schemas/AuthProvider",
            "description": "Authentication provider type"
          },
          "externalId": {
            "type": "string",
            "nullable": true,
            "description": "External user ID from the authentication provider"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Display name from the authentication provider"
          },
          "linkedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the authentication method was linked"
          }
        }
      },
      "AuthProvider": {
        "type": "string",
        "description": "All authentication provider types including email",
        "enum": [
          "email",
          "google",
          "discord",
          "twitch",
          "steam"
        ]
      },
      "AuthResponse": {
        "description": "Successful authentication response containing tokens and session information",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "accountId",
          "accessToken",
          "refreshToken",
          "expiresIn",
          "connectUrl"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the authenticated account"
          },
          "accessToken": {
            "type": "string",
            "description": "JWT access token for API authentication"
          },
          "refreshToken": {
            "type": "string",
            "description": "Token used to obtain new access tokens when the current one expires"
          },
          "expiresIn": {
            "type": "integer",
            "description": "Seconds until access token expires"
          },
          "connectUrl": {
            "type": "string",
            "format": "uri",
            "description": "WebSocket endpoint for Connect service"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "List of roles assigned to the authenticated user"
          },
          "requiresTwoFactor": {
            "type": "boolean",
            "default": false,
            "description": "Whether the user needs to complete two-factor authentication"
          }
        }
      },
      "AuthoringCheckoutRequest": {
        "type": "object",
        "description": "Request to checkout for authoring",
        "required": [
          "regionId",
          "kind",
          "editorId"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region to checkout"
          },
          "kind": {
            "$ref": "#/components/schemas/MapKind",
            "description": "Map kind to checkout"
          },
          "editorId": {
            "type": "string",
            "description": "Identifier for the editor/user"
          }
        }
      },
      "AuthoringCheckoutResponse": {
        "type": "object",
        "description": "Checkout response",
        "properties": {
          "authorityToken": {
            "type": "string",
            "description": "Token for publishing changes (if successful)",
            "nullable": true
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the checkout expires",
            "nullable": true
          },
          "lockedBy": {
            "type": "string",
            "description": "Who has the lock (if checkout failed)",
            "nullable": true
          },
          "lockedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the lock was acquired (if checkout failed)",
            "nullable": true
          }
        }
      },
      "AuthoringCommitRequest": {
        "type": "object",
        "description": "Request to commit authoring changes",
        "required": [
          "regionId",
          "kind",
          "authorityToken"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region being edited"
          },
          "kind": {
            "$ref": "#/components/schemas/MapKind",
            "description": "Map kind being edited"
          },
          "authorityToken": {
            "type": "string",
            "description": "Checkout authority token"
          },
          "commitMessage": {
            "type": "string",
            "description": "Optional commit message for history",
            "nullable": true
          }
        }
      },
      "AuthoringCommitResponse": {
        "type": "object",
        "description": "Commit response",
        "properties": {
          "version": {
            "type": "integer",
            "format": "int64",
            "description": "Committed version number",
            "nullable": true
          }
        }
      },
      "AuthoringReleaseRequest": {
        "type": "object",
        "description": "Request to release authoring checkout",
        "required": [
          "regionId",
          "kind",
          "authorityToken"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region being edited"
          },
          "kind": {
            "$ref": "#/components/schemas/MapKind",
            "description": "Map kind being edited"
          },
          "authorityToken": {
            "type": "string",
            "description": "Checkout authority token"
          }
        }
      },
      "AuthoringReleaseResponse": {
        "type": "object",
        "description": "Release response",
        "properties": {
          "released": {
            "type": "boolean",
            "description": "Whether checkout was released"
          }
        }
      },
      "AutoSpawnConfig": {
        "type": "object",
        "additionalProperties": false,
        "description": "Configuration for instantiate-on-access behavior",
        "properties": {
          "enabled": {
            "type": "boolean",
            "default": false,
            "description": "If true, accessing a non-existent actor creates it"
          },
          "idPattern": {
            "type": "string",
            "nullable": true,
            "description": "Regex pattern for actor IDs that trigger auto-spawn.\nExamples: \"npc-.*\" matches \"npc-grok\", \"npc-merchant-123\"\n"
          },
          "maxInstances": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum auto-spawned instances (0 = unlimited)"
          },
          "characterIdCaptureGroup": {
            "type": "integer",
            "minimum": 1,
            "nullable": true,
            "description": "1-based regex capture group index for extracting CharacterId from actor ID.\nExample: With idPattern \"npc-brain-([a-f0-9-]+)\" and characterIdCaptureGroup: 1,\nactor ID \"npc-brain-abc-123-def\" extracts \"abc-123-def\" as CharacterId (parsed as GUID).\n"
          }
        }
      },
      "AutogainInfo": {
        "type": "object",
        "description": "Autogain status for a balance",
        "additionalProperties": false,
        "required": [
          "lastCalculatedAt",
          "nextGainAt",
          "nextGainAmount",
          "mode"
        ],
        "properties": {
          "lastCalculatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When autogain was last calculated"
          },
          "nextGainAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the next autogain will apply"
          },
          "nextGainAmount": {
            "type": "number",
            "format": "double",
            "description": "Estimated next gain amount"
          },
          "mode": {
            "$ref": "#/components/schemas/AutogainMode",
            "description": "Current autogain mode"
          }
        }
      },
      "AutogainMode": {
        "type": "string",
        "description": "How autogain (energy/interest) is calculated",
        "enum": [
          "simple",
          "compound"
        ]
      },
      "BackstoryElement": {
        "type": "object",
        "description": "A machine-readable backstory element for behavior system consumption",
        "additionalProperties": false,
        "required": [
          "elementType",
          "key",
          "value"
        ],
        "properties": {
          "elementType": {
            "$ref": "#/components/schemas/BackstoryElementType",
            "description": "Category of this backstory element"
          },
          "key": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Machine-readable key (e.g., \"homeland\", \"trained_by\", \"past_job\").\nUsed by behavior system to query specific aspects.\n"
          },
          "value": {
            "type": "string",
            "minLength": 1,
            "maxLength": 500,
            "description": "Machine-readable value (e.g., \"northlands\", \"knights_guild\", \"blacksmith\").\nReferenced in behavior rules.\n"
          },
          "strength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.5,
            "description": "How strongly this element affects behavior (0.0 to 1.0).\nHigher strength = greater influence on decisions.\n"
          },
          "relatedEntityId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional related entity (location, organization, character)"
          },
          "relatedEntityType": {
            "type": "string",
            "nullable": true,
            "description": "Type of the related entity (if any)"
          }
        }
      },
      "BackstoryElementSnapshot": {
        "description": "Single backstory element",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "elementType",
          "key",
          "value",
          "strength"
        ],
        "properties": {
          "elementType": {
            "type": "string",
            "description": "Type of backstory element (ORIGIN, TRAUMA, GOAL, etc.)"
          },
          "key": {
            "type": "string",
            "description": "Machine-readable key (homeland, past_job, etc.)"
          },
          "value": {
            "type": "string",
            "description": "Machine-readable value (northlands, blacksmith, etc.)"
          },
          "strength": {
            "type": "number",
            "format": "float",
            "description": "How strongly this affects behavior (0.0 to 1.0)"
          }
        }
      },
      "BackstoryElementType": {
        "type": "string",
        "description": "Types of backstory elements. Each type represents a different aspect\nof the character's background that influences behavior.\n",
        "enum": [
          "ORIGIN",
          "OCCUPATION",
          "TRAINING",
          "TRAUMA",
          "ACHIEVEMENT",
          "SECRET",
          "GOAL",
          "FEAR",
          "BELIEF"
        ]
      },
      "BackstoryResponse": {
        "type": "object",
        "description": "Complete backstory data for a character",
        "additionalProperties": false,
        "required": [
          "characterId",
          "elements"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character this backstory belongs to"
          },
          "elements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BackstoryElement"
            },
            "description": "All backstory elements for this character"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this backstory was first created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this backstory was last modified"
          }
        }
      },
      "BackstorySnapshot": {
        "description": "Snapshot of backstory for enriched response",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "elements"
        ],
        "properties": {
          "elements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BackstoryElementSnapshot"
            },
            "description": "List of backstory elements"
          }
        }
      },
      "BalanceQuery": {
        "type": "object",
        "description": "A single balance query",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency definition ID"
          }
        }
      },
      "BalanceSummary": {
        "type": "object",
        "description": "Summary of a balance in a wallet",
        "additionalProperties": false,
        "required": [
          "currencyDefinitionId",
          "currencyCode",
          "amount",
          "lockedAmount",
          "effectiveAmount"
        ],
        "properties": {
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency definition ID"
          },
          "currencyCode": {
            "type": "string",
            "description": "Currency code for convenience"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Total balance amount"
          },
          "lockedAmount": {
            "type": "number",
            "format": "double",
            "description": "Amount reserved by authorization holds"
          },
          "effectiveAmount": {
            "type": "number",
            "format": "double",
            "description": "Available balance (amount - lockedAmount)"
          }
        }
      },
      "BatchBalanceResult": {
        "type": "object",
        "description": "Result of a single balance query in a batch",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "lockedAmount",
          "effectiveAmount"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency definition ID"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Total balance"
          },
          "lockedAmount": {
            "type": "number",
            "format": "double",
            "description": "Amount in holds"
          },
          "effectiveAmount": {
            "type": "number",
            "format": "double",
            "description": "Available balance"
          }
        }
      },
      "BatchCreditOperation": {
        "type": "object",
        "description": "A single credit operation in a batch",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "transactionType"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Target wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to credit"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to credit"
          },
          "transactionType": {
            "$ref": "#/components/schemas/TransactionType",
            "description": "Faucet transaction type"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "Reference type"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference ID"
          }
        }
      },
      "BatchCreditRequest": {
        "type": "object",
        "description": "Request to credit multiple wallets",
        "additionalProperties": false,
        "required": [
          "operations",
          "idempotencyKey"
        ],
        "properties": {
          "operations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BatchCreditOperation"
            },
            "minItems": 1,
            "maxItems": 100,
            "description": "Credit operations to execute"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Unique key covering the entire batch"
          }
        }
      },
      "BatchCreditResponse": {
        "type": "object",
        "description": "Results of batch credit operations",
        "additionalProperties": false,
        "required": [
          "results"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BatchCreditResult"
            },
            "description": "Results for each operation"
          }
        }
      },
      "BatchCreditResult": {
        "type": "object",
        "description": "Result of a single credit in a batch",
        "additionalProperties": false,
        "required": [
          "index",
          "success"
        ],
        "properties": {
          "index": {
            "type": "integer",
            "description": "Index in the operations array"
          },
          "success": {
            "type": "boolean",
            "description": "Whether the operation succeeded"
          },
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "nullable": true,
            "description": "Transaction record if successful"
          },
          "error": {
            "type": "string",
            "nullable": true,
            "description": "Error code if failed"
          }
        }
      },
      "BatchGetBalancesRequest": {
        "type": "object",
        "description": "Request to get multiple balances",
        "additionalProperties": false,
        "required": [
          "queries"
        ],
        "properties": {
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BalanceQuery"
            },
            "minItems": 1,
            "maxItems": 100,
            "description": "Balance queries to execute"
          }
        }
      },
      "BatchGetBalancesResponse": {
        "type": "object",
        "description": "Results of batch balance queries",
        "additionalProperties": false,
        "required": [
          "balances"
        ],
        "properties": {
          "balances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BatchBalanceResult"
            },
            "description": "Balance results (same order as queries)"
          }
        }
      },
      "BatchGetItemInstancesRequest": {
        "type": "object",
        "description": "Request to get multiple item instances",
        "additionalProperties": false,
        "required": [
          "instanceIds"
        ],
        "properties": {
          "instanceIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "maxItems": 100,
            "description": "Instance IDs to retrieve"
          }
        }
      },
      "BatchGetItemInstancesResponse": {
        "type": "object",
        "description": "Multiple item instances",
        "additionalProperties": false,
        "required": [
          "items",
          "notFound"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ItemInstanceResponse"
            },
            "description": "Found items"
          },
          "notFound": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Instance IDs that were not found"
          }
        }
      },
      "BehaviorTreeData": {
        "type": "object",
        "additionalProperties": false,
        "description": "Compiled behavior tree data with bytecode or download reference",
        "properties": {
          "bytecode": {
            "type": "string",
            "nullable": true,
            "description": "Base64-encoded compiled bytecode for the behavior tree"
          },
          "bytecodeSize": {
            "type": "integer",
            "description": "Size of the bytecode in bytes"
          },
          "downloadUrl": {
            "type": "string",
            "nullable": true,
            "description": "URL to download the compiled behavior asset"
          }
        }
      },
      "BindItemInstanceRequest": {
        "type": "object",
        "description": "Request to bind an item to a character",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "characterId"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Instance ID to bind"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to bind the item to"
          },
          "bindType": {
            "$ref": "#/components/schemas/SoulboundType",
            "description": "Type of binding to apply"
          }
        }
      },
      "BindRepositoryRequest": {
        "description": "Request to bind a Git repository for automatic documentation sync",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "repositoryUrl",
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "string",
            "description": "Owner of this binding. NOT a session ID.\nFor user-initiated bindings: the accountId (UUID format).\nFor service-initiated bindings: the service name (e.g., \"orchestrator\").\n"
          },
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to bind"
          },
          "repositoryUrl": {
            "type": "string",
            "description": "Git clone URL (HTTPS for public repos)"
          },
          "branch": {
            "type": "string",
            "default": "main",
            "description": "Branch to sync from"
          },
          "syncIntervalMinutes": {
            "type": "integer",
            "default": 60,
            "minimum": 5,
            "maximum": 1440,
            "description": "How often to sync (5 min to 24 hours)"
          },
          "filePatterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": [
              "**/*.md"
            ],
            "description": "Glob patterns for files to include"
          },
          "excludePatterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": [
              ".git/**",
              ".obsidian/**",
              "node_modules/**"
            ],
            "description": "Glob patterns for files to exclude"
          },
          "categoryMapping": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Map directory prefixes to categories"
          },
          "defaultCategory": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "Default category for documents without mapping"
          },
          "archiveEnabled": {
            "type": "boolean",
            "default": false,
            "description": "Enable archive functionality"
          },
          "archiveOnSync": {
            "type": "boolean",
            "default": false,
            "description": "Create archive after each sync"
          }
        }
      },
      "BindRepositoryResponse": {
        "description": "Response confirming repository binding creation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bindingId",
          "namespace",
          "status"
        ],
        "properties": {
          "bindingId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the repository binding"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace the repository is bound to"
          },
          "repositoryUrl": {
            "type": "string",
            "description": "URL of the bound repository"
          },
          "branch": {
            "type": "string",
            "description": "Branch being synced"
          },
          "status": {
            "$ref": "#/components/schemas/BindingStatus",
            "description": "Current status of the binding"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the binding was created"
          }
        }
      },
      "BindingStatus": {
        "type": "string",
        "enum": [
          "pending",
          "syncing",
          "synced",
          "error",
          "disabled"
        ],
        "description": "Status of a repository binding"
      },
      "Bounds": {
        "type": "object",
        "description": "An axis-aligned bounding box in 3D space",
        "required": [
          "min",
          "max"
        ],
        "properties": {
          "min": {
            "$ref": "#/components/schemas/Position3D",
            "description": "Minimum corner (lowest x, y, z values)"
          },
          "max": {
            "$ref": "#/components/schemas/Position3D",
            "description": "Maximum corner (highest x, y, z values)"
          }
        }
      },
      "BreachResponse": {
        "type": "object",
        "description": "Breach record details",
        "additionalProperties": false,
        "required": [
          "breachId",
          "contractId",
          "breachingEntityId",
          "breachingEntityType",
          "breachType",
          "status",
          "detectedAt"
        ],
        "properties": {
          "breachId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique breach identifier"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract that was breached"
          },
          "breachingEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity that breached"
          },
          "breachingEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of breaching entity"
          },
          "breachType": {
            "$ref": "#/components/schemas/BreachType",
            "description": "Type of breach"
          },
          "breachedTermOrMilestone": {
            "type": "string",
            "nullable": true,
            "description": "What was breached"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Breach description"
          },
          "status": {
            "$ref": "#/components/schemas/BreachStatus",
            "description": "Current status"
          },
          "detectedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When breach was detected"
          },
          "cureDeadline": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Deadline to cure breach"
          },
          "curedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When breach was cured"
          },
          "consequencesAppliedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When consequences were applied"
          }
        }
      },
      "BreachStatus": {
        "type": "string",
        "description": "Current status of a breach record",
        "enum": [
          "detected",
          "cure_period",
          "cured",
          "consequences_applied",
          "disputed",
          "forgiven"
        ]
      },
      "BreachSummary": {
        "type": "object",
        "description": "Brief breach information",
        "additionalProperties": false,
        "required": [
          "breachId",
          "breachType",
          "status"
        ],
        "properties": {
          "breachId": {
            "type": "string",
            "format": "uuid",
            "description": "Breach ID"
          },
          "breachType": {
            "$ref": "#/components/schemas/BreachType",
            "description": "Type of breach"
          },
          "status": {
            "$ref": "#/components/schemas/BreachStatus",
            "description": "Current status"
          }
        }
      },
      "BreachType": {
        "type": "string",
        "description": "Type of contract breach",
        "enum": [
          "term_violation",
          "milestone_missed",
          "unauthorized_action",
          "non_payment"
        ]
      },
      "BulkGetAssetsRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to retrieve metadata for multiple assets",
        "required": [
          "assetIds"
        ],
        "properties": {
          "assetIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Asset IDs to retrieve (max 100)"
          },
          "includeDownloadUrls": {
            "type": "boolean",
            "default": false,
            "description": "Whether to generate pre-signed download URLs"
          }
        }
      },
      "BulkGetAssetsResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Batch asset metadata response",
        "required": [
          "assets",
          "notFound"
        ],
        "properties": {
          "assets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetWithDownloadUrl"
            },
            "description": "Found assets with metadata"
          },
          "notFound": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Asset IDs that weren't found"
          }
        }
      },
      "BundleFormat": {
        "type": "string",
        "enum": [
          "bannou",
          "zip"
        ],
        "description": "Bundle file format"
      },
      "BundleInfo": {
        "type": "object",
        "additionalProperties": false,
        "description": "Complete metadata for an asset bundle (API response model)",
        "required": [
          "bundleId",
          "bundleType",
          "version",
          "metadataVersion",
          "realm",
          "status",
          "assetCount",
          "createdAt"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Unique bundle identifier"
          },
          "bundleType": {
            "$ref": "#/components/schemas/BundleType",
            "description": "Whether source or metabundle"
          },
          "version": {
            "type": "string",
            "description": "Bundle content version string"
          },
          "metadataVersion": {
            "type": "integer",
            "description": "Metadata version number (increments on metadata changes)"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable bundle name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Bundle description"
          },
          "owner": {
            "type": "string",
            "nullable": true,
            "description": "Owner account ID or service name (null for system-owned bundles)"
          },
          "realm": {
            "$ref": "#/components/schemas/Realm",
            "description": "Game realm this bundle belongs to"
          },
          "tags": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Key-value tags for categorization and filtering"
          },
          "status": {
            "$ref": "#/components/schemas/BundleLifecycle",
            "description": "Bundle lifecycle status"
          },
          "assetCount": {
            "type": "integer",
            "description": "Number of assets in the bundle"
          },
          "sizeBytes": {
            "type": "integer",
            "format": "int64",
            "nullable": true,
            "description": "Bundle file size in bytes (null if not yet calculated)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the bundle was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the bundle metadata was last updated"
          },
          "deletedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the bundle was soft-deleted (null if active)"
          }
        }
      },
      "BundleLifecycle": {
        "type": "string",
        "enum": [
          "active",
          "deleted",
          "processing"
        ],
        "description": "Bundle lifecycle status:\n- active: Bundle is available for use\n- deleted: Bundle has been soft-deleted (within retention period)\n- processing: Bundle is being processed (metabundle creation)\n"
      },
      "BundleManifestPreview": {
        "type": "object",
        "additionalProperties": false,
        "description": "Preview of bundle manifest for validation",
        "required": [
          "bundleId",
          "version",
          "assetCount"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Bundle identifier from the manifest"
          },
          "version": {
            "type": "string",
            "description": "Bundle version from the manifest"
          },
          "assetCount": {
            "type": "integer",
            "description": "Number of assets declared in the manifest"
          }
        }
      },
      "BundleSummary": {
        "type": "object",
        "additionalProperties": false,
        "description": "Summary information about a bundle",
        "required": [
          "bundleId",
          "bundleType",
          "version",
          "assetCount",
          "realm"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Bundle identifier"
          },
          "bundleType": {
            "$ref": "#/components/schemas/BundleType",
            "description": "Source or metabundle"
          },
          "version": {
            "type": "string",
            "description": "Bundle version"
          },
          "assetCount": {
            "type": "integer",
            "description": "Number of assets in bundle"
          },
          "sizeBytes": {
            "type": "integer",
            "format": "int64",
            "nullable": true,
            "description": "Bundle file size"
          },
          "realm": {
            "$ref": "#/components/schemas/Realm",
            "description": "Game realm"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the bundle was created"
          }
        }
      },
      "BundleType": {
        "type": "string",
        "enum": [
          "source",
          "metabundle"
        ],
        "description": "Bundle category:\n- source: Original bundle (uploaded or server-created from assets)\n- metabundle: Composed from other bundles server-side\n"
      },
      "BundleUploadRequest": {
        "description": "Request to upload a pre-built asset bundle file",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "filename",
          "size",
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "string",
            "description": "Owner of this bundle upload. NOT a session ID.\nFor user-initiated uploads: the accountId (UUID format).\nFor service-initiated uploads: the service name (e.g., \"orchestrator\").\n"
          },
          "filename": {
            "type": "string",
            "description": "Must end with .bannou or .zip"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "Bundle file size in bytes"
          },
          "manifestPreview": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BundleManifestPreview"
              }
            ],
            "nullable": true,
            "description": "Optional preview of bundle manifest for validation"
          }
        }
      },
      "BundleVersionRecord": {
        "type": "object",
        "additionalProperties": false,
        "description": "A single version record in bundle history",
        "required": [
          "version",
          "createdAt",
          "createdBy",
          "changes"
        ],
        "properties": {
          "version": {
            "type": "integer",
            "description": "Version number"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this version was created"
          },
          "createdBy": {
            "type": "string",
            "description": "Account ID that made the change"
          },
          "changes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of changes in this version"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Reason provided for the change"
          },
          "snapshot": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BundleInfo"
              }
            ],
            "nullable": true,
            "description": "Full metadata snapshot at this version (only for current version)"
          }
        }
      },
      "BundleWithDownloadUrl": {
        "description": "Bundle metadata combined with a pre-signed download URL",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bundleId",
          "version",
          "downloadUrl",
          "format",
          "expiresAt",
          "size",
          "assetCount",
          "fromCache"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Unique bundle identifier"
          },
          "version": {
            "type": "string",
            "description": "Bundle version string"
          },
          "downloadUrl": {
            "type": "string",
            "format": "uri",
            "description": "Pre-signed URL for downloading the bundle"
          },
          "format": {
            "$ref": "#/components/schemas/BundleFormat",
            "description": "Format of the downloadable bundle"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the download URL expires"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "Bundle file size in bytes"
          },
          "assetCount": {
            "type": "integer",
            "description": "Number of assets contained in the bundle"
          },
          "fromCache": {
            "type": "boolean",
            "description": "True if ZIP format was served from conversion cache"
          }
        }
      },
      "CachedBehaviorResponse": {
        "description": "Response containing a previously compiled behavior retrieved from cache",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "behaviorId",
          "compiledBehavior"
        ],
        "properties": {
          "behaviorId": {
            "type": "string",
            "description": "Unique identifier for the cached behavior"
          },
          "compiledBehavior": {
            "$ref": "#/components/schemas/CompiledBehavior",
            "description": "The compiled behavior data retrieved from cache"
          },
          "cacheTimestamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the behavior was cached"
          },
          "cacheHit": {
            "type": "boolean",
            "description": "Whether this was a cache hit or miss"
          }
        }
      },
      "CadenceInfo": {
        "description": "Information about a cadence",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "type",
          "position"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "authentic",
              "half",
              "plagal",
              "deceptive"
            ],
            "description": "Cadence type"
          },
          "position": {
            "type": "integer",
            "description": "Chord index where cadence ends"
          },
          "strength": {
            "type": "string",
            "enum": [
              "perfect",
              "imperfect"
            ],
            "nullable": true,
            "description": "Cadence strength"
          }
        }
      },
      "CalculateConversionRequest": {
        "type": "object",
        "description": "Request to preview a currency conversion",
        "additionalProperties": false,
        "required": [
          "fromCurrencyId",
          "toCurrencyId",
          "fromAmount"
        ],
        "properties": {
          "fromCurrencyId": {
            "type": "string",
            "format": "uuid",
            "description": "Source currency definition ID"
          },
          "toCurrencyId": {
            "type": "string",
            "format": "uuid",
            "description": "Target currency definition ID"
          },
          "fromAmount": {
            "type": "number",
            "format": "double",
            "description": "Amount to convert"
          }
        }
      },
      "CalculateConversionResponse": {
        "type": "object",
        "description": "Conversion preview result",
        "additionalProperties": false,
        "required": [
          "toAmount",
          "effectiveRate",
          "baseCurrency"
        ],
        "properties": {
          "toAmount": {
            "type": "number",
            "format": "double",
            "description": "Amount that would be received"
          },
          "effectiveRate": {
            "type": "number",
            "format": "double",
            "description": "Effective conversion rate applied"
          },
          "conversionPath": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConversionStep"
            },
            "description": "Steps in the conversion"
          },
          "baseCurrency": {
            "type": "string",
            "description": "Base currency used for conversion"
          }
        }
      },
      "CancelJobRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to cancel an async metabundle creation job",
        "required": [
          "jobId"
        ],
        "properties": {
          "jobId": {
            "type": "string",
            "format": "uuid",
            "description": "Job ID from the createMetabundle response"
          }
        }
      },
      "CancelJobResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of job cancellation attempt",
        "required": [
          "jobId",
          "cancelled",
          "status"
        ],
        "properties": {
          "jobId": {
            "type": "string",
            "format": "uuid",
            "description": "Job identifier"
          },
          "cancelled": {
            "type": "boolean",
            "description": "Whether the job was successfully cancelled"
          },
          "status": {
            "type": "string",
            "enum": [
              "queued",
              "processing",
              "ready",
              "failed",
              "cancelled"
            ],
            "description": "Current job status after cancellation attempt"
          },
          "message": {
            "type": "string",
            "nullable": true,
            "description": "Additional context about the cancellation result"
          }
        }
      },
      "CancelRequest": {
        "type": "object",
        "description": "Request to cancel escrow before fully funded",
        "required": [
          "escrowId",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Reason for cancellation"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "CancelResponse": {
        "type": "object",
        "description": "Response from cancelling an escrow",
        "required": [
          "escrow",
          "refunds"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Cancelled escrow agreement"
          },
          "refunds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RefundResult"
            },
            "description": "Refund results for any deposits"
          }
        }
      },
      "CancelSubscriptionRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to cancel a subscription",
        "required": [
          "subscriptionId"
        ],
        "properties": {
          "subscriptionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the subscription to cancel"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "maxLength": 500,
            "description": "Optional reason for cancellation"
          }
        }
      },
      "CapOverflowBehavior": {
        "type": "string",
        "description": "What happens when a credit would exceed the wallet cap",
        "enum": [
          "reject",
          "cap_and_lose",
          "cap_and_return"
        ]
      },
      "CaptureHoldRequest": {
        "type": "object",
        "description": "Request to capture (finalize) a hold",
        "additionalProperties": false,
        "required": [
          "holdId",
          "captureAmount",
          "idempotencyKey"
        ],
        "properties": {
          "holdId": {
            "type": "string",
            "format": "uuid",
            "description": "Hold ID to capture"
          },
          "captureAmount": {
            "type": "number",
            "format": "double",
            "description": "Final amount to debit (may be less than hold amount)"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Idempotency key"
          }
        }
      },
      "CaptureHoldResponse": {
        "type": "object",
        "description": "Result of hold capture",
        "additionalProperties": false,
        "required": [
          "hold",
          "transaction",
          "newBalance",
          "amountReleased"
        ],
        "properties": {
          "hold": {
            "$ref": "#/components/schemas/HoldRecord",
            "description": "Updated hold record"
          },
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Debit transaction"
          },
          "newBalance": {
            "type": "number",
            "format": "double",
            "description": "Balance after capture"
          },
          "amountReleased": {
            "type": "number",
            "format": "double",
            "description": "Difference between hold and capture (released back)"
          }
        }
      },
      "CharacterArchive": {
        "description": "Compressed archive of a dead character.\nContains text summaries instead of structured data for long-term storage.\nSelf-contained with no external references (suitable for cleanup).\n",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId",
          "name",
          "realmId",
          "speciesId",
          "birthDate",
          "deathDate",
          "compressedAt"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Original character ID"
          },
          "name": {
            "type": "string",
            "description": "Character display name"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm the character belonged to"
          },
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "description": "Character's species"
          },
          "birthDate": {
            "type": "string",
            "format": "date-time",
            "description": "In-game birth date"
          },
          "deathDate": {
            "type": "string",
            "format": "date-time",
            "description": "In-game death date"
          },
          "compressedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this archive was created"
          },
          "personalitySummary": {
            "type": "string",
            "nullable": true,
            "description": "Text summary of personality traits.\nExample: \"Brave and loyal, somewhat hot-tempered with a strong sense of justice\"\n"
          },
          "keyBackstoryPoints": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Key backstory elements as text.\nExample: [\"Trained by the Knights Guild\", \"Born in the Northlands\"]\n"
          },
          "majorLifeEvents": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Significant life events as text.\nExample: [\"Fought in the Battle of Stormgate (Hero)\", \"Survived the Great Flood\"]\n"
          },
          "familySummary": {
            "type": "string",
            "nullable": true,
            "description": "Text summary of family relationships.\nExample: \"Father of 3, married to Elena, orphaned at young age\"\n"
          }
        }
      },
      "CharacterContext": {
        "type": "object",
        "additionalProperties": false,
        "description": "Context information about a character for behavior resolution",
        "properties": {
          "npcId": {
            "type": "string",
            "nullable": true,
            "description": "Unique identifier for the NPC",
            "example": "npc_12345"
          },
          "culture": {
            "type": "string",
            "nullable": true,
            "description": "Cultural background identifier",
            "example": "european_medieval"
          },
          "profession": {
            "type": "string",
            "nullable": true,
            "description": "Character profession identifier",
            "example": "blacksmith"
          },
          "stats": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            },
            "nullable": true,
            "description": "Character statistics and attributes",
            "example": {
              "energy": 0.8,
              "health": 1.0,
              "hunger": 0.3
            }
          },
          "skills": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            },
            "nullable": true,
            "description": "Character skill levels",
            "example": {
              "blacksmithing": 85,
              "trading": 42
            }
          },
          "location": {
            "$ref": "#/components/schemas/Location",
            "nullable": true,
            "description": "Current location information for the character"
          },
          "relationships": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            },
            "nullable": true,
            "description": "Relationship values with other characters"
          },
          "worldState": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Relevant world state information"
          }
        }
      },
      "CharacterListResponse": {
        "description": "Paginated list of characters with metadata for navigation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characters",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "characters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CharacterResponse"
            },
            "description": "List of characters matching the query"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of characters matching the filter criteria"
          },
          "page": {
            "type": "integer",
            "description": "Current page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether there are more results after this page"
          },
          "hasPreviousPage": {
            "type": "boolean",
            "description": "Whether there are results before this page"
          }
        }
      },
      "CharacterResponse": {
        "description": "Complete character data returned from character operations",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId",
          "name",
          "realmId",
          "speciesId",
          "birthDate",
          "status",
          "createdAt"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the character"
          },
          "name": {
            "type": "string",
            "description": "Display name of the character"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID (partition key)"
          },
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "description": "Species ID (foreign key to Species service)"
          },
          "birthDate": {
            "type": "string",
            "format": "date-time",
            "description": "In-game birth timestamp"
          },
          "deathDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "In-game death timestamp"
          },
          "status": {
            "$ref": "#/components/schemas/CharacterStatus",
            "description": "Current lifecycle status of the character"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Real-world creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Real-world last update timestamp"
          }
        }
      },
      "CharacterStatus": {
        "type": "string",
        "description": "Character lifecycle status",
        "enum": [
          "alive",
          "dead",
          "dormant"
        ]
      },
      "ChatMessageRequest": {
        "description": "Request to send a chat message to players in a game session",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "sessionId",
          "accountId",
          "gameType",
          "message"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID of the sender. Provided by shortcut system."
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the sender. Provided by shortcut system."
          },
          "gameType": {
            "type": "string",
            "description": "Game type for the chat. Determines which lobby's players receive the message. Provided by shortcut system."
          },
          "message": {
            "type": "string",
            "maxLength": 500,
            "description": "Content of the chat message"
          },
          "messageType": {
            "type": "string",
            "enum": [
              "public",
              "whisper",
              "system"
            ],
            "default": "public",
            "description": "Type of message (public to all, whisper to one player, or system announcement)"
          },
          "targetPlayerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "For whisper messages"
          }
        }
      },
      "CheckAssetRequirementsRequest": {
        "type": "object",
        "description": "Request to check asset requirement clauses",
        "additionalProperties": false,
        "required": [
          "contractInstanceId"
        ],
        "properties": {
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          }
        }
      },
      "CheckAssetRequirementsResponse": {
        "type": "object",
        "description": "Response from checking asset requirements",
        "additionalProperties": false,
        "required": [
          "allSatisfied",
          "byParty"
        ],
        "properties": {
          "allSatisfied": {
            "type": "boolean",
            "description": "Whether all requirements across all parties are satisfied"
          },
          "byParty": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartyAssetRequirementStatus"
            },
            "description": "Status broken down by party"
          }
        }
      },
      "CheckConstraintRequest": {
        "type": "object",
        "description": "Request to check constraint",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "constraintType"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity to check"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type"
          },
          "constraintType": {
            "$ref": "#/components/schemas/ConstraintType",
            "description": "Type of constraint to check"
          },
          "proposedAction": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "What the entity wants to do"
          }
        }
      },
      "CheckConstraintResponse": {
        "type": "object",
        "description": "Constraint check result",
        "additionalProperties": false,
        "required": [
          "allowed"
        ],
        "properties": {
          "allowed": {
            "type": "boolean",
            "description": "Whether action is allowed"
          },
          "conflictingContracts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContractSummary"
            },
            "nullable": true,
            "description": "Contracts that would be violated"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Explanation if not allowed"
          }
        }
      },
      "CheckoutRequest": {
        "type": "object",
        "description": "Request to checkout a scene for editing",
        "required": [
          "sceneId"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene to checkout"
          },
          "editorId": {
            "type": "string",
            "nullable": true,
            "description": "Optional editor identifier (defaults to caller identity)"
          },
          "ttlMinutes": {
            "type": "integer",
            "nullable": true,
            "description": "Custom lock TTL (uses default if not specified)"
          }
        }
      },
      "CheckoutResponse": {
        "type": "object",
        "description": "Response containing checkout token and scene",
        "required": [
          "checkoutToken",
          "scene",
          "expiresAt"
        ],
        "properties": {
          "checkoutToken": {
            "type": "string",
            "description": "Token required for commit/discard/heartbeat"
          },
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "Current scene document"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the checkout lock expires"
          }
        }
      },
      "ChordEvent": {
        "description": "A chord with timing information",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "chord",
          "startTick",
          "durationTicks"
        ],
        "properties": {
          "chord": {
            "$ref": "#/components/schemas/ChordSymbol",
            "description": "Chord symbol"
          },
          "startTick": {
            "type": "integer",
            "minimum": 0,
            "description": "Start position in ticks"
          },
          "durationTicks": {
            "type": "integer",
            "minimum": 1,
            "description": "Duration in ticks"
          },
          "romanNumeral": {
            "type": "string",
            "nullable": true,
            "description": "Roman numeral analysis (e.g., \"IV\", \"V7\")"
          }
        }
      },
      "ChordSymbol": {
        "description": "A chord symbol with root and quality",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "root",
          "quality"
        ],
        "properties": {
          "root": {
            "$ref": "#/components/schemas/PitchClass",
            "description": "Chord root"
          },
          "quality": {
            "type": "string",
            "enum": [
              "major",
              "minor",
              "diminished",
              "augmented",
              "dominant7",
              "major7",
              "minor7",
              "diminished7",
              "halfDiminished7",
              "augmented7",
              "sus2",
              "sus4"
            ],
            "description": "Chord quality"
          },
          "bass": {
            "$ref": "#/components/schemas/PitchClass",
            "nullable": true,
            "description": "Bass note (for inversions/slash chords)"
          },
          "extensions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Chord extensions (e.g., \"9\", \"11\", \"13\")"
          }
        }
      },
      "ClauseAssetStatus": {
        "type": "object",
        "description": "Status of a single clause's asset requirements",
        "additionalProperties": false,
        "required": [
          "clauseId",
          "satisfied",
          "required",
          "current",
          "missing"
        ],
        "properties": {
          "clauseId": {
            "type": "string",
            "description": "Clause identifier"
          },
          "satisfied": {
            "type": "boolean",
            "description": "Whether requirement is satisfied"
          },
          "required": {
            "$ref": "#/components/schemas/AssetRequirementInfo",
            "description": "What the clause requires"
          },
          "current": {
            "type": "number",
            "description": "Current amount present"
          },
          "missing": {
            "type": "number",
            "description": "Amount still needed (0 if satisfied)"
          }
        }
      },
      "ClauseCategory": {
        "type": "string",
        "description": "Category of clause type",
        "enum": [
          "validation",
          "execution",
          "both"
        ]
      },
      "ClauseTypeSummary": {
        "type": "object",
        "description": "Summary of a clause type",
        "additionalProperties": false,
        "required": [
          "typeCode",
          "description",
          "category",
          "hasValidationHandler",
          "hasExecutionHandler",
          "isBuiltIn"
        ],
        "properties": {
          "typeCode": {
            "type": "string",
            "description": "Unique identifier"
          },
          "description": {
            "type": "string",
            "description": "Human-readable description"
          },
          "category": {
            "$ref": "#/components/schemas/ClauseCategory",
            "description": "Clause category"
          },
          "hasValidationHandler": {
            "type": "boolean",
            "description": "Whether a validation handler is registered"
          },
          "hasExecutionHandler": {
            "type": "boolean",
            "description": "Whether an execution handler is registered"
          },
          "isBuiltIn": {
            "type": "boolean",
            "description": "Whether this is a built-in type"
          }
        }
      },
      "ClientCapabilitiesResponse": {
        "description": "Response containing the client's capability manifest with available API endpoints and shortcuts",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "sessionId",
          "capabilities",
          "version",
          "generatedAt"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Session ID this capability manifest belongs to"
          },
          "capabilities": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ClientCapability"
            },
            "description": "Available API capabilities for this client"
          },
          "shortcuts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ClientShortcut"
            },
            "description": "Pre-bound API calls available for this session.\nShortcuts are invoked like normal capabilities but Connect injects\na pre-bound payload instead of using the client's payload.\n",
            "nullable": true
          },
          "version": {
            "type": "integer",
            "description": "Capability manifest version (increments on changes)"
          },
          "generatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this capability manifest was generated"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When these capabilities expire and need refresh",
            "nullable": true
          }
        }
      },
      "ClientCapability": {
        "description": "A single API capability available to the client, mapping a client-salted GUID to a service endpoint",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "guid",
          "service",
          "endpoint",
          "method"
        ],
        "properties": {
          "guid": {
            "type": "string",
            "format": "uuid",
            "description": "Client-salted GUID for this API endpoint (unique per session)"
          },
          "service": {
            "type": "string",
            "description": "Service name (e.g., \"account\", \"auth\")"
          },
          "endpoint": {
            "type": "string",
            "description": "API endpoint path (e.g., \"/account/create\")"
          },
          "method": {
            "type": "string",
            "enum": [
              "GET",
              "POST",
              "PUT",
              "DELETE",
              "PATCH"
            ],
            "description": "HTTP method for this endpoint"
          },
          "description": {
            "type": "string",
            "description": "Human-readable description of this capability",
            "nullable": true
          },
          "channel": {
            "type": "integer",
            "format": "uint16",
            "description": "Preferred WebSocket channel for this capability",
            "default": 0
          }
        }
      },
      "ClientShortcut": {
        "type": "object",
        "description": "Session shortcut information sent to clients in the capability manifest.\nShortcuts appear as invocable capabilities but Connect injects a pre-bound\npayload when the shortcut GUID is used, replacing any client-provided payload.\n",
        "additionalProperties": false,
        "required": [
          "guid",
          "targetService",
          "targetEndpoint",
          "name"
        ],
        "properties": {
          "guid": {
            "type": "string",
            "format": "uuid",
            "description": "GUID to use in WebSocket message header when invoking this shortcut.\nUses UUID version 7 bits to distinguish from regular service GUIDs (version 5).\n"
          },
          "targetService": {
            "type": "string",
            "description": "The service this shortcut invokes (for client display purposes)."
          },
          "targetEndpoint": {
            "type": "string",
            "description": "The endpoint this shortcut invokes (for client display purposes)."
          },
          "name": {
            "type": "string",
            "description": "Machine-readable shortcut identifier (e.g., \"get_my_stats\", \"join_game\")."
          },
          "description": {
            "type": "string",
            "description": "Human-readable description of what this shortcut does.",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "User-friendly name for display in client UIs.",
            "nullable": true
          },
          "sourceService": {
            "type": "string",
            "description": "The service that created this shortcut.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Categorization tags for client-side organization.",
            "nullable": true
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this shortcut expires (if time-limited).",
            "nullable": true
          }
        }
      },
      "CollapseDeltasRequest": {
        "type": "object",
        "description": "Request to collapse a delta chain into a full snapshot",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID that owns the save slot"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Name of the slot containing deltas to collapse"
          },
          "versionNumber": {
            "type": "integer",
            "nullable": true,
            "description": "Version to collapse to (latest if null)"
          },
          "deleteIntermediates": {
            "type": "boolean",
            "default": true,
            "description": "Delete intermediate delta versions after collapse"
          }
        }
      },
      "CombatPreferences": {
        "type": "object",
        "description": "Combat behavior preferences that influence tactical decisions.\nThese values affect GOAP action selection, retreat conditions,\nand group coordination behavior.\n",
        "additionalProperties": false,
        "required": [
          "style",
          "preferredRange",
          "groupRole",
          "riskTolerance",
          "retreatThreshold",
          "protectAllies"
        ],
        "properties": {
          "style": {
            "$ref": "#/components/schemas/CombatStyle",
            "description": "Overall combat approach"
          },
          "preferredRange": {
            "$ref": "#/components/schemas/PreferredRange",
            "description": "Preferred engagement distance"
          },
          "groupRole": {
            "$ref": "#/components/schemas/GroupRole",
            "description": "Role when fighting in groups"
          },
          "riskTolerance": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "Willingness to take dangerous actions (0.0 = very cautious, 1.0 = reckless).\nAffects ability selection and target prioritization.\n"
          },
          "retreatThreshold": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "Health percentage at which retreat is considered (0.0 = fight to death,\n0.5 = retreat at half health, 1.0 = retreat at any damage).\n"
          },
          "protectAllies": {
            "type": "boolean",
            "description": "Whether to prioritize ally protection over self-preservation.\nAffects target selection and positioning decisions.\n"
          }
        }
      },
      "CombatPreferencesResponse": {
        "type": "object",
        "description": "Combat preferences profile for behavior system consumption",
        "additionalProperties": false,
        "required": [
          "characterId",
          "preferences",
          "version",
          "createdAt"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character these preferences belong to"
          },
          "preferences": {
            "$ref": "#/components/schemas/CombatPreferences",
            "description": "The combat preferences values"
          },
          "version": {
            "type": "integer",
            "description": "Preferences version number (increments on each evolution)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When these preferences were first created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When these preferences were last modified"
          }
        }
      },
      "CombatPreferencesSnapshot": {
        "description": "Snapshot of combat preferences for enriched response",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "style",
          "preferredRange",
          "groupRole",
          "riskTolerance",
          "retreatThreshold",
          "protectAllies"
        ],
        "properties": {
          "style": {
            "type": "string",
            "description": "Combat style (DEFENSIVE, BALANCED, AGGRESSIVE, BERSERKER, TACTICAL)"
          },
          "preferredRange": {
            "type": "string",
            "description": "Preferred engagement distance (MELEE, CLOSE, MEDIUM, RANGED)"
          },
          "groupRole": {
            "type": "string",
            "description": "Role in group combat (FRONTLINE, SUPPORT, FLANKER, LEADER, SOLO)"
          },
          "riskTolerance": {
            "type": "number",
            "format": "float",
            "description": "Willingness to take risky actions (0.0 to 1.0)"
          },
          "retreatThreshold": {
            "type": "number",
            "format": "float",
            "description": "Health percentage at which retreat is considered (0.0 to 1.0)"
          },
          "protectAllies": {
            "type": "boolean",
            "description": "Whether to prioritize ally protection"
          }
        }
      },
      "CombatStyle": {
        "type": "string",
        "description": "Overall approach to combat situations. Affects target selection,\nability usage, and engagement decisions.\n",
        "enum": [
          "DEFENSIVE",
          "BALANCED",
          "AGGRESSIVE",
          "BERSERKER",
          "TACTICAL"
        ]
      },
      "CommitRequest": {
        "type": "object",
        "description": "Request to commit checkout changes",
        "required": [
          "sceneId",
          "checkoutToken",
          "scene"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene being committed"
          },
          "checkoutToken": {
            "type": "string",
            "description": "Checkout token from checkout response"
          },
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "Updated scene document"
          },
          "changesSummary": {
            "type": "string",
            "nullable": true,
            "description": "Optional summary of changes for audit"
          }
        }
      },
      "CommitResponse": {
        "type": "object",
        "description": "Response confirming commit",
        "required": [
          "committed",
          "newVersion"
        ],
        "properties": {
          "committed": {
            "type": "boolean",
            "description": "Whether commit was successful"
          },
          "newVersion": {
            "type": "string",
            "description": "New version after commit"
          },
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "nullable": true,
            "description": "Committed scene with updated metadata"
          }
        }
      },
      "ComparisonOperator": {
        "type": "string",
        "description": "Comparison operators for numeric conditions",
        "enum": [
          "eq",
          "ne",
          "gt",
          "gte",
          "lt",
          "lte"
        ]
      },
      "CompilationOptions": {
        "description": "Options controlling the ABML compilation process including optimizations and caching",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "enableOptimizations": {
            "type": "boolean",
            "default": true,
            "description": "Enable behavior tree optimizations"
          },
          "cacheCompiledResult": {
            "type": "boolean",
            "default": true,
            "description": "Cache the compiled behavior for reuse"
          },
          "strictValidation": {
            "type": "boolean",
            "default": false,
            "description": "Enable strict validation mode"
          },
          "culturalAdaptations": {
            "type": "boolean",
            "default": true,
            "description": "Apply cultural adaptations during compilation"
          },
          "goapIntegration": {
            "type": "boolean",
            "default": true,
            "description": "Generate GOAP goals from behaviors"
          }
        }
      },
      "CompileBehaviorRequest": {
        "description": "Request to compile an ABML behavior definition into executable behavior trees",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "abmlContent"
        ],
        "properties": {
          "abmlContent": {
            "type": "string",
            "description": "Raw ABML YAML content to compile",
            "example": "version: \"1.0.0\"\nmetadata:\n  id: \"example_behavior\"\n  category: \"basic\"\nbehaviors:\n  example:\n    triggers:\n      - condition: \"true\"\n    actions:\n      - log:\n          message: \"Hello World\"\n"
          },
          "behaviorName": {
            "type": "string",
            "nullable": true,
            "description": "Optional human-readable name for the behavior.\nIf not provided, extracted from ABML metadata.id or generated from content hash.\n",
            "example": "blacksmith_daily_routine"
          },
          "behaviorCategory": {
            "type": "string",
            "description": "Category for organizing behaviors (e.g., profession, cultural, situational).\nUsed for filtering and grouping in bundles.\n",
            "enum": [
              "base",
              "cultural",
              "professional",
              "personal",
              "situational",
              "ambient"
            ],
            "nullable": true,
            "example": "professional"
          },
          "bundleId": {
            "type": "string",
            "nullable": true,
            "description": "Optional bundle identifier for grouping related behaviors.\nWhen specified, the compiled behavior will be added to a bundle with this ID.\nClients can then download entire bundles for efficient bulk loading.\nIf the bundle doesn't exist, it will be created.\n",
            "example": "blacksmith-behaviors-v1"
          },
          "characterContext": {
            "$ref": "#/components/schemas/CharacterContext",
            "nullable": true,
            "description": "Character context for context variable resolution during compilation"
          },
          "compilationOptions": {
            "$ref": "#/components/schemas/CompilationOptions",
            "nullable": true,
            "description": "Options controlling the compilation process"
          }
        }
      },
      "CompileBehaviorResponse": {
        "description": "Response containing the results of an ABML behavior compilation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "behaviorId"
        ],
        "properties": {
          "behaviorId": {
            "type": "string",
            "description": "Unique identifier for the compiled behavior (content-addressable hash)",
            "example": "behavior-a1b2c3d4e5f6g7h8"
          },
          "behaviorName": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable name of the behavior",
            "example": "blacksmith_daily_routine"
          },
          "compiledBehavior": {
            "$ref": "#/components/schemas/CompiledBehavior",
            "nullable": true,
            "description": "The compiled behavior data including behavior tree and metadata"
          },
          "compilationTimeMs": {
            "type": "integer",
            "description": "Time taken to compile the behavior in milliseconds"
          },
          "assetId": {
            "type": "string",
            "nullable": true,
            "description": "Asset service ID where the compiled bytecode is stored. Null only when caching is explicitly disabled."
          },
          "bundleId": {
            "type": "string",
            "nullable": true,
            "description": "Bundle ID if the behavior was added to a bundle. Null if not bundled."
          },
          "isUpdate": {
            "type": "boolean",
            "description": "True if this replaced an existing behavior with the same content hash"
          },
          "warnings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Non-fatal warnings during compilation"
          }
        }
      },
      "CompiledBehavior": {
        "description": "Compiled behavior containing behavior tree, context schema, and GOAP integration data",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "behaviorTree",
          "contextSchema"
        ],
        "properties": {
          "behaviorTree": {
            "$ref": "#/components/schemas/BehaviorTreeData",
            "description": "Compiled behavior tree data with bytecode or download reference"
          },
          "contextSchema": {
            "$ref": "#/components/schemas/ContextSchemaData",
            "description": "Schema defining required context variables for execution"
          },
          "serviceDependencies": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "List of required services for this behavior"
          },
          "goapGoals": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GoapGoal"
            },
            "nullable": true,
            "description": "GOAP goals extracted from the behavior"
          },
          "executionMetadata": {
            "$ref": "#/components/schemas/ExecutionMetadata",
            "nullable": true,
            "description": "Metadata for behavior execution including performance hints and resource requirements"
          }
        }
      },
      "CompleteMilestoneRequest": {
        "type": "object",
        "description": "Request to complete a milestone",
        "additionalProperties": false,
        "required": [
          "contractId",
          "milestoneCode"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "milestoneCode": {
            "type": "string",
            "description": "Milestone to complete"
          },
          "evidence": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Evidence of completion"
          }
        }
      },
      "CompleteUploadRequest": {
        "description": "Request to finalize an upload and trigger asset processing",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "uploadId"
        ],
        "properties": {
          "uploadId": {
            "type": "string",
            "format": "uuid",
            "description": "Upload session ID from requestUpload"
          },
          "parts": {
            "type": "array",
            "nullable": true,
            "description": "For multipart uploads - ETags of completed parts (null for single-file uploads)",
            "items": {
              "$ref": "#/components/schemas/CompletedPart"
            }
          }
        }
      },
      "CompletedPart": {
        "description": "Information about a completed part in a multipart upload",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "partNumber",
          "etag"
        ],
        "properties": {
          "partNumber": {
            "type": "integer",
            "description": "Part number (1-based)"
          },
          "etag": {
            "type": "string",
            "description": "ETag returned from part upload"
          }
        }
      },
      "CompositionMetadata": {
        "description": "Metadata about a generated composition",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "styleId": {
            "type": "string",
            "nullable": true,
            "description": "Style used"
          },
          "key": {
            "$ref": "#/components/schemas/KeySignature",
            "nullable": true,
            "description": "Key signature"
          },
          "tempo": {
            "type": "integer",
            "nullable": true,
            "description": "Tempo in BPM"
          },
          "bars": {
            "type": "integer",
            "nullable": true,
            "description": "Number of bars"
          },
          "tuneType": {
            "type": "string",
            "nullable": true,
            "description": "Tune type if applicable"
          },
          "seed": {
            "type": "integer",
            "nullable": true,
            "description": "Random seed used"
          }
        }
      },
      "CompressionType": {
        "type": "string",
        "enum": [
          "lz4",
          "lzma",
          "none"
        ],
        "description": "Compression algorithm for bundles"
      },
      "ConflictingBundleEntry": {
        "type": "object",
        "additionalProperties": false,
        "description": "A bundle entry in an asset conflict",
        "required": [
          "bundleId",
          "contentHash"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Bundle containing this version"
          },
          "contentHash": {
            "type": "string",
            "description": "Content hash of asset in this bundle"
          }
        }
      },
      "ConsentRequest": {
        "type": "object",
        "description": "Request to record party consent for release or refund",
        "required": [
          "escrowId",
          "partyId",
          "partyType",
          "consentType",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party giving consent"
          },
          "partyType": {
            "type": "string",
            "description": "Party type"
          },
          "consentType": {
            "$ref": "#/components/schemas/EscrowConsentType",
            "description": "Type of consent being given"
          },
          "releaseToken": {
            "type": "string",
            "nullable": true,
            "description": "Release token (required for full_consent)"
          },
          "notes": {
            "type": "string",
            "nullable": true,
            "description": "Optional notes"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "ConsentResponse": {
        "type": "object",
        "description": "Response from recording party consent",
        "required": [
          "escrow",
          "consentRecorded",
          "triggered",
          "newStatus"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Updated escrow agreement"
          },
          "consentRecorded": {
            "type": "boolean",
            "description": "Whether consent was recorded"
          },
          "triggered": {
            "type": "boolean",
            "description": "Whether this consent triggered completion"
          },
          "newStatus": {
            "$ref": "#/components/schemas/EscrowStatus",
            "description": "New escrow status after consent"
          }
        }
      },
      "ConsentStatus": {
        "type": "string",
        "description": "Party's consent status",
        "enum": [
          "pending",
          "consented",
          "declined",
          "implicit"
        ]
      },
      "ConsentToContractRequest": {
        "type": "object",
        "description": "Request to consent to a contract",
        "additionalProperties": false,
        "required": [
          "contractId",
          "partyEntityId",
          "partyEntityType"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract to consent to"
          },
          "partyEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID of consenting party"
          },
          "partyEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type of consenting party"
          }
        }
      },
      "ConstraintType": {
        "type": "string",
        "description": "Type of constraint to check",
        "enum": [
          "exclusivity",
          "non_compete",
          "territory",
          "time_commitment"
        ]
      },
      "ContactRequest": {
        "description": "User-submitted contact form data",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "email",
          "subject",
          "message"
        ],
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "description": "Sender email address for replies"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "Name of the person submitting the form"
          },
          "subject": {
            "type": "string",
            "minLength": 5,
            "maxLength": 200,
            "description": "Subject line of the contact message"
          },
          "message": {
            "type": "string",
            "minLength": 10,
            "maxLength": 2000,
            "description": "Body content of the contact message"
          },
          "category": {
            "type": "string",
            "enum": [
              "general",
              "support",
              "bug",
              "feedback",
              "business"
            ],
            "default": "general",
            "description": "Category to route the contact request"
          }
        }
      },
      "ContactResponse": {
        "description": "Confirmation response after submitting a contact form",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "ticketId",
          "message"
        ],
        "properties": {
          "ticketId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the created support ticket"
          },
          "message": {
            "type": "string",
            "default": "Thank you for contacting us. We will respond within 24-48 hours.",
            "description": "Confirmation message displayed to the user"
          }
        }
      },
      "ContainerConstraintModel": {
        "type": "string",
        "description": "Container capacity constraint type",
        "enum": [
          "slot_only",
          "weight_only",
          "slot_and_weight",
          "grid",
          "volumetric",
          "unlimited"
        ]
      },
      "ContainerItem": {
        "type": "object",
        "description": "Item in a container",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "templateId",
          "quantity"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance ID"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Item template ID"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "description": "Item quantity"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Slot position"
          },
          "slotX": {
            "type": "integer",
            "nullable": true,
            "description": "Grid X position"
          },
          "slotY": {
            "type": "integer",
            "nullable": true,
            "description": "Grid Y position"
          },
          "rotated": {
            "type": "boolean",
            "nullable": true,
            "description": "Rotated in grid"
          }
        }
      },
      "ContainerOwnerType": {
        "type": "string",
        "description": "Type of entity that owns this container",
        "enum": [
          "character",
          "account",
          "location",
          "vehicle",
          "guild",
          "escrow",
          "mail",
          "other"
        ]
      },
      "ContainerResponse": {
        "type": "object",
        "description": "Container details",
        "additionalProperties": false,
        "required": [
          "containerId",
          "ownerId",
          "ownerType",
          "containerType",
          "constraintModel",
          "isEquipmentSlot",
          "canContainContainers",
          "nestingDepth",
          "selfWeight",
          "weightContribution",
          "slotCost",
          "contentsWeight",
          "totalWeight",
          "createdAt"
        ],
        "properties": {
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container unique identifier"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner entity ID"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Owner type"
          },
          "containerType": {
            "type": "string",
            "description": "Container type"
          },
          "constraintModel": {
            "$ref": "#/components/schemas/ContainerConstraintModel",
            "description": "Constraint model"
          },
          "isEquipmentSlot": {
            "type": "boolean",
            "description": "Whether this is an equipment slot"
          },
          "equipmentSlotName": {
            "type": "string",
            "nullable": true,
            "description": "Equipment slot name"
          },
          "maxSlots": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum slots"
          },
          "usedSlots": {
            "type": "integer",
            "nullable": true,
            "description": "Current used slots"
          },
          "maxWeight": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Maximum weight"
          },
          "gridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "Internal grid width"
          },
          "gridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "Internal grid height"
          },
          "maxVolume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Maximum volume"
          },
          "currentVolume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Current volume used"
          },
          "parentContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Parent container ID"
          },
          "nestingDepth": {
            "type": "integer",
            "description": "Depth in container hierarchy"
          },
          "canContainContainers": {
            "type": "boolean",
            "description": "Whether can hold containers"
          },
          "maxNestingDepth": {
            "type": "integer",
            "nullable": true,
            "description": "Max nesting depth"
          },
          "selfWeight": {
            "type": "number",
            "format": "double",
            "description": "Empty container weight"
          },
          "weightContribution": {
            "$ref": "#/components/schemas/WeightContribution",
            "description": "Weight propagation mode"
          },
          "slotCost": {
            "type": "integer",
            "description": "Slots used in parent"
          },
          "parentGridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "Width in parent grid"
          },
          "parentGridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "Height in parent grid"
          },
          "parentVolume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Volume in parent"
          },
          "contentsWeight": {
            "type": "number",
            "format": "double",
            "description": "Weight of direct contents"
          },
          "totalWeight": {
            "type": "number",
            "format": "double",
            "description": "Total weight including self"
          },
          "allowedCategories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Allowed categories"
          },
          "forbiddenCategories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Forbidden categories"
          },
          "allowedTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Required tags"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm ID"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Container tags"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "description": "Game-specific data"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "modifiedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last modification"
          }
        }
      },
      "ContainerWithContentsResponse": {
        "type": "object",
        "description": "Container with item contents",
        "additionalProperties": false,
        "required": [
          "container",
          "items"
        ],
        "properties": {
          "container": {
            "$ref": "#/components/schemas/ContainerResponse",
            "description": "Container details"
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContainerItem"
            },
            "description": "Items in container"
          }
        }
      },
      "ContextSchemaData": {
        "type": "object",
        "description": "Schema defining required context variables for behavior execution",
        "additionalProperties": true
      },
      "ContractInstanceResponse": {
        "type": "object",
        "description": "Contract instance details",
        "additionalProperties": false,
        "required": [
          "contractId",
          "templateId",
          "status",
          "parties",
          "createdAt"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique contract identifier"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Source template ID"
          },
          "templateCode": {
            "type": "string",
            "description": "Source template code"
          },
          "status": {
            "$ref": "#/components/schemas/ContractStatus",
            "description": "Current contract status"
          },
          "parties": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContractPartyResponse"
            },
            "description": "Contract parties"
          },
          "terms": {
            "$ref": "#/components/schemas/ContractTerms",
            "nullable": true,
            "description": "Contract terms"
          },
          "milestones": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MilestoneInstanceResponse"
            },
            "nullable": true,
            "description": "Milestone progress"
          },
          "currentMilestoneIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Index of current milestone"
          },
          "escrowIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "Related escrow IDs"
          },
          "proposedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When contract was proposed"
          },
          "acceptedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When all parties consented"
          },
          "effectiveFrom": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When contract became active"
          },
          "effectiveUntil": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When contract expires"
          },
          "terminatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When contract was terminated"
          },
          "gameMetadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Game-specific metadata"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last update timestamp"
          }
        }
      },
      "ContractInstanceStatusResponse": {
        "type": "object",
        "description": "Contract status summary",
        "additionalProperties": false,
        "required": [
          "contractId",
          "status",
          "milestoneProgress"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "status": {
            "$ref": "#/components/schemas/ContractStatus",
            "description": "Current status"
          },
          "milestoneProgress": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MilestoneProgressSummary"
            },
            "description": "Milestone progress summary"
          },
          "pendingConsents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PendingConsentSummary"
            },
            "nullable": true,
            "description": "Parties who haven't consented"
          },
          "activeBreaches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BreachSummary"
            },
            "nullable": true,
            "description": "Active breach records"
          },
          "daysUntilExpiration": {
            "type": "integer",
            "nullable": true,
            "description": "Days until natural expiration"
          }
        }
      },
      "ContractMetadataResponse": {
        "type": "object",
        "description": "Contract metadata",
        "additionalProperties": false,
        "required": [
          "contractId"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "instanceData": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Instance-level metadata"
          },
          "runtimeState": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Runtime state metadata"
          }
        }
      },
      "ContractPartyInput": {
        "type": "object",
        "description": "Party input for contract creation",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "role"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type"
          },
          "role": {
            "type": "string",
            "description": "Role from template"
          }
        }
      },
      "ContractPartyResponse": {
        "type": "object",
        "description": "Contract party details",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "role",
          "consentStatus"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type"
          },
          "role": {
            "type": "string",
            "description": "Role in contract"
          },
          "consentStatus": {
            "$ref": "#/components/schemas/ConsentStatus",
            "description": "Consent status"
          },
          "consentedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When consent was given"
          }
        }
      },
      "ContractStatus": {
        "type": "string",
        "description": "Current status of a contract instance",
        "enum": [
          "draft",
          "proposed",
          "pending",
          "active",
          "fulfilled",
          "expired",
          "terminated",
          "breached",
          "suspended",
          "disputed",
          "declined"
        ]
      },
      "ContractSummary": {
        "type": "object",
        "description": "Brief contract information",
        "additionalProperties": false,
        "required": [
          "contractId",
          "templateCode",
          "status",
          "role"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract ID"
          },
          "templateCode": {
            "type": "string",
            "description": "Template code"
          },
          "templateName": {
            "type": "string",
            "nullable": true,
            "description": "Template name"
          },
          "status": {
            "$ref": "#/components/schemas/ContractStatus",
            "description": "Current status"
          },
          "role": {
            "type": "string",
            "description": "Entity's role in contract"
          },
          "effectiveUntil": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When contract expires"
          }
        }
      },
      "ContractTemplateResponse": {
        "type": "object",
        "description": "Contract template details",
        "additionalProperties": false,
        "required": [
          "templateId",
          "code",
          "name",
          "minParties",
          "maxParties",
          "partyRoles",
          "defaultEnforcementMode",
          "isActive",
          "createdAt"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique template identifier"
          },
          "code": {
            "type": "string",
            "description": "Unique template code"
          },
          "name": {
            "type": "string",
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Detailed description"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm ID if realm-specific"
          },
          "minParties": {
            "type": "integer",
            "description": "Minimum parties required"
          },
          "maxParties": {
            "type": "integer",
            "description": "Maximum parties allowed"
          },
          "partyRoles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartyRoleDefinition"
            },
            "description": "Party role definitions"
          },
          "defaultTerms": {
            "$ref": "#/components/schemas/ContractTerms",
            "nullable": true,
            "description": "Default contract terms"
          },
          "milestones": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MilestoneDefinition"
            },
            "nullable": true,
            "description": "Milestone definitions"
          },
          "defaultEnforcementMode": {
            "$ref": "#/components/schemas/EnforcementMode",
            "description": "Default enforcement mode"
          },
          "transferable": {
            "type": "boolean",
            "description": "Whether contracts can be transferred"
          },
          "gameMetadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Game-specific metadata"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether template is active"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last update timestamp"
          }
        }
      },
      "ContractTerms": {
        "type": "object",
        "description": "Configurable contract terms",
        "additionalProperties": false,
        "properties": {
          "duration": {
            "type": "string",
            "nullable": true,
            "description": "Contract duration (ISO 8601 duration, null for perpetual)"
          },
          "paymentSchedule": {
            "$ref": "#/components/schemas/PaymentSchedule",
            "nullable": true,
            "description": "When payments occur"
          },
          "paymentFrequency": {
            "type": "string",
            "nullable": true,
            "description": "Recurring payment frequency (ISO 8601 duration)"
          },
          "terminationPolicy": {
            "$ref": "#/components/schemas/TerminationPolicy",
            "nullable": true,
            "description": "How contract can be terminated"
          },
          "terminationNoticePeriod": {
            "type": "string",
            "nullable": true,
            "description": "Required notice for termination (ISO 8601 duration)"
          },
          "breachThreshold": {
            "type": "integer",
            "minimum": 0,
            "nullable": true,
            "description": "Breaches before auto-termination (0 for no auto)"
          },
          "gracePeriodForCure": {
            "type": "string",
            "nullable": true,
            "description": "Time to cure breach (ISO 8601 duration)"
          },
          "customTerms": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Game-specific custom terms"
          }
        }
      },
      "ConversionStep": {
        "type": "object",
        "description": "A step in the conversion path",
        "additionalProperties": false,
        "required": [
          "from",
          "to",
          "rate"
        ],
        "properties": {
          "from": {
            "type": "string",
            "description": "Source currency code"
          },
          "to": {
            "type": "string",
            "description": "Target currency code"
          },
          "rate": {
            "type": "number",
            "format": "double",
            "description": "Rate applied in this step"
          }
        }
      },
      "Coordinates": {
        "type": "object",
        "additionalProperties": false,
        "description": "3D spatial coordinates representing a position in the game world",
        "properties": {
          "x": {
            "type": "number",
            "description": "X coordinate position"
          },
          "y": {
            "type": "number",
            "description": "Y coordinate position"
          },
          "z": {
            "type": "number",
            "description": "Z coordinate position"
          }
        }
      },
      "CopySaveRequest": {
        "description": "Request to copy save data from one slot to another, optionally across different entities or games.",
        "type": "object",
        "required": [
          "sourceGameId",
          "sourceOwnerId",
          "sourceOwnerType",
          "sourceSlotName",
          "targetGameId",
          "targetOwnerId",
          "targetOwnerType",
          "targetSlotName"
        ],
        "properties": {
          "sourceGameId": {
            "type": "string",
            "description": "Game identifier of the source save"
          },
          "sourceOwnerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID that owns the source save"
          },
          "sourceOwnerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns the source save"
          },
          "sourceSlotName": {
            "type": "string",
            "description": "Name of the source slot to copy from"
          },
          "sourceVersion": {
            "type": "integer",
            "nullable": true,
            "description": "Version to copy (latest if null)"
          },
          "targetGameId": {
            "type": "string",
            "description": "Game identifier for the target save"
          },
          "targetOwnerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID that will own the copied save"
          },
          "targetOwnerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that will own the copied save"
          },
          "targetSlotName": {
            "type": "string",
            "description": "Name of the target slot to copy to"
          },
          "targetCategory": {
            "$ref": "#/components/schemas/SaveCategory",
            "description": "Category for new slot if auto-created"
          }
        }
      },
      "CountItemsRequest": {
        "type": "object",
        "description": "Request to count items",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "templateId"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner to count for"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Owner type"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template to count"
          }
        }
      },
      "CountItemsResponse": {
        "type": "object",
        "description": "Count result",
        "additionalProperties": false,
        "required": [
          "templateId",
          "totalQuantity",
          "stackCount"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Counted template"
          },
          "totalQuantity": {
            "type": "number",
            "format": "double",
            "description": "Total quantity"
          },
          "stackCount": {
            "type": "integer",
            "description": "Number of stacks"
          }
        }
      },
      "CoverageAnalysis": {
        "type": "object",
        "additionalProperties": false,
        "description": "Statistics about asset resolution coverage",
        "required": [
          "totalRequested",
          "resolvedViaBundles",
          "resolvedStandalone",
          "unresolvedCount"
        ],
        "properties": {
          "totalRequested": {
            "type": "integer",
            "description": "Total number of assets requested"
          },
          "resolvedViaBundles": {
            "type": "integer",
            "description": "Assets resolved through bundle downloads"
          },
          "resolvedStandalone": {
            "type": "integer",
            "description": "Assets resolved as standalone downloads"
          },
          "unresolvedCount": {
            "type": "integer",
            "description": "Assets that could not be found"
          },
          "bundleEfficiency": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "description": "Ratio of assets provided to bundle downloads (higher is better)"
          }
        }
      },
      "CreateAchievementDefinitionRequest": {
        "type": "object",
        "description": "Request to create a new achievement",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "achievementId",
          "displayName",
          "description"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service owning this achievement"
          },
          "achievementId": {
            "type": "string",
            "maxLength": 64,
            "pattern": "^[a-z0-9_-]+$",
            "description": "Unique identifier for this achievement (lowercase, no spaces)"
          },
          "displayName": {
            "type": "string",
            "maxLength": 100,
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "maxLength": 500,
            "description": "Description of how to earn this achievement"
          },
          "hiddenDescription": {
            "type": "string",
            "maxLength": 500,
            "nullable": true,
            "description": "Description shown before achievement is earned (for hidden types)"
          },
          "achievementType": {
            "$ref": "#/components/schemas/AchievementType",
            "default": "standard",
            "description": "Classification of the achievement (affects visibility and progress behavior)"
          },
          "entityTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityType"
            },
            "description": "Which entity types can earn this achievement"
          },
          "progressTarget": {
            "type": "integer",
            "nullable": true,
            "description": "Target value for progressive achievements"
          },
          "points": {
            "type": "integer",
            "default": 10,
            "description": "Point value of this achievement"
          },
          "iconUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "URL to achievement icon"
          },
          "platforms": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Platform"
            },
            "description": "Platforms where this achievement exists"
          },
          "platformIds": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Platform-specific achievement IDs (e.g., {\"steam\": \"ACH_001\"})"
          },
          "prerequisites": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Achievement IDs that must be unlocked first"
          },
          "isActive": {
            "type": "boolean",
            "default": true,
            "description": "Whether this achievement can be earned"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional achievement-specific metadata"
          }
        }
      },
      "CreateActorTemplateRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to create a new actor template definition",
        "required": [
          "category",
          "behaviorRef"
        ],
        "properties": {
          "category": {
            "type": "string",
            "description": "Category identifier (e.g., \"npc-brain\", \"world-admin\", \"cron-cleanup\")"
          },
          "behaviorRef": {
            "type": "string",
            "description": "Reference to behavior in lib-assets (e.g., \"asset://behaviors/npc-brain-v1\")"
          },
          "configuration": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Default configuration passed to behavior execution"
          },
          "autoSpawn": {
            "description": "Auto-spawn configuration for instantiate-on-access",
            "nullable": true,
            "$ref": "#/components/schemas/AutoSpawnConfig"
          },
          "tickIntervalMs": {
            "type": "integer",
            "default": 1000,
            "description": "Milliseconds between behavior loop iterations"
          },
          "autoSaveIntervalSeconds": {
            "type": "integer",
            "default": 60,
            "description": "Seconds between automatic state saves (0 to disable)"
          },
          "maxInstancesPerNode": {
            "type": "integer",
            "default": 100,
            "description": "Maximum actors of this category per pool node"
          }
        }
      },
      "CreateArchiveRequest": {
        "description": "Request to create a point-in-time snapshot of namespace documentation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "string",
            "description": "Owner of this archive. NOT a session ID.\nFor user-initiated archives: the accountId (UUID format).\nFor service-initiated archives: the service name (e.g., \"orchestrator\").\n"
          },
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to archive"
          },
          "description": {
            "type": "string",
            "maxLength": 500,
            "description": "Optional description for the archive"
          }
        }
      },
      "CreateArchiveResponse": {
        "description": "Response containing the created archive details",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "archiveId",
          "namespace"
        ],
        "properties": {
          "archiveId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the created archive"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace that was archived"
          },
          "bundleAssetId": {
            "type": "string",
            "format": "uuid",
            "description": "Asset ID in Asset Service"
          },
          "documentCount": {
            "type": "integer",
            "description": "Number of documents in the archive"
          },
          "sizeBytes": {
            "type": "integer",
            "description": "Total size of the archive in bytes"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the archive was created"
          },
          "commitHash": {
            "type": "string",
            "nullable": true,
            "description": "Git commit hash if namespace is bound"
          }
        }
      },
      "CreateBundleRequest": {
        "description": "Request to create a new asset bundle from multiple assets",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bundleId",
          "assetIds",
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "string",
            "description": "Owner of this bundle. NOT a session ID.\nFor user-initiated bundles: the accountId (UUID format).\nFor service-initiated bundles: the service name (e.g., \"orchestrator\").\n"
          },
          "bundleId": {
            "type": "string",
            "description": "Unique bundle identifier"
          },
          "version": {
            "type": "string",
            "default": "1.0.0",
            "description": "Bundle version string"
          },
          "realm": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Realm"
              }
            ],
            "nullable": true,
            "description": "Game realm this bundle belongs to.\nDefaults to 'shared' if not specified.\n"
          },
          "assetIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of asset IDs to include in the bundle"
          },
          "compression": {
            "$ref": "#/components/schemas/CompressionType",
            "description": "Compression algorithm to use for the bundle"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Custom metadata for the bundle (null if none)"
          }
        }
      },
      "CreateBundleResponse": {
        "description": "Response with bundle creation status and estimated size",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bundleId",
          "status",
          "estimatedSize"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Unique bundle identifier"
          },
          "status": {
            "type": "string",
            "enum": [
              "queued",
              "processing",
              "ready",
              "failed"
            ],
            "description": "Bundle creation status"
          },
          "estimatedSize": {
            "type": "integer",
            "format": "int64",
            "description": "Estimated bundle size in bytes"
          }
        }
      },
      "CreateContainerRequest": {
        "type": "object",
        "description": "Request to create a new container",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "containerType",
          "constraintModel"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity that owns this container"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Type of the owning entity"
          },
          "containerType": {
            "type": "string",
            "maxLength": 64,
            "description": "Game-defined container type (e.g., inventory, bank, equipment_slot)"
          },
          "constraintModel": {
            "$ref": "#/components/schemas/ContainerConstraintModel",
            "description": "Capacity constraint model"
          },
          "isEquipmentSlot": {
            "type": "boolean",
            "default": false,
            "description": "Whether this container is an equipment slot"
          },
          "equipmentSlotName": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Equipment slot name if isEquipmentSlot is true"
          },
          "maxSlots": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum slots for slot-based containers"
          },
          "maxWeight": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Maximum weight capacity"
          },
          "gridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "Internal grid width for grid containers"
          },
          "gridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "Internal grid height for grid containers"
          },
          "maxVolume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Maximum volume for volumetric containers"
          },
          "parentContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Parent container ID for nested containers"
          },
          "canContainContainers": {
            "type": "boolean",
            "default": false,
            "description": "Whether this container can hold other containers"
          },
          "maxNestingDepth": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum nesting depth (null uses global default)"
          },
          "selfWeight": {
            "type": "number",
            "format": "double",
            "default": 0,
            "description": "Empty container weight"
          },
          "weightContribution": {
            "$ref": "#/components/schemas/WeightContribution",
            "description": "How weight propagates to parent"
          },
          "slotCost": {
            "type": "integer",
            "default": 1,
            "description": "Slots used in slot-based parent"
          },
          "parentGridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "Width footprint in grid-based parent"
          },
          "parentGridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "Height footprint in grid-based parent"
          },
          "parentVolume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Volume footprint in volumetric parent"
          },
          "allowedCategories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Allowed item categories (null allows all)"
          },
          "forbiddenCategories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Forbidden item categories"
          },
          "allowedTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Required item tags for placement"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm this container belongs to (null for account-level)"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Container tags for filtering"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "description": "Game-specific container data"
          }
        }
      },
      "CreateContractInstanceRequest": {
        "type": "object",
        "description": "Request to create a contract instance",
        "additionalProperties": false,
        "required": [
          "templateId",
          "parties"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template to create instance from"
          },
          "parties": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContractPartyInput"
            },
            "minItems": 2,
            "description": "Parties to this contract"
          },
          "terms": {
            "$ref": "#/components/schemas/ContractTerms",
            "nullable": true,
            "description": "Terms overriding template defaults"
          },
          "effectiveFrom": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When contract becomes active (null for immediate)"
          },
          "effectiveUntil": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When contract expires (null for perpetual)"
          },
          "escrowIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "Related escrow IDs"
          },
          "gameMetadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Instance-level game metadata"
          }
        }
      },
      "CreateDefinitionRequest": {
        "type": "object",
        "description": "Request to create a map definition",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "description": "Description of the map template",
            "nullable": true
          },
          "layers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LayerDefinition"
            },
            "description": "Layer configurations",
            "nullable": true
          },
          "defaultBounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Default bounds for regions using this definition",
            "nullable": true
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "description": "Additional metadata",
            "nullable": true
          }
        }
      },
      "CreateEscrowPartyInput": {
        "type": "object",
        "description": "Input for defining a party in escrow creation",
        "required": [
          "partyId",
          "partyType",
          "role"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party entity ID"
          },
          "partyType": {
            "type": "string",
            "description": "Party entity type"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Display name"
          },
          "role": {
            "$ref": "#/components/schemas/EscrowPartyRole",
            "description": "Role of this party in the escrow"
          },
          "consentRequired": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether consent is required (defaults based on role)"
          },
          "walletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Party wallet for currency operations"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Party container for item operations"
          }
        }
      },
      "CreateEscrowRequest": {
        "type": "object",
        "description": "Request to create a new escrow agreement",
        "required": [
          "escrowType",
          "trustMode",
          "parties",
          "expectedDeposits",
          "idempotencyKey"
        ],
        "properties": {
          "escrowType": {
            "$ref": "#/components/schemas/EscrowType",
            "description": "Type of escrow agreement"
          },
          "trustMode": {
            "$ref": "#/components/schemas/EscrowTrustMode",
            "description": "Trust mode for the escrow"
          },
          "trustedPartyId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "For single_party_trusted mode"
          },
          "trustedPartyType": {
            "type": "string",
            "nullable": true,
            "description": "Type of the trusted party"
          },
          "parties": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateEscrowPartyInput"
            },
            "description": "Parties in the escrow"
          },
          "expectedDeposits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExpectedDepositInput"
            },
            "description": "Expected deposits from parties"
          },
          "releaseAllocations": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/ReleaseAllocationInput"
            },
            "description": "Optional explicit release allocations"
          },
          "boundContractId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract governing this escrow"
          },
          "requiredConsentsForRelease": {
            "type": "integer",
            "nullable": true,
            "description": "Number of consents required (-1 for all)"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Optional expiration time"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "Reference type (trade, auction, etc.)"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference entity ID"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Application metadata"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key for this operation"
          }
        }
      },
      "CreateEscrowResponse": {
        "type": "object",
        "description": "Response from creating an escrow agreement",
        "required": [
          "escrow",
          "depositTokens"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Created escrow agreement"
          },
          "depositTokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartyToken"
            },
            "description": "Deposit tokens for each party (full_consent mode)"
          }
        }
      },
      "CreateHoldRequest": {
        "type": "object",
        "description": "Request to create an authorization hold",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "expiresAt",
          "idempotencyKey"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet to hold funds in"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to hold"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to reserve"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the hold auto-releases"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "Reference type (e.g. dining, hotel, gas)"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference entity ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Idempotency key"
          }
        }
      },
      "CreateItemInstanceRequest": {
        "type": "object",
        "description": "Request to create a new item instance",
        "additionalProperties": false,
        "required": [
          "templateId",
          "containerId",
          "realmId",
          "quantity",
          "originType"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template to instantiate"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container to place the item in"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm this instance exists in"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "minimum": 0,
            "exclusiveMinimum": true,
            "description": "Item quantity (respects template's quantityModel)"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Slot position in slot-based containers"
          },
          "slotX": {
            "type": "integer",
            "nullable": true,
            "description": "X position in grid-based containers"
          },
          "slotY": {
            "type": "integer",
            "nullable": true,
            "description": "Y position in grid-based containers"
          },
          "rotated": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether item is rotated in grid"
          },
          "currentDurability": {
            "type": "integer",
            "nullable": true,
            "description": "Initial durability (defaults to template's maxDurability)"
          },
          "customStats": {
            "type": "object",
            "nullable": true,
            "description": "Instance-specific stat modifications"
          },
          "customName": {
            "type": "string",
            "maxLength": 128,
            "nullable": true,
            "description": "Player-assigned custom name"
          },
          "instanceMetadata": {
            "type": "object",
            "nullable": true,
            "description": "Any other instance-specific data"
          },
          "originType": {
            "$ref": "#/components/schemas/ItemOriginType",
            "description": "How this item instance was created"
          },
          "originId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Source entity ID (quest ID, creature ID, etc.)"
          }
        }
      },
      "CreateItemTemplateRequest": {
        "type": "object",
        "description": "Request to create a new item template",
        "additionalProperties": false,
        "required": [
          "code",
          "gameId",
          "name",
          "category",
          "quantityModel",
          "maxStackSize",
          "scope"
        ],
        "properties": {
          "code": {
            "type": "string",
            "maxLength": 64,
            "pattern": "^[a-z][a-z0-9_]{1,63}$",
            "description": "Unique code within the game (immutable after creation)"
          },
          "gameId": {
            "type": "string",
            "maxLength": 64,
            "description": "Game service this template belongs to (immutable after creation)"
          },
          "name": {
            "type": "string",
            "maxLength": 128,
            "description": "Human-readable display name"
          },
          "description": {
            "type": "string",
            "maxLength": 1000,
            "nullable": true,
            "description": "Detailed description of this item"
          },
          "category": {
            "$ref": "#/components/schemas/ItemCategory",
            "description": "Item classification category"
          },
          "subcategory": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Game-defined subcategory (e.g., sword, helmet)"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string",
              "maxLength": 32
            },
            "nullable": true,
            "description": "Flexible filtering tags"
          },
          "rarity": {
            "$ref": "#/components/schemas/ItemRarity",
            "nullable": true,
            "description": "Item rarity tier (defaults to config when not specified)"
          },
          "quantityModel": {
            "$ref": "#/components/schemas/QuantityModel",
            "description": "How quantities are tracked for this item"
          },
          "maxStackSize": {
            "type": "integer",
            "minimum": 1,
            "description": "Maximum stack size (1 for unique items)"
          },
          "unitOfMeasure": {
            "type": "string",
            "maxLength": 32,
            "nullable": true,
            "description": "Unit for continuous quantities (e.g., liters, kg)"
          },
          "weightPrecision": {
            "$ref": "#/components/schemas/WeightPrecision",
            "nullable": true,
            "description": "Precision for weight values (defaults to config when not specified)"
          },
          "weight": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Weight value (interpreted per weightPrecision)"
          },
          "volume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Volume for volumetric inventories"
          },
          "gridWidth": {
            "type": "integer",
            "minimum": 1,
            "nullable": true,
            "description": "Width in grid-based inventories"
          },
          "gridHeight": {
            "type": "integer",
            "minimum": 1,
            "nullable": true,
            "description": "Height in grid-based inventories"
          },
          "canRotate": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether item can be rotated in grid"
          },
          "baseValue": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Reference price for vendors/markets"
          },
          "tradeable": {
            "type": "boolean",
            "default": true,
            "description": "Whether item can be traded/auctioned"
          },
          "destroyable": {
            "type": "boolean",
            "default": true,
            "description": "Whether item can be destroyed/discarded"
          },
          "soulboundType": {
            "$ref": "#/components/schemas/SoulboundType",
            "nullable": true,
            "description": "Binding behavior when item is acquired (defaults to config when not specified)"
          },
          "hasDurability": {
            "type": "boolean",
            "default": false,
            "description": "Whether item has durability tracking"
          },
          "maxDurability": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum durability value"
          },
          "scope": {
            "$ref": "#/components/schemas/ItemScope",
            "description": "Realm availability scope"
          },
          "availableRealms": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "Realm IDs where this template is available (for realm_specific or multi_realm)"
          },
          "stats": {
            "type": "object",
            "nullable": true,
            "description": "Game-defined stats (e.g., attack, defense)"
          },
          "effects": {
            "type": "object",
            "nullable": true,
            "description": "Game-defined effects (e.g., on_use, on_equip)"
          },
          "requirements": {
            "type": "object",
            "nullable": true,
            "description": "Game-defined requirements (e.g., level, strength)"
          },
          "display": {
            "type": "object",
            "nullable": true,
            "description": "Display properties (e.g., iconId, modelId)"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "description": "Any other game-specific data"
          }
        }
      },
      "CreateLeaderboardDefinitionRequest": {
        "type": "object",
        "description": "Request to create a new leaderboard",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId",
          "displayName"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service owning this leaderboard"
          },
          "leaderboardId": {
            "type": "string",
            "maxLength": 64,
            "pattern": "^[a-z0-9_-]+$",
            "description": "Unique identifier for this leaderboard (lowercase, no spaces)"
          },
          "displayName": {
            "type": "string",
            "maxLength": 100,
            "description": "Human-readable name for the leaderboard"
          },
          "description": {
            "type": "string",
            "maxLength": 500,
            "nullable": true,
            "description": "Description of what this leaderboard tracks"
          },
          "entityTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityType"
            },
            "description": "Which entity types can appear on this leaderboard"
          },
          "sortOrder": {
            "$ref": "#/components/schemas/SortOrder",
            "default": "descending",
            "description": "Sort order (descending for high scores, ascending for times)"
          },
          "updateMode": {
            "$ref": "#/components/schemas/UpdateMode",
            "default": "replace",
            "description": "How to handle score updates"
          },
          "isSeasonal": {
            "type": "boolean",
            "default": false,
            "description": "Whether this leaderboard resets each season"
          },
          "isPublic": {
            "type": "boolean",
            "default": true,
            "description": "Whether the leaderboard is publicly visible"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional leaderboard-specific metadata"
          }
        }
      },
      "CreateMetabundleRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to create a metabundle from source bundles and/or standalone assets.\nAt least one of sourceBundleIds or standaloneAssetIds must be provided.\nThis enables packaging behaviors/scripts with 3D assets as a complete unit.\n",
        "required": [
          "metabundleId",
          "owner",
          "realm"
        ],
        "properties": {
          "metabundleId": {
            "type": "string",
            "description": "Unique identifier for the new metabundle"
          },
          "sourceBundleIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Source bundle IDs to pull assets from. Can cherry-pick specific\nassets using assetFilter, or include all if assetFilter is null.\n"
          },
          "standaloneAssetIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Individual asset IDs (not in bundles) to include directly.\nUseful for including behaviors, scripts, or metadata files\nalongside bundled 3D assets.\n"
          },
          "version": {
            "type": "string",
            "default": "1.0.0",
            "description": "Metabundle version string"
          },
          "owner": {
            "type": "string",
            "description": "Owner of this metabundle. NOT a session ID.\nFor user-initiated: the accountId (UUID format).\nFor service-initiated: the service name.\n"
          },
          "realm": {
            "$ref": "#/components/schemas/Realm",
            "description": "Game realm for this metabundle"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description"
          },
          "assetFilter": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Optional subset of asset IDs to include FROM SOURCE BUNDLES.\nIf null, all assets from source bundles are included.\nStandalone assets are always included regardless of this filter.\n"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Custom metadata for the metabundle"
          }
        }
      },
      "CreateMetabundleResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response from metabundle creation.\nFor synchronous creation (small jobs): status=ready with downloadUrl.\nFor async creation (large jobs): status=queued with jobId for polling.\n",
        "required": [
          "metabundleId",
          "status",
          "assetCount",
          "sizeBytes"
        ],
        "properties": {
          "metabundleId": {
            "type": "string",
            "description": "Metabundle identifier"
          },
          "jobId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Job ID for async processing. Only present when status is 'queued' or 'processing'.\nUse /bundles/job/status to poll for completion, or wait for\nMetabundleCreationCompleteEvent via WebSocket.\n"
          },
          "status": {
            "type": "string",
            "enum": [
              "queued",
              "processing",
              "ready",
              "failed"
            ],
            "description": "Creation status.\n- queued: Job accepted for async processing (poll with jobId)\n- processing: Job is actively running\n- ready: Metabundle created and available for download\n- failed: Creation failed (see conflicts for details)\n"
          },
          "downloadUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "Pre-signed download URL (only present when status is 'ready')"
          },
          "assetCount": {
            "type": "integer",
            "description": "Number of assets in the metabundle"
          },
          "standaloneAssetCount": {
            "type": "integer",
            "nullable": true,
            "description": "Number of standalone assets included directly (not from bundles)"
          },
          "sizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Total size in bytes"
          },
          "sourceBundles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SourceBundleReference"
            },
            "description": "Provenance data for the metabundle"
          },
          "conflicts": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/AssetConflict"
            },
            "description": "Present if creation failed due to asset conflicts"
          }
        }
      },
      "CreateSceneRequest": {
        "type": "object",
        "description": "Request to create a new scene",
        "required": [
          "scene"
        ],
        "properties": {
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "The scene document to create"
          }
        }
      },
      "CreateSlotRequest": {
        "description": "Request to create a new save slot for an entity.",
        "type": "object",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName",
          "category"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "minLength": 1,
            "maxLength": 32,
            "pattern": "^[a-z][a-z0-9-]*$",
            "description": "Game identifier for namespace isolation (e.g., \"arcadia\", \"fantasia\")"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64,
            "pattern": "^[a-z0-9]([a-z0-9-]*[a-z0-9])?$",
            "description": "Slot name (lowercase alphanumeric with hyphens, single char like \"q\" allowed)"
          },
          "category": {
            "$ref": "#/components/schemas/SaveCategory",
            "description": "Save category determining retention and cleanup behavior"
          },
          "maxVersions": {
            "type": "integer",
            "nullable": true,
            "minimum": 1,
            "maximum": 100,
            "description": "Override default max versions for this category (null = use category default)"
          },
          "retentionDays": {
            "type": "integer",
            "nullable": true,
            "minimum": 1,
            "description": "Days to retain versions (null = indefinite)"
          },
          "compressionType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CompressionType"
              }
            ],
            "nullable": true,
            "description": "Compression algorithm to use for save data (null = use category default)"
          },
          "tags": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string",
              "maxLength": 32
            },
            "maxItems": 20,
            "description": "Searchable tags for slot categorization (e.g., \"boss-fight\", \"chapter-3\")"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom key-value metadata for the slot"
          }
        }
      },
      "CreateWalletRequest": {
        "type": "object",
        "description": "Request to create a new wallet",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner entity ID"
          },
          "ownerType": {
            "$ref": "#/components/schemas/WalletOwnerType",
            "description": "Type of owner entity"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm ID for realm-scoped wallets (null for global)"
          }
        }
      },
      "CreditCurrencyRequest": {
        "type": "object",
        "description": "Request to credit currency to a wallet",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "transactionType",
          "idempotencyKey"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Target wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to credit"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to credit (must be positive)"
          },
          "transactionType": {
            "$ref": "#/components/schemas/TransactionType",
            "description": "Must be a faucet type (mint, quest_reward, loot_drop, etc.)"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "What triggered this transaction (quest, admin, etc.)"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference entity ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Unique key to prevent duplicate processing"
          },
          "bypassEarnCap": {
            "type": "boolean",
            "default": false,
            "description": "Skip earn cap enforcement (admin use)"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Free-form transaction metadata"
          }
        }
      },
      "CreditCurrencyResponse": {
        "type": "object",
        "description": "Result of credit operation",
        "additionalProperties": false,
        "required": [
          "transaction",
          "newBalance",
          "earnCapApplied",
          "walletCapApplied"
        ],
        "properties": {
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Created transaction record"
          },
          "newBalance": {
            "type": "number",
            "format": "double",
            "description": "Balance after credit"
          },
          "earnCapApplied": {
            "type": "boolean",
            "description": "Whether earn cap limited the credit"
          },
          "earnCapAmountLimited": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Amount reduced by earn cap"
          },
          "walletCapApplied": {
            "type": "boolean",
            "description": "Whether wallet cap limited the credit"
          },
          "walletCapAmountLost": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Amount lost due to wallet cap (cap_and_lose behavior)"
          }
        }
      },
      "CureBreachRequest": {
        "type": "object",
        "description": "Request to cure a breach",
        "additionalProperties": false,
        "required": [
          "breachId"
        ],
        "properties": {
          "breachId": {
            "type": "string",
            "format": "uuid",
            "description": "Breach to cure"
          },
          "cureEvidence": {
            "type": "string",
            "maxLength": 2000,
            "nullable": true,
            "description": "Evidence of cure"
          }
        }
      },
      "CurrencyDefinitionResponse": {
        "type": "object",
        "description": "Currency definition details",
        "additionalProperties": false,
        "required": [
          "definitionId",
          "code",
          "name",
          "scope",
          "precision",
          "transferable",
          "tradeable",
          "autogainEnabled",
          "expires",
          "linkedToItem",
          "isBaseCurrency",
          "isActive",
          "createdAt"
        ],
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique definition identifier"
          },
          "code": {
            "type": "string",
            "description": "Unique currency code"
          },
          "name": {
            "type": "string",
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Detailed description"
          },
          "scope": {
            "$ref": "#/components/schemas/CurrencyScope",
            "description": "Realm availability scope"
          },
          "realmsAvailable": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "Available realm IDs"
          },
          "precision": {
            "$ref": "#/components/schemas/CurrencyPrecision",
            "description": "Decimal precision"
          },
          "transferable": {
            "type": "boolean",
            "description": "Whether transferable between wallets"
          },
          "tradeable": {
            "type": "boolean",
            "description": "Whether usable in trades"
          },
          "allowNegative": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether negative balance allowed (null uses plugin default)"
          },
          "perWalletCap": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Maximum per-wallet balance"
          },
          "capOverflowBehavior": {
            "$ref": "#/components/schemas/CapOverflowBehavior",
            "nullable": true,
            "description": "Overflow behavior when cap exceeded"
          },
          "globalSupplyCap": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Global supply cap"
          },
          "dailyEarnCap": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Daily earn cap"
          },
          "weeklyEarnCap": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Weekly earn cap"
          },
          "earnCapResetTime": {
            "type": "string",
            "nullable": true,
            "description": "Earn cap reset time"
          },
          "autogainEnabled": {
            "type": "boolean",
            "description": "Whether autogain is enabled"
          },
          "autogainMode": {
            "$ref": "#/components/schemas/AutogainMode",
            "nullable": true,
            "description": "Autogain calculation mode"
          },
          "autogainAmount": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Autogain amount per interval"
          },
          "autogainInterval": {
            "type": "string",
            "nullable": true,
            "description": "Autogain interval duration"
          },
          "autogainCap": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Autogain balance cap"
          },
          "expires": {
            "type": "boolean",
            "description": "Whether currency can expire"
          },
          "expirationPolicy": {
            "$ref": "#/components/schemas/ExpirationPolicy",
            "nullable": true,
            "description": "Expiration policy"
          },
          "expirationDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Fixed expiration date"
          },
          "expirationDuration": {
            "type": "string",
            "nullable": true,
            "description": "Expiration duration"
          },
          "seasonId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Season ID for expiration"
          },
          "linkedToItem": {
            "type": "boolean",
            "description": "Whether linked to inventory item"
          },
          "linkedItemTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Linked item template ID"
          },
          "linkageMode": {
            "$ref": "#/components/schemas/ItemLinkageMode",
            "nullable": true,
            "description": "Item linkage mode"
          },
          "isBaseCurrency": {
            "type": "boolean",
            "description": "Whether this is the base currency"
          },
          "exchangeRateToBase": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Exchange rate to base currency"
          },
          "exchangeRateUpdatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When exchange rate was last updated"
          },
          "iconAssetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Icon asset ID"
          },
          "displayFormat": {
            "type": "string",
            "nullable": true,
            "description": "Display format string"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether definition is active"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "modifiedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last modification timestamp"
          }
        }
      },
      "CurrencyPrecision": {
        "type": "string",
        "description": "How the currency handles decimal values (immutable after creation)",
        "enum": [
          "integer",
          "decimal_2",
          "decimal_4",
          "decimal_8",
          "decimal_full",
          "big_integer"
        ]
      },
      "CurrencyScope": {
        "type": "string",
        "description": "Scope of currency availability across realms",
        "enum": [
          "global",
          "realm_specific",
          "multi_realm"
        ]
      },
      "CurrencyTransactionRecord": {
        "type": "object",
        "description": "Immutable record of a currency transaction",
        "additionalProperties": false,
        "required": [
          "transactionId",
          "currencyDefinitionId",
          "amount",
          "transactionType",
          "idempotencyKey",
          "timestamp"
        ],
        "properties": {
          "transactionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique transaction identifier"
          },
          "sourceWalletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Source wallet (null for faucets)"
          },
          "targetWalletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Target wallet (null for sinks)"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency definition ID"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Transaction amount (always positive)"
          },
          "transactionType": {
            "$ref": "#/components/schemas/TransactionType",
            "description": "Transaction classification"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "What triggered this transaction"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference entity ID"
          },
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Associated escrow ID"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When transaction occurred"
          },
          "sourceBalanceBefore": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Source balance before transaction"
          },
          "sourceBalanceAfter": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Source balance after transaction"
          },
          "targetBalanceBefore": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Target balance before transaction"
          },
          "targetBalanceAfter": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Target balance after transaction"
          },
          "autogainPeriodsApplied": {
            "type": "integer",
            "nullable": true,
            "description": "Number of autogain periods applied"
          },
          "overflowAmountLost": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Amount lost to cap overflow"
          },
          "earnCapAmountLimited": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Amount limited by earn cap"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Free-form metadata"
          }
        }
      },
      "CustomAffordance": {
        "type": "object",
        "description": "Custom affordance definition for novel scenarios",
        "properties": {
          "description": {
            "type": "string",
            "description": "Human-readable description of this affordance",
            "nullable": true
          },
          "requires": {
            "type": "object",
            "additionalProperties": true,
            "description": "Required criteria. Object types, property constraints.\nExample: { \"objectTypes\": [\"boulder\"], \"cover_rating\": { \"min\": 0.5 } }\n",
            "nullable": true
          },
          "prefers": {
            "type": "object",
            "additionalProperties": true,
            "description": "Preferred criteria (boost score but not required).\nExample: { \"elevation\": { \"prefer_higher\": true } }\n",
            "nullable": true
          },
          "excludes": {
            "type": "object",
            "additionalProperties": true,
            "description": "Exclusion criteria. Reject candidates matching these.\nExample: { \"hazards\": true, \"contested\": true }\n",
            "nullable": true
          }
        }
      },
      "CustomScripts": {
        "description": "Custom script injection configuration for adding JavaScript to pages",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "head": {
            "type": "string",
            "nullable": true,
            "description": "Custom scripts to inject in the HTML head"
          },
          "bodyStart": {
            "type": "string",
            "nullable": true,
            "description": "Custom scripts to inject at the start of the body"
          },
          "bodyEnd": {
            "type": "string",
            "nullable": true,
            "description": "Custom scripts to inject at the end of the body"
          }
        }
      },
      "DebitCurrencyRequest": {
        "type": "object",
        "description": "Request to debit currency from a wallet",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "transactionType",
          "idempotencyKey"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Source wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to debit"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to debit (must be positive)"
          },
          "transactionType": {
            "$ref": "#/components/schemas/TransactionType",
            "description": "Must be a sink type (burn, vendor_purchase, fee, etc.)"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "What triggered this transaction"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference entity ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Unique key to prevent duplicate processing"
          },
          "allowNegative": {
            "type": "boolean",
            "nullable": true,
            "description": "Override negative balance allowance for this transaction"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Free-form transaction metadata"
          }
        }
      },
      "DebitCurrencyResponse": {
        "type": "object",
        "description": "Result of debit operation",
        "additionalProperties": false,
        "required": [
          "transaction",
          "newBalance"
        ],
        "properties": {
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Created transaction record"
          },
          "newBalance": {
            "type": "number",
            "format": "double",
            "description": "Balance after debit"
          }
        }
      },
      "DeclineMatchRequest": {
        "type": "object",
        "description": "Request to decline a formed match",
        "additionalProperties": false,
        "required": [
          "webSocketSessionId",
          "accountId",
          "matchId"
        ],
        "properties": {
          "webSocketSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player"
          },
          "matchId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the match to decline"
          }
        }
      },
      "DeleteAchievementDefinitionRequest": {
        "type": "object",
        "description": "Request to delete an achievement",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "achievementId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "achievementId": {
            "type": "string",
            "description": "ID of the achievement to delete"
          }
        }
      },
      "DeleteActorTemplateRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to delete an actor template",
        "required": [
          "templateId"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the template to delete"
          },
          "forceStopActors": {
            "type": "boolean",
            "default": false,
            "description": "If true, stops all running actors using this template"
          }
        }
      },
      "DeleteActorTemplateResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response confirming template deletion",
        "required": [
          "deleted",
          "stoppedActorCount"
        ],
        "properties": {
          "deleted": {
            "type": "boolean",
            "description": "Whether the template was successfully deleted"
          },
          "stoppedActorCount": {
            "type": "integer",
            "description": "Number of running actors that were stopped"
          }
        }
      },
      "DeleteBundleRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to delete a bundle",
        "required": [
          "bundleId"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Bundle identifier to delete"
          },
          "permanent": {
            "type": "boolean",
            "default": false,
            "description": "If true, permanently delete (admin only). If false, soft-delete."
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for deletion (recorded in version history)"
          }
        }
      },
      "DeleteBundleResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of bundle deletion",
        "required": [
          "bundleId",
          "status",
          "deletedAt"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Deleted bundle identifier"
          },
          "status": {
            "type": "string",
            "enum": [
              "deleted",
              "permanently_deleted"
            ],
            "description": "Deletion status"
          },
          "deletedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the bundle was deleted"
          },
          "retentionUntil": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When soft-deleted bundle will be permanently removed (null for permanent deletes)"
          }
        }
      },
      "DeleteLeaderboardDefinitionRequest": {
        "type": "object",
        "description": "Request to delete a leaderboard",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard to delete"
          }
        }
      },
      "DeleteSceneRequest": {
        "type": "object",
        "description": "Request to delete a scene",
        "required": [
          "sceneId"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the scene to delete"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for deletion (included in event)"
          }
        }
      },
      "DeleteSceneResponse": {
        "type": "object",
        "description": "Response confirming scene deletion",
        "required": [
          "deleted"
        ],
        "properties": {
          "deleted": {
            "type": "boolean",
            "description": "Whether the scene was successfully deleted"
          },
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the deleted scene"
          },
          "referencingScenes": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "If deletion failed, IDs of scenes that reference this one"
          }
        }
      },
      "DeleteSlotRequest": {
        "type": "object",
        "description": "Request to permanently delete a save slot and all its versions",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "minLength": 1,
            "maxLength": 32,
            "pattern": "^[a-z][a-z0-9-]*$",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          }
        }
      },
      "DeleteSlotResponse": {
        "type": "object",
        "description": "Result of a slot deletion operation with cleanup statistics",
        "required": [
          "deleted",
          "versionsDeleted",
          "bytesFreed"
        ],
        "properties": {
          "deleted": {
            "type": "boolean",
            "description": "Whether slot was deleted"
          },
          "versionsDeleted": {
            "type": "integer",
            "description": "Number of versions deleted"
          },
          "bytesFreed": {
            "type": "integer",
            "format": "int64",
            "description": "Storage freed in bytes"
          }
        }
      },
      "DeleteVersionRequest": {
        "type": "object",
        "description": "Request to permanently delete a specific save version",
        "required": [
          "ownerId",
          "ownerType",
          "slotName",
          "versionNumber"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Version to delete"
          }
        }
      },
      "DeleteVersionResponse": {
        "type": "object",
        "description": "Result of a version deletion operation with storage freed",
        "required": [
          "deleted",
          "bytesFreed"
        ],
        "properties": {
          "deleted": {
            "type": "boolean",
            "description": "Whether version was deleted"
          },
          "bytesFreed": {
            "type": "integer",
            "format": "int64",
            "description": "Storage freed in bytes"
          }
        }
      },
      "DeltaAlgorithm": {
        "type": "string",
        "enum": [
          "JSON_PATCH",
          "BSDIFF",
          "XDELTA"
        ],
        "default": "JSON_PATCH",
        "description": "Algorithm used for delta computation.\nJSON_PATCH: RFC 6902, best for structured JSON data\nBSDIFF: Binary diff, good for general binary data\nXDELTA: RFC 3284 VCDIFF, efficient for large binary files\n"
      },
      "DepositRequest": {
        "type": "object",
        "description": "Request to deposit assets into an escrow",
        "required": [
          "escrowId",
          "partyId",
          "partyType",
          "assets",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party depositing"
          },
          "partyType": {
            "type": "string",
            "description": "Party type"
          },
          "assets": {
            "$ref": "#/components/schemas/EscrowAssetBundleInput",
            "description": "Assets to deposit"
          },
          "depositToken": {
            "type": "string",
            "nullable": true,
            "description": "Deposit token (required for full_consent)"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "DepositResponse": {
        "type": "object",
        "description": "Response from depositing assets into an escrow",
        "required": [
          "escrow",
          "deposit",
          "fullyFunded",
          "releaseTokens"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Updated escrow agreement"
          },
          "deposit": {
            "$ref": "#/components/schemas/EscrowDeposit",
            "description": "Deposit record"
          },
          "fullyFunded": {
            "type": "boolean",
            "description": "Whether escrow is now fully funded"
          },
          "releaseTokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartyToken"
            },
            "description": "Release tokens (issued when fully funded)"
          }
        }
      },
      "DestroyItemInstanceRequest": {
        "type": "object",
        "description": "Request to destroy an item instance",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "reason"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Instance ID to destroy"
          },
          "reason": {
            "type": "string",
            "description": "Reason for destruction (consumed, destroyed, expired, admin)"
          }
        }
      },
      "DestroyItemInstanceResponse": {
        "type": "object",
        "description": "Response after destroying an item instance",
        "additionalProperties": false,
        "required": [
          "destroyed",
          "instanceId",
          "templateId"
        ],
        "properties": {
          "destroyed": {
            "type": "boolean",
            "description": "Whether destruction was successful"
          },
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Destroyed instance ID"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template of destroyed instance"
          }
        }
      },
      "DeviceInfo": {
        "description": "Information about the client device used for authentication or session tracking",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "deviceType": {
            "type": "string",
            "enum": [
              "desktop",
              "mobile",
              "tablet",
              "console"
            ],
            "nullable": true,
            "description": "Category of the device"
          },
          "platform": {
            "type": "string",
            "nullable": true,
            "description": "Operating system or platform name"
          },
          "browser": {
            "type": "string",
            "nullable": true,
            "description": "Browser name and version if applicable"
          },
          "appVersion": {
            "type": "string",
            "nullable": true,
            "description": "Version of the client application"
          }
        }
      },
      "DiscardRequest": {
        "type": "object",
        "description": "Request to discard checkout",
        "required": [
          "sceneId",
          "checkoutToken"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene to discard changes for"
          },
          "checkoutToken": {
            "type": "string",
            "description": "Checkout token"
          }
        }
      },
      "DiscardResponse": {
        "type": "object",
        "description": "Response confirming discard",
        "required": [
          "discarded"
        ],
        "properties": {
          "discarded": {
            "type": "boolean",
            "description": "Whether discard was successful"
          }
        }
      },
      "DisputeRequest": {
        "type": "object",
        "description": "Request to raise a dispute on a funded escrow",
        "required": [
          "escrowId",
          "partyId",
          "partyType",
          "reason",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party raising dispute"
          },
          "partyType": {
            "type": "string",
            "description": "Party type"
          },
          "reason": {
            "type": "string",
            "description": "Reason for dispute"
          },
          "releaseToken": {
            "type": "string",
            "nullable": true,
            "description": "Release token (proves party identity)"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "DisputeResponse": {
        "type": "object",
        "description": "Response from raising a dispute on an escrow",
        "required": [
          "escrow"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Disputed escrow agreement"
          }
        }
      },
      "DistributionRecord": {
        "type": "object",
        "description": "Record of an asset distribution",
        "additionalProperties": false,
        "required": [
          "clauseId",
          "clauseType",
          "assetType",
          "amount"
        ],
        "properties": {
          "clauseId": {
            "type": "string",
            "description": "Clause that was executed"
          },
          "clauseType": {
            "type": "string",
            "description": "Type of clause (fee, distribution)"
          },
          "assetType": {
            "type": "string",
            "description": "Type of asset (currency, item)"
          },
          "amount": {
            "type": "number",
            "description": "Amount transferred"
          },
          "sourceWalletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Source wallet ID (for currency)"
          },
          "destinationWalletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Destination wallet ID (for currency)"
          },
          "sourceContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Source container ID (for items)"
          },
          "destinationContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Destination container ID (for items)"
          }
        }
      },
      "Document": {
        "description": "Complete document with all metadata and content",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "documentId",
          "namespace",
          "slug",
          "title",
          "category",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "documentId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the document"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace the document belongs to"
          },
          "slug": {
            "type": "string",
            "description": "URL-friendly unique identifier"
          },
          "title": {
            "type": "string",
            "description": "Display title of the document"
          },
          "category": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "Category for organizing the document"
          },
          "content": {
            "type": "string",
            "description": "Full markdown content of the document"
          },
          "summary": {
            "type": "string",
            "nullable": true,
            "description": "Brief text summary of the document"
          },
          "voiceSummary": {
            "type": "string",
            "nullable": true,
            "description": "Concise summary optimized for voice AI"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tags for filtering and search"
          },
          "relatedDocuments": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "IDs of related documents"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "description": "Custom metadata key-value pairs"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the document was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the document was last updated"
          }
        }
      },
      "DocumentCategory": {
        "type": "string",
        "enum": [
          "getting-started",
          "api-reference",
          "architecture",
          "deployment",
          "troubleshooting",
          "tutorials",
          "game-systems",
          "world-lore",
          "npc-ai",
          "other"
        ],
        "description": "Fixed categories for type-safe filtering"
      },
      "DocumentResult": {
        "description": "Search result with relevance scoring and match highlights",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "documentId",
          "slug",
          "title",
          "relevanceScore"
        ],
        "properties": {
          "documentId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the document"
          },
          "slug": {
            "type": "string",
            "description": "URL-friendly unique identifier"
          },
          "title": {
            "type": "string",
            "description": "Display title of the document"
          },
          "category": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "Category of the document"
          },
          "summary": {
            "type": "string",
            "nullable": true,
            "description": "Brief text summary of the document"
          },
          "voiceSummary": {
            "type": "string",
            "nullable": true,
            "description": "Concise summary optimized for voice AI"
          },
          "content": {
            "type": "string",
            "nullable": true,
            "description": "Full document content if requested"
          },
          "relevanceScore": {
            "type": "number",
            "format": "float",
            "description": "Relevance score from 0.0 to 1.0"
          },
          "matchHighlights": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Text snippets showing where matches occurred"
          }
        }
      },
      "DocumentSummary": {
        "description": "Lightweight document representation for listings and references",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "documentId",
          "slug",
          "title",
          "category"
        ],
        "properties": {
          "documentId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the document"
          },
          "slug": {
            "type": "string",
            "description": "URL-friendly unique identifier"
          },
          "title": {
            "type": "string",
            "description": "Display title of the document"
          },
          "category": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "Category of the document"
          },
          "summary": {
            "type": "string",
            "nullable": true,
            "description": "Brief text summary of the document"
          },
          "voiceSummary": {
            "type": "string",
            "nullable": true,
            "description": "Concise summary optimized for voice AI"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tags associated with the document"
          }
        }
      },
      "DownloadInfo": {
        "description": "Download details for a specific game client version and platform",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "platform",
          "version",
          "url",
          "size",
          "checksum"
        ],
        "properties": {
          "platform": {
            "type": "string",
            "enum": [
              "windows",
              "macos",
              "linux"
            ],
            "description": "Target operating system platform"
          },
          "version": {
            "type": "string",
            "description": "Version number of the game client"
          },
          "url": {
            "type": "string",
            "format": "uri",
            "description": "Download URL for the game client"
          },
          "size": {
            "type": "integer",
            "description": "File size in bytes"
          },
          "checksum": {
            "type": "string",
            "description": "SHA256 checksum"
          },
          "releaseNotes": {
            "type": "string",
            "nullable": true,
            "description": "Release notes or changelog for this version"
          },
          "minimumRequirements": {
            "type": "object",
            "additionalProperties": true,
            "description": "Minimum system requirements for the client"
          }
        }
      },
      "DownloadsResponse": {
        "description": "Collection of available game client downloads by platform",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "clients"
        ],
        "properties": {
          "clients": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DownloadInfo"
            },
            "description": "Available game client downloads"
          }
        }
      },
      "DuplicateSceneRequest": {
        "type": "object",
        "description": "Request to duplicate a scene",
        "required": [
          "sourceSceneId",
          "newName"
        ],
        "properties": {
          "sourceSceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene to duplicate"
          },
          "newName": {
            "type": "string",
            "description": "Name for the duplicate"
          },
          "newGameId": {
            "type": "string",
            "nullable": true,
            "description": "Optional different game ID"
          },
          "newSceneType": {
            "$ref": "#/components/schemas/SceneType",
            "nullable": true,
            "description": "Optional different scene type"
          }
        }
      },
      "EarnCapInfo": {
        "type": "object",
        "description": "Current earn cap status for a balance",
        "additionalProperties": false,
        "required": [
          "dailyEarned",
          "dailyRemaining",
          "dailyResetsAt",
          "weeklyEarned",
          "weeklyRemaining",
          "weeklyResetsAt"
        ],
        "properties": {
          "dailyEarned": {
            "type": "number",
            "format": "double",
            "description": "Amount earned today"
          },
          "dailyRemaining": {
            "type": "number",
            "format": "double",
            "description": "Remaining daily earn allowance"
          },
          "dailyResetsAt": {
            "type": "string",
            "format": "date-time",
            "description": "When daily counter resets"
          },
          "weeklyEarned": {
            "type": "number",
            "format": "double",
            "description": "Amount earned this week"
          },
          "weeklyRemaining": {
            "type": "number",
            "format": "double",
            "description": "Remaining weekly earn allowance"
          },
          "weeklyResetsAt": {
            "type": "string",
            "format": "date-time",
            "description": "When weekly counter resets"
          }
        }
      },
      "EmotionalImpact": {
        "type": "string",
        "description": "How the encounter emotionally affected the character",
        "enum": [
          "GRATITUDE",
          "ANGER",
          "FEAR",
          "RESPECT",
          "CONTEMPT",
          "AFFECTION",
          "RIVALRY",
          "INDIFFERENCE",
          "GUILT",
          "PRIDE"
        ]
      },
      "EmotionalStateInput": {
        "description": "6-dimensional emotional state input (all values 0-1)",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "tension": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "nullable": true,
            "description": "Tension level (0=resolved, 1=maximum tension)"
          },
          "brightness": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "nullable": true,
            "description": "Brightness level (0=dark, 1=bright)"
          },
          "energy": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "nullable": true,
            "description": "Energy level (0=calm, 1=energetic)"
          },
          "warmth": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "nullable": true,
            "description": "Warmth level (0=distant, 1=intimate)"
          },
          "stability": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "nullable": true,
            "description": "Stability level (0=unstable, 1=grounded)"
          },
          "valence": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "nullable": true,
            "description": "Valence level (0=negative, 1=positive)"
          }
        }
      },
      "EmotionalStateSnapshot": {
        "description": "Snapshot of emotional state at a specific point in the composition",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bar",
          "tension",
          "brightness",
          "energy"
        ],
        "properties": {
          "bar": {
            "type": "integer",
            "description": "Bar number where this snapshot was taken"
          },
          "phaseName": {
            "type": "string",
            "nullable": true,
            "description": "Name of the narrative phase at this point"
          },
          "tension": {
            "type": "number",
            "description": "Tension level (0-1)"
          },
          "brightness": {
            "type": "number",
            "description": "Brightness level (0-1)"
          },
          "energy": {
            "type": "number",
            "description": "Energy level (0-1)"
          },
          "warmth": {
            "type": "number",
            "description": "Warmth level (0-1)"
          },
          "stability": {
            "type": "number",
            "description": "Stability level (0-1)"
          },
          "valence": {
            "type": "number",
            "description": "Valence level (0-1)"
          }
        }
      },
      "EncounterListResponse": {
        "type": "object",
        "description": "Paginated list of encounters",
        "additionalProperties": false,
        "required": [
          "encounters",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "encounters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EncounterResponse"
            },
            "description": "List of encounters with perspectives"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total matching encounters"
          },
          "page": {
            "type": "integer",
            "description": "Current page (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "description": "Results per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether more results exist"
          },
          "hasPreviousPage": {
            "type": "boolean",
            "description": "Whether previous results exist"
          }
        }
      },
      "EncounterModel": {
        "type": "object",
        "description": "Core encounter record representing a memorable interaction",
        "additionalProperties": false,
        "required": [
          "encounterId",
          "timestamp",
          "realmId",
          "encounterTypeCode",
          "outcome",
          "participantIds",
          "createdAt"
        ],
        "properties": {
          "encounterId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this encounter"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "In-game time when the encounter occurred"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm where the encounter took place"
          },
          "locationId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Specific location within the realm (optional)"
          },
          "encounterTypeCode": {
            "type": "string",
            "description": "Type code for this encounter (e.g., COMBAT, TRADE)"
          },
          "context": {
            "type": "string",
            "maxLength": 500,
            "nullable": true,
            "description": "What triggered or contextualized the encounter"
          },
          "outcome": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EncounterOutcome"
              }
            ],
            "description": "Outcome of the encounter (POSITIVE, NEGATIVE, NEUTRAL, MEMORABLE, TRANSFORMATIVE)"
          },
          "participantIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "minItems": 2,
            "description": "All character IDs involved in the encounter"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional encounter-specific data"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "System timestamp when record was created"
          }
        }
      },
      "EncounterOutcome": {
        "type": "string",
        "description": "Overall outcome of an encounter",
        "enum": [
          "POSITIVE",
          "NEGATIVE",
          "NEUTRAL",
          "MEMORABLE",
          "TRANSFORMATIVE"
        ]
      },
      "EncounterPerspectiveModel": {
        "type": "object",
        "description": "A character's individual perspective on an encounter",
        "additionalProperties": false,
        "required": [
          "perspectiveId",
          "encounterId",
          "characterId",
          "emotionalImpact",
          "memoryStrength",
          "createdAt"
        ],
        "properties": {
          "perspectiveId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this perspective"
          },
          "encounterId": {
            "type": "string",
            "format": "uuid",
            "description": "Reference to the shared encounter record"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character holding this perspective"
          },
          "emotionalImpact": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EmotionalImpact"
              }
            ],
            "description": "Primary emotional response to the encounter"
          },
          "sentimentShift": {
            "type": "number",
            "format": "float",
            "minimum": -1.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Opinion change toward other participants (-1.0 to +1.0)"
          },
          "memoryStrength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "How strongly remembered (0.0-1.0, decays over time)"
          },
          "rememberedAs": {
            "type": "string",
            "maxLength": 200,
            "nullable": true,
            "description": "Short description from this character's POV"
          },
          "lastDecayedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When memory decay was last applied"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "System timestamp when record was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last modification timestamp"
          }
        }
      },
      "EncounterResponse": {
        "type": "object",
        "description": "Response containing an encounter with perspectives",
        "additionalProperties": false,
        "required": [
          "encounter",
          "perspectives"
        ],
        "properties": {
          "encounter": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EncounterModel"
              }
            ],
            "description": "The shared encounter record"
          },
          "perspectives": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EncounterPerspectiveModel"
            },
            "description": "All perspectives on this encounter"
          }
        }
      },
      "EncounterTypeListResponse": {
        "type": "object",
        "description": "Response containing a list of encounter types",
        "additionalProperties": false,
        "required": [
          "types",
          "totalCount"
        ],
        "properties": {
          "types": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EncounterTypeResponse"
            },
            "description": "List of encounter types"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of types"
          }
        }
      },
      "EncounterTypeResponse": {
        "type": "object",
        "description": "Response containing an encounter type",
        "additionalProperties": false,
        "required": [
          "typeId",
          "code",
          "name",
          "isBuiltIn",
          "sortOrder",
          "isActive",
          "createdAt"
        ],
        "properties": {
          "typeId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier"
          },
          "code": {
            "type": "string",
            "description": "Unique code"
          },
          "name": {
            "type": "string",
            "description": "Display name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Description"
          },
          "isBuiltIn": {
            "type": "boolean",
            "description": "Whether this is a built-in type"
          },
          "defaultEmotionalImpact": {
            "$ref": "#/components/schemas/EmotionalImpact",
            "nullable": true,
            "description": "Suggested emotional response"
          },
          "sortOrder": {
            "type": "integer",
            "description": "Display ordering"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether the type is active"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the type was created"
          }
        }
      },
      "EndEncounterRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to end an active encounter",
        "required": [
          "actorId"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "ID of the Event Brain actor managing the encounter"
          }
        }
      },
      "EndEncounterResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response after ending an encounter",
        "required": [
          "actorId",
          "encounterId"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "ID of the actor"
          },
          "encounterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the ended encounter"
          },
          "durationMs": {
            "type": "integer",
            "nullable": true,
            "description": "Duration of the encounter in milliseconds"
          }
        }
      },
      "EnforcementMode": {
        "type": "string",
        "description": "How contract breaches are handled",
        "enum": [
          "advisory",
          "event_only",
          "consequence_based",
          "community"
        ]
      },
      "EnrichedCharacterResponse": {
        "description": "Character data with optional enriched fields.\nFields are only populated if the corresponding include flag was set in the request.\n",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId",
          "name",
          "realmId",
          "speciesId",
          "birthDate",
          "status",
          "createdAt"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the character"
          },
          "name": {
            "type": "string",
            "description": "Display name of the character"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID (partition key)"
          },
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "description": "Species ID (foreign key to Species service)"
          },
          "birthDate": {
            "type": "string",
            "format": "date-time",
            "description": "In-game birth timestamp"
          },
          "deathDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "In-game death timestamp"
          },
          "status": {
            "$ref": "#/components/schemas/CharacterStatus",
            "description": "Current lifecycle status of the character"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Real-world creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Real-world last update timestamp"
          },
          "personality": {
            "$ref": "#/components/schemas/PersonalitySnapshot",
            "nullable": true,
            "description": "Personality traits (included if includePersonality=true)"
          },
          "backstory": {
            "$ref": "#/components/schemas/BackstorySnapshot",
            "nullable": true,
            "description": "Backstory elements (included if includeBackstory=true)"
          },
          "familyTree": {
            "$ref": "#/components/schemas/FamilyTreeResponse",
            "nullable": true,
            "description": "Family relationships (included if includeFamilyTree=true)"
          },
          "combatPreferences": {
            "$ref": "#/components/schemas/CombatPreferencesSnapshot",
            "nullable": true,
            "description": "Combat preferences (included if includeCombatPreferences=true)"
          }
        }
      },
      "EntityRankResponse": {
        "type": "object",
        "description": "Entity's rank on a leaderboard",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "score",
          "rank",
          "totalEntries"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type for the ranked entity"
          },
          "score": {
            "type": "number",
            "format": "double",
            "description": "Entity's current score"
          },
          "rank": {
            "type": "integer",
            "format": "int64",
            "description": "Entity's current rank (1-based)"
          },
          "totalEntries": {
            "type": "integer",
            "format": "int64",
            "description": "Total entries on the leaderboard"
          },
          "percentile": {
            "type": "number",
            "format": "double",
            "description": "Percentile ranking (0-100)"
          }
        }
      },
      "EntityType": {
        "type": "string",
        "description": "Type of entity that can earn achievements",
        "enum": [
          "account",
          "character",
          "guild",
          "actor",
          "custom"
        ]
      },
      "ErrorResponse": {
        "type": "object",
        "description": "Standard error response format",
        "required": [
          "error",
          "message"
        ],
        "properties": {
          "error": {
            "type": "string",
            "description": "Error code"
          },
          "message": {
            "type": "string",
            "description": "Human-readable error message"
          },
          "details": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Additional error details"
          }
        }
      },
      "EscrowAgreement": {
        "type": "object",
        "description": "Main escrow agreement record",
        "required": [
          "id",
          "escrowType",
          "trustMode",
          "parties",
          "expectedDeposits",
          "deposits",
          "consents",
          "status",
          "requiredConsentsForRelease",
          "createdAt",
          "createdBy",
          "createdByType",
          "expiresAt"
        ],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique escrow agreement identifier"
          },
          "escrowType": {
            "$ref": "#/components/schemas/EscrowType",
            "description": "Type of escrow agreement"
          },
          "trustMode": {
            "$ref": "#/components/schemas/EscrowTrustMode",
            "description": "Trust mode for the escrow"
          },
          "trustedPartyId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "For single_party_trusted - which party has authority"
          },
          "trustedPartyType": {
            "type": "string",
            "nullable": true,
            "description": "Type of the trusted party"
          },
          "initiatorServiceId": {
            "type": "string",
            "nullable": true,
            "description": "For initiator_trusted - which service created this"
          },
          "parties": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowParty"
            },
            "description": "All parties involved in the escrow"
          },
          "expectedDeposits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExpectedDeposit"
            },
            "description": "What deposits are expected from each party"
          },
          "deposits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowDeposit"
            },
            "description": "Actual deposits received"
          },
          "releaseAllocations": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/ReleaseAllocation"
            },
            "description": "How assets should be distributed on release"
          },
          "boundContractId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract governing conditions for this escrow"
          },
          "consents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowConsent"
            },
            "description": "Consent decisions from parties"
          },
          "status": {
            "$ref": "#/components/schemas/EscrowStatus",
            "description": "Current escrow status"
          },
          "requiredConsentsForRelease": {
            "type": "integer",
            "description": "How many parties must consent for release (-1 = all required)"
          },
          "lastValidatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the escrow was last validated"
          },
          "validationFailures": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/ValidationFailure"
            },
            "description": "Any validation failures detected"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the escrow was created"
          },
          "createdBy": {
            "type": "string",
            "format": "uuid",
            "description": "Who created the escrow"
          },
          "createdByType": {
            "type": "string",
            "description": "Type of the creator entity"
          },
          "fundedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When all expected deposits were received"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "Auto-refund if not completed by this time"
          },
          "completedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the escrow reached terminal state"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "What this escrow is for (e.g., trade, auction, contract)"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of the referenced entity"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Game/application specific metadata"
          },
          "resolution": {
            "$ref": "#/components/schemas/EscrowResolution",
            "description": "How the escrow was resolved",
            "nullable": true
          },
          "resolutionNotes": {
            "type": "string",
            "nullable": true,
            "description": "Notes about the resolution"
          }
        }
      },
      "EscrowAsset": {
        "type": "object",
        "description": "An asset held in escrow",
        "required": [
          "assetType",
          "sourceOwnerId",
          "sourceOwnerType"
        ],
        "properties": {
          "assetType": {
            "$ref": "#/components/schemas/AssetType",
            "description": "Type of asset held in escrow"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "For assetType=currency - currency definition ID"
          },
          "currencyCode": {
            "type": "string",
            "nullable": true,
            "description": "Denormalized currency code for display"
          },
          "currencyAmount": {
            "type": "number",
            "nullable": true,
            "description": "Amount of currency"
          },
          "itemInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "For assetType=item - unique item instance ID"
          },
          "itemName": {
            "type": "string",
            "nullable": true,
            "description": "Denormalized item name for display"
          },
          "itemTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "For assetType=item_stack - stackable item template"
          },
          "itemTemplateName": {
            "type": "string",
            "nullable": true,
            "description": "Denormalized template name for display"
          },
          "itemQuantity": {
            "type": "integer",
            "nullable": true,
            "description": "For assetType=item_stack - quantity"
          },
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "For assetType=contract - contract instance ID"
          },
          "contractTemplateCode": {
            "type": "string",
            "nullable": true,
            "description": "Denormalized contract template code"
          },
          "contractDescription": {
            "type": "string",
            "nullable": true,
            "description": "Description of the contract"
          },
          "contractPartyRole": {
            "type": "string",
            "nullable": true,
            "description": "Which party role in the contract is being escrowed"
          },
          "customAssetType": {
            "type": "string",
            "nullable": true,
            "description": "For assetType=custom - registered handler type"
          },
          "customAssetId": {
            "type": "string",
            "nullable": true,
            "description": "Custom asset identifier"
          },
          "customAssetData": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Handler-specific data"
          },
          "sourceOwnerId": {
            "type": "string",
            "format": "uuid",
            "description": "Where this asset came from (for refunds)"
          },
          "sourceOwnerType": {
            "type": "string",
            "description": "Type of the source owner"
          },
          "sourceContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Source wallet/container ID"
          }
        }
      },
      "EscrowAssetBundle": {
        "type": "object",
        "description": "Groups multiple assets for a single deposit or release",
        "required": [
          "bundleId",
          "assets"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "format": "uuid",
            "description": "Bundle identifier"
          },
          "assets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAsset"
            },
            "description": "Assets in this bundle"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Summary for display"
          },
          "estimatedValue": {
            "type": "number",
            "nullable": true,
            "description": "Optional valuation for UI display"
          }
        }
      },
      "EscrowAssetBundleInput": {
        "type": "object",
        "description": "Input for specifying a bundle of assets",
        "required": [
          "assets"
        ],
        "properties": {
          "assets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAssetInput"
            },
            "description": "Assets to deposit"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Bundle description"
          },
          "estimatedValue": {
            "type": "number",
            "nullable": true,
            "description": "Estimated value"
          }
        }
      },
      "EscrowAssetInput": {
        "type": "object",
        "description": "Input for specifying an asset in escrow operations",
        "required": [
          "assetType"
        ],
        "properties": {
          "assetType": {
            "$ref": "#/components/schemas/AssetType",
            "description": "Type of asset to deposit"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Currency definition ID"
          },
          "currencyCode": {
            "type": "string",
            "nullable": true,
            "description": "Currency code"
          },
          "currencyAmount": {
            "type": "number",
            "nullable": true,
            "description": "Currency amount"
          },
          "itemInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Item instance ID"
          },
          "itemName": {
            "type": "string",
            "nullable": true,
            "description": "Item name"
          },
          "itemTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Item template ID (for stacks)"
          },
          "itemTemplateName": {
            "type": "string",
            "nullable": true,
            "description": "Item template name"
          },
          "itemQuantity": {
            "type": "integer",
            "nullable": true,
            "description": "Item quantity (for stacks)"
          },
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract instance ID"
          },
          "contractTemplateCode": {
            "type": "string",
            "nullable": true,
            "description": "Contract template code"
          },
          "contractDescription": {
            "type": "string",
            "nullable": true,
            "description": "Contract description"
          },
          "contractPartyRole": {
            "type": "string",
            "nullable": true,
            "description": "Contract party role being escrowed"
          },
          "customAssetType": {
            "type": "string",
            "nullable": true,
            "description": "Custom asset type"
          },
          "customAssetId": {
            "type": "string",
            "nullable": true,
            "description": "Custom asset ID"
          },
          "customAssetData": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Custom asset data"
          }
        }
      },
      "EscrowConsent": {
        "type": "object",
        "description": "Records a party consent decision",
        "required": [
          "partyId",
          "partyType",
          "consentType",
          "consentedAt"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party giving consent"
          },
          "partyType": {
            "type": "string",
            "description": "Type of the party"
          },
          "consentType": {
            "$ref": "#/components/schemas/EscrowConsentType",
            "description": "Type of consent given"
          },
          "consentedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When consent was given"
          },
          "releaseTokenUsed": {
            "type": "string",
            "nullable": true,
            "description": "Token used (for audit)"
          },
          "notes": {
            "type": "string",
            "nullable": true,
            "description": "Optional notes"
          }
        }
      },
      "EscrowConsentType": {
        "type": "string",
        "description": "Type of consent being given.\n- release: Agrees to release assets to recipients\n- refund: Agrees to refund assets to depositors\n- dispute: Raises a dispute\n- reaffirm: Re-affirms after validation failure\n",
        "enum": [
          "release",
          "refund",
          "dispute",
          "reaffirm"
        ]
      },
      "EscrowDeposit": {
        "type": "object",
        "description": "Records an actual deposit",
        "required": [
          "id",
          "escrowId",
          "partyId",
          "partyType",
          "assets",
          "depositedAt",
          "idempotencyKey"
        ],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Deposit record identifier"
          },
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow this deposit belongs to"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party who deposited"
          },
          "partyType": {
            "type": "string",
            "description": "Type of the depositing party"
          },
          "assets": {
            "$ref": "#/components/schemas/EscrowAssetBundle",
            "description": "Assets deposited"
          },
          "depositedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the deposit was made"
          },
          "depositTokenUsed": {
            "type": "string",
            "nullable": true,
            "description": "Token used (for audit)"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key for this deposit"
          }
        }
      },
      "EscrowDepositRequest": {
        "type": "object",
        "description": "Request from lib-escrow to debit wallet for deposit",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "escrowId",
          "idempotencyKey"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet to debit"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to debit"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to debit for escrow"
          },
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Associated escrow agreement ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Idempotency key"
          }
        }
      },
      "EscrowDepositResponse": {
        "type": "object",
        "description": "Result of escrow deposit (wallet debit)",
        "additionalProperties": false,
        "required": [
          "transaction",
          "newBalance"
        ],
        "properties": {
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Debit transaction record"
          },
          "newBalance": {
            "type": "number",
            "format": "double",
            "description": "Wallet balance after debit"
          }
        }
      },
      "EscrowParty": {
        "type": "object",
        "description": "A party in the escrow agreement",
        "required": [
          "partyId",
          "partyType",
          "role",
          "consentRequired",
          "depositTokenUsed",
          "releaseTokenUsed"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party entity identifier"
          },
          "partyType": {
            "type": "string",
            "description": "Type of the party entity (account, character, npc, guild, system)"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Display name for UI/logging"
          },
          "role": {
            "$ref": "#/components/schemas/EscrowPartyRole",
            "description": "Role of this party in the escrow"
          },
          "consentRequired": {
            "type": "boolean",
            "description": "Whether this party consent is required for release"
          },
          "walletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Party own wallet (where currency comes from/returns to)"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Party own container (where items come from/return to)"
          },
          "escrowWalletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Escrow wallet for THIS party deposits (owned by escrow)"
          },
          "escrowContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Escrow container for THIS party deposits (owned by escrow)"
          },
          "depositToken": {
            "type": "string",
            "nullable": true,
            "description": "Token for depositing (full_consent mode)"
          },
          "depositTokenUsed": {
            "type": "boolean",
            "description": "Whether the deposit token has been used"
          },
          "depositTokenUsedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the deposit token was used"
          },
          "releaseToken": {
            "type": "string",
            "nullable": true,
            "description": "Token for consenting to release"
          },
          "releaseTokenUsed": {
            "type": "boolean",
            "description": "Whether the release token has been used"
          },
          "releaseTokenUsedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the release token was used"
          }
        }
      },
      "EscrowPartyRole": {
        "type": "string",
        "description": "Role of a party in the escrow.\n- depositor: Deposits assets into escrow\n- recipient: Receives assets when released\n- depositor_recipient: Both deposits and can receive (typical for trades)\n- arbiter: Can resolve disputes, does not deposit or receive\n- observer: Can view status but cannot act\n",
        "enum": [
          "depositor",
          "recipient",
          "depositor_recipient",
          "arbiter",
          "observer"
        ]
      },
      "EscrowRefundRequest": {
        "type": "object",
        "description": "Request from lib-escrow to credit depositor on refund",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "escrowId",
          "idempotencyKey"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Depositor wallet to credit"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to credit"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to refund"
          },
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Associated escrow agreement ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Idempotency key"
          }
        }
      },
      "EscrowRefundResponse": {
        "type": "object",
        "description": "Result of escrow refund (depositor credit)",
        "additionalProperties": false,
        "required": [
          "transaction",
          "newBalance"
        ],
        "properties": {
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Credit transaction record"
          },
          "newBalance": {
            "type": "number",
            "format": "double",
            "description": "Depositor balance after credit"
          }
        }
      },
      "EscrowReleaseRequest": {
        "type": "object",
        "description": "Request from lib-escrow to credit recipient on completion",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "escrowId",
          "idempotencyKey"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Recipient wallet to credit"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to credit"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to credit"
          },
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Associated escrow agreement ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Idempotency key"
          }
        }
      },
      "EscrowReleaseResponse": {
        "type": "object",
        "description": "Result of escrow release (recipient credit)",
        "additionalProperties": false,
        "required": [
          "transaction",
          "newBalance"
        ],
        "properties": {
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Credit transaction record"
          },
          "newBalance": {
            "type": "number",
            "format": "double",
            "description": "Recipient balance after credit"
          }
        }
      },
      "EscrowResolution": {
        "type": "string",
        "description": "How the escrow was resolved.\n- released: Assets went to designated recipients\n- refunded: Assets returned to depositors\n- split: Arbiter split assets between parties\n- expired_refunded: Timed out, auto-refunded\n- cancelled_refunded: Cancelled, deposits refunded\n- violation_refunded: Validation failure caused refund\n",
        "enum": [
          "released",
          "refunded",
          "split",
          "expired_refunded",
          "cancelled_refunded",
          "violation_refunded"
        ]
      },
      "EscrowStatus": {
        "type": "string",
        "description": "Current status of the escrow agreement.\n- pending_deposits: Waiting for parties to deposit\n- partially_funded: Some but not all deposits received\n- funded: All deposits received, awaiting consent/condition\n- pending_consent: Some consents received, waiting for more\n- pending_condition: Waiting for contract fulfillment or external verification\n- finalizing: Running contract finalizer prebound APIs (transient)\n- releasing: Release in progress (transient)\n- released: Assets transferred to recipients\n- refunding: Refund in progress (transient)\n- refunded: Assets returned to depositors\n- disputed: In dispute, arbiter must resolve\n- expired: Timed out without completion\n- cancelled: Cancelled before funding complete\n- validation_failed: Held assets changed, awaiting re-affirmation\n",
        "enum": [
          "pending_deposits",
          "partially_funded",
          "funded",
          "pending_consent",
          "pending_condition",
          "finalizing",
          "releasing",
          "released",
          "refunding",
          "refunded",
          "disputed",
          "expired",
          "cancelled",
          "validation_failed"
        ]
      },
      "EscrowTrustMode": {
        "type": "string",
        "description": "Trust model for the escrow agreement.\n- full_consent: All parties must explicitly consent using tokens\n- initiator_trusted: The service that created the escrow can complete unilaterally\n- single_party_trusted: A designated party can complete unilaterally\n",
        "enum": [
          "full_consent",
          "initiator_trusted",
          "single_party_trusted"
        ]
      },
      "EscrowType": {
        "type": "string",
        "description": "Type of escrow agreement.\n- two_party: Simple trade escrow between Party A and Party B\n- multi_party: N parties with complex deposit/receive rules\n- conditional: Release based on external condition or contract fulfillment\n- auction: Winner-takes-all with refunds to losers\n",
        "enum": [
          "two_party",
          "multi_party",
          "conditional",
          "auction"
        ]
      },
      "EventCategory": {
        "type": "string",
        "description": "Categories of historical events that characters can participate in",
        "enum": [
          "WAR",
          "NATURAL_DISASTER",
          "POLITICAL",
          "ECONOMIC",
          "RELIGIOUS",
          "CULTURAL",
          "PERSONAL"
        ]
      },
      "ExecuteContractRequest": {
        "type": "object",
        "description": "Request to execute contract clauses",
        "additionalProperties": false,
        "required": [
          "contractInstanceId"
        ],
        "properties": {
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Idempotency key for the execution"
          }
        }
      },
      "ExecuteContractResponse": {
        "type": "object",
        "description": "Response from executing a contract",
        "additionalProperties": false,
        "required": [
          "executed",
          "alreadyExecuted"
        ],
        "properties": {
          "executed": {
            "type": "boolean",
            "description": "Whether execution was successful"
          },
          "alreadyExecuted": {
            "type": "boolean",
            "description": "True if this was a repeat call (idempotency)"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "distributions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DistributionRecord"
            },
            "nullable": true,
            "description": "Records of what was moved where"
          },
          "executedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When execution occurred"
          }
        }
      },
      "ExecuteConversionRequest": {
        "type": "object",
        "description": "Request to execute a currency conversion",
        "additionalProperties": false,
        "required": [
          "walletId",
          "fromCurrencyId",
          "toCurrencyId",
          "fromAmount",
          "idempotencyKey"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet to perform conversion in"
          },
          "fromCurrencyId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to debit"
          },
          "toCurrencyId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to credit"
          },
          "fromAmount": {
            "type": "number",
            "format": "double",
            "description": "Amount to convert"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Unique key for idempotency"
          }
        }
      },
      "ExecuteConversionResponse": {
        "type": "object",
        "description": "Result of conversion execution",
        "additionalProperties": false,
        "required": [
          "debitTransaction",
          "creditTransaction",
          "fromDebited",
          "toCredited",
          "effectiveRate"
        ],
        "properties": {
          "debitTransaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Debit transaction (conversion_debit)"
          },
          "creditTransaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Credit transaction (conversion_credit)"
          },
          "fromDebited": {
            "type": "number",
            "format": "double",
            "description": "Amount debited"
          },
          "toCredited": {
            "type": "number",
            "format": "double",
            "description": "Amount credited"
          },
          "effectiveRate": {
            "type": "number",
            "format": "double",
            "description": "Rate applied"
          }
        }
      },
      "ExecutionMetadata": {
        "type": "object",
        "additionalProperties": false,
        "description": "Metadata about behavior execution requirements including timing, resources, and interrupt conditions",
        "properties": {
          "estimatedDuration": {
            "type": "integer",
            "description": "Estimated execution time in seconds"
          },
          "resourceRequirements": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            },
            "nullable": true,
            "description": "Resource requirements for behavior execution"
          },
          "interruptConditions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Conditions that can interrupt behavior execution"
          }
        }
      },
      "ExpectedDeposit": {
        "type": "object",
        "description": "Defines what a party should deposit",
        "required": [
          "partyId",
          "partyType",
          "expectedAssets",
          "optional",
          "fulfilled"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party who should deposit"
          },
          "partyType": {
            "type": "string",
            "description": "Type of the party"
          },
          "expectedAssets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAsset"
            },
            "description": "Expected assets from this party"
          },
          "optional": {
            "type": "boolean",
            "description": "Is this deposit optional"
          },
          "depositDeadline": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Deadline for this specific deposit"
          },
          "fulfilled": {
            "type": "boolean",
            "description": "Has this party fulfilled their deposit requirement"
          }
        }
      },
      "ExpectedDepositInput": {
        "type": "object",
        "description": "Input for defining expected deposits from a party",
        "required": [
          "partyId",
          "partyType",
          "expectedAssets"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party who should deposit"
          },
          "partyType": {
            "type": "string",
            "description": "Type of the party"
          },
          "expectedAssets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAssetInput"
            },
            "description": "Expected assets"
          },
          "optional": {
            "type": "boolean",
            "nullable": true,
            "description": "Is this deposit optional"
          },
          "depositDeadline": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Specific deadline for this deposit"
          }
        }
      },
      "ExpirationPolicy": {
        "type": "string",
        "description": "How currency expiration is determined",
        "enum": [
          "fixed_date",
          "duration_from_earn",
          "end_of_season"
        ]
      },
      "ExportSavesRequest": {
        "type": "object",
        "description": "Request to export all saves for an owner to a downloadable archive",
        "required": [
          "gameId",
          "ownerId",
          "ownerType"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID that owns the saves to export"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns the saves to export"
          },
          "slotNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Specific slots to export (all if null)"
          }
        }
      },
      "ExportSavesResponse": {
        "type": "object",
        "description": "Response with pre-signed URL for downloading exported save archive",
        "required": [
          "downloadUrl",
          "expiresAt",
          "sizeBytes"
        ],
        "properties": {
          "downloadUrl": {
            "type": "string",
            "format": "uri",
            "description": "Pre-signed URL to download export archive"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the download URL expires"
          },
          "sizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Archive size"
          }
        }
      },
      "FailMilestoneRequest": {
        "type": "object",
        "description": "Request to fail a milestone",
        "additionalProperties": false,
        "required": [
          "contractId",
          "milestoneCode"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "milestoneCode": {
            "type": "string",
            "description": "Milestone that failed"
          },
          "reason": {
            "type": "string",
            "maxLength": 1000,
            "nullable": true,
            "description": "Reason for failure"
          }
        }
      },
      "FamilyMember": {
        "description": "Reference to a family member",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId",
          "relationshipType"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the related character"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "Display name (if available)"
          },
          "relationshipType": {
            "type": "string",
            "description": "Specific relationship type (MOTHER, FATHER, SON, DAUGHTER, etc.)"
          },
          "isAlive": {
            "type": "boolean",
            "description": "Whether the related character is alive"
          }
        }
      },
      "FamilyTreeResponse": {
        "description": "Family relationships for a character",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "parents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FamilyMember"
            },
            "description": "Parent relationships (biological and adoptive)"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FamilyMember"
            },
            "description": "Child relationships"
          },
          "siblings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FamilyMember"
            },
            "description": "Sibling relationships (including half-siblings)"
          },
          "spouse": {
            "$ref": "#/components/schemas/FamilyMember",
            "nullable": true,
            "description": "Current spouse (if any)"
          },
          "pastLives": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PastLifeReference"
            },
            "description": "Previous incarnations (if reincarnation tracked)"
          }
        }
      },
      "FinalizerResult": {
        "type": "object",
        "description": "Result from a contract finalizer API call",
        "required": [
          "endpoint",
          "success"
        ],
        "properties": {
          "endpoint": {
            "type": "string",
            "description": "Finalizer endpoint"
          },
          "success": {
            "type": "boolean",
            "description": "Whether it succeeded"
          },
          "error": {
            "type": "string",
            "nullable": true,
            "description": "Error message if failed"
          }
        }
      },
      "FindAssetUsageRequest": {
        "type": "object",
        "description": "Request to find asset usage",
        "required": [
          "assetId"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "format": "uuid",
            "description": "Asset ID to find usage of"
          },
          "gameId": {
            "type": "string",
            "nullable": true,
            "description": "Optional game filter"
          }
        }
      },
      "FindAssetUsageResponse": {
        "type": "object",
        "description": "Scenes using the asset",
        "required": [
          "usages"
        ],
        "properties": {
          "usages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetUsageInfo"
            },
            "description": "Asset usage instances"
          }
        }
      },
      "FindReferencesRequest": {
        "type": "object",
        "description": "Request to find referencing scenes",
        "required": [
          "sceneId"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene ID to find references to"
          }
        }
      },
      "FindReferencesResponse": {
        "type": "object",
        "description": "Scenes that reference the target",
        "required": [
          "referencingScenes"
        ],
        "properties": {
          "referencingScenes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ReferenceInfo"
            },
            "description": "Scenes containing references"
          }
        }
      },
      "FindSpaceRequest": {
        "type": "object",
        "description": "Request to find space for item",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "templateId"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner to search"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Owner type"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Item template"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "default": 1,
            "description": "Quantity to place"
          },
          "preferStackable": {
            "type": "boolean",
            "default": true,
            "description": "Prefer existing stacks"
          }
        }
      },
      "FindSpaceResponse": {
        "type": "object",
        "description": "Find space result",
        "additionalProperties": false,
        "required": [
          "hasSpace",
          "candidates"
        ],
        "properties": {
          "hasSpace": {
            "type": "boolean",
            "description": "Whether space found"
          },
          "candidates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpaceCandidate"
            },
            "description": "Potential placements"
          }
        }
      },
      "FormTemplate": {
        "description": "A musical form structure template",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "name",
          "sections"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Form name (e.g., \"AABB\", \"verse-chorus\")"
          },
          "sections": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Section sequence (e.g., [\"A\", \"A\", \"B\", \"B\"])"
          },
          "barsPerSection": {
            "type": "integer",
            "minimum": 1,
            "maximum": 64,
            "default": 8,
            "description": "Default bars per section"
          }
        }
      },
      "GameActionRequest": {
        "description": "Request to perform a game action such as movement or combat",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "sessionId",
          "accountId",
          "gameType",
          "actionType"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID of the client. Provided by shortcut system."
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player. Provided by shortcut system."
          },
          "gameType": {
            "type": "string",
            "description": "Game type for the action. Determines which lobby to apply the action. Provided by shortcut system."
          },
          "actionType": {
            "type": "string",
            "enum": [
              "move",
              "interact",
              "attack",
              "cast_spell",
              "use_item"
            ],
            "description": "Type of game action to perform"
          },
          "actionData": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Action-specific data"
          },
          "targetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Target of the action (if applicable)"
          }
        }
      },
      "GameActionResponse": {
        "description": "Response indicating the result of a game action with any state changes",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "actionId"
        ],
        "properties": {
          "actionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this action instance"
          },
          "result": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Action result data"
          },
          "newGameState": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Updated game state (if applicable)"
          }
        }
      },
      "GamePlayer": {
        "description": "Information about a player currently participating in a game session",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "accountId",
          "sessionId",
          "joinedAt",
          "role"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the player's account"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID that joined the game. Chat and events are delivered to this specific session only."
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Display name shown to other players"
          },
          "role": {
            "type": "string",
            "enum": [
              "player",
              "spectator",
              "moderator"
            ],
            "description": "Role of the player in the game session"
          },
          "joinedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the player joined the session"
          },
          "characterData": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Game-specific character data for this player (null if none provided)"
          },
          "voiceSessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Voice participant session ID (if player has joined voice)"
          }
        }
      },
      "GameSessionResponse": {
        "description": "Complete details of a game session including players and settings",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "sessionId",
          "gameType",
          "status",
          "createdAt",
          "sessionType"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the game session"
          },
          "gameType": {
            "type": "string",
            "enum": [
              "arcadia",
              "generic"
            ],
            "description": "Type of game for this session"
          },
          "sessionType": {
            "$ref": "#/components/schemas/SessionType",
            "description": "Type of session - lobby or matchmade"
          },
          "sessionName": {
            "type": "string",
            "nullable": true,
            "description": "Display name for the session"
          },
          "status": {
            "type": "string",
            "enum": [
              "waiting",
              "active",
              "full",
              "finished"
            ],
            "description": "Current status of the game session"
          },
          "maxPlayers": {
            "type": "integer",
            "description": "Maximum number of players allowed in the session"
          },
          "currentPlayers": {
            "type": "integer",
            "description": "Current number of players in the session"
          },
          "isPrivate": {
            "type": "boolean",
            "description": "Whether the session requires a password to join"
          },
          "owner": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the session owner"
          },
          "players": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GamePlayer"
            },
            "description": "List of players currently in the session"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the session was created"
          },
          "gameSettings": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Game-specific configuration settings"
          },
          "reservations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ReservationInfo"
            },
            "nullable": true,
            "description": "For matchmade sessions - reservation tokens for expected players"
          },
          "reservationExpiresAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "For matchmade sessions - when reservations expire"
          }
        }
      },
      "GenerateCompositionRequest": {
        "description": "Request to generate a complete musical composition",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "styleId"
        ],
        "properties": {
          "styleId": {
            "type": "string",
            "description": "ID of the style to use for generation",
            "example": "celtic"
          },
          "durationBars": {
            "type": "integer",
            "minimum": 4,
            "maximum": 256,
            "default": 32,
            "description": "Target duration in bars"
          },
          "key": {
            "$ref": "#/components/schemas/KeySignature",
            "nullable": true,
            "description": "Key signature (random if not specified)"
          },
          "tempo": {
            "type": "integer",
            "minimum": 40,
            "maximum": 240,
            "description": "Tempo in BPM (uses style default if not specified)"
          },
          "mood": {
            "type": "string",
            "enum": [
              "bright",
              "dark",
              "neutral",
              "melancholic",
              "triumphant"
            ],
            "nullable": true,
            "description": "Mood constraint for generation"
          },
          "tuneType": {
            "type": "string",
            "nullable": true,
            "description": "Style-specific tune type (e.g., \"reel\", \"jig\" for Celtic)",
            "example": "reel"
          },
          "seed": {
            "type": "integer",
            "nullable": true,
            "description": "Random seed for reproducible generation"
          },
          "narrative": {
            "$ref": "#/components/schemas/NarrativeOptions",
            "nullable": true,
            "description": "Narrative/emotional arc options for storyteller-driven composition.\nIf omitted, narrative is inferred from mood. When provided, enables\nfine-grained control over emotional journey and tension curves.\n"
          }
        }
      },
      "GenerateCompositionResponse": {
        "description": "Response containing the generated composition",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "compositionId",
          "midiJson"
        ],
        "properties": {
          "compositionId": {
            "type": "string",
            "description": "Unique identifier for the composition"
          },
          "midiJson": {
            "$ref": "#/components/schemas/MidiJson",
            "description": "Generated MIDI-JSON output"
          },
          "metadata": {
            "$ref": "#/components/schemas/CompositionMetadata",
            "nullable": true,
            "description": "Metadata about the generation"
          },
          "generationTimeMs": {
            "type": "integer",
            "description": "Time taken to generate in milliseconds"
          },
          "narrativeUsed": {
            "type": "string",
            "nullable": true,
            "description": "ID of the narrative template used for composition"
          },
          "emotionalJourney": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EmotionalStateSnapshot"
            },
            "nullable": true,
            "description": "Emotional state at each section boundary"
          },
          "tensionCurve": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "nullable": true,
            "description": "Tension values at bar boundaries (0-1 scale)"
          }
        }
      },
      "GenerateMelodyRequest": {
        "description": "Request to generate a melody over harmony",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "harmony"
        ],
        "properties": {
          "harmony": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChordEvent"
            },
            "description": "Chord progression to generate melody over"
          },
          "styleId": {
            "type": "string",
            "nullable": true,
            "description": "Style for melodic preferences"
          },
          "range": {
            "$ref": "#/components/schemas/PitchRange",
            "nullable": true,
            "description": "Pitch range for the melody"
          },
          "contour": {
            "type": "string",
            "enum": [
              "arch",
              "wave",
              "ascending",
              "descending",
              "static"
            ],
            "nullable": true,
            "description": "Overall melodic contour"
          },
          "rhythmDensity": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Note density (0=sparse, 1=dense)"
          },
          "syncopation": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Amount of syncopation"
          },
          "seed": {
            "type": "integer",
            "nullable": true,
            "description": "Random seed for reproducibility"
          }
        }
      },
      "GenerateMelodyResponse": {
        "description": "Response containing a generated melody",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "notes"
        ],
        "properties": {
          "notes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NoteEvent"
            },
            "description": "Generated note events"
          },
          "analysis": {
            "$ref": "#/components/schemas/MelodyAnalysis",
            "nullable": true,
            "description": "Analysis of the melody"
          }
        }
      },
      "GenerateProgressionRequest": {
        "description": "Request to generate a chord progression",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "key",
          "length"
        ],
        "properties": {
          "key": {
            "$ref": "#/components/schemas/KeySignature",
            "description": "Key for the progression"
          },
          "length": {
            "type": "integer",
            "minimum": 2,
            "maximum": 64,
            "description": "Number of chords in the progression"
          },
          "styleId": {
            "type": "string",
            "nullable": true,
            "description": "Style to use for harmonic preferences"
          },
          "startChord": {
            "type": "string",
            "nullable": true,
            "description": "Starting chord (roman numeral, e.g., \"I\")"
          },
          "endChord": {
            "type": "string",
            "nullable": true,
            "description": "Ending chord (roman numeral, e.g., \"I\")"
          },
          "cadenceType": {
            "type": "string",
            "enum": [
              "authentic",
              "half",
              "plagal",
              "deceptive"
            ],
            "nullable": true,
            "description": "Cadence type for ending"
          },
          "allowSecondaryDominants": {
            "type": "boolean",
            "default": true,
            "description": "Allow secondary dominant chords"
          },
          "allowModalInterchange": {
            "type": "boolean",
            "default": false,
            "description": "Allow borrowed chords from parallel modes"
          },
          "seed": {
            "type": "integer",
            "nullable": true,
            "description": "Random seed for reproducibility"
          }
        }
      },
      "GenerateProgressionResponse": {
        "description": "Response containing a generated chord progression",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "chords"
        ],
        "properties": {
          "chords": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChordEvent"
            },
            "description": "Generated chord events"
          },
          "analysis": {
            "$ref": "#/components/schemas/ProgressionAnalysis",
            "nullable": true,
            "description": "Analysis of the progression"
          }
        }
      },
      "GetAccountSubscriptionsRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get subscriptions for an account",
        "required": [
          "accountId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the account to get subscriptions for"
          },
          "includeInactive": {
            "type": "boolean",
            "default": false,
            "description": "If true, include cancelled subscriptions"
          },
          "includeExpired": {
            "type": "boolean",
            "default": false,
            "description": "If true, include expired subscriptions"
          }
        }
      },
      "GetAchievementProgressRequest": {
        "type": "object",
        "description": "Request to get achievement progress",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "entityId",
          "entityType"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type whose progress is requested"
          },
          "achievementId": {
            "type": "string",
            "nullable": true,
            "description": "Specific achievement ID (null for all)"
          }
        }
      },
      "GetAncestorsRequest": {
        "description": "Request to retrieve all ancestor types in the hierarchy chain from a relationship type up to the root",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "typeId"
        ],
        "properties": {
          "typeId": {
            "type": "string",
            "format": "uuid",
            "description": "The relationship type to get ancestors for"
          }
        }
      },
      "GetAssetRequest": {
        "description": "Request to retrieve asset metadata and download URL",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "assetId"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Asset identifier"
          },
          "version": {
            "type": "string",
            "default": "latest",
            "description": "Version ID or 'latest'"
          }
        }
      },
      "GetBackstoryRequest": {
        "type": "object",
        "description": "Request payload for getting a character's backstory",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to get backstory for"
          },
          "elementTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BackstoryElementType"
            },
            "nullable": true,
            "description": "Filter by element types (null for all)"
          },
          "minimumStrength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Filter by minimum strength"
          }
        }
      },
      "GetBalanceRequest": {
        "type": "object",
        "description": "Request to get a specific currency balance",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency definition ID"
          }
        }
      },
      "GetBalanceResponse": {
        "type": "object",
        "description": "Detailed balance information",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "lockedAmount",
          "effectiveAmount"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency definition ID"
          },
          "currencyCode": {
            "type": "string",
            "description": "Currency code"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Total balance"
          },
          "lockedAmount": {
            "type": "number",
            "format": "double",
            "description": "Amount in authorization holds"
          },
          "effectiveAmount": {
            "type": "number",
            "format": "double",
            "description": "Available balance (amount - lockedAmount)"
          },
          "earnCapInfo": {
            "$ref": "#/components/schemas/EarnCapInfo",
            "nullable": true,
            "description": "Earn cap status (null if no caps configured)"
          },
          "autogainInfo": {
            "$ref": "#/components/schemas/AutogainInfo",
            "nullable": true,
            "description": "Autogain status (null if autogain not enabled)"
          }
        }
      },
      "GetBreachRequest": {
        "type": "object",
        "description": "Request to get breach details",
        "additionalProperties": false,
        "required": [
          "breachId"
        ],
        "properties": {
          "breachId": {
            "type": "string",
            "format": "uuid",
            "description": "Breach ID"
          }
        }
      },
      "GetBundleRequest": {
        "description": "Request to retrieve bundle metadata and download URL",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bundleId"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Bundle identifier to retrieve"
          },
          "format": {
            "$ref": "#/components/schemas/BundleFormat",
            "description": "Desired download format (bannou or zip)"
          }
        }
      },
      "GetCachedBehaviorRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get a cached compiled behavior",
        "required": [
          "behaviorId"
        ],
        "properties": {
          "behaviorId": {
            "type": "string",
            "description": "Unique identifier for the cached behavior"
          }
        }
      },
      "GetCharacterArchiveRequest": {
        "description": "Request to retrieve a character's compressed archive",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to get archive for"
          }
        }
      },
      "GetCharacterRequest": {
        "description": "Request payload for retrieving a single character by ID",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to retrieve"
          }
        }
      },
      "GetCharactersByRealmRequest": {
        "description": "Request payload for retrieving all characters within a specific realm",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID to query (uses partition key for efficiency)"
          },
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by species"
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CharacterStatus"
              }
            ],
            "nullable": true,
            "description": "Optional status filter"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "GetChildRelationshipTypesRequest": {
        "description": "Request to retrieve all child relationship types for a given parent type",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "parentTypeId"
        ],
        "properties": {
          "parentTypeId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the parent relationship type"
          },
          "recursive": {
            "type": "boolean",
            "default": false,
            "description": "Include all descendants, not just direct children"
          }
        }
      },
      "GetClientCapabilitiesRequest": {
        "type": "object",
        "description": "Request to get capability manifest for a connected session (debugging endpoint)",
        "additionalProperties": false,
        "required": [
          "sessionId"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Session ID to retrieve capabilities for (must have active WebSocket connection)"
          },
          "serviceFilter": {
            "type": "string",
            "description": "Optional filter by service name prefix",
            "nullable": true
          },
          "includeMetadata": {
            "type": "boolean",
            "description": "Include additional metadata about each capability",
            "default": false
          }
        }
      },
      "GetCombatPreferencesRequest": {
        "type": "object",
        "description": "Request payload for retrieving combat preferences",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to get combat preferences for"
          }
        }
      },
      "GetConsentStatusRequest": {
        "type": "object",
        "description": "Request to get consent status for all parties",
        "required": [
          "escrowId"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          }
        }
      },
      "GetConsentStatusResponse": {
        "type": "object",
        "description": "Response containing consent status for all parties",
        "required": [
          "partiesRequiringConsent",
          "consentsReceived",
          "consentsRequired",
          "canRelease",
          "canRefund"
        ],
        "properties": {
          "partiesRequiringConsent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartyConsentStatus"
            },
            "description": "Consent status per party"
          },
          "consentsReceived": {
            "type": "integer",
            "description": "Number of consents received"
          },
          "consentsRequired": {
            "type": "integer",
            "description": "Number of consents required"
          },
          "canRelease": {
            "type": "boolean",
            "description": "Whether release can proceed"
          },
          "canRefund": {
            "type": "boolean",
            "description": "Whether refund can proceed"
          }
        }
      },
      "GetContainerRequest": {
        "type": "object",
        "description": "Request to get a container",
        "additionalProperties": false,
        "required": [
          "containerId"
        ],
        "properties": {
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container ID to retrieve"
          },
          "includeContents": {
            "type": "boolean",
            "default": true,
            "description": "Whether to include item contents"
          }
        }
      },
      "GetContractInstanceRequest": {
        "type": "object",
        "description": "Request to get a contract instance",
        "additionalProperties": false,
        "required": [
          "contractId"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          }
        }
      },
      "GetContractInstanceStatusRequest": {
        "type": "object",
        "description": "Request to get contract status",
        "additionalProperties": false,
        "required": [
          "contractId"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          }
        }
      },
      "GetContractMetadataRequest": {
        "type": "object",
        "description": "Request to get contract metadata",
        "additionalProperties": false,
        "required": [
          "contractId"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          }
        }
      },
      "GetContractTemplateRequest": {
        "type": "object",
        "description": "Request to get a contract template",
        "additionalProperties": false,
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Template ID (provide this or code)"
          },
          "code": {
            "type": "string",
            "nullable": true,
            "description": "Template code (provide this or templateId)"
          }
        }
      },
      "GetCurrencyDefinitionRequest": {
        "type": "object",
        "description": "Request to get a currency definition",
        "additionalProperties": false,
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Definition ID (provide this or code)"
          },
          "code": {
            "type": "string",
            "nullable": true,
            "description": "Currency code (provide this or definitionId)"
          }
        }
      },
      "GetDefinitionRequest": {
        "type": "object",
        "description": "Request to get a map definition",
        "required": [
          "definitionId"
        ],
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Definition ID to retrieve"
          }
        }
      },
      "GetDepositStatusRequest": {
        "type": "object",
        "description": "Request to get deposit status for a party",
        "required": [
          "escrowId",
          "partyId",
          "partyType"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party ID"
          },
          "partyType": {
            "type": "string",
            "description": "Party type"
          }
        }
      },
      "GetDepositStatusResponse": {
        "type": "object",
        "description": "Response containing party deposit status",
        "required": [
          "expectedAssets",
          "depositedAssets",
          "fulfilled"
        ],
        "properties": {
          "expectedAssets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAsset"
            },
            "description": "Expected assets from this party"
          },
          "depositedAssets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAsset"
            },
            "description": "Actually deposited assets"
          },
          "fulfilled": {
            "type": "boolean",
            "description": "Whether deposit requirement is fulfilled"
          },
          "depositToken": {
            "type": "string",
            "nullable": true,
            "description": "Deposit token (if not yet used)"
          },
          "depositDeadline": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Deposit deadline"
          }
        }
      },
      "GetDocumentRequest": {
        "description": "Request to retrieve a specific document by ID or slug",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace containing the document"
          },
          "documentId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Unique identifier of the document to retrieve (null if using slug)"
          },
          "slug": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "nullable": true,
            "description": "URL-friendly slug of the document to retrieve (null if using documentId)"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional session ID for tracking document views (null if not tracking)"
          },
          "includeRelated": {
            "$ref": "#/components/schemas/RelatedDepth",
            "nullable": true,
            "description": "How deep to fetch related documents (null for no related documents)"
          },
          "includeContent": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include full document content"
          },
          "renderHtml": {
            "type": "boolean",
            "default": false,
            "description": "Whether to render markdown content as HTML"
          }
        }
      },
      "GetDocumentResponse": {
        "description": "Response containing the requested document and optional related documents",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "document"
        ],
        "properties": {
          "document": {
            "$ref": "#/components/schemas/Document",
            "description": "The requested document"
          },
          "relatedDocuments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentSummary"
            },
            "description": "List of related documents based on includeRelated depth"
          },
          "contentFormat": {
            "type": "string",
            "enum": [
              "markdown",
              "html",
              "none"
            ],
            "description": "Format of the content field in the response"
          }
        }
      },
      "GetEncounterTypeRequest": {
        "type": "object",
        "description": "Request to retrieve an encounter type by code",
        "additionalProperties": false,
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Unique code of the encounter type"
          }
        }
      },
      "GetEnrichedCharacterRequest": {
        "description": "Request payload for retrieving a character with optional related data.\nEach include flag fetches data from its respective service (zero overhead if not requested).\n",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to retrieve"
          },
          "includePersonality": {
            "type": "boolean",
            "default": false,
            "description": "Include personality traits from character-personality service"
          },
          "includeBackstory": {
            "type": "boolean",
            "default": false,
            "description": "Include backstory elements from character-history service"
          },
          "includeFamilyTree": {
            "type": "boolean",
            "default": false,
            "description": "Include family relationships from relationship service"
          },
          "includeCombatPreferences": {
            "type": "boolean",
            "default": false,
            "description": "Include combat preferences from character-personality service"
          }
        }
      },
      "GetEntityRankRequest": {
        "type": "object",
        "description": "Request to get an entity's rank",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId",
          "entityId",
          "entityType"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type whose rank is requested"
          }
        }
      },
      "GetEscrowRequest": {
        "type": "object",
        "description": "Request to retrieve an escrow agreement by ID",
        "required": [
          "escrowId"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID to retrieve"
          }
        }
      },
      "GetEscrowResponse": {
        "type": "object",
        "description": "Response containing escrow agreement details",
        "required": [
          "escrow"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Escrow agreement details"
          }
        }
      },
      "GetEventParticipantsRequest": {
        "type": "object",
        "description": "Request payload for getting participants of an event",
        "additionalProperties": false,
        "required": [
          "eventId"
        ],
        "properties": {
          "eventId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the historical event"
          },
          "role": {
            "$ref": "#/components/schemas/ParticipationRole",
            "nullable": true,
            "description": "Filter by participation role"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "GetExchangeRateRequest": {
        "type": "object",
        "description": "Request to get exchange rate between currencies",
        "additionalProperties": false,
        "required": [
          "fromCurrencyId",
          "toCurrencyId"
        ],
        "properties": {
          "fromCurrencyId": {
            "type": "string",
            "format": "uuid",
            "description": "Source currency ID"
          },
          "toCurrencyId": {
            "type": "string",
            "format": "uuid",
            "description": "Target currency ID"
          }
        }
      },
      "GetExchangeRateResponse": {
        "type": "object",
        "description": "Exchange rate information",
        "additionalProperties": false,
        "required": [
          "rate",
          "inverseRate",
          "baseCurrency",
          "fromCurrencyRateToBase",
          "toCurrencyRateToBase"
        ],
        "properties": {
          "rate": {
            "type": "number",
            "format": "double",
            "description": "Conversion rate (from -> to)"
          },
          "inverseRate": {
            "type": "number",
            "format": "double",
            "description": "Inverse rate (to -> from)"
          },
          "baseCurrency": {
            "type": "string",
            "description": "Base currency code"
          },
          "fromCurrencyRateToBase": {
            "type": "number",
            "format": "double",
            "description": "Source currency rate to base"
          },
          "toCurrencyRateToBase": {
            "type": "number",
            "format": "double",
            "description": "Target currency rate to base"
          }
        }
      },
      "GetGameSessionRequest": {
        "type": "object",
        "description": "Request to get a specific game session",
        "additionalProperties": false,
        "required": [
          "sessionId"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game session to retrieve"
          }
        }
      },
      "GetGlobalSupplyRequest": {
        "type": "object",
        "description": "Request to get global supply stats",
        "additionalProperties": false,
        "required": [
          "currencyDefinitionId"
        ],
        "properties": {
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to query"
          }
        }
      },
      "GetGlobalSupplyResponse": {
        "type": "object",
        "description": "Global supply statistics",
        "additionalProperties": false,
        "required": [
          "totalSupply",
          "inCirculation",
          "inEscrow",
          "totalMinted",
          "totalBurned"
        ],
        "properties": {
          "totalSupply": {
            "type": "number",
            "format": "double",
            "description": "Sum of all positive balances"
          },
          "inCirculation": {
            "type": "number",
            "format": "double",
            "description": "Total in wallets"
          },
          "inEscrow": {
            "type": "number",
            "format": "double",
            "description": "Locked in escrow"
          },
          "totalMinted": {
            "type": "number",
            "format": "double",
            "description": "All-time faucet total"
          },
          "totalBurned": {
            "type": "number",
            "format": "double",
            "description": "All-time sink total"
          },
          "supplyCap": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Global supply cap (null if none)"
          },
          "supplyCapRemaining": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Remaining supply before cap"
          }
        }
      },
      "GetHoldRequest": {
        "type": "object",
        "description": "Request to get hold details",
        "additionalProperties": false,
        "required": [
          "holdId"
        ],
        "properties": {
          "holdId": {
            "type": "string",
            "format": "uuid",
            "description": "Hold ID"
          }
        }
      },
      "GetItemInstanceRequest": {
        "type": "object",
        "description": "Request to get an item instance",
        "additionalProperties": false,
        "required": [
          "instanceId"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Instance ID to retrieve"
          }
        }
      },
      "GetItemTemplateRequest": {
        "type": "object",
        "description": "Request to get an item template",
        "additionalProperties": false,
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Template ID (provide this or code+gameId)"
          },
          "code": {
            "type": "string",
            "nullable": true,
            "description": "Item code (provide with gameId)"
          },
          "gameId": {
            "type": "string",
            "nullable": true,
            "description": "Game service ID (provide with code)"
          }
        }
      },
      "GetJobStatusRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get the status of an async metabundle creation job",
        "required": [
          "jobId"
        ],
        "properties": {
          "jobId": {
            "type": "string",
            "format": "uuid",
            "description": "Job ID from the createMetabundle response"
          }
        }
      },
      "GetJobStatusResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Status of an async metabundle creation job.\nWhen status is 'ready', the response includes the full metabundle details.\n",
        "required": [
          "jobId",
          "metabundleId",
          "status"
        ],
        "properties": {
          "jobId": {
            "type": "string",
            "format": "uuid",
            "description": "Job identifier"
          },
          "metabundleId": {
            "type": "string",
            "description": "Metabundle identifier being created"
          },
          "status": {
            "type": "string",
            "enum": [
              "queued",
              "processing",
              "ready",
              "failed",
              "cancelled"
            ],
            "description": "Current job status.\n- queued: Waiting for processing resources\n- processing: Actively being processed\n- ready: Completed successfully\n- failed: Creation failed\n- cancelled: Job was cancelled\n"
          },
          "progress": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100,
            "nullable": true,
            "description": "Progress percentage (0-100) when status is 'processing'"
          },
          "downloadUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "Pre-signed download URL (only when status is 'ready')"
          },
          "assetCount": {
            "type": "integer",
            "nullable": true,
            "description": "Number of assets in metabundle (when ready)"
          },
          "standaloneAssetCount": {
            "type": "integer",
            "nullable": true,
            "description": "Number of standalone assets included (when ready)"
          },
          "sizeBytes": {
            "type": "integer",
            "format": "int64",
            "nullable": true,
            "description": "Total size in bytes (when ready)"
          },
          "sourceBundles": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/SourceBundleReference"
            },
            "description": "Provenance data (when ready)"
          },
          "errorCode": {
            "type": "string",
            "nullable": true,
            "description": "Error code (when status is 'failed')"
          },
          "errorMessage": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable error description (when status is 'failed')"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the job was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the job was last updated"
          },
          "processingTimeMs": {
            "type": "integer",
            "format": "int64",
            "nullable": true,
            "description": "Total processing time in milliseconds (when complete)"
          }
        }
      },
      "GetLocationAncestorsRequest": {
        "description": "Request to retrieve the full ancestry chain of a location up to the root",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "locationId"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "The location to get ancestors for"
          }
        }
      },
      "GetLocationByCodeRequest": {
        "description": "Request to retrieve a location by its code within a specific realm",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "code",
          "realmId"
        ],
        "properties": {
          "code": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "pattern": "^[A-Z][A-Z0-9_]*$",
            "description": "Unique code for the location within the realm"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID to scope the code lookup"
          }
        }
      },
      "GetLocationDescendantsRequest": {
        "description": "Request to retrieve all descendants of a location (children, grandchildren, etc.)",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "locationId"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "The location to get descendants for"
          },
          "locationType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LocationType"
              }
            ],
            "nullable": true,
            "description": "Optional filter by location type"
          },
          "maxDepth": {
            "type": "integer",
            "minimum": 1,
            "maximum": 10,
            "nullable": true,
            "description": "Maximum depth of descendants to return (null = all)"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated locations in the response"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "GetLocationRequest": {
        "description": "Request to retrieve a location by its unique identifier",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "locationId"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the location"
          }
        }
      },
      "GetMatchmakingStatsRequest": {
        "type": "object",
        "description": "Request to get matchmaking statistics",
        "additionalProperties": false,
        "properties": {
          "queueId": {
            "type": "string",
            "nullable": true,
            "description": "Filter by specific queue (null for all queues)"
          },
          "gameId": {
            "type": "string",
            "nullable": true,
            "description": "Filter by game ID"
          }
        }
      },
      "GetMatchmakingStatusRequest": {
        "type": "object",
        "description": "Request to get matchmaking status",
        "additionalProperties": false,
        "required": [
          "webSocketSessionId",
          "accountId",
          "ticketId"
        ],
        "properties": {
          "webSocketSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player"
          },
          "ticketId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the ticket to query"
          }
        }
      },
      "GetMilestoneRequest": {
        "type": "object",
        "description": "Request to get milestone details",
        "additionalProperties": false,
        "required": [
          "contractId",
          "milestoneCode"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "milestoneCode": {
            "type": "string",
            "description": "Milestone code"
          }
        }
      },
      "GetOrCreateContainerRequest": {
        "type": "object",
        "description": "Request to get or create a container",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "containerType",
          "constraintModel"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner entity ID"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Owner type"
          },
          "containerType": {
            "type": "string",
            "description": "Container type to find or create"
          },
          "constraintModel": {
            "$ref": "#/components/schemas/ContainerConstraintModel",
            "description": "Constraint model for new container"
          },
          "maxSlots": {
            "type": "integer",
            "nullable": true,
            "description": "Default max slots if creating"
          },
          "maxWeight": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Default max weight if creating"
          },
          "gridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "Default grid width if creating"
          },
          "gridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "Default grid height if creating"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm for new container"
          }
        }
      },
      "GetOrCreateWalletRequest": {
        "type": "object",
        "description": "Request to get or create a wallet",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner entity ID"
          },
          "ownerType": {
            "$ref": "#/components/schemas/WalletOwnerType",
            "description": "Type of owner entity"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm ID for realm-scoped wallets"
          }
        }
      },
      "GetOrCreateWalletResponse": {
        "type": "object",
        "description": "Result of get-or-create operation",
        "additionalProperties": false,
        "required": [
          "wallet",
          "balances",
          "created"
        ],
        "properties": {
          "wallet": {
            "$ref": "#/components/schemas/WalletResponse",
            "description": "Wallet details"
          },
          "balances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BalanceSummary"
            },
            "description": "All non-zero balances"
          },
          "created": {
            "type": "boolean",
            "description": "Whether a new wallet was created"
          }
        }
      },
      "GetParticipationRequest": {
        "type": "object",
        "description": "Request payload for getting a character's event participation",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to get participation for"
          },
          "eventCategory": {
            "$ref": "#/components/schemas/EventCategory",
            "nullable": true,
            "description": "Filter by event category"
          },
          "minimumSignificance": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Filter by minimum significance"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "GetPersonalityRequest": {
        "type": "object",
        "description": "Request payload for retrieving a character's personality",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to get personality for"
          }
        }
      },
      "GetPerspectiveRequest": {
        "type": "object",
        "description": "Request to get a character's perspective on an encounter",
        "additionalProperties": false,
        "required": [
          "encounterId",
          "characterId"
        ],
        "properties": {
          "encounterId": {
            "type": "string",
            "format": "uuid",
            "description": "Encounter to get perspective for"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character whose perspective to retrieve"
          }
        }
      },
      "GetQueueRequest": {
        "type": "object",
        "description": "Request to get details of a specific queue",
        "additionalProperties": false,
        "required": [
          "queueId"
        ],
        "properties": {
          "queueId": {
            "type": "string",
            "description": "ID of the queue to retrieve"
          }
        }
      },
      "GetRanksAroundRequest": {
        "type": "object",
        "description": "Request to get entries around an entity",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId",
          "entityId",
          "entityType"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity to center on"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type of the anchor entry"
          },
          "countBefore": {
            "type": "integer",
            "default": 5,
            "maximum": 50,
            "description": "Entries to show before the entity"
          },
          "countAfter": {
            "type": "integer",
            "default": 5,
            "maximum": 50,
            "description": "Entries to show after the entity"
          }
        }
      },
      "GetRealmByCodeRequest": {
        "description": "Request to retrieve a realm by its unique code identifier",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "minLength": 1,
            "maxLength": 50,
            "pattern": "^[A-Z][A-Z0-9_]*$",
            "description": "Unique code for the realm (e.g., \"OMEGA\", \"ARCADIA\", \"FANTASIA\")"
          }
        }
      },
      "GetRealmEventParticipantsRequest": {
        "type": "object",
        "description": "Request payload for getting participants of an event",
        "additionalProperties": false,
        "required": [
          "eventId"
        ],
        "properties": {
          "eventId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the historical event"
          },
          "role": {
            "$ref": "#/components/schemas/RealmEventRole",
            "nullable": true,
            "description": "Filter by participation role"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "GetRealmLoreRequest": {
        "type": "object",
        "description": "Request payload for getting a realm's lore",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the realm to get lore for"
          },
          "elementTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RealmLoreElementType"
            },
            "nullable": true,
            "description": "Filter by element types (null for all)"
          },
          "minimumStrength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Filter by minimum strength"
          }
        }
      },
      "GetRealmParticipationRequest": {
        "type": "object",
        "description": "Request payload for getting a realm's event participation",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the realm to get participation for"
          },
          "eventCategory": {
            "$ref": "#/components/schemas/RealmEventCategory",
            "nullable": true,
            "description": "Filter by event category"
          },
          "minimumImpact": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Filter by minimum impact"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "GetRealmRequest": {
        "description": "Request to retrieve a specific realm by its unique identifier",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the realm"
          }
        }
      },
      "GetRelationshipRequest": {
        "description": "Request to retrieve a specific relationship by its ID",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "relationshipId"
        ],
        "properties": {
          "relationshipId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the relationship to retrieve"
          }
        }
      },
      "GetRelationshipTypeByCodeRequest": {
        "description": "Request to retrieve a relationship type by its unique code string",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "minLength": 1,
            "maxLength": 50,
            "pattern": "^[A-Z][A-Z0-9_]*$",
            "description": "Unique code for the relationship type (e.g., \"SON\", \"MOTHER\", \"FRIEND\")"
          }
        }
      },
      "GetRelationshipTypeRequest": {
        "description": "Request to retrieve a relationship type by its unique identifier",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "relationshipTypeId"
        ],
        "properties": {
          "relationshipTypeId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the relationship type"
          }
        }
      },
      "GetRelationshipsBetweenRequest": {
        "description": "Request to get all relationships between two specific entities",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "entity1Id",
          "entity1Type",
          "entity2Id",
          "entity2Type"
        ],
        "properties": {
          "entity1Id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the first entity to check relationships for"
          },
          "entity1Type": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the first entity"
          },
          "entity2Id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the second entity to check relationships for"
          },
          "entity2Type": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the second entity"
          },
          "relationshipTypeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional filter by relationship type"
          },
          "includeEnded": {
            "type": "boolean",
            "default": false,
            "description": "Include relationships that have ended"
          }
        }
      },
      "GetSceneRequest": {
        "type": "object",
        "description": "Request to retrieve a scene",
        "required": [
          "sceneId"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the scene to retrieve"
          },
          "version": {
            "type": "string",
            "nullable": true,
            "description": "Specific version to retrieve (null = latest)"
          },
          "resolveReferences": {
            "type": "boolean",
            "default": false,
            "description": "Whether to resolve and embed referenced scenes"
          },
          "maxReferenceDepth": {
            "type": "integer",
            "default": 3,
            "minimum": 1,
            "maximum": 10,
            "description": "Maximum depth for reference resolution (prevents infinite recursion)"
          }
        }
      },
      "GetSceneResponse": {
        "type": "object",
        "description": "Response containing a scene and resolution metadata",
        "required": [
          "scene"
        ],
        "properties": {
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "The retrieved scene"
          },
          "resolvedReferences": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResolvedReference"
            },
            "nullable": true,
            "description": "List of resolved references (if resolveReferences was true)"
          },
          "unresolvedReferences": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UnresolvedReference"
            },
            "nullable": true,
            "description": "References that could not be resolved (circular, missing, depth exceeded)"
          },
          "resolutionErrors": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Error messages for reference resolution issues"
          }
        }
      },
      "GetSeasonRequest": {
        "type": "object",
        "description": "Request to get season information",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard"
          },
          "seasonNumber": {
            "type": "integer",
            "nullable": true,
            "description": "Specific season number (null for current)"
          }
        }
      },
      "GetSentimentRequest": {
        "type": "object",
        "description": "Request to get aggregate sentiment toward another character",
        "additionalProperties": false,
        "required": [
          "characterId",
          "targetCharacterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character whose sentiment to query"
          },
          "targetCharacterId": {
            "type": "string",
            "format": "uuid",
            "description": "Target character to measure sentiment toward"
          }
        }
      },
      "GetServiceRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get a service by ID or stub name (provide either one)",
        "properties": {
          "serviceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of the service to retrieve (null if using stubName)"
          },
          "stubName": {
            "type": "string",
            "nullable": true,
            "description": "Stub name of the service to retrieve (null if using serviceId)"
          }
        }
      },
      "GetSlotRequest": {
        "type": "object",
        "description": "Request to retrieve metadata for a specific save slot",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "minLength": 1,
            "maxLength": 32,
            "pattern": "^[a-z][a-z0-9-]*$",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          }
        }
      },
      "GetSpeciesByCodeRequest": {
        "description": "Request to retrieve a species by its unique code identifier",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "minLength": 1,
            "maxLength": 50,
            "pattern": "^[A-Z][A-Z0-9_]*$",
            "description": "Unique code for the species (e.g., \"HUMAN\", \"ELF\", \"DWARF\")"
          }
        }
      },
      "GetSpeciesRequest": {
        "description": "Request to retrieve a single species by its unique identifier",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "speciesId"
        ],
        "properties": {
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the species"
          }
        }
      },
      "GetStyleRequest": {
        "description": "Request to get a style definition",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "styleId": {
            "type": "string",
            "nullable": true,
            "description": "Style ID to retrieve"
          },
          "styleName": {
            "type": "string",
            "nullable": true,
            "description": "Style name to retrieve (alternative to ID)"
          }
        }
      },
      "GetSubscriptionRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get a specific subscription",
        "required": [
          "subscriptionId"
        ],
        "properties": {
          "subscriptionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the subscription to retrieve"
          }
        }
      },
      "GetTopRanksRequest": {
        "type": "object",
        "description": "Request to get top leaderboard entries",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard"
          },
          "count": {
            "type": "integer",
            "default": 100,
            "maximum": 1000,
            "description": "Number of entries to return"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Number of entries to skip"
          }
        }
      },
      "GetTransactionHistoryRequest": {
        "type": "object",
        "description": "Request to get transaction history",
        "additionalProperties": false,
        "required": [
          "walletId"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet to query"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by currency"
          },
          "transactionTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransactionType"
            },
            "nullable": true,
            "description": "Filter by transaction types"
          },
          "fromDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Start of date range"
          },
          "toDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "End of date range"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 50,
            "description": "Results per page"
          },
          "offset": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Result offset"
          }
        }
      },
      "GetTransactionHistoryResponse": {
        "type": "object",
        "description": "Paginated transaction history",
        "additionalProperties": false,
        "required": [
          "transactions",
          "totalCount"
        ],
        "properties": {
          "transactions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CurrencyTransactionRecord"
            },
            "description": "Transaction records"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total matching transactions"
          }
        }
      },
      "GetTransactionRequest": {
        "type": "object",
        "description": "Request to get a transaction by ID",
        "additionalProperties": false,
        "required": [
          "transactionId"
        ],
        "properties": {
          "transactionId": {
            "type": "string",
            "format": "uuid",
            "description": "Transaction ID"
          }
        }
      },
      "GetTransactionsByReferenceRequest": {
        "type": "object",
        "description": "Request to get transactions by reference",
        "additionalProperties": false,
        "required": [
          "referenceType",
          "referenceId"
        ],
        "properties": {
          "referenceType": {
            "type": "string",
            "description": "Reference type"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "description": "Reference ID"
          }
        }
      },
      "GetTransactionsByReferenceResponse": {
        "type": "object",
        "description": "Transactions for a reference",
        "additionalProperties": false,
        "required": [
          "transactions"
        ],
        "properties": {
          "transactions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CurrencyTransactionRecord"
            },
            "description": "Matching transactions"
          }
        }
      },
      "GetValidationRulesRequest": {
        "type": "object",
        "description": "Request to get validation rules",
        "required": [
          "gameId",
          "sceneType"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game ID"
          },
          "sceneType": {
            "$ref": "#/components/schemas/SceneType",
            "description": "Scene type"
          }
        }
      },
      "GetValidationRulesResponse": {
        "type": "object",
        "description": "Response containing validation rules",
        "required": [
          "gameId",
          "sceneType"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game ID"
          },
          "sceneType": {
            "$ref": "#/components/schemas/SceneType",
            "description": "Scene type"
          },
          "rules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationRule"
            },
            "description": "Registered rules (empty if none)"
          }
        }
      },
      "GetWalletRequest": {
        "type": "object",
        "description": "Request to get a wallet",
        "additionalProperties": false,
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Wallet ID (provide this or ownerId+ownerType)"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Owner ID (requires ownerType)"
          },
          "ownerType": {
            "$ref": "#/components/schemas/WalletOwnerType",
            "nullable": true,
            "description": "Owner type (requires ownerId)"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm ID (required if using ownerId lookup)"
          }
        }
      },
      "GoapGoal": {
        "description": "Goal definition for GOAP planning with conditions and priority",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "name",
          "conditions",
          "priority"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the goal",
            "example": "satisfy_hunger"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description of the goal"
          },
          "conditions": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "World state conditions that satisfy this goal (literal conditions)",
            "example": {
              "hunger": "<= 0.3",
              "gold": ">= 50"
            }
          },
          "priority": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "description": "Priority of this goal relative to others"
          },
          "preconditions": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "World state conditions required to pursue this goal"
          }
        }
      },
      "GoapPlanRequest": {
        "description": "Request to generate a GOAP plan to achieve a goal from current world state",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "goal",
          "worldState",
          "behaviorId"
        ],
        "properties": {
          "agentId": {
            "type": "string",
            "nullable": true,
            "description": "Unique identifier for the agent requesting the plan"
          },
          "goal": {
            "$ref": "#/components/schemas/GoapGoal",
            "description": "The goal to achieve through planning"
          },
          "worldState": {
            "type": "object",
            "additionalProperties": true,
            "description": "Current world state as key-value pairs",
            "example": {
              "hunger": 0.8,
              "gold": 50,
              "location": "home"
            }
          },
          "behaviorId": {
            "type": "string",
            "description": "ID of compiled behavior containing GOAP actions"
          },
          "options": {
            "$ref": "#/components/schemas/GoapPlanningOptions",
            "nullable": true,
            "description": "Options controlling the planning process"
          }
        }
      },
      "GoapPlanResponse": {
        "description": "Response containing the generated GOAP plan. If no plan could be found, plan is null and failureReason explains why.",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "plan": {
            "$ref": "#/components/schemas/GoapPlanResult",
            "nullable": true,
            "description": "The generated plan if successful"
          },
          "planningTimeMs": {
            "type": "integer",
            "description": "Time spent planning in milliseconds"
          },
          "nodesExpanded": {
            "type": "integer",
            "description": "Number of nodes expanded during A* search"
          },
          "failureReason": {
            "type": "string",
            "nullable": true,
            "description": "Reason for planning failure if unsuccessful",
            "example": "No plan found - goal unreachable"
          }
        }
      },
      "GoapPlanResult": {
        "description": "Result of GOAP planning containing the ordered sequence of actions to achieve a goal",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "goalId",
          "actions",
          "totalCost"
        ],
        "properties": {
          "goalId": {
            "type": "string",
            "description": "ID of the goal this plan achieves"
          },
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PlannedActionResponse"
            },
            "description": "Ordered sequence of actions to execute"
          },
          "totalCost": {
            "type": "number",
            "format": "float",
            "description": "Total cost of all actions in the plan"
          }
        }
      },
      "GoapPlanningOptions": {
        "description": "Options controlling the GOAP planning process including depth and timeout limits",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "maxDepth": {
            "type": "integer",
            "default": 10,
            "description": "Maximum plan depth (number of actions)"
          },
          "maxNodes": {
            "type": "integer",
            "default": 1000,
            "description": "Maximum nodes to expand during search"
          },
          "timeoutMs": {
            "type": "integer",
            "default": 100,
            "description": "Planning timeout in milliseconds"
          }
        }
      },
      "GroupRole": {
        "type": "string",
        "description": "Preferred role when fighting in groups. Affects positioning,\ntarget priority, and coordination behavior.\n",
        "enum": [
          "FRONTLINE",
          "SUPPORT",
          "FLANKER",
          "LEADER",
          "SOLO"
        ]
      },
      "HarmonyStyle": {
        "description": "Harmonic progression style preferences",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "primaryCadence": {
            "type": "string",
            "enum": [
              "authentic",
              "plagal",
              "half",
              "deceptive"
            ],
            "default": "authentic",
            "description": "Most common cadence type"
          },
          "dominantPrepProbability": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.6,
            "description": "Probability of pre-dominant before dominant"
          },
          "secondaryDominantProbability": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.3,
            "description": "Probability of secondary dominants"
          },
          "modalInterchangeProbability": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.1,
            "description": "Probability of borrowed chords"
          },
          "commonProgressions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Common chord progressions as roman numeral strings"
          }
        }
      },
      "HasItemResult": {
        "type": "object",
        "description": "Individual item check result",
        "additionalProperties": false,
        "required": [
          "templateId",
          "required",
          "available",
          "satisfied"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template checked"
          },
          "required": {
            "type": "number",
            "format": "double",
            "description": "Required quantity"
          },
          "available": {
            "type": "number",
            "format": "double",
            "description": "Available quantity"
          },
          "satisfied": {
            "type": "boolean",
            "description": "Whether requirement met"
          }
        }
      },
      "HasItemsRequest": {
        "type": "object",
        "description": "Request to check for items",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "requirements"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner to check"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Owner type"
          },
          "requirements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ItemRequirement"
            },
            "description": "Required items"
          }
        }
      },
      "HasItemsResponse": {
        "type": "object",
        "description": "Has items result",
        "additionalProperties": false,
        "required": [
          "hasAll",
          "results"
        ],
        "properties": {
          "hasAll": {
            "type": "boolean",
            "description": "Whether all requirements met"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HasItemResult"
            },
            "description": "Per-item results"
          }
        }
      },
      "HasMetRequest": {
        "type": "object",
        "description": "Request to check if two characters have met",
        "additionalProperties": false,
        "required": [
          "characterIdA",
          "characterIdB"
        ],
        "properties": {
          "characterIdA": {
            "type": "string",
            "format": "uuid",
            "description": "First character"
          },
          "characterIdB": {
            "type": "string",
            "format": "uuid",
            "description": "Second character"
          }
        }
      },
      "HasMetResponse": {
        "type": "object",
        "description": "Response for has-met check",
        "additionalProperties": false,
        "required": [
          "hasMet",
          "encounterCount"
        ],
        "properties": {
          "hasMet": {
            "type": "boolean",
            "description": "Whether the characters have any recorded encounters"
          },
          "encounterCount": {
            "type": "integer",
            "description": "Total number of encounters between them"
          }
        }
      },
      "HazardInfo": {
        "type": "object",
        "additionalProperties": true,
        "description": "Information about a hazard in range",
        "properties": {
          "hazardType": {
            "type": "string",
            "description": "Type of hazard (fire, poison, radiation, deep_water, etc.)"
          },
          "distance": {
            "type": "number",
            "format": "float",
            "description": "Distance to hazard edge"
          },
          "severity": {
            "type": "number",
            "format": "float",
            "minimum": 0,
            "maximum": 1,
            "description": "Hazard severity (0-1)"
          },
          "direction": {
            "type": "string",
            "nullable": true,
            "description": "Direction to hazard center"
          }
        }
      },
      "HeartbeatRequest": {
        "type": "object",
        "description": "Request to extend checkout lock",
        "required": [
          "sceneId",
          "checkoutToken"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene being edited"
          },
          "checkoutToken": {
            "type": "string",
            "description": "Checkout token"
          }
        }
      },
      "HeartbeatResponse": {
        "type": "object",
        "description": "Response confirming lock extension",
        "required": [
          "extended",
          "newExpiresAt"
        ],
        "properties": {
          "extended": {
            "type": "boolean",
            "description": "Whether extension was successful"
          },
          "newExpiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "New expiration time"
          },
          "extensionsRemaining": {
            "type": "integer",
            "description": "Number of extensions remaining"
          }
        }
      },
      "HistoricalParticipation": {
        "type": "object",
        "description": "Record of a character's participation in a historical event",
        "additionalProperties": false,
        "required": [
          "participationId",
          "characterId",
          "eventId",
          "eventName",
          "eventCategory",
          "role",
          "eventDate",
          "createdAt"
        ],
        "properties": {
          "participationId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique ID for this participation record"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character who participated"
          },
          "eventId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the historical event"
          },
          "eventName": {
            "type": "string",
            "description": "Name of the event (for display and summarization)"
          },
          "eventCategory": {
            "$ref": "#/components/schemas/EventCategory",
            "description": "Category of the historical event"
          },
          "role": {
            "$ref": "#/components/schemas/ParticipationRole",
            "description": "How the character participated"
          },
          "eventDate": {
            "type": "string",
            "format": "date-time",
            "description": "In-game date when the event occurred"
          },
          "significance": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.5,
            "description": "How significant this event was for the character (0.0 to 1.0).\nAffects behavior system weighting of this memory.\n"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Event-specific details for behavior decisions"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this record was created"
          }
        }
      },
      "HistoryRequest": {
        "type": "object",
        "description": "Request for scene version history",
        "required": [
          "sceneId"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene to get history for"
          },
          "limit": {
            "type": "integer",
            "default": 10,
            "description": "Maximum versions to return"
          }
        }
      },
      "HistoryResponse": {
        "type": "object",
        "description": "Scene version history",
        "required": [
          "sceneId",
          "versions"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene ID"
          },
          "currentVersion": {
            "type": "string",
            "description": "Current active version"
          },
          "versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VersionInfo"
            },
            "description": "Version history entries"
          }
        }
      },
      "HoldRecord": {
        "type": "object",
        "description": "Authorization hold record",
        "additionalProperties": false,
        "required": [
          "holdId",
          "walletId",
          "currencyDefinitionId",
          "amount",
          "status",
          "createdAt",
          "expiresAt"
        ],
        "properties": {
          "holdId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique hold identifier"
          },
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet with held funds"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency held"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount reserved"
          },
          "status": {
            "$ref": "#/components/schemas/HoldStatus",
            "description": "Current hold status"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When hold was created"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When hold auto-releases"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "Reference type"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference ID"
          },
          "capturedAmount": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Amount actually captured (may differ from held amount)"
          },
          "completedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When hold was captured/released/expired"
          }
        }
      },
      "HoldResponse": {
        "type": "object",
        "description": "Hold details",
        "additionalProperties": false,
        "required": [
          "hold"
        ],
        "properties": {
          "hold": {
            "$ref": "#/components/schemas/HoldRecord",
            "description": "Hold record"
          }
        }
      },
      "HoldStatus": {
        "type": "string",
        "description": "Current status of an authorization hold",
        "enum": [
          "active",
          "captured",
          "released",
          "expired"
        ]
      },
      "InjectPerceptionRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to inject a perception event into an actor's queue",
        "required": [
          "actorId",
          "perception"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "Target actor to inject perception into"
          },
          "perception": {
            "description": "Perception data to inject",
            "$ref": "#/components/schemas/PerceptionData"
          }
        }
      },
      "InjectPerceptionResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response confirming perception injection",
        "required": [
          "queued",
          "queueDepth"
        ],
        "properties": {
          "queued": {
            "type": "boolean",
            "description": "Whether the perception was successfully queued"
          },
          "queueDepth": {
            "type": "integer",
            "description": "Current depth of the perception queue"
          }
        }
      },
      "IntervalPreferences": {
        "description": "Melodic interval preference weights",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "stepWeight": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.5,
            "description": "Weight for stepwise motion (M2, m2)"
          },
          "thirdWeight": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.25,
            "description": "Weight for thirds (M3, m3)"
          },
          "leapWeight": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.15,
            "description": "Weight for larger leaps (P4, P5)"
          },
          "largeLeapWeight": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.1,
            "description": "Weight for leaps larger than P5"
          }
        }
      },
      "InvalidateCacheRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to invalidate a cached behavior",
        "required": [
          "behaviorId"
        ],
        "properties": {
          "behaviorId": {
            "type": "string",
            "description": "Unique identifier for the cached behavior to invalidate"
          }
        }
      },
      "ItemCategory": {
        "type": "string",
        "description": "Item classification category",
        "enum": [
          "weapon",
          "armor",
          "accessory",
          "consumable",
          "material",
          "container",
          "quest",
          "currency_like",
          "misc",
          "custom"
        ]
      },
      "ItemInstanceResponse": {
        "type": "object",
        "description": "Item instance details",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "templateId",
          "containerId",
          "realmId",
          "quantity",
          "originType",
          "createdAt"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique instance identifier"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Reference to the item template"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container holding this item"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm this instance exists in"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "description": "Item quantity"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Slot position in slot-based containers"
          },
          "slotX": {
            "type": "integer",
            "nullable": true,
            "description": "X position in grid-based containers"
          },
          "slotY": {
            "type": "integer",
            "nullable": true,
            "description": "Y position in grid-based containers"
          },
          "rotated": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether item is rotated in grid"
          },
          "currentDurability": {
            "type": "integer",
            "nullable": true,
            "description": "Current durability"
          },
          "boundToId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Character ID this item is bound to"
          },
          "boundAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When item was bound"
          },
          "customStats": {
            "type": "object",
            "nullable": true,
            "description": "Instance-specific stat modifications"
          },
          "customName": {
            "type": "string",
            "nullable": true,
            "description": "Player-assigned custom name"
          },
          "instanceMetadata": {
            "type": "object",
            "nullable": true,
            "description": "Other instance-specific data"
          },
          "originType": {
            "$ref": "#/components/schemas/ItemOriginType",
            "description": "How this item instance was created"
          },
          "originId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Source entity ID"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Instance creation timestamp"
          },
          "modifiedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last modification timestamp"
          }
        }
      },
      "ItemLinkageMode": {
        "type": "string",
        "description": "How currency is linked to inventory items",
        "enum": [
          "none",
          "visual_only",
          "reference_only"
        ]
      },
      "ItemOriginType": {
        "type": "string",
        "description": "How an item instance was created",
        "enum": [
          "loot",
          "quest",
          "craft",
          "trade",
          "purchase",
          "spawn",
          "other"
        ]
      },
      "ItemRarity": {
        "type": "string",
        "description": "Item rarity tier",
        "enum": [
          "common",
          "uncommon",
          "rare",
          "epic",
          "legendary",
          "custom"
        ]
      },
      "ItemRequirement": {
        "type": "object",
        "description": "Required item and quantity",
        "additionalProperties": false,
        "required": [
          "templateId",
          "quantity"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Required template"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "minimum": 1,
            "description": "Required quantity"
          }
        }
      },
      "ItemScope": {
        "type": "string",
        "description": "Realm availability scope (consistent with CurrencyScope)",
        "enum": [
          "global",
          "realm_specific",
          "multi_realm"
        ]
      },
      "ItemTemplateResponse": {
        "type": "object",
        "description": "Item template details",
        "additionalProperties": false,
        "required": [
          "templateId",
          "code",
          "gameId",
          "name",
          "category",
          "quantityModel",
          "maxStackSize",
          "scope",
          "tradeable",
          "destroyable",
          "soulboundType",
          "hasDurability",
          "isActive",
          "isDeprecated",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique template identifier"
          },
          "code": {
            "type": "string",
            "description": "Unique code within the game"
          },
          "gameId": {
            "type": "string",
            "description": "Game service this template belongs to"
          },
          "name": {
            "type": "string",
            "description": "Human-readable display name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Detailed description"
          },
          "category": {
            "$ref": "#/components/schemas/ItemCategory",
            "description": "Item classification category"
          },
          "subcategory": {
            "type": "string",
            "nullable": true,
            "description": "Game-defined subcategory"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Filtering tags"
          },
          "rarity": {
            "$ref": "#/components/schemas/ItemRarity",
            "description": "Item rarity tier"
          },
          "quantityModel": {
            "$ref": "#/components/schemas/QuantityModel",
            "description": "How quantities are tracked"
          },
          "maxStackSize": {
            "type": "integer",
            "description": "Maximum stack size"
          },
          "unitOfMeasure": {
            "type": "string",
            "nullable": true,
            "description": "Unit for continuous quantities"
          },
          "weightPrecision": {
            "$ref": "#/components/schemas/WeightPrecision",
            "description": "Precision for weight values"
          },
          "weight": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Weight value"
          },
          "volume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Volume for volumetric inventories"
          },
          "gridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "Width in grid-based inventories"
          },
          "gridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "Height in grid-based inventories"
          },
          "canRotate": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether item can be rotated in grid"
          },
          "baseValue": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Reference price"
          },
          "tradeable": {
            "type": "boolean",
            "description": "Whether item can be traded"
          },
          "destroyable": {
            "type": "boolean",
            "description": "Whether item can be destroyed"
          },
          "soulboundType": {
            "$ref": "#/components/schemas/SoulboundType",
            "description": "Binding behavior type"
          },
          "hasDurability": {
            "type": "boolean",
            "description": "Whether item has durability"
          },
          "maxDurability": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum durability value"
          },
          "scope": {
            "$ref": "#/components/schemas/ItemScope",
            "description": "Realm availability scope"
          },
          "availableRealms": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "Available realms"
          },
          "stats": {
            "type": "object",
            "nullable": true,
            "description": "Game-defined stats"
          },
          "effects": {
            "type": "object",
            "nullable": true,
            "description": "Game-defined effects"
          },
          "requirements": {
            "type": "object",
            "nullable": true,
            "description": "Game-defined requirements"
          },
          "display": {
            "type": "object",
            "nullable": true,
            "description": "Display properties"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "description": "Other game-specific data"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether template is active"
          },
          "isDeprecated": {
            "type": "boolean",
            "description": "Whether template is deprecated"
          },
          "deprecatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When template was deprecated"
          },
          "migrationTargetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Migration target template"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Last update timestamp"
          }
        }
      },
      "JoinMatchmakingRequest": {
        "type": "object",
        "description": "Request to join a matchmaking queue",
        "additionalProperties": false,
        "required": [
          "webSocketSessionId",
          "accountId",
          "queueId"
        ],
        "properties": {
          "webSocketSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID for event delivery"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player joining"
          },
          "queueId": {
            "type": "string",
            "description": "ID of the queue to join"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Party ID if joining as part of a party"
          },
          "partyMembers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartyMemberInfo"
            },
            "nullable": true,
            "description": "Party member information (required if partyId provided)"
          },
          "stringProperties": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "String properties for query matching"
          },
          "numericProperties": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            },
            "nullable": true,
            "description": "Numeric properties for query matching"
          },
          "query": {
            "type": "string",
            "nullable": true,
            "maxLength": 1000,
            "description": "Lucene-like query for opponent matching"
          },
          "tournamentId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Tournament ID if joining tournament queue"
          }
        }
      },
      "JoinMatchmakingResponse": {
        "type": "object",
        "description": "Response after joining a matchmaking queue",
        "additionalProperties": false,
        "required": [
          "ticketId",
          "queueId",
          "estimatedWaitSeconds"
        ],
        "properties": {
          "ticketId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this matchmaking ticket"
          },
          "queueId": {
            "type": "string",
            "description": "Queue that was joined"
          },
          "estimatedWaitSeconds": {
            "type": "integer",
            "nullable": true,
            "description": "Estimated wait time based on current queue (null if unknown)"
          },
          "position": {
            "type": "integer",
            "nullable": true,
            "description": "Approximate position in queue (null if not tracked)"
          }
        }
      },
      "JsonPatchOperation": {
        "type": "object",
        "required": [
          "op",
          "path"
        ],
        "description": "JSON Patch operation per RFC 6902.\nUses JsonPatch.Net library (MIT licensed).\n",
        "properties": {
          "op": {
            "type": "string",
            "enum": [
              "add",
              "remove",
              "replace",
              "move",
              "copy",
              "test"
            ],
            "description": "Operation type"
          },
          "path": {
            "type": "string",
            "description": "JSON Pointer to target location"
          },
          "from": {
            "type": "string",
            "nullable": true,
            "description": "Source path (for move/copy operations)"
          },
          "value": {
            "description": "Value to use (for add/replace/test operations)"
          }
        }
      },
      "KeySignature": {
        "description": "A key signature with tonic and mode",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "tonic",
          "mode"
        ],
        "properties": {
          "tonic": {
            "$ref": "#/components/schemas/PitchClass",
            "description": "Tonic pitch class"
          },
          "mode": {
            "type": "string",
            "enum": [
              "major",
              "minor",
              "dorian",
              "phrygian",
              "lydian",
              "mixolydian",
              "aeolian",
              "locrian"
            ],
            "description": "Mode/scale type"
          }
        }
      },
      "KeySignatureEvent": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.KeySignatureEvent",
        "description": "A key signature change event",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "tick",
          "tonic",
          "mode"
        ],
        "properties": {
          "tick": {
            "type": "integer",
            "minimum": 0,
            "description": "Tick position"
          },
          "tonic": {
            "$ref": "#/components/schemas/PitchClass",
            "description": "Tonic pitch class"
          },
          "mode": {
            "$ref": "#/components/schemas/ModeType",
            "description": "Mode/scale type"
          }
        }
      },
      "LayerDefinition": {
        "type": "object",
        "description": "Configuration for a specific layer within a map definition",
        "required": [
          "kind"
        ],
        "properties": {
          "kind": {
            "$ref": "#/components/schemas/MapKind",
            "description": "The layer kind"
          },
          "storageMode": {
            "type": "string",
            "enum": [
              "durable",
              "cached",
              "ephemeral"
            ],
            "default": "cached",
            "description": "How this layer's data should be stored"
          },
          "ttlSeconds": {
            "type": "integer",
            "description": "TTL for cached/ephemeral data (0 = no TTL)",
            "nullable": true
          },
          "defaultNonAuthorityHandling": {
            "$ref": "#/components/schemas/NonAuthorityHandlingMode",
            "description": "Default non-authority handling for channels using this layer"
          },
          "cellSize": {
            "type": "number",
            "format": "double",
            "description": "Spatial cell size for indexing (default from config if not set)",
            "nullable": true
          }
        }
      },
      "LeaderboardDefinitionResponse": {
        "type": "object",
        "description": "Leaderboard definition details",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId",
          "displayName",
          "sortOrder",
          "updateMode",
          "isSeasonal",
          "isPublic",
          "createdAt"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning game service"
          },
          "leaderboardId": {
            "type": "string",
            "description": "Unique identifier for this leaderboard"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Description of the leaderboard"
          },
          "entityTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityType"
            },
            "description": "Allowed entity types"
          },
          "sortOrder": {
            "$ref": "#/components/schemas/SortOrder",
            "description": "Ordering used when ranking scores (descending for high scores, ascending for low)"
          },
          "updateMode": {
            "$ref": "#/components/schemas/UpdateMode",
            "description": "Rule applied when new scores are submitted (replace/increment/max/min)"
          },
          "isSeasonal": {
            "type": "boolean",
            "description": "Whether the leaderboard is seasonal"
          },
          "isPublic": {
            "type": "boolean",
            "description": "Whether the leaderboard is publicly visible"
          },
          "currentSeason": {
            "type": "integer",
            "nullable": true,
            "description": "Current season number (if seasonal)"
          },
          "entryCount": {
            "type": "integer",
            "format": "int64",
            "description": "Number of entries on the leaderboard"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the leaderboard was created"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional metadata"
          }
        }
      },
      "LeaderboardEntriesResponse": {
        "type": "object",
        "description": "Response containing leaderboard entries",
        "additionalProperties": false,
        "required": [
          "leaderboardId",
          "entries",
          "totalEntries"
        ],
        "properties": {
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard"
          },
          "entries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LeaderboardEntry"
            },
            "description": "List of leaderboard entries"
          },
          "totalEntries": {
            "type": "integer",
            "format": "int64",
            "description": "Total entries on the leaderboard"
          }
        }
      },
      "LeaderboardEntry": {
        "type": "object",
        "description": "A single entry on a leaderboard",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "score",
          "rank"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type for this leaderboard entry"
          },
          "score": {
            "type": "number",
            "format": "double",
            "description": "Entity's score"
          },
          "rank": {
            "type": "integer",
            "format": "int64",
            "description": "Entity's rank (1-based)"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Cached display name for the entity"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Entry metadata"
          }
        }
      },
      "LeaveGameSessionByIdRequest": {
        "type": "object",
        "description": "Request to leave a specific game session by ID",
        "additionalProperties": false,
        "required": [
          "webSocketSessionId",
          "accountId",
          "gameSessionId"
        ],
        "properties": {
          "webSocketSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID of the client leaving."
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player leaving."
          },
          "gameSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game session to leave."
          }
        }
      },
      "LeaveGameSessionRequest": {
        "type": "object",
        "description": "Request to leave a game session",
        "additionalProperties": false,
        "required": [
          "sessionId",
          "accountId",
          "gameType"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID of the client leaving. Provided by shortcut system."
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player leaving. Provided by shortcut system."
          },
          "gameType": {
            "type": "string",
            "description": "Game type being left. Determines which lobby to leave. Provided by shortcut system."
          }
        }
      },
      "LeaveMatchmakingRequest": {
        "type": "object",
        "description": "Request to leave a matchmaking queue",
        "additionalProperties": false,
        "required": [
          "webSocketSessionId",
          "accountId",
          "ticketId"
        ],
        "properties": {
          "webSocketSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player"
          },
          "ticketId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the ticket to cancel"
          }
        }
      },
      "ListAchievementDefinitionsRequest": {
        "type": "object",
        "description": "Request to list achievement definitions",
        "additionalProperties": false,
        "required": [
          "gameServiceId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "platform": {
            "$ref": "#/components/schemas/Platform",
            "nullable": true,
            "description": "Filter by platform"
          },
          "achievementType": {
            "$ref": "#/components/schemas/AchievementType",
            "nullable": true,
            "description": "Filter by achievement classification"
          },
          "isActive": {
            "type": "boolean",
            "nullable": true,
            "description": "Filter by active status"
          },
          "includeHidden": {
            "type": "boolean",
            "default": false,
            "description": "Include hidden achievements in response"
          }
        }
      },
      "ListAchievementDefinitionsResponse": {
        "type": "object",
        "description": "Response containing achievement definitions",
        "additionalProperties": false,
        "required": [
          "achievements"
        ],
        "properties": {
          "achievements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AchievementDefinitionResponse"
            },
            "description": "List of achievement definitions"
          }
        }
      },
      "ListArchivesRequest": {
        "description": "Request to list available archives for a namespace",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to list archives for"
          },
          "limit": {
            "type": "integer",
            "default": 20,
            "minimum": 1,
            "maximum": 100,
            "description": "Maximum number of archives to return"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "minimum": 0,
            "description": "Number of archives to skip"
          }
        }
      },
      "ListArchivesResponse": {
        "description": "Response containing a paginated list of archives",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "archives",
          "total"
        ],
        "properties": {
          "archives": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ArchiveInfo"
            },
            "description": "List of archives for the namespace"
          },
          "total": {
            "type": "integer",
            "description": "Total number of archives"
          }
        }
      },
      "ListBundleVersionsRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list bundle version history",
        "required": [
          "bundleId"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Bundle identifier to get history for"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Maximum versions to return"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          }
        }
      },
      "ListBundleVersionsResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Bundle version history",
        "required": [
          "bundleId",
          "currentVersion",
          "versions",
          "totalCount"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Bundle identifier"
          },
          "currentVersion": {
            "type": "integer",
            "description": "Current version number"
          },
          "versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BundleVersionRecord"
            },
            "description": "Version history records (newest first)"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of versions"
          }
        }
      },
      "ListCharactersRequest": {
        "description": "Request payload for listing characters with filtering and pagination",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm to list characters from (required for efficiency)"
          },
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by species"
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CharacterStatus"
              }
            ],
            "nullable": true,
            "description": "Filter by status"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "ListClauseTypesRequest": {
        "type": "object",
        "description": "Request to list clause types",
        "additionalProperties": false,
        "properties": {
          "category": {
            "$ref": "#/components/schemas/ClauseCategory",
            "nullable": true,
            "description": "Filter by category"
          },
          "includeBuiltIn": {
            "type": "boolean",
            "default": true,
            "description": "Include built-in types in response"
          }
        }
      },
      "ListClauseTypesResponse": {
        "type": "object",
        "description": "Response containing list of clause types",
        "additionalProperties": false,
        "required": [
          "clauseTypes"
        ],
        "properties": {
          "clauseTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ClauseTypeSummary"
            },
            "description": "List of registered clause types"
          }
        }
      },
      "ListContainersRequest": {
        "type": "object",
        "description": "Request to list containers for an owner",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner entity ID"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Owner type"
          },
          "containerType": {
            "type": "string",
            "nullable": true,
            "description": "Filter by container type"
          },
          "includeEquipmentSlots": {
            "type": "boolean",
            "default": true,
            "description": "Include equipment slot containers"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by realm"
          }
        }
      },
      "ListContainersResponse": {
        "type": "object",
        "description": "List of containers",
        "additionalProperties": false,
        "required": [
          "containers",
          "totalCount"
        ],
        "properties": {
          "containers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContainerResponse"
            },
            "description": "List of containers"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total count"
          }
        }
      },
      "ListContractTemplatesRequest": {
        "type": "object",
        "description": "Request to list contract templates",
        "additionalProperties": false,
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by realm (null includes cross-realm templates)"
          },
          "isActive": {
            "type": "boolean",
            "nullable": true,
            "description": "Filter by active status"
          },
          "searchTerm": {
            "type": "string",
            "nullable": true,
            "description": "Search in name and description"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Results per page"
          }
        }
      },
      "ListContractTemplatesResponse": {
        "type": "object",
        "description": "Paginated list of contract templates",
        "additionalProperties": false,
        "required": [
          "templates",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContractTemplateResponse"
            },
            "description": "List of templates"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total matching templates"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Results per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether more results exist"
          }
        }
      },
      "ListCurrencyDefinitionsRequest": {
        "type": "object",
        "description": "Request to list currency definitions",
        "additionalProperties": false,
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by realm availability"
          },
          "scope": {
            "$ref": "#/components/schemas/CurrencyScope",
            "nullable": true,
            "description": "Filter by scope"
          },
          "includeInactive": {
            "type": "boolean",
            "default": false,
            "description": "Include inactive definitions"
          },
          "isBaseCurrency": {
            "type": "boolean",
            "nullable": true,
            "description": "Filter by base currency flag"
          }
        }
      },
      "ListCurrencyDefinitionsResponse": {
        "type": "object",
        "description": "List of currency definitions",
        "additionalProperties": false,
        "required": [
          "definitions"
        ],
        "properties": {
          "definitions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CurrencyDefinitionResponse"
            },
            "description": "Currency definitions matching filter"
          }
        }
      },
      "ListDefinitionsRequest": {
        "type": "object",
        "description": "Request to list map definitions",
        "properties": {
          "nameFilter": {
            "type": "string",
            "description": "Filter by name (partial match)",
            "nullable": true
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Max results to return"
          }
        }
      },
      "ListDefinitionsResponse": {
        "type": "object",
        "description": "Response containing list of map definitions",
        "properties": {
          "definitions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapDefinition"
            },
            "description": "List of definitions"
          },
          "total": {
            "type": "integer",
            "description": "Total count matching filter"
          },
          "offset": {
            "type": "integer",
            "description": "Current offset"
          },
          "limit": {
            "type": "integer",
            "description": "Results limit used"
          }
        }
      },
      "ListDocumentsRequest": {
        "description": "Request to list documents with optional filtering and pagination",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to list documents from"
          },
          "category": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "Filter to a specific category"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by tags (null to skip tag filtering)"
          },
          "tagsMatch": {
            "type": "string",
            "enum": [
              "all",
              "any"
            ],
            "default": "all",
            "description": "Whether documents must match all tags or any tag"
          },
          "createdAfter": {
            "type": "string",
            "format": "date-time",
            "description": "Filter to documents created after this timestamp"
          },
          "createdBefore": {
            "type": "string",
            "format": "date-time",
            "description": "Filter to documents created before this timestamp"
          },
          "updatedAfter": {
            "type": "string",
            "format": "date-time",
            "description": "Filter to documents updated after this timestamp"
          },
          "updatedBefore": {
            "type": "string",
            "format": "date-time",
            "description": "Filter to documents updated before this timestamp"
          },
          "titlesOnly": {
            "type": "boolean",
            "default": false,
            "description": "Return only document titles without summaries"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "minimum": 1,
            "description": "Page number for pagination"
          },
          "pageSize": {
            "type": "integer",
            "default": 20,
            "minimum": 1,
            "maximum": 100,
            "description": "Number of documents per page"
          },
          "sortBy": {
            "$ref": "#/components/schemas/ListSortField",
            "description": "Field to sort results by"
          },
          "sortOrder": {
            "type": "string",
            "enum": [
              "asc",
              "desc"
            ],
            "default": "desc",
            "description": "Sort order direction"
          }
        }
      },
      "ListDocumentsResponse": {
        "description": "Response containing a paginated list of documents",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "documents"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "description": "The namespace that was listed"
          },
          "documents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentSummary"
            },
            "description": "List of documents in the namespace"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of documents matching filters"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of documents per page"
          },
          "totalPages": {
            "type": "integer",
            "description": "Total number of pages available"
          }
        }
      },
      "ListEncounterTypesRequest": {
        "type": "object",
        "description": "Request to list encounter types with optional filtering",
        "additionalProperties": false,
        "properties": {
          "includeInactive": {
            "type": "boolean",
            "default": false,
            "description": "Include soft-deleted types"
          },
          "builtInOnly": {
            "type": "boolean",
            "default": false,
            "description": "Only return built-in types"
          },
          "customOnly": {
            "type": "boolean",
            "default": false,
            "description": "Only return custom types"
          }
        }
      },
      "ListEscrowsRequest": {
        "type": "object",
        "description": "Request to list escrow agreements with optional filters",
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by party"
          },
          "partyType": {
            "type": "string",
            "nullable": true,
            "description": "Party type filter"
          },
          "status": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/EscrowStatus"
            },
            "description": "Filter by status"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "Filter by reference type"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by reference ID"
          },
          "fromDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter from date"
          },
          "toDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter to date"
          },
          "limit": {
            "type": "integer",
            "nullable": true,
            "description": "Limit results"
          },
          "offset": {
            "type": "integer",
            "nullable": true,
            "description": "Offset for pagination"
          }
        }
      },
      "ListEscrowsResponse": {
        "type": "object",
        "description": "Response containing list of escrow agreements",
        "required": [
          "escrows",
          "totalCount"
        ],
        "properties": {
          "escrows": {
            "type": "array",
            "description": "List of escrow agreements matching the query",
            "items": {
              "$ref": "#/components/schemas/EscrowAgreement"
            }
          },
          "totalCount": {
            "type": "integer",
            "description": "Total count for pagination"
          }
        }
      },
      "ListItemTemplatesRequest": {
        "type": "object",
        "description": "Request to list item templates",
        "additionalProperties": false,
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Filter by game service"
          },
          "category": {
            "$ref": "#/components/schemas/ItemCategory",
            "description": "Filter by item category"
          },
          "subcategory": {
            "type": "string",
            "nullable": true,
            "description": "Filter by subcategory"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by tags (items must have all specified tags)"
          },
          "rarity": {
            "$ref": "#/components/schemas/ItemRarity",
            "description": "Filter by rarity tier"
          },
          "scope": {
            "$ref": "#/components/schemas/ItemScope",
            "description": "Filter by realm scope"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by realm availability"
          },
          "includeInactive": {
            "type": "boolean",
            "default": false,
            "description": "Include inactive templates"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Include deprecated templates"
          },
          "search": {
            "type": "string",
            "nullable": true,
            "description": "Search in name and description"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "maximum": 200,
            "description": "Maximum results to return"
          }
        }
      },
      "ListItemTemplatesResponse": {
        "type": "object",
        "description": "Paginated list of item templates",
        "additionalProperties": false,
        "required": [
          "templates",
          "totalCount"
        ],
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ItemTemplateResponse"
            },
            "description": "List of templates"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching templates"
          }
        }
      },
      "ListItemsByContainerRequest": {
        "type": "object",
        "description": "Request to list items in a container",
        "additionalProperties": false,
        "required": [
          "containerId"
        ],
        "properties": {
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container to list items from"
          }
        }
      },
      "ListItemsResponse": {
        "type": "object",
        "description": "List of item instances",
        "additionalProperties": false,
        "required": [
          "items",
          "totalCount"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ItemInstanceResponse"
            },
            "description": "List of items"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching items"
          }
        }
      },
      "ListLocationsByParentRequest": {
        "description": "Request to list all child locations of a specified parent location",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "parentLocationId"
        ],
        "properties": {
          "parentLocationId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the parent location"
          },
          "locationType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LocationType"
              }
            ],
            "nullable": true,
            "description": "Optional filter by location type"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated locations in the response"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "ListLocationsByRealmRequest": {
        "description": "Request to list all locations within a specific realm with optional filtering",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID to query"
          },
          "locationType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LocationType"
              }
            ],
            "nullable": true,
            "description": "Optional type filter"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated locations in the response"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "ListLocationsRequest": {
        "description": "Request to list locations within a realm with optional type and deprecation filtering",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID to query (required - locations are partitioned by realm)"
          },
          "locationType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LocationType"
              }
            ],
            "nullable": true,
            "description": "Filter by location type"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated locations in the response"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "ListQueuesRequest": {
        "type": "object",
        "description": "Request to list available matchmaking queues",
        "additionalProperties": false,
        "properties": {
          "gameId": {
            "type": "string",
            "nullable": true,
            "description": "Filter by game ID (null for all games)"
          },
          "includeDisabled": {
            "type": "boolean",
            "default": false,
            "description": "Include disabled queues in the list (admin only)"
          }
        }
      },
      "ListQueuesResponse": {
        "type": "object",
        "description": "Response containing available matchmaking queues",
        "additionalProperties": false,
        "required": [
          "queues"
        ],
        "properties": {
          "queues": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueueSummary"
            },
            "description": "List of available queues"
          }
        }
      },
      "ListRealmsRequest": {
        "description": "Request to list realms with optional filtering and pagination",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Filter by category (e.g., \"MAIN\", \"SPECIAL\", \"TEST\")"
          },
          "isActive": {
            "type": "boolean",
            "nullable": true,
            "description": "Filter by active status"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated realms in the response"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of realms to return per page"
          }
        }
      },
      "ListRelationshipTypesRequest": {
        "description": "Request to list relationship types with optional filtering by category, hierarchy, and deprecation status",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Filter by category (e.g., \"FAMILY\", \"SOCIAL\", \"ECONOMIC\") (null to include all)"
          },
          "includeChildren": {
            "type": "boolean",
            "default": true,
            "description": "Whether to include child types in the response"
          },
          "rootsOnly": {
            "type": "boolean",
            "default": false,
            "description": "Only return types with no parent (root types)"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated types in the response"
          }
        }
      },
      "ListRelationshipsByEntityRequest": {
        "description": "Request to list all relationships for a specific entity with optional filters",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity to get relationships for"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the entity to get relationships for"
          },
          "relationshipTypeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional filter by relationship type"
          },
          "otherEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "nullable": true,
            "description": "Optional filter by the other entity's type"
          },
          "includeEnded": {
            "type": "boolean",
            "default": false,
            "description": "Include relationships that have ended"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for paginated results (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page (max 100)"
          }
        }
      },
      "ListRelationshipsByTypeRequest": {
        "description": "Request to list all relationships of a specific relationship type",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "relationshipTypeId"
        ],
        "properties": {
          "relationshipTypeId": {
            "type": "string",
            "format": "uuid",
            "description": "Relationship type to filter by"
          },
          "entity1Type": {
            "$ref": "#/components/schemas/EntityType",
            "nullable": true,
            "description": "Optional filter by entity1 type"
          },
          "entity2Type": {
            "$ref": "#/components/schemas/EntityType",
            "nullable": true,
            "description": "Optional filter by entity2 type"
          },
          "includeEnded": {
            "type": "boolean",
            "default": false,
            "description": "Include relationships that have ended"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for paginated results (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page (max 100)"
          }
        }
      },
      "ListRepositoryBindingsRequest": {
        "description": "Request to list all repository bindings with optional filtering",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "status": {
            "$ref": "#/components/schemas/BindingStatus",
            "description": "Filter by binding status"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "minimum": 1,
            "maximum": 100,
            "description": "Maximum number of bindings to return"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "minimum": 0,
            "description": "Number of bindings to skip"
          }
        }
      },
      "ListRepositoryBindingsResponse": {
        "description": "Response containing a list of repository bindings",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bindings",
          "total"
        ],
        "properties": {
          "bindings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RepositoryBindingInfo"
            },
            "description": "List of repository bindings"
          },
          "total": {
            "type": "integer",
            "description": "Total number of bindings matching filter"
          }
        }
      },
      "ListRootLocationsRequest": {
        "description": "Request to list all top-level locations (without parents) in a realm",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID to get root locations for"
          },
          "locationType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LocationType"
              }
            ],
            "nullable": true,
            "description": "Optional filter by location type"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated locations in the response"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "ListScenesRequest": {
        "type": "object",
        "description": "Request to list scenes with optional filters",
        "properties": {
          "gameId": {
            "type": "string",
            "nullable": true,
            "description": "Filter by game ID"
          },
          "sceneType": {
            "$ref": "#/components/schemas/SceneType",
            "nullable": true,
            "description": "Filter by single scene type"
          },
          "sceneTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SceneType"
            },
            "nullable": true,
            "description": "Filter by multiple scene types (OR)"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by tags (scenes must have ALL specified tags)"
          },
          "nameContains": {
            "type": "string",
            "nullable": true,
            "description": "Filter by name containing this substring (case-insensitive)"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "minimum": 0,
            "description": "Pagination offset"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "minimum": 1,
            "maximum": 200,
            "description": "Maximum results to return"
          }
        }
      },
      "ListScenesResponse": {
        "type": "object",
        "description": "Response containing scene list and pagination info",
        "required": [
          "scenes",
          "total"
        ],
        "properties": {
          "scenes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SceneSummary"
            },
            "description": "List of scene summaries (not full documents)"
          },
          "total": {
            "type": "integer",
            "description": "Total number of matching scenes"
          },
          "offset": {
            "type": "integer",
            "description": "Current offset"
          },
          "limit": {
            "type": "integer",
            "description": "Applied limit"
          }
        }
      },
      "ListSchemasRequest": {
        "type": "object",
        "description": "Request to list all registered schemas for a namespace",
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Schema namespace to list"
          }
        }
      },
      "ListSchemasResponse": {
        "type": "object",
        "description": "List of registered schemas with latest version indicator",
        "required": [
          "schemas"
        ],
        "properties": {
          "schemas": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SchemaResponse"
            },
            "description": "Registered schemas"
          },
          "latestVersion": {
            "type": "string",
            "nullable": true,
            "description": "Latest schema version"
          }
        }
      },
      "ListServicesRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list all game services",
        "properties": {
          "activeOnly": {
            "type": "boolean",
            "default": false,
            "description": "If true, only return active services"
          }
        }
      },
      "ListServicesResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response containing list of game services",
        "required": [
          "services",
          "totalCount"
        ],
        "properties": {
          "services": {
            "type": "array",
            "description": "List of game services matching the request criteria",
            "items": {
              "$ref": "#/components/schemas/ServiceInfo"
            }
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of services matching the filter"
          }
        }
      },
      "ListSlotsRequest": {
        "type": "object",
        "description": "Request to list all save slots belonging to a specific owner",
        "required": [
          "gameId",
          "ownerId",
          "ownerType"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "minLength": 1,
            "maxLength": 32,
            "pattern": "^[a-z][a-z0-9-]*$",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns the save slots to list"
          },
          "category": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SaveCategory"
              }
            ],
            "nullable": true,
            "description": "Optional filter by save category"
          },
          "includeVersionCount": {
            "type": "boolean",
            "default": true,
            "description": "Include version count in response"
          }
        }
      },
      "ListSlotsResponse": {
        "type": "object",
        "description": "Response containing a list of save slots for an owner",
        "required": [
          "slots"
        ],
        "properties": {
          "slots": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SlotResponse"
            },
            "description": "List of slots"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of slots for owner"
          }
        }
      },
      "ListSortField": {
        "type": "string",
        "enum": [
          "created_at",
          "updated_at",
          "title"
        ],
        "default": "updated_at",
        "description": "Fields available for sorting document lists"
      },
      "ListSpeciesByRealmRequest": {
        "description": "Request to list species available within a specific realm",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the realm to filter by"
          },
          "isPlayable": {
            "type": "boolean",
            "nullable": true,
            "description": "Filter by playable status"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of items per page"
          }
        }
      },
      "ListSpeciesRequest": {
        "description": "Request to list species with optional filtering and pagination",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Filter by category (e.g., \"HUMANOID\", \"BEAST\", \"MAGICAL\")"
          },
          "isPlayable": {
            "type": "boolean",
            "nullable": true,
            "description": "Filter by playable status"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated species in the response"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of items per page"
          }
        }
      },
      "ListStylesRequest": {
        "description": "Request to list available styles",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Filter by category (e.g., \"folk\", \"classical\", \"jazz\")"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 50,
            "description": "Maximum number of styles to return"
          },
          "offset": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Pagination offset"
          }
        }
      },
      "ListStylesResponse": {
        "description": "Response containing a list of styles",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "styles",
          "total"
        ],
        "properties": {
          "styles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StyleSummary"
            },
            "description": "Style summaries"
          },
          "total": {
            "type": "integer",
            "description": "Total number of styles matching filter"
          }
        }
      },
      "ListUnlockedAchievementsRequest": {
        "type": "object",
        "description": "Request to list unlocked achievements",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "entityId",
          "entityType"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type whose unlocked achievements are listed"
          },
          "platform": {
            "$ref": "#/components/schemas/Platform",
            "nullable": true,
            "description": "Filter by platform"
          }
        }
      },
      "ListUnlockedAchievementsResponse": {
        "type": "object",
        "description": "Response containing unlocked achievements",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "achievements",
          "totalPoints"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type for the returned unlocked achievements"
          },
          "achievements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UnlockedAchievement"
            },
            "description": "List of unlocked achievements"
          },
          "totalPoints": {
            "type": "integer",
            "description": "Total points earned"
          }
        }
      },
      "ListVersionsRequest": {
        "description": "Request to list all versions of an asset with pagination",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "assetId"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Asset identifier to list versions for"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Maximum number of versions to return"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Number of versions to skip for pagination"
          }
        }
      },
      "ListVersionsResponse": {
        "type": "object",
        "description": "Paginated list of save versions within a slot",
        "required": [
          "versions",
          "totalCount"
        ],
        "properties": {
          "versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VersionResponse"
            },
            "description": "List of versions"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total version count in slot"
          }
        }
      },
      "LoadRequest": {
        "type": "object",
        "description": "Request to load save data from a specific slot and version",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "minLength": 1,
            "maxLength": 32,
            "pattern": "^[a-z][a-z0-9-]*$",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          },
          "versionNumber": {
            "type": "integer",
            "nullable": true,
            "description": "Specific version to load (defaults to latest)"
          },
          "checkpointName": {
            "type": "string",
            "nullable": true,
            "description": "Load by checkpoint name instead of version number"
          },
          "includeMetadata": {
            "type": "boolean",
            "default": true,
            "description": "Include version metadata in response"
          }
        }
      },
      "LoadResponse": {
        "type": "object",
        "description": "Response containing loaded save data with integrity verification",
        "required": [
          "slotId",
          "versionNumber",
          "data",
          "contentHash"
        ],
        "properties": {
          "slotId": {
            "type": "string",
            "format": "uuid",
            "description": "Slot identifier"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Version number loaded"
          },
          "data": {
            "type": "string",
            "format": "byte",
            "description": "Base64-encoded save data (decompressed)"
          },
          "contentHash": {
            "type": "string",
            "description": "SHA-256 hash for integrity verification"
          },
          "schemaVersion": {
            "type": "string",
            "nullable": true,
            "description": "Schema version of this save"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable name"
          },
          "pinned": {
            "type": "boolean",
            "description": "Whether this version is pinned"
          },
          "checkpointName": {
            "type": "string",
            "nullable": true,
            "description": "Checkpoint name if pinned"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Save timestamp"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom metadata"
          }
        }
      },
      "Location": {
        "type": "object",
        "additionalProperties": false,
        "description": "Character location information including current position, region, and 3D coordinates",
        "properties": {
          "current": {
            "type": "string",
            "nullable": true,
            "description": "Current location name or identifier"
          },
          "region": {
            "type": "string",
            "nullable": true,
            "description": "Region or zone the character is in"
          },
          "coordinates": {
            "$ref": "#/components/schemas/Coordinates",
            "nullable": true,
            "description": "3D spatial coordinates of the character's position in the game world"
          }
        }
      },
      "LocationExistsRequest": {
        "description": "Request to check if a location exists and is active",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "locationId"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the location to validate"
          }
        }
      },
      "LocationExistsResponse": {
        "description": "Response indicating whether a location exists and its active status",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "exists",
          "isActive"
        ],
        "properties": {
          "exists": {
            "type": "boolean",
            "description": "Whether the location exists"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether the location is active (false if deprecated or not found)"
          },
          "locationId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "The location ID if found"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "The realm ID if location found"
          }
        }
      },
      "LocationListResponse": {
        "description": "Paginated list of locations with metadata for navigation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "locations",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "locations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LocationResponse"
            },
            "description": "List of locations matching the query"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of locations matching the query (across all pages)"
          },
          "page": {
            "type": "integer",
            "description": "Current page number (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether there are more pages after the current page"
          },
          "hasPreviousPage": {
            "type": "boolean",
            "description": "Whether there are pages before the current page"
          }
        }
      },
      "LocationResponse": {
        "description": "Complete location data returned from API operations",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "locationId",
          "realmId",
          "code",
          "name",
          "locationType",
          "depth",
          "isDeprecated",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the location"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm this location belongs to"
          },
          "code": {
            "type": "string",
            "description": "Unique code for the location within its realm"
          },
          "name": {
            "type": "string",
            "description": "Display name of the location"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Optional description of the location"
          },
          "locationType": {
            "$ref": "#/components/schemas/LocationType",
            "description": "Type classification of the location"
          },
          "parentLocationId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Parent location ID (null for root locations)"
          },
          "depth": {
            "type": "integer",
            "description": "Depth in hierarchy (0 for root locations)"
          },
          "isDeprecated": {
            "type": "boolean",
            "description": "Whether this location is deprecated and cannot be used"
          },
          "deprecatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Timestamp when this location was deprecated"
          },
          "deprecationReason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for deprecation"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional metadata for the location (JSON)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the location was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the location was last updated"
          }
        }
      },
      "LocationType": {
        "type": "string",
        "description": "Type classification for locations",
        "enum": [
          "CONTINENT",
          "REGION",
          "CITY",
          "DISTRICT",
          "BUILDING",
          "ROOM",
          "LANDMARK",
          "WILDERNESS",
          "DUNGEON",
          "OTHER"
        ]
      },
      "LockContractRequest": {
        "type": "object",
        "description": "Request to lock a contract under guardian custody",
        "additionalProperties": false,
        "required": [
          "contractInstanceId",
          "guardianId",
          "guardianType"
        ],
        "properties": {
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID to lock"
          },
          "guardianId": {
            "type": "string",
            "format": "uuid",
            "description": "Guardian entity ID (e.g., escrow agreement ID)"
          },
          "guardianType": {
            "type": "string",
            "maxLength": 64,
            "description": "Guardian entity type (e.g., \"escrow\")"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Optional idempotency key for the operation"
          }
        }
      },
      "LockContractResponse": {
        "type": "object",
        "description": "Response from locking a contract",
        "additionalProperties": false,
        "required": [
          "locked",
          "contractId"
        ],
        "properties": {
          "locked": {
            "type": "boolean",
            "description": "Whether the contract was locked"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "guardianId": {
            "type": "string",
            "format": "uuid",
            "description": "Guardian entity ID"
          },
          "lockedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the contract was locked"
          }
        }
      },
      "LoginRequest": {
        "description": "Request to authenticate a user with email and password credentials",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "email",
          "password"
        ],
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "description": "Email address for authentication"
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "User password for authentication"
          },
          "rememberMe": {
            "type": "boolean",
            "default": false,
            "description": "Whether to extend the session duration for persistent login"
          },
          "deviceInfo": {
            "$ref": "#/components/schemas/DeviceInfo",
            "nullable": true,
            "description": "Information about the client device (optional)"
          }
        }
      },
      "Logo": {
        "description": "Site logo configuration including image URL and accessibility text",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "url": {
            "type": "string",
            "format": "uri",
            "description": "URL of the site logo image"
          },
          "alt": {
            "type": "string",
            "description": "Alt text for the logo image"
          }
        }
      },
      "LogoutRequest": {
        "description": "Request to logout and invalidate authentication tokens",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "allSessions": {
            "type": "boolean",
            "default": false,
            "description": "Logout from all sessions/devices"
          }
        }
      },
      "MapDefinition": {
        "type": "object",
        "description": "A map definition template that describes the structure of a region",
        "required": [
          "definitionId",
          "name",
          "createdAt"
        ],
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this definition"
          },
          "name": {
            "type": "string",
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "description": "Description of the map template",
            "nullable": true
          },
          "layers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LayerDefinition"
            },
            "description": "Layer configurations for this map",
            "nullable": true
          },
          "defaultBounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Default bounds for regions using this definition",
            "nullable": true
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "description": "Additional metadata (schema-less)",
            "nullable": true
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the definition was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the definition was last updated",
            "nullable": true
          }
        }
      },
      "MapKind": {
        "type": "string",
        "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
        "enum": [
          "terrain",
          "static_geometry",
          "navigation",
          "resources",
          "spawn_points",
          "points_of_interest",
          "dynamic_objects",
          "hazards",
          "weather_effects",
          "ownership",
          "combat_effects",
          "visual_effects"
        ]
      },
      "MapObject": {
        "type": "object",
        "description": "A stored map object with full metadata",
        "required": [
          "objectId",
          "regionId",
          "kind",
          "objectType",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "objectId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this object"
          },
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region this object belongs to"
          },
          "kind": {
            "$ref": "#/components/schemas/MapKind",
            "description": "Map kind this object is stored under"
          },
          "objectType": {
            "type": "string",
            "description": "Publisher-defined type"
          },
          "position": {
            "$ref": "#/components/schemas/Position3D",
            "description": "Position for point objects",
            "nullable": true
          },
          "bounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Bounding box for area objects",
            "nullable": true
          },
          "data": {
            "type": "object",
            "additionalProperties": true,
            "description": "Schema-less object data (publisher-defined)",
            "nullable": true
          },
          "version": {
            "type": "integer",
            "format": "int64",
            "description": "Monotonic version for ordering"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the object was first created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the object was last updated"
          }
        }
      },
      "MarkerType": {
        "type": "string",
        "description": "Types of marker nodes for spawn points, waypoints, and other positional markers.",
        "enum": [
          "generic",
          "spawn_point",
          "npc_spawn",
          "waypoint",
          "camera_point",
          "light_point",
          "audio_point",
          "trigger_point"
        ]
      },
      "MatchesHierarchyRequest": {
        "description": "Request to check if a relationship type matches or descends from an ancestor type in the hierarchy",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "typeId",
          "ancestorTypeId"
        ],
        "properties": {
          "typeId": {
            "type": "string",
            "format": "uuid",
            "description": "The relationship type to check"
          },
          "ancestorTypeId": {
            "type": "string",
            "format": "uuid",
            "description": "The potential ancestor type"
          }
        }
      },
      "MatchesHierarchyResponse": {
        "description": "Response indicating whether a type matches an ancestor in the hierarchy and the depth between them",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "matches"
        ],
        "properties": {
          "matches": {
            "type": "boolean",
            "description": "True if typeId equals or descends from ancestorTypeId"
          },
          "depth": {
            "type": "integer",
            "description": "Number of levels between the types (0 if same, -1 if no match)"
          }
        }
      },
      "MatchmakingStatsResponse": {
        "type": "object",
        "description": "Matchmaking operational statistics",
        "additionalProperties": false,
        "required": [
          "timestamp",
          "queueStats"
        ],
        "properties": {
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When these stats were collected"
          },
          "queueStats": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueueStats"
            },
            "description": "Statistics per queue"
          }
        }
      },
      "MatchmakingStatusResponse": {
        "type": "object",
        "description": "Current matchmaking status for a ticket",
        "additionalProperties": false,
        "required": [
          "ticketId",
          "queueId",
          "status",
          "intervalsElapsed",
          "createdAt"
        ],
        "properties": {
          "ticketId": {
            "type": "string",
            "format": "uuid",
            "description": "Ticket identifier"
          },
          "queueId": {
            "type": "string",
            "description": "Queue the ticket is in"
          },
          "status": {
            "$ref": "#/components/schemas/TicketStatus",
            "description": "Current ticket status"
          },
          "intervalsElapsed": {
            "type": "integer",
            "description": "Number of processing intervals elapsed"
          },
          "currentSkillRange": {
            "type": "integer",
            "nullable": true,
            "description": "Current skill matching range (null if skill not used)"
          },
          "estimatedWaitSeconds": {
            "type": "integer",
            "nullable": true,
            "description": "Updated estimated wait time"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the ticket was created"
          },
          "matchId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Match ID if a match has been found"
          }
        }
      },
      "MelodyAnalysis": {
        "description": "Analysis of a melody",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "range": {
            "$ref": "#/components/schemas/PitchRange",
            "nullable": true,
            "description": "Pitch range used"
          },
          "intervalDistribution": {
            "type": "object",
            "additionalProperties": {
              "type": "number",
              "format": "float"
            },
            "nullable": true,
            "description": "Distribution of interval sizes"
          },
          "contour": {
            "type": "string",
            "nullable": true,
            "description": "Detected contour shape"
          },
          "noteCount": {
            "type": "integer",
            "description": "Total number of notes"
          },
          "averageNoteDuration": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "description": "Average note duration in ticks"
          }
        }
      },
      "MergeStacksRequest": {
        "type": "object",
        "description": "Request to merge stacks",
        "additionalProperties": false,
        "required": [
          "sourceInstanceId",
          "targetInstanceId"
        ],
        "properties": {
          "sourceInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Stack to merge from (destroyed)"
          },
          "targetInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Stack to merge into"
          }
        }
      },
      "MergeStacksResponse": {
        "type": "object",
        "description": "Response after merging",
        "additionalProperties": false,
        "required": [
          "success",
          "targetInstanceId",
          "newQuantity",
          "sourceDestroyed"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether merge succeeded"
          },
          "targetInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Merged stack ID"
          },
          "newQuantity": {
            "type": "number",
            "format": "double",
            "description": "New quantity"
          },
          "sourceDestroyed": {
            "type": "boolean",
            "description": "Whether source was destroyed"
          },
          "overflowQuantity": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Quantity that didn't fit"
          }
        }
      },
      "MetadataType": {
        "type": "string",
        "description": "Type of metadata to update",
        "enum": [
          "instance_data",
          "runtime_state"
        ]
      },
      "MidiEvent": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.MidiEvent",
        "description": "A single MIDI event",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "tick",
          "type"
        ],
        "properties": {
          "tick": {
            "type": "integer",
            "minimum": 0,
            "description": "Absolute tick position"
          },
          "type": {
            "$ref": "#/components/schemas/MidiEventType",
            "description": "Event type"
          },
          "note": {
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "nullable": true,
            "description": "MIDI note number (for note events)"
          },
          "velocity": {
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "nullable": true,
            "description": "Note velocity (for note events)"
          },
          "duration": {
            "type": "integer",
            "minimum": 1,
            "nullable": true,
            "description": "Note duration in ticks (for noteOn with implicit noteOff)"
          },
          "program": {
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "nullable": true,
            "description": "Program number (for programChange)"
          },
          "controller": {
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "nullable": true,
            "description": "Controller number (for controlChange)"
          },
          "value": {
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "nullable": true,
            "description": "Controller value (for controlChange)"
          }
        }
      },
      "MidiEventType": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.MidiEventType",
        "description": "MIDI event type",
        "type": "string",
        "enum": [
          "NoteOn",
          "NoteOff",
          "ProgramChange",
          "ControlChange"
        ]
      },
      "MidiHeader": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.MidiHeader",
        "description": "MIDI file header information",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "format": {
            "type": "integer",
            "minimum": 0,
            "maximum": 2,
            "default": 1,
            "description": "MIDI format type (0, 1, or 2)"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "Composition name"
          },
          "tempos": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TempoEvent"
            },
            "nullable": true,
            "description": "Tempo changes"
          },
          "timeSignatures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TimeSignatureEvent"
            },
            "nullable": true,
            "description": "Time signature changes"
          },
          "keySignatures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KeySignatureEvent"
            },
            "nullable": true,
            "description": "Key signature changes"
          }
        }
      },
      "MidiJson": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.MidiJson",
        "description": "MIDI-JSON format representation of a musical piece",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "tracks",
          "ticksPerBeat"
        ],
        "properties": {
          "header": {
            "$ref": "#/components/schemas/MidiHeader",
            "nullable": true,
            "description": "MIDI header information"
          },
          "ticksPerBeat": {
            "type": "integer",
            "minimum": 24,
            "maximum": 960,
            "default": 480,
            "description": "Ticks per beat (PPQN)"
          },
          "tracks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MidiTrack"
            },
            "description": "MIDI tracks"
          }
        }
      },
      "MidiTrack": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.MidiTrack",
        "description": "A single MIDI track containing events",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "events"
        ],
        "properties": {
          "name": {
            "type": "string",
            "nullable": true,
            "description": "Track name"
          },
          "channel": {
            "type": "integer",
            "minimum": 0,
            "maximum": 15,
            "default": 0,
            "description": "MIDI channel"
          },
          "instrument": {
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "nullable": true,
            "description": "GM instrument number"
          },
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MidiEvent"
            },
            "description": "Track events"
          }
        }
      },
      "MigrateSaveRequest": {
        "type": "object",
        "description": "Request to migrate a save to a newer schema version",
        "required": [
          "ownerId",
          "ownerType",
          "slotName",
          "targetSchemaVersion"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Specific version to migrate (defaults to latest)"
          },
          "targetSchemaVersion": {
            "type": "string",
            "description": "Target schema version to migrate to"
          },
          "dryRun": {
            "type": "boolean",
            "default": false,
            "description": "Validate migration without saving"
          }
        }
      },
      "MigrateSaveResponse": {
        "type": "object",
        "description": "Result of a schema migration operation with version path details",
        "required": [
          "success",
          "fromSchemaVersion",
          "toSchemaVersion"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether migration succeeded"
          },
          "fromSchemaVersion": {
            "type": "string",
            "description": "Original schema version"
          },
          "toSchemaVersion": {
            "type": "string",
            "description": "Target schema version"
          },
          "newVersionNumber": {
            "type": "integer",
            "nullable": true,
            "description": "New version number (null if dry run)"
          },
          "migrationPath": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Migration path applied (list of versions)"
          },
          "warnings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Non-fatal migration warnings"
          }
        }
      },
      "MilestoneDefinition": {
        "type": "object",
        "description": "Milestone definition in a template",
        "additionalProperties": false,
        "required": [
          "code",
          "name",
          "sequence",
          "required"
        ],
        "properties": {
          "code": {
            "type": "string",
            "maxLength": 64,
            "description": "Unique milestone code within template"
          },
          "name": {
            "type": "string",
            "maxLength": 200,
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "maxLength": 1000,
            "nullable": true,
            "description": "What this milestone represents"
          },
          "sequence": {
            "type": "integer",
            "minimum": 0,
            "description": "Order in the contract flow"
          },
          "required": {
            "type": "boolean",
            "description": "Whether milestone must be completed"
          },
          "deadline": {
            "type": "string",
            "nullable": true,
            "description": "Relative deadline (ISO 8601 duration)"
          },
          "onComplete": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreboundApi"
            },
            "nullable": true,
            "description": "APIs to call on completion"
          },
          "onExpire": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreboundApi"
            },
            "nullable": true,
            "description": "APIs to call if deadline passes"
          }
        }
      },
      "MilestoneInstanceResponse": {
        "type": "object",
        "description": "Milestone instance status",
        "additionalProperties": false,
        "required": [
          "code",
          "name",
          "sequence",
          "required",
          "status"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Milestone code"
          },
          "name": {
            "type": "string",
            "description": "Milestone name"
          },
          "sequence": {
            "type": "integer",
            "description": "Order in flow"
          },
          "required": {
            "type": "boolean",
            "description": "Whether required"
          },
          "status": {
            "$ref": "#/components/schemas/MilestoneStatus",
            "description": "Current status"
          },
          "completedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When completed"
          },
          "failedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When failed"
          },
          "deadline": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Absolute deadline"
          }
        }
      },
      "MilestoneProgressSummary": {
        "type": "object",
        "description": "Brief milestone progress",
        "additionalProperties": false,
        "required": [
          "code",
          "status"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Milestone code"
          },
          "status": {
            "$ref": "#/components/schemas/MilestoneStatus",
            "description": "Current status"
          }
        }
      },
      "MilestoneResponse": {
        "type": "object",
        "description": "Milestone details",
        "additionalProperties": false,
        "required": [
          "contractId",
          "milestone"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "milestone": {
            "$ref": "#/components/schemas/MilestoneInstanceResponse",
            "description": "Milestone details"
          }
        }
      },
      "MilestoneStatus": {
        "type": "string",
        "description": "Current status of a milestone",
        "enum": [
          "pending",
          "active",
          "completed",
          "failed",
          "skipped"
        ]
      },
      "ModeDistribution": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Style.ModeDistribution",
        "description": "Probability distribution over musical modes",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "major": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of major mode"
          },
          "minor": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of natural minor"
          },
          "dorian": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of dorian mode"
          },
          "phrygian": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of phrygian mode"
          },
          "lydian": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of lydian mode"
          },
          "mixolydian": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of mixolydian mode"
          },
          "aeolian": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of aeolian mode"
          },
          "locrian": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of locrian mode"
          }
        }
      },
      "ModeType": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Collections.ModeType",
        "description": "Musical mode/scale type",
        "type": "string",
        "enum": [
          "Major",
          "Minor",
          "Dorian",
          "Phrygian",
          "Lydian",
          "Mixolydian",
          "Aeolian",
          "Locrian",
          "HarmonicMinor",
          "MelodicMinor",
          "MajorPentatonic",
          "MinorPentatonic",
          "Blues",
          "WholeTone",
          "Chromatic"
        ]
      },
      "ModifyItemInstanceRequest": {
        "type": "object",
        "description": "Request to modify item instance state",
        "additionalProperties": false,
        "required": [
          "instanceId"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Instance ID to modify"
          },
          "durabilityDelta": {
            "type": "integer",
            "nullable": true,
            "description": "Change to durability (positive to repair, negative for damage)"
          },
          "customStats": {
            "type": "object",
            "nullable": true,
            "description": "New custom stats (merges with existing)"
          },
          "customName": {
            "type": "string",
            "maxLength": 128,
            "nullable": true,
            "description": "New custom name"
          },
          "quantityDelta": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Change to quantity (positive to add, negative to subtract). Only valid for stackable items."
          },
          "instanceMetadata": {
            "type": "object",
            "nullable": true,
            "description": "New instance metadata (merges with existing)"
          }
        }
      },
      "MoveItemRequest": {
        "type": "object",
        "description": "Request to move item",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "targetContainerId"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance ID to move"
          },
          "targetContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "Target container ID"
          },
          "targetSlotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Target slot"
          },
          "targetSlotX": {
            "type": "integer",
            "nullable": true,
            "description": "Target grid X"
          },
          "targetSlotY": {
            "type": "integer",
            "nullable": true,
            "description": "Target grid Y"
          },
          "rotated": {
            "type": "boolean",
            "nullable": true,
            "description": "Rotate in target"
          }
        }
      },
      "MoveItemResponse": {
        "type": "object",
        "description": "Response after moving item",
        "additionalProperties": false,
        "required": [
          "success",
          "instanceId",
          "sourceContainerId",
          "targetContainerId"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether move succeeded"
          },
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Moved item ID"
          },
          "sourceContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "Previous container"
          },
          "targetContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "New container"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "New slot"
          },
          "slotX": {
            "type": "integer",
            "nullable": true,
            "description": "New grid X"
          },
          "slotY": {
            "type": "integer",
            "nullable": true,
            "description": "New grid Y"
          }
        }
      },
      "MultipartConfig": {
        "description": "Configuration for multipart uploads of large files",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "required": {
            "type": "boolean",
            "description": "Whether multipart upload is required for this file size"
          },
          "partSize": {
            "type": "integer",
            "description": "Size of each part in bytes"
          },
          "maxParts": {
            "type": "integer",
            "description": "Maximum number of parts"
          },
          "uploadUrls": {
            "type": "array",
            "nullable": true,
            "description": "Pre-signed URLs for each part of the multipart upload",
            "items": {
              "$ref": "#/components/schemas/PartUploadInfo"
            }
          }
        }
      },
      "NarrativeOptions": {
        "description": "Options for narrative-driven composition using the Storyteller engine",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "templateId": {
            "type": "string",
            "nullable": true,
            "description": "Specific narrative template ID (e.g., 'journey_and_return', 'tension_and_release', 'simple_arc').\nIf not specified, template is inferred from mood or defaults to 'simple_arc'.\n"
          },
          "initialEmotion": {
            "$ref": "#/components/schemas/EmotionalStateInput",
            "nullable": true,
            "description": "Starting emotional state for the composition"
          },
          "targetEmotion": {
            "$ref": "#/components/schemas/EmotionalStateInput",
            "nullable": true,
            "description": "Target emotional state for the ending"
          },
          "tensionProfile": {
            "type": "string",
            "enum": [
              "gradual_build",
              "early_climax",
              "late_climax",
              "sustained",
              "wave"
            ],
            "nullable": true,
            "description": "Preferred tension curve shape throughout the composition"
          }
        }
      },
      "NavigationItem": {
        "description": "A navigation menu entry with optional nested children for dropdowns",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "label",
          "url",
          "order"
        ],
        "properties": {
          "label": {
            "type": "string",
            "description": "Display text for the navigation link"
          },
          "url": {
            "type": "string",
            "description": "Target URL or path for the navigation link"
          },
          "order": {
            "type": "integer",
            "description": "Sort order for the navigation item"
          },
          "target": {
            "type": "string",
            "enum": [
              "_self",
              "_blank"
            ],
            "default": "_self",
            "description": "Link target attribute for opening behavior"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NavigationItem"
            },
            "description": "Nested child navigation items for dropdowns"
          }
        }
      },
      "NearbyObject": {
        "type": "object",
        "additionalProperties": true,
        "description": "Information about a nearby object perceived by the character",
        "properties": {
          "objectId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the object"
          },
          "objectType": {
            "type": "string",
            "description": "Type of object (boulder_cluster, tree, building, etc.)"
          },
          "distance": {
            "type": "number",
            "format": "float",
            "description": "Distance from character in game units"
          },
          "direction": {
            "type": "string",
            "description": "Relative direction (north, south, east, west, above, below, etc.)"
          },
          "position": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Position3D"
              }
            ],
            "nullable": true,
            "description": "Optional absolute position"
          }
        }
      },
      "NewsItem": {
        "description": "A single news article or announcement entry",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "id",
          "title",
          "summary",
          "publishedAt"
        ],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the news item"
          },
          "title": {
            "type": "string",
            "description": "Headline of the news item"
          },
          "summary": {
            "type": "string",
            "description": "Brief summary or excerpt of the news content"
          },
          "content": {
            "type": "string",
            "nullable": true,
            "description": "Full content body of the news item"
          },
          "author": {
            "type": "string",
            "description": "Name of the news item author"
          },
          "publishedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Date and time when the news was published"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Category tags associated with the news item"
          },
          "imageUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "URL of the featured image for the news item"
          }
        }
      },
      "NewsResponse": {
        "description": "Paginated list of news items with total count",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "items",
          "total"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NewsItem"
            },
            "description": "List of news items for the current page"
          },
          "total": {
            "type": "integer",
            "description": "Total number of news items available"
          },
          "hasMore": {
            "type": "boolean",
            "description": "Whether more news items are available beyond this page"
          }
        }
      },
      "NodeType": {
        "type": "string",
        "description": "Structural node type. Indicates what kind of data the node contains,\nnot how it will be used at runtime. Consumers interpret nodes according\nto their own needs via tags and annotations.\n",
        "enum": [
          "group",
          "mesh",
          "marker",
          "volume",
          "emitter",
          "reference",
          "custom"
        ]
      },
      "NonAuthorityHandlingMode": {
        "type": "string",
        "description": "How to handle publish attempts from non-authority sources",
        "enum": [
          "reject_and_alert",
          "accept_and_alert",
          "reject_silent"
        ],
        "default": "reject_and_alert"
      },
      "NoteEvent": {
        "description": "A musical note event with timing and pitch",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "pitch",
          "startTick",
          "durationTicks"
        ],
        "properties": {
          "pitch": {
            "$ref": "#/components/schemas/Pitch",
            "description": "Note pitch"
          },
          "startTick": {
            "type": "integer",
            "minimum": 0,
            "description": "Start position in ticks"
          },
          "durationTicks": {
            "type": "integer",
            "minimum": 1,
            "description": "Duration in ticks"
          },
          "velocity": {
            "type": "integer",
            "minimum": 1,
            "maximum": 127,
            "default": 80,
            "description": "Note velocity"
          }
        }
      },
      "OAuthCallbackRequest": {
        "description": "Request containing OAuth provider callback data to complete authentication",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Authorization code returned by the OAuth provider"
          },
          "state": {
            "type": "string",
            "nullable": true,
            "description": "State parameter for CSRF protection, must match the value sent in the init request"
          },
          "deviceInfo": {
            "$ref": "#/components/schemas/DeviceInfo",
            "nullable": true,
            "description": "Information about the client device (optional)"
          }
        }
      },
      "OwnerType": {
        "type": "string",
        "enum": [
          "ACCOUNT",
          "CHARACTER",
          "SESSION",
          "REALM"
        ],
        "description": "Type of entity that owns this save slot"
      },
      "PageContent": {
        "description": "Full content and metadata for a CMS-managed page",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "slug",
          "title",
          "content",
          "contentType",
          "published"
        ],
        "properties": {
          "slug": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "description": "URL-friendly identifier for the page"
          },
          "title": {
            "type": "string",
            "description": "Display title of the page"
          },
          "content": {
            "type": "string",
            "description": "HTML, Markdown, or custom template content"
          },
          "contentType": {
            "type": "string",
            "enum": [
              "html",
              "markdown",
              "blazor"
            ],
            "description": "Format of the page content"
          },
          "template": {
            "type": "string",
            "nullable": true,
            "description": "Template name for custom layouts"
          },
          "published": {
            "type": "boolean",
            "description": "Whether the page is publicly visible"
          },
          "publishedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Date and time when the page was published"
          },
          "lastModified": {
            "type": "string",
            "format": "date-time",
            "description": "Date and time of the last modification"
          },
          "author": {
            "type": "string",
            "nullable": true,
            "description": "Name or identifier of the page author"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "description": "Custom metadata for the page"
          },
          "seo": {
            "$ref": "#/components/schemas/SEOMetadata",
            "description": "Search engine optimization settings for the page"
          }
        }
      },
      "PageMetadata": {
        "description": "Summary metadata for a CMS page without full content",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "slug",
          "title",
          "published"
        ],
        "properties": {
          "slug": {
            "type": "string",
            "description": "URL-friendly identifier for the page"
          },
          "title": {
            "type": "string",
            "description": "Display title of the page"
          },
          "published": {
            "type": "boolean",
            "description": "Whether the page is publicly visible"
          },
          "publishedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Date and time when the page was published"
          },
          "lastModified": {
            "type": "string",
            "format": "date-time",
            "description": "Date and time of the last modification"
          },
          "author": {
            "type": "string",
            "nullable": true,
            "description": "Name or identifier of the page author"
          }
        }
      },
      "PartUploadInfo": {
        "description": "Upload information for a single part in a multipart upload",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "partNumber",
          "uploadUrl"
        ],
        "properties": {
          "partNumber": {
            "type": "integer",
            "description": "Part number (1-based)"
          },
          "uploadUrl": {
            "type": "string",
            "format": "uri",
            "description": "Pre-signed URL for uploading this part"
          },
          "minSize": {
            "type": "integer",
            "format": "int64",
            "description": "Minimum size for this part"
          },
          "maxSize": {
            "type": "integer",
            "format": "int64",
            "description": "Maximum size for this part"
          }
        }
      },
      "ParticipationListResponse": {
        "type": "object",
        "description": "Paginated list of participation records",
        "additionalProperties": false,
        "required": [
          "participations",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "participations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HistoricalParticipation"
            },
            "description": "List of participation records"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching records"
          },
          "page": {
            "type": "integer",
            "description": "Current page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether there are more results after this page"
          },
          "hasPreviousPage": {
            "type": "boolean",
            "description": "Whether there are results before this page"
          }
        }
      },
      "ParticipationRole": {
        "type": "string",
        "description": "How the character participated in the historical event",
        "enum": [
          "LEADER",
          "COMBATANT",
          "VICTIM",
          "WITNESS",
          "BENEFICIARY",
          "CONSPIRATOR",
          "HERO",
          "SURVIVOR"
        ]
      },
      "PartyAssetRequirementStatus": {
        "type": "object",
        "description": "Asset requirement status for a single party",
        "additionalProperties": false,
        "required": [
          "partyRole",
          "satisfied",
          "clauses"
        ],
        "properties": {
          "partyRole": {
            "type": "string",
            "description": "Party role (e.g., party_a, party_b)"
          },
          "satisfied": {
            "type": "boolean",
            "description": "Whether all party's requirements are satisfied"
          },
          "clauses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ClauseAssetStatus"
            },
            "description": "Status of each clause for this party"
          }
        }
      },
      "PartyConsentStatus": {
        "type": "object",
        "description": "Consent status for a single party",
        "required": [
          "partyId",
          "partyType",
          "consentGiven"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party ID"
          },
          "partyType": {
            "type": "string",
            "description": "Party type"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Party display name"
          },
          "consentGiven": {
            "type": "boolean",
            "description": "Whether consent was given"
          },
          "consentType": {
            "$ref": "#/components/schemas/EscrowConsentType",
            "description": "Type of consent given (if any)",
            "nullable": true
          },
          "consentedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When consent was given"
          }
        }
      },
      "PartyMemberInfo": {
        "type": "object",
        "description": "Information about a party member for matchmaking",
        "additionalProperties": false,
        "required": [
          "accountId",
          "webSocketSessionId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the party member"
          },
          "webSocketSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID for event delivery"
          },
          "skillRating": {
            "type": "number",
            "nullable": true,
            "description": "Pre-fetched skill rating (optional, will be looked up if not provided)"
          }
        }
      },
      "PartyRoleDefinition": {
        "type": "object",
        "description": "Definition of a party role in a contract template",
        "additionalProperties": false,
        "required": [
          "role",
          "minCount",
          "maxCount"
        ],
        "properties": {
          "role": {
            "type": "string",
            "maxLength": 64,
            "description": "Role identifier (employer, employee, buyer, seller, etc.)"
          },
          "minCount": {
            "type": "integer",
            "minimum": 0,
            "description": "Minimum entities required in this role"
          },
          "maxCount": {
            "type": "integer",
            "minimum": 1,
            "description": "Maximum entities allowed in this role"
          },
          "allowedEntityTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityType"
            },
            "nullable": true,
            "description": "Which entity types can fill this role (null for any)"
          }
        }
      },
      "PartySkillAggregation": {
        "type": "string",
        "description": "Method for aggregating party member skills",
        "enum": [
          "highest",
          "average",
          "weighted"
        ]
      },
      "PartyToken": {
        "type": "object",
        "description": "Token issued to a party for deposit or release operations",
        "required": [
          "partyId",
          "partyType",
          "token"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party ID"
          },
          "partyType": {
            "type": "string",
            "description": "Party type"
          },
          "token": {
            "type": "string",
            "description": "The token"
          }
        }
      },
      "PasswordResetConfirmRequest": {
        "description": "Request to confirm a password reset using the emailed token and new password",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "token",
          "newPassword"
        ],
        "properties": {
          "token": {
            "type": "string",
            "description": "Password reset token received via email"
          },
          "newPassword": {
            "type": "string",
            "format": "password",
            "minLength": 8,
            "description": "New password to set for the account"
          }
        }
      },
      "PasswordResetRequest": {
        "description": "Request to initiate a password reset by sending a reset link to the email",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "email"
        ],
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "description": "Email address associated with the account to reset"
          }
        }
      },
      "PastLifeReference": {
        "description": "Reference to a past incarnation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the previous incarnation"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "Display name of the past life"
          },
          "deathDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the past life ended"
          }
        }
      },
      "PaymentSchedule": {
        "type": "string",
        "description": "When payments occur",
        "enum": [
          "one_time",
          "recurring",
          "milestone_based"
        ]
      },
      "PendingConsentSummary": {
        "type": "object",
        "description": "Summary of pending consent",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "role"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type"
          },
          "role": {
            "type": "string",
            "description": "Role in contract"
          }
        }
      },
      "PerceptionData": {
        "type": "object",
        "additionalProperties": false,
        "description": "Data representing a perception event for an actor.\n\nSpatial context can be provided in two ways (hybrid approach):\n1. Typed: Use the optional spatialContext field for structured spatial data\n2. Schema-less: Use perceptionType=\"spatial\" with data containing spatial info\n\nThe typed approach is recommended when game server has structured spatial data.\nThe schema-less approach allows flexibility for game-specific spatial formats.\n",
        "required": [
          "perceptionType",
          "sourceId"
        ],
        "properties": {
          "perceptionType": {
            "type": "string",
            "description": "Perception type. Common values: visual, auditory, tactile, olfactory,\nproprioceptive, spatial. Use \"spatial\" for schema-less spatial data in 'data' field.\n"
          },
          "sourceId": {
            "type": "string",
            "description": "ID of the entity causing this perception"
          },
          "sourceType": {
            "type": "string",
            "nullable": true,
            "description": "Type of source (character, npc, object, environment)"
          },
          "data": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Perception-specific data. For perceptionType=\"spatial\", this can contain\ngame-specific spatial context in any format the game server defines.\n"
          },
          "urgency": {
            "type": "number",
            "format": "float",
            "minimum": 0,
            "maximum": 1,
            "default": 0.5,
            "description": "How urgent this perception is (0-1)"
          },
          "spatialContext": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SpatialContext"
              }
            ],
            "nullable": true,
            "description": "Optional typed spatial context from game server's local spatial state.\nProvides structured information about terrain, nearby objects, hazards, etc.\nAlternative to using perceptionType=\"spatial\" with schema-less data.\n"
          }
        }
      },
      "PersonalityResponse": {
        "type": "object",
        "description": "Complete personality profile for behavior system consumption",
        "additionalProperties": false,
        "required": [
          "characterId",
          "traits",
          "version",
          "createdAt"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character this personality belongs to"
          },
          "traits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TraitValue"
            },
            "description": "All trait axis values for this character"
          },
          "version": {
            "type": "integer",
            "description": "Personality version number (increments on each evolution)"
          },
          "archetypeHint": {
            "type": "string",
            "nullable": true,
            "description": "Optional archetype code for behavior optimization (e.g., \"guardian\",\n\"merchant\", \"scholar\", \"trickster\"). Allows behavior system to use\npre-compiled behavior variants for common personality patterns.\n"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this personality was first created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this personality was last modified"
          }
        }
      },
      "PersonalitySnapshot": {
        "description": "Snapshot of personality traits for enriched response",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "traits",
          "version"
        ],
        "properties": {
          "traits": {
            "type": "object",
            "additionalProperties": {
              "type": "number",
              "format": "float"
            },
            "description": "Trait values keyed by trait name (OPENNESS, AGREEABLENESS, etc.)"
          },
          "version": {
            "type": "integer",
            "description": "Personality version number (increments on evolution)"
          }
        }
      },
      "PerspectiveResponse": {
        "type": "object",
        "description": "Response containing a perspective",
        "additionalProperties": false,
        "required": [
          "perspective"
        ],
        "properties": {
          "perspective": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EncounterPerspectiveModel"
              }
            ],
            "description": "The character's perspective on the encounter"
          }
        }
      },
      "PinVersionRequest": {
        "type": "object",
        "description": "Request to pin a save version as a checkpoint to prevent cleanup",
        "required": [
          "ownerId",
          "ownerType",
          "slotName",
          "versionNumber"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Version to pin"
          },
          "checkpointName": {
            "type": "string",
            "maxLength": 64,
            "description": "Optional checkpoint name for easy retrieval"
          }
        }
      },
      "Pitch": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Pitch.Pitch",
        "description": "A specific pitch with pitch class and octave",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "pitchClass",
          "octave"
        ],
        "properties": {
          "pitchClass": {
            "$ref": "#/components/schemas/PitchClass",
            "description": "Pitch class (note name)"
          },
          "octave": {
            "type": "integer",
            "minimum": 0,
            "maximum": 9,
            "description": "Octave number (middle C = C4)"
          },
          "midiNumber": {
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "description": "MIDI note number (computed if not provided)"
          }
        }
      },
      "PitchClass": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Pitch.PitchClass",
        "description": "A pitch class (note name without octave)",
        "type": "string",
        "enum": [
          "C",
          "Cs",
          "D",
          "Ds",
          "E",
          "F",
          "Fs",
          "G",
          "Gs",
          "A",
          "As",
          "B"
        ]
      },
      "PitchRange": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Pitch.PitchRange",
        "description": "A pitch range from low to high",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "low",
          "high"
        ],
        "properties": {
          "low": {
            "$ref": "#/components/schemas/Pitch",
            "description": "Lowest pitch (inclusive)"
          },
          "high": {
            "$ref": "#/components/schemas/Pitch",
            "description": "Highest pitch (inclusive)"
          }
        }
      },
      "PlannedActionResponse": {
        "description": "Single action within a GOAP plan with position and cost information",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "actionId",
          "index",
          "cost"
        ],
        "properties": {
          "actionId": {
            "type": "string",
            "description": "ID of the action (flow name)"
          },
          "index": {
            "type": "integer",
            "description": "Position in the plan sequence"
          },
          "cost": {
            "type": "number",
            "format": "float",
            "description": "Cost of this action"
          }
        }
      },
      "Platform": {
        "type": "string",
        "description": "External platform for achievement sync",
        "enum": [
          "steam",
          "xbox",
          "playstation",
          "internal"
        ]
      },
      "Position3D": {
        "type": "object",
        "additionalProperties": false,
        "description": "3D position in world coordinates",
        "required": [
          "x",
          "y",
          "z"
        ],
        "properties": {
          "x": {
            "type": "number",
            "format": "float",
            "description": "X coordinate"
          },
          "y": {
            "type": "number",
            "format": "float",
            "description": "Y coordinate (typically vertical)"
          },
          "z": {
            "type": "number",
            "format": "float",
            "description": "Z coordinate"
          }
        }
      },
      "PreboundApi": {
        "type": "object",
        "description": "Pre-configured API call to execute on contract events",
        "additionalProperties": false,
        "required": [
          "serviceName",
          "endpoint",
          "payloadTemplate"
        ],
        "properties": {
          "serviceName": {
            "type": "string",
            "description": "Target service name"
          },
          "endpoint": {
            "type": "string",
            "description": "Target endpoint path"
          },
          "payloadTemplate": {
            "type": "string",
            "description": "JSON payload with variable placeholders"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description"
          },
          "executionMode": {
            "type": "string",
            "enum": [
              "sync",
              "async",
              "fire_and_forget"
            ],
            "default": "sync",
            "description": "How to execute the API call"
          },
          "responseValidation": {
            "$ref": "#/components/schemas/ResponseValidation",
            "nullable": true,
            "description": "Optional validation rules for the response"
          }
        }
      },
      "PreferredRange": {
        "type": "string",
        "description": "Preferred engagement distance. Influences positioning and\nability selection in combat.\n",
        "enum": [
          "MELEE",
          "CLOSE",
          "MEDIUM",
          "RANGED"
        ]
      },
      "ProcessingStatus": {
        "type": "string",
        "enum": [
          "pending",
          "processing",
          "complete",
          "failed"
        ],
        "description": "Asset processing pipeline status"
      },
      "ProgressionAnalysis": {
        "description": "Analysis of a chord progression",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "romanNumerals": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Roman numeral analysis"
          },
          "cadences": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CadenceInfo"
            },
            "nullable": true,
            "description": "Detected cadences"
          },
          "functionalAnalysis": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "tonic",
                "subdominant",
                "dominant",
                "predominant"
              ]
            },
            "nullable": true,
            "description": "Functional analysis per chord"
          }
        }
      },
      "PromoteVersionRequest": {
        "type": "object",
        "description": "Request to promote an older save version to be the latest",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName",
          "versionNumber"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Name of the slot containing the version to promote"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Old version to promote to latest"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Display name for promoted version"
          }
        }
      },
      "ProposeContractInstanceRequest": {
        "type": "object",
        "description": "Request to propose a contract to parties",
        "additionalProperties": false,
        "required": [
          "contractId"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance to propose"
          }
        }
      },
      "Provider": {
        "type": "string",
        "enum": [
          "google",
          "discord",
          "twitch"
        ],
        "description": "OAuth provider type"
      },
      "ProviderInfo": {
        "type": "object",
        "description": "Information about an available authentication provider",
        "additionalProperties": false,
        "required": [
          "name",
          "displayName",
          "authType"
        ],
        "properties": {
          "name": {
            "type": "string",
            "example": "discord",
            "description": "Internal identifier for the provider (matches Provider enum for OAuth)"
          },
          "displayName": {
            "type": "string",
            "example": "Discord",
            "description": "Human-readable name for the provider"
          },
          "authType": {
            "type": "string",
            "enum": [
              "oauth",
              "ticket"
            ],
            "description": "Authentication mechanism (oauth = browser redirect, ticket = game client token)"
          },
          "authUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "example": "https://discord.com/oauth2/authorize",
            "description": "URL to initiate OAuth authentication (null for ticket-based auth like Steam)"
          }
        }
      },
      "ProvidersResponse": {
        "type": "object",
        "description": "List of available authentication providers",
        "additionalProperties": false,
        "required": [
          "providers"
        ],
        "properties": {
          "providers": {
            "type": "array",
            "description": "Available authentication providers",
            "items": {
              "$ref": "#/components/schemas/ProviderInfo"
            }
          }
        }
      },
      "QuantityModel": {
        "type": "string",
        "description": "How quantities are tracked for this item type",
        "enum": [
          "discrete",
          "continuous",
          "unique"
        ]
      },
      "Quaternion": {
        "type": "object",
        "description": "Rotation represented as a quaternion",
        "required": [
          "x",
          "y",
          "z",
          "w"
        ],
        "properties": {
          "x": {
            "type": "number",
            "format": "double",
            "description": "X component"
          },
          "y": {
            "type": "number",
            "format": "double",
            "description": "Y component"
          },
          "z": {
            "type": "number",
            "format": "double",
            "description": "Z component"
          },
          "w": {
            "type": "number",
            "format": "double",
            "description": "W component (scalar)"
          }
        }
      },
      "QueryActiveContractsRequest": {
        "type": "object",
        "description": "Request to query active contracts",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity to query"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type"
          },
          "templateCodes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by template codes"
          }
        }
      },
      "QueryActiveContractsResponse": {
        "type": "object",
        "description": "Active contracts for entity",
        "additionalProperties": false,
        "required": [
          "contracts"
        ],
        "properties": {
          "contracts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContractSummary"
            },
            "description": "Active contracts"
          }
        }
      },
      "QueryBetweenRequest": {
        "type": "object",
        "description": "Request to query encounters between two characters",
        "additionalProperties": false,
        "required": [
          "characterIdA",
          "characterIdB"
        ],
        "properties": {
          "characterIdA": {
            "type": "string",
            "format": "uuid",
            "description": "First character"
          },
          "characterIdB": {
            "type": "string",
            "format": "uuid",
            "description": "Second character"
          },
          "encounterTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Filter by encounter type"
          },
          "minimumMemoryStrength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Filter by minimum memory strength (for either character)"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Results per page"
          }
        }
      },
      "QueryBoundsRequest": {
        "type": "object",
        "description": "Query map data within bounds",
        "required": [
          "regionId",
          "bounds"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region to query"
          },
          "bounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Bounding box to query"
          },
          "kinds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapKind"
            },
            "description": "Kinds to query (default all)",
            "nullable": true
          },
          "maxObjects": {
            "type": "integer",
            "default": 500,
            "maximum": 5000,
            "description": "Maximum objects to return"
          }
        }
      },
      "QueryBoundsResponse": {
        "type": "object",
        "description": "Bounds query results",
        "properties": {
          "objects": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapObject"
            },
            "description": "Objects within bounds"
          },
          "bounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Queried bounds"
          },
          "truncated": {
            "type": "boolean",
            "description": "Whether results were truncated"
          }
        }
      },
      "QueryBundlesByAssetRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to find bundles containing a specific asset",
        "required": [
          "assetId",
          "realm"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Platform asset ID to search for"
          },
          "realm": {
            "$ref": "#/components/schemas/Realm",
            "description": "Game realm to search within"
          },
          "bundleType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BundleType"
              }
            ],
            "nullable": true,
            "description": "Filter by bundle type (optional, null for all types)"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Maximum results to return"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          }
        }
      },
      "QueryBundlesByAssetResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Bundles containing the requested asset",
        "required": [
          "assetId",
          "bundles",
          "total",
          "limit",
          "offset"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "The queried asset ID"
          },
          "bundles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BundleSummary"
            },
            "description": "Bundles containing this asset"
          },
          "total": {
            "type": "integer",
            "description": "Total matching bundles"
          },
          "limit": {
            "type": "integer",
            "description": "Page size"
          },
          "offset": {
            "type": "integer",
            "description": "Page offset"
          }
        }
      },
      "QueryBundlesRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Advanced bundle query with filters",
        "properties": {
          "tags": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by exact tag key-value matches"
          },
          "tagExists": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter bundles that have these tag keys (any value)"
          },
          "tagNotExists": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter bundles that do NOT have these tag keys"
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BundleLifecycle"
              }
            ],
            "nullable": true,
            "description": "Filter by lifecycle status (null for active only by default)"
          },
          "createdAfter": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter bundles created after this time"
          },
          "createdBefore": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter bundles created before this time"
          },
          "nameContains": {
            "type": "string",
            "nullable": true,
            "description": "Filter bundles with name containing this string (case-insensitive)"
          },
          "owner": {
            "type": "string",
            "nullable": true,
            "description": "Filter by bundle owner account ID"
          },
          "realm": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Realm"
              }
            ],
            "nullable": true,
            "description": "Filter by realm"
          },
          "bundleType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BundleType"
              }
            ],
            "nullable": true,
            "description": "Filter by bundle type (source or metabundle)"
          },
          "sortField": {
            "type": "string",
            "enum": [
              "created_at",
              "updated_at",
              "name",
              "size"
            ],
            "nullable": true,
            "description": "Field to sort by (default created_at)"
          },
          "sortOrder": {
            "type": "string",
            "enum": [
              "asc",
              "desc"
            ],
            "nullable": true,
            "description": "Sort order (default desc)"
          },
          "limit": {
            "type": "integer",
            "default": 100,
            "description": "Maximum results to return (max 1000)"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          },
          "includeDeleted": {
            "type": "boolean",
            "default": false,
            "description": "Include soft-deleted bundles in results"
          }
        }
      },
      "QueryBundlesResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Bundle query results",
        "required": [
          "bundles",
          "totalCount",
          "limit",
          "offset"
        ],
        "properties": {
          "bundles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BundleInfo"
            },
            "description": "Matching bundles"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching bundles (for pagination)"
          },
          "limit": {
            "type": "integer",
            "description": "Page size used"
          },
          "offset": {
            "type": "integer",
            "description": "Page offset used"
          }
        }
      },
      "QueryByCharacterRequest": {
        "type": "object",
        "description": "Request to query encounters by character",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to query encounters for"
          },
          "encounterTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Filter by encounter type"
          },
          "outcome": {
            "$ref": "#/components/schemas/EncounterOutcome",
            "nullable": true,
            "description": "Filter by outcome"
          },
          "minimumMemoryStrength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Filter by minimum memory strength"
          },
          "fromTimestamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter encounters after this time"
          },
          "toTimestamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter encounters before this time"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Results per page"
          }
        }
      },
      "QueryByLocationRequest": {
        "type": "object",
        "description": "Request to query recent encounters at a location",
        "additionalProperties": false,
        "required": [
          "locationId"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "Location to query"
          },
          "encounterTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Filter by encounter type"
          },
          "fromTimestamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter encounters after this time"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Results per page"
          }
        }
      },
      "QueryContractInstancesRequest": {
        "type": "object",
        "description": "Request to query contract instances",
        "additionalProperties": false,
        "properties": {
          "partyEntityId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by party entity ID"
          },
          "partyEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "nullable": true,
            "description": "Filter by party entity type"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by template"
          },
          "statuses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContractStatus"
            },
            "nullable": true,
            "description": "Filter by statuses"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Results per page"
          }
        }
      },
      "QueryContractInstancesResponse": {
        "type": "object",
        "description": "Paginated list of contract instances",
        "additionalProperties": false,
        "required": [
          "contracts",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "contracts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContractInstanceResponse"
            },
            "description": "List of contracts"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total matching contracts"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Results per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether more results exist"
          }
        }
      },
      "QueryDocumentationRequest": {
        "description": "Request to search documentation using natural language queries",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "query"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to search within"
          },
          "query": {
            "type": "string",
            "minLength": 3,
            "maxLength": 500,
            "description": "Natural language query to search for"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Optional session ID for conversational context"
          },
          "category": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "Filter results to a specific category"
          },
          "maxResults": {
            "type": "integer",
            "default": 5,
            "minimum": 1,
            "maximum": 20,
            "description": "Maximum number of results to return"
          },
          "includeContent": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include full document content in results"
          },
          "maxSummaryLength": {
            "type": "integer",
            "default": 300,
            "minimum": 50,
            "maximum": 500,
            "description": "Maximum length of summaries in characters"
          },
          "minRelevanceScore": {
            "type": "number",
            "format": "float",
            "default": 0.3,
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "Minimum relevance score threshold for results"
          }
        }
      },
      "QueryDocumentationResponse": {
        "description": "Response containing search results and voice-friendly summaries",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "query",
          "results"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "description": "The namespace that was searched"
          },
          "query": {
            "type": "string",
            "description": "The original query string"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentResult"
            },
            "description": "List of matching documents"
          },
          "totalResults": {
            "type": "integer",
            "description": "Total number of matching documents"
          },
          "voiceSummary": {
            "type": "string",
            "description": "Concise spoken summary for voice AI"
          },
          "suggestedFollowups": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Suggested follow-up queries"
          },
          "noResultsMessage": {
            "type": "string",
            "description": "User-friendly message when no results found"
          }
        }
      },
      "QueryItemsRequest": {
        "type": "object",
        "description": "Request to query items",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner to search"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Owner type"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by template"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Filter by category"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by tags"
          },
          "containerType": {
            "type": "string",
            "nullable": true,
            "description": "Filter by container type"
          },
          "excludeEquipmentSlots": {
            "type": "boolean",
            "default": false,
            "description": "Exclude equipment slots"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "maximum": 200,
            "description": "Max results"
          }
        }
      },
      "QueryItemsResponse": {
        "type": "object",
        "description": "Query results",
        "additionalProperties": false,
        "required": [
          "items",
          "totalCount"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryResultItem"
            },
            "description": "Found items"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total matching"
          }
        }
      },
      "QueryObjectsByTypeRequest": {
        "type": "object",
        "description": "Query objects by type",
        "required": [
          "regionId",
          "objectType"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region to query"
          },
          "objectType": {
            "type": "string",
            "description": "Object type to filter by"
          },
          "bounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Optional bounds filter",
            "nullable": true
          },
          "maxObjects": {
            "type": "integer",
            "default": 500,
            "maximum": 5000,
            "description": "Maximum objects to return"
          }
        }
      },
      "QueryObjectsByTypeResponse": {
        "type": "object",
        "description": "Object type query results",
        "properties": {
          "objects": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapObject"
            },
            "description": "Matching objects"
          },
          "objectType": {
            "type": "string",
            "description": "Queried object type"
          },
          "truncated": {
            "type": "boolean",
            "description": "Whether results were truncated"
          }
        }
      },
      "QueryPointRequest": {
        "type": "object",
        "description": "Query map data at a point",
        "required": [
          "regionId",
          "position"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region to query"
          },
          "position": {
            "$ref": "#/components/schemas/Position3D",
            "description": "Point to query at"
          },
          "kinds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapKind"
            },
            "description": "Kinds to query (default all)",
            "nullable": true
          },
          "radius": {
            "type": "number",
            "description": "Include objects within this radius",
            "nullable": true
          }
        }
      },
      "QueryPointResponse": {
        "type": "object",
        "description": "Point query results",
        "properties": {
          "objects": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapObject"
            },
            "description": "Objects at/near the point"
          },
          "position": {
            "$ref": "#/components/schemas/Position3D",
            "description": "Queried position"
          },
          "radius": {
            "type": "number",
            "description": "Applied radius filter",
            "nullable": true
          }
        }
      },
      "QueryResultItem": {
        "type": "object",
        "description": "Item in query results",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "templateId",
          "containerId",
          "quantity"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance ID"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template ID"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container ID"
          },
          "containerType": {
            "type": "string",
            "description": "Container type"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "description": "Quantity"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Slot position"
          }
        }
      },
      "QuerySavesRequest": {
        "type": "object",
        "description": "Advanced query for saves across multiple owners with filtering and sorting",
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by owner ID"
          },
          "ownerType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/OwnerType"
              }
            ],
            "nullable": true,
            "description": "Filter by owner type"
          },
          "category": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SaveCategory"
              }
            ],
            "nullable": true,
            "description": "Filter by save category"
          },
          "createdAfter": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter by creation date"
          },
          "createdBefore": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter by creation date"
          },
          "pinnedOnly": {
            "type": "boolean",
            "nullable": true,
            "description": "Only return pinned versions"
          },
          "schemaVersion": {
            "type": "string",
            "nullable": true,
            "description": "Filter by schema version"
          },
          "metadataFilter": {
            "type": "object",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            },
            "description": "Filter by metadata key-value pairs"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          },
          "limit": {
            "type": "integer",
            "default": 20,
            "maximum": 100,
            "description": "Maximum results"
          },
          "sortBy": {
            "type": "string",
            "enum": [
              "created_at",
              "size",
              "version_number"
            ],
            "default": "created_at",
            "description": "Sort field"
          },
          "sortOrder": {
            "type": "string",
            "enum": [
              "asc",
              "desc"
            ],
            "default": "desc",
            "description": "Sort order"
          }
        }
      },
      "QuerySavesResponse": {
        "type": "object",
        "description": "Paginated results from a save query operation",
        "required": [
          "results",
          "totalCount"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryResultItem"
            },
            "description": "Query results"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total matching results"
          }
        }
      },
      "QueueResponse": {
        "type": "object",
        "description": "Full configuration details of a matchmaking queue",
        "additionalProperties": false,
        "required": [
          "queueId",
          "gameId",
          "displayName",
          "enabled",
          "minCount",
          "maxCount",
          "countMultiple",
          "intervalSeconds",
          "maxIntervals",
          "createdAt"
        ],
        "properties": {
          "queueId": {
            "type": "string",
            "description": "Unique identifier for the queue"
          },
          "gameId": {
            "type": "string",
            "description": "Game this queue is for"
          },
          "sessionGameType": {
            "$ref": "#/components/schemas/SessionGameType",
            "description": "Game type for created sessions (maps to game-session service)"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable queue name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Detailed description of the queue"
          },
          "enabled": {
            "type": "boolean",
            "description": "Whether the queue is currently accepting tickets"
          },
          "minCount": {
            "type": "integer",
            "minimum": 2,
            "description": "Minimum players required for a match"
          },
          "maxCount": {
            "type": "integer",
            "maximum": 200,
            "description": "Maximum players in a match"
          },
          "countMultiple": {
            "type": "integer",
            "minimum": 1,
            "description": "Player count must be divisible by this (e.g., 2 for pairs)"
          },
          "intervalSeconds": {
            "type": "integer",
            "minimum": 1,
            "description": "Seconds between match processing intervals"
          },
          "maxIntervals": {
            "type": "integer",
            "minimum": 1,
            "description": "Maximum intervals before relaxing to minCount"
          },
          "skillExpansion": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SkillExpansionStep"
            },
            "nullable": true,
            "description": "Skill window expansion steps"
          },
          "partySkillAggregation": {
            "$ref": "#/components/schemas/PartySkillAggregation",
            "description": "How to calculate party skill rating"
          },
          "partySkillWeights": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "nullable": true,
            "description": "Weights for weighted party skill aggregation"
          },
          "partyMaxSize": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum party size for this queue"
          },
          "allowConcurrent": {
            "type": "boolean",
            "default": true,
            "description": "Whether players can be in multiple queues"
          },
          "exclusiveGroup": {
            "type": "string",
            "nullable": true,
            "description": "Exclusive group name (player can only be in one queue of the group)"
          },
          "useSkillRating": {
            "type": "boolean",
            "default": true,
            "description": "Whether to use lib-analytics skill rating for matching"
          },
          "ratingCategory": {
            "type": "string",
            "nullable": true,
            "description": "lib-analytics rating category to use"
          },
          "startWhenMinimumReached": {
            "type": "boolean",
            "default": false,
            "description": "Start match with minCount after maxIntervals (for large lobbies)"
          },
          "requiresRegistration": {
            "type": "boolean",
            "default": false,
            "description": "Whether players must be registered for a tournament"
          },
          "tournamentIdRequired": {
            "type": "boolean",
            "default": false,
            "description": "Whether a tournament ID is required to join"
          },
          "matchAcceptTimeoutSeconds": {
            "type": "integer",
            "default": 30,
            "description": "Seconds players have to accept/decline a formed match"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the queue was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the queue was last updated"
          }
        }
      },
      "QueueStats": {
        "type": "object",
        "description": "Statistics for a single matchmaking queue",
        "additionalProperties": false,
        "required": [
          "queueId",
          "currentTickets",
          "matchesFormedLastHour",
          "averageWaitSeconds"
        ],
        "properties": {
          "queueId": {
            "type": "string",
            "description": "Queue identifier"
          },
          "currentTickets": {
            "type": "integer",
            "description": "Number of active tickets"
          },
          "matchesFormedLastHour": {
            "type": "integer",
            "description": "Matches formed in the last hour"
          },
          "averageWaitSeconds": {
            "type": "number",
            "description": "Average wait time in seconds"
          },
          "medianWaitSeconds": {
            "type": "number",
            "nullable": true,
            "description": "Median wait time in seconds"
          },
          "timeoutRatePercent": {
            "type": "number",
            "nullable": true,
            "description": "Percentage of tickets that timed out"
          },
          "cancelRatePercent": {
            "type": "number",
            "nullable": true,
            "description": "Percentage of tickets cancelled by user"
          }
        }
      },
      "QueueSummary": {
        "type": "object",
        "description": "Summary information about a matchmaking queue",
        "additionalProperties": false,
        "required": [
          "queueId",
          "gameId",
          "displayName",
          "enabled",
          "minCount",
          "maxCount"
        ],
        "properties": {
          "queueId": {
            "type": "string",
            "description": "Unique identifier for the queue"
          },
          "gameId": {
            "type": "string",
            "description": "Game this queue is for"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable queue name"
          },
          "enabled": {
            "type": "boolean",
            "description": "Whether the queue is currently accepting tickets"
          },
          "minCount": {
            "type": "integer",
            "description": "Minimum players required for a match"
          },
          "maxCount": {
            "type": "integer",
            "description": "Maximum players in a match"
          },
          "currentTickets": {
            "type": "integer",
            "nullable": true,
            "description": "Current number of tickets in queue (if available)"
          },
          "averageWaitSeconds": {
            "type": "number",
            "nullable": true,
            "description": "Average wait time in seconds (if available)"
          }
        }
      },
      "ReaffirmRequest": {
        "type": "object",
        "description": "Request to re-affirm after validation failure",
        "required": [
          "escrowId",
          "partyId",
          "partyType",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party reaffirming"
          },
          "partyType": {
            "type": "string",
            "description": "Party type"
          },
          "releaseToken": {
            "type": "string",
            "nullable": true,
            "description": "Release token"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "ReaffirmResponse": {
        "type": "object",
        "description": "Response from party re-affirming after validation failure",
        "required": [
          "escrow",
          "allReaffirmed"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Reaffirmed escrow agreement"
          },
          "allReaffirmed": {
            "type": "boolean",
            "description": "Whether all parties have reaffirmed"
          }
        }
      },
      "Realm": {
        "type": "string",
        "enum": [
          "omega",
          "arcadia",
          "fantasia",
          "shared"
        ],
        "description": "Game realm the asset belongs to"
      },
      "RealmEventCategory": {
        "type": "string",
        "description": "Categories of historical events that realms can participate in",
        "enum": [
          "FOUNDING",
          "WAR",
          "TREATY",
          "CATACLYSM",
          "DISCOVERY",
          "MIGRATION",
          "CULTURAL_SHIFT",
          "ECONOMIC_CHANGE",
          "POLITICAL_UPHEAVAL"
        ]
      },
      "RealmEventRole": {
        "type": "string",
        "description": "How the realm participated in the historical event",
        "enum": [
          "ORIGIN",
          "AGGRESSOR",
          "DEFENDER",
          "MEDIATOR",
          "AFFECTED",
          "BENEFICIARY",
          "INSTIGATOR",
          "NEUTRAL_PARTY"
        ]
      },
      "RealmExistsRequest": {
        "description": "Request to check if a realm exists and is available for use",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the realm to validate"
          }
        }
      },
      "RealmExistsResponse": {
        "description": "Response indicating whether a realm exists and its active status",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "exists",
          "isActive"
        ],
        "properties": {
          "exists": {
            "type": "boolean",
            "description": "Whether the realm exists"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether the realm is active (false if deprecated or not found)"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "The realm ID if found"
          }
        }
      },
      "RealmHistoricalParticipation": {
        "type": "object",
        "description": "Record of a realm's participation in a historical event",
        "additionalProperties": false,
        "required": [
          "participationId",
          "realmId",
          "eventId",
          "eventName",
          "eventCategory",
          "role",
          "eventDate",
          "createdAt"
        ],
        "properties": {
          "participationId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique ID for this participation record"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the realm that participated"
          },
          "eventId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the historical event"
          },
          "eventName": {
            "type": "string",
            "description": "Name of the event (for display and summarization)"
          },
          "eventCategory": {
            "$ref": "#/components/schemas/RealmEventCategory",
            "description": "Category of the historical event"
          },
          "role": {
            "$ref": "#/components/schemas/RealmEventRole",
            "description": "How the realm participated"
          },
          "eventDate": {
            "type": "string",
            "format": "date-time",
            "description": "In-game date when the event occurred"
          },
          "impact": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.5,
            "description": "How significant this event was for the realm (0.0 to 1.0).\nAffects behavior system weighting.\n"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Event-specific details for behavior decisions"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this record was created"
          }
        }
      },
      "RealmListResponse": {
        "description": "Paginated list of realms with metadata for navigation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realms",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "realms": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RealmResponse"
            },
            "description": "List of realms matching the query criteria"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of realms matching the query (before pagination)"
          },
          "page": {
            "type": "integer",
            "description": "Current page number (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of realms per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether there are more realms available on the next page"
          },
          "hasPreviousPage": {
            "type": "boolean",
            "description": "Whether there are realms available on the previous page"
          }
        }
      },
      "RealmLoreElement": {
        "type": "object",
        "description": "A machine-readable lore element for behavior system consumption",
        "additionalProperties": false,
        "required": [
          "elementType",
          "key",
          "value"
        ],
        "properties": {
          "elementType": {
            "$ref": "#/components/schemas/RealmLoreElementType",
            "description": "Category of this lore element"
          },
          "key": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Machine-readable key (e.g., \"founding_year\", \"primary_export\", \"capital_city\").\nUsed by behavior system to query specific aspects.\n"
          },
          "value": {
            "type": "string",
            "minLength": 1,
            "maxLength": 500,
            "description": "Machine-readable value (e.g., \"year_of_the_dragon\", \"iron_ore\", \"stormgate\").\nReferenced in behavior rules.\n"
          },
          "strength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.5,
            "description": "How strongly this element affects behavior (0.0 to 1.0).\nHigher strength = greater influence on decisions.\n"
          },
          "relatedEntityId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional related entity (location, organization, character)"
          },
          "relatedEntityType": {
            "type": "string",
            "nullable": true,
            "description": "Type of the related entity (if any)"
          }
        }
      },
      "RealmLoreElementType": {
        "type": "string",
        "description": "Types of lore elements. Each type represents a different aspect\nof the realm's background that influences behavior.\n",
        "enum": [
          "ORIGIN_MYTH",
          "CULTURAL_PRACTICE",
          "POLITICAL_SYSTEM",
          "ECONOMIC_BASE",
          "RELIGIOUS_TRADITION",
          "GEOGRAPHIC_FEATURE",
          "FAMOUS_FIGURE",
          "TECHNOLOGICAL_LEVEL"
        ]
      },
      "RealmLoreResponse": {
        "type": "object",
        "description": "Complete lore data for a realm",
        "additionalProperties": false,
        "required": [
          "realmId",
          "elements"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the realm this lore belongs to"
          },
          "elements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RealmLoreElement"
            },
            "description": "All lore elements for this realm"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this lore was first created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this lore was last modified"
          }
        }
      },
      "RealmParticipationListResponse": {
        "type": "object",
        "description": "Paginated list of participation records",
        "additionalProperties": false,
        "required": [
          "participations",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "participations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RealmHistoricalParticipation"
            },
            "description": "List of participation records"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching records"
          },
          "page": {
            "type": "integer",
            "description": "Current page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether there are more results after this page"
          },
          "hasPreviousPage": {
            "type": "boolean",
            "description": "Whether there are results before this page"
          }
        }
      },
      "RealmResponse": {
        "description": "Complete realm information returned from API operations",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId",
          "code",
          "name",
          "isActive",
          "isDeprecated",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the realm"
          },
          "code": {
            "type": "string",
            "description": "Unique code for the realm (e.g., \"OMEGA\", \"ARCADIA\")"
          },
          "name": {
            "type": "string",
            "description": "Display name for the realm"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Detailed description of the realm"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Category for grouping realms"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether the realm is currently active for gameplay"
          },
          "isDeprecated": {
            "type": "boolean",
            "description": "Whether this realm is deprecated and cannot be used for new entities"
          },
          "deprecatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Timestamp when this realm was deprecated"
          },
          "deprecationReason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for deprecation"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional custom metadata for the realm"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the realm was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the realm was last updated"
          }
        }
      },
      "RealmStatus": {
        "description": "Status and population information for a single game realm",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId",
          "name",
          "status",
          "population"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the game realm"
          },
          "name": {
            "type": "string",
            "description": "Display name of the game realm"
          },
          "status": {
            "type": "string",
            "enum": [
              "online",
              "offline",
              "maintenance",
              "full"
            ],
            "description": "Current operational status of the realm"
          },
          "population": {
            "type": "string",
            "enum": [
              "low",
              "medium",
              "high",
              "full"
            ],
            "description": "Current player population level"
          },
          "playerCount": {
            "type": "integer",
            "nullable": true,
            "description": "Current number of players online"
          },
          "ping": {
            "type": "integer",
            "description": "Latency in milliseconds",
            "nullable": true
          }
        }
      },
      "ReferenceInfo": {
        "type": "object",
        "description": "Information about a reference",
        "required": [
          "sceneId",
          "sceneName",
          "nodeId",
          "nodeRefId"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene containing the reference"
          },
          "sceneName": {
            "type": "string",
            "description": "Name of the referencing scene"
          },
          "nodeId": {
            "type": "string",
            "format": "uuid",
            "description": "Node containing the reference"
          },
          "nodeRefId": {
            "type": "string",
            "description": "refId of the referencing node"
          },
          "nodeName": {
            "type": "string",
            "description": "Name of the referencing node"
          }
        }
      },
      "RefreshRequest": {
        "description": "Request to obtain a new access token using a valid refresh token",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "refreshToken"
        ],
        "properties": {
          "refreshToken": {
            "type": "string",
            "description": "Refresh token issued during authentication to obtain a new access token"
          }
        }
      },
      "RefundRequest": {
        "type": "object",
        "description": "Request to trigger escrow refund to depositors",
        "required": [
          "escrowId",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "initiatorServiceId": {
            "type": "string",
            "nullable": true,
            "description": "For initiator_trusted mode"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Reason for refund"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "RefundResponse": {
        "type": "object",
        "description": "Response from refunding escrow assets to depositors",
        "required": [
          "escrow",
          "refunds"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Refunded escrow agreement"
          },
          "refunds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RefundResult"
            },
            "description": "Refund results per depositor"
          }
        }
      },
      "RefundResult": {
        "type": "object",
        "description": "Result of refunding assets to a single depositor",
        "required": [
          "depositorPartyId",
          "success"
        ],
        "properties": {
          "depositorPartyId": {
            "type": "string",
            "format": "uuid",
            "description": "Depositor party ID"
          },
          "assets": {
            "$ref": "#/components/schemas/EscrowAssetBundle",
            "description": "Assets refunded (null if failed)",
            "nullable": true
          },
          "success": {
            "type": "boolean",
            "description": "Whether refund succeeded"
          },
          "error": {
            "type": "string",
            "nullable": true,
            "description": "Error message if failed"
          }
        }
      },
      "RegisterRequest": {
        "type": "object",
        "description": "Request to register a new user account",
        "additionalProperties": false,
        "required": [
          "username",
          "password",
          "email"
        ],
        "properties": {
          "username": {
            "type": "string",
            "description": "Unique username for the account",
            "minLength": 3,
            "maxLength": 32,
            "pattern": "^[a-zA-Z0-9_]+$",
            "example": "gameuser123"
          },
          "password": {
            "type": "string",
            "description": "Password for the account (will be hashed)",
            "minLength": 8,
            "format": "password",
            "example": "SecurePassword123!"
          },
          "email": {
            "type": "string",
            "format": "email",
            "description": "Email address for account recovery and notifications",
            "example": "user@example.com"
          }
        }
      },
      "RegisterResponse": {
        "type": "object",
        "description": "Response from successful user registration",
        "additionalProperties": false,
        "required": [
          "accountId",
          "accessToken",
          "connectUrl"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the newly created account"
          },
          "accessToken": {
            "type": "string",
            "description": "JWT access token for immediate authentication",
            "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJnYW1ldXNlcjEyMyIsImlhdCI6MTY0MDk5NTIwMCwiZXhwIjoxNjQwOTk4ODAwfQ.signature"
          },
          "refreshToken": {
            "type": "string",
            "description": "Refresh token for obtaining new access tokens",
            "nullable": true,
            "example": "refresh_token_abc123xyz789"
          },
          "connectUrl": {
            "type": "string",
            "format": "uri",
            "description": "WebSocket endpoint for Connect service"
          }
        }
      },
      "RegisterSchemaRequest": {
        "type": "object",
        "description": "Request to register a new save data schema with optional migration rules",
        "required": [
          "namespace",
          "schemaVersion",
          "schema"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Schema namespace (e.g., game identifier)"
          },
          "schemaVersion": {
            "type": "string",
            "description": "Schema version identifier"
          },
          "schema": {
            "type": "object",
            "description": "JSON Schema definition for validation"
          },
          "previousVersion": {
            "type": "string",
            "nullable": true,
            "description": "Previous version this migrates from"
          },
          "migrationPatch": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/JsonPatchOperation"
            },
            "description": "JSON Patch (RFC 6902) operations to migrate from previousVersion.\nUses JsonPatch.Net library (MIT licensed).\n"
          }
        }
      },
      "RelatedDepth": {
        "type": "string",
        "enum": [
          "none",
          "direct",
          "extended"
        ],
        "default": "direct",
        "description": "How deep to traverse related document links:\n- none: No related documents included\n- direct: Only directly linked documents (depth 1)\n- extended: Related documents + their related documents (depth 2)\n"
      },
      "RelationshipListResponse": {
        "description": "Paginated list of relationships with metadata for navigation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "relationships",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "relationships": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RelationshipResponse"
            },
            "description": "List of relationships matching the query"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of relationships matching the query"
          },
          "page": {
            "type": "integer",
            "description": "Current page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether there are more results on the next page"
          },
          "hasPreviousPage": {
            "type": "boolean",
            "description": "Whether there are results on the previous page"
          }
        }
      },
      "RelationshipResponse": {
        "description": "Complete details of a relationship between two entities",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "relationshipId",
          "entity1Id",
          "entity1Type",
          "entity2Id",
          "entity2Type",
          "relationshipTypeId",
          "startedAt",
          "createdAt"
        ],
        "properties": {
          "relationshipId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the relationship"
          },
          "entity1Id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the first entity in the relationship"
          },
          "entity1Type": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the first entity in the relationship"
          },
          "entity2Id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the second entity in the relationship"
          },
          "entity2Type": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the second entity in the relationship"
          },
          "relationshipTypeId": {
            "type": "string",
            "format": "uuid",
            "description": "Relationship type ID (from RelationshipType service)"
          },
          "startedAt": {
            "type": "string",
            "format": "date-time",
            "description": "In-game timestamp when relationship started"
          },
          "endedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "In-game timestamp when relationship ended, null if still active"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Type-specific relationship data"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "System timestamp when the relationship record was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "System timestamp when the relationship record was last updated"
          }
        }
      },
      "RelationshipTypeListResponse": {
        "description": "Response containing a list of relationship types with total count",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "types",
          "totalCount"
        ],
        "properties": {
          "types": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RelationshipTypeResponse"
            },
            "description": "List of relationship types matching the query"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of relationship types returned"
          }
        }
      },
      "RelationshipTypeResponse": {
        "description": "Complete representation of a relationship type including hierarchy, inverse, and deprecation information",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "relationshipTypeId",
          "code",
          "name",
          "isBidirectional",
          "isDeprecated",
          "depth",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "relationshipTypeId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the relationship type"
          },
          "code": {
            "type": "string",
            "description": "Unique code for the relationship type (e.g., \"SON\", \"MOTHER\")"
          },
          "name": {
            "type": "string",
            "description": "Human-readable display name for the relationship type"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Detailed description of the relationship type"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Category for grouping relationship types (e.g., \"FAMILY\", \"SOCIAL\")"
          },
          "parentTypeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of the parent type in the hierarchy (null for root types)"
          },
          "parentTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Code of the parent type (for convenience)"
          },
          "inverseTypeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of the inverse relationship type (e.g., PARENT is inverse of CHILD)"
          },
          "inverseTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Code of the inverse relationship type (for convenience)"
          },
          "isBidirectional": {
            "type": "boolean",
            "description": "Whether the relationship is the same in both directions (e.g., SIBLING)"
          },
          "isDeprecated": {
            "type": "boolean",
            "description": "Whether this type is deprecated and cannot be used for new relationships"
          },
          "deprecatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Timestamp when this type was deprecated"
          },
          "deprecationReason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for deprecation"
          },
          "depth": {
            "type": "integer",
            "description": "Depth in the hierarchy (0 for root types)"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional custom metadata for the relationship type"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the relationship type was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the relationship type was last updated"
          }
        }
      },
      "ReleaseAllocation": {
        "type": "object",
        "description": "Defines who gets what on release",
        "required": [
          "recipientPartyId",
          "recipientPartyType",
          "assets"
        ],
        "properties": {
          "recipientPartyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party receiving assets"
          },
          "recipientPartyType": {
            "type": "string",
            "description": "Type of the recipient party"
          },
          "assets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAsset"
            },
            "description": "Assets this recipient should receive"
          },
          "destinationWalletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Where to deliver currency"
          },
          "destinationContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Where to deliver items"
          }
        }
      },
      "ReleaseAllocationInput": {
        "type": "object",
        "description": "Input for specifying how assets should be allocated on release",
        "required": [
          "recipientPartyId",
          "recipientPartyType",
          "assets"
        ],
        "properties": {
          "recipientPartyId": {
            "type": "string",
            "format": "uuid",
            "description": "Recipient party ID"
          },
          "recipientPartyType": {
            "type": "string",
            "description": "Recipient party type"
          },
          "assets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAssetInput"
            },
            "description": "Assets to allocate"
          },
          "destinationWalletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Destination wallet"
          },
          "destinationContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Destination container"
          }
        }
      },
      "ReleaseHoldRequest": {
        "type": "object",
        "description": "Request to release a hold",
        "additionalProperties": false,
        "required": [
          "holdId"
        ],
        "properties": {
          "holdId": {
            "type": "string",
            "format": "uuid",
            "description": "Hold ID to release"
          }
        }
      },
      "ReleaseRequest": {
        "type": "object",
        "description": "Request to trigger escrow release to recipients",
        "required": [
          "escrowId",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "initiatorServiceId": {
            "type": "string",
            "nullable": true,
            "description": "For initiator_trusted mode"
          },
          "notes": {
            "type": "string",
            "nullable": true,
            "description": "Optional notes"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "ReleaseResponse": {
        "type": "object",
        "description": "Response from releasing escrow assets to recipients",
        "required": [
          "escrow",
          "finalizerResults",
          "releases"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Released escrow agreement"
          },
          "finalizerResults": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FinalizerResult"
            },
            "description": "Results of contract finalizer APIs"
          },
          "releases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ReleaseResult"
            },
            "description": "Release results per recipient"
          }
        }
      },
      "ReleaseResult": {
        "type": "object",
        "description": "Result of releasing assets to a single recipient",
        "required": [
          "recipientPartyId",
          "success"
        ],
        "properties": {
          "recipientPartyId": {
            "type": "string",
            "format": "uuid",
            "description": "Recipient party ID"
          },
          "assets": {
            "$ref": "#/components/schemas/EscrowAssetBundle",
            "description": "Assets released (null if failed)",
            "nullable": true
          },
          "success": {
            "type": "boolean",
            "description": "Whether release succeeded"
          },
          "error": {
            "type": "string",
            "nullable": true,
            "description": "Error message if failed"
          }
        }
      },
      "RemoveItemRequest": {
        "type": "object",
        "description": "Request to remove item from container",
        "additionalProperties": false,
        "required": [
          "instanceId"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance ID to remove"
          }
        }
      },
      "RemoveItemResponse": {
        "type": "object",
        "description": "Response after removing item",
        "additionalProperties": false,
        "required": [
          "success",
          "instanceId",
          "previousContainerId"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether remove succeeded"
          },
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Removed item ID"
          },
          "previousContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container removed from"
          }
        }
      },
      "RenameSlotRequest": {
        "type": "object",
        "description": "Request to rename an existing save slot",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName",
          "newSlotName"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game identifier"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID that owns the slot"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Current slot name"
          },
          "newSlotName": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64,
            "pattern": "^[a-z0-9]([a-z0-9-]*[a-z0-9])?$",
            "description": "New slot name"
          }
        }
      },
      "ReportBreachRequest": {
        "type": "object",
        "description": "Request to report a breach",
        "additionalProperties": false,
        "required": [
          "contractId",
          "breachingEntityId",
          "breachingEntityType",
          "breachType"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract that was breached"
          },
          "breachingEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity that breached"
          },
          "breachingEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of breaching entity"
          },
          "breachType": {
            "$ref": "#/components/schemas/BreachType",
            "description": "Type of breach"
          },
          "breachedTermOrMilestone": {
            "type": "string",
            "nullable": true,
            "description": "Code of breached term or milestone"
          },
          "description": {
            "type": "string",
            "maxLength": 2000,
            "nullable": true,
            "description": "Breach description"
          }
        }
      },
      "RepositoryBindingInfo": {
        "description": "Detailed repository binding configuration and status",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bindingId",
          "namespace",
          "repositoryUrl",
          "status"
        ],
        "properties": {
          "bindingId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the repository binding"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace the repository is bound to"
          },
          "repositoryUrl": {
            "type": "string",
            "description": "URL of the bound repository"
          },
          "branch": {
            "type": "string",
            "description": "Branch being synced"
          },
          "status": {
            "$ref": "#/components/schemas/BindingStatus",
            "description": "Current status of the binding"
          },
          "syncEnabled": {
            "type": "boolean",
            "description": "Whether automatic sync is enabled"
          },
          "syncIntervalMinutes": {
            "type": "integer",
            "description": "Sync interval in minutes"
          },
          "documentCount": {
            "type": "integer",
            "description": "Number of documents from this repository"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the binding was created"
          },
          "owner": {
            "type": "string",
            "description": "Owner of this binding. NOT a session ID.\nContains either an accountId (UUID format) for user-initiated bindings\nor a service name for service-initiated bindings.\n"
          }
        }
      },
      "RepositoryStatusRequest": {
        "description": "Request to get current repository binding and sync status",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to get status for"
          }
        }
      },
      "RepositoryStatusResponse": {
        "description": "Response containing binding configuration and recent sync information",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "binding": {
            "$ref": "#/components/schemas/RepositoryBindingInfo",
            "description": "Current binding configuration and status"
          },
          "lastSync": {
            "$ref": "#/components/schemas/SyncInfo",
            "description": "Information about the most recent sync"
          }
        }
      },
      "RequestSnapshotRequest": {
        "type": "object",
        "description": "Request for full snapshot",
        "required": [
          "regionId"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region to snapshot"
          },
          "kinds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapKind"
            },
            "description": "Which kinds to include (default all)",
            "nullable": true
          },
          "bounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Optional bounds filter",
            "nullable": true
          },
          "authorityToken": {
            "type": "string",
            "description": "Optional authority token. If provided and valid, clears the\nRequiresConsumeBeforePublish flag for require_consume takeover mode.\n",
            "nullable": true
          }
        }
      },
      "RequestSnapshotResponse": {
        "type": "object",
        "description": "Snapshot response",
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region ID"
          },
          "objects": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapObject"
            },
            "description": "All objects in snapshot"
          },
          "payloadRef": {
            "type": "string",
            "description": "For large snapshots, lib-asset reference",
            "nullable": true
          },
          "version": {
            "type": "integer",
            "format": "int64",
            "description": "Snapshot version"
          }
        }
      },
      "ReservationInfo": {
        "type": "object",
        "description": "Reservation token returned when creating a matchmade session",
        "additionalProperties": false,
        "required": [
          "accountId",
          "token",
          "expiresAt"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID this reservation is for"
          },
          "token": {
            "type": "string",
            "description": "Token to claim this reservation"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this reservation expires"
          }
        }
      },
      "ResolveBundlesRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to resolve optimal bundle downloads for requested assets",
        "required": [
          "assetIds",
          "realm"
        ],
        "properties": {
          "assetIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Platform asset IDs to resolve"
          },
          "realm": {
            "$ref": "#/components/schemas/Realm",
            "description": "Game realm to search within"
          },
          "preferMetabundles": {
            "type": "boolean",
            "default": true,
            "description": "Prefer metabundles when coverage is equal"
          },
          "includeStandalone": {
            "type": "boolean",
            "default": true,
            "description": "Include standalone assets not in any bundle"
          },
          "maxBundles": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum number of bundles to return (optimization limit)"
          }
        }
      },
      "ResolveBundlesResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Optimal bundle set for requested assets",
        "required": [
          "bundles",
          "standaloneAssets",
          "coverage"
        ],
        "properties": {
          "bundles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResolvedBundle"
            },
            "description": "Bundles to download"
          },
          "standaloneAssets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResolvedAsset"
            },
            "description": "Individual assets to download"
          },
          "coverage": {
            "$ref": "#/components/schemas/CoverageAnalysis",
            "description": "Coverage statistics"
          },
          "unresolved": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Asset IDs that couldn't be found (null if all resolved)"
          }
        }
      },
      "ResolveRequest": {
        "type": "object",
        "description": "Request for arbiter to resolve a disputed escrow",
        "required": [
          "escrowId",
          "arbiterId",
          "arbiterType",
          "resolution",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "arbiterId": {
            "type": "string",
            "format": "uuid",
            "description": "Arbiter ID"
          },
          "arbiterType": {
            "type": "string",
            "description": "Arbiter type"
          },
          "resolution": {
            "$ref": "#/components/schemas/EscrowResolution",
            "description": "Resolution decision for the dispute"
          },
          "splitAllocations": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/SplitAllocation"
            },
            "description": "For split resolution"
          },
          "notes": {
            "type": "string",
            "nullable": true,
            "description": "Resolution notes"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "ResolveResponse": {
        "type": "object",
        "description": "Response from arbiter resolving a disputed escrow",
        "required": [
          "escrow",
          "transfers"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Resolved escrow agreement"
          },
          "transfers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransferResult"
            },
            "description": "Transfer results"
          }
        }
      },
      "ResolvedAsset": {
        "type": "object",
        "additionalProperties": false,
        "description": "A standalone asset selected for download",
        "required": [
          "assetId",
          "downloadUrl",
          "expiresAt",
          "size"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Asset identifier"
          },
          "downloadUrl": {
            "type": "string",
            "format": "uri",
            "description": "Pre-signed download URL"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the download URL expires"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "Asset file size in bytes"
          },
          "contentHash": {
            "type": "string",
            "nullable": true,
            "description": "SHA256 hash of asset content"
          }
        }
      },
      "ResolvedBundle": {
        "type": "object",
        "additionalProperties": false,
        "description": "A bundle selected for download in resolution",
        "required": [
          "bundleId",
          "bundleType",
          "downloadUrl",
          "expiresAt",
          "size",
          "assetsProvided"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Bundle identifier"
          },
          "bundleType": {
            "$ref": "#/components/schemas/BundleType",
            "description": "Whether source or metabundle"
          },
          "version": {
            "type": "string",
            "nullable": true,
            "description": "Bundle version"
          },
          "downloadUrl": {
            "type": "string",
            "format": "uri",
            "description": "Pre-signed download URL"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the download URL expires"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "Bundle file size in bytes"
          },
          "assetsProvided": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Which of the requested assets this bundle provides"
          }
        }
      },
      "ResolvedReference": {
        "type": "object",
        "description": "A successfully resolved scene reference",
        "required": [
          "nodeId",
          "refId",
          "referencedSceneId",
          "scene"
        ],
        "properties": {
          "nodeId": {
            "type": "string",
            "format": "uuid",
            "description": "Node ID containing the reference"
          },
          "refId": {
            "type": "string",
            "description": "refId of the referencing node"
          },
          "referencedSceneId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the referenced scene"
          },
          "referencedVersion": {
            "type": "string",
            "nullable": true,
            "description": "Version that was resolved"
          },
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "The resolved scene content"
          },
          "depth": {
            "type": "integer",
            "description": "Depth level of this reference"
          }
        }
      },
      "ResponseValidation": {
        "type": "object",
        "description": "Validation rules for API responses with three-outcome model.\nUsed by lib-contract to validate clause conditions without\nunderstanding the specific API semantics.\n",
        "additionalProperties": false,
        "properties": {
          "successConditions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationCondition"
            },
            "description": "Conditions that must ALL pass for success.\nIf any fail, checks permanent failure conditions.\n"
          },
          "permanentFailureConditions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationCondition"
            },
            "description": "Conditions that indicate permanent failure (clause violated).\nChecked when success conditions fail.\n"
          },
          "transientFailureStatusCodes": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "HTTP status codes that indicate transient failure (retry later).\nDefault: [408, 429, 502, 503, 504]\n"
          }
        }
      },
      "RestoreBundleRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to restore a soft-deleted bundle",
        "required": [
          "bundleId"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Bundle identifier to restore"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for restoration (recorded in version history)"
          }
        }
      },
      "RestoreBundleResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of bundle restoration",
        "required": [
          "bundleId",
          "status",
          "restoredAt",
          "restoredFromVersion"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Restored bundle identifier"
          },
          "status": {
            "type": "string",
            "description": "Current bundle status (should be \"active\")"
          },
          "restoredAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the bundle was restored"
          },
          "restoredFromVersion": {
            "type": "integer",
            "description": "Version number the bundle was restored from"
          }
        }
      },
      "SEOMetadata": {
        "description": "Search engine optimization and social media sharing metadata",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Meta description for search engines"
          },
          "keywords": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Keywords for search engine indexing"
          },
          "ogTitle": {
            "type": "string",
            "nullable": true,
            "description": "Open Graph title for social media sharing"
          },
          "ogDescription": {
            "type": "string",
            "nullable": true,
            "description": "Open Graph description for social media sharing"
          },
          "ogImage": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "Open Graph image URL for social media sharing"
          }
        }
      },
      "SaveCategory": {
        "type": "string",
        "enum": [
          "QUICK_SAVE",
          "AUTO_SAVE",
          "MANUAL_SAVE",
          "CHECKPOINT",
          "STATE_SNAPSHOT"
        ],
        "description": "Category of save with predefined behaviors.\nQUICK_SAVE: Single-slot fast save, overwritten frequently (max 1 version).\nAUTO_SAVE: System-triggered periodic saves (max 5 versions, rolling).\nMANUAL_SAVE: User-initiated named saves (max 10 versions, no auto-cleanup).\nCHECKPOINT: Progress markers (max 20 versions, rolling).\nSTATE_SNAPSHOT: Full state captures for debugging (max 3 versions, rolling).\n"
      },
      "SaveDeltaRequest": {
        "type": "object",
        "description": "Request to save incremental changes as a delta from a base version",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName",
          "baseVersion",
          "delta"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Name of the slot to save the delta to"
          },
          "baseVersion": {
            "type": "integer",
            "description": "Version number this delta is based on"
          },
          "delta": {
            "type": "string",
            "format": "byte",
            "description": "Base64-encoded delta/patch data.\nFor JSON_PATCH: Array of RFC 6902 operations\nFor BSDIFF/XDELTA: Binary patch data\n"
          },
          "algorithm": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DeltaAlgorithm"
              }
            ],
            "nullable": true,
            "description": "Delta computation algorithm to use (defaults to JSON_PATCH)"
          },
          "schemaVersion": {
            "type": "string",
            "nullable": true,
            "description": "Schema version of this save for migration tracking"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable name for this delta save"
          },
          "deviceId": {
            "type": "string",
            "nullable": true,
            "description": "Device identifier for cross-device sync conflict detection"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom key-value metadata for this delta version"
          }
        }
      },
      "SaveDeltaResponse": {
        "type": "object",
        "description": "Result of delta save operation with size and chain information",
        "required": [
          "slotId",
          "versionNumber",
          "baseVersion",
          "deltaSizeBytes",
          "estimatedFullSizeBytes",
          "createdAt"
        ],
        "properties": {
          "slotId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the save slot"
          },
          "versionNumber": {
            "type": "integer",
            "description": "New version number"
          },
          "baseVersion": {
            "type": "integer",
            "description": "Base version this delta is relative to"
          },
          "deltaSizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Size of stored delta"
          },
          "estimatedFullSizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Estimated size when reconstructed"
          },
          "chainLength": {
            "type": "integer",
            "description": "Number of deltas in chain to base snapshot"
          },
          "compressionSavings": {
            "type": "number",
            "format": "double",
            "description": "Storage savings vs full snapshot (0-1)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the delta version was created"
          }
        }
      },
      "SaveRequest": {
        "type": "object",
        "description": "Request to save game state data to a slot with optional compression and metadata",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName",
          "data"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name (auto-created if doesn't exist)"
          },
          "category": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SaveCategory"
              }
            ],
            "nullable": true,
            "description": "Category for auto-created slots (defaults to MANUAL_SAVE)"
          },
          "data": {
            "type": "string",
            "format": "byte",
            "description": "Base64-encoded save data"
          },
          "schemaVersion": {
            "type": "string",
            "nullable": true,
            "description": "Schema version identifier for migration tracking"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "maxLength": 128,
            "description": "Human-readable name for this save"
          },
          "thumbnail": {
            "type": "string",
            "format": "byte",
            "nullable": true,
            "description": "Optional preview image (JPEG/WebP). Max size configurable\n(default 256KB). Used for save slot previews in game UI.\n"
          },
          "deviceId": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Optional device identifier for cloud save conflict detection.\nWhen provided, saves are prefixed/tagged with device info,\nenabling opt-in cross-device sync with collision awareness.\n"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom metadata (e.g., level, playtime, location)"
          },
          "pinAsCheckpoint": {
            "type": "string",
            "nullable": true,
            "maxLength": 64,
            "description": "If provided, pin this version with checkpoint name"
          }
        }
      },
      "SaveResponse": {
        "type": "object",
        "description": "Result of a save operation including version info and conflict detection",
        "required": [
          "slotId",
          "versionNumber",
          "contentHash",
          "sizeBytes",
          "createdAt"
        ],
        "properties": {
          "slotId": {
            "type": "string",
            "format": "uuid",
            "description": "Slot identifier"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Assigned version number"
          },
          "contentHash": {
            "type": "string",
            "description": "SHA-256 hash of save data"
          },
          "sizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Size of save data in bytes"
          },
          "compressedSizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Compressed size (if compression applied)"
          },
          "compressionRatio": {
            "type": "number",
            "format": "double",
            "description": "Compression ratio (0-1)"
          },
          "pinned": {
            "type": "boolean",
            "description": "Whether version was pinned"
          },
          "checkpointName": {
            "type": "string",
            "nullable": true,
            "description": "Checkpoint name if pinned"
          },
          "thumbnailUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "Pre-signed URL to retrieve thumbnail (if provided)"
          },
          "conflictDetected": {
            "type": "boolean",
            "description": "True if this save overwrote a version from a different device.\nOnly relevant when deviceId is used for cloud sync.\n"
          },
          "conflictingDeviceId": {
            "type": "string",
            "nullable": true,
            "description": "Device ID of the overwritten version (if conflict)"
          },
          "conflictingVersion": {
            "type": "integer",
            "nullable": true,
            "description": "Version number that was overwritten (if conflict)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Save timestamp"
          },
          "versionsCleanedUp": {
            "type": "integer",
            "description": "Number of old versions cleaned up by rolling policy"
          },
          "uploadPending": {
            "type": "boolean",
            "description": "True if async upload is enabled and data is queued for MinIO upload.\nSave is immediately loadable from Redis cache, but not yet durable.\n"
          }
        }
      },
      "Scene": {
        "type": "object",
        "description": "A complete scene document with hierarchical node structure",
        "required": [
          "sceneId",
          "gameId",
          "sceneType",
          "name",
          "version",
          "root"
        ],
        "properties": {
          "schema": {
            "type": "string",
            "description": "Schema identifier for validation",
            "default": "bannou://schemas/scene/v1"
          },
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique scene identifier"
          },
          "gameId": {
            "type": "string",
            "description": "Game service identifier for partitioning. Treated as opaque string.\nDefault is the nil UUID for unpartitioned scenes.\n",
            "default": "00000000-0000-0000-0000-000000000000"
          },
          "sceneType": {
            "$ref": "#/components/schemas/SceneType",
            "description": "Scene classification for querying and validation"
          },
          "name": {
            "type": "string",
            "description": "Human-readable scene name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Optional scene description"
          },
          "version": {
            "type": "string",
            "pattern": "^\\d+\\.\\d+\\.\\d+$",
            "description": "Semantic version (MAJOR.MINOR.PATCH)"
          },
          "root": {
            "$ref": "#/components/schemas/SceneNode",
            "description": "Root node of the scene hierarchy"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Searchable tags for filtering scenes"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Scene-level metadata. Not interpreted by Scene service.\nExamples: author, thumbnail, editor preferences, generator config.\n"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the scene was first created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the scene was last modified"
          }
        }
      },
      "SceneNode": {
        "type": "object",
        "description": "A node in the scene hierarchy. Nodes can contain children to form\na tree structure. Each node has a local transform relative to its parent.\n",
        "required": [
          "nodeId",
          "refId",
          "name",
          "nodeType",
          "localTransform"
        ],
        "properties": {
          "nodeId": {
            "type": "string",
            "format": "uuid",
            "description": "Globally unique node identifier"
          },
          "refId": {
            "type": "string",
            "pattern": "^[a-z][a-z0-9_]*$",
            "description": "Scene-local reference identifier. Must be unique within the scene.\nUsed for scripting and cross-referencing. Examples: main_door, npc_spawn_1\n"
          },
          "parentNodeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Parent node ID. Null for the root node only."
          },
          "name": {
            "type": "string",
            "description": "Human-readable display name for the node"
          },
          "nodeType": {
            "$ref": "#/components/schemas/NodeType",
            "description": "The structural type of this node"
          },
          "localTransform": {
            "$ref": "#/components/schemas/Transform",
            "description": "Transform relative to parent node"
          },
          "asset": {
            "$ref": "#/components/schemas/AssetReference",
            "nullable": true,
            "description": "Optional asset binding (mesh, sound, particle effect)"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SceneNode"
            },
            "description": "Child nodes in the hierarchy"
          },
          "enabled": {
            "type": "boolean",
            "default": true,
            "description": "Whether this node is active in the scene definition"
          },
          "sortOrder": {
            "type": "integer",
            "default": 0,
            "description": "Ordering among siblings for deterministic iteration"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive)"
          },
          "annotations": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Consumer-specific data stored without interpretation.\nUse namespaced keys (e.g., render.castShadows, arcadia.interactionType).\n"
          },
          "attachmentPoints": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AttachmentPoint"
            },
            "description": "Predefined locations for attaching child objects.\nUsed by Scene Composer for furniture decoration, wall accessories, etc.\n"
          },
          "affordances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Affordance"
            },
            "description": "Interaction capabilities of this node.\nUsed by AI navigation and character controllers.\n"
          },
          "assetSlot": {
            "$ref": "#/components/schemas/AssetSlot",
            "nullable": true,
            "description": "Procedural asset swapping configuration.\nDefines which assets can substitute for this node's asset.\n"
          },
          "markerType": {
            "$ref": "#/components/schemas/MarkerType",
            "nullable": true,
            "description": "Type of marker for marker nodes.\nOnly relevant when nodeType is 'marker'.\n"
          },
          "volumeShape": {
            "$ref": "#/components/schemas/VolumeShape",
            "nullable": true,
            "description": "Shape of volume for volume nodes.\nOnly relevant when nodeType is 'volume'.\n"
          },
          "volumeSize": {
            "$ref": "#/components/schemas/Vector3",
            "nullable": true,
            "description": "Size/extents of the volume (interpretation depends on volumeShape).\nFor box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.\n"
          },
          "referenceSceneId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Scene ID to embed for reference nodes.\nOnly relevant when nodeType is 'reference'.\n"
          }
        }
      },
      "SceneResponse": {
        "type": "object",
        "description": "Standard response containing a scene",
        "required": [
          "scene"
        ],
        "properties": {
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "The scene document"
          }
        }
      },
      "SceneSummary": {
        "type": "object",
        "description": "Summary of a scene for list results (excludes full node tree)",
        "required": [
          "sceneId",
          "gameId",
          "sceneType",
          "name",
          "version"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique scene identifier"
          },
          "gameId": {
            "type": "string",
            "description": "Game service identifier"
          },
          "sceneType": {
            "$ref": "#/components/schemas/SceneType",
            "description": "Scene classification"
          },
          "name": {
            "type": "string",
            "description": "Scene name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Scene description"
          },
          "version": {
            "type": "string",
            "description": "Current version"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Scene tags"
          },
          "nodeCount": {
            "type": "integer",
            "description": "Total number of nodes in scene"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Last update timestamp"
          },
          "isCheckedOut": {
            "type": "boolean",
            "description": "Whether scene is currently checked out"
          }
        }
      },
      "SceneType": {
        "type": "string",
        "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
        "enum": [
          "unknown",
          "region",
          "city",
          "district",
          "lot",
          "building",
          "room",
          "dungeon",
          "arena",
          "vehicle",
          "prefab",
          "cutscene",
          "other"
        ]
      },
      "SchemaResponse": {
        "type": "object",
        "description": "Registered schema definition with version lineage information",
        "required": [
          "namespace",
          "schemaVersion",
          "createdAt"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Schema namespace"
          },
          "schemaVersion": {
            "type": "string",
            "description": "Schema version"
          },
          "schema": {
            "type": "object",
            "description": "JSON Schema definition"
          },
          "previousVersion": {
            "type": "string",
            "nullable": true,
            "description": "Previous version"
          },
          "hasMigration": {
            "type": "boolean",
            "description": "Whether migration script is registered"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Registration timestamp"
          }
        }
      },
      "SearchDocumentationRequest": {
        "description": "Request to search documentation using keyword matching",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "searchTerm"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to search within"
          },
          "searchTerm": {
            "type": "string",
            "minLength": 2,
            "maxLength": 200,
            "description": "Keyword or phrase to search for"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional session ID for tracking searches (null if not tracking)"
          },
          "category": {
            "$ref": "#/components/schemas/DocumentCategory",
            "nullable": true,
            "description": "Filter results to a specific category (null for all categories)"
          },
          "maxResults": {
            "type": "integer",
            "default": 10,
            "minimum": 1,
            "maximum": 50,
            "description": "Maximum number of results to return"
          },
          "searchIn": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchField"
            },
            "nullable": true,
            "description": "Fields to search within (null for default fields)"
          },
          "sortBy": {
            "type": "string",
            "enum": [
              "relevance",
              "recency",
              "alphabetical"
            ],
            "default": "relevance",
            "description": "How to sort the search results"
          },
          "includeContent": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include full document content in results"
          }
        }
      },
      "SearchDocumentationResponse": {
        "description": "Response containing keyword search results",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "results"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "description": "The namespace that was searched"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentResult"
            },
            "description": "List of matching documents"
          },
          "totalResults": {
            "type": "integer",
            "description": "Total number of matching documents"
          },
          "searchTerm": {
            "type": "string",
            "description": "The original search term"
          }
        }
      },
      "SearchField": {
        "type": "string",
        "enum": [
          "title",
          "content",
          "tags",
          "summary"
        ],
        "description": "Fields that can be searched within documents"
      },
      "SearchMatchType": {
        "type": "string",
        "description": "Where the search match was found",
        "enum": [
          "name",
          "description",
          "tag",
          "node_name"
        ]
      },
      "SearchResult": {
        "type": "object",
        "description": "A single search result",
        "required": [
          "scene",
          "matchType"
        ],
        "properties": {
          "scene": {
            "$ref": "#/components/schemas/SceneSummary",
            "description": "Matching scene summary"
          },
          "matchType": {
            "$ref": "#/components/schemas/SearchMatchType",
            "description": "Where the match was found"
          },
          "matchContext": {
            "type": "string",
            "nullable": true,
            "description": "Context around the match"
          }
        }
      },
      "SearchScenesRequest": {
        "type": "object",
        "description": "Request for full-text search",
        "required": [
          "query"
        ],
        "properties": {
          "query": {
            "type": "string",
            "description": "Search query text"
          },
          "gameId": {
            "type": "string",
            "nullable": true,
            "description": "Filter by game ID"
          },
          "sceneTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SceneType"
            },
            "nullable": true,
            "description": "Filter by scene types"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Maximum results"
          }
        }
      },
      "SearchScenesResponse": {
        "type": "object",
        "description": "Search results",
        "required": [
          "results",
          "total"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchResult"
            },
            "description": "Matching scenes"
          },
          "total": {
            "type": "integer",
            "description": "Total matches"
          }
        }
      },
      "SeasonResponse": {
        "type": "object",
        "description": "Season information",
        "additionalProperties": false,
        "required": [
          "leaderboardId",
          "seasonNumber",
          "startedAt",
          "isActive"
        ],
        "properties": {
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard"
          },
          "seasonNumber": {
            "type": "integer",
            "description": "Season number"
          },
          "seasonName": {
            "type": "string",
            "nullable": true,
            "description": "Name of the season"
          },
          "startedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this season started"
          },
          "endedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this season ended (null if active)"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether this is the current season"
          },
          "entryCount": {
            "type": "integer",
            "format": "int64",
            "description": "Number of entries in this season"
          }
        }
      },
      "SentimentResponse": {
        "type": "object",
        "description": "Response containing aggregate sentiment",
        "additionalProperties": false,
        "required": [
          "characterId",
          "targetCharacterId",
          "sentiment",
          "encounterCount"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character whose sentiment was queried"
          },
          "targetCharacterId": {
            "type": "string",
            "format": "uuid",
            "description": "Target of the sentiment"
          },
          "sentiment": {
            "type": "number",
            "format": "float",
            "minimum": -1.0,
            "maximum": 1.0,
            "description": "Aggregate sentiment (-1.0 = hostile, +1.0 = friendly)"
          },
          "encounterCount": {
            "type": "integer",
            "description": "Number of encounters factored in"
          },
          "dominantEmotion": {
            "$ref": "#/components/schemas/EmotionalImpact",
            "nullable": true,
            "description": "Most common emotional impact across encounters"
          }
        }
      },
      "ServerStatusResponse": {
        "description": "Aggregated status of all game server realms",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realms",
          "globalStatus"
        ],
        "properties": {
          "globalStatus": {
            "type": "string",
            "enum": [
              "online",
              "partial",
              "offline",
              "maintenance"
            ],
            "description": "Overall status across all game realms"
          },
          "realms": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RealmStatus"
            },
            "description": "Status information for each game realm"
          }
        }
      },
      "ServiceInfo": {
        "type": "object",
        "additionalProperties": false,
        "description": "Information about a game service",
        "required": [
          "serviceId",
          "stubName",
          "displayName",
          "isActive",
          "createdAt"
        ],
        "properties": {
          "serviceId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the service"
          },
          "stubName": {
            "type": "string",
            "description": "URL-safe identifier (e.g., \"arcadia\")"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable name (e.g., \"Arcadia Online\")"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Optional description"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether the service is currently active"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the service was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the service was last updated"
          }
        }
      },
      "SessionGameType": {
        "type": "string",
        "description": "Game type for created sessions (maps to game-session service GameType)",
        "enum": [
          "generic",
          "arcadia"
        ],
        "default": "generic"
      },
      "SessionInfo": {
        "description": "Information about an active user session including device and activity details",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "sessionId",
          "createdAt",
          "lastActive"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the session"
          },
          "deviceInfo": {
            "$ref": "#/components/schemas/DeviceInfo",
            "nullable": true,
            "description": "Information about the device used for this session"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the session was created"
          },
          "lastActive": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of the last activity in this session"
          },
          "ipAddress": {
            "type": "string",
            "nullable": true,
            "description": "IP address from which the session was initiated"
          },
          "location": {
            "type": "string",
            "nullable": true,
            "description": "Geographic location derived from the IP address"
          }
        }
      },
      "SessionType": {
        "type": "string",
        "description": "Type of game session - determines join behavior",
        "enum": [
          "lobby",
          "matchmade"
        ]
      },
      "SessionsResponse": {
        "description": "Response containing a list of all active sessions for an account",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "sessions"
        ],
        "properties": {
          "sessions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SessionInfo"
            },
            "description": "List of active sessions for the account"
          }
        }
      },
      "SetTemplateValuesRequest": {
        "type": "object",
        "description": "Request to set template values on a contract",
        "additionalProperties": false,
        "required": [
          "contractInstanceId",
          "templateValues"
        ],
        "properties": {
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "templateValues": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Key-value pairs for template substitution.\nKeys should follow pattern: EscrowId, PartyA_EscrowWalletId, etc.\n"
          }
        }
      },
      "SetTemplateValuesResponse": {
        "type": "object",
        "description": "Response from setting template values",
        "additionalProperties": false,
        "required": [
          "updated",
          "contractId"
        ],
        "properties": {
          "updated": {
            "type": "boolean",
            "description": "Whether values were updated"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "valueCount": {
            "type": "integer",
            "description": "Number of template values set"
          }
        }
      },
      "SiteSettings": {
        "description": "Global website configuration including branding, languages, and integrations",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "siteName",
          "siteUrl",
          "defaultLanguage"
        ],
        "properties": {
          "siteName": {
            "type": "string",
            "description": "Display name of the website"
          },
          "siteUrl": {
            "type": "string",
            "format": "uri",
            "description": "Base URL of the website"
          },
          "tagline": {
            "type": "string",
            "nullable": true,
            "description": "Short slogan or description of the site"
          },
          "defaultLanguage": {
            "type": "string",
            "default": "en",
            "description": "Default language code for the website"
          },
          "supportedLanguages": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of supported language codes"
          },
          "maintenanceMode": {
            "type": "boolean",
            "default": false,
            "description": "Whether the site is in maintenance mode"
          },
          "maintenanceMessage": {
            "type": "string",
            "nullable": true,
            "description": "Message displayed during maintenance mode"
          },
          "contactEmail": {
            "type": "string",
            "format": "email",
            "description": "Primary contact email address for the site"
          },
          "socialLinks": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "format": "uri"
            },
            "description": "Map of social media platform names to profile URLs"
          },
          "analytics": {
            "description": "Analytics and tracking service configuration",
            "$ref": "#/components/schemas/Analytics"
          },
          "customScripts": {
            "description": "Custom JavaScript scripts to inject into pages",
            "$ref": "#/components/schemas/CustomScripts"
          }
        }
      },
      "SkillExpansionStep": {
        "type": "object",
        "description": "A step in the skill window expansion curve",
        "additionalProperties": false,
        "required": [
          "intervals"
        ],
        "properties": {
          "intervals": {
            "type": "integer",
            "minimum": 0,
            "description": "Number of intervals after which this step applies"
          },
          "range": {
            "type": "integer",
            "nullable": true,
            "minimum": 0,
            "description": "Skill range (null means any skill level)"
          }
        }
      },
      "SlotResponse": {
        "type": "object",
        "description": "Complete metadata for a save slot including version statistics",
        "required": [
          "slotId",
          "ownerId",
          "ownerType",
          "slotName",
          "category",
          "createdAt"
        ],
        "properties": {
          "slotId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique slot identifier"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          },
          "category": {
            "$ref": "#/components/schemas/SaveCategory",
            "description": "Save category determining retention and cleanup behavior"
          },
          "maxVersions": {
            "type": "integer",
            "description": "Maximum versions to retain"
          },
          "retentionDays": {
            "type": "integer",
            "nullable": true,
            "description": "Days to retain versions (null = indefinite)"
          },
          "compressionType": {
            "$ref": "#/components/schemas/CompressionType",
            "description": "Compression algorithm used for save data"
          },
          "versionCount": {
            "type": "integer",
            "description": "Current number of versions in slot"
          },
          "latestVersion": {
            "type": "integer",
            "nullable": true,
            "description": "Latest version number (null if empty)"
          },
          "totalSizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Total storage used by all versions"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Slot creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Last modification timestamp"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom key-value metadata"
          }
        }
      },
      "SortOrder": {
        "type": "string",
        "description": "How scores are sorted",
        "enum": [
          "descending",
          "ascending"
        ]
      },
      "SoulboundType": {
        "type": "string",
        "description": "When item becomes bound to a character",
        "enum": [
          "none",
          "on_pickup",
          "on_equip",
          "on_use"
        ]
      },
      "SourceBundleReference": {
        "type": "object",
        "additionalProperties": false,
        "description": "Provenance reference to a source bundle used in metabundle creation",
        "required": [
          "bundleId",
          "version",
          "assetIds",
          "contentHash"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Source bundle identifier"
          },
          "version": {
            "type": "string",
            "description": "Version of source bundle at composition time"
          },
          "assetIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Asset IDs contributed from this source bundle"
          },
          "contentHash": {
            "type": "string",
            "description": "Hash of source bundle at composition time (for integrity verification)"
          }
        }
      },
      "SpaceCandidate": {
        "type": "object",
        "description": "Potential placement location",
        "additionalProperties": false,
        "required": [
          "containerId",
          "containerType",
          "canFitQuantity"
        ],
        "properties": {
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container ID"
          },
          "containerType": {
            "type": "string",
            "description": "Container type"
          },
          "canFitQuantity": {
            "type": "number",
            "format": "double",
            "description": "How much can fit"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Available slot"
          },
          "slotX": {
            "type": "integer",
            "nullable": true,
            "description": "Available grid X"
          },
          "slotY": {
            "type": "integer",
            "nullable": true,
            "description": "Available grid Y"
          },
          "existingStackInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Stack to merge with"
          }
        }
      },
      "SpatialContext": {
        "type": "object",
        "additionalProperties": true,
        "description": "Spatial context derived from game server's authoritative spatial state.\nIncluded in perception events to give NPC actors awareness of their environment\nwithout requiring direct map subscriptions.\n\nNote: additionalProperties=true allows game-specific extensions.\n",
        "properties": {
          "terrainType": {
            "type": "string",
            "nullable": true,
            "description": "Terrain type at character position (grass, stone, water, etc.)"
          },
          "elevation": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "description": "Elevation at character position"
          },
          "nearbyObjects": {
            "type": "array",
            "nullable": true,
            "description": "Objects within perception radius",
            "items": {
              "$ref": "#/components/schemas/NearbyObject"
            }
          },
          "hazardsInRange": {
            "type": "array",
            "nullable": true,
            "description": "Active hazards within detection range",
            "items": {
              "$ref": "#/components/schemas/HazardInfo"
            }
          },
          "pathableDirections": {
            "type": "array",
            "nullable": true,
            "description": "Directions the character can move (for navigation awareness)",
            "items": {
              "type": "string",
              "description": "Cardinal or relative direction (north, south, east, west, forward, etc.)"
            }
          },
          "coverNearby": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether cover is available within close range"
          },
          "indoors": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether character is currently indoors/under roof"
          }
        }
      },
      "SpawnActorRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to spawn a new actor from a template",
        "required": [
          "templateId"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template to instantiate from"
          },
          "actorId": {
            "type": "string",
            "nullable": true,
            "description": "Optional custom actor ID (auto-generated if not provided)"
          },
          "configurationOverrides": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Override template defaults"
          },
          "initialState": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Initial state passed to behavior"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional character ID for NPC brain actors"
          }
        }
      },
      "SpeciesListResponse": {
        "description": "Paginated list of species with total count for pagination",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "species",
          "totalCount"
        ],
        "properties": {
          "species": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpeciesResponse"
            },
            "description": "List of species matching the query"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of species matching the query (for pagination)"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of items per page"
          }
        }
      },
      "SpeciesResponse": {
        "description": "Complete species data including all attributes and realm associations",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "speciesId",
          "code",
          "name",
          "isPlayable",
          "isDeprecated",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the species"
          },
          "code": {
            "type": "string",
            "description": "Unique code for the species (e.g., \"HUMAN\", \"ELF\")"
          },
          "name": {
            "type": "string",
            "description": "Display name for the species"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Description of the species"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Category for grouping (e.g., \"HUMANOID\", \"BEAST\", \"MAGICAL\")"
          },
          "isPlayable": {
            "type": "boolean",
            "description": "Whether players can create characters of this species"
          },
          "isDeprecated": {
            "type": "boolean",
            "description": "Whether this species is deprecated and cannot be used for new characters"
          },
          "deprecatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Timestamp when this species was deprecated"
          },
          "deprecationReason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for deprecation"
          },
          "baseLifespan": {
            "type": "integer",
            "nullable": true,
            "description": "Base lifespan in game years"
          },
          "maturityAge": {
            "type": "integer",
            "nullable": true,
            "description": "Age at which the species reaches maturity"
          },
          "traitModifiers": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Base trait modifiers for this species"
          },
          "realmIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Realms where this species is available"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional metadata for the species"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the species was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the species was last updated"
          }
        }
      },
      "SplitAllocation": {
        "type": "object",
        "description": "Allocation of assets to a party in a split resolution",
        "required": [
          "partyId",
          "partyType",
          "assets"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party ID"
          },
          "partyType": {
            "type": "string",
            "description": "Party type"
          },
          "assets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAssetInput"
            },
            "description": "Assets allocated to this party"
          }
        }
      },
      "SplitStackRequest": {
        "type": "object",
        "description": "Request to split a stack",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "quantity"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Stack to split"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "minimum": 1,
            "description": "Quantity to split off"
          },
          "targetSlotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Slot for new stack"
          },
          "targetSlotX": {
            "type": "integer",
            "nullable": true,
            "description": "Grid X for new stack"
          },
          "targetSlotY": {
            "type": "integer",
            "nullable": true,
            "description": "Grid Y for new stack"
          }
        }
      },
      "SplitStackResponse": {
        "type": "object",
        "description": "Response after splitting",
        "additionalProperties": false,
        "required": [
          "success",
          "originalInstanceId",
          "newInstanceId",
          "originalQuantity",
          "newQuantity"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether split succeeded"
          },
          "originalInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Original stack ID"
          },
          "newInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "New stack ID"
          },
          "originalQuantity": {
            "type": "number",
            "format": "double",
            "description": "Remaining quantity"
          },
          "newQuantity": {
            "type": "number",
            "format": "double",
            "description": "Split quantity"
          }
        }
      },
      "StartEncounterRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to start an encounter managed by an Event Brain actor",
        "required": [
          "actorId",
          "encounterId",
          "encounterType",
          "participants"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "ID of the Event Brain actor that will manage this encounter"
          },
          "encounterId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this encounter"
          },
          "encounterType": {
            "type": "string",
            "description": "Type of encounter (e.g., \"combat\", \"conversation\", \"choreography\")"
          },
          "participants": {
            "type": "array",
            "description": "Character IDs of participants in the encounter",
            "items": {
              "type": "string",
              "format": "uuid"
            }
          },
          "initialData": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Optional initial data for the encounter"
          }
        }
      },
      "StatusResponse": {
        "description": "Health and version status information for the website service",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "status",
          "version",
          "uptime"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "healthy",
              "degraded",
              "maintenance"
            ],
            "description": "Current health status of the website service"
          },
          "version": {
            "type": "string",
            "example": "1.0.0",
            "description": "Current version of the website service"
          },
          "uptime": {
            "type": "integer",
            "description": "Uptime in seconds"
          },
          "maintenanceMessage": {
            "type": "string",
            "nullable": true,
            "description": "Message displayed during maintenance mode"
          }
        }
      },
      "SteamVerifyRequest": {
        "type": "object",
        "description": "Request to verify a Steam Session Ticket. The ticket is obtained client-side via\nISteamUser::GetAuthTicketForWebApi(\"bannou\"). SteamID is NOT included because\nit must be obtained from Steam's Web API response (never trust client-provided SteamID).\n",
        "additionalProperties": false,
        "required": [
          "ticket"
        ],
        "properties": {
          "ticket": {
            "type": "string",
            "description": "Hex-encoded Steam Session Ticket from ISteamUser::GetAuthTicketForWebApi().\nClient converts ticket bytes to hex string: BitConverter.ToString(ticketData).Replace(\"-\", \"\")\n",
            "example": "140000006A7B3C8E..."
          },
          "deviceInfo": {
            "$ref": "#/components/schemas/DeviceInfo",
            "nullable": true,
            "description": "Information about the client device (optional)"
          }
        }
      },
      "StopActorRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to stop a running actor",
        "required": [
          "actorId"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "ID of the actor to stop"
          },
          "graceful": {
            "type": "boolean",
            "default": true,
            "description": "If true, allows behavior to complete current iteration"
          }
        }
      },
      "StopActorResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response confirming actor stop operation",
        "required": [
          "stopped",
          "finalStatus"
        ],
        "properties": {
          "stopped": {
            "type": "boolean",
            "description": "Whether the actor was successfully stopped"
          },
          "finalStatus": {
            "description": "Final status of the actor after stopping",
            "$ref": "#/components/schemas/ActorStatus"
          }
        }
      },
      "StyleDefinitionResponse": {
        "description": "Response containing a style definition",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "styleId",
          "name",
          "category"
        ],
        "properties": {
          "styleId": {
            "type": "string",
            "description": "Unique style identifier"
          },
          "name": {
            "type": "string",
            "description": "Style name"
          },
          "category": {
            "type": "string",
            "description": "Style category"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description"
          },
          "modeDistribution": {
            "$ref": "#/components/schemas/ModeDistribution",
            "nullable": true,
            "description": "Mode probability distribution"
          },
          "intervalPreferences": {
            "$ref": "#/components/schemas/IntervalPreferences",
            "nullable": true,
            "description": "Interval preferences"
          },
          "formTemplates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FormTemplate"
            },
            "nullable": true,
            "description": "Available forms"
          },
          "tuneTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TuneType"
            },
            "nullable": true,
            "description": "Style-specific tune types"
          },
          "defaultTempo": {
            "type": "integer",
            "description": "Default tempo"
          },
          "harmonyStyle": {
            "$ref": "#/components/schemas/HarmonyStyle",
            "nullable": true,
            "description": "Harmony preferences"
          }
        }
      },
      "StyleSummary": {
        "description": "Brief style summary for listing",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "styleId",
          "name",
          "category"
        ],
        "properties": {
          "styleId": {
            "type": "string",
            "description": "Style identifier"
          },
          "name": {
            "type": "string",
            "description": "Style name"
          },
          "category": {
            "type": "string",
            "description": "Style category"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Brief description"
          }
        }
      },
      "SubscriptionInfo": {
        "type": "object",
        "additionalProperties": false,
        "description": "Information about a subscription",
        "required": [
          "subscriptionId",
          "accountId",
          "serviceId",
          "stubName",
          "startDate",
          "isActive",
          "createdAt"
        ],
        "properties": {
          "subscriptionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the subscription"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the account this subscription belongs to"
          },
          "serviceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the subscribed service (game)"
          },
          "stubName": {
            "type": "string",
            "description": "Stub name of the service (denormalized for efficiency)"
          },
          "displayName": {
            "type": "string",
            "description": "Display name of the service (denormalized for efficiency)"
          },
          "startDate": {
            "type": "string",
            "format": "date-time",
            "description": "When the subscription started"
          },
          "expirationDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the subscription expires (null for unlimited)"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether the subscription is currently active"
          },
          "cancelledAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the subscription was cancelled (if applicable)"
          },
          "cancellationReason": {
            "type": "string",
            "nullable": true,
            "description": "Reason for cancellation (if applicable)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the subscription was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the subscription was last updated"
          }
        }
      },
      "SubscriptionListResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response containing list of subscriptions",
        "required": [
          "subscriptions",
          "totalCount"
        ],
        "properties": {
          "subscriptions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SubscriptionInfo"
            },
            "description": "List of subscriptions matching the filter criteria"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of subscriptions matching the filter"
          }
        }
      },
      "SubscriptionResponse": {
        "description": "Current subscription status and plan details for an account",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "status",
          "type"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "active",
              "inactive",
              "trial",
              "expired"
            ],
            "description": "Current state of the subscription"
          },
          "type": {
            "type": "string",
            "enum": [
              "free",
              "basic",
              "premium",
              "lifetime"
            ],
            "description": "Subscription tier or plan type"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Date and time when the subscription expires"
          },
          "autoRenew": {
            "type": "boolean",
            "description": "Whether automatic renewal is enabled"
          },
          "benefits": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of benefits included in the subscription"
          }
        }
      },
      "SuggestRelatedRequest": {
        "description": "Request to get related topic suggestions based on a source",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "suggestionSource"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace for suggestions"
          },
          "suggestionSource": {
            "$ref": "#/components/schemas/SuggestionSource",
            "description": "Type of source to base suggestions on"
          },
          "sourceValue": {
            "type": "string",
            "description": "The value for the suggestion source (document ID, slug, topic, or category)"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Optional session ID for personalized suggestions"
          },
          "maxSuggestions": {
            "type": "integer",
            "default": 5,
            "minimum": 1,
            "maximum": 10,
            "description": "Maximum number of suggestions to return"
          },
          "excludeRecentlyViewed": {
            "type": "boolean",
            "default": true,
            "description": "Exclude documents viewed in current session"
          }
        }
      },
      "SuggestRelatedResponse": {
        "description": "Response containing suggested related topics for conversational flow",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "suggestions"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "description": "The namespace suggestions are from"
          },
          "suggestions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TopicSuggestion"
            },
            "description": "List of suggested related topics"
          },
          "voicePrompt": {
            "type": "string",
            "description": "Voice-friendly prompt for presenting suggestions"
          },
          "sessionInfluenced": {
            "type": "boolean",
            "description": "Whether suggestions were influenced by session history"
          }
        }
      },
      "SuggestionSource": {
        "type": "string",
        "enum": [
          "document_id",
          "slug",
          "topic",
          "category"
        ],
        "description": "Source type for generating related topic suggestions"
      },
      "SyncInfo": {
        "description": "Information about a repository sync operation",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "syncId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the sync operation"
          },
          "status": {
            "$ref": "#/components/schemas/SyncStatus",
            "description": "Result status of the sync"
          },
          "triggeredBy": {
            "$ref": "#/components/schemas/SyncTrigger",
            "description": "What triggered the sync"
          },
          "startedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when sync started"
          },
          "completedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when sync completed"
          },
          "commitHash": {
            "type": "string",
            "nullable": true,
            "description": "Git commit hash that was synced (null if sync failed or repo is empty)"
          },
          "documentsProcessed": {
            "type": "integer",
            "description": "Total documents processed in sync"
          }
        }
      },
      "SyncRepositoryRequest": {
        "description": "Request to trigger a manual repository sync",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to sync"
          },
          "force": {
            "type": "boolean",
            "default": false,
            "description": "Force full re-sync even if commit hash unchanged"
          }
        }
      },
      "SyncRepositoryResponse": {
        "description": "Response containing sync operation results and statistics",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "syncId",
          "status"
        ],
        "properties": {
          "syncId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of this sync operation"
          },
          "status": {
            "$ref": "#/components/schemas/SyncStatus",
            "description": "Result status of the sync"
          },
          "commitHash": {
            "type": "string",
            "nullable": true,
            "description": "Git commit hash that was synced (null if sync failed or repo is empty)"
          },
          "documentsCreated": {
            "type": "integer",
            "description": "Number of new documents created"
          },
          "documentsUpdated": {
            "type": "integer",
            "description": "Number of existing documents updated"
          },
          "documentsDeleted": {
            "type": "integer",
            "description": "Number of documents deleted"
          },
          "documentsFailed": {
            "type": "integer",
            "description": "Number of documents that failed to process"
          },
          "durationMs": {
            "type": "integer",
            "description": "Time taken for sync in milliseconds"
          },
          "errorMessage": {
            "type": "string",
            "nullable": true,
            "description": "Error message if sync failed"
          }
        }
      },
      "SyncStatus": {
        "type": "string",
        "description": "Status of platform synchronization",
        "enum": [
          "pending",
          "synced",
          "failed",
          "not_linked"
        ]
      },
      "SyncTrigger": {
        "type": "string",
        "enum": [
          "manual",
          "scheduled"
        ],
        "description": "What triggered the sync operation"
      },
      "TempoEvent": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.TempoEvent",
        "description": "A tempo change event",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "tick",
          "bpm"
        ],
        "properties": {
          "tick": {
            "type": "integer",
            "minimum": 0,
            "description": "Tick position"
          },
          "bpm": {
            "type": "number",
            "format": "float",
            "minimum": 20,
            "maximum": 400,
            "description": "Tempo in BPM"
          }
        }
      },
      "TempoRange": {
        "description": "A tempo range with min and max BPM",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "min",
          "max"
        ],
        "properties": {
          "min": {
            "type": "integer",
            "minimum": 20,
            "maximum": 400,
            "description": "Minimum tempo"
          },
          "max": {
            "type": "integer",
            "minimum": 20,
            "maximum": 400,
            "description": "Maximum tempo"
          }
        }
      },
      "TerminateContractInstanceRequest": {
        "type": "object",
        "description": "Request to terminate a contract",
        "additionalProperties": false,
        "required": [
          "contractId",
          "requestingEntityId",
          "requestingEntityType"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract to terminate"
          },
          "requestingEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity requesting termination"
          },
          "requestingEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of requesting entity"
          },
          "reason": {
            "type": "string",
            "maxLength": 1000,
            "nullable": true,
            "description": "Reason for termination"
          }
        }
      },
      "TerminateSessionRequest": {
        "type": "object",
        "description": "Request to terminate a specific session",
        "additionalProperties": false,
        "required": [
          "sessionId"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the session to terminate"
          }
        }
      },
      "TerminationPolicy": {
        "type": "string",
        "description": "How the contract can be terminated",
        "enum": [
          "mutual_consent",
          "unilateral_with_notice",
          "unilateral_immediate",
          "non_terminable"
        ]
      },
      "ThemeConfig": {
        "description": "Visual theme configuration including colors, fonts, and navigation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "themeName",
          "primaryColor"
        ],
        "properties": {
          "themeName": {
            "type": "string",
            "description": "Name of the active theme"
          },
          "primaryColor": {
            "type": "string",
            "pattern": "^#[0-9A-Fa-f]{6}$",
            "description": "Primary brand color in hex format"
          },
          "secondaryColor": {
            "type": "string",
            "pattern": "^#[0-9A-Fa-f]{6}$",
            "description": "Secondary brand color in hex format"
          },
          "backgroundColor": {
            "type": "string",
            "pattern": "^#[0-9A-Fa-f]{6}$",
            "description": "Default background color in hex format"
          },
          "textColor": {
            "type": "string",
            "pattern": "^#[0-9A-Fa-f]{6}$",
            "description": "Default text color in hex format"
          },
          "fontFamily": {
            "type": "string",
            "description": "Primary font family for the site"
          },
          "customCSS": {
            "type": "string",
            "nullable": true,
            "description": "Additional custom CSS styles"
          },
          "logo": {
            "description": "Site logo configuration for branding",
            "$ref": "#/components/schemas/Logo"
          },
          "favicon": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "URL of the site favicon"
          },
          "navigation": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NavigationItem"
            },
            "description": "Main navigation menu items"
          }
        }
      },
      "TicketStatus": {
        "type": "string",
        "description": "Current status of a matchmaking ticket",
        "enum": [
          "searching",
          "match_found",
          "match_accepted",
          "cancelled",
          "expired"
        ]
      },
      "TimeSignatureEvent": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.TimeSignatureEvent",
        "description": "A time signature change event",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "tick",
          "numerator",
          "denominator"
        ],
        "properties": {
          "tick": {
            "type": "integer",
            "minimum": 0,
            "description": "Tick position"
          },
          "numerator": {
            "type": "integer",
            "minimum": 1,
            "maximum": 32,
            "description": "Beats per measure"
          },
          "denominator": {
            "type": "integer",
            "minimum": 1,
            "maximum": 32,
            "description": "Beat unit (4 = quarter, 8 = eighth)"
          }
        }
      },
      "TopicSuggestion": {
        "description": "A suggested related topic with relevance context",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "documentId",
          "title"
        ],
        "properties": {
          "documentId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the suggested document"
          },
          "slug": {
            "type": "string",
            "description": "URL-friendly slug of the suggested document"
          },
          "title": {
            "type": "string",
            "description": "Title of the suggested document"
          },
          "category": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "Category of the suggested document"
          },
          "relevanceReason": {
            "type": "string",
            "description": "Explanation of why this document is relevant"
          }
        }
      },
      "TraitAxis": {
        "type": "string",
        "description": "Core personality trait axes. Each represents a spectrum from -1.0 to +1.0.\nBased on psychological research (Big Five + game-relevant extensions).\n",
        "enum": [
          "OPENNESS",
          "CONSCIENTIOUSNESS",
          "EXTRAVERSION",
          "AGREEABLENESS",
          "NEUROTICISM",
          "HONESTY",
          "AGGRESSION",
          "LOYALTY"
        ]
      },
      "TraitValue": {
        "type": "object",
        "description": "A single personality trait with its current value and evolution history",
        "additionalProperties": false,
        "required": [
          "axis",
          "value"
        ],
        "properties": {
          "axis": {
            "$ref": "#/components/schemas/TraitAxis",
            "description": "The personality axis this value represents"
          },
          "value": {
            "type": "number",
            "format": "float",
            "minimum": -1.0,
            "maximum": 1.0,
            "description": "Current trait value on the spectrum (-1.0 to +1.0)"
          },
          "lastChangedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this trait last evolved (null if never changed since creation)"
          },
          "changeCount": {
            "type": "integer",
            "default": 0,
            "description": "Number of times this trait has evolved"
          }
        }
      },
      "TransactionResponse": {
        "type": "object",
        "description": "Transaction details",
        "additionalProperties": false,
        "required": [
          "transaction"
        ],
        "properties": {
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Transaction record"
          }
        }
      },
      "TransactionType": {
        "type": "string",
        "description": "Classification of the currency transaction",
        "enum": [
          "mint",
          "quest_reward",
          "loot_drop",
          "vendor_sale",
          "autogain",
          "refund",
          "conversion_credit",
          "burn",
          "vendor_purchase",
          "fee",
          "expiration",
          "cap_overflow",
          "conversion_debit",
          "transfer",
          "trade",
          "gift",
          "escrow_deposit",
          "escrow_release",
          "escrow_refund"
        ]
      },
      "TransferContractPartyRequest": {
        "type": "object",
        "description": "Request to transfer a party role to a new entity",
        "additionalProperties": false,
        "required": [
          "contractInstanceId",
          "fromEntityId",
          "fromEntityType",
          "toEntityId",
          "toEntityType",
          "guardianId",
          "guardianType"
        ],
        "properties": {
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "fromEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "Current party entity ID"
          },
          "fromEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Current party entity type"
          },
          "toEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "New entity ID to receive the role"
          },
          "toEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "New entity type"
          },
          "guardianId": {
            "type": "string",
            "format": "uuid",
            "description": "Guardian entity ID (must be current guardian)"
          },
          "guardianType": {
            "type": "string",
            "maxLength": 64,
            "description": "Guardian entity type"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Optional idempotency key for the operation"
          }
        }
      },
      "TransferContractPartyResponse": {
        "type": "object",
        "description": "Response from transferring a party role",
        "additionalProperties": false,
        "required": [
          "transferred",
          "contractId"
        ],
        "properties": {
          "transferred": {
            "type": "boolean",
            "description": "Whether the transfer was successful"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "role": {
            "type": "string",
            "description": "Role that was transferred"
          },
          "fromEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "Previous party entity ID"
          },
          "toEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "New party entity ID"
          }
        }
      },
      "TransferCurrencyRequest": {
        "type": "object",
        "description": "Request to transfer currency between wallets",
        "additionalProperties": false,
        "required": [
          "sourceWalletId",
          "targetWalletId",
          "currencyDefinitionId",
          "amount",
          "transactionType",
          "idempotencyKey"
        ],
        "properties": {
          "sourceWalletId": {
            "type": "string",
            "format": "uuid",
            "description": "Source wallet ID"
          },
          "targetWalletId": {
            "type": "string",
            "format": "uuid",
            "description": "Target wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to transfer"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to transfer (must be positive)"
          },
          "transactionType": {
            "$ref": "#/components/schemas/TransactionType",
            "description": "Must be a transfer type (transfer, trade, gift)"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "What triggered this transfer"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference entity ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Unique key to prevent duplicate processing"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Free-form transaction metadata"
          }
        }
      },
      "TransferCurrencyResponse": {
        "type": "object",
        "description": "Result of transfer operation",
        "additionalProperties": false,
        "required": [
          "transaction",
          "sourceNewBalance",
          "targetNewBalance",
          "targetCapApplied"
        ],
        "properties": {
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Created transaction record"
          },
          "sourceNewBalance": {
            "type": "number",
            "format": "double",
            "description": "Source wallet balance after transfer"
          },
          "targetNewBalance": {
            "type": "number",
            "format": "double",
            "description": "Target wallet balance after transfer"
          },
          "targetCapApplied": {
            "type": "boolean",
            "description": "Whether target wallet cap was applied"
          },
          "targetCapAmountLost": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Amount lost due to target wallet cap"
          }
        }
      },
      "TransferItemRequest": {
        "type": "object",
        "description": "Request to transfer item ownership",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "targetContainerId"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance ID"
          },
          "targetContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "Target container ID"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Quantity to transfer (all if null)"
          }
        }
      },
      "TransferItemResponse": {
        "type": "object",
        "description": "Response after transfer",
        "additionalProperties": false,
        "required": [
          "success",
          "instanceId",
          "sourceContainerId",
          "targetContainerId",
          "quantityTransferred"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether transfer succeeded"
          },
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Transferred item ID"
          },
          "sourceContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "Previous container"
          },
          "targetContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "New container"
          },
          "quantityTransferred": {
            "type": "number",
            "format": "double",
            "description": "Amount transferred"
          }
        }
      },
      "TransferResult": {
        "type": "object",
        "description": "Result of transferring assets to a party during resolution",
        "required": [
          "partyId",
          "success"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party ID"
          },
          "assets": {
            "$ref": "#/components/schemas/EscrowAssetBundle",
            "description": "Assets transferred (null if failed)",
            "nullable": true
          },
          "success": {
            "type": "boolean",
            "description": "Whether transfer succeeded"
          },
          "error": {
            "type": "string",
            "nullable": true,
            "description": "Error message if failed"
          }
        }
      },
      "Transform": {
        "type": "object",
        "description": "Position, rotation, and scale in 3D space",
        "required": [
          "position",
          "rotation",
          "scale"
        ],
        "properties": {
          "position": {
            "$ref": "#/components/schemas/Vector3",
            "description": "Position relative to parent"
          },
          "rotation": {
            "$ref": "#/components/schemas/Quaternion",
            "description": "Rotation relative to parent"
          },
          "scale": {
            "$ref": "#/components/schemas/Vector3",
            "description": "Scale relative to parent"
          }
        }
      },
      "TuneType": {
        "description": "A style-specific tune type definition",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "name",
          "meter"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Tune type name (e.g., \"reel\", \"jig\")"
          },
          "meter": {
            "$ref": "#/components/schemas/TimeSignatureEvent",
            "description": "Time signature for this tune type"
          },
          "tempoRange": {
            "$ref": "#/components/schemas/TempoRange",
            "nullable": true,
            "description": "Typical tempo range"
          },
          "defaultForm": {
            "type": "string",
            "nullable": true,
            "description": "Default form for this tune type"
          },
          "rhythmPatterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Rhythm pattern names to use"
          }
        }
      },
      "UnlockContractRequest": {
        "type": "object",
        "description": "Request to unlock a contract from guardian custody",
        "additionalProperties": false,
        "required": [
          "contractInstanceId",
          "guardianId",
          "guardianType"
        ],
        "properties": {
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID to unlock"
          },
          "guardianId": {
            "type": "string",
            "format": "uuid",
            "description": "Guardian entity ID (must match current guardian)"
          },
          "guardianType": {
            "type": "string",
            "maxLength": 64,
            "description": "Guardian entity type"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Optional idempotency key for the operation"
          }
        }
      },
      "UnlockContractResponse": {
        "type": "object",
        "description": "Response from unlocking a contract",
        "additionalProperties": false,
        "required": [
          "unlocked",
          "contractId"
        ],
        "properties": {
          "unlocked": {
            "type": "boolean",
            "description": "Whether the contract was unlocked"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          }
        }
      },
      "UnlockedAchievement": {
        "type": "object",
        "description": "An unlocked achievement instance",
        "additionalProperties": false,
        "required": [
          "achievementId",
          "displayName",
          "points",
          "unlockedAt"
        ],
        "properties": {
          "achievementId": {
            "type": "string",
            "description": "Achievement identifier"
          },
          "displayName": {
            "type": "string",
            "description": "Achievement name"
          },
          "description": {
            "type": "string",
            "description": "Achievement description"
          },
          "points": {
            "type": "integer",
            "description": "Point value"
          },
          "iconUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "Achievement icon"
          },
          "unlockedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When it was unlocked"
          }
        }
      },
      "UnpinVersionRequest": {
        "type": "object",
        "description": "Request to unpin a previously pinned save version",
        "required": [
          "ownerId",
          "ownerType",
          "slotName",
          "versionNumber"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Version to unpin"
          }
        }
      },
      "UnresolvedReference": {
        "type": "object",
        "description": "A scene reference that could not be resolved",
        "required": [
          "nodeId",
          "refId",
          "referencedSceneId",
          "reason"
        ],
        "properties": {
          "nodeId": {
            "type": "string",
            "format": "uuid",
            "description": "Node ID containing the reference"
          },
          "refId": {
            "type": "string",
            "description": "refId of the referencing node"
          },
          "referencedSceneId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the scene that could not be resolved"
          },
          "reason": {
            "$ref": "#/components/schemas/UnresolvedReferenceReason",
            "description": "Why the reference could not be resolved"
          },
          "cyclePath": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "For circular references, the cycle path (sceneId chain)"
          }
        }
      },
      "UnresolvedReferenceReason": {
        "type": "string",
        "description": "Reason why a scene reference could not be resolved",
        "enum": [
          "not_found",
          "circular_reference",
          "depth_exceeded",
          "access_denied"
        ]
      },
      "UpdateAchievementDefinitionRequest": {
        "type": "object",
        "description": "Request to update an achievement definition",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "achievementId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "achievementId": {
            "type": "string",
            "description": "ID of the achievement to update"
          },
          "displayName": {
            "type": "string",
            "maxLength": 100,
            "nullable": true,
            "description": "New display name"
          },
          "description": {
            "type": "string",
            "maxLength": 500,
            "nullable": true,
            "description": "New description"
          },
          "isActive": {
            "type": "boolean",
            "nullable": true,
            "description": "New active status"
          },
          "platformIds": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Updated platform ID mappings"
          }
        }
      },
      "UpdateActorTemplateRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to update an existing actor template",
        "required": [
          "templateId"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the template to update"
          },
          "behaviorRef": {
            "type": "string",
            "nullable": true,
            "description": "New behavior reference (triggers behavior.updated subscription)"
          },
          "configuration": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Updated configuration settings"
          },
          "autoSpawn": {
            "description": "Updated auto-spawn configuration",
            "nullable": true,
            "$ref": "#/components/schemas/AutoSpawnConfig"
          },
          "tickIntervalMs": {
            "type": "integer",
            "nullable": true,
            "description": "Updated tick interval in milliseconds"
          },
          "autoSaveIntervalSeconds": {
            "type": "integer",
            "nullable": true,
            "description": "Updated auto-save interval in seconds"
          }
        }
      },
      "UpdateBundleRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to update bundle metadata",
        "required": [
          "bundleId"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Bundle identifier to update"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "New bundle name (null to leave unchanged)"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "New bundle description (null to leave unchanged)"
          },
          "tags": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Replace all tags with these (null to leave unchanged)"
          },
          "addTags": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Tags to add (merged with existing)"
          },
          "removeTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Tag keys to remove"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for the update (recorded in version history)"
          }
        }
      },
      "UpdateBundleResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of bundle update operation",
        "required": [
          "bundleId",
          "version",
          "previousVersion",
          "changes"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Updated bundle identifier"
          },
          "version": {
            "type": "integer",
            "description": "New version number after update"
          },
          "previousVersion": {
            "type": "integer",
            "description": "Version number before update"
          },
          "changes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of changes made (e.g., \"name changed\", \"tag 'env' added\")"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the update occurred"
          }
        }
      },
      "UpdateContainerRequest": {
        "type": "object",
        "description": "Request to update container properties",
        "additionalProperties": false,
        "required": [
          "containerId"
        ],
        "properties": {
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container ID to update"
          },
          "maxSlots": {
            "type": "integer",
            "nullable": true,
            "description": "New max slots"
          },
          "maxWeight": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "New max weight"
          },
          "gridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "New grid width"
          },
          "gridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "New grid height"
          },
          "maxVolume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "New max volume"
          },
          "allowedCategories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New allowed categories"
          },
          "forbiddenCategories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New forbidden categories"
          },
          "allowedTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New allowed tags"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New container tags"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "description": "New metadata"
          }
        }
      },
      "UpdateContractMetadataRequest": {
        "type": "object",
        "description": "Request to update contract metadata",
        "additionalProperties": false,
        "required": [
          "contractId",
          "metadataType",
          "data"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "metadataType": {
            "$ref": "#/components/schemas/MetadataType",
            "description": "Which metadata to update"
          },
          "data": {
            "type": "object",
            "additionalProperties": true,
            "description": "Metadata to set or merge"
          }
        }
      },
      "UpdateDefinitionRequest": {
        "type": "object",
        "description": "Request to update a map definition",
        "required": [
          "definitionId"
        ],
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Definition ID to update"
          },
          "name": {
            "type": "string",
            "description": "New name (optional)",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "New description (optional)",
            "nullable": true
          },
          "layers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LayerDefinition"
            },
            "description": "New layer configurations (replaces existing)",
            "nullable": true
          },
          "defaultBounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "New default bounds",
            "nullable": true
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "description": "New metadata (replaces existing)",
            "nullable": true
          }
        }
      },
      "UpdateEncounterPhaseRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to update the phase of an active encounter",
        "required": [
          "actorId",
          "phase"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "ID of the Event Brain actor managing the encounter"
          },
          "phase": {
            "type": "string",
            "description": "New phase name for the encounter"
          }
        }
      },
      "UpdateEncounterPhaseResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response after updating encounter phase",
        "required": [
          "actorId",
          "currentPhase"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "ID of the actor managing the encounter"
          },
          "previousPhase": {
            "type": "string",
            "nullable": true,
            "description": "Previous phase name"
          },
          "currentPhase": {
            "type": "string",
            "description": "Current phase name after update"
          }
        }
      },
      "UpdateItemTemplateRequest": {
        "type": "object",
        "description": "Request to update mutable fields of an item template",
        "additionalProperties": false,
        "required": [
          "templateId"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template ID to update"
          },
          "name": {
            "type": "string",
            "maxLength": 128,
            "nullable": true,
            "description": "New display name"
          },
          "description": {
            "type": "string",
            "maxLength": 1000,
            "nullable": true,
            "description": "New description"
          },
          "subcategory": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "New subcategory"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New tags (replaces existing)"
          },
          "rarity": {
            "$ref": "#/components/schemas/ItemRarity",
            "description": "New rarity tier"
          },
          "weight": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "New weight value"
          },
          "volume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "New volume value"
          },
          "gridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "New grid width"
          },
          "gridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "New grid height"
          },
          "canRotate": {
            "type": "boolean",
            "nullable": true,
            "description": "New rotation setting"
          },
          "baseValue": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "New base value"
          },
          "tradeable": {
            "type": "boolean",
            "nullable": true,
            "description": "New tradeable setting"
          },
          "destroyable": {
            "type": "boolean",
            "nullable": true,
            "description": "New destroyable setting"
          },
          "maxDurability": {
            "type": "integer",
            "nullable": true,
            "description": "New max durability"
          },
          "availableRealms": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "New available realms"
          },
          "stats": {
            "type": "object",
            "nullable": true,
            "description": "New stats"
          },
          "effects": {
            "type": "object",
            "nullable": true,
            "description": "New effects"
          },
          "requirements": {
            "type": "object",
            "nullable": true,
            "description": "New requirements"
          },
          "display": {
            "type": "object",
            "nullable": true,
            "description": "New display properties"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "description": "New metadata"
          },
          "isActive": {
            "type": "boolean",
            "nullable": true,
            "description": "Active status"
          }
        }
      },
      "UpdateLeaderboardDefinitionRequest": {
        "type": "object",
        "description": "Request to update a leaderboard definition",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard to update"
          },
          "displayName": {
            "type": "string",
            "maxLength": 100,
            "nullable": true,
            "description": "New display name"
          },
          "description": {
            "type": "string",
            "maxLength": 500,
            "nullable": true,
            "description": "New description"
          },
          "isPublic": {
            "type": "boolean",
            "nullable": true,
            "description": "New visibility setting"
          }
        }
      },
      "UpdateMode": {
        "type": "string",
        "description": "How to handle score updates",
        "enum": [
          "replace",
          "increment",
          "max",
          "min"
        ]
      },
      "UpdatePasswordRequest": {
        "type": "object",
        "description": "Request to update an account password",
        "additionalProperties": false,
        "required": [
          "accountId",
          "passwordHash"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the account to update"
          },
          "passwordHash": {
            "type": "string",
            "description": "New pre-hashed password from Auth service"
          }
        }
      },
      "UpdateProfileRequest": {
        "type": "object",
        "description": "Request to update an account profile",
        "additionalProperties": false,
        "required": [
          "accountId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the account to update"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "maxLength": 100,
            "description": "New display name for the account"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Updated custom metadata for the account"
          }
        }
      },
      "UpdateRepositoryBindingRequest": {
        "description": "Request to update repository binding configuration",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace of the binding to update"
          },
          "syncEnabled": {
            "type": "boolean",
            "description": "Enable or disable automatic syncing"
          },
          "syncIntervalMinutes": {
            "type": "integer",
            "minimum": 5,
            "maximum": 1440,
            "description": "New sync interval in minutes"
          },
          "filePatterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New glob patterns for files to include (null to keep unchanged)"
          },
          "excludePatterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New glob patterns for files to exclude (null to keep unchanged)"
          },
          "categoryMapping": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "New directory-to-category mapping (null to keep unchanged)"
          },
          "defaultCategory": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "New default category for unmapped documents"
          },
          "archiveEnabled": {
            "type": "boolean",
            "description": "Enable or disable archive functionality"
          },
          "archiveOnSync": {
            "type": "boolean",
            "description": "Enable or disable archiving after each sync"
          }
        }
      },
      "UpdateRepositoryBindingResponse": {
        "description": "Response containing the updated binding configuration",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "binding"
        ],
        "properties": {
          "binding": {
            "$ref": "#/components/schemas/RepositoryBindingInfo",
            "description": "Updated binding configuration"
          }
        }
      },
      "UpdateSceneRequest": {
        "type": "object",
        "description": "Request to update an existing scene",
        "required": [
          "scene"
        ],
        "properties": {
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "The updated scene document (sceneId must match existing)"
          },
          "checkoutToken": {
            "type": "string",
            "nullable": true,
            "description": "Checkout token if updating via checkout workflow"
          }
        }
      },
      "UpdateVerificationRequest": {
        "type": "object",
        "description": "Request to update email verification status",
        "additionalProperties": false,
        "required": [
          "accountId",
          "emailVerified"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the account to update"
          },
          "emailVerified": {
            "type": "boolean",
            "description": "New email verification status"
          }
        }
      },
      "UploadRequest": {
        "description": "Request to initiate an asset upload and receive a pre-signed URL",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "filename",
          "size",
          "contentType",
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "string",
            "description": "Owner of this asset operation. NOT a session ID.\nFor user-initiated uploads: the accountId (UUID format).\nFor service-initiated uploads: the service name (e.g., \"behavior\", \"orchestrator\").\n"
          },
          "filename": {
            "type": "string",
            "description": "Original filename with extension"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "File size in bytes"
          },
          "contentType": {
            "type": "string",
            "description": "MIME content type (e.g., image/png, model/gltf-binary)"
          },
          "metadata": {
            "$ref": "#/components/schemas/AssetMetadataInput",
            "description": "Optional metadata for asset categorization"
          }
        }
      },
      "UploadResponse": {
        "description": "Response containing pre-signed URL and configuration for uploading an asset",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "uploadId",
          "uploadUrl",
          "expiresAt"
        ],
        "properties": {
          "uploadId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique upload session identifier"
          },
          "uploadUrl": {
            "type": "string",
            "format": "uri",
            "description": "Pre-signed URL for uploading the file"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the upload URL expires"
          },
          "multipart": {
            "$ref": "#/components/schemas/MultipartConfig",
            "description": "Configuration for multipart uploads if file size requires it"
          },
          "requiredHeaders": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Headers the client must include when uploading to the pre-signed URL"
          }
        }
      },
      "ValidateAbmlRequest": {
        "description": "Request to validate ABML YAML content against schema and semantic rules",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "abmlContent"
        ],
        "properties": {
          "abmlContent": {
            "type": "string",
            "description": "Raw ABML YAML content to validate"
          },
          "strictMode": {
            "type": "boolean",
            "default": false,
            "description": "Enable strict validation mode with enhanced checking"
          }
        }
      },
      "ValidateAbmlResponse": {
        "description": "Response containing the results of ABML validation including errors and warnings",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "isValid"
        ],
        "properties": {
          "isValid": {
            "type": "boolean",
            "description": "Whether the ABML definition is valid"
          },
          "validationErrors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "nullable": true,
            "description": "List of validation errors if invalid"
          },
          "semanticWarnings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Semantic warnings that don't prevent compilation"
          },
          "schemaVersion": {
            "type": "string",
            "nullable": true,
            "description": "ABML schema version used for validation"
          }
        }
      },
      "ValidateDepositRequest": {
        "type": "object",
        "description": "Request to validate a deposit without executing",
        "required": [
          "escrowId",
          "partyId",
          "partyType",
          "assets"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party to validate"
          },
          "partyType": {
            "type": "string",
            "description": "Party type"
          },
          "assets": {
            "$ref": "#/components/schemas/EscrowAssetBundleInput",
            "description": "Assets to validate"
          }
        }
      },
      "ValidateDepositResponse": {
        "type": "object",
        "description": "Response from deposit validation",
        "required": [
          "valid",
          "errors",
          "warnings"
        ],
        "properties": {
          "valid": {
            "type": "boolean",
            "description": "Whether the deposit would be valid"
          },
          "errors": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Validation errors"
          },
          "warnings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Validation warnings"
          }
        }
      },
      "ValidateGoapPlanRequest": {
        "description": "Request to validate an existing GOAP plan against current world state",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "plan",
          "currentActionIndex",
          "worldState"
        ],
        "properties": {
          "plan": {
            "$ref": "#/components/schemas/GoapPlanResult",
            "description": "The plan to validate"
          },
          "currentActionIndex": {
            "type": "integer",
            "description": "Index of the action currently being executed"
          },
          "worldState": {
            "type": "object",
            "additionalProperties": true,
            "description": "Current world state"
          },
          "activeGoals": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GoapGoal"
            },
            "nullable": true,
            "description": "All active goals for priority checking"
          }
        }
      },
      "ValidateGoapPlanResponse": {
        "description": "Response indicating whether a GOAP plan is still valid and suggested next action",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "isValid",
          "reason",
          "suggestedAction"
        ],
        "properties": {
          "isValid": {
            "type": "boolean",
            "description": "Whether the plan is still valid"
          },
          "reason": {
            "type": "string",
            "enum": [
              "none",
              "preconditionInvalidated",
              "actionFailed",
              "betterGoalAvailable",
              "planCompleted",
              "goalAlreadySatisfied",
              "suboptimalPlan"
            ],
            "description": "Reason for the validation result"
          },
          "suggestedAction": {
            "type": "string",
            "enum": [
              "continue",
              "replan",
              "abort"
            ],
            "description": "Suggested action based on validation"
          },
          "invalidatedAtIndex": {
            "type": "integer",
            "description": "Index where plan became invalid (if applicable)"
          },
          "message": {
            "type": "string",
            "nullable": true,
            "description": "Additional details about the validation result. Null when no additional context is needed."
          }
        }
      },
      "ValidateMidiJsonRequest": {
        "description": "Request to validate MIDI-JSON structure",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "midiJson"
        ],
        "properties": {
          "midiJson": {
            "$ref": "#/components/schemas/MidiJson",
            "description": "MIDI-JSON structure to validate"
          },
          "strictMode": {
            "type": "boolean",
            "default": false,
            "description": "Enable strict validation with additional checks"
          }
        }
      },
      "ValidateMidiJsonResponse": {
        "description": "Response containing validation results",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "isValid"
        ],
        "properties": {
          "isValid": {
            "type": "boolean",
            "description": "Whether the MIDI-JSON is valid"
          },
          "errors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "nullable": true,
            "description": "Validation errors if invalid"
          },
          "warnings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Non-fatal warnings"
          }
        }
      },
      "ValidateSceneRequest": {
        "type": "object",
        "description": "Request to validate a scene structure",
        "required": [
          "scene"
        ],
        "properties": {
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "The scene to validate"
          },
          "applyGameRules": {
            "type": "boolean",
            "default": true,
            "description": "Whether to apply registered game-specific validation rules"
          }
        }
      },
      "ValidateTokenResponse": {
        "description": "Response from token validation containing validity status and associated account details",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "valid",
          "accountId",
          "sessionId"
        ],
        "properties": {
          "valid": {
            "type": "boolean",
            "description": "Whether the token is valid and not expired"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the account associated with the token"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Session identifier for WebSocket connections and service routing"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "List of roles assigned to the authenticated user"
          },
          "authorizations": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Authorization strings from active subscriptions.\nFormat: \"{stubName}:{state}\" (e.g., \"arcadia:authorized\")\n"
          },
          "remainingTime": {
            "type": "integer",
            "description": "Seconds until expiration"
          }
        }
      },
      "ValidationCondition": {
        "type": "object",
        "description": "A single condition to check against an API response",
        "additionalProperties": false,
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ValidationConditionType"
              }
            ],
            "description": "The type of validation condition to check"
          },
          "jsonPath": {
            "type": "string",
            "nullable": true,
            "description": "JsonPath expression to extract value from response.\nRequired for jsonPathEquals, jsonPathExists, jsonPathNotExists.\nExample: \"$.balance\", \"$.items[0].status\"\n"
          },
          "expectedValue": {
            "type": "string",
            "nullable": true,
            "description": "Expected value for comparison conditions.\nType coercion applied: \"true\"/\"false\" for booleans, numeric strings for numbers.\n"
          },
          "operator": {
            "$ref": "#/components/schemas/ComparisonOperator",
            "nullable": true,
            "description": "Comparison operator for numeric comparisons"
          },
          "statusCodes": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "HTTP status codes for statusCodeIn condition"
          }
        }
      },
      "ValidationConditionType": {
        "type": "string",
        "description": "Type of validation condition",
        "enum": [
          "statusCodeIn",
          "jsonPathEquals",
          "jsonPathNotEquals",
          "jsonPathExists",
          "jsonPathNotExists",
          "jsonPathGreaterThan",
          "jsonPathLessThan",
          "jsonPathContains"
        ]
      },
      "ValidationError": {
        "description": "Detailed validation error with type, location, and message information",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "type",
          "message"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "syntax",
              "semantic",
              "schema",
              "context",
              "service_dependency"
            ],
            "description": "Type of validation error"
          },
          "message": {
            "type": "string",
            "description": "Human-readable error message"
          },
          "lineNumber": {
            "type": "integer",
            "description": "Line number where the error occurred (if applicable)"
          },
          "columnNumber": {
            "type": "integer",
            "description": "Column number where the error occurred (if applicable)"
          },
          "yamlPath": {
            "type": "string",
            "nullable": true,
            "description": "YAML path to the problematic element",
            "example": "behaviors.morning_startup.actions[0]"
          }
        }
      },
      "ValidationFailure": {
        "type": "object",
        "description": "Records a validation check failure",
        "required": [
          "detectedAt",
          "assetType",
          "assetDescription",
          "failureType",
          "affectedPartyId",
          "affectedPartyType"
        ],
        "properties": {
          "detectedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the failure was detected"
          },
          "assetType": {
            "type": "string",
            "description": "Type of asset affected"
          },
          "assetDescription": {
            "type": "string",
            "description": "Description of the affected asset"
          },
          "failureType": {
            "$ref": "#/components/schemas/ValidationFailureType",
            "description": "Type of validation failure"
          },
          "affectedPartyId": {
            "type": "string",
            "format": "uuid",
            "description": "Which party deposit is affected"
          },
          "affectedPartyType": {
            "type": "string",
            "description": "Type of the affected party"
          },
          "details": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Additional failure details"
          }
        }
      },
      "ValidationFailureType": {
        "type": "string",
        "description": "Type of validation failure detected.\n- asset_missing: Asset no longer exists in escrow custody\n- asset_mutated: Asset properties changed (e.g., item durability)\n- asset_expired: Asset has a time-based expiration that triggered\n- balance_mismatch: Wallet balance does not match expected held amount\n",
        "enum": [
          "asset_missing",
          "asset_mutated",
          "asset_expired",
          "balance_mismatch"
        ]
      },
      "ValidationResult": {
        "type": "object",
        "description": "Result of scene validation",
        "required": [
          "valid"
        ],
        "properties": {
          "valid": {
            "type": "boolean",
            "description": "Whether the scene passed all validation checks"
          },
          "errors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "nullable": true,
            "description": "Validation errors (severity = error)"
          },
          "warnings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "nullable": true,
            "description": "Validation warnings (severity = warning)"
          }
        }
      },
      "ValidationRule": {
        "type": "object",
        "description": "A validation rule definition",
        "required": [
          "ruleId",
          "description",
          "severity",
          "ruleType"
        ],
        "properties": {
          "ruleId": {
            "type": "string",
            "description": "Unique rule identifier within the gameId+sceneType"
          },
          "description": {
            "type": "string",
            "description": "Human-readable description of the rule"
          },
          "severity": {
            "$ref": "#/components/schemas/ValidationSeverity",
            "description": "Whether violation is an error or warning"
          },
          "ruleType": {
            "$ref": "#/components/schemas/ValidationRuleType",
            "description": "Type of validation check"
          },
          "config": {
            "$ref": "#/components/schemas/ValidationRuleConfig",
            "nullable": true,
            "description": "Rule-specific configuration"
          }
        }
      },
      "ValidationRuleConfig": {
        "type": "object",
        "description": "Configuration for a validation rule",
        "properties": {
          "nodeType": {
            "type": "string",
            "nullable": true,
            "description": "Filter to nodes of this type (for require_tag)"
          },
          "tag": {
            "type": "string",
            "nullable": true,
            "description": "Tag to check for"
          },
          "minCount": {
            "type": "integer",
            "nullable": true,
            "description": "Minimum occurrences required"
          },
          "maxCount": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum occurrences allowed"
          },
          "annotationPath": {
            "type": "string",
            "nullable": true,
            "description": "JSONPath to required annotation field (for require_annotation)"
          },
          "expression": {
            "type": "string",
            "nullable": true,
            "description": "Custom validation expression (for custom_expression)"
          }
        }
      },
      "ValidationRuleType": {
        "type": "string",
        "description": "Type of validation check to perform",
        "enum": [
          "require_tag",
          "require_node_type",
          "forbid_tag",
          "require_annotation",
          "custom_expression"
        ]
      },
      "ValidationSeverity": {
        "type": "string",
        "description": "Severity level of a validation issue",
        "enum": [
          "error",
          "warning"
        ]
      },
      "Vector3": {
        "type": "object",
        "description": "A point or direction in 3D space",
        "required": [
          "x",
          "y",
          "z"
        ],
        "properties": {
          "x": {
            "type": "number",
            "format": "double",
            "description": "X coordinate"
          },
          "y": {
            "type": "number",
            "format": "double",
            "description": "Y coordinate"
          },
          "z": {
            "type": "number",
            "format": "double",
            "description": "Z coordinate"
          }
        }
      },
      "VerifyConditionRequest": {
        "type": "object",
        "description": "Request to verify a condition for conditional escrow",
        "required": [
          "escrowId",
          "conditionMet",
          "verifierId",
          "verifierType",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "conditionMet": {
            "type": "boolean",
            "description": "Whether the condition was met"
          },
          "verifierId": {
            "type": "string",
            "format": "uuid",
            "description": "Verifier entity ID"
          },
          "verifierType": {
            "type": "string",
            "description": "Verifier entity type"
          },
          "verificationData": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Proof/evidence data"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "VerifyConditionResponse": {
        "type": "object",
        "description": "Response from verifying a condition on an escrow",
        "required": [
          "escrow",
          "triggered"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Updated escrow agreement"
          },
          "triggered": {
            "type": "boolean",
            "description": "Whether this triggered release/refund"
          }
        }
      },
      "VerifyIntegrityRequest": {
        "type": "object",
        "description": "Request to verify data integrity of a save version via hash comparison",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Name of the slot to verify"
          },
          "versionNumber": {
            "type": "integer",
            "nullable": true,
            "description": "Version to verify (latest if null)"
          }
        }
      },
      "VerifyIntegrityResponse": {
        "type": "object",
        "description": "Result of integrity verification with hash comparison details",
        "required": [
          "valid",
          "versionNumber"
        ],
        "properties": {
          "valid": {
            "type": "boolean",
            "description": "Whether integrity check passed"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Version that was verified"
          },
          "expectedHash": {
            "type": "string",
            "description": "Expected SHA-256 hash"
          },
          "actualHash": {
            "type": "string",
            "nullable": true,
            "description": "Actual hash (null if data unavailable)"
          },
          "errorMessage": {
            "type": "string",
            "nullable": true,
            "description": "Error details if verification failed"
          }
        }
      },
      "VersionInfo": {
        "type": "object",
        "description": "Information about a specific version",
        "required": [
          "version",
          "createdAt"
        ],
        "properties": {
          "version": {
            "type": "string",
            "description": "Version string"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this version was created"
          },
          "createdBy": {
            "type": "string",
            "nullable": true,
            "description": "Who created this version"
          },
          "changesSummary": {
            "type": "string",
            "nullable": true,
            "description": "Summary of changes"
          },
          "nodeCount": {
            "type": "integer",
            "description": "Node count at this version"
          }
        }
      },
      "VersionResponse": {
        "type": "object",
        "description": "Metadata for a single save version including size and checkpoint info",
        "required": [
          "versionNumber",
          "contentHash",
          "sizeBytes",
          "createdAt"
        ],
        "properties": {
          "versionNumber": {
            "type": "integer",
            "description": "Version number"
          },
          "assetId": {
            "type": "string",
            "format": "uuid",
            "description": "Reference to asset in lib-asset"
          },
          "contentHash": {
            "type": "string",
            "description": "SHA-256 hash"
          },
          "sizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Size in bytes"
          },
          "compressedSizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Compressed size if applicable"
          },
          "schemaVersion": {
            "type": "string",
            "nullable": true,
            "description": "Schema version"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable name"
          },
          "pinned": {
            "type": "boolean",
            "description": "Whether version is pinned"
          },
          "checkpointName": {
            "type": "string",
            "nullable": true,
            "description": "Checkpoint name if pinned"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom metadata"
          }
        }
      },
      "VoiceLeadRequest": {
        "description": "Request to apply voice leading to a chord sequence",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "chords",
          "voiceCount"
        ],
        "properties": {
          "chords": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChordSymbol"
            },
            "description": "Chord symbols to voice"
          },
          "voiceCount": {
            "type": "integer",
            "minimum": 2,
            "maximum": 8,
            "description": "Number of voices"
          },
          "ranges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PitchRange"
            },
            "nullable": true,
            "description": "Pitch range per voice (defaults based on voice count)"
          },
          "rules": {
            "$ref": "#/components/schemas/VoiceLeadingRules",
            "nullable": true,
            "description": "Voice leading rules to apply"
          }
        }
      },
      "VoiceLeadResponse": {
        "description": "Response containing voiced chords",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "voicings"
        ],
        "properties": {
          "voicings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VoicedChord"
            },
            "description": "Voiced chord realizations"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VoiceLeadingViolation"
            },
            "nullable": true,
            "description": "Voice leading rule violations (warnings)"
          }
        }
      },
      "VoiceLeadingRules": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Harmony.VoiceLeadingRules",
        "description": "Rules for voice leading",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "avoidParallelFifths": {
            "type": "boolean",
            "default": true,
            "description": "Avoid parallel perfect fifths"
          },
          "avoidParallelOctaves": {
            "type": "boolean",
            "default": true,
            "description": "Avoid parallel octaves"
          },
          "preferStepwiseMotion": {
            "type": "boolean",
            "default": true,
            "description": "Prefer stepwise voice motion"
          },
          "avoidVoiceCrossing": {
            "type": "boolean",
            "default": true,
            "description": "Avoid voice crossing"
          },
          "maxLeap": {
            "type": "integer",
            "minimum": 1,
            "maximum": 12,
            "default": 7,
            "description": "Maximum leap in semitones"
          }
        }
      },
      "VoiceLeadingViolation": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Harmony.VoiceLeadingViolation",
        "description": "A voice leading rule violation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "type",
          "position",
          "voices",
          "isError",
          "message"
        ],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/VoiceLeadingViolationType",
            "description": "Type of violation"
          },
          "position": {
            "type": "integer",
            "description": "Position in the progression (0-based)"
          },
          "voices": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "Voice indices involved (0 = bass)"
          },
          "isError": {
            "type": "boolean",
            "description": "Severity (true = error, false = warning)"
          },
          "message": {
            "type": "string",
            "description": "Human-readable description"
          }
        }
      },
      "VoiceLeadingViolationType": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Harmony.VoiceLeadingViolationType",
        "description": "Type of voice leading rule violation",
        "type": "string",
        "enum": [
          "ParallelFifths",
          "ParallelOctaves",
          "VoiceCrossing",
          "VoiceOverlap",
          "LargeLeap",
          "UnresolvedLeap",
          "DoubledLeadingTone"
        ]
      },
      "VoicedChord": {
        "description": "A chord with specific voice pitches",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "symbol",
          "pitches"
        ],
        "properties": {
          "symbol": {
            "$ref": "#/components/schemas/ChordSymbol",
            "description": "Original chord symbol"
          },
          "pitches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Pitch"
            },
            "description": "Pitches from lowest to highest voice"
          }
        }
      },
      "VolumeShape": {
        "type": "string",
        "description": "Shape of a volume node for spatial bounds",
        "enum": [
          "box",
          "sphere",
          "capsule",
          "cylinder"
        ]
      },
      "WalletOwnerType": {
        "type": "string",
        "description": "Type of entity that owns a wallet",
        "enum": [
          "account",
          "character",
          "npc",
          "guild",
          "faction",
          "location",
          "system"
        ]
      },
      "WalletResponse": {
        "type": "object",
        "description": "Wallet details",
        "additionalProperties": false,
        "required": [
          "walletId",
          "ownerId",
          "ownerType",
          "status",
          "createdAt"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique wallet identifier"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner entity ID"
          },
          "ownerType": {
            "$ref": "#/components/schemas/WalletOwnerType",
            "description": "Owner type"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm ID"
          },
          "status": {
            "$ref": "#/components/schemas/WalletStatus",
            "description": "Current wallet status"
          },
          "frozenReason": {
            "type": "string",
            "nullable": true,
            "description": "Reason wallet was frozen"
          },
          "frozenAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When wallet was frozen"
          },
          "frozenBy": {
            "type": "string",
            "nullable": true,
            "description": "Who froze the wallet"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "lastActivityAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last transaction timestamp"
          }
        }
      },
      "WalletStatus": {
        "type": "string",
        "description": "Current status of a wallet",
        "enum": [
          "active",
          "frozen",
          "closed"
        ]
      },
      "WalletWithBalancesResponse": {
        "type": "object",
        "description": "Wallet with all non-zero balances",
        "additionalProperties": false,
        "required": [
          "wallet",
          "balances"
        ],
        "properties": {
          "wallet": {
            "$ref": "#/components/schemas/WalletResponse",
            "description": "Wallet details"
          },
          "balances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BalanceSummary"
            },
            "description": "All non-zero balances in this wallet"
          }
        }
      },
      "WeightContribution": {
        "type": "string",
        "description": "How container weight propagates to parent",
        "enum": [
          "none",
          "self_only",
          "self_plus_contents"
        ]
      },
      "WeightPrecision": {
        "type": "string",
        "description": "Precision for weight values (consistent with CurrencyPrecision)",
        "enum": [
          "integer",
          "decimal_1",
          "decimal_2",
          "decimal_3"
        ]
      }
    },
    "securitySchemes": {
      "BearerAuth": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "JWT",
        "description": "JWT access token obtained from /auth/login or OAuth flow"
      }
    }
  },
  "tags": [
    {
      "name": "ABML Behavior Management",
      "description": "Arcadia Behavior Markup Language (ABML) API for character behavior management."
    },
    {
      "name": "Actor",
      "description": "Distributed actor management and execution for NPC brains, event coordinators,"
    },
    {
      "name": "Asset",
      "description": "Asset management service for storage, versioning, and distribution of large binary assets."
    },
    {
      "name": "Bannou Account",
      "description": "Internal account management service (CRUD operations only, never exposed to internet)."
    },
    {
      "name": "Bannou Achievement",
      "description": "Achievement and trophy system with progress tracking and platform synchronization."
    },
    {
      "name": "Bannou Auth",
      "description": "Authentication and session management service (Internet-facing)."
    },
    {
      "name": "Bannou Character",
      "description": "Character management service for Arcadia game world."
    },
    {
      "name": "Bannou Character Encounter",
      "description": "Character encounter tracking service for memorable interactions between characters."
    },
    {
      "name": "Bannou Character History",
      "description": "Historical event participation and backstory management for characters."
    },
    {
      "name": "Bannou Character Personality",
      "description": "Machine-readable personality traits for NPC behavior decisions."
    },
    {
      "name": "Bannou Connect",
      "description": "Real-time communication and WebSocket connection management for Bannou services."
    },
    {
      "name": "Bannou Documentation",
      "description": "Knowledge base API for AI agents to query documentation."
    },
    {
      "name": "Bannou Game",
      "description": "Registry service for game services that users can subscribe to."
    },
    {
      "name": "Bannou Game Session",
      "description": "Minimal game session management for Arcadia and other games."
    },
    {
      "name": "Bannou Leaderboard",
      "description": "Real-time leaderboard management using Redis Sorted Sets for efficient ranking."
    },
    {
      "name": "Bannou Location",
      "description": "Location management service for Arcadia game world."
    },
    {
      "name": "Bannou Mapping",
      "description": "Spatial data management service for Arcadia game worlds."
    },
    {
      "name": "Bannou Matchmaking",
      "description": "Matchmaking service for competitive and casual game matching."
    },
    {
      "name": "Bannou Realm",
      "description": "Realm management service for Arcadia game world."
    },
    {
      "name": "Bannou Realm History",
      "description": "Historical event participation and lore management for realms."
    },
    {
      "name": "Bannou RelationshipType",
      "description": "Relationship type management service for Arcadia game world."
    },
    {
      "name": "Bannou Scene",
      "description": "Hierarchical composition storage for game worlds."
    },
    {
      "name": "Bannou Species",
      "description": "Species management service for Arcadia game world."
    },
    {
      "name": "Bannou Subscription",
      "description": "Manages user subscriptions to game services."
    },
    {
      "name": "Bannou Voice",
      "description": "Voice communication coordination service for P2P and room-based audio."
    },
    {
      "name": "Bannou Website",
      "description": "Public-facing website service for registration, information, and account management."
    },
    {
      "name": "Contract",
      "description": "Binding agreements between entities with milestone-based progression."
    },
    {
      "name": "Currency",
      "description": "Multi-currency management service for game economies."
    },
    {
      "name": "Escrow",
      "description": "Full-custody orchestration layer for multi-party asset exchanges."
    },
    {
      "name": "Inventory",
      "description": "Container and inventory management service for games."
    },
    {
      "name": "Item",
      "description": "Item template and instance management service."
    },
    {
      "name": "Music Theory Engine",
      "description": "Pure computation music generation using formal music theory rules."
    },
    {
      "name": "Relationship",
      "description": "Generic relationship management service for entity-to-entity relationships."
    },
    {
      "name": "Save-Load",
      "description": "Generic save/load system for game state persistence."
    }
  ]
}
