{
  "openapi": "3.0.3",
  "info": {
    "title": "Bannou Client API",
    "description": "Consolidated client-facing API schema for Bannou services.\n\nThis schema contains all endpoints accessible to game clients (anonymous, user,\nauthenticated, developer roles). Admin-only endpoints are excluded.\n\nGenerated by generate-client-schema.py from individual service schemas.\n\n## WebSocket Binary Protocol\n\nAll endpoints can be accessed via the WebSocket binary protocol:\n- Request header: 31 bytes (flags, channel, sequence, serviceGuid, messageId)\n- Response header: 16 bytes (flags, channel, sequence, messageId, responseCode)\n- Payload: JSON (UTF-8 encoded)\n\nSee the x-bannou-protocol extension for protocol details.",
    "version": "1.0.0",
    "contact": {
      "name": "Bannou Development Team"
    }
  },
  "servers": [
    {
      "url": "http://localhost:5012",
      "description": "Local development server"
    }
  ],
  "x-bannou-protocol": {
    "requestHeaderSize": 31,
    "responseHeaderSize": 16,
    "headerLayout": {
      "request": [
        {
          "offset": 0,
          "size": 1,
          "field": "flags",
          "type": "uint8"
        },
        {
          "offset": 1,
          "size": 2,
          "field": "channel",
          "type": "uint16_be"
        },
        {
          "offset": 3,
          "size": 4,
          "field": "sequence",
          "type": "uint32_be"
        },
        {
          "offset": 7,
          "size": 16,
          "field": "serviceGuid",
          "type": "guid_rfc4122"
        },
        {
          "offset": 23,
          "size": 8,
          "field": "messageId",
          "type": "uint64_be"
        }
      ],
      "response": [
        {
          "offset": 0,
          "size": 1,
          "field": "flags",
          "type": "uint8"
        },
        {
          "offset": 1,
          "size": 2,
          "field": "channel",
          "type": "uint16_be"
        },
        {
          "offset": 3,
          "size": 4,
          "field": "sequence",
          "type": "uint32_be"
        },
        {
          "offset": 7,
          "size": 8,
          "field": "messageId",
          "type": "uint64_be"
        },
        {
          "offset": 15,
          "size": 1,
          "field": "responseCode",
          "type": "uint8"
        }
      ]
    },
    "messageFlags": {
      "None": 0,
      "Binary": 1,
      "Encrypted": 2,
      "Compressed": 4,
      "HighPriority": 8,
      "Event": 16,
      "Client": 32,
      "Response": 64,
      "Meta": 128
    },
    "responseCodes": {
      "OK": 0,
      "RequestError": 10,
      "RequestTooLarge": 11,
      "TooManyRequests": 12,
      "InvalidRequestChannel": 13,
      "Unauthorized": 20,
      "ServiceNotFound": 30,
      "ClientNotFound": 31,
      "MessageNotFound": 32,
      "BroadcastNotAllowed": 40,
      "Service_BadRequest": 50,
      "Service_NotFound": 51,
      "Service_Unauthorized": 52,
      "Service_Conflict": 53,
      "Service_InternalServerError": 60,
      "ShortcutExpired": 70,
      "ShortcutTargetNotFound": 71,
      "ShortcutRevoked": 72
    }
  },
  "paths": {
    "/account/profile/update": {
      "post": {
        "summary": "Update account profile",
        "operationId": "updateProfile",
        "tags": [
          "Profile Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateProfileRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Profile updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountResponse"
                }
              }
            }
          },
          "404": {
            "description": "Account not found"
          }
        }
      }
    },
    "/account/password/update": {
      "post": {
        "summary": "Update account password hash",
        "operationId": "updatePasswordHash",
        "tags": [
          "Account Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdatePasswordRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Password hash updated successfully"
          },
          "404": {
            "description": "Account not found"
          }
        }
      }
    },
    "/account/mfa/update": {
      "post": {
        "summary": "Update MFA settings for an account",
        "description": "Sets or clears MFA-related fields (mfaEnabled, mfaSecret, mfaRecoveryCodes) atomically.\nUsed by Auth service during MFA enable/disable flows. Auth owns the encryption logic;\nAccount stores the opaque encrypted data.\n",
        "operationId": "updateMfa",
        "tags": [
          "Account Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateMfaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "MFA settings updated successfully"
          },
          "404": {
            "description": "Account not found"
          },
          "409": {
            "description": "Concurrent modification detected"
          }
        }
      }
    },
    "/account/verification/update": {
      "post": {
        "summary": "Update email verification status",
        "operationId": "updateVerificationStatus",
        "tags": [
          "Account Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateVerificationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Verification status updated successfully"
          },
          "404": {
            "description": "Account not found"
          }
        }
      }
    },
    "/achievement/definition/create": {
      "post": {
        "summary": "Create a new achievement definition",
        "description": "Create a new achievement with specified criteria and platform mappings.\nDeveloper-only endpoint.\n",
        "operationId": "createAchievementDefinition",
        "tags": [
          "Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateAchievementDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Achievement created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AchievementDefinitionResponse"
                }
              }
            }
          },
          "409": {
            "description": "Achievement with this ID already exists"
          }
        }
      }
    },
    "/achievement/definition/list": {
      "post": {
        "summary": "List achievement definitions",
        "description": "List achievements for a game service with optional platform filtering.",
        "operationId": "listAchievementDefinitions",
        "tags": [
          "Definitions"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListAchievementDefinitionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Achievement definitions retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListAchievementDefinitionsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/achievement/definition/update": {
      "post": {
        "summary": "Update achievement definition",
        "description": "Update properties of an existing achievement.\nDeveloper-only endpoint.\n",
        "operationId": "updateAchievementDefinition",
        "tags": [
          "Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateAchievementDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Achievement updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AchievementDefinitionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Achievement not found"
          }
        }
      }
    },
    "/achievement/definition/delete": {
      "post": {
        "summary": "Delete achievement definition",
        "description": "Delete an achievement. Earned instances are preserved in history.\nDeveloper-only endpoint.\n",
        "operationId": "deleteAchievementDefinition",
        "tags": [
          "Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteAchievementDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Achievement deleted successfully"
          },
          "404": {
            "description": "Achievement not found"
          }
        }
      }
    },
    "/achievement/progress/get": {
      "post": {
        "summary": "Get entity's achievement progress",
        "description": "Get progress for an entity across all achievements or a specific one.",
        "operationId": "getAchievementProgress",
        "tags": [
          "Progress"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetAchievementProgressRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Progress retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AchievementProgressResponse"
                }
              }
            }
          }
        }
      }
    },
    "/achievement/list-unlocked": {
      "post": {
        "summary": "List unlocked achievements",
        "description": "Get all achievements unlocked by an entity.",
        "operationId": "listUnlockedAchievements",
        "tags": [
          "Progress"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListUnlockedAchievementsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Unlocked achievements retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListUnlockedAchievementsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/template/create": {
      "post": {
        "operationId": "CreateActorTemplate",
        "summary": "Create an actor template (category definition)",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateActorTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActorTemplateResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/template/update": {
      "post": {
        "operationId": "UpdateActorTemplate",
        "summary": "Update an actor template",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateActorTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActorTemplateResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/template/delete": {
      "post": {
        "operationId": "DeleteActorTemplate",
        "summary": "Delete an actor template",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteActorTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteActorTemplateResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/spawn": {
      "post": {
        "operationId": "SpawnActor",
        "summary": "Spawn a new actor from a template",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SpawnActorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Actor spawned successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActorInstanceResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/stop": {
      "post": {
        "operationId": "StopActor",
        "summary": "Stop a running actor",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StopActorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Actor stopped successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StopActorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/cleanup-by-character": {
      "post": {
        "operationId": "CleanupByCharacter",
        "summary": "Cleanup actors referencing a deleted character",
        "description": "Called by lib-resource cleanup coordination when a character is deleted.\nStops and removes all actors that reference the specified characterId.\nThis endpoint is designed for internal service-to-service calls during\ncascading resource cleanup.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CleanupByCharacterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cleanup completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupByCharacterResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/inject-perception": {
      "post": {
        "operationId": "InjectPerception",
        "summary": "Inject a perception event into an actor's queue (testing)",
        "description": "Injects a perception event directly into the actor's perception queue\nfor testing purposes. Useful for testing actor behavior without a\nfull game server setup.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InjectPerceptionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Perception injected successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InjectPerceptionResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/encounter/start": {
      "post": {
        "operationId": "StartEncounter",
        "summary": "Start an encounter managed by an Event Brain actor",
        "description": "Initializes an encounter with the specified participants. The Event Brain actor\nwill coordinate the encounter, sending instructions to participant NPC Brain actors\nvia their character perception channels.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StartEncounterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounter started successfully"
          }
        }
      }
    },
    "/actor/encounter/update-phase": {
      "post": {
        "operationId": "UpdateEncounterPhase",
        "summary": "Update the phase of an active encounter",
        "description": "Updates the phase of an encounter being managed by an Event Brain actor.\nPhase changes are logged and can trigger behavior changes in participant actors.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateEncounterPhaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounter phase updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateEncounterPhaseResponse"
                }
              }
            }
          }
        }
      }
    },
    "/actor/encounter/end": {
      "post": {
        "operationId": "EndEncounter",
        "summary": "End an active encounter",
        "description": "Ends an encounter being managed by an Event Brain actor. This clears the\nencounter state and allows the actor to manage a new encounter.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EndEncounterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounter ended successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EndEncounterResponse"
                }
              }
            }
          }
        }
      }
    },
    "/assets/upload/request": {
      "post": {
        "summary": "Request upload URL for a new asset",
        "description": "Generate a pre-signed URL for uploading a new asset directly to storage.\nFor large files (>50MB), returns multipart upload configuration.\n",
        "operationId": "requestUpload",
        "tags": [
          "Assets"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UploadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Upload URL generated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (filename, size, or content_type)"
          },
          "401": {
            "description": "Not authenticated"
          },
          "403": {
            "description": "Insufficient permissions"
          }
        }
      }
    },
    "/assets/upload/complete": {
      "post": {
        "summary": "Mark upload as complete, trigger processing",
        "description": "Called after the client has uploaded the file to the pre-signed URL.\nTriggers the asset processing pipeline (texture conversion, model validation, etc.)\nand emits completion events via WebSocket.\n",
        "operationId": "completeUpload",
        "tags": [
          "Assets"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompleteUploadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Asset created, processing started",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetMetadata"
                }
              }
            }
          },
          "400": {
            "description": "Invalid upload_id or missing parts for multipart"
          },
          "404": {
            "description": "Upload session not found or expired"
          }
        }
      }
    },
    "/assets/get": {
      "post": {
        "summary": "Get asset metadata and download URL",
        "description": "Retrieve asset metadata and generate a pre-signed download URL.\nSpecify version to download a specific version, or omit for latest.\n",
        "operationId": "getAsset",
        "tags": [
          "Assets"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetAssetRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Asset metadata with download URL",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetWithDownloadUrl"
                }
              }
            }
          },
          "404": {
            "description": "Asset not found"
          }
        }
      }
    },
    "/assets/list-versions": {
      "post": {
        "summary": "List all versions of an asset",
        "description": "Retrieve version history for an asset with pagination.\nIncludes version IDs, creation timestamps, and archive status.\n",
        "operationId": "listAssetVersions",
        "tags": [
          "Assets"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListVersionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of asset versions",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetVersionList"
                }
              }
            }
          },
          "404": {
            "description": "Asset not found"
          }
        }
      }
    },
    "/assets/search": {
      "post": {
        "summary": "Search assets by tags, type, or realm",
        "description": "Search assets using various filters with pagination.\nAll filters are optional and combine with AND logic.\n",
        "operationId": "searchAssets",
        "tags": [
          "Assets"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AssetSearchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Matching assets",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetSearchResult"
                }
              }
            }
          }
        }
      }
    },
    "/bundles/create": {
      "post": {
        "summary": "Create asset bundle from multiple assets",
        "description": "Create a .bannou bundle containing multiple assets.\nFor large bundles, processing is delegated to the processing pool.\nCompletion notification sent via WebSocket event.\n",
        "operationId": "createBundle",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateBundleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bundle created immediately (small bundles)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateBundleResponse"
                }
              }
            }
          },
          "202": {
            "description": "Bundle creation queued (large bundles)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateBundleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid asset_ids or bundle_id"
          }
        }
      }
    },
    "/bundles/get": {
      "post": {
        "summary": "Get bundle manifest and download URL",
        "description": "Retrieve bundle metadata and generate a pre-signed download URL.\nSupports both native .bannou format and ZIP conversion (cached).\n",
        "operationId": "getBundle",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetBundleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bundle manifest with download URL",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BundleWithDownloadUrl"
                }
              }
            }
          },
          "404": {
            "description": "Bundle not found"
          }
        }
      }
    },
    "/bundles/upload/request": {
      "post": {
        "summary": "Request upload URL for a pre-made bundle",
        "description": "Upload a pre-built bundle (.bannou or .zip format).\nAfter upload, the bundle undergoes validation before registration.\n",
        "operationId": "requestBundleUpload",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BundleUploadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Upload URL generated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid filename or size"
          }
        }
      }
    },
    "/bundles/metabundle/create": {
      "post": {
        "summary": "Create metabundle from source bundles",
        "description": "Compose a metabundle by extracting and repackaging assets from multiple\nsource bundles. The resulting metabundle is a complete physical copy with\nprovenance metadata tracking the source bundles.\n\nAssets are deduplicated by content hash. If the same asset ID exists in\nmultiple source bundles with different content hashes, the request fails\nwith conflict details.\n",
        "operationId": "createMetabundle",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateMetabundleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Metabundle created or queued for creation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateMetabundleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or asset conflicts detected"
          },
          "404": {
            "description": "One or more source bundles not found"
          },
          "409": {
            "description": "Metabundle ID already exists"
          }
        }
      }
    },
    "/bundles/job/status": {
      "post": {
        "summary": "Get async metabundle job status",
        "description": "Poll the status of an async metabundle creation job.\nUse the jobId returned from createMetabundle when status was 'queued'.\n\nClients can either poll this endpoint or wait for the\nMetabundleCreationCompleteEvent via WebSocket for completion notification.\n",
        "operationId": "getJobStatus",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetJobStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Job status retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetJobStatusResponse"
                }
              }
            }
          },
          "404": {
            "description": "Job not found or expired"
          }
        }
      }
    },
    "/bundles/job/cancel": {
      "post": {
        "summary": "Cancel an async metabundle job",
        "description": "Cancel a pending or processing metabundle creation job.\nJobs that are already completed (ready or failed) cannot be cancelled.\n\nSuccessfully cancelled jobs will emit a MetabundleCreationCompleteEvent\nwith status 'cancelled' via WebSocket.\n",
        "operationId": "cancelJob",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CancelJobRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Job cancellation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CancelJobResponse"
                }
              }
            }
          },
          "404": {
            "description": "Job not found or expired"
          },
          "409": {
            "description": "Job cannot be cancelled (already completed)"
          }
        }
      }
    },
    "/bundles/resolve": {
      "post": {
        "summary": "Compute optimal bundles for requested assets",
        "description": "Given a list of asset IDs, compute the optimal set of bundles to download\nto obtain all requested assets with minimal transfers.\n\nThe algorithm uses greedy set-cover optimization:\n1. Find all bundles containing requested assets\n2. Select bundles that cover the most uncovered assets\n3. Prefer metabundles when coverage is equal (tie-breaker)\n4. Include standalone assets for any remaining unresolved IDs\n\nReturns pre-signed download URLs for all selected bundles and assets.\n",
        "operationId": "resolveBundles",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResolveBundlesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Resolution complete with download URLs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResolveBundlesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          }
        }
      }
    },
    "/bundles/query/by-asset": {
      "post": {
        "summary": "Find all bundles containing a specific asset",
        "description": "Query the reverse index to find all bundles (source and metabundle)\nthat contain a specific asset ID. Useful for understanding asset\ndistribution and debugging resolution issues.\n",
        "operationId": "queryBundlesByAsset",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryBundlesByAssetRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bundles containing the asset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryBundlesByAssetResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          }
        }
      }
    },
    "/bundles/update": {
      "post": {
        "summary": "Update bundle metadata",
        "description": "Update metadata for an existing bundle (name, description, tags).\nDoes not modify bundle contents - for that, create a new bundle.\n\nIncrements the bundle version and records the change in version history.\nOnly the bundle owner or admin can update.\n",
        "operationId": "updateBundle",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateBundleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bundle updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateBundleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Not authorized to update this bundle"
          },
          "404": {
            "description": "Bundle not found or deleted"
          }
        }
      }
    },
    "/bundles/delete": {
      "post": {
        "summary": "Soft-delete a bundle",
        "description": "Soft-delete a bundle, marking it as deleted but retaining data\nfor the configured retention period (default 30 days).\n\nDeleted bundles are excluded from resolution and queries by default.\nUse permanent=true for immediate, unrecoverable deletion (admin only).\n\nOnly the bundle owner or admin can delete.\n",
        "operationId": "deleteBundle",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteBundleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bundle deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteBundleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Not authorized to delete this bundle"
          },
          "404": {
            "description": "Bundle not found"
          }
        }
      }
    },
    "/bundles/restore": {
      "post": {
        "summary": "Restore a soft-deleted bundle",
        "description": "Restore a bundle that was soft-deleted, making it active again.\nCan only restore bundles within their retention period.\n\nOnly the bundle owner or admin can restore.\n",
        "operationId": "restoreBundle",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RestoreBundleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bundle restored successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RestoreBundleResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or bundle not in deleted state"
          },
          "403": {
            "description": "Not authorized to restore this bundle"
          },
          "404": {
            "description": "Bundle not found or permanently deleted"
          },
          "410": {
            "description": "Bundle retention period has expired"
          }
        }
      }
    },
    "/bundles/query": {
      "post": {
        "summary": "Query bundles with advanced filters",
        "description": "Query bundles with flexible filtering options including:\n- Tag matching (exact, exists, not exists)\n- Status filtering (active, deleted)\n- Date range filtering\n- Name search (contains)\n- Owner filtering\n- Realm and bundle type filtering\n\nSupports pagination and sorting.\n",
        "operationId": "queryBundles",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryBundlesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Query results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryBundlesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid query parameters"
          }
        }
      }
    },
    "/bundles/list-versions": {
      "post": {
        "summary": "List version history for a bundle",
        "description": "Get the version history for a bundle, showing all metadata changes\nover time. Each version record includes:\n- Version number\n- When the change was made\n- Who made the change\n- What changed\n- Optional reason for the change\n\nThe current version's full metadata snapshot is always included.\n",
        "operationId": "listBundleVersions",
        "tags": [
          "Bundles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListBundleVersionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Version history",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListBundleVersionsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Bundle not found"
          }
        }
      }
    },
    "/assets/bulk-get": {
      "post": {
        "summary": "Batch asset metadata lookup",
        "description": "Retrieve metadata for multiple assets in a single request.\nOptionally includes pre-signed download URLs.\nMaximum 100 asset IDs per request.\n",
        "operationId": "bulkGetAssets",
        "tags": [
          "Assets"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BulkGetAssetsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Asset metadata retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkGetAssetsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or too many asset IDs"
          }
        }
      }
    },
    "/auth/login": {
      "post": {
        "summary": "Login with email/password",
        "operationId": "login",
        "tags": [
          "Authentication"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Login successful or MFA challenge issued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LoginResponse"
                }
              }
            }
          },
          "401": {
            "description": "Invalid credentials"
          },
          "429": {
            "description": "Too many login attempts"
          }
        }
      }
    },
    "/auth/register": {
      "post": {
        "summary": "Register new user account",
        "operationId": "register",
        "tags": [
          "Authentication"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegisterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Registration successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisterResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request data"
          },
          "409": {
            "description": "Username already exists"
          }
        }
      }
    },
    "/auth/oauth/{provider}/init": {
      "get": {
        "summary": "Initialize OAuth2 flow (browser redirect)",
        "description": "Browser-facing endpoint for initiating OAuth flows. The user's browser navigates\nto this URL directly, which then redirects to the OAuth provider.\n\n**Note**: This endpoint uses GET with path parameters because it's a browser\nredirect flow, not a WebSocket-routed API call.\n",
        "operationId": "initOAuth",
        "tags": [
          "OAuth"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "provider",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/Provider"
            }
          },
          {
            "name": "redirectUri",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uri"
            }
          },
          {
            "name": "state",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "302": {
            "description": "Redirect to OAuth provider"
          }
        },
        "x-manual-implementation": true
      }
    },
    "/auth/oauth/{provider}/callback": {
      "post": {
        "summary": "Complete OAuth2 flow (browser redirect callback)",
        "description": "Browser-facing callback endpoint for OAuth providers. The OAuth provider redirects\nthe user's browser back to this URL after authentication.\n\n**Note**: This endpoint uses path parameters because the callback URL is registered\nwith OAuth providers and cannot be changed without updating provider configurations.\n",
        "operationId": "completeOAuth",
        "tags": [
          "OAuth"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "provider",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/Provider"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OAuthCallbackRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OAuth authentication successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/auth/steam/verify": {
      "post": {
        "summary": "Verify Steam Session Ticket",
        "description": "Validates a Steam Session Ticket obtained from the game client via ISteamUser::GetAuthTicketForWebApi().\nThe server validates the ticket with Steam's Web API and retrieves the SteamID from Steam's response.\nNEVER trust client-provided SteamID - it must come from Steam's authenticated response.\n",
        "operationId": "verifySteamAuth",
        "tags": [
          "Steam"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SteamVerifyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Steam authentication successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthResponse"
                }
              }
            }
          },
          "401": {
            "description": "Invalid or expired Steam ticket"
          },
          "500": {
            "description": "Steam API unavailable or internal error"
          }
        }
      }
    },
    "/auth/refresh": {
      "post": {
        "summary": "Refresh access token",
        "operationId": "refreshToken",
        "tags": [
          "Tokens"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "jwt",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Current JWT access token for refresh",
            "x-from-authorization": "bearer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RefreshRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Token refreshed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/auth/validate": {
      "post": {
        "summary": "Validate access token",
        "operationId": "validateToken",
        "tags": [
          "Tokens"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "jwt",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "JWT access token for validation",
            "x-from-authorization": "bearer"
          }
        ],
        "responses": {
          "200": {
            "description": "Token is valid",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidateTokenResponse"
                }
              }
            }
          },
          "401": {
            "description": "Invalid or missing token"
          },
          "403": {
            "description": "Token expired or malformed"
          }
        }
      }
    },
    "/auth/logout": {
      "post": {
        "summary": "Logout and invalidate tokens",
        "operationId": "logout",
        "tags": [
          "Authentication"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "jwt",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "JWT access token for session identification",
            "x-from-authorization": "bearer"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LogoutRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Logged out successfully"
          }
        }
      }
    },
    "/auth/sessions/list": {
      "post": {
        "summary": "Get active sessions for account",
        "operationId": "getSessions",
        "tags": [
          "Sessions"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "jwt",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "JWT access token for session identification",
            "x-from-authorization": "bearer"
          }
        ],
        "responses": {
          "200": {
            "description": "Active sessions retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SessionsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/auth/sessions/terminate": {
      "post": {
        "summary": "Terminate specific session",
        "operationId": "terminateSession",
        "tags": [
          "Sessions"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "jwt",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "JWT access token for session identification",
            "x-from-authorization": "bearer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TerminateSessionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Session terminated"
          },
          "404": {
            "description": "Session not found"
          }
        }
      }
    },
    "/auth/password/reset": {
      "post": {
        "summary": "Request password reset",
        "operationId": "requestPasswordReset",
        "tags": [
          "Password"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PasswordResetRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Reset email sent if account exists"
          }
        }
      }
    },
    "/auth/password/confirm": {
      "post": {
        "summary": "Confirm password reset with token",
        "operationId": "confirmPasswordReset",
        "tags": [
          "Password"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PasswordResetConfirmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Password reset successfully"
          }
        }
      }
    },
    "/auth/providers": {
      "post": {
        "summary": "List available authentication providers",
        "description": "Returns a list of available OAuth and authentication providers based on server configuration.\nProviders are only listed if their client credentials are configured.\nSteam authentication uses session tickets, not OAuth, but is included for completeness.\n",
        "operationId": "listProviders",
        "tags": [
          "Authentication"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "responses": {
          "200": {
            "description": "List of available providers",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProvidersResponse"
                }
              }
            }
          }
        }
      }
    },
    "/auth/mfa/setup": {
      "post": {
        "summary": "Initialize MFA setup",
        "description": "Generates a TOTP secret and 10 recovery codes. Returns an otpauth:// URI for QR\ncode scanning and the recovery codes in plain text (shown only once). The setup is\nnot active until confirmed via /auth/mfa/enable with a valid TOTP code.\n",
        "operationId": "setupMfa",
        "tags": [
          "MFA"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "jwt",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "JWT access token",
            "x-from-authorization": "bearer"
          }
        ],
        "responses": {
          "200": {
            "description": "MFA setup initiated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MfaSetupResponse"
                }
              }
            }
          },
          "409": {
            "description": "MFA already enabled for this account"
          }
        }
      }
    },
    "/auth/mfa/enable": {
      "post": {
        "summary": "Confirm MFA setup with TOTP code",
        "description": "Verifies a TOTP code against the pending setup secret to prove the authenticator\napp is correctly configured. On success, persists MFA settings to the account and\nMFA is active for all subsequent password logins.\n",
        "operationId": "enableMfa",
        "tags": [
          "MFA"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "jwt",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "JWT access token",
            "x-from-authorization": "bearer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MfaEnableRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "MFA enabled successfully"
          },
          "400": {
            "description": "Invalid TOTP code or expired setup token"
          },
          "409": {
            "description": "MFA already enabled"
          }
        }
      }
    },
    "/auth/mfa/disable": {
      "post": {
        "summary": "Disable MFA for current account",
        "description": "Disables MFA for the authenticated account. Requires a valid TOTP code or\nrecovery code to prevent unauthorized disable. Clears the TOTP secret and\nrecovery codes from the account.\n",
        "operationId": "disableMfa",
        "tags": [
          "MFA"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "jwt",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "JWT access token",
            "x-from-authorization": "bearer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MfaDisableRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "MFA disabled successfully"
          },
          "400": {
            "description": "Invalid TOTP code or recovery code"
          },
          "404": {
            "description": "MFA not enabled for this account"
          }
        }
      }
    },
    "/auth/mfa/verify": {
      "post": {
        "summary": "Verify MFA code during login",
        "description": "Completes the MFA challenge issued during login by verifying a TOTP code or\nrecovery code. On success, returns full authentication tokens (same as a\nnon-MFA login would). The challenge token is single-use and has a configurable\nTTL (default 5 minutes).\n",
        "operationId": "verifyMfa",
        "tags": [
          "MFA"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MfaVerifyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "MFA verified, tokens issued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid TOTP code or recovery code"
          },
          "401": {
            "description": "Challenge token not found, expired, or already used"
          }
        }
      }
    },
    "/compile": {
      "post": {
        "summary": "Compile ABML behavior definition",
        "description": "Compiles a YAML-based ABML behavior definition into executable behavior trees.\nHandles stackable behavior sets, cultural adaptations, and context variable resolution.\n",
        "operationId": "CompileAbmlBehavior",
        "tags": [
          "ABML"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/yaml": {
              "schema": {
                "type": "string",
                "description": "Raw ABML YAML content"
              },
              "example": "version: \"1.0.0\"\nmetadata:\n  id: \"blacksmith_daily_routine\"\n  category: \"profession\"\n  priority: 60\n  description: \"Daily routine for a master blacksmith NPC\"\n\ncontext:\n  variables:\n    energy_level: \"${npc.stats.energy}\"\n    skill_level: \"${npc.skills.blacksmithing}\"\n    shop_reputation: \"${npc.reputation.local}\"\n\n  services:\n    - name: \"crafting_service\"\n      required: true\n    - name: \"economy_service\"\n      required: true\n\nbehaviors:\n  morning_startup:\n    triggers:\n      - time_range: \"06:00-09:00\"\n      - condition: \"${context.energy_level > 0.7}\"\n    actions:\n      - wake_up:\n          animation: \"stretch_and_yawn\"\n          duration: 3\n          energy_cost: -0.05\n"
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompileBehaviorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "ABML behavior compiled successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CompileBehaviorResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid ABML definition or compilation error"
          },
          "403": {
            "description": "Forbidden - insufficient permissions"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/validate": {
      "post": {
        "summary": "Validate ABML definition",
        "description": "Validates ABML YAML against schema and checks for semantic correctness.\nIncludes context variable validation and service dependency checking.\n",
        "operationId": "ValidateAbml",
        "tags": [
          "Validation"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/yaml": {
              "schema": {
                "type": "string",
                "description": "Raw ABML YAML content to validate"
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ValidateAbmlRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Validation completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidateAbmlResponse"
                }
              }
            }
          }
        }
      }
    },
    "/cache/get": {
      "post": {
        "summary": "Get cached compiled behavior",
        "description": "Retrieves a previously compiled behavior from the cache.\nUsed for performance optimization in high-frequency behavior execution.\n",
        "operationId": "GetCachedBehavior",
        "tags": [
          "Cache"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCachedBehaviorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cached behavior retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CachedBehaviorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Behavior not found in cache"
          }
        }
      }
    },
    "/cache/invalidate": {
      "post": {
        "summary": "Invalidate cached behavior",
        "description": "Removes a behavior from the cache, forcing recompilation on next access.\nUsed when behavior definitions are updated.\n",
        "operationId": "InvalidateCachedBehavior",
        "tags": [
          "Cache"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InvalidateCacheRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cache invalidated successfully"
          },
          "404": {
            "description": "Behavior not found in cache"
          }
        }
      }
    },
    "/goap/plan": {
      "post": {
        "summary": "Generate GOAP plan",
        "description": "Generates a GOAP plan to achieve a goal from the current world state.\nUses A* search to find the optimal sequence of actions.\n",
        "operationId": "GenerateGoapPlan",
        "tags": [
          "GOAP"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoapPlanRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Plan generated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GoapPlanResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or planning failed"
          }
        }
      }
    },
    "/goap/validate-plan": {
      "post": {
        "summary": "Validate existing GOAP plan",
        "description": "Validates an existing GOAP plan against the current world state.\nReturns whether the plan is still valid or needs replanning.\n",
        "operationId": "ValidateGoapPlan",
        "tags": [
          "GOAP"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ValidateGoapPlanRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Plan validation completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidateGoapPlanResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          }
        }
      }
    },
    "/character/get": {
      "post": {
        "summary": "Get character by ID",
        "operationId": "getCharacter",
        "tags": [
          "Character Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCharacterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Character retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CharacterResponse"
                }
              }
            }
          },
          "404": {
            "description": "Character not found"
          }
        }
      }
    },
    "/character/list": {
      "post": {
        "summary": "List characters with filtering",
        "operationId": "listCharacters",
        "tags": [
          "Character Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListCharactersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Characters retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CharacterListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character/get-enriched": {
      "post": {
        "summary": "Get character with optional related data (personality, backstory, family)",
        "description": "Retrieves a character with optional include flags for related data.\nUse this endpoint when you need aggregated character data from multiple services.\nEach included dataset is fetched from its respective service.\n",
        "operationId": "getEnrichedCharacter",
        "tags": [
          "Character Lookup"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEnrichedCharacterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Character retrieved with requested includes",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EnrichedCharacterResponse"
                }
              }
            }
          },
          "404": {
            "description": "Character not found"
          }
        }
      }
    },
    "/character/get-archive": {
      "post": {
        "summary": "Get compressed archive data for a character",
        "operationId": "getCharacterArchive",
        "tags": [
          "Character Compression"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCharacterArchiveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Archive retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CharacterArchive"
                }
              }
            }
          },
          "404": {
            "description": "Archive not found (character may not be compressed yet)"
          }
        }
      }
    },
    "/character/by-realm": {
      "post": {
        "summary": "Get all characters in a realm (primary query pattern)",
        "operationId": "getCharactersByRealm",
        "tags": [
          "Character Lookup"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCharactersByRealmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Characters retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CharacterListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character/get-compress-data": {
      "post": {
        "summary": "Get character base data for compression",
        "operationId": "getCompressData",
        "tags": [
          "Character Compression"
        ],
        "description": "Called by Resource service during compression.\nReturns core character data (name, dates, family summary).\nReturns BadRequest if character is alive - only dead characters can be compressed.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCompressDataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Character base data returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CharacterBaseArchive"
                }
              }
            }
          },
          "400": {
            "description": "Character is not dead (cannot compress alive characters)"
          },
          "404": {
            "description": "Character not found"
          }
        }
      }
    },
    "/character-encounter/type/get": {
      "post": {
        "summary": "Get encounter type by code",
        "operationId": "getEncounterType",
        "tags": [
          "Encounter Type Management"
        ],
        "description": "Retrieve an encounter type by its unique code.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEncounterTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounter type retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EncounterTypeResponse"
                }
              }
            }
          },
          "404": {
            "description": "Encounter type not found"
          }
        }
      }
    },
    "/character-encounter/type/list": {
      "post": {
        "summary": "List all encounter types",
        "operationId": "listEncounterTypes",
        "tags": [
          "Encounter Type Management"
        ],
        "description": "Retrieve all encounter types including built-in and custom types.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListEncounterTypesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounter types retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EncounterTypeListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-encounter/query/by-character": {
      "post": {
        "summary": "Get character's encounters (paginated)",
        "operationId": "queryByCharacter",
        "tags": [
          "Queries"
        ],
        "description": "Retrieves all encounters for a character with optional filtering.\nMemory decay is applied lazily on access.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryByCharacterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounters retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EncounterListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-encounter/query/between": {
      "post": {
        "summary": "Get encounters between two characters",
        "operationId": "queryBetween",
        "tags": [
          "Queries"
        ],
        "description": "Retrieves all encounters between two specific characters.\nUseful for relationship history and dialogue context.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryBetweenRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounters retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EncounterListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-encounter/query/by-location": {
      "post": {
        "summary": "Recent encounters at location",
        "operationId": "queryByLocation",
        "tags": [
          "Queries"
        ],
        "description": "Retrieves recent encounters at a specific location.\nUseful for scene context and area history.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryByLocationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Encounters retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EncounterListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-encounter/has-met": {
      "post": {
        "summary": "Quick check if two characters have met",
        "operationId": "hasMet",
        "tags": [
          "Queries"
        ],
        "description": "Fast boolean check for whether two characters have any recorded encounters.\nDoes not apply memory decay or return encounter details.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HasMetRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Check completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HasMetResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-encounter/get-sentiment": {
      "post": {
        "summary": "Aggregate sentiment toward another character",
        "operationId": "getSentiment",
        "tags": [
          "Queries"
        ],
        "description": "Calculates the aggregate sentiment a character has toward another based\non all their encounters. Memory strength is factored into the calculation.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSentimentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Sentiment calculated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SentimentResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-encounter/get-perspective": {
      "post": {
        "summary": "Get character's view of encounter",
        "operationId": "getPerspective",
        "tags": [
          "Perspectives"
        ],
        "description": "Retrieves a specific character's perspective on an encounter.\nIncludes emotional impact, sentiment shift, and memory strength.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetPerspectiveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Perspective retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PerspectiveResponse"
                }
              }
            }
          },
          "404": {
            "description": "Perspective not found"
          }
        }
      }
    },
    "/character-encounter/get-compress-data": {
      "post": {
        "summary": "Get encounter data for compression",
        "operationId": "getCompressData",
        "tags": [
          "Compression"
        ],
        "description": "Called by Resource service during character compression.\nReturns encounters and perspectives involving this character for archival.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCompressDataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Compressed data returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CharacterEncounterArchive"
                }
              }
            }
          },
          "404": {
            "description": "No encounter data for character"
          }
        }
      }
    },
    "/character-history/get-participation": {
      "post": {
        "summary": "Get all historical events a character participated in",
        "operationId": "getParticipation",
        "tags": [
          "Historical Events"
        ],
        "description": "Retrieves all historical event participation records for a character.\nSupports filtering by event category and minimum significance.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetParticipationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Participation records retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ParticipationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-history/get-event-participants": {
      "post": {
        "summary": "Get all characters who participated in a historical event",
        "operationId": "getEventParticipants",
        "tags": [
          "Historical Events"
        ],
        "description": "Retrieves all characters who participated in a specific historical event.\nUseful for generating event summaries or finding related characters.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEventParticipantsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Participants retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ParticipationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/character-history/get-backstory": {
      "post": {
        "summary": "Get machine-readable backstory elements for behavior system",
        "operationId": "getBackstory",
        "tags": [
          "Backstory"
        ],
        "description": "Retrieves structured backstory elements for a character. These elements\nare machine-readable key-value pairs used by the behavior system for\ndecision-making, not narrative text for players.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetBackstoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Backstory retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackstoryResponse"
                }
              }
            }
          },
          "404": {
            "description": "No backstory defined for this character"
          }
        }
      }
    },
    "/character-history/get-compress-data": {
      "post": {
        "summary": "Get history data for compression",
        "operationId": "getCompressData",
        "tags": [
          "Compression"
        ],
        "description": "Called by Resource service during character compression.\nReturns historical participations, backstory elements, and text summaries for archival.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCompressDataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Compressed data returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CharacterHistoryArchive"
                }
              }
            }
          },
          "404": {
            "description": "No history data for character"
          }
        }
      }
    },
    "/character-personality/get": {
      "post": {
        "summary": "Get personality for a character",
        "operationId": "getPersonality",
        "tags": [
          "Personality Management"
        ],
        "description": "Retrieves the personality profile for a character. Returns 404 if no\npersonality has been defined for this character.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetPersonalityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Personality retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PersonalityResponse"
                }
              }
            }
          },
          "404": {
            "description": "No personality defined for this character"
          }
        }
      }
    },
    "/character-personality/get-combat": {
      "post": {
        "summary": "Get combat preferences for a character",
        "operationId": "getCombatPreferences",
        "tags": [
          "Combat Preferences"
        ],
        "description": "Retrieves the combat preferences for a character. Combat preferences\ninfluence tactical decisions in the behavior system, including engagement\nstyle, positioning, and retreat conditions.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCombatPreferencesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Combat preferences retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CombatPreferencesResponse"
                }
              }
            }
          },
          "404": {
            "description": "No combat preferences defined for this character"
          }
        }
      }
    },
    "/character-personality/get-compress-data": {
      "post": {
        "summary": "Get personality data for compression",
        "operationId": "getCompressData",
        "tags": [
          "Compression"
        ],
        "description": "Called by Resource service during character compression.\nReturns personality traits and combat preferences for archival.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCompressDataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Compressed data returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CharacterPersonalityArchive"
                }
              }
            }
          },
          "404": {
            "description": "No personality data for character"
          }
        }
      }
    },
    "/character-personality/cleanup-by-character": {
      "post": {
        "summary": "Cleanup all personality data for a deleted character",
        "operationId": "cleanupByCharacter",
        "tags": [
          "Resource Cleanup"
        ],
        "description": "Called by lib-resource cleanup coordination when a character is deleted.\nRemoves BOTH personality traits AND combat preferences for the specified character.\nThis endpoint is designed for internal service-to-service calls during\ncascading resource cleanup.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CleanupByCharacterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cleanup completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupByCharacterResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/type/register": {
      "post": {
        "operationId": "RegisterRoomType",
        "summary": "Register a new room type",
        "description": "Registers a new room type definition. Room types are a dynamic registry of string codes. Built-in types (text, sentiment, emoji) are pre-registered on startup. Custom types are added via this endpoint. Returns conflict if code already exists for the given game service scope.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegisterRoomTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Room type registered successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RoomTypeResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/type/get": {
      "post": {
        "operationId": "GetRoomType",
        "summary": "Get room type by code",
        "description": "Returns the room type definition for the specified code and optional game service scope.",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRoomTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Room type found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RoomTypeResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/type/list": {
      "post": {
        "operationId": "ListRoomTypes",
        "summary": "List room types with filters",
        "description": "Returns room types matching the specified filters with pagination.",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRoomTypesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Room types returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListRoomTypesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/type/update": {
      "post": {
        "operationId": "UpdateRoomType",
        "summary": "Update a room type definition",
        "description": "Updates mutable fields of a room type definition. Cannot change code or message format.",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateRoomTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Room type updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RoomTypeResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/type/deprecate": {
      "post": {
        "operationId": "DeprecateRoomType",
        "summary": "Soft-deprecate a room type",
        "description": "Sets the room type status to Deprecated. Existing rooms continue to work but no new rooms can be created with this type.",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeprecateRoomTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Room type deprecated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RoomTypeResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/room/create": {
      "post": {
        "operationId": "CreateRoom",
        "summary": "Create a chat room",
        "description": "Creates a new chat room of the specified type. Optionally associates a governing contract that drives room lifecycle (lock, archive, delete) on contract state changes.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateRoomRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Room created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatRoomResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/room/get": {
      "post": {
        "operationId": "GetRoom",
        "summary": "Get room by ID",
        "description": "Returns the chat room metadata for the specified room ID.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRoomRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Room found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatRoomResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/room/list": {
      "post": {
        "operationId": "ListRooms",
        "summary": "List rooms with filters",
        "description": "Returns rooms matching the specified filters with pagination.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRoomsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Rooms returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListRoomsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/room/update": {
      "post": {
        "operationId": "UpdateRoom",
        "summary": "Update room settings",
        "description": "Updates mutable room settings. Caller must be the room owner.",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateRoomRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Room updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatRoomResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/room/delete": {
      "post": {
        "operationId": "DeleteRoom",
        "summary": "Delete a room",
        "description": "Deletes a room, removing all participants and messages. Caller must be the room owner or the room must be empty.",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteRoomRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Room deleted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatRoomResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/room/archive": {
      "post": {
        "operationId": "ArchiveRoom",
        "summary": "Archive a room to Resource",
        "description": "Archives a persistent room via lib-resource, preserving message history and metadata. Room is marked as archived after successful archival.",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ArchiveRoomRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Room archived",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatRoomResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/room/join": {
      "post": {
        "operationId": "JoinRoom",
        "summary": "Join a chat room",
        "description": "Joins the caller to the specified room. For companion rooms in AutoJoinLazy or Manual mode, the room is created on-the-fly if it does not yet exist. Returns conflict if the room is full or forbidden if the caller is banned.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/JoinRoomRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Joined room",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatRoomResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/room/leave": {
      "post": {
        "operationId": "LeaveRoom",
        "summary": "Leave a chat room",
        "description": "Removes the caller from the room. If the owner leaves, promotes the next moderator or oldest member.",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LeaveRoomRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Left room",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatRoomResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/room/participants": {
      "post": {
        "operationId": "ListParticipants",
        "summary": "List room participants",
        "description": "Returns all current participants in the room with their roles and status.",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListParticipantsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Participants returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ParticipantsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/room/participant/kick": {
      "post": {
        "operationId": "KickParticipant",
        "summary": "Remove a participant from the room",
        "description": "Kicks a participant from the room. Caller must be Owner or Moderator with higher role than target.",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KickParticipantRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Participant kicked",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatRoomResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/room/participant/ban": {
      "post": {
        "operationId": "BanParticipant",
        "summary": "Ban a participant from the room",
        "description": "Bans a participant. If currently in the room, they are kicked first. Optionally set a duration; null means permanent.",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BanParticipantRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Participant banned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatRoomResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/room/participant/unban": {
      "post": {
        "operationId": "UnbanParticipant",
        "summary": "Unban a participant",
        "description": "Removes a ban record for a participant. Caller must be Owner or Moderator.",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnbanParticipantRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Participant unbanned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatRoomResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/room/participant/mute": {
      "post": {
        "operationId": "MuteParticipant",
        "summary": "Mute a participant",
        "description": "Mutes a participant, preventing them from sending messages. Optionally set a duration; null means permanent.",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MuteParticipantRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Participant muted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatRoomResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/message/send": {
      "post": {
        "operationId": "SendMessage",
        "summary": "Send a message to a room",
        "description": "Sends a message to the specified room. Content is validated against the room type's message format and validator config. For AutoJoinLazy companion rooms, the room is created and the sender auto-joined if the room does not yet exist.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SendMessageRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Message sent",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatMessageResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/message/send-batch": {
      "post": {
        "operationId": "SendMessageBatch",
        "summary": "Send multiple messages",
        "description": "Sends multiple messages to a room atomically. Intended for bulk sentiment pushes from higher-layer services.",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SendMessageBatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Messages sent",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SendMessageBatchResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/message/history": {
      "post": {
        "operationId": "GetMessageHistory",
        "summary": "Get message history",
        "description": "Returns paginated message history for a room, ordered by timestamp descending. Uses cursor-based pagination.",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MessageHistoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Messages returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MessageHistoryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/message/delete": {
      "post": {
        "operationId": "DeleteMessage",
        "summary": "Delete a message",
        "description": "Deletes a specific message. Caller must be the message sender, room Owner, or Moderator.",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteMessageRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Message deleted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatMessageResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/message/pin": {
      "post": {
        "operationId": "PinMessage",
        "summary": "Pin a message",
        "description": "Pins a message in the room. Caller must be Owner or Moderator. Returns conflict if max pinned messages reached.",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PinMessageRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Message pinned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatMessageResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/message/unpin": {
      "post": {
        "operationId": "UnpinMessage",
        "summary": "Unpin a message",
        "description": "Unpins a previously pinned message. Caller must be Owner or Moderator.",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnpinMessageRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Message unpinned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatMessageResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/message/search": {
      "post": {
        "operationId": "SearchMessages",
        "summary": "Full-text search in persistent rooms",
        "description": "Searches message content in persistent rooms using MySQL full-text search. Not available for ephemeral rooms.",
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "chat": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchMessagesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Search results returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchMessagesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/admin/rooms": {
      "post": {
        "operationId": "AdminListRooms",
        "summary": "List all rooms system-wide",
        "description": "Returns all rooms across the system for administrative purposes. Supports filtering by status and type.",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AdminListRoomsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Rooms returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListRoomsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/admin/stats": {
      "post": {
        "operationId": "AdminGetStats",
        "summary": "Room and message statistics",
        "description": "Returns system-wide chat statistics for monitoring and debugging.",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AdminGetStatsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Statistics returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AdminStatsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/chat/admin/cleanup": {
      "post": {
        "operationId": "AdminForceCleanup",
        "summary": "Force cleanup of idle rooms",
        "description": "Triggers an immediate idle room cleanup cycle, bypassing the normal interval.",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AdminForceCleanupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cleanup executed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AdminCleanupResponse"
                }
              }
            }
          }
        }
      }
    },
    "/collection/entry-template/create": {
      "post": {
        "operationId": "createEntryTemplate",
        "tags": [
          "EntryTemplate"
        ],
        "summary": "Create an entry template",
        "description": "Create an entry template defining a collectible content item. Each template\nhas a unique code within its collection type and game service, references\nan item template for inventory placement, and includes display/metadata fields.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateEntryTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Entry template created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (validation error)"
          },
          "404": {
            "description": "Referenced game service or item template not found"
          },
          "409": {
            "description": "Duplicate code for this collection type and game service"
          }
        }
      }
    },
    "/collection/entry-template/get": {
      "post": {
        "operationId": "getEntryTemplate",
        "tags": [
          "EntryTemplate"
        ],
        "summary": "Get an entry template by ID",
        "description": "Retrieves an entry template by its unique identifier.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEntryTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Entry template retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryTemplateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Entry template not found"
          }
        }
      }
    },
    "/collection/entry-template/list": {
      "post": {
        "operationId": "listEntryTemplates",
        "tags": [
          "EntryTemplate"
        ],
        "summary": "List entry templates",
        "description": "Paginated list of entry templates filtered by collection type, game service, and optional category.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListEntryTemplatesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Entry templates retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListEntryTemplatesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/collection/entry-template/update": {
      "post": {
        "operationId": "updateEntryTemplate",
        "tags": [
          "EntryTemplate"
        ],
        "summary": "Update an entry template",
        "description": "Update mutable fields of an entry template (displayName, tags, assets, unlockHint, themes, music metadata).",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateEntryTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Entry template updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryTemplateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Entry template not found"
          }
        }
      }
    },
    "/collection/entry-template/delete": {
      "post": {
        "operationId": "deleteEntryTemplate",
        "tags": [
          "EntryTemplate"
        ],
        "summary": "Delete an entry template",
        "description": "Delete an entry template. Warns if instances reference it but does not block deletion.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteEntryTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Entry template deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryTemplateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Entry template not found"
          }
        }
      }
    },
    "/collection/entry-template/seed": {
      "post": {
        "operationId": "seedEntryTemplates",
        "tags": [
          "EntryTemplate"
        ],
        "summary": "Bulk seed entry templates",
        "description": "Bulk create entry templates from a payload, skipping duplicates. Validates item template IDs. Returns count of created templates.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SeedEntryTemplatesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedEntryTemplatesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (validation errors)"
          }
        }
      }
    },
    "/collection/create": {
      "post": {
        "operationId": "createCollection",
        "tags": [
          "Collection"
        ],
        "summary": "Create a collection for an owner",
        "description": "Create a collection instance for an owner entity. One collection per type\nper game service per owner (ownerId + ownerType). Creates an inventory\ncontainer (unlimited type) to hold unlocked entry items.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateCollectionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Collection created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Referenced game service not found"
          },
          "409": {
            "description": "Duplicate collection type for this owner and game service, or max collections exceeded"
          }
        }
      }
    },
    "/collection/get": {
      "post": {
        "operationId": "getCollection",
        "tags": [
          "Collection"
        ],
        "summary": "Get a collection with unlocked entry summary",
        "description": "Retrieves a collection instance with its unlocked entry count.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCollectionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Collection retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Collection not found"
          }
        }
      }
    },
    "/collection/list": {
      "post": {
        "operationId": "listCollections",
        "tags": [
          "Collection"
        ],
        "summary": "List all collections for an owner",
        "description": "List all collection instances for an owner entity, with optional game service filter.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListCollectionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Collections retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListCollectionsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/collection/delete": {
      "post": {
        "operationId": "deleteCollection",
        "tags": [
          "Collection"
        ],
        "summary": "Delete a collection and its inventory container",
        "description": "Delete a collection instance, destroying its inventory container and all contained entry items.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteCollectionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Collection deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Collection not found"
          }
        }
      }
    },
    "/collection/grant": {
      "post": {
        "operationId": "grantEntry",
        "tags": [
          "Entry"
        ],
        "summary": "Grant/unlock an entry (idempotent)",
        "description": "Grant an entry to a collection. Idempotent: returns existing if already\nunlocked. Auto-creates collection instance (and inventory container)\nif one does not exist for this owner+type+game. Creates an item instance\nand places it in the collection container.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GrantEntryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Entry granted (or already unlocked)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GrantEntryResponse"
                }
              }
            }
          },
          "404": {
            "description": "Entry template not found"
          },
          "409": {
            "description": "Max entries reached or item creation failed"
          }
        }
      }
    },
    "/collection/has": {
      "post": {
        "operationId": "hasEntry",
        "tags": [
          "Entry"
        ],
        "summary": "Check if owner has a specific entry",
        "description": "Check if an owner has a specific entry unlocked in their collection.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HasEntryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Check completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HasEntryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/collection/query": {
      "post": {
        "operationId": "queryEntries",
        "tags": [
          "Entry"
        ],
        "summary": "Query unlocked entries with filtering",
        "description": "Query unlocked entries in a collection with optional filtering by category, tags, and metadata.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryEntriesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Entries retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryEntriesResponse"
                }
              }
            }
          },
          "404": {
            "description": "Collection not found"
          }
        }
      }
    },
    "/collection/update-metadata": {
      "post": {
        "operationId": "updateEntryMetadata",
        "tags": [
          "Entry"
        ],
        "summary": "Update entry instance metadata",
        "description": "Update metadata for an unlocked entry (play count, kill count, favorites, discovery level, custom data).",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateEntryMetadataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Metadata updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnlockedEntryResponse"
                }
              }
            }
          },
          "404": {
            "description": "Collection or entry not found"
          }
        }
      }
    },
    "/collection/stats": {
      "post": {
        "operationId": "getCompletionStats",
        "tags": [
          "Entry"
        ],
        "summary": "Get completion statistics per collection type",
        "description": "Get completion statistics for a collection including total entries, unlocked count, percentage, and breakdown by category.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCompletionStatsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Statistics retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CompletionStatsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Collection not found"
          }
        }
      }
    },
    "/collection/content/select-for-area": {
      "post": {
        "operationId": "selectContentForArea",
        "tags": [
          "Content"
        ],
        "summary": "Select content for an area based on unlocked library",
        "description": "Select a content entry for an area based on the owner's unlocked collection\nand area theme configuration. Uses weighted random selection based on theme overlap.\nFalls back to the area's default entry if no matches are found.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SelectContentForAreaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Content selected successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentSelectionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Area config not found or no matching collection exists"
          }
        }
      }
    },
    "/collection/content/area-config/set": {
      "post": {
        "operationId": "setAreaContentConfig",
        "tags": [
          "Content"
        ],
        "summary": "Set area-to-theme mapping",
        "description": "Create or update an area content configuration that maps an area code to themes and a default entry.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetAreaContentConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Area content config saved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AreaContentConfigResponse"
                }
              }
            }
          },
          "404": {
            "description": "Game service or default entry template not found"
          }
        }
      }
    },
    "/collection/content/area-config/get": {
      "post": {
        "operationId": "getAreaContentConfig",
        "tags": [
          "Content"
        ],
        "summary": "Get area content config",
        "description": "Get the content configuration for a specific area and game service.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetAreaContentConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Area content config retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AreaContentConfigResponse"
                }
              }
            }
          },
          "404": {
            "description": "Area content config not found"
          }
        }
      }
    },
    "/collection/content/area-config/list": {
      "post": {
        "operationId": "listAreaContentConfigs",
        "tags": [
          "Content"
        ],
        "summary": "List area configs for a game service",
        "description": "List all area content configurations for a game service.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListAreaContentConfigsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Area content configs retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListAreaContentConfigsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/collection/discovery/advance": {
      "post": {
        "operationId": "advanceDiscovery",
        "tags": [
          "Discovery"
        ],
        "summary": "Advance progressive discovery level",
        "description": "Advance the discovery level of an unlocked entry (bestiary-style progressive\nreveal). Each level reveals additional information about the entry as defined\nin the entry template's discovery levels.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AdvanceDiscoveryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Discovery level advanced",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AdvanceDiscoveryResponse"
                }
              }
            }
          },
          "404": {
            "description": "Collection or entry not found, or entry not unlocked"
          },
          "409": {
            "description": "Already at max discovery level"
          }
        }
      }
    },
    "/client-capabilities": {
      "post": {
        "summary": "Get client capability manifest (GUID \u2192 API mappings)",
        "operationId": "getClientCapabilities",
        "tags": [
          "Client Capabilities"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "description": "Returns the capability manifest for the authenticated client's session.\nMaps client-salted GUIDs to available API endpoints based on the client's\ncurrent permissions and session state.\n\n**Security**: Each client receives unique GUIDs for the same API endpoints.\nThis prevents cross-session exploitation and enables per-client rate limiting.\n\n**Dynamic Updates**: Capabilities may change during a session when:\n- Role changes occur (admin promotion, etc.)\n- Subscription status changes\n- Session state transitions\n\nClients should listen for capability update events via WebSocket to stay current.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetClientCapabilitiesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Client capabilities retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClientCapabilitiesResponse"
                }
              }
            }
          },
          "401": {
            "description": "Not authenticated - requires valid session"
          },
          "500": {
            "description": "Error retrieving capabilities"
          }
        }
      }
    },
    "/contract/template/get": {
      "post": {
        "operationId": "getContractTemplate",
        "tags": [
          "Templates"
        ],
        "summary": "Get template by ID or code",
        "description": "Retrieves a contract template by its unique ID or code.\nAt least one of templateId or code must be provided.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetContractTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Neither templateId nor code provided"
          },
          "404": {
            "description": "Template not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/template/list": {
      "post": {
        "operationId": "listContractTemplates",
        "tags": [
          "Templates"
        ],
        "summary": "List templates with filters",
        "description": "Lists contract templates with optional filtering by realm, active status,\nand search term.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListContractTemplatesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Templates retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListContractTemplatesResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/create": {
      "post": {
        "operationId": "createContractInstance",
        "tags": [
          "Instances"
        ],
        "summary": "Create contract instance from template",
        "description": "Creates a new contract instance from a template. The instance starts\nin 'draft' status and must be proposed to parties before activation.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateContractInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Instance created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (missing required parties, invalid terms)"
          },
          "404": {
            "description": "Template not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/propose": {
      "post": {
        "operationId": "proposeContractInstance",
        "tags": [
          "Instances"
        ],
        "summary": "Propose contract to parties (starts consent flow)",
        "description": "Moves a draft contract to 'proposed' status and notifies parties.\nParties must consent before the contract becomes active.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProposeContractInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Contract proposed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Contract not in draft status"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/consent": {
      "post": {
        "operationId": "consentToContract",
        "tags": [
          "Instances"
        ],
        "summary": "Party consents to contract",
        "description": "Records a party's consent to a proposed contract. When all required\nparties consent, the contract moves to 'accepted' then 'active' status.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConsentToContractRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Consent recorded successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Party not part of this contract or already consented"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/get": {
      "post": {
        "operationId": "getContractInstance",
        "tags": [
          "Instances"
        ],
        "summary": "Get instance by ID",
        "description": "Retrieves a contract instance by its unique ID.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetContractInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Instance retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractInstanceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Instance not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/query": {
      "post": {
        "operationId": "queryContractInstances",
        "tags": [
          "Instances"
        ],
        "summary": "Query instances by party, template, status",
        "description": "Queries contract instances with various filters. At least one filter\nmust be provided.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryContractInstancesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Instances retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryContractInstancesResponse"
                }
              }
            }
          },
          "400": {
            "description": "No filter criteria provided"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/terminate": {
      "post": {
        "operationId": "terminateContractInstance",
        "tags": [
          "Instances"
        ],
        "summary": "Request early termination",
        "description": "Requests early termination of an active contract. Depending on the\ncontract's termination policy, this may require mutual consent or\nincur penalties.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TerminateContractInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Termination processed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Contract cannot be terminated (policy violation)"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/get-status": {
      "post": {
        "operationId": "getContractInstanceStatus",
        "tags": [
          "Instances"
        ],
        "summary": "Get current status and milestone progress",
        "description": "Gets the current status of a contract including milestone progress,\npending consents, and any active breaches.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetContractInstanceStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Status retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractInstanceStatusResponse"
                }
              }
            }
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/milestone/complete": {
      "post": {
        "operationId": "completeMilestone",
        "tags": [
          "Milestones"
        ],
        "summary": "External system reports milestone completed",
        "description": "Called by external systems to report that a milestone's conditions\nhave been met. Triggers onComplete prebound APIs and may advance\ncontract status.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompleteMilestoneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Milestone completed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MilestoneResponse"
                }
              }
            }
          },
          "400": {
            "description": "Milestone not in valid state for completion"
          },
          "404": {
            "description": "Contract or milestone not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/milestone/fail": {
      "post": {
        "operationId": "failMilestone",
        "tags": [
          "Milestones"
        ],
        "summary": "External system reports milestone failed",
        "description": "Called by external systems to report that a milestone has failed\n(e.g., deadline passed, conditions cannot be met). Triggers onExpire\nprebound APIs and may record a breach.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FailMilestoneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Milestone failure recorded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MilestoneResponse"
                }
              }
            }
          },
          "400": {
            "description": "Milestone not in valid state for failure"
          },
          "404": {
            "description": "Contract or milestone not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/milestone/get": {
      "post": {
        "operationId": "getMilestone",
        "tags": [
          "Milestones"
        ],
        "summary": "Get milestone details and status",
        "description": "Gets the current state of a specific milestone.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetMilestoneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Milestone retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MilestoneResponse"
                }
              }
            }
          },
          "404": {
            "description": "Contract or milestone not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/breach/report": {
      "post": {
        "operationId": "reportBreach",
        "tags": [
          "Breaches"
        ],
        "summary": "Report a contract breach",
        "description": "Reports a breach of contract terms. This can be called by parties\nor external systems. The breach enters a grace period for cure\nif configured.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReportBreachRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Breach reported successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BreachResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid breach report"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/breach/cure": {
      "post": {
        "operationId": "cureBreach",
        "tags": [
          "Breaches"
        ],
        "summary": "Mark breach as cured (system/admin action)",
        "description": "Marks a breach as cured within the grace period. This prevents\nconsequences from being applied. Called by systems that verify\nthe breach has been remedied.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CureBreachRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Breach cured successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BreachResponse"
                }
              }
            }
          },
          "400": {
            "description": "Breach not in curable state"
          },
          "404": {
            "description": "Breach not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/breach/get": {
      "post": {
        "operationId": "getBreach",
        "tags": [
          "Breaches"
        ],
        "summary": "Get breach details",
        "description": "Retrieves details of a specific breach record.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetBreachRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Breach retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BreachResponse"
                }
              }
            }
          },
          "404": {
            "description": "Breach not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/metadata/update": {
      "post": {
        "operationId": "updateContractMetadata",
        "tags": [
          "Metadata"
        ],
        "summary": "Update game metadata on instance",
        "description": "Updates game-specific metadata on a contract instance without\ntouching contract state. Used by higher-level systems (quests, etc.)\nto store additional context.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateContractMetadataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Metadata updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractMetadataResponse"
                }
              }
            }
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/metadata/get": {
      "post": {
        "operationId": "getContractMetadata",
        "tags": [
          "Metadata"
        ],
        "summary": "Get game metadata",
        "description": "Retrieves game-specific metadata from a contract instance.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetContractMetadataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Metadata retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContractMetadataResponse"
                }
              }
            }
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/check-constraint": {
      "post": {
        "operationId": "checkContractConstraint",
        "tags": [
          "Constraints"
        ],
        "summary": "Check if entity can take action given contracts",
        "description": "Checks whether an entity's proposed action would violate any\nactive contract constraints (exclusivity, non-compete, territory, etc.).\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CheckConstraintRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Constraint check completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckConstraintResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/query-active": {
      "post": {
        "operationId": "queryActiveContracts",
        "tags": [
          "Constraints"
        ],
        "summary": "Query active contracts for entity",
        "description": "Returns all active contracts where the specified entity is a party.\nUseful for displaying current obligations in UI.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryActiveContractsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Active contracts retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryActiveContractsResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/contract/lock": {
      "post": {
        "operationId": "lockContract",
        "tags": [
          "Guardian"
        ],
        "summary": "Lock contract under guardian custody",
        "description": "Locks a contract under guardian custody (e.g., escrow). A locked contract\ncannot be modified, terminated, or have parties transferred except by the\nguardian. Requires the contract template to have `transferable: true`.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LockContractRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Contract locked successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LockContractResponse"
                }
              }
            }
          },
          "400": {
            "description": "Contract not transferable"
          },
          "404": {
            "description": "Contract not found"
          },
          "409": {
            "description": "Contract already locked"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/unlock": {
      "post": {
        "operationId": "unlockContract",
        "tags": [
          "Guardian"
        ],
        "summary": "Unlock contract from guardian custody",
        "description": "Unlocks a contract from guardian custody. Only the current guardian can\nunlock a contract. Called on escrow refund to restore contract to original state.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnlockContractRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Contract unlocked successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnlockContractResponse"
                }
              }
            }
          },
          "403": {
            "description": "Not the current guardian"
          },
          "404": {
            "description": "Contract not found or not locked"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/transfer-party": {
      "post": {
        "operationId": "transferContractParty",
        "tags": [
          "Guardian"
        ],
        "summary": "Transfer party role to new entity",
        "description": "Transfers a party role to a new entity. Used by escrow to reassign contract\nroles on release (e.g., transfer landlord role to new property owner).\nContract must be locked and caller must be the guardian.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransferContractPartyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Party transferred successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransferContractPartyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Party not found in contract"
          },
          "403": {
            "description": "Not the current guardian or contract not locked"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/clause-type/list": {
      "post": {
        "operationId": "listClauseTypes",
        "tags": [
          "ClauseTypes"
        ],
        "summary": "List all registered clause types",
        "description": "Lists all registered clause types including built-in types and\ncustom-registered types.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListClauseTypesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Clause types listed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListClauseTypesResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/set-template-values": {
      "post": {
        "operationId": "setContractTemplateValues",
        "tags": [
          "Execution"
        ],
        "summary": "Set template values on contract instance",
        "description": "Sets template values on a contract instance. Called by escrow when binding\na contract to an escrow agreement. Template values are used for variable\nsubstitution in clause handlers (e.g., wallet IDs, container IDs).\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetTemplateValuesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template values set successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SetTemplateValuesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid template key format"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/check-asset-requirements": {
      "post": {
        "operationId": "checkAssetRequirements",
        "tags": [
          "Execution"
        ],
        "summary": "Check if asset requirement clauses are satisfied",
        "description": "Checks if all asset requirement clauses are satisfied. Uses template values\n(e.g., PartyA_EscrowWalletId) to query actual balances in escrow wallets/containers\nvia the registered clause type handlers.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CheckAssetRequirementsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Asset requirements checked",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckAssetRequirementsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Template values not set"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/contract/instance/execute": {
      "post": {
        "operationId": "executeContract",
        "tags": [
          "Execution"
        ],
        "summary": "Execute all contract clauses (idempotent)",
        "description": "Executes all contract distribution clauses - distribute assets per clauses,\ncollect fees, mark contract as executed. This is idempotent - calling twice\nreturns the same result without re-executing. Contract must be in fulfilled\nstatus and all template values must be set.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteContractRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Contract executed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExecuteContractResponse"
                }
              }
            }
          },
          "400": {
            "description": "Contract not in fulfilled status or template values missing"
          },
          "404": {
            "description": "Contract not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/definition/get": {
      "post": {
        "operationId": "getCurrencyDefinition",
        "tags": [
          "Currency Definition"
        ],
        "summary": "Get currency definition by ID or code",
        "description": "Retrieves a currency definition by its unique ID or code.\nAt least one of definitionId or code must be provided.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCurrencyDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Currency definition retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CurrencyDefinitionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Neither definitionId nor code provided"
          },
          "404": {
            "description": "Currency definition not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/definition/list": {
      "post": {
        "operationId": "listCurrencyDefinitions",
        "tags": [
          "Currency Definition"
        ],
        "summary": "List currency definitions with filters",
        "description": "Lists currency definitions with optional filtering by realm, scope,\nactive status, and base currency flag.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListCurrencyDefinitionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Currency definitions retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListCurrencyDefinitionsResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/wallet/create": {
      "post": {
        "operationId": "createWallet",
        "tags": [
          "Wallet"
        ],
        "summary": "Create a new wallet for an owner",
        "description": "Creates a new wallet for a polymorphic owner (account, character, NPC, guild, etc.).\nEach owner+ownerType+realm combination can have at most one wallet.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateWalletRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Wallet created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WalletResponse"
                }
              }
            }
          },
          "409": {
            "description": "Wallet already exists for this owner/realm"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/wallet/get": {
      "post": {
        "operationId": "getWallet",
        "tags": [
          "Wallet"
        ],
        "summary": "Get wallet by ID or owner",
        "description": "Retrieves a wallet by its ID, or by owner+ownerType+realm combination.\nReturns the wallet with all non-zero balances.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetWalletRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Wallet retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WalletWithBalancesResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/wallet/get-or-create": {
      "post": {
        "operationId": "getOrCreateWallet",
        "tags": [
          "Wallet"
        ],
        "summary": "Get existing wallet or create if not exists",
        "description": "Retrieves a wallet if it exists, otherwise creates a new one.\nUpsert pattern for convenience.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetOrCreateWalletRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Wallet retrieved or created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetOrCreateWalletResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/balance/get": {
      "post": {
        "operationId": "getBalance",
        "tags": [
          "Balance"
        ],
        "summary": "Get balance for a specific currency in a wallet",
        "description": "Retrieves the current balance for a specific currency in a wallet.\nIn lazy autogain mode, this may trigger autogain calculation and emit events.\nReturns earn cap info and autogain info when applicable.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetBalanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Balance retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetBalanceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet or currency not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/balance/batch-get": {
      "post": {
        "operationId": "batchGetBalances",
        "tags": [
          "Balance"
        ],
        "summary": "Get multiple balances in one call",
        "description": "Retrieves balances for multiple wallet+currency combinations.\nAutogain is applied where applicable.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchGetBalancesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Balances retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchGetBalancesResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/credit": {
      "post": {
        "operationId": "creditCurrency",
        "tags": [
          "Balance"
        ],
        "summary": "Credit currency to a wallet (faucet operation)",
        "description": "Credits currency to a wallet. This is a faucet operation (currency enters the system).\nEnforces earn caps, wallet caps, and global supply caps. Requires idempotency key.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreditCurrencyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Currency credited successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreditCurrencyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid transaction type or amount"
          },
          "404": {
            "description": "Wallet or currency not found"
          },
          "409": {
            "description": "Idempotency key already used"
          },
          "422": {
            "description": "Earn cap or supply cap exceeded"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/debit": {
      "post": {
        "operationId": "debitCurrency",
        "tags": [
          "Balance"
        ],
        "summary": "Debit currency from a wallet (sink operation)",
        "description": "Debits currency from a wallet. This is a sink operation (currency exits the system).\nChecks for sufficient funds unless negative balance is allowed.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DebitCurrencyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Currency debited successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DebitCurrencyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid transaction type or amount"
          },
          "404": {
            "description": "Wallet or currency not found"
          },
          "422": {
            "description": "Insufficient funds"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/transfer": {
      "post": {
        "operationId": "transferCurrency",
        "tags": [
          "Balance"
        ],
        "summary": "Transfer currency between wallets",
        "description": "Transfers currency from one wallet to another. Validates transferability,\nrealm compatibility, and sufficient funds.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransferCurrencyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transfer completed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransferCurrencyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or currency not transferable"
          },
          "404": {
            "description": "Wallet or currency not found"
          },
          "422": {
            "description": "Insufficient funds or cross-realm not allowed"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/batch-credit": {
      "post": {
        "operationId": "batchCreditCurrency",
        "tags": [
          "Balance"
        ],
        "summary": "Credit multiple wallets in one call",
        "description": "Credits currency to multiple wallets in one call. Each operation is independent;\nfailures do not rollback others. For atomic multi-wallet operations, use lib-escrow.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchCreditRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Batch credit processed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchCreditResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/convert/calculate": {
      "post": {
        "operationId": "calculateConversion",
        "tags": [
          "Conversion"
        ],
        "summary": "Calculate conversion without executing",
        "description": "Previews a currency conversion calculation without executing it.\nUses base currency exchange rates to compute the effective rate.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CalculateConversionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Conversion calculated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CalculateConversionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Currency not found"
          },
          "422": {
            "description": "No base currency or missing exchange rate"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/convert/execute": {
      "post": {
        "operationId": "executeConversion",
        "tags": [
          "Conversion"
        ],
        "summary": "Execute currency conversion in a wallet",
        "description": "Executes a currency conversion within a single wallet. Debits the source\ncurrency and credits the target currency at the computed exchange rate.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteConversionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Conversion executed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExecuteConversionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet or currency not found"
          },
          "422": {
            "description": "Insufficient funds or missing exchange rate"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/exchange-rate/get": {
      "post": {
        "operationId": "getExchangeRate",
        "tags": [
          "Conversion"
        ],
        "summary": "Get exchange rate between two currencies",
        "description": "Retrieves the exchange rate between two currencies using the base currency\nas an intermediary.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetExchangeRateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Exchange rate retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetExchangeRateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Currency not found"
          },
          "422": {
            "description": "No base currency or missing exchange rate"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/transaction/get": {
      "post": {
        "operationId": "getTransaction",
        "tags": [
          "Transaction History"
        ],
        "summary": "Get a transaction by ID",
        "description": "Retrieves a single transaction record by its unique ID.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetTransactionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transaction retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Transaction not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/transaction/history": {
      "post": {
        "operationId": "getTransactionHistory",
        "tags": [
          "Transaction History"
        ],
        "summary": "Get paginated transaction history for a wallet",
        "description": "Retrieves transaction history for a wallet with optional filters\nby currency, transaction type, and date range.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetTransactionHistoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transaction history retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetTransactionHistoryResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/transaction/by-reference": {
      "post": {
        "operationId": "getTransactionsByReference",
        "tags": [
          "Transaction History"
        ],
        "summary": "Get transactions by reference type and ID",
        "description": "Retrieves all transactions linked to a specific reference (quest, auction,\nescrow, etc.).\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetTransactionsByReferenceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transactions retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetTransactionsByReferenceResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/stats/global-supply": {
      "post": {
        "operationId": "getGlobalSupply",
        "tags": [
          "Analytics"
        ],
        "summary": "Get global supply statistics for a currency",
        "description": "Returns aggregate supply statistics including total supply, circulation,\nescrow amounts, and lifetime mint/burn totals.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetGlobalSupplyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Supply statistics retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetGlobalSupplyResponse"
                }
              }
            }
          },
          "404": {
            "description": "Currency not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/currency/escrow/deposit": {
      "post": {
        "operationId": "escrowDeposit",
        "tags": [
          "Escrow Integration"
        ],
        "summary": "Debit wallet for escrow deposit",
        "description": "Called by lib-escrow when a party deposits currency into an escrow agreement.\nImmediately debits the wallet (no lock tracking needed - escrow owns the funds).\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EscrowDepositRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Escrow deposit processed (wallet debited)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowDepositResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet or currency not found"
          },
          "422": {
            "description": "Insufficient funds or wallet frozen"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/escrow/release": {
      "post": {
        "operationId": "escrowRelease",
        "tags": [
          "Escrow Integration"
        ],
        "summary": "Credit recipient on escrow completion",
        "description": "Called by lib-escrow when an escrow agreement completes successfully.\nCredits the recipient wallet with the released funds.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EscrowReleaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Escrow release processed (recipient credited)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowReleaseResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet or currency not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/escrow/refund": {
      "post": {
        "operationId": "escrowRefund",
        "tags": [
          "Escrow Integration"
        ],
        "summary": "Credit depositor on escrow refund",
        "description": "Called by lib-escrow when an escrow agreement is cancelled or refunded.\nCredits the original depositor wallet with the refunded funds.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EscrowRefundRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Escrow refund processed (depositor credited)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EscrowRefundResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet or currency not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/hold/create": {
      "post": {
        "operationId": "createHold",
        "tags": [
          "Authorization Hold"
        ],
        "summary": "Create an authorization hold (reserve funds)",
        "description": "Creates an authorization hold that reserves funds without debiting.\nThe held amount reduces the effective balance but does not leave the wallet.\nUsed for pre-auth scenarios (dining, gas, hotels) where final amount may differ.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateHoldRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Hold created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HoldResponse"
                }
              }
            }
          },
          "404": {
            "description": "Wallet or currency not found"
          },
          "422": {
            "description": "Insufficient effective balance for hold"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/hold/capture": {
      "post": {
        "operationId": "captureHold",
        "tags": [
          "Authorization Hold"
        ],
        "summary": "Capture held funds (debit final amount)",
        "description": "Captures an active hold by debiting the final amount (which may be less than\nor equal to the held amount). Any difference is released back to available balance.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CaptureHoldRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Hold captured successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CaptureHoldResponse"
                }
              }
            }
          },
          "400": {
            "description": "Hold is not in active status or capture amount exceeds hold"
          },
          "404": {
            "description": "Hold not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/hold/release": {
      "post": {
        "operationId": "releaseHold",
        "tags": [
          "Authorization Hold"
        ],
        "summary": "Release held funds (make available again)",
        "description": "Releases an active hold, making all held funds available again.\nNo debit occurs.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReleaseHoldRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Hold released successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HoldResponse"
                }
              }
            }
          },
          "400": {
            "description": "Hold is not in active status"
          },
          "404": {
            "description": "Hold not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/currency/hold/get": {
      "post": {
        "operationId": "getHold",
        "tags": [
          "Authorization Hold"
        ],
        "summary": "Get hold status and details",
        "description": "Retrieves the current status and details of an authorization hold.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetHoldRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Hold retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HoldResponse"
                }
              }
            }
          },
          "404": {
            "description": "Hold not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/divine/deity/create": {
      "post": {
        "summary": "Create a new deity",
        "description": "Creates a deity entity with domain influences and personality traits.\nProvisions a divinity currency wallet, a domain power seed, and optionally\nstarts a deity watcher actor via Puppetmaster.\n",
        "operationId": "createDeity",
        "tags": [
          "Deity Management"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateDeityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Deity created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeityResponse"
                }
              }
            }
          },
          "404": {
            "description": "Game service not found"
          },
          "409": {
            "description": "Deity with this code already exists for this game service"
          }
        }
      }
    },
    "/divine/deity/get": {
      "post": {
        "summary": "Get a deity by ID",
        "description": "Returns a single deity entity by its unique identifier.",
        "operationId": "getDeity",
        "tags": [
          "Deity Management"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetDeityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Deity found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeityResponse"
                }
              }
            }
          },
          "404": {
            "description": "Deity not found"
          }
        }
      }
    },
    "/divine/deity/get-by-code": {
      "post": {
        "summary": "Get a deity by code within a game service",
        "description": "Looks up a deity by its unique code within a game service scope.",
        "operationId": "getDeityByCode",
        "tags": [
          "Deity Management"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetDeityByCodeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Deity found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeityResponse"
                }
              }
            }
          },
          "404": {
            "description": "Deity not found for this game service and code"
          }
        }
      }
    },
    "/divine/deity/list": {
      "post": {
        "summary": "List deities with optional filters",
        "description": "Returns a paginated list of deities for a game service, optionally\nfiltered by domain code and status.\n",
        "operationId": "listDeities",
        "tags": [
          "Deity Management"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListDeitiesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Deities listed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListDeitiesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/divine/deity/update": {
      "post": {
        "summary": "Update deity properties",
        "description": "Partial update of deity properties. Only non-null fields are applied.\nRequires a distributed lock on the deity.\n",
        "operationId": "updateDeity",
        "tags": [
          "Deity Management"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateDeityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Deity updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeityResponse"
                }
              }
            }
          },
          "404": {
            "description": "Deity not found"
          },
          "409": {
            "description": "Concurrent modification conflict"
          }
        }
      }
    },
    "/divine/deity/activate": {
      "post": {
        "summary": "Activate a dormant deity",
        "description": "Sets the deity status to Active. If Puppetmaster is available and no\nwatcher actor exists, starts one. Publishes a deity activated event.\n",
        "operationId": "activateDeity",
        "tags": [
          "Deity Management"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ActivateDeityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Deity activated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeityResponse"
                }
              }
            }
          },
          "400": {
            "description": "Deity is already active"
          },
          "404": {
            "description": "Deity not found"
          }
        }
      }
    },
    "/divine/deity/deactivate": {
      "post": {
        "summary": "Deactivate an active deity",
        "description": "Sets the deity status to Dormant. Stops the watcher actor if Puppetmaster\nis available. Clears all attention slots. Publishes a deity dormant event.\n",
        "operationId": "deactivateDeity",
        "tags": [
          "Deity Management"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeactivateDeityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Deity deactivated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeityResponse"
                }
              }
            }
          },
          "400": {
            "description": "Deity is already dormant or archived"
          },
          "404": {
            "description": "Deity not found"
          }
        }
      }
    },
    "/divine/deity/delete": {
      "post": {
        "summary": "Delete a deity",
        "description": "Permanently deletes a deity and all dependent data. Deactivates the deity\nif active, revokes all blessings, removes all follower relationships, deletes\nattention slots, and coordinates cleanup via lib-resource. Publishes a\nlifecycle deleted event.\n",
        "operationId": "deleteDeity",
        "tags": [
          "Deity Management"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteDeityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Deity deleted"
          },
          "404": {
            "description": "Deity not found"
          }
        }
      }
    },
    "/divine/divinity/get-balance": {
      "post": {
        "summary": "Get a deity's divinity balance",
        "description": "Returns the current divinity balance for a deity by querying its currency wallet.",
        "operationId": "getDivinityBalance",
        "tags": [
          "Divinity Economy"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetDivinityBalanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Balance retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DivinityBalanceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Deity not found"
          }
        }
      }
    },
    "/divine/divinity/credit": {
      "post": {
        "summary": "Credit divinity to a deity",
        "description": "Credits divinity to a deity's currency wallet. Used for mortal actions\nin the deity's domain, direct grants, or other divinity generation sources.\n",
        "operationId": "creditDivinity",
        "tags": [
          "Divinity Economy"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreditDivinityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Divinity credited",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DivinityBalanceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Deity not found"
          }
        }
      }
    },
    "/divine/divinity/debit": {
      "post": {
        "summary": "Debit divinity from a deity",
        "description": "Debits divinity from a deity's currency wallet. Used for blessing grants,\nmiracles, or other divinity expenditures. Validates sufficient balance\nbefore debiting.\n",
        "operationId": "debitDivinity",
        "tags": [
          "Divinity Economy"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DebitDivinityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Divinity debited",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DivinityBalanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Insufficient divinity balance"
          },
          "404": {
            "description": "Deity not found"
          }
        }
      }
    },
    "/divine/divinity/get-history": {
      "post": {
        "summary": "Get divinity transaction history",
        "description": "Returns paginated transaction history for a deity's divinity wallet.",
        "operationId": "getDivinityHistory",
        "tags": [
          "Divinity Economy"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetDivinityHistoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "History retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DivinityHistoryResponse"
                }
              }
            }
          },
          "404": {
            "description": "Deity not found"
          }
        }
      }
    },
    "/divine/blessing/grant": {
      "post": {
        "summary": "Grant a blessing from a deity to an entity",
        "description": "Orchestrates the full blessing ceremony: validates deity is active, validates\ntarget entity exists, checks blessing capacity, calculates divinity cost from tier,\ndebits divinity, grants the blessing via lib-collection (Greater/Supreme) or\nStatus Inventory (Minor/Standard), and records the blessing. Blessings are\nentity-agnostic -- characters, accounts, deities, or any entity type can receive them.\n",
        "operationId": "grantBlessing",
        "tags": [
          "Blessing Orchestration"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GrantBlessingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Blessing granted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BlessingResponse"
                }
              }
            }
          },
          "400": {
            "description": "Deity is not active or insufficient divinity"
          },
          "404": {
            "description": "Deity or target entity not found"
          },
          "409": {
            "description": "Entity has reached maximum active blessings"
          }
        }
      }
    },
    "/divine/blessing/revoke": {
      "post": {
        "summary": "Revoke an active blessing",
        "description": "Revokes a blessing. For status-type blessings (Minor/Standard), removes\nthe status item. For permanent blessings (Greater/Supreme), marks as\nrevoked in collection. Updates the blessing record with revocation timestamp.\n",
        "operationId": "revokeBlessing",
        "tags": [
          "Blessing Orchestration"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RevokeBlessingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Blessing revoked",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BlessingResponse"
                }
              }
            }
          },
          "400": {
            "description": "Blessing is already revoked"
          },
          "404": {
            "description": "Blessing not found"
          }
        }
      }
    },
    "/divine/blessing/list-by-entity": {
      "post": {
        "summary": "List blessings for an entity",
        "description": "Returns paginated blessings granted to a specific entity.",
        "operationId": "listBlessingsByEntity",
        "tags": [
          "Blessing Orchestration"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListBlessingsByEntityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Blessings listed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListBlessingsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/divine/blessing/list-by-deity": {
      "post": {
        "summary": "List blessings granted by a deity",
        "description": "Returns paginated blessings granted by a specific deity, optionally filtered by tier.",
        "operationId": "listBlessingsByDeity",
        "tags": [
          "Blessing Orchestration"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListBlessingsByDeityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Blessings listed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListBlessingsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/divine/blessing/get": {
      "post": {
        "summary": "Get a blessing by ID",
        "description": "Returns a single blessing record by its unique identifier.",
        "operationId": "getBlessing",
        "tags": [
          "Blessing Orchestration"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetBlessingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Blessing found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BlessingResponse"
                }
              }
            }
          },
          "404": {
            "description": "Blessing not found"
          }
        }
      }
    },
    "/divine/follower/register": {
      "post": {
        "summary": "Register a character as a follower of a deity",
        "description": "Creates a deity-character follower relationship via lib-relationship,\nincrements the deity's follower count, and adds the character to the\ndeity's attention slots if capacity is available.\n",
        "operationId": "registerFollower",
        "tags": [
          "Follower Management"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegisterFollowerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Follower registered",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FollowerResponse"
                }
              }
            }
          },
          "404": {
            "description": "Deity or character not found"
          },
          "409": {
            "description": "Character is already a follower of this deity"
          }
        }
      }
    },
    "/divine/follower/unregister": {
      "post": {
        "summary": "Unregister a character as a follower",
        "description": "Removes the deity-character follower relationship, decrements the\ndeity's follower count, and removes the character from attention slots.\n",
        "operationId": "unregisterFollower",
        "tags": [
          "Follower Management"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnregisterFollowerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Follower unregistered"
          },
          "404": {
            "description": "Deity, character, or follower relationship not found"
          }
        }
      }
    },
    "/divine/follower/get-followers": {
      "post": {
        "summary": "Get followers of a deity",
        "description": "Returns paginated follower list for a deity by querying relationships.",
        "operationId": "getFollowers",
        "tags": [
          "Follower Management"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetFollowersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Followers listed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListFollowersResponse"
                }
              }
            }
          },
          "404": {
            "description": "Deity not found"
          }
        }
      }
    },
    "/divine/cleanup-by-character": {
      "post": {
        "summary": "Cleanup divine data for a deleted character",
        "description": "Called by lib-resource when a character is deleted. Revokes all active\nblessings targeting this character (entityType=character), removes follower\nrelationships from all deities, updates follower counts, and clears\nattention slots.\n",
        "operationId": "cleanupByCharacter",
        "tags": [
          "Resource Cleanup"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CleanupByCharacterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cleanup completed"
          }
        }
      }
    },
    "/divine/cleanup-by-game-service": {
      "post": {
        "summary": "Cleanup divine data for a deleted game service",
        "description": "Called by lib-resource when a game service is deleted. Deletes all deities\nfor this game service along with their blessings, followers, attention\nslots, and associated resources.\n",
        "operationId": "cleanupByGameService",
        "tags": [
          "Resource Cleanup"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CleanupByGameServiceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cleanup completed"
          }
        }
      }
    },
    "/documentation/query": {
      "post": {
        "operationId": "queryDocumentation",
        "summary": "Natural language documentation search",
        "description": "Search documentation using natural language queries.\nReturns the most relevant documents with voice-friendly summaries.\n",
        "tags": [
          "Search"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryDocumentationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Search results with voice-friendly summaries",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDocumentationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/documentation/get": {
      "post": {
        "operationId": "getDocument",
        "summary": "Get specific document by ID or slug",
        "description": "Retrieve a specific document by its unique identifier or slug.\nReturns full content with metadata.\n",
        "tags": [
          "Documents"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetDocumentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Document content",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetDocumentResponse"
                }
              }
            }
          },
          "404": {
            "description": "Document not found"
          }
        }
      }
    },
    "/documentation/search": {
      "post": {
        "operationId": "searchDocumentation",
        "summary": "Full-text keyword search",
        "description": "Search documentation using exact keyword matching.\nFaster than semantic search but less flexible.\n",
        "tags": [
          "Search"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchDocumentationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Matching documents",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchDocumentationResponse"
                }
              }
            }
          }
        }
      }
    },
    "/documentation/list": {
      "post": {
        "operationId": "listDocuments",
        "summary": "List documents by category",
        "description": "List all documents in a specific category or all categories.\nSupports pagination for large result sets.\n",
        "tags": [
          "Documents"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListDocumentsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Document list",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListDocumentsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/documentation/suggest": {
      "post": {
        "operationId": "suggestRelatedTopics",
        "summary": "Get related topics and follow-up suggestions",
        "description": "Given a topic or document ID, returns related topics the user\nmight want to explore. Useful for conversational AI flow.\n",
        "tags": [
          "Search"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SuggestRelatedRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Related topics",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuggestRelatedResponse"
                }
              }
            }
          }
        }
      }
    },
    "/documentation/repo/bind": {
      "post": {
        "operationId": "bindRepository",
        "summary": "Bind a git repository to a documentation namespace",
        "description": "Bind a git repository URL to a documentation namespace.\nThe namespace will be exclusively managed by the repository - manual edits will be blocked.\nTriggers initial sync after binding.\n",
        "tags": [
          "Repository"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BindRepositoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Repository binding created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BindRepositoryResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (malformed URL, invalid branch)"
          },
          "409": {
            "description": "Namespace already bound to a repository"
          }
        }
      }
    },
    "/documentation/repo/sync": {
      "post": {
        "operationId": "syncRepository",
        "summary": "Manually trigger repository sync",
        "description": "Manually trigger synchronization of a bound repository.\nIf force=true, performs full re-sync regardless of commit hash.\n",
        "tags": [
          "Repository"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SyncRepositoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Sync completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyncRepositoryResponse"
                }
              }
            }
          },
          "404": {
            "description": "No binding found for namespace"
          },
          "409": {
            "description": "Sync already in progress"
          }
        }
      }
    },
    "/documentation/repo/status": {
      "post": {
        "operationId": "getRepositoryStatus",
        "summary": "Get repository binding status",
        "description": "Get current status of a repository binding including sync state and statistics.\n",
        "tags": [
          "Repository"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RepositoryStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Repository binding status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RepositoryStatusResponse"
                }
              }
            }
          },
          "404": {
            "description": "No binding found for namespace"
          }
        }
      }
    },
    "/documentation/repo/list": {
      "post": {
        "operationId": "listRepositoryBindings",
        "summary": "List all repository bindings",
        "description": "List all repository bindings with optional filtering by status.\n",
        "tags": [
          "Repository"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRepositoryBindingsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of repository bindings",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListRepositoryBindingsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/documentation/repo/update": {
      "post": {
        "operationId": "updateRepositoryBinding",
        "summary": "Update repository binding configuration",
        "description": "Update sync settings, file patterns, category mappings, or archive configuration.\n",
        "tags": [
          "Repository"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateRepositoryBindingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Repository binding updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateRepositoryBindingResponse"
                }
              }
            }
          },
          "404": {
            "description": "No binding found for namespace"
          }
        }
      }
    },
    "/documentation/repo/archive/create": {
      "post": {
        "operationId": "createDocumentationArchive",
        "summary": "Create documentation archive",
        "description": "Create a .bannou bundle archive of all documents in a namespace.\nArchives are stored via Asset Service.\n",
        "tags": [
          "Archive"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateArchiveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Archive created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateArchiveResponse"
                }
              }
            }
          },
          "404": {
            "description": "Namespace not found"
          }
        }
      }
    },
    "/documentation/repo/archive/list": {
      "post": {
        "operationId": "listDocumentationArchives",
        "summary": "List documentation archives",
        "description": "List all archives for a namespace.\n",
        "tags": [
          "Archive"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListArchivesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of archives",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListArchivesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/create": {
      "post": {
        "operationId": "createEscrow",
        "tags": [
          "Lifecycle"
        ],
        "summary": "Create a new escrow agreement",
        "description": "Create a new escrow agreement. For each party, creates a dedicated escrow wallet\nand container (owned by escrow entity). Issues deposit tokens and returns ALL\ntokens to the creating service, which is responsible for distributing them to\nparties through appropriate channels. Sets template values on bound contract.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateEscrowRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Escrow created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateEscrowResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          }
        }
      }
    },
    "/escrow/get": {
      "post": {
        "operationId": "getEscrow",
        "tags": [
          "Lifecycle"
        ],
        "summary": "Get escrow details",
        "description": "Get escrow agreement details by ID.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEscrowRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Escrow details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetEscrowResponse"
                }
              }
            }
          },
          "404": {
            "description": "Escrow not found"
          }
        }
      }
    },
    "/escrow/list": {
      "post": {
        "operationId": "listEscrows",
        "tags": [
          "Lifecycle"
        ],
        "summary": "List escrows for a party",
        "description": "List escrow agreements with filtering options.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListEscrowsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of escrows",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListEscrowsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/deposit": {
      "post": {
        "operationId": "deposit",
        "tags": [
          "Deposits"
        ],
        "summary": "Deposit assets into escrow",
        "description": "Deposit assets into escrow. Transfers currency from party's own wallet to that\nparty's escrow wallet. Moves items from party's own container to that party's\nescrow container. Locks contracts with escrow as guardian.\nRejects soulbound/non-tradeable items. After each deposit, queries bound contract\nto check if all asset requirements are satisfied.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DepositRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Deposit successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepositResponse"
                }
              }
            }
          },
          "400": {
            "description": "Deposit failed"
          }
        }
      }
    },
    "/escrow/deposit/validate": {
      "post": {
        "operationId": "validateDeposit",
        "tags": [
          "Deposits"
        ],
        "summary": "Validate a deposit without executing",
        "description": "Validate a deposit without executing (dry run).",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ValidateDepositRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Validation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidateDepositResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/deposit/status": {
      "post": {
        "operationId": "getDepositStatus",
        "tags": [
          "Deposits"
        ],
        "summary": "Get deposit status for a party",
        "description": "Get deposit status for a party in an escrow.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetDepositStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Deposit status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetDepositStatusResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/consent": {
      "post": {
        "operationId": "recordConsent",
        "tags": [
          "Consent"
        ],
        "summary": "Record party consent",
        "description": "Record party consent for release, refund, or re-affirmation.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConsentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Consent recorded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConsentResponse"
                }
              }
            }
          },
          "400": {
            "description": "Consent failed"
          }
        }
      }
    },
    "/escrow/consent/status": {
      "post": {
        "operationId": "getConsentStatus",
        "tags": [
          "Consent"
        ],
        "summary": "Get consent status for escrow",
        "description": "Get consent status for all parties in an escrow.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetConsentStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Consent status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetConsentStatusResponse"
                }
              }
            }
          }
        }
      }
    },
    "/escrow/release": {
      "post": {
        "operationId": "release",
        "tags": [
          "Completion"
        ],
        "summary": "Trigger release",
        "description": "Trigger release (for trusted modes or after consent).\nIf boundContractId is set, checks contract status first (must be fulfilled).\nRuns finalization flow before releasing remaining assets.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReleaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Release result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReleaseResponse"
                }
              }
            }
          },
          "400": {
            "description": "Release failed"
          }
        }
      }
    },
    "/escrow/refund": {
      "post": {
        "operationId": "refund",
        "tags": [
          "Completion"
        ],
        "summary": "Trigger refund",
        "description": "Trigger refund (for trusted modes or consent).",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RefundRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Refund result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RefundResponse"
                }
              }
            }
          },
          "400": {
            "description": "Refund failed"
          }
        }
      }
    },
    "/escrow/cancel": {
      "post": {
        "operationId": "cancel",
        "tags": [
          "Completion"
        ],
        "summary": "Cancel escrow before fully funded",
        "description": "Cancel escrow before fully funded, refunding any deposits.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CancelRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cancel result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CancelResponse"
                }
              }
            }
          },
          "400": {
            "description": "Cancel failed"
          }
        }
      }
    },
    "/escrow/dispute": {
      "post": {
        "operationId": "dispute",
        "tags": [
          "Completion"
        ],
        "summary": "Raise a dispute on funded escrow",
        "description": "Raise a dispute on a funded escrow.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DisputeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Dispute raised",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DisputeResponse"
                }
              }
            }
          },
          "400": {
            "description": "Dispute failed"
          }
        }
      }
    },
    "/escrow/confirm-release": {
      "post": {
        "operationId": "confirmRelease",
        "tags": [
          "Completion"
        ],
        "summary": "Confirm receipt of released assets",
        "description": "Called by parties to confirm they received their released assets.\nRequired when ReleaseMode is party_required or service_and_party.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConfirmReleaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Confirmation recorded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfirmReleaseResponse"
                }
              }
            }
          },
          "400": {
            "description": "Confirmation failed"
          },
          "404": {
            "description": "Escrow not found"
          }
        }
      }
    },
    "/escrow/confirm-refund": {
      "post": {
        "operationId": "confirmRefund",
        "tags": [
          "Completion"
        ],
        "summary": "Confirm receipt of refunded assets",
        "description": "Called by parties to confirm they received their refunded deposits.\nRequired when RefundMode is party_required.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConfirmRefundRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Confirmation recorded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfirmRefundResponse"
                }
              }
            }
          },
          "400": {
            "description": "Confirmation failed"
          },
          "404": {
            "description": "Escrow not found"
          }
        }
      }
    },
    "/escrow/resolve": {
      "post": {
        "operationId": "resolve",
        "tags": [
          "Arbiter"
        ],
        "summary": "Arbiter resolves disputed escrow",
        "description": "Arbiter resolves a disputed escrow.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResolveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Resolution result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResolveResponse"
                }
              }
            }
          },
          "400": {
            "description": "Resolution failed"
          }
        }
      }
    },
    "/escrow/verify-condition": {
      "post": {
        "operationId": "verifyCondition",
        "tags": [
          "Condition"
        ],
        "summary": "Verify condition for conditional escrow",
        "description": "Verify condition for conditional escrow (non-contract path).\nFor escrows with boundContractId, use contract milestones instead.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VerifyConditionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Verification result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VerifyConditionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Verification failed"
          }
        }
      }
    },
    "/escrow/reaffirm": {
      "post": {
        "operationId": "reaffirm",
        "tags": [
          "Validation"
        ],
        "summary": "Re-affirm after validation failure",
        "description": "Re-affirm after validation failure (party accepts changed state).",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReaffirmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Reaffirmation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReaffirmResponse"
                }
              }
            }
          },
          "400": {
            "description": "Reaffirmation failed"
          }
        }
      }
    },
    "/faction/create": {
      "post": {
        "summary": "Create a new faction",
        "operationId": "createFaction",
        "tags": [
          "Faction CRUD"
        ],
        "description": "Creates a new faction entity and automatically creates a seed via lib-seed\nwith ownerType \"faction\" and the configured seed type code. The seed starts\nin the \"nascent\" phase with no capabilities unlocked.\n\nThe faction code must be unique within the game service scope.\n\nIf parentFactionId is provided, validates that the parent exists, belongs\nto the same game service and realm, and that the resulting hierarchy depth\ndoes not exceed the configured maximum.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateFactionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Faction created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FactionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid faction data or hierarchy depth exceeded"
          },
          "404": {
            "description": "Parent faction, game service, or realm not found"
          },
          "409": {
            "description": "Faction code already exists in this game service"
          }
        }
      }
    },
    "/faction/get": {
      "post": {
        "summary": "Get a faction by ID",
        "operationId": "getFaction",
        "tags": [
          "Faction CRUD"
        ],
        "description": "Retrieves a faction by its unique identifier. Includes the current seed\ngrowth phase (denormalized from lib-seed for convenience) and member count.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetFactionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Faction retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FactionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Faction not found"
          }
        }
      }
    },
    "/faction/get-by-code": {
      "post": {
        "summary": "Get a faction by code",
        "operationId": "getFactionByCode",
        "tags": [
          "Faction CRUD"
        ],
        "description": "Retrieves a faction by its unique code within a game service scope.\nCodes are human-readable identifiers like \"thieves_guild\" or \"royal_guard\".\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetFactionByCodeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Faction retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FactionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Faction not found"
          }
        }
      }
    },
    "/faction/list": {
      "post": {
        "summary": "List factions with filters",
        "operationId": "listFactions",
        "tags": [
          "Faction CRUD"
        ],
        "description": "Returns a paginated list of factions with optional filters by realm,\ngame service, status, and parent faction. Supports cursor-based pagination.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListFactionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Factions retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListFactionsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/faction/update": {
      "post": {
        "summary": "Update a faction",
        "operationId": "updateFaction",
        "tags": [
          "Faction CRUD"
        ],
        "description": "Updates mutable faction properties (name, description, code). The faction\ncode must remain unique within its game service scope. Cannot change\ngameServiceId or realmId after creation.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateFactionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Faction updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FactionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Faction not found"
          },
          "409": {
            "description": "Updated code conflicts with existing faction"
          }
        }
      }
    },
    "/faction/deprecate": {
      "post": {
        "summary": "Deprecate a faction",
        "operationId": "deprecateFaction",
        "tags": [
          "Faction CRUD"
        ],
        "description": "Marks a faction as deprecated. Deprecated factions cannot accept new members\nor define new norms, but existing memberships and norms remain active.\nExisting norm enforcement continues until the faction is dissolved.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeprecateFactionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Faction deprecated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FactionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Faction not found"
          },
          "409": {
            "description": "Faction is already deprecated or dissolved"
          }
        }
      }
    },
    "/faction/undeprecate": {
      "post": {
        "summary": "Reactivate a deprecated faction",
        "operationId": "undeprecateFaction",
        "tags": [
          "Faction CRUD"
        ],
        "description": "Restores a deprecated faction to active status.",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UndeprecateFactionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Faction reactivated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FactionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Faction not found"
          },
          "409": {
            "description": "Faction is not in deprecated status"
          }
        }
      }
    },
    "/faction/designate-realm-baseline": {
      "post": {
        "summary": "Designate a faction as realm baseline",
        "operationId": "designateRealmBaseline",
        "tags": [
          "Faction CRUD"
        ],
        "description": "Sets a faction as the realm's baseline cultural faction. The baseline\nfaction provides realm-wide default norms (honor codes, cultural taboos,\nspecies instincts) that apply to all characters in the realm unless\noverridden by more specific faction norms.\n\nOnly one faction per realm can be the baseline. Setting a new baseline\nclears the previous one. The faction must belong to the specified realm.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DesignateRealmBaselineRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Faction designated as realm baseline",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FactionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Faction not found"
          },
          "409": {
            "description": "Faction does not belong to the specified realm"
          }
        }
      }
    },
    "/faction/get-realm-baseline": {
      "post": {
        "summary": "Get the realm baseline faction",
        "operationId": "getRealmBaseline",
        "tags": [
          "Faction CRUD"
        ],
        "description": "Returns the faction designated as the baseline cultural faction for a realm.\nReturns 404 if no baseline has been designated.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRealmBaselineRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Realm baseline faction retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FactionResponse"
                }
              }
            }
          },
          "404": {
            "description": "No baseline faction designated for this realm"
          }
        }
      }
    },
    "/faction/member/add": {
      "post": {
        "summary": "Add a character to a faction",
        "operationId": "addMember",
        "tags": [
          "Membership"
        ],
        "description": "Adds a character as a member of a faction. The faction must be active\n(not deprecated or dissolved). If no role is specified, the configured\ndefault member role is used.\n\nA character can be a member of multiple factions simultaneously. Duplicate\nmembership (same character + same faction) returns Conflict.\n\nPublishes a faction.member.added event for downstream consumers.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddMemberRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Member added",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FactionMemberResponse"
                }
              }
            }
          },
          "404": {
            "description": "Faction or character not found"
          },
          "409": {
            "description": "Character is already a member of this faction, or faction is not active"
          }
        }
      }
    },
    "/faction/member/remove": {
      "post": {
        "summary": "Remove a character from a faction",
        "operationId": "removeMember",
        "tags": [
          "Membership"
        ],
        "description": "Removes a character's membership in a faction. Publishes a\nfaction.member.removed event for downstream consumers.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RemoveMemberRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Member removed"
          },
          "404": {
            "description": "Membership not found"
          }
        }
      }
    },
    "/faction/member/list": {
      "post": {
        "summary": "List members of a faction",
        "operationId": "listMembers",
        "tags": [
          "Membership"
        ],
        "description": "Returns a paginated list of members for a faction. Supports filtering\nby role and cursor-based pagination. Ordered by join date descending.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListMembersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Members retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListMembersResponse"
                }
              }
            }
          },
          "404": {
            "description": "Faction not found"
          }
        }
      }
    },
    "/faction/member/list-by-character": {
      "post": {
        "summary": "List a character's faction memberships",
        "operationId": "listMembershipsByCharacter",
        "tags": [
          "Membership"
        ],
        "description": "Returns all faction memberships for a character. Used by lib-obligation\nto determine which guild faction norms apply to a character, and by the\n${faction.*} variable provider for ABML behavior expressions.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListMembershipsByCharacterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Memberships retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListMembershipsByCharacterResponse"
                }
              }
            }
          }
        }
      }
    },
    "/faction/member/update-role": {
      "post": {
        "summary": "Update a member's role",
        "operationId": "updateMemberRole",
        "tags": [
          "Membership"
        ],
        "description": "Changes a member's role within a faction. Publishes a\nfaction.member.role-changed event for downstream consumers.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateMemberRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Role updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FactionMemberResponse"
                }
              }
            }
          },
          "404": {
            "description": "Membership not found"
          }
        }
      }
    },
    "/faction/member/check": {
      "post": {
        "summary": "Check if a character is a member of a faction",
        "operationId": "checkMembership",
        "tags": [
          "Membership"
        ],
        "description": "Returns whether a character is currently a member of the specified faction,\nand if so, their role. Lightweight lookup for permission/capability checks.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CheckMembershipRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Membership check result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckMembershipResponse"
                }
              }
            }
          }
        }
      }
    },
    "/faction/territory/claim": {
      "post": {
        "summary": "Claim a location for a faction",
        "operationId": "claimTerritory",
        "tags": [
          "Territory"
        ],
        "description": "Claims a location as faction territory. Requires the faction's seed to\nhave unlocked the \"territory.claim\" capability. A location can only have\none controlling faction at a time (exclusive claim). If the location is\nalready claimed by another faction, the claim is rejected with Conflict.\n\nThe faction must belong to the same realm as the location.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ClaimTerritoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Territory claimed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TerritoryClaimResponse"
                }
              }
            }
          },
          "403": {
            "description": "Faction seed lacks territory.claim capability"
          },
          "404": {
            "description": "Faction or location not found"
          },
          "409": {
            "description": "Location already claimed by another faction, or realm mismatch"
          }
        }
      }
    },
    "/faction/territory/release": {
      "post": {
        "summary": "Release a territory claim",
        "operationId": "releaseTerritory",
        "tags": [
          "Territory"
        ],
        "description": "Releases a faction's claim on a location. The territory becomes unclaimed\nand available for other factions. Publishes a faction.territory.released event.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReleaseTerritoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Territory released"
          },
          "404": {
            "description": "Territory claim not found"
          }
        }
      }
    },
    "/faction/territory/list": {
      "post": {
        "summary": "List territory claims for a faction",
        "operationId": "listTerritoryClaims",
        "tags": [
          "Territory"
        ],
        "description": "Returns all territory claims for a faction with optional status filtering\nand cursor-based pagination.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListTerritoryClaimsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Territory claims retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListTerritoryClaimsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Faction not found"
          }
        }
      }
    },
    "/faction/territory/get-controlling": {
      "post": {
        "summary": "Get the controlling faction for a location",
        "operationId": "getControllingFaction",
        "tags": [
          "Territory"
        ],
        "description": "Returns the faction that currently controls a location. Used by\nlib-obligation and the norm resolution hierarchy to determine which\nlocation faction norms apply at a character's current position.\n\nReturns 404 if the location has no controlling faction.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetControllingFactionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Controlling faction retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ControllingFactionResponse"
                }
              }
            }
          },
          "404": {
            "description": "No faction controls this location"
          }
        }
      }
    },
    "/faction/norm/define": {
      "post": {
        "summary": "Define a behavioral norm for a faction",
        "operationId": "defineNorm",
        "tags": [
          "Norms"
        ],
        "description": "Creates a new behavioral norm definition for a faction. Requires the\nfaction's seed to have unlocked the \"norm.define\" capability (growth\nthreshold must be reached). Higher-severity norms may require additional\ncapabilities (norm.enforce.basic for Standard, norm.enforce.sanctions\nfor Strict).\n\nNorms are stored as faction configuration and queried by lib-obligation\nfor NPC cognition cost modifiers. They are NOT contract instances --\nthis avoids the scaling problem of 100K NPCs each needing individual\ncontract instances for ambient social rules.\n\nThe violationType is an opaque string that maps to lib-obligation's\nviolation type vocabulary (e.g., \"theft\", \"deception\", \"violence\",\n\"honor_combat\"). No separate taxonomy is maintained -- the vocabulary\nis defined by contract templates and action tag mappings.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DefineNormRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Norm defined",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NormDefinitionResponse"
                }
              }
            }
          },
          "403": {
            "description": "Faction seed lacks required norm capability"
          },
          "404": {
            "description": "Faction not found"
          },
          "409": {
            "description": "Faction is not active, or maximum norms per faction reached"
          }
        }
      }
    },
    "/faction/norm/update": {
      "post": {
        "summary": "Update an existing norm",
        "operationId": "updateNorm",
        "tags": [
          "Norms"
        ],
        "description": "Updates properties of an existing norm definition. The violationType\ncannot be changed (delete and recreate if needed). Severity changes\nare subject to capability checks.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateNormRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Norm updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NormDefinitionResponse"
                }
              }
            }
          },
          "403": {
            "description": "Faction seed lacks required capability for new severity"
          },
          "404": {
            "description": "Norm not found"
          }
        }
      }
    },
    "/faction/norm/delete": {
      "post": {
        "summary": "Delete a norm definition",
        "operationId": "deleteNorm",
        "tags": [
          "Norms"
        ],
        "description": "Removes a behavioral norm definition from a faction.",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteNormRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Norm deleted"
          },
          "404": {
            "description": "Norm not found"
          }
        }
      }
    },
    "/faction/norm/list": {
      "post": {
        "summary": "List norms defined by a faction",
        "operationId": "listNorms",
        "tags": [
          "Norms"
        ],
        "description": "Returns all norm definitions for a faction with optional filtering\nby severity and scope.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListNormsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Norms retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListNormsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Faction not found"
          }
        }
      }
    },
    "/faction/cleanup-by-character": {
      "post": {
        "summary": "Cleanup faction data for a deleted character",
        "operationId": "cleanupByCharacter",
        "tags": [
          "Resource Cleanup"
        ],
        "description": "Called by lib-resource cleanup coordination when a character is deleted.\nRemoves all faction memberships for the character. Territory claims and\nnorm definitions are faction-owned, not character-owned, so they remain.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CleanupByCharacterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cleanup completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupByCharacterResponse"
                }
              }
            }
          }
        }
      }
    },
    "/faction/cleanup-by-realm": {
      "post": {
        "summary": "Cleanup faction data for a deleted realm",
        "operationId": "cleanupByRealm",
        "tags": [
          "Resource Cleanup"
        ],
        "description": "Called by lib-resource cleanup coordination when a realm is deleted.\nRemoves all factions belonging to the realm, including their memberships,\nterritory claims, norm definitions, and associated seeds.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CleanupByRealmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cleanup completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupByRealmResponse"
                }
              }
            }
          }
        }
      }
    },
    "/faction/cleanup-by-location": {
      "post": {
        "summary": "Cleanup territory claims for a deleted location",
        "operationId": "cleanupByLocation",
        "tags": [
          "Resource Cleanup"
        ],
        "description": "Called by lib-resource cleanup coordination when a location is deleted.\nRemoves all territory claims referencing the location. The faction itself\nremains intact.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CleanupByLocationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cleanup completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupByLocationResponse"
                }
              }
            }
          }
        }
      }
    },
    "/faction/get-compress-data": {
      "post": {
        "summary": "Get faction data for character archival compression",
        "operationId": "getCompressData",
        "tags": [
          "Compression"
        ],
        "description": "Called by Resource service during character compression. Returns faction\nmemberships and roles for the character for archival. Norm definitions\nare faction-owned data and not included in character archives.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCompressDataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Compressed data returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FactionArchive"
                }
              }
            }
          },
          "404": {
            "description": "No faction data for character"
          }
        }
      }
    },
    "/game-service/services/list": {
      "post": {
        "summary": "List all registered game services",
        "description": "Returns all game services, optionally filtered by active status.",
        "operationId": "listServices",
        "tags": [
          "Game Service Registry"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListServicesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Services retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListServicesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/game-service/services/get": {
      "post": {
        "summary": "Get service by ID or stub name",
        "description": "Retrieves a single service by either serviceId (GUID) or stubName.",
        "operationId": "getService",
        "tags": [
          "Game Service Registry"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetServiceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Service retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceInfo"
                }
              }
            }
          },
          "404": {
            "description": "Service not found"
          }
        }
      }
    },
    "/sessions/get": {
      "post": {
        "summary": "Get game session details",
        "description": "Get details of the current game session the user has joined.",
        "operationId": "getGameSession",
        "tags": [
          "Game Sessions"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "game-session": "in_game"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetGameSessionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Game session retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GameSessionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Game session not found"
          }
        }
      }
    },
    "/sessions/leave": {
      "post": {
        "summary": "Leave a game session",
        "operationId": "leaveGameSession",
        "tags": [
          "Game Sessions"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "game-session": "in_game"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LeaveGameSessionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successfully left game session"
          },
          "404": {
            "description": "Game session not found"
          }
        }
      }
    },
    "/sessions/chat": {
      "post": {
        "summary": "Send chat message to game session",
        "operationId": "sendChatMessage",
        "tags": [
          "Game Chat"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "game-session": "in_game"
            }
          }
        ],
        "x-rate-limit": {
          "requestsPerMinute": 60,
          "burstLimit": 10
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatMessageRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Chat message sent successfully"
          },
          "404": {
            "description": "Game session not found"
          }
        }
      }
    },
    "/sessions/actions": {
      "post": {
        "summary": "Perform game action (enhanced permissions after joining)",
        "operationId": "performGameAction",
        "tags": [
          "Game Actions"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "game-session": "in_game"
            }
          }
        ],
        "x-rate-limit": {
          "requestsPerMinute": 120,
          "burstLimit": 20
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GameActionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Game action performed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GameActionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Game session not found"
          },
          "400": {
            "description": "Invalid game action"
          }
        }
      }
    },
    "/sessions/leave-session": {
      "post": {
        "summary": "Leave a specific game session by ID",
        "description": "Leave a game session by its session ID. This is the session-specific alternative\nto /sessions/leave which uses gameType. Useful for matchmade sessions.\n",
        "operationId": "leaveGameSessionById",
        "tags": [
          "Game Sessions"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "game-session": "in_game"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LeaveGameSessionByIdRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successfully left game session"
          },
          "404": {
            "description": "Game session not found or player not in session"
          }
        }
      }
    },
    "/gardener/garden/enter": {
      "post": {
        "summary": "Enter the garden",
        "description": "Creates a garden instance for the player. Finds or creates the player's\nactive guardian seed, initializes drift metrics, and returns the initial\ngarden state. First tick of the garden orchestrator spawns POIs.\n",
        "operationId": "enterGarden",
        "tags": [
          "Garden Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EnterGardenRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Garden instance created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GardenStateResponse"
                }
              }
            }
          },
          "404": {
            "description": "No active seed found for account"
          },
          "409": {
            "description": "Player already has an active garden instance"
          }
        }
      }
    },
    "/gardener/garden/get": {
      "post": {
        "summary": "Get current garden state",
        "description": "Returns the player's current garden instance with active POIs.",
        "operationId": "getGardenState",
        "tags": [
          "Garden Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetGardenStateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Garden state retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GardenStateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Player is not in the garden"
          }
        }
      }
    },
    "/gardener/garden/update-position": {
      "post": {
        "summary": "Update player position in the garden",
        "description": "Updates the player's position and velocity in garden space. Accumulates\ndrift metrics and checks proximity triggers against active POIs.\n",
        "operationId": "updatePosition",
        "tags": [
          "Garden Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdatePositionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Position updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PositionUpdateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Player is not in the garden"
          }
        }
      }
    },
    "/gardener/garden/leave": {
      "post": {
        "summary": "Leave the garden",
        "description": "Cleans up the garden instance, all associated POIs, and publishes a\ngarden-left event with session duration.\n",
        "operationId": "leaveGarden",
        "tags": [
          "Garden Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LeaveGardenRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Left the garden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LeaveGardenResponse"
                }
              }
            }
          },
          "404": {
            "description": "Player is not in the garden"
          }
        }
      }
    },
    "/gardener/poi/list": {
      "post": {
        "summary": "List active POIs",
        "description": "Returns all active POIs for the player's current garden instance.",
        "operationId": "listPois",
        "tags": [
          "POI Interaction"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListPoisRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "POIs retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListPoisResponse"
                }
              }
            }
          },
          "404": {
            "description": "Player is not in the garden"
          }
        }
      }
    },
    "/gardener/poi/interact": {
      "post": {
        "summary": "Interact with a POI",
        "description": "Triggers interaction with a POI. Result depends on the POI's trigger mode:\nprompted POIs return scenario info with choices, proximity/interaction POIs\nenter the scenario directly.\n",
        "operationId": "interactWithPoi",
        "tags": [
          "POI Interaction"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InteractWithPoiRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Interaction result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PoiInteractionResponse"
                }
              }
            }
          },
          "400": {
            "description": "POI is expired or already interacted with"
          },
          "404": {
            "description": "POI not found"
          }
        }
      }
    },
    "/gardener/poi/decline": {
      "post": {
        "summary": "Decline a POI",
        "description": "Marks a POI as declined. The template is added to the garden instance's\nscenario history for diversity scoring.\n",
        "operationId": "declinePoi",
        "tags": [
          "POI Interaction"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeclinePoiRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "POI declined",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeclinePoiResponse"
                }
              }
            }
          },
          "400": {
            "description": "POI is not in Active status"
          },
          "404": {
            "description": "POI not found"
          }
        }
      }
    },
    "/gardener/scenario/enter": {
      "post": {
        "summary": "Enter a scenario",
        "description": "Validates prerequisites, creates a game session, creates a scenario\ninstance, destroys the garden instance (player leaves the garden), and\npublishes scenario-started events.\n",
        "operationId": "enterScenario",
        "tags": [
          "Scenario Lifecycle"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EnterScenarioRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scenario entered",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScenarioStateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Prerequisites not met or invalid template"
          },
          "409": {
            "description": "Global scenario capacity reached"
          }
        }
      }
    },
    "/gardener/scenario/get": {
      "post": {
        "summary": "Get current scenario state",
        "description": "Returns the player's active scenario instance.",
        "operationId": "getScenarioState",
        "tags": [
          "Scenario Lifecycle"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetScenarioStateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scenario state retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScenarioStateResponse"
                }
              }
            }
          },
          "404": {
            "description": "No active scenario"
          }
        }
      }
    },
    "/gardener/scenario/complete": {
      "post": {
        "summary": "Complete a scenario",
        "description": "Calculates and awards growth per domain, closes the game session,\nwrites history, and returns the player to the garden.\n",
        "operationId": "completeScenario",
        "tags": [
          "Scenario Lifecycle"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompleteScenarioRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scenario completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScenarioCompletionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Scenario instance not found"
          }
        }
      }
    },
    "/gardener/scenario/abandon": {
      "post": {
        "summary": "Abandon a scenario",
        "description": "Awards partial growth proportional to time spent, cleans up the\ngame session, and writes history.\n",
        "operationId": "abandonScenario",
        "tags": [
          "Scenario Lifecycle"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AbandonScenarioRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scenario abandoned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AbandonScenarioResponse"
                }
              }
            }
          },
          "404": {
            "description": "Scenario instance not found"
          }
        }
      }
    },
    "/gardener/scenario/chain": {
      "post": {
        "summary": "Chain to another scenario",
        "description": "Completes the current scenario with growth awards and immediately\ncreates a new scenario instance from the target template. Validates\nchaining rules (leadsTo list, max chain depth).\n",
        "operationId": "chainScenario",
        "tags": [
          "Scenario Lifecycle"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChainScenarioRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Chained to new scenario",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScenarioStateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Chaining rules not met or max chain depth exceeded"
          },
          "404": {
            "description": "Current scenario or target template not found"
          }
        }
      }
    },
    "/gardener/template/create": {
      "post": {
        "summary": "Create a scenario template",
        "description": "Creates a new scenario template definition.",
        "operationId": "createTemplate",
        "tags": [
          "Template Management"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScenarioTemplateResponse"
                }
              }
            }
          },
          "409": {
            "description": "Template with this code already exists"
          }
        }
      }
    },
    "/gardener/template/get": {
      "post": {
        "summary": "Get scenario template by ID",
        "description": "Returns a scenario template by its unique identifier.",
        "operationId": "getTemplate",
        "tags": [
          "Template Management"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScenarioTemplateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Template not found"
          }
        }
      }
    },
    "/gardener/template/get-by-code": {
      "post": {
        "summary": "Get scenario template by code",
        "description": "Returns a scenario template by its unique code string.",
        "operationId": "getTemplateByCode",
        "tags": [
          "Template Management"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetTemplateByCodeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScenarioTemplateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Template not found"
          }
        }
      }
    },
    "/gardener/template/list": {
      "post": {
        "summary": "List scenario templates",
        "description": "Returns paginated scenario templates with optional filters.",
        "operationId": "listTemplates",
        "tags": [
          "Template Management"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListTemplatesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Templates listed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListTemplatesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/gardener/template/update": {
      "post": {
        "summary": "Update scenario template",
        "description": "Updates non-null fields of an existing template.",
        "operationId": "updateTemplate",
        "tags": [
          "Template Management"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScenarioTemplateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Template not found"
          }
        }
      }
    },
    "/gardener/template/deprecate": {
      "post": {
        "summary": "Deprecate scenario template",
        "description": "Sets the template status to Deprecated, preventing new instances.",
        "operationId": "deprecateTemplate",
        "tags": [
          "Template Management"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeprecateTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template deprecated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScenarioTemplateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Template not found"
          }
        }
      }
    },
    "/gardener/template/delete": {
      "post": {
        "summary": "Delete scenario template",
        "description": "Permanently deletes a scenario template. Template must be in Deprecated status before deletion. Publishes a scenario-template.deleted lifecycle event.",
        "operationId": "deleteTemplate",
        "tags": [
          "Template Management"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Template deleted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScenarioTemplateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Template not found"
          },
          "409": {
            "description": "Template is not in Deprecated status"
          }
        }
      }
    },
    "/gardener/phase/get": {
      "post": {
        "summary": "Get deployment phase configuration",
        "description": "Returns the current deployment phase configuration. Creates defaults if none exists.",
        "operationId": "getPhaseConfig",
        "tags": [
          "Deployment Phase"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetPhaseConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Phase config retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PhaseConfigResponse"
                }
              }
            }
          }
        }
      }
    },
    "/gardener/phase/update": {
      "post": {
        "summary": "Update deployment phase configuration",
        "description": "Updates non-null fields of the phase configuration. Publishes phase-changed event if phase changes.",
        "operationId": "updatePhaseConfig",
        "tags": [
          "Deployment Phase"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdatePhaseConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Phase config updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PhaseConfigResponse"
                }
              }
            }
          }
        }
      }
    },
    "/gardener/phase/get-metrics": {
      "post": {
        "summary": "Get deployment phase metrics",
        "description": "Returns current counts of active garden instances, scenario instances, and capacity utilization.",
        "operationId": "getPhaseMetrics",
        "tags": [
          "Deployment Phase"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetPhaseMetricsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Phase metrics retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PhaseMetricsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/gardener/bond/enter-together": {
      "post": {
        "summary": "Enter a scenario together with a bonded player",
        "description": "Both bonded players enter a shared scenario instance. Validates bond state,\nboth participants' garden instances, and template multiplayer support.\n",
        "operationId": "enterScenarioTogether",
        "tags": [
          "Bond Scenarios"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EnterTogetherRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Both players entered shared scenario",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScenarioStateResponse"
                }
              }
            }
          },
          "400": {
            "description": "One or both participants not in garden, or template does not support multiplayer"
          },
          "404": {
            "description": "Bond not found"
          }
        }
      }
    },
    "/gardener/bond/get-shared-garden": {
      "post": {
        "summary": "Get shared garden state for bonded players",
        "description": "Returns the merged garden state for both bond participants including shared POIs.",
        "operationId": "getSharedGardenState",
        "tags": [
          "Bond Scenarios"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSharedGardenRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Shared garden state retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SharedGardenStateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Bond not found or participants not in garden"
          }
        }
      }
    },
    "/inventory/container/create": {
      "post": {
        "operationId": "createContainer",
        "tags": [
          "Container"
        ],
        "summary": "Create a new container",
        "description": "Creates a new container with the specified constraint model and capacity.\nContainer types are game-defined strings (e.g., \"inventory\", \"bank\", \"equipment_slot\").\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateContainerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Container created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContainerResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (validation error)"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/inventory/container/get": {
      "post": {
        "operationId": "getContainer",
        "tags": [
          "Container"
        ],
        "summary": "Get container with contents",
        "description": "Retrieves a container by ID, optionally including its contents.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetContainerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Container retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContainerWithContentsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Container not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/container/get-or-create": {
      "post": {
        "operationId": "getOrCreateContainer",
        "tags": [
          "Container"
        ],
        "summary": "Get container or create if not exists",
        "description": "Enables lazy container creation for character inventories.\nIf a container doesn't exist for the owner/type combination, creates it\nwith the specified defaults.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetOrCreateContainerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Container retrieved or created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContainerResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/inventory/container/list": {
      "post": {
        "operationId": "listContainers",
        "tags": [
          "Container"
        ],
        "summary": "List containers for owner",
        "description": "Returns all containers owned by the specified entity.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListContainersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Containers retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListContainersResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/container/update": {
      "post": {
        "operationId": "updateContainer",
        "tags": [
          "Container"
        ],
        "summary": "Update container properties",
        "description": "Updates mutable container properties like capacity limits and filtering.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateContainerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Container updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContainerResponse"
                }
              }
            }
          },
          "404": {
            "description": "Container not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/inventory/add": {
      "post": {
        "operationId": "addItemToContainer",
        "tags": [
          "Inventory Operations"
        ],
        "summary": "Add item to container",
        "description": "Adds an item instance to a container. Validates container constraints\n(slots, weight, grid, category filters). For stackable items, may\nmerge with existing stacks.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddItemRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item added successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddItemResponse"
                }
              }
            }
          },
          "400": {
            "description": "Constraint violation (full, overweight, wrong category)"
          },
          "404": {
            "description": "Container or item not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/inventory/remove": {
      "post": {
        "operationId": "removeItemFromContainer",
        "tags": [
          "Inventory Operations"
        ],
        "summary": "Remove item from container",
        "description": "Removes an item from its container. The item still exists but has no\ncontainer assignment. Use destroy via lib-item to permanently delete.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RemoveItemRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item removed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RemoveItemResponse"
                }
              }
            }
          },
          "404": {
            "description": "Item not found in specified container"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/inventory/move": {
      "post": {
        "operationId": "moveItem",
        "tags": [
          "Inventory Operations"
        ],
        "summary": "Move item to different slot or container",
        "description": "Moves an item within the same container (slot change) or to a different\ncontainer. Validates destination constraints. For equipment slots, this\neffectively equips/unequips items.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MoveItemRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item moved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MoveItemResponse"
                }
              }
            }
          },
          "400": {
            "description": "Constraint violation at destination"
          },
          "404": {
            "description": "Item or container not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/transfer": {
      "post": {
        "operationId": "transferItem",
        "tags": [
          "Inventory Operations"
        ],
        "summary": "Transfer item to different owner",
        "description": "Transfers an item to a container owned by a different entity.\nUsed for trades, gifts, and loot distribution.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransferItemRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item transferred successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransferItemResponse"
                }
              }
            }
          },
          "400": {
            "description": "Item is bound or not tradeable"
          },
          "404": {
            "description": "Item or container not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/inventory/split": {
      "post": {
        "operationId": "splitStack",
        "tags": [
          "Inventory Operations"
        ],
        "summary": "Split stack into two",
        "description": "Splits a stack of items into two stacks. The original stack keeps the\nremainder, and a new stack is created with the split quantity.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SplitStackRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Stack split successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SplitStackResponse"
                }
              }
            }
          },
          "400": {
            "description": "Cannot split unique items or invalid quantity"
          },
          "404": {
            "description": "Item not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/merge": {
      "post": {
        "operationId": "mergeStacks",
        "tags": [
          "Inventory Operations"
        ],
        "summary": "Merge two stacks",
        "description": "Merges two stacks of the same item template. The source stack is\ndestroyed and its quantity added to the target stack.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MergeStacksRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Stacks merged successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MergeStacksResponse"
                }
              }
            }
          },
          "400": {
            "description": "Items are not the same template or target would exceed max stack"
          },
          "404": {
            "description": "Item not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/query": {
      "post": {
        "operationId": "queryItems",
        "tags": [
          "Inventory Queries"
        ],
        "summary": "Find items across containers",
        "description": "Searches for items across all containers owned by an entity.\nCan filter by template, category, tags, and other criteria.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryItemsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Items found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryItemsResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/count": {
      "post": {
        "operationId": "countItems",
        "tags": [
          "Inventory Queries"
        ],
        "summary": "Count items of a template",
        "description": "Counts total quantity of a specific item template across containers.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CountItemsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Count completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CountItemsResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/has": {
      "post": {
        "operationId": "hasItems",
        "tags": [
          "Inventory Queries"
        ],
        "summary": "Check if entity has required items",
        "description": "Checks if an entity has the required quantities of specified items.\nUsed for crafting and quest requirements validation.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HasItemsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Check completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HasItemsResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/inventory/find-space": {
      "post": {
        "operationId": "findSpace",
        "tags": [
          "Inventory Queries"
        ],
        "summary": "Find where item would fit",
        "description": "Finds available space for an item in the owner's containers.\nReturns candidate containers and slots where the item could be placed.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FindSpaceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Space search completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FindSpaceResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/item/template/create": {
      "post": {
        "operationId": "createItemTemplate",
        "tags": [
          "Item Template"
        ],
        "summary": "Create a new item template",
        "description": "Creates a new item definition for a game. Code, gameId, quantityModel, and scope\nare immutable after creation.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateItemTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item template created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (validation error)"
          },
          "409": {
            "description": "Code already exists for this gameId"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/item/template/get": {
      "post": {
        "operationId": "getItemTemplate",
        "tags": [
          "Item Template"
        ],
        "summary": "Get item template by ID or code",
        "description": "Retrieves an item template by its unique ID or by code+gameId combination.\nAt least one of templateId or (code + gameId) must be provided.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetItemTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item template retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Neither templateId nor code+gameId provided"
          },
          "404": {
            "description": "Item template not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/item/template/list": {
      "post": {
        "operationId": "listItemTemplates",
        "tags": [
          "Item Template"
        ],
        "summary": "List item templates with filters",
        "description": "Lists item templates with optional filtering by gameId, category, tags,\nrarity, scope, and active status.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListItemTemplatesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item templates retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListItemTemplatesResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/item/template/update": {
      "post": {
        "operationId": "updateItemTemplate",
        "tags": [
          "Item Template"
        ],
        "summary": "Update mutable fields of an item template",
        "description": "Updates mutable fields of an item template. Code, gameId, quantityModel, and scope\nare immutable after creation and cannot be changed.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateItemTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item template updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Attempted to change immutable field"
          },
          "404": {
            "description": "Item template not found"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/item/instance/create": {
      "post": {
        "operationId": "createItemInstance",
        "tags": [
          "Item Instance"
        ],
        "summary": "Create a new item instance",
        "description": "Creates a new item instance from a template. The instance must be placed\nin a container (containerId required). Use lib-inventory's /inventory/add\nfor most use cases - this endpoint is for low-level instance creation.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateItemInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item instance created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (validation error)"
          },
          "404": {
            "description": "Template not found"
          },
          "409": {
            "description": "Template is deprecated"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/item/instance/get": {
      "post": {
        "operationId": "getItemInstance",
        "tags": [
          "Item Instance"
        ],
        "summary": "Get item instance by ID",
        "description": "Retrieves an item instance by its unique ID.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetItemInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item instance retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemInstanceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Item instance not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/item/instance/modify": {
      "post": {
        "operationId": "modifyItemInstance",
        "tags": [
          "Item Instance"
        ],
        "summary": "Modify item instance state",
        "description": "Modifies an item instance's mutable state: durability, custom stats,\ncustom name, and metadata. Cannot modify bound items unless admin.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ModifyItemInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item instance modified successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid modification (e.g., negative durability)"
          },
          "404": {
            "description": "Item instance not found"
          },
          "409": {
            "description": "Item is corrupted/mirrored and cannot be modified"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/item/instance/bind": {
      "post": {
        "operationId": "bindItemInstance",
        "tags": [
          "Item Instance"
        ],
        "summary": "Bind item to character",
        "description": "Binds an item instance to a character. The bind type must be allowed by\nthe template's soulboundType. Once bound, the item cannot be traded.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BindItemInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item instance bound successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Item cannot be bound (template doesn't allow binding)"
          },
          "404": {
            "description": "Item instance not found"
          },
          "409": {
            "description": "Item already bound"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/item/instance/destroy": {
      "post": {
        "operationId": "destroyItemInstance",
        "tags": [
          "Item Instance"
        ],
        "summary": "Destroy item instance",
        "description": "Permanently destroys an item instance. The reason is recorded for audit.\nCannot destroy bound items unless admin or reason is 'admin'.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DestroyItemInstanceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item instance destroyed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DestroyItemInstanceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Item instance not found"
          },
          "409": {
            "description": "Item is bound and cannot be destroyed"
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/item/use": {
      "post": {
        "operationId": "useItem",
        "tags": [
          "Item Instance"
        ],
        "summary": "Use an item (execute its behavior contract)",
        "description": "Uses an item by executing its behavior contract. The item's template must have\na useBehaviorContractTemplateId defined. Creates a transient contract instance,\ncompletes the \"use\" milestone (triggering prebound APIs), and consumes the item\non success if the template defines it as consumable. Returns failure if the\ncontract's prebound APIs fail.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UseItemRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Item used successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UseItemResponse"
                }
              }
            }
          },
          "400": {
            "description": "Item template has no behavior contract or invalid request"
          },
          "404": {
            "description": "Item instance not found"
          },
          "422": {
            "description": "Item use failed (contract prebound APIs failed)"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/item/use-step": {
      "post": {
        "operationId": "useItemStep",
        "tags": [
          "Item Instance"
        ],
        "summary": "Complete a specific step of a multi-step item use",
        "description": "For items with multi-milestone use behaviors, completes a specific milestone.\nThe first call (without an existing contractInstanceId on the item) creates\nthe contract instance and stores it on the item; subsequent calls progress\nthe existing contract. Item is consumed only when all required milestones\nare complete (per itemUseBehavior).\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UseItemStepRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Step completed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UseItemStepResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or item template has no behavior contract"
          },
          "404": {
            "description": "Item instance not found"
          },
          "409": {
            "description": "Another operation is in progress on this item (distributed lock held)"
          },
          "422": {
            "description": "Step execution failed (CanUse validation or milestone completion)"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/item/instance/list-by-container": {
      "post": {
        "operationId": "listItemsByContainer",
        "tags": [
          "Item Query"
        ],
        "summary": "List items in a container",
        "description": "Returns all item instances in the specified container.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListItemsByContainerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Items retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListItemsResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/item/instance/batch-get": {
      "post": {
        "operationId": "batchGetItemInstances",
        "tags": [
          "Item Query"
        ],
        "summary": "Get multiple item instances by ID",
        "description": "Retrieves multiple item instances in a single request.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchGetItemInstancesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Items retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchGetItemInstancesResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/leaderboard/definition/create": {
      "post": {
        "summary": "Create a new leaderboard definition",
        "description": "Create a new leaderboard with specified properties.\nDeveloper-only endpoint for setting up game leaderboards.\n",
        "operationId": "createLeaderboardDefinition",
        "tags": [
          "Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateLeaderboardDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Leaderboard created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LeaderboardDefinitionResponse"
                }
              }
            }
          },
          "409": {
            "description": "Leaderboard with this ID already exists"
          }
        }
      }
    },
    "/leaderboard/definition/update": {
      "post": {
        "summary": "Update leaderboard definition",
        "description": "Update properties of an existing leaderboard.\nDeveloper-only endpoint.\n",
        "operationId": "updateLeaderboardDefinition",
        "tags": [
          "Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateLeaderboardDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Leaderboard updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LeaderboardDefinitionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Leaderboard not found"
          }
        }
      }
    },
    "/leaderboard/definition/delete": {
      "post": {
        "summary": "Delete leaderboard definition",
        "description": "Delete a leaderboard and all its scores.\nDeveloper-only endpoint. This action is irreversible.\n",
        "operationId": "deleteLeaderboardDefinition",
        "tags": [
          "Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteLeaderboardDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Leaderboard deleted successfully"
          },
          "404": {
            "description": "Leaderboard not found"
          }
        }
      }
    },
    "/leaderboard/rank/get": {
      "post": {
        "summary": "Get entity's rank",
        "description": "Get the current rank and score for a specific entity.",
        "operationId": "getEntityRank",
        "tags": [
          "Rankings"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEntityRankRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Rank retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityRankResponse"
                }
              }
            }
          },
          "404": {
            "description": "Entity not found on leaderboard"
          }
        }
      }
    },
    "/leaderboard/rank/top": {
      "post": {
        "summary": "Get top entries",
        "description": "Get the top N entries on a leaderboard.",
        "operationId": "getTopRanks",
        "tags": [
          "Rankings"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetTopRanksRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Top ranks retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LeaderboardEntriesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/leaderboard/rank/around": {
      "post": {
        "summary": "Get entries around entity",
        "description": "Get leaderboard entries surrounding a specific entity.\nUseful for showing a player's position with nearby competitors.\n",
        "operationId": "getRanksAround",
        "tags": [
          "Rankings"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRanksAroundRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Ranks retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LeaderboardEntriesResponse"
                }
              }
            }
          },
          "404": {
            "description": "Entity not found on leaderboard"
          }
        }
      }
    },
    "/leaderboard/season/get": {
      "post": {
        "summary": "Get current season info",
        "description": "Get information about the current or a specific past season.",
        "operationId": "getSeason",
        "tags": [
          "Seasons"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSeasonRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Season info retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeasonResponse"
                }
              }
            }
          },
          "404": {
            "description": "Season not found"
          }
        }
      }
    },
    "/license/board-template/create": {
      "post": {
        "operationId": "createBoardTemplate",
        "tags": [
          "BoardTemplate"
        ],
        "summary": "Create a new board template",
        "description": "Create a board template with grid dimensions, starting nodes, adjacency mode,\nand a reference to the contract template that controls unlock behavior.\nBoard templates are scoped to a game service.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateBoardTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Board template created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BoardTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (validation error)"
          },
          "404": {
            "description": "Referenced game service or contract template not found"
          }
        }
      }
    },
    "/license/board-template/get": {
      "post": {
        "operationId": "getBoardTemplate",
        "tags": [
          "BoardTemplate"
        ],
        "summary": "Get a board template by ID",
        "description": "Retrieves a board template by its unique identifier.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetBoardTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Board template retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BoardTemplateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Board template not found"
          }
        }
      }
    },
    "/license/board-template/list": {
      "post": {
        "operationId": "listBoardTemplates",
        "tags": [
          "BoardTemplate"
        ],
        "summary": "List board templates for a game service",
        "description": "Paginated list of board templates filtered by game service ID.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListBoardTemplatesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Board templates retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListBoardTemplatesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/license/board-template/update": {
      "post": {
        "operationId": "updateBoardTemplate",
        "tags": [
          "BoardTemplate"
        ],
        "summary": "Update a board template",
        "description": "Update mutable fields of a board template. Grid dimensions, starting nodes,\nand contract template are immutable after creation.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateBoardTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Board template updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BoardTemplateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Board template not found"
          }
        }
      }
    },
    "/license/board-template/delete": {
      "post": {
        "operationId": "deleteBoardTemplate",
        "tags": [
          "BoardTemplate"
        ],
        "summary": "Delete a board template",
        "description": "Delete a board template. Blocked if active board instances exist\nthat reference this template.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteBoardTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Board template deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BoardTemplateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Board template not found"
          },
          "409": {
            "description": "Active board instances exist for this template"
          }
        }
      }
    },
    "/license/definition/add": {
      "post": {
        "operationId": "addLicenseDefinition",
        "tags": [
          "Definition"
        ],
        "summary": "Add a license definition to a board template",
        "description": "Add a license definition (node) to a board template at a specific grid position.\nEach definition has a unique code within the template, a grid position, an LP cost,\nand a reference to the item template that is created when the license is unlocked.\nOptional non-adjacent prerequisites can reference other license codes on the board.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddLicenseDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "License definition added successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LicenseDefinitionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (position out of bounds, invalid item template)"
          },
          "404": {
            "description": "Board template or item template not found"
          },
          "409": {
            "description": "Duplicate code or position, or max definitions exceeded"
          }
        }
      }
    },
    "/license/definition/get": {
      "post": {
        "operationId": "getLicenseDefinition",
        "tags": [
          "Definition"
        ],
        "summary": "Get a license definition",
        "description": "Get a license definition by board template ID and license code.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetLicenseDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "License definition retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LicenseDefinitionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Board template or license definition not found"
          }
        }
      }
    },
    "/license/definition/list": {
      "post": {
        "operationId": "listLicenseDefinitions",
        "tags": [
          "Definition"
        ],
        "summary": "List all license definitions for a board template",
        "description": "Returns the full grid layout of all license definitions for a board template.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListLicenseDefinitionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "License definitions retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListLicenseDefinitionsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Board template not found"
          }
        }
      }
    },
    "/license/definition/update": {
      "post": {
        "operationId": "updateLicenseDefinition",
        "tags": [
          "Definition"
        ],
        "summary": "Update a license definition",
        "description": "Update mutable fields of a license definition. Position and code are immutable\nafter creation.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateLicenseDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "License definition updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LicenseDefinitionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Board template or license definition not found"
          }
        }
      }
    },
    "/license/definition/remove": {
      "post": {
        "operationId": "removeLicenseDefinition",
        "tags": [
          "Definition"
        ],
        "summary": "Remove a license definition from a board template",
        "description": "Remove a license definition from a board template. Blocked if any board\ninstances have this license unlocked.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RemoveLicenseDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "License definition removed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LicenseDefinitionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Board template or license definition not found"
          },
          "409": {
            "description": "License is unlocked by active board instances"
          }
        }
      }
    },
    "/license/board/create": {
      "post": {
        "operationId": "createBoard",
        "tags": [
          "Board"
        ],
        "summary": "Create a board instance for an owner",
        "description": "Create a board instance for an owner from a board template. Validates the owner type\nis in the template's allowedOwnerTypes, game service matches, and no duplicate board\nexists (one board per template per owner). For character owners, validates the character\nexists and resolves realm context. Creates an inventory container (slot_only,\nmaxSlots = gridWidth * gridHeight) to hold unlocked license items.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateBoardRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Board created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BoardResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (inactive template)"
          },
          "404": {
            "description": "Character, game service, or board template not found"
          },
          "409": {
            "description": "Duplicate board or max boards per character exceeded"
          }
        }
      }
    },
    "/license/board/get": {
      "post": {
        "operationId": "getBoard",
        "tags": [
          "Board"
        ],
        "summary": "Get a board instance by ID",
        "description": "Retrieves a board instance by its unique identifier.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetBoardRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Board retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BoardResponse"
                }
              }
            }
          },
          "404": {
            "description": "Board not found"
          }
        }
      }
    },
    "/license/board/list-by-owner": {
      "post": {
        "operationId": "listBoardsByOwner",
        "tags": [
          "Board"
        ],
        "summary": "List boards for an owner",
        "description": "List all board instances for an owner (by ownerType + ownerId), with optional game service filter.",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListBoardsByOwnerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Boards retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListBoardsByOwnerResponse"
                }
              }
            }
          }
        }
      }
    },
    "/license/board/delete": {
      "post": {
        "operationId": "deleteBoard",
        "tags": [
          "Board"
        ],
        "summary": "Delete a board instance",
        "description": "Delete a board instance. Destroys the inventory container and all license\nitems within it.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteBoardRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Board deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BoardResponse"
                }
              }
            }
          },
          "404": {
            "description": "Board not found"
          }
        }
      }
    },
    "/license/unlock": {
      "post": {
        "operationId": "unlockLicense",
        "tags": [
          "Gameplay"
        ],
        "summary": "Unlock a license on a board",
        "description": "The core operation. Validates adjacency and prerequisites, creates a contract\ninstance from the board template's contract template, executes the unlock\nmilestone (LP deduction, ability grants via prebound APIs), then creates an\nitem instance and places it in the board container. Atomic: if contract\nexecution fails, no license is placed.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnlockLicenseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "License unlocked successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnlockLicenseResponse"
                }
              }
            }
          },
          "400": {
            "description": "Not adjacent, prerequisites not met, or insufficient LP"
          },
          "404": {
            "description": "Board or license definition not found"
          },
          "409": {
            "description": "License already unlocked"
          },
          "500": {
            "description": "Contract execution failed"
          }
        }
      }
    },
    "/license/check-unlockable": {
      "post": {
        "operationId": "checkUnlockable",
        "tags": [
          "Gameplay"
        ],
        "summary": "Check if a license can be unlocked",
        "description": "Check if a license can be unlocked without performing the unlock. Returns\nadjacency status, prerequisite status, and whether the character has\nsufficient LP.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CheckUnlockableRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Unlockability check completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckUnlockableResponse"
                }
              }
            }
          },
          "404": {
            "description": "Board or license definition not found"
          }
        }
      }
    },
    "/license/board-state": {
      "post": {
        "operationId": "getBoardState",
        "tags": [
          "Gameplay"
        ],
        "summary": "Get full board state",
        "description": "Get the full board state: all defined license positions with unlock status\n(unlocked, locked, unlockable) and adjacency info. Primary endpoint for\nclient UI rendering.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BoardStateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Board state retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BoardStateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Board not found"
          }
        }
      }
    },
    "/license/board-template/seed": {
      "post": {
        "operationId": "seedBoardTemplate",
        "tags": [
          "BoardTemplate"
        ],
        "summary": "Bulk seed a board template with license definitions",
        "description": "Bulk seed a board template with license definitions from a JSON payload.\nTwo-pass: creates definitions, then resolves prerequisite references.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SeedBoardTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Board template seeded successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedBoardTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid definitions (out of bounds, duplicates)"
          },
          "404": {
            "description": "Board template not found"
          }
        }
      }
    },
    "/license/board/clone": {
      "post": {
        "operationId": "cloneBoard",
        "tags": [
          "Board"
        ],
        "summary": "Clone a board's unlock state to a new owner",
        "description": "Developer-only endpoint for cloning NPC progression. Reads unlock state\nfrom a source board, creates a new board for the target owner, and bulk-creates\nitem instances for all unlocked licenses. Skips contracts entirely (admin tooling,\nnot gameplay). Publishes a single license.board.cloned event.\nDoes not publish individual license.unlocked events.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CloneBoardRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Board cloned successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CloneBoardResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (owner type not allowed, missing realm for character)"
          },
          "404": {
            "description": "Source board, target owner (character), or template not found"
          },
          "409": {
            "description": "Target already has a board for this template, or max boards exceeded"
          }
        }
      }
    },
    "/license/cleanup-by-owner": {
      "post": {
        "operationId": "cleanupByOwner",
        "tags": [
          "Cleanup"
        ],
        "summary": "Cleanup boards referencing a deleted owner",
        "description": "Called by lib-resource cleanup coordination when an owner entity is deleted.\nDeletes all board instances for the specified owner (ownerType + ownerId),\ndestroying their inventory containers and all contained license items.\nThis endpoint is designed for internal service-to-service calls during\ncascading resource cleanup.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CleanupByOwnerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cleanup completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupByOwnerResponse"
                }
              }
            }
          }
        }
      }
    },
    "/location/get": {
      "post": {
        "summary": "Get location by ID",
        "operationId": "getLocation",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetLocationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Location retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationResponse"
                }
              }
            }
          },
          "404": {
            "description": "Location not found"
          }
        }
      }
    },
    "/location/get-by-code": {
      "post": {
        "summary": "Get location by code and realm",
        "description": "Retrieve a location using its unique code within a specific realm",
        "operationId": "getLocationByCode",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetLocationByCodeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Location retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationResponse"
                }
              }
            }
          },
          "404": {
            "description": "Location not found"
          }
        }
      }
    },
    "/location/list": {
      "post": {
        "summary": "List locations with filtering",
        "description": "Retrieve locations with optional realm, parent, and type filtering",
        "operationId": "listLocations",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListLocationsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Locations retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/location/list-by-realm": {
      "post": {
        "summary": "List all locations in a realm (primary query pattern)",
        "description": "Returns all locations within a specific realm, optionally filtered by\nlocation type and parent. This is the primary access pattern for\nrealm-scoped location queries.\n",
        "operationId": "listLocationsByRealm",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListLocationsByRealmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Locations retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/location/list-by-parent": {
      "post": {
        "summary": "Get child locations for a parent location",
        "description": "Retrieve all locations that have the specified location as their parent.\nUseful for getting all cities in a region, all buildings in a city, etc.\n",
        "operationId": "listLocationsByParent",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListLocationsByParentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Child locations retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Parent location not found"
          }
        }
      }
    },
    "/location/list-root": {
      "post": {
        "summary": "Get root locations in a realm",
        "description": "Returns all top-level locations in a realm (locations with no parent).\nThese are typically regions or major areas within the realm.\n",
        "operationId": "listRootLocations",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRootLocationsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Root locations retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/location/get-ancestors": {
      "post": {
        "summary": "Get all ancestors of a location",
        "description": "Returns the full ancestry chain from the specified location up to the\nroot location (parentLocationId=null). For example, for a specific building\nmight return [district, city, region].\n",
        "operationId": "getLocationAncestors",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetLocationAncestorsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Ancestors retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Location not found"
          }
        }
      }
    },
    "/location/validate-territory": {
      "post": {
        "operationId": "validateTerritory",
        "tags": [
          "Location"
        ],
        "summary": "Validate location against territory boundaries",
        "description": "Checks if a proposed location falls within or outside specified territory boundaries.\nUsed by Contract service's clause type handler system for territory validation.\n\nTerritory modes:\n- exclusive: Location must NOT be within any territory location (or descendants)\n- inclusive: Location MUST be within at least one territory location (or descendants)\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ValidateTerritoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Territory validation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidateTerritoryResponse"
                }
              }
            }
          },
          "404": {
            "description": "Location not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/location/get-descendants": {
      "post": {
        "summary": "Get all descendants of a location",
        "description": "Returns all locations that are descendants of the specified location\n(direct children, grandchildren, etc.). Useful for finding all places\nwithin a region or city.\n",
        "operationId": "getLocationDescendants",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetLocationDescendantsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Descendants retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Location not found"
          }
        }
      }
    },
    "/location/exists": {
      "post": {
        "summary": "Check if location exists and is active",
        "description": "Fast validation endpoint for other services to check location validity.\nReturns true if location exists and is not deprecated, false otherwise.\n",
        "operationId": "locationExists",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LocationExistsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Validation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationExistsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/location/query/by-position": {
      "post": {
        "summary": "Find locations containing a spatial position",
        "description": "Given a Position3D and realmId, returns all locations whose bounds contain\nthat position, ordered by depth descending (most specific first). Only\nlocations with spatial bounds data are considered. A position is \"in\" a\nlocation if it falls within the location's axis-aligned bounding box.\n",
        "operationId": "queryLocationsByPosition",
        "tags": [
          "Location"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryLocationsByPositionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Locations containing the position",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LocationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/location/report-entity-position": {
      "post": {
        "summary": "Report entity presence at a location",
        "description": "Reports that an entity is present at a location. Creates or refreshes an ephemeral\npresence binding with configurable TTL. Reporters must call this periodically to\nkeep the presence alive. Publishes arrival/departure events only when the entity's\nlocation actually changes (pure refreshes are silent).\n\nThe optional previousLocationId provides a caller-hint optimization: if provided\nand matches the current stored location, only a TTL refresh occurs (no GET needed).\nIf omitted, the service reads the current value to detect location changes.\n",
        "operationId": "reportEntityPosition",
        "tags": [
          "Location Presence"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReportEntityPositionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Position reported successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReportEntityPositionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Location not found"
          }
        }
      }
    },
    "/location/get-entity-location": {
      "post": {
        "summary": "Get the current location of an entity",
        "description": "Queries where an entity currently is. Returns the entity's location if a\nnon-expired presence binding exists.\n",
        "operationId": "getEntityLocation",
        "tags": [
          "Location Presence"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEntityLocationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Entity location query result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetEntityLocationResponse"
                }
              }
            }
          }
        }
      }
    },
    "/location/list-entities-at-location": {
      "post": {
        "summary": "List entities currently at a location",
        "description": "Queries which entities are currently present at a location. Supports optional\nentity type filtering and pagination. Results are hydrated from the entity\npresence store for reporting metadata.\n",
        "operationId": "listEntitiesAtLocation",
        "tags": [
          "Location Presence"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListEntitiesAtLocationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Entity list for the location",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListEntitiesAtLocationResponse"
                }
              }
            }
          }
        }
      }
    },
    "/location/clear-entity-position": {
      "post": {
        "summary": "Remove entity presence from its current location",
        "description": "Clears an entity's presence binding, removing it from its current location.\nPublishes a departure event if the entity was present at a location.\n",
        "operationId": "clearEntityPosition",
        "tags": [
          "Location Presence"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ClearEntityPositionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Entity position cleared",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClearEntityPositionResponse"
                }
              }
            }
          }
        }
      }
    },
    "/mapping/request-snapshot": {
      "post": {
        "summary": "Request full snapshot for cold start",
        "description": "Consumers use this when starting up to get initial state.\nReturns current snapshot of requested region/kinds.\nFor very large maps, payloadRef points to lib-asset storage.\n",
        "operationId": "requestSnapshot",
        "tags": [
          "Runtime"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestSnapshotRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Snapshot returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RequestSnapshotResponse"
                }
              }
            }
          },
          "404": {
            "description": "Region not found"
          }
        }
      }
    },
    "/mapping/query/point": {
      "post": {
        "summary": "Query map data at a specific point",
        "description": "Returns all map data at a point across requested kinds.\nUsed by behavior stacks for contextual decisions.\nOptionally includes objects within radius.\n",
        "operationId": "queryPoint",
        "tags": [
          "Query"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryPointRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Query results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryPointResponse"
                }
              }
            }
          }
        }
      }
    },
    "/mapping/query/bounds": {
      "post": {
        "summary": "Query map data within bounds",
        "description": "Returns map data within a bounding box.\nFor event actors needing region overview.\nLimited to maxObjects per kind.\n",
        "operationId": "queryBounds",
        "tags": [
          "Query"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryBoundsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Query results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryBoundsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/mapping/query/objects-by-type": {
      "post": {
        "summary": "Find all objects of a type in region",
        "description": "Returns all objects matching an objectType filter.\nFor event actors asking \"where are all the boulder clusters?\"\n",
        "operationId": "queryObjectsByType",
        "tags": [
          "Query"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryObjectsByTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Matching objects",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryObjectsByTypeResponse"
                }
              }
            }
          }
        }
      }
    },
    "/mapping/query/affordance": {
      "post": {
        "summary": "Find locations that afford a specific action or scene type",
        "description": "Affordance queries answer \"where can I do X?\" by combining\nmultiple map kinds and applying game-specific scoring logic.\n\nUsed by Event Brain for procedural scene orchestration:\n- \"Find ambush locations\"\n- \"Find dramatic reveal spots\"\n- \"Find sheltered rest areas\"\n\nWell-known types have predefined scoring; use affordanceType=custom\nwith customAffordance for novel scenarios.\n",
        "operationId": "queryAffordance",
        "tags": [
          "Query"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AffordanceQueryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scored locations",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AffordanceQueryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/mapping/authoring/checkout": {
      "post": {
        "summary": "Acquire exclusive edit lock for design-time editing",
        "description": "For level editors and design tools only.\nGame servers do NOT use this - they use create-channel for implicit authority.\nReturns authority token for publishing edits.\n",
        "operationId": "checkoutForAuthoring",
        "tags": [
          "Authoring"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthoringCheckoutRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Checkout successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthoringCheckoutResponse"
                }
              }
            }
          },
          "409": {
            "description": "Already checked out by another editor"
          }
        }
      }
    },
    "/mapping/authoring/commit": {
      "post": {
        "summary": "Commit design-time changes",
        "description": "Commits pending changes and releases the checkout lock.\nOptionally includes a commit message for history.\n",
        "operationId": "commitAuthoring",
        "tags": [
          "Authoring"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthoringCommitRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Changes committed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthoringCommitResponse"
                }
              }
            }
          },
          "403": {
            "description": "Invalid checkout token"
          }
        }
      }
    },
    "/mapping/authoring/release": {
      "post": {
        "summary": "Release authoring checkout without committing",
        "description": "Discards pending changes and releases the checkout lock.\nUse when abandoning edits.\n",
        "operationId": "releaseAuthoring",
        "tags": [
          "Authoring"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthoringReleaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Checkout released",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthoringReleaseResponse"
                }
              }
            }
          }
        }
      }
    },
    "/mapping/definition/create": {
      "post": {
        "summary": "Create a map definition template",
        "description": "Creates a new map definition (template) that describes the structure\nof a region. Definitions are templates that can be used to bootstrap\nchannels with predefined layer configurations.\n",
        "operationId": "createDefinition",
        "tags": [
          "Definition"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Definition created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MapDefinition"
                }
              }
            }
          },
          "409": {
            "description": "Definition with this name already exists"
          }
        }
      }
    },
    "/mapping/definition/get": {
      "post": {
        "summary": "Get a map definition by ID",
        "description": "Returns the full map definition including all layer configurations.",
        "operationId": "getDefinition",
        "tags": [
          "Definition"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Definition found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MapDefinition"
                }
              }
            }
          },
          "404": {
            "description": "Definition not found"
          }
        }
      }
    },
    "/mapping/definition/list": {
      "post": {
        "summary": "List map definitions with optional filters",
        "description": "Returns a paginated list of map definitions.",
        "operationId": "listDefinitions",
        "tags": [
          "Definition"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListDefinitionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Definitions list",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListDefinitionsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/mapping/definition/update": {
      "post": {
        "summary": "Update a map definition",
        "description": "Updates an existing map definition. Cannot change the definition ID.\nLayer configurations can be modified.\n",
        "operationId": "updateDefinition",
        "tags": [
          "Definition"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Definition updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MapDefinition"
                }
              }
            }
          },
          "404": {
            "description": "Definition not found"
          }
        }
      }
    },
    "/matchmaking/queue/list": {
      "post": {
        "summary": "List available matchmaking queues",
        "description": "List all available matchmaking queues that players can join.\nReturns queue configuration details including skill settings.\n",
        "operationId": "listQueues",
        "tags": [
          "Queues"
        ],
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "x-rate-limit": {
          "requestsPerMinute": 30,
          "requestsPerHour": 500
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListQueuesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Queues retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListQueuesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/matchmaking/queue/get": {
      "post": {
        "summary": "Get queue details",
        "description": "Get detailed configuration for a specific matchmaking queue.\n",
        "operationId": "getQueue",
        "tags": [
          "Queues"
        ],
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetQueueRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Queue details retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueueResponse"
                }
              }
            }
          },
          "404": {
            "description": "Queue not found"
          }
        }
      }
    },
    "/matchmaking/join": {
      "post": {
        "summary": "Join matchmaking queue",
        "description": "Join a matchmaking queue with specified properties and query.\nCreates a matchmaking ticket and begins searching for compatible players.\nReturns immediately after ticket creation. Match results are delivered\nvia WebSocket push events.\n",
        "operationId": "joinMatchmaking",
        "tags": [
          "Matchmaking"
        ],
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "x-rate-limit": {
          "requestsPerMinute": 10,
          "requestsPerHour": 100
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/JoinMatchmakingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successfully joined matchmaking queue",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JoinMatchmakingResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid query syntax or properties"
          },
          "409": {
            "description": "Already in queue, queue limit reached, or exclusive group conflict"
          }
        }
      }
    },
    "/matchmaking/leave": {
      "post": {
        "summary": "Leave matchmaking queue",
        "description": "Leave a matchmaking queue and cancel the ticket.\nOnly available when actively in a queue (shortcut/prebound).\n",
        "operationId": "leaveMatchmaking",
        "tags": [
          "Matchmaking"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "matchmaking": "in_queue"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LeaveMatchmakingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successfully left matchmaking queue"
          },
          "404": {
            "description": "Ticket not found or not in queue"
          }
        }
      }
    },
    "/matchmaking/status": {
      "post": {
        "summary": "Get matchmaking status",
        "description": "Get current matchmaking status for the player's active ticket.\nOnly available when actively in a queue (shortcut/prebound).\n",
        "operationId": "getMatchmakingStatus",
        "tags": [
          "Matchmaking"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "matchmaking": "in_queue"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetMatchmakingStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Status retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MatchmakingStatusResponse"
                }
              }
            }
          },
          "404": {
            "description": "No active matchmaking ticket"
          }
        }
      }
    },
    "/matchmaking/accept": {
      "post": {
        "summary": "Accept a formed match",
        "description": "Accept a match that has been formed. Only available when a match\nis pending acceptance (shortcut/prebound after match formation).\nAll players must accept within the timeout for the match to start.\n",
        "operationId": "acceptMatch",
        "tags": [
          "Matchmaking"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "matchmaking": "match_pending"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AcceptMatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Match acceptance recorded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptMatchResponse"
                }
              }
            }
          },
          "404": {
            "description": "No pending match or already processed"
          }
        }
      }
    },
    "/matchmaking/decline": {
      "post": {
        "summary": "Decline a formed match",
        "description": "Decline a match that has been formed. Only available when a match\nis pending acceptance (shortcut/prebound after match formation).\nDeclining cancels the match for all participants.\n",
        "operationId": "declineMatch",
        "tags": [
          "Matchmaking"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "matchmaking": "match_pending"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeclineMatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Match declined"
          },
          "404": {
            "description": "No pending match or already processed"
          }
        }
      }
    },
    "/matchmaking/stats": {
      "post": {
        "summary": "Get queue statistics",
        "description": "Get operational statistics for matchmaking queues.\nIncludes queue depths, average wait times, and match rates.\n",
        "operationId": "getMatchmakingStats",
        "tags": [
          "Statistics"
        ],
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetMatchmakingStatsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Statistics retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MatchmakingStatsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/music/generate": {
      "post": {
        "summary": "Generate composition from style and constraints",
        "description": "Generates a complete musical composition using the specified style definition\nand compositional constraints. Returns MIDI-JSON format output.\n",
        "operationId": "GenerateComposition",
        "tags": [
          "Generation"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenerateCompositionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Composition generated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateCompositionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or generation constraints"
          },
          "404": {
            "description": "Style not found"
          }
        }
      }
    },
    "/music/validate": {
      "post": {
        "summary": "Validate MIDI-JSON structure",
        "description": "Validates a MIDI-JSON structure for correctness including note ranges,\ntiming, and format compliance.\n",
        "operationId": "ValidateMidiJson",
        "tags": [
          "Validation"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ValidateMidiJsonRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Validation completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidateMidiJsonResponse"
                }
              }
            }
          }
        }
      }
    },
    "/music/style/get": {
      "post": {
        "summary": "Get style definition",
        "description": "Retrieves a style definition by ID or name. Styles define mode preferences,\ninterval rules, form templates, and genre-specific parameters.\n",
        "operationId": "GetStyle",
        "tags": [
          "Styles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetStyleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Style retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StyleDefinitionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Style not found"
          }
        }
      }
    },
    "/music/style/list": {
      "post": {
        "summary": "List available styles",
        "description": "Lists all available style definitions with optional filtering by category.\n",
        "operationId": "ListStyles",
        "tags": [
          "Styles"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListStylesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Styles listed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListStylesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/music/theory/progression": {
      "post": {
        "summary": "Generate chord progression",
        "description": "Generates a chord progression using harmonic function theory.\nSupports multiple harmonic styles including functional harmony,\nmodal interchange, and jazz voicings.\n",
        "operationId": "GenerateProgression",
        "tags": [
          "Theory"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenerateProgressionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Progression generated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateProgressionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          }
        }
      }
    },
    "/music/theory/melody": {
      "post": {
        "summary": "Generate melody over harmony",
        "description": "Generates a melodic line over a chord progression using contour rules,\ninterval preferences, and rhythmic patterns from the specified style.\n",
        "operationId": "GenerateMelody",
        "tags": [
          "Theory"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenerateMelodyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Melody generated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateMelodyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          }
        }
      }
    },
    "/music/theory/voice-lead": {
      "post": {
        "summary": "Apply voice leading to chords",
        "description": "Applies voice leading rules to a chord sequence, ensuring smooth\npart-writing according to traditional or style-specific rules.\n",
        "operationId": "ApplyVoiceLeading",
        "tags": [
          "Theory"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VoiceLeadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Voice leading applied successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VoiceLeadResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          }
        }
      }
    },
    "/obligation/action-mapping/set": {
      "post": {
        "summary": "Create or update an action tag to violation type mapping",
        "operationId": "setActionMapping",
        "tags": [
          "Action Mapping"
        ],
        "description": "Registers or replaces a mapping from a GOAP action tag to one or more\nviolation type codes. These mappings define how the obligation service\nconnects GOAP planner actions (e.g., tag \"steal_food\") to contract\nbehavioral clause violation types (e.g., \"theft\", \"dishonesty\").\n\nMappings are idempotent by tag \u2014 setting a mapping for an existing tag\nreplaces the previous mapping entirely.\n\nBy default, action tags are matched 1:1 against violation type codes\n(tag \"theft\" matches violation type \"theft\"). Explicit mappings are only\nneeded when the vocabularies differ or when one action triggers multiple\nviolation types (e.g., \"attack_surrendered_enemy\" \u2192 [\"honor_combat\", \"show_mercy\"]).\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetActionMappingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Mapping saved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActionMappingResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid mapping data"
          }
        }
      }
    },
    "/obligation/action-mapping/list": {
      "post": {
        "summary": "List registered action tag mappings",
        "operationId": "listActionMappings",
        "tags": [
          "Action Mapping"
        ],
        "description": "Returns all registered action tag to violation type mappings.\nSupports cursor-based pagination and optional text search.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListActionMappingsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Mappings retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListActionMappingsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/obligation/action-mapping/delete": {
      "post": {
        "summary": "Delete an action tag mapping",
        "operationId": "deleteActionMapping",
        "tags": [
          "Action Mapping"
        ],
        "description": "Removes a registered action tag mapping. After deletion, the tag will\nfall back to convention-based 1:1 matching (tag name == violation type code).\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteActionMappingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Mapping deleted successfully"
          },
          "404": {
            "description": "No mapping found for this tag"
          }
        }
      }
    },
    "/obligation/query-violations": {
      "post": {
        "summary": "Query violation history for a character",
        "operationId": "queryViolations",
        "tags": [
          "Violations"
        ],
        "description": "Returns the violation history for a character with cursor-based pagination.\nSupports filtering by contract, violation type, and time range.\nOrdered by timestamp descending (most recent first).\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryViolationsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Violations retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryViolationsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/obligation/invalidate-cache": {
      "post": {
        "summary": "Force obligation cache refresh for a character",
        "operationId": "invalidateCache",
        "tags": [
          "Cache Management"
        ],
        "description": "Forces a full cache rebuild for a character's obligation manifest.\nQueries all active contracts for the character, extracts behavioral\nclauses, and rebuilds the cached obligation state.\n\nNormally, the cache is maintained automatically via contract lifecycle\nevents. This endpoint is for administrative and debugging purposes.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InvalidateCacheRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cache refreshed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvalidateCacheResponse"
                }
              }
            }
          }
        }
      }
    },
    "/obligation/get-compress-data": {
      "post": {
        "summary": "Get obligation data for character archival compression",
        "operationId": "getCompressData",
        "tags": [
          "Compression"
        ],
        "description": "Called by Resource service during character compression.\nReturns violation history and cached obligation state for archival.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCompressDataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Compressed data returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObligationArchive"
                }
              }
            }
          },
          "404": {
            "description": "No obligation data for character"
          }
        }
      }
    },
    "/obligation/cleanup-by-character": {
      "post": {
        "summary": "Cleanup all obligation data for a deleted character",
        "operationId": "cleanupByCharacter",
        "tags": [
          "Resource Cleanup"
        ],
        "description": "Called by lib-resource cleanup coordination when a character is deleted.\nRemoves cached obligation manifests and violation history for the\nspecified character. This endpoint is designed for internal\nservice-to-service calls during cascading resource cleanup.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CleanupByCharacterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cleanup completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupByCharacterResponse"
                }
              }
            }
          }
        }
      }
    },
    "/puppetmaster/watchers/start": {
      "post": {
        "summary": "Manually start a regional watcher",
        "description": "Starts a regional watcher for the specified realm with the given behavior.\nIf a watcher already exists for this realm and watcher type, returns the existing watcher.\n",
        "operationId": "startWatcher",
        "tags": [
          "Watchers"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StartWatcherRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Watcher started or already exists",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StartWatcherResponse"
                }
              }
            }
          }
        }
      }
    },
    "/puppetmaster/watchers/stop": {
      "post": {
        "summary": "Stop a regional watcher",
        "description": "Stops an active regional watcher by its ID.",
        "operationId": "stopWatcher",
        "tags": [
          "Watchers"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StopWatcherRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Watcher stopped successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StopWatcherResponse"
                }
              }
            }
          }
        }
      }
    },
    "/puppetmaster/watchers/start-for-realm": {
      "post": {
        "summary": "Start all relevant watchers for a realm",
        "description": "Starts all applicable regional watchers for the specified realm.\nUses configured watcher templates to determine which watchers to start.\n",
        "operationId": "startWatchersForRealm",
        "tags": [
          "Watchers"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StartWatchersForRealmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Watchers started for realm",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StartWatchersForRealmResponse"
                }
              }
            }
          }
        }
      }
    },
    "/quest/definition/create": {
      "post": {
        "operationId": "createQuestDefinition",
        "tags": [
          "Definitions"
        ],
        "summary": "Create a new quest definition",
        "description": "Creates a quest definition wrapping a contract template with quest metadata.",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateQuestDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Quest definition created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuestDefinitionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (validation error)"
          },
          "409": {
            "description": "Quest definition with this code already exists"
          }
        }
      }
    },
    "/quest/definition/get": {
      "post": {
        "operationId": "getQuestDefinition",
        "tags": [
          "Definitions"
        ],
        "summary": "Get quest definition by ID or code",
        "description": "Retrieves a quest definition by its unique identifier or code.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetQuestDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Quest definition found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuestDefinitionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Quest definition not found"
          }
        }
      }
    },
    "/quest/definition/list": {
      "post": {
        "operationId": "listQuestDefinitions",
        "tags": [
          "Definitions"
        ],
        "summary": "List quest definitions with filtering",
        "description": "Lists quest definitions with optional filtering by category, difficulty, tags.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListQuestDefinitionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Quest definitions retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListQuestDefinitionsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/quest/definition/update": {
      "post": {
        "operationId": "updateQuestDefinition",
        "tags": [
          "Definitions"
        ],
        "summary": "Update quest definition metadata",
        "description": "Updates quest metadata (not contract template - that's immutable).",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateQuestDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Quest definition updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuestDefinitionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Quest definition not found"
          }
        }
      }
    },
    "/quest/definition/deprecate": {
      "post": {
        "operationId": "deprecateQuestDefinition",
        "tags": [
          "Definitions"
        ],
        "summary": "Mark quest definition as deprecated",
        "description": "Marks a quest definition as deprecated. No new instances can be created.",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeprecateQuestDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Quest definition deprecated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuestDefinitionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Quest definition not found"
          }
        }
      }
    },
    "/quest/accept": {
      "post": {
        "operationId": "acceptQuest",
        "tags": [
          "Instances"
        ],
        "summary": "Accept a quest",
        "description": "Creates a contract instance and auto-consents for the questor. Returns the active quest.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AcceptQuestRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Quest accepted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuestInstanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Prerequisites not met or already at max quests"
          },
          "404": {
            "description": "Quest definition not found"
          },
          "409": {
            "description": "Quest already active or on cooldown"
          }
        }
      }
    },
    "/quest/abandon": {
      "post": {
        "operationId": "abandonQuest",
        "tags": [
          "Instances"
        ],
        "summary": "Abandon an active quest",
        "description": "Terminates the underlying contract and marks the quest as abandoned.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AbandonQuestRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Quest abandoned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuestInstanceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Quest not found"
          },
          "409": {
            "description": "Quest not in abandonable state"
          }
        }
      }
    },
    "/quest/get": {
      "post": {
        "operationId": "getQuest",
        "tags": [
          "Instances"
        ],
        "summary": "Get quest instance details",
        "description": "Retrieves detailed quest instance information including objectives.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetQuestRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Quest instance found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuestInstanceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Quest not found"
          }
        }
      }
    },
    "/quest/list": {
      "post": {
        "operationId": "listQuests",
        "tags": [
          "Instances"
        ],
        "summary": "List character's quests",
        "description": "Lists quests for a character filtered by status.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListQuestsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Quests retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListQuestsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/quest/list-available": {
      "post": {
        "operationId": "listAvailableQuests",
        "tags": [
          "Instances"
        ],
        "summary": "List quests available to accept",
        "description": "Lists quests a character can accept (prerequisites met, not on cooldown, not active).",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListAvailableQuestsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Available quests retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListAvailableQuestsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/quest/log": {
      "post": {
        "operationId": "getQuestLog",
        "tags": [
          "Instances"
        ],
        "summary": "Get player-facing quest log",
        "description": "Returns UI-optimized quest log with progress summaries.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetQuestLogRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Quest log retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuestLogResponse"
                }
              }
            }
          }
        }
      }
    },
    "/quest/objective/progress": {
      "post": {
        "operationId": "reportObjectiveProgress",
        "tags": [
          "Objectives"
        ],
        "summary": "Report progress on an objective",
        "description": "Manually reports progress on a quest objective. Used by game systems.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReportProgressRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Progress recorded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectiveProgressResponse"
                }
              }
            }
          },
          "404": {
            "description": "Quest or objective not found"
          }
        }
      }
    },
    "/quest/objective/get": {
      "post": {
        "operationId": "getObjectiveProgress",
        "tags": [
          "Objectives"
        ],
        "summary": "Get objective progress details",
        "description": "Returns detailed progress information for a specific objective.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetObjectiveProgressRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Objective progress retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectiveProgressResponse"
                }
              }
            }
          },
          "404": {
            "description": "Quest or objective not found"
          }
        }
      }
    },
    "/quest/get-compress-data": {
      "post": {
        "summary": "Get quest data for compression",
        "operationId": "getCompressData",
        "tags": [
          "Compression"
        ],
        "description": "Called by Resource service during character compression.\nReturns active quests, completion counts, and category breakdown for archival.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCompressDataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Compressed data returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuestArchive"
                }
              }
            }
          },
          "404": {
            "description": "No quest data for character"
          }
        }
      }
    },
    "/realm/get": {
      "post": {
        "summary": "Get realm by ID",
        "operationId": "getRealm",
        "tags": [
          "Realm"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRealmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Realm retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmResponse"
                }
              }
            }
          },
          "404": {
            "description": "Realm not found"
          }
        }
      }
    },
    "/realm/get-by-code": {
      "post": {
        "summary": "Get realm by code",
        "description": "Retrieve a realm using its unique code (e.g., \"REALM_1\", \"REALM_2\")",
        "operationId": "getRealmByCode",
        "tags": [
          "Realm"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRealmByCodeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Realm retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmResponse"
                }
              }
            }
          },
          "404": {
            "description": "Realm not found"
          }
        }
      }
    },
    "/realm/list": {
      "post": {
        "summary": "List all realms",
        "description": "Retrieve all realms with optional filtering",
        "operationId": "listRealms",
        "tags": [
          "Realm"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRealmsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Realms retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/realm/exists": {
      "post": {
        "summary": "Check if realm exists and is active",
        "description": "Fast validation endpoint for other services to check realm validity.\nReturns true if realm exists and is not deprecated, false otherwise.\n",
        "operationId": "realmExists",
        "tags": [
          "Realm"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RealmExistsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Validation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmExistsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/realm/exists-batch": {
      "post": {
        "summary": "Check if multiple realms exist and are active",
        "description": "Batch validation endpoint for services creating multi-realm entities.\nReturns validation results for each realm ID in a single call, avoiding\nN+1 API calls when validating multiple realms.\n",
        "operationId": "realmsExistBatch",
        "tags": [
          "Realm"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RealmsExistBatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Validation results for all requested realms",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmsExistBatchResponse"
                }
              }
            }
          }
        }
      }
    },
    "/realm-history/get-participation": {
      "post": {
        "summary": "Get all historical events a realm participated in",
        "operationId": "getRealmParticipation",
        "tags": [
          "Historical Events"
        ],
        "description": "Retrieves all historical event participation records for a realm.\nSupports filtering by event category and minimum impact.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRealmParticipationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Participation records retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmParticipationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/realm-history/get-event-participants": {
      "post": {
        "summary": "Get all realms that participated in a historical event",
        "operationId": "getRealmEventParticipants",
        "tags": [
          "Historical Events"
        ],
        "description": "Retrieves all realms that participated in a specific historical event.\nUseful for generating event summaries or finding related realms.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRealmEventParticipantsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Participants retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmParticipationListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/realm-history/get-lore": {
      "post": {
        "summary": "Get machine-readable lore elements for behavior system",
        "operationId": "getRealmLore",
        "tags": [
          "Lore"
        ],
        "description": "Retrieves structured lore elements for a realm. These elements\nare machine-readable key-value pairs used by the behavior system for\ndecision-making, not narrative text for players.\n",
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRealmLoreRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Lore retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealmLoreResponse"
                }
              }
            }
          },
          "404": {
            "description": "No lore defined for this realm"
          }
        }
      }
    },
    "/relationship/get": {
      "post": {
        "operationId": "getRelationship",
        "tags": [
          "Relationship Management"
        ],
        "summary": "Get a relationship by ID",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRelationshipRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Relationship retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipResponse"
                }
              }
            }
          },
          "404": {
            "description": "Relationship not found"
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/relationship/list-by-entity": {
      "post": {
        "operationId": "listRelationshipsByEntity",
        "tags": [
          "Relationship Management"
        ],
        "summary": "List all relationships for an entity",
        "description": "Returns all relationships where the specified entity is either\nentity1 or entity2. Supports filtering by relationship type,\nother entity type, and whether to include ended relationships.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRelationshipsByEntityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Relationships retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipListResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/relationship/get-between": {
      "post": {
        "operationId": "getRelationshipsBetween",
        "tags": [
          "Relationship Management"
        ],
        "summary": "Get all relationships between two specific entities",
        "description": "Returns all relationships that exist between two specific entities,\nregardless of which is entity1 or entity2.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRelationshipsBetweenRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Relationships retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipListResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/relationship/list-by-type": {
      "post": {
        "operationId": "listRelationshipsByType",
        "tags": [
          "Relationship Management"
        ],
        "summary": "List all relationships of a specific type",
        "description": "Returns all relationships that use a specific relationship type.\nUseful for finding all \"FRIEND\" relationships, for example.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRelationshipsByTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Relationships retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipListResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ]
      }
    },
    "/relationship/cleanup-by-entity": {
      "post": {
        "operationId": "cleanupByEntity",
        "tags": [
          "Relationship Management"
        ],
        "summary": "Cleanup relationships referencing a deleted entity",
        "description": "Called by lib-resource cleanup coordination when a foundational entity\n(character, realm) is deleted. Ends all active relationships where the\nspecified entity is either entity1 or entity2. Ended relationships are\npreserved for history (soft-delete via endedAt). This endpoint is designed\nfor internal service-to-service calls during cascading resource cleanup.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CleanupByEntityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cleanup completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupByEntityResponse"
                }
              }
            }
          }
        },
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ]
      }
    },
    "/relationship-type/get": {
      "post": {
        "summary": "Get relationship type by ID",
        "operationId": "getRelationshipType",
        "tags": [
          "Relationship Type Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRelationshipTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Relationship type retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipTypeResponse"
                }
              }
            }
          },
          "404": {
            "description": "Relationship type not found"
          }
        }
      }
    },
    "/relationship-type/get-by-code": {
      "post": {
        "summary": "Get relationship type by code",
        "description": "Retrieve a relationship type using its unique code (e.g., \"SON\", \"MOTHER\", \"FRIEND\")",
        "operationId": "getRelationshipTypeByCode",
        "tags": [
          "Relationship Type Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetRelationshipTypeByCodeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Relationship type retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipTypeResponse"
                }
              }
            }
          },
          "404": {
            "description": "Relationship type not found"
          }
        }
      }
    },
    "/relationship-type/list": {
      "post": {
        "summary": "List all relationship types",
        "description": "Retrieve all relationship types with optional hierarchy filtering",
        "operationId": "listRelationshipTypes",
        "tags": [
          "Relationship Type Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListRelationshipTypesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Relationship types retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipTypeListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/relationship-type/get-children": {
      "post": {
        "summary": "Get child types for a parent type",
        "description": "Retrieve all relationship types that have the specified type as their parent",
        "operationId": "getChildRelationshipTypes",
        "tags": [
          "Relationship Type Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetChildRelationshipTypesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Child relationship types retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipTypeListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Parent relationship type not found"
          }
        }
      }
    },
    "/relationship-type/matches-hierarchy": {
      "post": {
        "summary": "Check if type matches ancestor in hierarchy",
        "description": "Checks if a relationship type matches or descends from an ancestor type.\nFor example, \"SON\" matches \"CHILD\" because CHILD is an ancestor of SON.\nThis enables queries like \"find all CHILD relationships\" to match SON, DAUGHTER, etc.\n",
        "operationId": "matchesHierarchy",
        "tags": [
          "Relationship Type Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MatchesHierarchyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Hierarchy match result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MatchesHierarchyResponse"
                }
              }
            }
          },
          "404": {
            "description": "One or both relationship types not found"
          }
        }
      }
    },
    "/relationship-type/get-ancestors": {
      "post": {
        "summary": "Get all ancestors of a relationship type",
        "description": "Returns the full ancestry chain from the specified type up to the root.\nFor example, for \"SON\" might return [\"CHILD\", \"FAMILY\"].\n",
        "operationId": "getAncestors",
        "tags": [
          "Relationship Type Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetAncestorsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Ancestors retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RelationshipTypeListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Relationship type not found"
          }
        }
      }
    },
    "/resource/register": {
      "post": {
        "operationId": "registerReference",
        "tags": [
          "Reference Management"
        ],
        "summary": "Register a reference to a resource",
        "description": "Records that sourceType:sourceId references resourceType:resourceId.\nTypically called via event handlers, not directly.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegisterReferenceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Reference registered",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisterReferenceResponse"
                }
              }
            }
          }
        }
      }
    },
    "/resource/unregister": {
      "post": {
        "operationId": "unregisterReference",
        "tags": [
          "Reference Management"
        ],
        "summary": "Remove a reference to a resource",
        "description": "Records that sourceType:sourceId no longer references resourceType:resourceId.\nTypically called via event handlers, not directly.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnregisterReferenceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Reference unregistered",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnregisterReferenceResponse"
                }
              }
            }
          }
        }
      }
    },
    "/resource/check": {
      "post": {
        "operationId": "checkReferences",
        "tags": [
          "Reference Management"
        ],
        "summary": "Check reference count and cleanup eligibility",
        "description": "Returns the current reference count for a resource and whether it is\neligible for cleanup (refcount=0 and grace period passed).\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CheckReferencesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Reference status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckReferencesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/resource/list": {
      "post": {
        "operationId": "listReferences",
        "tags": [
          "Reference Management"
        ],
        "summary": "List all references to a resource",
        "description": "Returns all entities currently referencing a resource.\nUseful for debugging and understanding reference chains.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListReferencesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of references",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListReferencesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/resource/cleanup/execute": {
      "post": {
        "operationId": "executeCleanup",
        "tags": [
          "Cleanup Management"
        ],
        "summary": "Execute cleanup for a resource",
        "description": "Validates refcount=0, grace period passed, acquires distributed lock,\nre-validates under lock, then executes all cleanup callbacks.\nReturns Conflict if refcount changed during execution.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteCleanupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cleanup executed or rejected",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExecuteCleanupResponse"
                }
              }
            }
          }
        }
      }
    },
    "/resource/cleanup/list": {
      "post": {
        "operationId": "listCleanupCallbacks",
        "tags": [
          "Cleanup Management"
        ],
        "summary": "List registered cleanup callbacks",
        "description": "Returns all cleanup callbacks registered for a resource type.\nUseful for debugging and admin inspection of cleanup chains.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListCleanupCallbacksRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of registered callbacks",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListCleanupCallbacksResponse"
                }
              }
            }
          }
        }
      }
    },
    "/resource/compress/execute": {
      "post": {
        "operationId": "executeCompress",
        "tags": [
          "Compression Management"
        ],
        "summary": "Compress a resource and all dependents",
        "description": "Gathers data from all registered compression callbacks, bundles into\na unified archive, and stores in MySQL. Optionally deletes source data\nafter successful archival via existing cleanup callbacks.\n\nFlow:\n1. Get all compression callbacks for resourceType, sorted by priority\n2. If dryRun, return preview without executing\n3. Acquire distributed lock\n4. Execute each callback to gather data\n5. Bundle responses into archive (gzipped JSON per entry)\n6. Store archive in MySQL\n7. If deleteSourceData, invoke cleanup callbacks\n8. Publish resource.compressed event\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteCompressRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Compression result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExecuteCompressResponse"
                }
              }
            }
          }
        }
      }
    },
    "/resource/compress/list": {
      "post": {
        "operationId": "listCompressCallbacks",
        "tags": [
          "Compression Management"
        ],
        "summary": "List registered compression callbacks",
        "description": "Returns all compression callbacks registered for a resource type.\nUseful for debugging and admin inspection of compression chains.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListCompressCallbacksRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Callback list",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListCompressCallbacksResponse"
                }
              }
            }
          }
        }
      }
    },
    "/resource/archive/get": {
      "post": {
        "operationId": "getArchive",
        "tags": [
          "Compression Management"
        ],
        "summary": "Retrieve compressed archive",
        "description": "Retrieves a compressed archive by resource type and ID.\nReturns the latest version unless a specific archiveId is provided.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetArchiveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Archive data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetArchiveResponse"
                }
              }
            }
          }
        }
      }
    },
    "/resource/snapshot/execute": {
      "post": {
        "operationId": "executeSnapshot",
        "tags": [
          "Snapshot Management"
        ],
        "summary": "Create ephemeral snapshot of a living resource",
        "description": "Creates a non-destructive snapshot of a resource using the same compression\ncallbacks, but stores the result in Redis with a configurable TTL instead\nof permanent MySQL storage.\n\n**Use Case**: The Storyline Composer needs compressed data from living\nentities (not just dead/archived ones) to seed emergent narratives.\nThis endpoint provides that capability without affecting the source data.\n\n**Key Differences from compress/execute**:\n1. Stores in Redis (ephemeral) not MySQL (permanent)\n2. Never deletes source data\n3. Publishes `resource.snapshot.created` event (not `resource.compressed`)\n4. Snapshot expires after TTL (default 1 hour, max 24 hours)\n\n**Intended Consumers**:\n- Actor behaviors (via ABML service_call)\n- Regional Watchers for storyline composition\n- Analytics for living entity state capture\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteSnapshotRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Snapshot result with snapshot ID and data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExecuteSnapshotResponse"
                }
              }
            }
          }
        }
      }
    },
    "/resource/snapshot/get": {
      "post": {
        "operationId": "getSnapshot",
        "tags": [
          "Snapshot Management"
        ],
        "summary": "Retrieve an ephemeral snapshot",
        "description": "Retrieves a previously created snapshot by its ID.\nReturns 404 if the snapshot has expired or doesn't exist.\n\nSnapshots are stored with TTL - if the TTL has elapsed, the snapshot\nis automatically deleted by Redis.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSnapshotRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Snapshot data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetSnapshotResponse"
                }
              }
            }
          }
        }
      }
    },
    "/save-load/slot/create": {
      "post": {
        "tags": [
          "Slots"
        ],
        "operationId": "CreateSlot",
        "summary": "Create or configure a save slot",
        "description": "Creates a new save slot or updates configuration of an existing slot.\nSlots are auto-created on first save, but pre-creation allows setting\ncustom configuration (max versions, retention policy, etc.).\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateSlotRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Slot created or updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlotResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "409": {
            "description": "Slot already exists with different owner"
          }
        }
      }
    },
    "/save-load/slot/get": {
      "post": {
        "tags": [
          "Slots"
        ],
        "operationId": "GetSlot",
        "summary": "Get slot metadata",
        "description": "Returns slot configuration and version summary.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSlotRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Slot found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlotResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot not found"
          }
        }
      }
    },
    "/save-load/slot/list": {
      "post": {
        "tags": [
          "Slots"
        ],
        "operationId": "ListSlots",
        "summary": "List slots for owner",
        "description": "Returns all slots owned by the specified entity.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSlotsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Slots listed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSlotsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/save-load/slot/delete": {
      "post": {
        "tags": [
          "Slots"
        ],
        "operationId": "DeleteSlot",
        "summary": "Delete slot and all versions",
        "description": "Permanently deletes a slot and all save versions within it.\nThis is irreversible. Requires owner access or admin role.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteSlotRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Slot deleted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteSlotResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot not found"
          },
          "403": {
            "description": "Not authorized to delete this slot"
          }
        }
      }
    },
    "/save-load/slot/rename": {
      "post": {
        "tags": [
          "Slots"
        ],
        "operationId": "RenameSlot",
        "summary": "Rename a save slot",
        "description": "Renames an existing slot without affecting its versions or data.\nThe new name must not already exist for this owner.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RenameSlotRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Slot renamed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SlotResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot not found"
          },
          "409": {
            "description": "Target name already exists"
          }
        }
      }
    },
    "/save-load/save": {
      "post": {
        "tags": [
          "Saves"
        ],
        "operationId": "Save",
        "summary": "Save data to slot",
        "description": "Creates a new version in the specified slot with the provided data.\nIf the slot doesn't exist, it's auto-created with default configuration.\n\nLarge saves (>1MB by default) are automatically compressed.\nRolling version cleanup is applied based on slot configuration.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SaveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Save successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SaveResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or data validation failed"
          },
          "413": {
            "description": "Save data exceeds maximum size limit"
          },
          "403": {
            "description": "Not authorized to save to this slot"
          }
        }
      }
    },
    "/save-load/load": {
      "post": {
        "tags": [
          "Saves"
        ],
        "operationId": "Load",
        "summary": "Load data from slot",
        "description": "Retrieves save data from the specified slot. By default, loads the\nlatest version. Optionally specify a version number or checkpoint name.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Load successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LoadResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          },
          "403": {
            "description": "Not authorized to load from this slot"
          }
        }
      }
    },
    "/save-load/save-delta": {
      "post": {
        "tags": [
          "Saves"
        ],
        "operationId": "SaveDelta",
        "summary": "Save incremental changes from base version",
        "description": "Creates a new version by applying a delta (patch) to a base version.\nSignificantly reduces storage for large saves with small incremental changes.\n\nUses JSON Patch (RFC 6902) by default. The implementation is designed to\nallow swapping to binary diff algorithms (bsdiff/xdelta) if needed for\nspecific use cases (e.g., binary game state).\n\nDelta versions store only the patch; full data is reconstructed on load.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SaveDeltaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Delta save successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SaveDeltaResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid delta or base version not found"
          },
          "409": {
            "description": "Base version has been deleted (cannot apply delta)"
          },
          "413": {
            "description": "Delta too large (consider full save instead)"
          }
        }
      }
    },
    "/save-load/load-with-deltas": {
      "post": {
        "tags": [
          "Saves"
        ],
        "operationId": "LoadWithDeltas",
        "summary": "Load save reconstructing from delta chain",
        "description": "Loads save data, automatically reconstructing from delta chain if needed.\nReturns the full reconstructed data, not the raw delta.\n\nFor performance, the service may cache reconstructed data or collapse\ndelta chains during background cleanup.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Load successful (reconstructed if delta)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LoadResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          },
          "422": {
            "description": "Delta chain broken (base version missing)"
          }
        }
      }
    },
    "/save-load/collapse-deltas": {
      "post": {
        "tags": [
          "Saves"
        ],
        "operationId": "CollapseDeltas",
        "summary": "Collapse delta chain into full snapshot",
        "description": "Collapses a chain of delta versions into a single full snapshot.\nUseful for reducing load latency or before deleting base versions.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CollapseDeltasRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Delta chain collapsed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SaveResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          }
        }
      }
    },
    "/save-load/version/list": {
      "post": {
        "tags": [
          "Versions"
        ],
        "operationId": "ListVersions",
        "summary": "List versions in slot",
        "description": "Returns all versions in a slot with metadata.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListVersionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Versions listed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListVersionsResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot not found"
          }
        }
      }
    },
    "/save-load/version/pin": {
      "post": {
        "tags": [
          "Versions"
        ],
        "operationId": "PinVersion",
        "summary": "Pin a version as checkpoint",
        "description": "Pins a specific version, excluding it from rolling cleanup.\nOptionally assigns a checkpoint name for easy retrieval.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PinVersionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Version pinned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VersionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          }
        }
      }
    },
    "/save-load/version/unpin": {
      "post": {
        "tags": [
          "Versions"
        ],
        "operationId": "UnpinVersion",
        "summary": "Unpin a version",
        "description": "Removes pin from a version, making it eligible for rolling cleanup.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnpinVersionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Version unpinned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VersionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          }
        }
      }
    },
    "/save-load/version/delete": {
      "post": {
        "tags": [
          "Versions"
        ],
        "operationId": "DeleteVersion",
        "summary": "Delete specific version",
        "description": "Permanently deletes a specific version from a slot.\nCannot delete pinned versions; unpin first.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteVersionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Version deleted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteVersionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          },
          "409": {
            "description": "Cannot delete pinned version"
          }
        }
      }
    },
    "/save-load/query": {
      "post": {
        "tags": [
          "Query"
        ],
        "operationId": "QuerySaves",
        "summary": "Query saves with filters",
        "description": "Search and filter saves across slots. Supports filtering by owner,\ncategory, date range, metadata, and more. Paginated results.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QuerySavesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Query results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuerySavesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/save-load/copy": {
      "post": {
        "tags": [
          "Transfer"
        ],
        "operationId": "CopySave",
        "summary": "Copy save to different slot or owner",
        "description": "Copies a save version to a different slot or owner.\nCan copy to same owner (different slot) or different owner (with admin).\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CopySaveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Save copied",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SaveResponse"
                }
              }
            }
          },
          "404": {
            "description": "Source slot or version not found"
          },
          "403": {
            "description": "Not authorized to copy to target"
          }
        }
      }
    },
    "/save-load/export": {
      "post": {
        "tags": [
          "Transfer"
        ],
        "operationId": "ExportSaves",
        "summary": "Export saves for backup/portability",
        "description": "Exports one or more slots with all versions as a downloadable archive.\nReturns a pre-signed URL to download the export bundle.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExportSavesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Export prepared",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExportSavesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/save-load/verify": {
      "post": {
        "tags": [
          "Validation"
        ],
        "operationId": "VerifyIntegrity",
        "summary": "Verify save data integrity",
        "description": "Verifies the integrity of stored save data by comparing content hash\nagainst the stored SHA-256 hash. Detects corruption or tampering.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VerifyIntegrityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Verification result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VerifyIntegrityResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          }
        }
      }
    },
    "/save-load/version/promote": {
      "post": {
        "tags": [
          "Versions"
        ],
        "operationId": "PromoteVersion",
        "summary": "Promote old version to latest",
        "description": "Creates a new version from an existing older version, effectively\n\"promoting\" it to be the latest. Useful for rollback scenarios.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromoteVersionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Version promoted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SaveResponse"
                }
              }
            }
          },
          "404": {
            "description": "Slot or version not found"
          }
        }
      }
    },
    "/save-load/migrate": {
      "post": {
        "tags": [
          "Migration"
        ],
        "operationId": "MigrateSave",
        "summary": "Migrate save to new schema version",
        "description": "Applies migration handlers to upgrade a save from one schema version\nto another. Creates a new version with the migrated data.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MigrateSaveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Migration successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MigrateSaveResponse"
                }
              }
            }
          },
          "400": {
            "description": "Migration failed or no path exists"
          },
          "404": {
            "description": "Save not found"
          }
        }
      }
    },
    "/save-load/schema/register": {
      "post": {
        "tags": [
          "Migration"
        ],
        "operationId": "RegisterSchema",
        "summary": "Register a save data schema",
        "description": "Registers a JSON schema for validation of save data.\nOptionally includes migration handlers from previous versions.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegisterSchemaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Schema registered",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SchemaResponse"
                }
              }
            }
          }
        }
      }
    },
    "/save-load/schema/list": {
      "post": {
        "tags": [
          "Migration"
        ],
        "operationId": "ListSchemas",
        "summary": "List registered schemas",
        "description": "Returns all registered schemas for a game/namespace.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSchemasRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Schemas listed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSchemasResponse"
                }
              }
            }
          }
        }
      }
    },
    "/scene/create": {
      "post": {
        "summary": "Create a new scene document",
        "description": "Creates a new scene document and stores it in lib-asset.\nPublishes scene.created event on success.\nReturns Conflict if a scene with the same sceneId already exists.\n",
        "operationId": "createScene",
        "tags": [
          "Scene"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateSceneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scene created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SceneResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid scene structure (validation failed)"
          },
          "409": {
            "description": "Scene with this sceneId already exists"
          }
        }
      }
    },
    "/scene/get": {
      "post": {
        "summary": "Retrieve a scene by ID",
        "description": "Retrieves a scene document. Optionally resolves nested scene references\nup to a configurable depth.\n",
        "operationId": "getScene",
        "tags": [
          "Scene"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSceneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scene retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetSceneResponse"
                }
              }
            }
          },
          "404": {
            "description": "Scene not found"
          }
        }
      }
    },
    "/scene/list": {
      "post": {
        "summary": "List scenes with filtering",
        "description": "Lists scenes matching the provided filters. Supports pagination.\nResults are ordered by updatedAt descending (most recent first).\n",
        "operationId": "listScenes",
        "tags": [
          "Scene"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListScenesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scenes listed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListScenesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/scene/update": {
      "post": {
        "summary": "Update a scene document",
        "description": "Updates an existing scene document. Scene must not be checked out by\nanother user. Increments the PATCH version automatically.\nPublishes scene.updated event on success.\n",
        "operationId": "updateScene",
        "tags": [
          "Scene"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateSceneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scene updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SceneResponse"
                }
              }
            }
          },
          "404": {
            "description": "Scene not found"
          },
          "409": {
            "description": "Scene is checked out by another user"
          },
          "400": {
            "description": "Invalid scene structure"
          }
        }
      }
    },
    "/scene/delete": {
      "post": {
        "summary": "Delete a scene",
        "description": "Soft-deletes a scene. The scene data remains recoverable via lib-asset\nfor approximately 30 days. Cannot delete if other scenes reference this one.\nPublishes scene.deleted event on success.\n",
        "operationId": "deleteScene",
        "tags": [
          "Scene"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteSceneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scene deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteSceneResponse"
                }
              }
            }
          },
          "404": {
            "description": "Scene not found"
          },
          "409": {
            "description": "Cannot delete - other scenes reference this scene"
          }
        }
      }
    },
    "/scene/validate": {
      "post": {
        "summary": "Validate a scene structure",
        "description": "Validates a scene document without saving it. Checks structural validity\nand optionally applies game-specific validation rules.\n",
        "operationId": "validateScene",
        "tags": [
          "Scene"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ValidateSceneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Validation result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationResult"
                }
              }
            }
          }
        }
      }
    },
    "/scene/checkout": {
      "post": {
        "summary": "Lock a scene for editing",
        "description": "Acquires an exclusive lock on the scene for editing.\nReturns a checkout token required for commit.\nLock expires after TTL if not extended via heartbeat.\n",
        "operationId": "checkoutScene",
        "tags": [
          "Versioning"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CheckoutRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Checkout successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckoutResponse"
                }
              }
            }
          },
          "404": {
            "description": "Scene not found"
          },
          "409": {
            "description": "Scene already checked out by another user"
          }
        }
      }
    },
    "/scene/commit": {
      "post": {
        "summary": "Save changes and release lock",
        "description": "Commits the changes made during checkout, increments version,\nand releases the lock. Publishes scene.committed event.\n",
        "operationId": "commitScene",
        "tags": [
          "Versioning"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CommitRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Commit successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CommitResponse"
                }
              }
            }
          },
          "403": {
            "description": "Invalid checkout token"
          },
          "409": {
            "description": "Checkout expired"
          }
        }
      }
    },
    "/scene/discard": {
      "post": {
        "summary": "Release lock without saving changes",
        "description": "Discards any changes and releases the checkout lock.\nScene remains at its pre-checkout version.\n",
        "operationId": "discardCheckout",
        "tags": [
          "Versioning"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DiscardRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Discard successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DiscardResponse"
                }
              }
            }
          },
          "403": {
            "description": "Invalid checkout token"
          }
        }
      }
    },
    "/scene/heartbeat": {
      "post": {
        "summary": "Extend checkout lock TTL",
        "description": "Extends the checkout lock TTL. Should be called periodically\nduring editing to prevent lock expiration.\n",
        "operationId": "heartbeatCheckout",
        "tags": [
          "Versioning"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HeartbeatRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Lock extended",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HeartbeatResponse"
                }
              }
            }
          },
          "403": {
            "description": "Invalid checkout token"
          },
          "409": {
            "description": "Checkout expired"
          }
        }
      }
    },
    "/scene/history": {
      "post": {
        "summary": "Get version history for a scene",
        "description": "Returns the version history for a scene, up to the configured\nretention limit per gameId.\n",
        "operationId": "getSceneHistory",
        "tags": [
          "Versioning"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HistoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "History retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HistoryResponse"
                }
              }
            }
          },
          "404": {
            "description": "Scene not found"
          }
        }
      }
    },
    "/scene/get-validation-rules": {
      "post": {
        "summary": "Get validation rules for a gameId+sceneType",
        "description": "Retrieves the registered validation rules for a specific\ngameId and sceneType combination.\n",
        "operationId": "getValidationRules",
        "tags": [
          "Validation"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetValidationRulesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Rules retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetValidationRulesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/scene/search": {
      "post": {
        "summary": "Full-text search across scenes",
        "description": "Searches scene names, descriptions, tags, and node names\nfor matching content.\n",
        "operationId": "searchScenes",
        "tags": [
          "Query"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchScenesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchScenesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/scene/find-references": {
      "post": {
        "summary": "Find scenes that reference a given scene",
        "description": "Returns all scenes that contain reference nodes pointing\nto the specified scene.\n",
        "operationId": "findReferences",
        "tags": [
          "Query"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FindReferencesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Referencing scenes found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FindReferencesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/scene/find-asset-usage": {
      "post": {
        "summary": "Find scenes using a specific asset",
        "description": "Returns all scenes containing nodes that reference\na specific asset ID.\n",
        "operationId": "findAssetUsage",
        "tags": [
          "Query"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FindAssetUsageRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Asset usage found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FindAssetUsageResponse"
                }
              }
            }
          }
        }
      }
    },
    "/scene/duplicate": {
      "post": {
        "summary": "Duplicate a scene with a new ID",
        "description": "Creates a copy of a scene with a new sceneId and name.\nAll node IDs are regenerated. Version resets to 1.0.0.\n",
        "operationId": "duplicateScene",
        "tags": [
          "Scene"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DuplicateSceneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scene duplicated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SceneResponse"
                }
              }
            }
          },
          "404": {
            "description": "Source scene not found"
          }
        }
      }
    },
    "/seed/create": {
      "post": {
        "operationId": "CreateSeed",
        "summary": "Create a new seed",
        "description": "Creates a new seed bound to the specified owner. The seed type must be registered and the owner type must be allowed by the seed type definition. Returns conflict if creating this seed would exceed the type's MaxPerOwner limit.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateSeedRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/get": {
      "post": {
        "operationId": "GetSeed",
        "summary": "Get seed by ID",
        "description": "Returns the seed entity with current growth phase and summary data.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSeedRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/get-by-owner": {
      "post": {
        "operationId": "GetSeedsByOwner",
        "summary": "Get seeds by owner ID and type",
        "description": "Returns all seeds owned by the specified entity. Optionally filter by seed type code and status.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSeedsByOwnerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seeds found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSeedsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/list": {
      "post": {
        "operationId": "ListSeeds",
        "summary": "List seeds with filtering",
        "description": "Returns seeds matching the specified filters. Supports filtering by seed type, owner type, growth phase, status, and game service.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSeedsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seeds returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSeedsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/update": {
      "post": {
        "operationId": "UpdateSeed",
        "summary": "Update seed metadata or display name",
        "description": "Updates mutable fields of a seed. Cannot change owner or seed type.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateSeedRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/activate": {
      "post": {
        "operationId": "ActivateSeed",
        "summary": "Set a seed as active",
        "description": "Activates the specified seed. Only one seed of a given type can be active per owner at a time. Deactivates any previously active seed of the same type.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ActivateSeedRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed activated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/archive": {
      "post": {
        "operationId": "ArchiveSeed",
        "summary": "Archive a seed",
        "description": "Soft-deletes a seed, preserving its data but removing it from active rotation. Archived seeds do not count toward the MaxPerOwner limit. Cannot archive an active seed.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ArchiveSeedRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed archived",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/growth/get": {
      "post": {
        "operationId": "GetGrowth",
        "summary": "Get full growth domain map",
        "description": "Returns the complete growth domain map for a seed, including all top-level and sub-domain entries with their current depth values.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetGrowthRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Growth data returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GrowthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/growth/record": {
      "post": {
        "operationId": "RecordGrowth",
        "summary": "Record growth in a domain",
        "description": "Records growth in a specific domain for a seed. Primarily called internally by consuming services after processing game events. Triggers capability manifest recomputation if thresholds are crossed.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecordGrowthRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Growth recorded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GrowthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/growth/record-batch": {
      "post": {
        "operationId": "RecordGrowthBatch",
        "summary": "Record growth across multiple domains atomically",
        "description": "Records growth across multiple domains in a single atomic operation. Useful when a single game event contributes to multiple domains simultaneously.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecordGrowthBatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Growth recorded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GrowthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/growth/get-phase": {
      "post": {
        "operationId": "GetGrowthPhase",
        "summary": "Get current growth phase",
        "description": "Returns the current computed growth phase for the seed, based on the seed type's configured phase thresholds.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetGrowthPhaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Phase returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GrowthPhaseResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/capability/get-manifest": {
      "post": {
        "operationId": "GetCapabilityManifest",
        "summary": "Get current capability manifest",
        "description": "Returns the most recently computed capability manifest for the seed. Consumers interpret what capabilities mean (UX modules, spawning permissions, faction actions, etc.).\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCapabilityManifestRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Manifest returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CapabilityManifestResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/type/register": {
      "post": {
        "operationId": "RegisterSeedType",
        "summary": "Register a new seed type definition",
        "description": "Registers a seed type with its growth phase definitions, capability rules, bond cardinality, and owner type restrictions. Seed types are scoped to game services.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegisterSeedTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed type registered",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedTypeResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/type/get": {
      "post": {
        "operationId": "GetSeedType",
        "summary": "Get seed type definition",
        "description": "Returns the full seed type definition including phases and capability rules.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSeedTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed type found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedTypeResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/type/list": {
      "post": {
        "operationId": "ListSeedTypes",
        "summary": "List registered seed types",
        "description": "Returns all seed types registered for the specified game service.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSeedTypesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed types returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSeedTypesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/type/update": {
      "post": {
        "operationId": "UpdateSeedType",
        "summary": "Update seed type definition",
        "description": "Updates a seed type definition. Changes to phase thresholds or capability rules trigger recomputation for all seeds of this type.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateSeedTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed type updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedTypeResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/type/deprecate": {
      "post": {
        "operationId": "DeprecateSeedType",
        "summary": "Deprecate a seed type",
        "description": "Marks a seed type as deprecated. Deprecated seed types cannot be used to create new seeds. Existing seeds of this type remain unaffected. Must be deprecated before it can be deleted.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeprecateSeedTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed type deprecated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedTypeResponse"
                }
              }
            }
          },
          "404": {
            "description": "Seed type not found"
          },
          "409": {
            "description": "Seed type already deprecated"
          }
        }
      }
    },
    "/seed/type/undeprecate": {
      "post": {
        "operationId": "UndeprecateSeedType",
        "summary": "Restore a deprecated seed type",
        "description": "Removes deprecated status from a seed type, allowing new seeds of this type to be created again.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UndeprecateSeedTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed type restored",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedTypeResponse"
                }
              }
            }
          },
          "404": {
            "description": "Seed type not found"
          },
          "409": {
            "description": "Seed type is not deprecated"
          }
        }
      }
    },
    "/seed/type/delete": {
      "post": {
        "operationId": "DeleteSeedType",
        "summary": "Delete a seed type",
        "description": "Hard deletes a deprecated seed type. Fails if any non-archived seeds of this type exist. Must deprecate first, then ensure all seeds are archived or deleted before calling this endpoint.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteSeedTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed type deleted"
          },
          "400": {
            "description": "Seed type is not deprecated"
          },
          "404": {
            "description": "Seed type not found"
          },
          "409": {
            "description": "Non-archived seeds still exist for this type"
          }
        }
      }
    },
    "/seed/bond/initiate": {
      "post": {
        "operationId": "InitiateBond",
        "summary": "Begin bond process between seeds",
        "description": "Initiates a bond between seeds of the same type. All participants must confirm for the bond to become active. Returns conflict if any participant already has a bond and the type's cardinality is 1.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InitiateBondRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bond initiated, awaiting confirmation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BondResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/bond/confirm": {
      "post": {
        "operationId": "ConfirmBond",
        "summary": "Confirm a pending bond",
        "description": "Confirms a pending bond. When all participants have confirmed, the bond becomes active. Bond permanence is determined by the seed type.\n",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConfirmBondRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bond confirmed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BondResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/bond/get": {
      "post": {
        "operationId": "GetBond",
        "summary": "Get bond by ID",
        "description": "Returns the bond record with all participants and status.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetBondRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bond found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BondResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/bond/get-for-seed": {
      "post": {
        "operationId": "GetBondForSeed",
        "summary": "Get bond for a specific seed",
        "description": "Returns the bond that the specified seed participates in, if any.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetBondForSeedRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Bond found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BondResponse"
                }
              }
            }
          }
        }
      }
    },
    "/seed/bond/get-partners": {
      "post": {
        "operationId": "GetBondPartners",
        "summary": "Get partner seed(s) public info",
        "description": "Returns public information about the other seeds in the bond.",
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetBondPartnersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Partners returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BondPartnersResponse"
                }
              }
            }
          }
        }
      }
    },
    "/species/get": {
      "post": {
        "summary": "Get species by ID",
        "operationId": "getSpecies",
        "tags": [
          "Species"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSpeciesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Species retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpeciesResponse"
                }
              }
            }
          },
          "404": {
            "description": "Species not found"
          }
        }
      }
    },
    "/species/get-by-code": {
      "post": {
        "summary": "Get species by code",
        "description": "Retrieve a species using its unique code (e.g., \"HUMAN\", \"ELF\", \"DWARF\")",
        "operationId": "getSpeciesByCode",
        "tags": [
          "Species"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSpeciesByCodeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Species retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpeciesResponse"
                }
              }
            }
          },
          "404": {
            "description": "Species not found"
          }
        }
      }
    },
    "/species/list": {
      "post": {
        "summary": "List all species",
        "description": "Retrieve all species with optional realm filtering",
        "operationId": "listSpecies",
        "tags": [
          "Species"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSpeciesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Species retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpeciesListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/species/list-by-realm": {
      "post": {
        "summary": "List species available in a realm",
        "description": "Retrieve all species that are available in a specific realm",
        "operationId": "listSpeciesByRealm",
        "tags": [
          "Species"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSpeciesByRealmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Species retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpeciesListResponse"
                }
              }
            }
          },
          "404": {
            "description": "Realm not found"
          }
        }
      }
    },
    "/status/template/create": {
      "post": {
        "operationId": "createStatusTemplate",
        "tags": [
          "StatusTemplate"
        ],
        "summary": "Create a status template",
        "description": "Create a status template defining a status effect type. Each template has\na unique code within its game service, references an item template for\ninventory placement, and configures stacking behavior and optional contract\nintegration for lifecycle management.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateStatusTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Status template created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatusTemplateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (validation error)"
          },
          "404": {
            "description": "Referenced game service or item template not found"
          },
          "409": {
            "description": "Duplicate code for this game service, or max templates exceeded"
          }
        }
      }
    },
    "/status/template/get": {
      "post": {
        "operationId": "getStatusTemplate",
        "tags": [
          "StatusTemplate"
        ],
        "summary": "Get a status template by ID",
        "description": "Retrieves a status template by its unique identifier.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetStatusTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Status template retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatusTemplateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Status template not found"
          }
        }
      }
    },
    "/status/template/get-by-code": {
      "post": {
        "operationId": "getStatusTemplateByCode",
        "tags": [
          "StatusTemplate"
        ],
        "summary": "Get a status template by code",
        "description": "Retrieves a status template by its game service and unique code.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetStatusTemplateByCodeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Status template retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatusTemplateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Status template not found"
          }
        }
      }
    },
    "/status/template/list": {
      "post": {
        "operationId": "listStatusTemplates",
        "tags": [
          "StatusTemplate"
        ],
        "summary": "List status templates",
        "description": "Paginated list of status templates filtered by game service with optional category filter.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListStatusTemplatesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Status templates retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListStatusTemplatesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/status/template/update": {
      "post": {
        "operationId": "updateStatusTemplate",
        "tags": [
          "StatusTemplate"
        ],
        "summary": "Update a status template",
        "description": "Update mutable fields of a status template. Only non-null fields in the request are updated.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateStatusTemplateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Status template updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatusTemplateResponse"
                }
              }
            }
          },
          "404": {
            "description": "Status template not found"
          }
        }
      }
    },
    "/status/template/seed": {
      "post": {
        "operationId": "seedStatusTemplates",
        "tags": [
          "StatusTemplate"
        ],
        "summary": "Bulk seed status templates",
        "description": "Bulk create status templates from a payload, skipping duplicates. Validates item template IDs. Returns count of created templates.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SeedStatusTemplatesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedStatusTemplatesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (validation errors)"
          }
        }
      }
    },
    "/status/grant": {
      "post": {
        "operationId": "grantStatus",
        "tags": [
          "Status"
        ],
        "summary": "Grant a status effect to an entity",
        "description": "Grant a status effect to an entity. Creates an item instance in the entity's\nstatus container and optionally creates a contract instance for lifecycle\nmanagement. Auto-creates the status container (and inventory container) if\none does not exist for this entity and game service.\n\nStacking behavior is determined by the template:\n- refresh_duration: resets timer, increments stack count\n- independent: creates a separate instance per application\n- increase_intensity: increments stack, resets timer\n- replace: removes existing, creates new\n- ignore: rejects if already present\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GrantStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Status granted successfully (or stacked/refreshed/replaced)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GrantStatusResponse"
                }
              }
            }
          },
          "404": {
            "description": "Status template or game service not found"
          },
          "409": {
            "description": "Grant rejected (max statuses, stack limit, ignore behavior, contract/item failure)"
          }
        }
      }
    },
    "/status/remove": {
      "post": {
        "operationId": "removeStatus",
        "tags": [
          "Status"
        ],
        "summary": "Remove a specific status instance",
        "description": "Remove a specific status instance by ID. Destroys the item via lib-item,\ncancels any associated contract, deletes the instance record, and invalidates\nthe active status cache.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RemoveStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Status removed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatusInstanceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Status instance not found"
          }
        }
      }
    },
    "/status/remove-by-source": {
      "post": {
        "operationId": "removeBySource",
        "tags": [
          "Status"
        ],
        "summary": "Remove all statuses from a source",
        "description": "Remove all status instances granted by a specific source for an entity. Used for cascading removal when a source entity is deleted.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RemoveBySourceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Statuses removed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RemoveStatusesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/status/remove-by-category": {
      "post": {
        "operationId": "removeByCategory",
        "tags": [
          "Status"
        ],
        "summary": "Remove all statuses of a category (cleanse)",
        "description": "Remove all status instances of a given category for an entity. Used for cleanse mechanics (remove all debuffs, etc.).",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RemoveByCategoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Statuses cleansed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RemoveStatusesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/status/has": {
      "post": {
        "operationId": "hasStatus",
        "tags": [
          "Status"
        ],
        "summary": "Check if an entity has a specific status",
        "description": "Check if an entity has a specific status template code active. Returns the status instance ID and stack count if found.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HasStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Check completed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HasStatusResponse"
                }
              }
            }
          }
        }
      }
    },
    "/status/list": {
      "post": {
        "operationId": "listStatuses",
        "tags": [
          "Status"
        ],
        "summary": "List active statuses for an entity",
        "description": "List active status effects for an entity with optional category filter\nand seed-derived passive effect inclusion. Merges item-based statuses\nfrom cache with seed-derived effects when includePassive is true.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListStatusesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Statuses retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListStatusesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/status/get": {
      "post": {
        "operationId": "getStatus",
        "tags": [
          "Status"
        ],
        "summary": "Get a specific status instance",
        "description": "Retrieves a status instance by its unique identifier with full details including metadata.",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Status instance retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatusInstanceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Status instance not found"
          }
        }
      }
    },
    "/status/effects/get": {
      "post": {
        "operationId": "getEffects",
        "tags": [
          "Effects"
        ],
        "summary": "Get unified effects for an entity",
        "description": "Get all active effects for an entity including both item-based statuses\nand seed-derived passive capabilities. Returns a unified view with source\nattribution via the effectSource field.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetEffectsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Effects retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetEffectsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/status/effects/get-seed": {
      "post": {
        "operationId": "getSeedEffects",
        "tags": [
          "Effects"
        ],
        "summary": "Get seed-derived passive effects for an entity",
        "description": "Get seed-derived passive effects only. Queries ISeedClient for capability\nmanifests across all seeds owned by the entity. Returns capabilities with\ndomain, fidelity, and seed attribution.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSeedEffectsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Seed effects retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SeedEffectsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/status/cleanup-by-owner": {
      "post": {
        "operationId": "cleanupByOwner",
        "tags": [
          "Cleanup"
        ],
        "summary": "Remove all statuses and containers for an owner",
        "description": "Remove all status containers, instances, and inventory containers for an\nowner entity. Called by lib-resource cleanup callbacks when a character or\naccount is deleted. Destroys inventory containers (cascades to items),\ndeletes all instance records, and invalidates all caches.\n",
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CleanupByOwnerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cleanup completed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupResponse"
                }
              }
            }
          }
        }
      }
    },
    "/storyline/compose": {
      "post": {
        "summary": "Compose a storyline plan from archive seeds",
        "description": "Generates a storyline plan using data from compressed archives and/or\nlive snapshots. The plan describes phases, actions, and entity requirements\nbut does NOT create any entities - callers decide whether to instantiate.\n\n**Workflow**:\n1. Fetch archive/snapshot data via IResourceClient\n2. Extract world state from archive bundle\n3. Select template based on goal and constraints\n4. Run GOAP planner to generate action sequences\n5. Cache plan and publish storyline.composed event\n",
        "operationId": "Compose",
        "tags": [
          "Composition"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ComposeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Storyline plan generated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ComposeResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (no valid archives, incompatible goal/genre)"
          },
          "404": {
            "description": "Archive or snapshot not found"
          }
        }
      }
    },
    "/storyline/plan/get": {
      "post": {
        "summary": "Retrieve a cached storyline plan",
        "description": "Retrieves a previously generated storyline plan by its ID.\nReturns 404 if the plan has expired from cache or doesn't exist.\n",
        "operationId": "GetPlan",
        "tags": [
          "Plans"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetPlanRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Plan retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetPlanResponse"
                }
              }
            }
          },
          "404": {
            "description": "Plan not found or expired"
          }
        }
      }
    },
    "/storyline/plan/list": {
      "post": {
        "summary": "List cached storyline plans",
        "description": "Lists storyline plans in the cache, optionally filtered by realm.\nPlans are ordered by creation time (newest first).\n",
        "operationId": "ListPlans",
        "tags": [
          "Plans"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListPlansRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Plans listed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListPlansResponse"
                }
              }
            }
          }
        }
      }
    },
    "/storyline/scenario/create": {
      "post": {
        "summary": "Create a new scenario definition",
        "description": "Creates a reusable scenario definition template.\nScenarios are passive building blocks with triggering conditions,\nphases, mutations, and optional quest hooks.\n",
        "operationId": "CreateScenarioDefinition",
        "tags": [
          "Scenario Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateScenarioDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scenario definition created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScenarioDefinition"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (validation error)"
          },
          "409": {
            "description": "Scenario with code already exists"
          }
        }
      }
    },
    "/storyline/scenario/get": {
      "post": {
        "summary": "Get a scenario definition by ID or code",
        "description": "Retrieves a scenario definition by its ID or code.\nUses read-through cache for performance.\n",
        "operationId": "GetScenarioDefinition",
        "tags": [
          "Scenario Definitions"
        ],
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetScenarioDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scenario definition retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetScenarioDefinitionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Scenario not found"
          }
        }
      }
    },
    "/storyline/scenario/list": {
      "post": {
        "summary": "List scenario definitions",
        "description": "Lists scenario definitions with optional filtering by realm, game service, and tags.\nResults are paginated and ordered by priority (descending), then creation time.\n",
        "operationId": "ListScenarioDefinitions",
        "tags": [
          "Scenario Definitions"
        ],
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListScenarioDefinitionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scenarios listed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListScenarioDefinitionsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/storyline/scenario/update": {
      "post": {
        "summary": "Update a scenario definition",
        "description": "Updates an existing scenario definition.\nUses ETag for optimistic concurrency control.\n",
        "operationId": "UpdateScenarioDefinition",
        "tags": [
          "Scenario Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateScenarioDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scenario updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScenarioDefinition"
                }
              }
            }
          },
          "404": {
            "description": "Scenario not found"
          },
          "409": {
            "description": "Concurrent modification conflict"
          }
        }
      }
    },
    "/storyline/scenario/deprecate": {
      "post": {
        "summary": "Deprecate a scenario definition",
        "description": "Soft-deletes a scenario definition by marking it deprecated.\nDeprecated scenarios are not returned by find-available.\n",
        "operationId": "DeprecateScenarioDefinition",
        "tags": [
          "Scenario Definitions"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeprecateScenarioDefinitionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scenario deprecated"
          },
          "404": {
            "description": "Scenario not found"
          }
        }
      }
    },
    "/storyline/scenario/test": {
      "post": {
        "summary": "Dry-run scenario trigger",
        "description": "Tests whether a scenario would trigger for a character without\nactually executing it. Returns detailed condition evaluation results\nand predicted mutations.\n",
        "operationId": "TestScenarioTrigger",
        "tags": [
          "Scenario Discovery"
        ],
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TestScenarioRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Test result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestScenarioResponse"
                }
              }
            }
          },
          "404": {
            "description": "Scenario not found"
          }
        }
      }
    },
    "/storyline/scenario/get-active": {
      "post": {
        "summary": "Get active scenarios for a character",
        "description": "Returns currently executing scenarios for a character.\n",
        "operationId": "GetActiveScenarios",
        "tags": [
          "Scenario Execution"
        ],
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetActiveScenariosRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Active scenarios",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetActiveScenariosResponse"
                }
              }
            }
          }
        }
      }
    },
    "/storyline/scenario/get-history": {
      "post": {
        "summary": "Get scenario execution history",
        "description": "Returns historical scenario executions for a character with pagination.\n",
        "operationId": "GetScenarioHistory",
        "tags": [
          "Scenario Execution"
        ],
        "x-permissions": [
          {
            "role": "user"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetScenarioHistoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Scenario history",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetScenarioHistoryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/storyline/get-compress-data": {
      "post": {
        "summary": "Get storyline data for compression",
        "operationId": "getCompressData",
        "tags": [
          "Compression"
        ],
        "description": "Called by Resource service during character compression.\nReturns scenario participations, active arcs, and completion counts for archival.\n",
        "x-permissions": [
          {
            "role": "developer"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetCompressDataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Compressed data returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StorylineArchive"
                }
              }
            }
          },
          "404": {
            "description": "No storyline data for character"
          }
        }
      }
    },
    "/subscription/account/list": {
      "post": {
        "summary": "Get subscriptions for an account",
        "description": "Returns all subscriptions for a given account, with optional filtering.",
        "operationId": "getAccountSubscriptions",
        "tags": [
          "Subscription Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetAccountSubscriptionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Subscriptions retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/subscription/get": {
      "post": {
        "summary": "Get a specific subscription by ID",
        "operationId": "getSubscription",
        "tags": [
          "Subscription Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetSubscriptionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Subscription retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionInfo"
                }
              }
            }
          },
          "404": {
            "description": "Subscription not found"
          }
        }
      }
    },
    "/subscription/cancel": {
      "post": {
        "summary": "Cancel a subscription",
        "description": "Cancels a subscription. Users can cancel their own subscriptions,\nadmins can cancel any subscription.\n",
        "operationId": "cancelSubscription",
        "tags": [
          "Subscription Management"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CancelSubscriptionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Subscription cancelled successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionInfo"
                }
              }
            }
          },
          "404": {
            "description": "Subscription not found"
          },
          "403": {
            "description": "Not authorized to cancel this subscription"
          }
        }
      }
    },
    "/voice/peer/answer": {
      "post": {
        "summary": "Send SDP answer to complete WebRTC handshake",
        "description": "Called by clients after receiving a VoicePeerJoinedEvent containing an SDP offer.\nThe client generates an SDP answer and sends it via this endpoint.\nThe answering peer is notified via VoicePeerUpdatedEvent.\n\n**Access Control**: This endpoint requires the `voice:ringing` state, which is\nautomatically set by the Voice service when a VoicePeerJoinedEvent is sent to the client.\nThe state is cleared after the answer is processed or times out.\n",
        "operationId": "answerPeer",
        "tags": [
          "Voice Peers"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "voice": "ringing"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AnswerPeerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "SDP answer processed, peer notified"
          },
          "404": {
            "description": "Peer or room not found"
          },
          "403": {
            "description": "Not in voice:ringing state (no pending offers)"
          }
        }
      }
    },
    "/voice/room/broadcast/request": {
      "post": {
        "summary": "Request broadcast consent from all room participants",
        "description": "Initiates the broadcast consent flow. All current room participants receive a VoiceBroadcastConsentRequestEvent. Broadcasting only starts after all participants consent. If ANY participant declines, the broadcast request is denied.\nThis endpoint is the ONLY way to initiate voice room broadcasting. lib-stream subscribes to the resulting approval/decline events.\n",
        "operationId": "requestBroadcastConsent",
        "tags": [
          "Voice Broadcasting"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "voice": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BroadcastConsentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Consent request sent to all participants",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BroadcastConsentStatus"
                }
              }
            }
          },
          "404": {
            "description": "Room not found"
          },
          "409": {
            "description": "Broadcast already active or consent pending"
          }
        }
      }
    },
    "/voice/room/broadcast/consent": {
      "post": {
        "summary": "Respond to a broadcast consent request",
        "description": "Called by each participant to consent or decline broadcasting. When all participants consent, lib-voice publishes voice.room.broadcast.approved. If any participant declines, lib-voice publishes voice.room.broadcast.declined.\n",
        "operationId": "respondBroadcastConsent",
        "tags": [
          "Voice Broadcasting"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "voice": "consent_pending"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BroadcastConsentResponse"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Consent response recorded",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BroadcastConsentStatus"
                }
              }
            }
          },
          "404": {
            "description": "Room not found or no pending consent request"
          }
        }
      }
    },
    "/voice/room/broadcast/stop": {
      "post": {
        "summary": "Stop broadcasting from a voice room",
        "description": "Any participant can stop an active broadcast at any time. This is equivalent to revoking consent. Publishes voice.room.broadcast.stopped with reason ConsentRevoked.\n",
        "operationId": "stopBroadcast",
        "tags": [
          "Voice Broadcasting"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "voice": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StopBroadcastConsentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Broadcast stopped"
          },
          "404": {
            "description": "Room not found or not broadcasting"
          }
        }
      }
    },
    "/voice/room/broadcast/status": {
      "post": {
        "summary": "Get broadcast status for a voice room",
        "description": "Returns the current broadcast state: whether consent is pending, active, or inactive.\n",
        "operationId": "getBroadcastStatus",
        "tags": [
          "Voice Broadcasting"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {
              "voice": "in_room"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BroadcastStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Broadcast status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BroadcastConsentStatus"
                }
              }
            }
          },
          "404": {
            "description": "Room not found"
          }
        }
      }
    },
    "/website/status": {
      "get": {
        "summary": "Get website status and version",
        "operationId": "getStatus",
        "tags": [
          "Status"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "responses": {
          "200": {
            "description": "Website service status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatusResponse"
                }
              }
            }
          }
        }
      }
    },
    "/website/content/{slug}": {
      "get": {
        "summary": "Get dynamic page content from CMS",
        "operationId": "getPageContent",
        "tags": [
          "Content"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "slug",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "pattern": "^[a-z0-9-]+$"
            },
            "description": "Page slug identifier"
          }
        ],
        "responses": {
          "200": {
            "description": "Page content retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PageContent"
                }
              }
            }
          },
          "404": {
            "description": "Page not found"
          }
        }
      }
    },
    "/website/news": {
      "get": {
        "summary": "Get latest news and announcements",
        "operationId": "getNews",
        "tags": [
          "Content"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 50,
              "default": 10
            },
            "description": "Number of news items to return"
          },
          {
            "name": "offset",
            "in": "query",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            },
            "description": "Pagination offset"
          }
        ],
        "responses": {
          "200": {
            "description": "News items retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NewsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/website/downloads": {
      "get": {
        "summary": "Get download links for game clients",
        "operationId": "getDownloads",
        "tags": [
          "Downloads"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "parameters": [
          {
            "name": "platform",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/Platform"
            },
            "description": "Filter by platform"
          }
        ],
        "responses": {
          "200": {
            "description": "Download links retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DownloadsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/website/contact": {
      "post": {
        "summary": "Submit contact form",
        "operationId": "submitContact",
        "tags": [
          "Contact"
        ],
        "x-permissions": [
          {
            "role": "anonymous",
            "states": {}
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ContactRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Contact form submitted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContactResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid form data"
          },
          "429": {
            "description": "Too many requests"
          }
        }
      }
    },
    "/website/account/profile": {
      "get": {
        "summary": "Get account profile for logged-in user",
        "operationId": "getAccountProfile",
        "tags": [
          "Account"
        ],
        "x-permissions": [
          {
            "role": "user",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "Account profile retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountProfile"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        }
      }
    },
    "/website/cms/pages": {
      "get": {
        "summary": "List all CMS pages",
        "operationId": "listPages",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "includeUnpublished",
            "in": "query",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Page list retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PageMetadata"
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create new CMS page",
        "operationId": "createPage",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PageContent"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Page created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PageContent"
                }
              }
            }
          }
        }
      }
    },
    "/website/cms/pages/{slug}": {
      "put": {
        "summary": "Update CMS page",
        "operationId": "updatePage",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "slug",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PageContent"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Page updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PageContent"
                }
              }
            }
          }
        }
      },
      "delete": {
        "summary": "Delete CMS page",
        "operationId": "deletePage",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "slug",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Page deleted"
          }
        }
      }
    },
    "/website/cms/site-settings": {
      "get": {
        "summary": "Get site configuration",
        "operationId": "getSiteSettings",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "responses": {
          "200": {
            "description": "Site settings retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SiteSettings"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update site configuration",
        "operationId": "updateSiteSettings",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SiteSettings"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Settings updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SiteSettings"
                }
              }
            }
          }
        }
      }
    },
    "/website/cms/theme": {
      "get": {
        "summary": "Get current theme configuration",
        "operationId": "getTheme",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "responses": {
          "200": {
            "description": "Theme configuration retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ThemeConfig"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update theme configuration",
        "operationId": "updateTheme",
        "tags": [
          "CMS"
        ],
        "x-permissions": [
          {
            "role": "developer",
            "states": {}
          }
        ],
        "security": [
          {
            "BearerAuth": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ThemeConfig"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Theme updated"
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AbandonQuestRequest": {
        "type": "object",
        "description": "Request to abandon an active quest",
        "additionalProperties": false,
        "required": [
          "questInstanceId",
          "questorCharacterId"
        ],
        "properties": {
          "questInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Quest instance to abandon"
          },
          "questorCharacterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character abandoning"
          }
        }
      },
      "AbandonScenarioRequest": {
        "type": "object",
        "description": "Request to abandon a scenario",
        "required": [
          "accountId",
          "scenarioInstanceId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account abandoning the scenario"
          },
          "scenarioInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Scenario instance to abandon"
          }
        }
      },
      "AbandonScenarioResponse": {
        "type": "object",
        "description": "Response after abandoning a scenario",
        "required": [
          "scenarioInstanceId",
          "partialGrowthAwarded"
        ],
        "properties": {
          "scenarioInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Abandoned scenario instance ID"
          },
          "partialGrowthAwarded": {
            "type": "object",
            "additionalProperties": {
              "type": "number",
              "format": "float"
            },
            "description": "Partial growth awarded based on time spent"
          }
        }
      },
      "AcceptMatchRequest": {
        "type": "object",
        "description": "Request to accept a formed match",
        "additionalProperties": false,
        "required": [
          "webSocketSessionId",
          "accountId",
          "matchId"
        ],
        "properties": {
          "webSocketSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player"
          },
          "matchId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the match to accept"
          }
        }
      },
      "AcceptMatchResponse": {
        "type": "object",
        "description": "Response after accepting a match",
        "additionalProperties": false,
        "required": [
          "matchId",
          "allAccepted"
        ],
        "properties": {
          "matchId": {
            "type": "string",
            "format": "uuid",
            "description": "Match identifier"
          },
          "allAccepted": {
            "type": "boolean",
            "description": "Whether all players have accepted"
          },
          "acceptedCount": {
            "type": "integer",
            "nullable": true,
            "description": "Number of players who have accepted"
          },
          "totalCount": {
            "type": "integer",
            "nullable": true,
            "description": "Total players who need to accept"
          },
          "gameSessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game session ID (set when all players accept)"
          }
        }
      },
      "AcceptQuestRequest": {
        "type": "object",
        "description": "Request to accept a quest and create an active instance",
        "additionalProperties": false,
        "required": [
          "questorCharacterId"
        ],
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Quest definition ID (provide either this or code)"
          },
          "code": {
            "type": "string",
            "nullable": true,
            "description": "Quest code (provide either this or definitionId)"
          },
          "questorCharacterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character accepting the quest"
          },
          "questGiverCharacterId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "NPC offering the quest"
          },
          "termOverrides": {
            "type": "object",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            },
            "description": "Template variable overrides"
          }
        }
      },
      "AccountProfile": {
        "description": "User account information displayed on the website profile page",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "accountId",
          "email",
          "createdAt"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the account"
          },
          "email": {
            "type": "string",
            "format": "email",
            "description": "Email address associated with the account"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "User-chosen display name"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Date and time when the account was created"
          },
          "lastLogin": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Date and time of the last successful login"
          }
        }
      },
      "AccountResponse": {
        "type": "object",
        "description": "Account information response",
        "additionalProperties": false,
        "required": [
          "accountId",
          "createdAt",
          "emailVerified",
          "roles"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the account"
          },
          "email": {
            "type": "string",
            "format": "email",
            "nullable": true,
            "description": "Email address associated with the account. Null for OAuth/Steam accounts without email."
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Display name for the account"
          },
          "passwordHash": {
            "type": "string",
            "nullable": true,
            "description": "BCrypt hashed password for authentication"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the account was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Timestamp when the account was last updated"
          },
          "emailVerified": {
            "type": "boolean",
            "description": "Whether the email address has been verified"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of roles assigned to the account"
          },
          "authMethods": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AuthMethodInfo"
            },
            "description": "List of authentication methods linked to the account"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Custom metadata associated with the account"
          },
          "mfaEnabled": {
            "type": "boolean",
            "default": false,
            "description": "Whether multi-factor authentication is enabled for this account"
          },
          "mfaSecret": {
            "type": "string",
            "nullable": true,
            "description": "Encrypted TOTP secret (AES-256-GCM ciphertext). Auth service encrypts and decrypts. Account stores opaque ciphertext."
          },
          "mfaRecoveryCodes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "BCrypt-hashed single-use recovery codes. Auth service generates and verifies. Account stores opaque hashes."
          }
        }
      },
      "AchievementDefinitionResponse": {
        "type": "object",
        "description": "Achievement definition details",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "achievementId",
          "displayName",
          "description",
          "achievementType",
          "points",
          "isActive",
          "createdAt"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning game service"
          },
          "achievementId": {
            "type": "string",
            "description": "Unique identifier"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "description": "How to earn this achievement"
          },
          "hiddenDescription": {
            "type": "string",
            "nullable": true,
            "description": "Description for hidden achievements"
          },
          "achievementType": {
            "$ref": "#/components/schemas/AchievementType",
            "description": "Classification of the achievement"
          },
          "entityTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityType"
            },
            "description": "Allowed entity types"
          },
          "progressTarget": {
            "type": "integer",
            "nullable": true,
            "description": "Target for progressive achievements"
          },
          "points": {
            "type": "integer",
            "description": "Point value"
          },
          "iconUrl": {
            "type": "string",
            "nullable": true,
            "description": "Achievement icon URL"
          },
          "platforms": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Platform"
            },
            "description": "Available platforms"
          },
          "platformIds": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Platform-specific IDs"
          },
          "prerequisites": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Required achievements"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether achievement is earnable"
          },
          "earnedCount": {
            "type": "integer",
            "format": "int64",
            "description": "How many entities have earned this"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the achievement was created"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional metadata"
          }
        }
      },
      "AchievementProgress": {
        "type": "object",
        "description": "Progress toward a single achievement",
        "additionalProperties": false,
        "required": [
          "achievementId",
          "isUnlocked"
        ],
        "properties": {
          "achievementId": {
            "type": "string",
            "description": "Achievement identifier"
          },
          "displayName": {
            "type": "string",
            "description": "Achievement display name"
          },
          "currentProgress": {
            "type": "integer",
            "nullable": true,
            "description": "Current progress (for progressive)"
          },
          "targetProgress": {
            "type": "integer",
            "nullable": true,
            "description": "Target progress (for progressive)"
          },
          "percentComplete": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Completion percentage (0-100)"
          },
          "isUnlocked": {
            "type": "boolean",
            "description": "Whether achievement is unlocked"
          },
          "unlockedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When achievement was unlocked"
          }
        }
      },
      "AchievementProgressResponse": {
        "type": "object",
        "description": "Achievement progress for an entity",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "progress"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type that owns this progress summary"
          },
          "progress": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AchievementProgress"
            },
            "description": "Progress for each achievement"
          },
          "totalPoints": {
            "type": "integer",
            "description": "Total points from unlocked achievements"
          },
          "unlockedCount": {
            "type": "integer",
            "description": "Number of unlocked achievements"
          }
        }
      },
      "AchievementType": {
        "type": "string",
        "description": "Type of achievement",
        "enum": [
          "standard",
          "progressive",
          "hidden",
          "secret"
        ]
      },
      "ActionEffect": {
        "x-sdk-type": "BeyondImmersion.Bannou.StorylineStoryteller.Actions.ActionEffect",
        "type": "object",
        "additionalProperties": false,
        "description": "Effect of an action on world state (SDK type)",
        "required": [
          "key",
          "value"
        ],
        "properties": {
          "key": {
            "type": "string",
            "description": "State key to modify"
          },
          "value": {
            "description": "New value to set (any type)"
          },
          "cardinality": {
            "$ref": "#/components/schemas/EffectCardinality",
            "description": "How the effect is applied"
          }
        }
      },
      "ActionMappingResponse": {
        "type": "object",
        "description": "A registered mapping from a GOAP action tag to violation type codes",
        "additionalProperties": false,
        "required": [
          "tag",
          "violationTypes",
          "createdAt"
        ],
        "properties": {
          "tag": {
            "type": "string",
            "minLength": 1,
            "maxLength": 128,
            "description": "The GOAP action tag (e.g., \"steal_food\", \"deceive_merchant\")"
          },
          "violationTypes": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 128
            },
            "minItems": 1,
            "maxItems": 20,
            "description": "Violation type codes this tag maps to (e.g., [\"theft\", \"dishonesty\"])"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "maxLength": 512,
            "description": "Human-readable description of what this mapping represents"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this mapping was first created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this mapping was last modified"
          }
        }
      },
      "ActivateDeityRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to activate a dormant deity",
        "required": [
          "deityId"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity to activate"
          }
        }
      },
      "ActivateSeedRequest": {
        "type": "object",
        "description": "Request to activate a seed.",
        "required": [
          "seedId"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed to activate."
          }
        }
      },
      "ActiveQuestSummary": {
        "type": "object",
        "description": "Summary of an active quest for archive purposes",
        "additionalProperties": false,
        "required": [
          "questId",
          "questCode",
          "name",
          "currentObjective",
          "totalObjectives",
          "startedAt"
        ],
        "properties": {
          "questId": {
            "type": "string",
            "format": "uuid",
            "description": "Quest instance ID"
          },
          "questCode": {
            "type": "string",
            "description": "Quest code for lookup"
          },
          "name": {
            "type": "string",
            "description": "Quest display name"
          },
          "currentObjective": {
            "type": "integer",
            "minimum": 0,
            "description": "Number of completed objectives"
          },
          "totalObjectives": {
            "type": "integer",
            "minimum": 1,
            "description": "Total number of objectives"
          },
          "startedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the quest was accepted"
          },
          "category": {
            "$ref": "#/components/schemas/QuestCategory",
            "nullable": true,
            "description": "Quest category (if available)"
          }
        }
      },
      "ActorCapabilities": {
        "type": "object",
        "description": "Actor-specific capabilities that affect affordance evaluation.\nSame location may afford different actions to different actor types.\n",
        "properties": {
          "size": {
            "$ref": "#/components/schemas/ActorSize",
            "description": "Affects cover requirements and passage width"
          },
          "height": {
            "type": "number",
            "description": "Actor height in meters (affects cover, sightlines)",
            "nullable": true
          },
          "canClimb": {
            "type": "boolean",
            "default": false,
            "description": "Can reach elevated positions"
          },
          "canSwim": {
            "type": "boolean",
            "default": false,
            "description": "Includes water-based positions"
          },
          "canFly": {
            "type": "boolean",
            "default": false,
            "description": "Includes aerial positions"
          },
          "perceptionRange": {
            "type": "number",
            "description": "Affects sightline distance requirements",
            "nullable": true
          },
          "movementSpeed": {
            "type": "number",
            "description": "Affects escape route viability calculations",
            "nullable": true
          },
          "stealthRating": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "Affects ambush/hidden_path affordance scoring",
            "nullable": true
          }
        }
      },
      "ActorInstanceResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response containing actor instance details",
        "required": [
          "actorId",
          "templateId",
          "category",
          "status",
          "startedAt",
          "loopIterations"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "Unique actor identifier"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template this actor was instantiated from"
          },
          "category": {
            "type": "string",
            "description": "Actor category from template"
          },
          "nodeId": {
            "type": "string",
            "nullable": true,
            "description": "Pool node running this actor (null in bannou mode)"
          },
          "nodeAppId": {
            "type": "string",
            "nullable": true,
            "description": "Pool node's app-id for direct messaging"
          },
          "status": {
            "description": "Current actor lifecycle state",
            "$ref": "#/components/schemas/ActorStatus"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Associated character ID (for NPC brains)"
          },
          "startedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the actor started running"
          },
          "lastHeartbeat": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last heartbeat timestamp from the actor"
          },
          "loopIterations": {
            "type": "integer",
            "format": "int64",
            "description": "Number of behavior loop iterations executed"
          }
        }
      },
      "ActorSize": {
        "type": "string",
        "description": "Size classification affecting cover requirements and passage width",
        "enum": [
          "tiny",
          "small",
          "medium",
          "large",
          "huge"
        ],
        "default": "medium"
      },
      "ActorStatus": {
        "type": "string",
        "enum": [
          "pending",
          "starting",
          "running",
          "paused",
          "stopping",
          "stopped",
          "error"
        ],
        "description": "Current actor lifecycle state"
      },
      "ActorTemplateResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response containing actor template details",
        "required": [
          "templateId",
          "category",
          "behaviorRef",
          "tickIntervalMs",
          "autoSaveIntervalSeconds",
          "maxInstancesPerNode",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique template identifier"
          },
          "category": {
            "type": "string",
            "description": "Category identifier"
          },
          "behaviorRef": {
            "type": "string",
            "description": "Reference to behavior in lib-assets"
          },
          "configuration": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Default configuration passed to behavior execution"
          },
          "autoSpawn": {
            "description": "Auto-spawn configuration for instantiate-on-access",
            "nullable": true,
            "$ref": "#/components/schemas/AutoSpawnConfig"
          },
          "tickIntervalMs": {
            "type": "integer",
            "description": "Milliseconds between behavior loop iterations"
          },
          "autoSaveIntervalSeconds": {
            "type": "integer",
            "description": "Seconds between automatic state saves"
          },
          "maxInstancesPerNode": {
            "type": "integer",
            "description": "Maximum actors of this category per pool node"
          },
          "cognitionTemplateId": {
            "type": "string",
            "nullable": true,
            "description": "Cognition template ID for this actor type. Primary source for cognition\npipeline resolution. When null, falls back to ABML metadata, then category default.\n"
          },
          "cognitionOverrides": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Static template-level cognition overrides. Applied as the first layer\nin the three-layer override composition (template \u2192 instance \u2192 ABML metadata).\n"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the template was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the template was last updated"
          }
        }
      },
      "AddItemRequest": {
        "type": "object",
        "description": "Request to add item to container",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "containerId"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance ID to add"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Target container ID"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Specific slot (auto-assign if null)"
          },
          "slotX": {
            "type": "integer",
            "nullable": true,
            "description": "Grid X position"
          },
          "slotY": {
            "type": "integer",
            "nullable": true,
            "description": "Grid Y position"
          },
          "rotated": {
            "type": "boolean",
            "nullable": true,
            "description": "Rotate in grid"
          },
          "autoStack": {
            "type": "boolean",
            "default": true,
            "description": "Auto-merge with existing stacks"
          }
        }
      },
      "AddItemResponse": {
        "type": "object",
        "description": "Response after adding item",
        "additionalProperties": false,
        "required": [
          "success",
          "instanceId",
          "containerId"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether add succeeded"
          },
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Added item ID"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container ID"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Assigned slot"
          },
          "slotX": {
            "type": "integer",
            "nullable": true,
            "description": "Assigned X position"
          },
          "slotY": {
            "type": "integer",
            "nullable": true,
            "description": "Assigned Y position"
          },
          "mergedWithInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Instance merged into if stacked"
          }
        }
      },
      "AddLicenseDefinitionRequest": {
        "type": "object",
        "description": "Request to add a license definition to a board template",
        "additionalProperties": false,
        "required": [
          "boardTemplateId",
          "code",
          "position",
          "lpCost",
          "itemTemplateId"
        ],
        "properties": {
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template to add this definition to"
          },
          "code": {
            "type": "string",
            "maxLength": 64,
            "description": "Unique license code within this board template"
          },
          "position": {
            "$ref": "#/components/schemas/GridPosition",
            "description": "Grid position for this license node"
          },
          "lpCost": {
            "type": "integer",
            "minimum": 0,
            "description": "License Point cost to unlock this node"
          },
          "itemTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Item template created when this license is unlocked"
          },
          "prerequisites": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "License codes that must be unlocked before this one (non-adjacent requirements)"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description of what this license grants"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Game-specific metadata for this license node"
          }
        }
      },
      "AddMemberRequest": {
        "type": "object",
        "description": "Request to add a character to a faction",
        "additionalProperties": false,
        "required": [
          "factionId",
          "characterId"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction to add the character to"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to add as a member"
          },
          "role": {
            "$ref": "#/components/schemas/FactionMemberRole",
            "nullable": true,
            "description": "Role to assign (null uses configured default)"
          }
        }
      },
      "AdjacencyMode": {
        "type": "string",
        "description": "Grid traversal adjacency mode for a board template.\n- four_way: Orthogonal only (up, down, left, right)\n- eight_way: Orthogonal + diagonal (all 8 surrounding cells)\n",
        "enum": [
          "four_way",
          "eight_way"
        ]
      },
      "AdminCleanupResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of admin-triggered idle room cleanup",
        "required": [
          "cleanedRooms",
          "archivedRooms",
          "deletedRooms"
        ],
        "properties": {
          "cleanedRooms": {
            "type": "integer",
            "description": "Total rooms processed by cleanup"
          },
          "archivedRooms": {
            "type": "integer",
            "description": "Number of rooms archived"
          },
          "deletedRooms": {
            "type": "integer",
            "description": "Number of rooms deleted"
          }
        }
      },
      "AdminForceCleanupRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Empty request body for force cleanup",
        "properties": {}
      },
      "AdminGetStatsRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Empty request body for stats endpoint",
        "properties": {}
      },
      "AdminListRoomsRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Admin request to list all rooms with filters and pagination",
        "properties": {
          "roomTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Filter by room type"
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChatRoomStatus"
              }
            ],
            "nullable": true,
            "description": "Filter by status"
          },
          "page": {
            "type": "integer",
            "default": 0,
            "description": "Page number (zero-based)"
          },
          "pageSize": {
            "type": "integer",
            "default": 50,
            "description": "Number of items per page"
          }
        }
      },
      "AdminStatsResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "System-wide chat statistics for admin monitoring",
        "required": [
          "totalRooms",
          "activeRooms",
          "lockedRooms",
          "archivedRooms",
          "totalParticipants",
          "totalRoomTypes"
        ],
        "properties": {
          "totalRooms": {
            "type": "integer",
            "description": "Total number of rooms in the system"
          },
          "activeRooms": {
            "type": "integer",
            "description": "Number of active rooms"
          },
          "lockedRooms": {
            "type": "integer",
            "description": "Number of locked rooms"
          },
          "archivedRooms": {
            "type": "integer",
            "description": "Number of archived rooms"
          },
          "totalParticipants": {
            "type": "integer",
            "description": "Total participants across all rooms"
          },
          "totalRoomTypes": {
            "type": "integer",
            "description": "Total registered room types"
          }
        }
      },
      "AdvanceDiscoveryRequest": {
        "type": "object",
        "description": "Request to advance the discovery level of an unlocked entry",
        "additionalProperties": false,
        "required": [
          "collectionId",
          "entryCode"
        ],
        "properties": {
          "collectionId": {
            "type": "string",
            "format": "uuid",
            "description": "Collection containing the entry"
          },
          "entryCode": {
            "type": "string",
            "description": "Entry code to advance discovery for"
          }
        }
      },
      "AdvanceDiscoveryResponse": {
        "type": "object",
        "description": "Result of advancing discovery level",
        "additionalProperties": false,
        "required": [
          "entryCode",
          "newLevel",
          "reveals"
        ],
        "properties": {
          "entryCode": {
            "type": "string",
            "description": "Entry code that was advanced"
          },
          "newLevel": {
            "type": "integer",
            "description": "New discovery level after advancement"
          },
          "reveals": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Information keys revealed at the new level"
          }
        }
      },
      "Affordance": {
        "type": "object",
        "description": "Describes a capability or interaction mode for a node.\nUsed by AI systems to understand what actions are possible and by\ncharacter controllers for contextual animations.\n",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/AffordanceType",
            "description": "The type of affordance"
          },
          "parameters": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Type-specific parameters. Examples:\n- sittable: { height: 0.5, facing: [0,0,1] }\n- door: { openAngle: 90, locked: false }\n- container: { capacity: 10, itemTypes: [\"weapon\", \"consumable\"] }\n"
          }
        }
      },
      "AffordanceFreshness": {
        "type": "string",
        "description": "Controls caching behavior for affordance queries",
        "enum": [
          "fresh",
          "cached",
          "aggressive_cache"
        ],
        "default": "cached"
      },
      "AffordanceLocation": {
        "type": "object",
        "description": "A location that affords the requested action",
        "properties": {
          "position": {
            "$ref": "#/components/schemas/Position3D",
            "description": "Location position"
          },
          "bounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Area bounds if affordance spans an area",
            "nullable": true
          },
          "score": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "How well this location affords the action (0-1)"
          },
          "features": {
            "type": "object",
            "additionalProperties": true,
            "description": "What makes this location suitable.\nExample: { \"cover_rating\": 0.8, \"sightlines\": [\"north\"], \"terrain\": \"rocky\" }\n",
            "nullable": true
          },
          "objectIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Map objects contributing to this affordance",
            "nullable": true
          }
        }
      },
      "AffordanceQueryMetadata": {
        "type": "object",
        "description": "Metadata about the affordance query execution",
        "properties": {
          "kindsSearched": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Map kinds that were queried",
            "nullable": true
          },
          "objectsEvaluated": {
            "type": "integer",
            "description": "Number of candidate objects evaluated"
          },
          "candidatesGenerated": {
            "type": "integer",
            "description": "Number of candidate positions generated"
          },
          "searchDurationMs": {
            "type": "integer",
            "description": "Query execution time in milliseconds"
          },
          "cacheHit": {
            "type": "boolean",
            "description": "Whether results came from cache"
          }
        }
      },
      "AffordanceQueryRequest": {
        "type": "object",
        "description": "Query for locations that afford a specific action",
        "required": [
          "regionId",
          "affordanceType"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region to search"
          },
          "affordanceType": {
            "$ref": "#/components/schemas/AffordanceType",
            "description": "Type of affordance to search for"
          },
          "customAffordance": {
            "$ref": "#/components/schemas/CustomAffordance",
            "description": "Custom affordance definition (when affordanceType=custom)",
            "nullable": true
          },
          "bounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Optional bounds to search within",
            "nullable": true
          },
          "maxResults": {
            "type": "integer",
            "default": 10,
            "maximum": 100,
            "description": "Maximum locations to return"
          },
          "minScore": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "default": 0.5,
            "description": "Minimum affordance score to include"
          },
          "participantCount": {
            "type": "integer",
            "description": "Expected participants (affects space requirements)",
            "nullable": true
          },
          "excludePositions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Position3D"
            },
            "description": "Positions to exclude (e.g., player's current location)",
            "nullable": true
          },
          "actorCapabilities": {
            "$ref": "#/components/schemas/ActorCapabilities",
            "description": "Actor capabilities affecting evaluation",
            "nullable": true
          },
          "freshness": {
            "$ref": "#/components/schemas/AffordanceFreshness",
            "description": "Cache freshness level"
          },
          "maxAgeSeconds": {
            "type": "integer",
            "minimum": 0,
            "maximum": 3600,
            "description": "Max age of cached results (for cached/aggressive_cache)",
            "nullable": true
          }
        }
      },
      "AffordanceQueryResponse": {
        "type": "object",
        "description": "Affordance query results",
        "properties": {
          "locations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AffordanceLocation"
            },
            "description": "Scored locations (highest score first)"
          },
          "queryMetadata": {
            "$ref": "#/components/schemas/AffordanceQueryMetadata",
            "description": "Metadata about query execution (optional)",
            "nullable": true
          }
        }
      },
      "AffordanceType": {
        "type": "string",
        "description": "Well-known affordance types with predefined scoring logic.\nUse 'custom' for novel affordance definitions.\n",
        "enum": [
          "ambush",
          "shelter",
          "vista",
          "choke_point",
          "gathering_spot",
          "dramatic_reveal",
          "hidden_path",
          "defensible_position",
          "custom"
        ]
      },
      "Analytics": {
        "description": "Analytics and tracking configuration for website visitor metrics",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "googleAnalyticsId": {
            "type": "string",
            "nullable": true,
            "description": "Google Analytics tracking ID"
          },
          "otherTrackers": {
            "type": "object",
            "additionalProperties": true,
            "description": "Configuration for other analytics trackers"
          }
        }
      },
      "AnswerPeerRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to send an SDP answer to complete a WebRTC handshake.\nSent by clients after receiving a VoicePeerJoinedEvent with an SDP offer.\n",
        "required": [
          "roomId",
          "senderSessionId",
          "targetSessionId",
          "sdpAnswer"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Voice room ID"
          },
          "senderSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Session ID of the answering peer (caller of this endpoint)"
          },
          "targetSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Session ID of the peer whose offer we're answering"
          },
          "sdpAnswer": {
            "type": "string",
            "description": "SDP answer generated by this client's WebRTC stack"
          },
          "iceCandidates": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "ICE candidates for NAT traversal (can be trickled later)"
          }
        }
      },
      "ArcType": {
        "x-sdk-type": "BeyondImmersion.Bannou.StorylineTheory.Arcs.ArcType",
        "type": "string",
        "enum": [
          "RagsToRiches",
          "Tragedy",
          "ManInHole",
          "Icarus",
          "Cinderella",
          "Oedipus"
        ],
        "description": "Emotional arc shapes from Reagan et al. research.\nRagsToRiches: Rise (1)\nTragedy: Fall (2)\nManInHole: Fall then rise (3)\nIcarus: Rise then fall (4)\nCinderella: Rise, fall, rise (5)\nOedipus: Fall, rise, fall (6)\n"
      },
      "ArchiveBundleEntry": {
        "type": "object",
        "additionalProperties": false,
        "description": "Single entry in the archive bundle",
        "required": [
          "sourceType",
          "serviceName",
          "data",
          "compressedAt"
        ],
        "properties": {
          "sourceType": {
            "type": "string",
            "description": "Type of data (e.g., \"character-personality\")"
          },
          "serviceName": {
            "type": "string",
            "description": "Service that provided the data"
          },
          "data": {
            "type": "string",
            "description": "Base64-encoded gzipped JSON from the service callback"
          },
          "compressedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this entry was compressed"
          },
          "dataChecksum": {
            "type": "string",
            "nullable": true,
            "description": "SHA256 hash for integrity verification"
          },
          "originalSizeBytes": {
            "type": "integer",
            "nullable": true,
            "description": "Size before compression"
          }
        }
      },
      "ArchiveInfo": {
        "description": "Archive metadata including size and document count",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "archiveId",
          "namespace",
          "createdAt"
        ],
        "properties": {
          "archiveId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the archive"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace the archive belongs to"
          },
          "bundleAssetId": {
            "type": "string",
            "format": "uuid",
            "description": "Asset ID in Asset Service"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Description of the archive"
          },
          "documentCount": {
            "type": "integer",
            "description": "Number of documents in the archive"
          },
          "sizeBytes": {
            "type": "integer",
            "description": "Total size of the archive in bytes"
          },
          "commitHash": {
            "type": "string",
            "nullable": true,
            "description": "Git commit hash if namespace was bound at archive time"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the archive was created"
          },
          "owner": {
            "type": "string",
            "description": "Owner of this archive. NOT a session ID.\nContains either an accountId (UUID format) for user-initiated archives\nor a service name for service-initiated archives.\n"
          }
        }
      },
      "ArchiveRoomRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to archive a room (makes it read-only)",
        "required": [
          "roomId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID to archive"
          }
        }
      },
      "ArchiveSeedRequest": {
        "type": "object",
        "description": "Request to archive a seed.",
        "required": [
          "seedId"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed to archive."
          }
        }
      },
      "AreaContentConfigResponse": {
        "type": "object",
        "description": "Area content configuration",
        "additionalProperties": false,
        "required": [
          "areaConfigId",
          "areaCode",
          "gameServiceId",
          "collectionType",
          "themes",
          "defaultEntryCode",
          "createdAt"
        ],
        "properties": {
          "areaConfigId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique area config identifier"
          },
          "areaCode": {
            "type": "string",
            "description": "Area code"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this area config belongs to"
          },
          "collectionType": {
            "$ref": "#/components/schemas/CollectionType",
            "description": "Type of collection this config applies to"
          },
          "themes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Theme tags for this area"
          },
          "defaultEntryCode": {
            "type": "string",
            "description": "Default entry code"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this area config was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this area config was last updated"
          }
        }
      },
      "AssetConflict": {
        "type": "object",
        "additionalProperties": false,
        "description": "Describes a conflict when the same asset ID has different content hashes",
        "required": [
          "assetId",
          "conflictingBundles"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "The conflicting asset identifier"
          },
          "conflictingBundles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConflictingBundleEntry"
            },
            "description": "Bundles with conflicting versions of this asset"
          }
        }
      },
      "AssetMetadata": {
        "type": "object",
        "additionalProperties": false,
        "description": "Complete asset metadata including system-generated fields",
        "required": [
          "assetId",
          "contentHash",
          "filename",
          "contentType",
          "size",
          "assetType",
          "realm",
          "tags",
          "processingStatus",
          "isArchived",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Unique asset identifier"
          },
          "contentHash": {
            "type": "string",
            "description": "SHA256 hash of file contents"
          },
          "filename": {
            "type": "string",
            "description": "Original filename"
          },
          "contentType": {
            "type": "string",
            "description": "MIME content type"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "File size in bytes"
          },
          "assetType": {
            "$ref": "#/components/schemas/AssetType",
            "description": "Type classification for the asset"
          },
          "realm": {
            "$ref": "#/components/schemas/GameRealm",
            "description": "Game realm the asset belongs to"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Searchable tags for the asset"
          },
          "processingStatus": {
            "$ref": "#/components/schemas/ProcessingStatus",
            "description": "Current status of asset processing pipeline"
          },
          "isArchived": {
            "type": "boolean",
            "description": "Whether the asset is in cold/archival storage",
            "default": false
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the asset was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the asset was last updated"
          }
        }
      },
      "AssetMetadataInput": {
        "type": "object",
        "additionalProperties": false,
        "description": "User-provided metadata for asset categorization",
        "properties": {
          "assetType": {
            "$ref": "#/components/schemas/AssetType",
            "description": "Type classification for the asset"
          },
          "realm": {
            "$ref": "#/components/schemas/GameRealm",
            "description": "Game realm the asset belongs to"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Searchable tags for the asset"
          }
        }
      },
      "AssetReference": {
        "type": "object",
        "description": "Reference to an asset in lib-asset",
        "required": [
          "assetId"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional bundle containing the asset"
          },
          "assetId": {
            "type": "string",
            "format": "uuid",
            "description": "Asset identifier in lib-asset"
          },
          "variantId": {
            "type": "string",
            "nullable": true,
            "description": "Variant identifier (consumer interprets meaning)"
          }
        }
      },
      "AssetRequirementInfo": {
        "type": "object",
        "description": "Information about a required asset",
        "additionalProperties": false,
        "required": [
          "type",
          "code",
          "amount"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Asset type (currency, item, item_stack)"
          },
          "code": {
            "type": "string",
            "description": "Currency code or item template code"
          },
          "amount": {
            "type": "number",
            "description": "Amount or quantity required"
          }
        }
      },
      "AssetSearchRequest": {
        "description": "Search criteria for filtering assets with pagination",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "assetType",
          "realm"
        ],
        "properties": {
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by tags (assets must have all specified tags) (null to skip tag filtering)"
          },
          "assetType": {
            "$ref": "#/components/schemas/AssetType",
            "description": "Filter by asset type"
          },
          "realm": {
            "$ref": "#/components/schemas/GameRealm",
            "description": "Filter by game realm"
          },
          "contentType": {
            "type": "string",
            "nullable": true,
            "description": "MIME content type filter (null to skip content type filtering)"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Maximum number of results to return"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Number of results to skip for pagination"
          }
        }
      },
      "AssetSearchResult": {
        "description": "Paginated results from an asset search query",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "assets",
          "total",
          "limit",
          "offset"
        ],
        "properties": {
          "assets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetMetadata"
            },
            "description": "List of matching assets"
          },
          "total": {
            "type": "integer",
            "description": "Total number of matching assets"
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of results returned per page"
          },
          "offset": {
            "type": "integer",
            "description": "Number of results skipped"
          }
        }
      },
      "AssetSlot": {
        "type": "object",
        "description": "Defines acceptable asset types for procedural swapping at this node.\nUsed by procedural generation systems to substitute assets while\nmaintaining scene coherence.\n",
        "required": [
          "slotType"
        ],
        "properties": {
          "slotType": {
            "type": "string",
            "description": "Category of acceptable assets.\nExamples: chair, table, wall_art, floor_lamp\n"
          },
          "acceptsTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tags that acceptable assets must have.\nUsed for filtering when selecting random variations.\n"
          },
          "defaultAsset": {
            "$ref": "#/components/schemas/AssetReference",
            "nullable": true,
            "description": "Default asset if no specific asset is bound"
          },
          "variations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReference"
            },
            "description": "Pre-approved asset variations for random selection.\nProcedural systems pick from this list rather than searching all assets.\n"
          }
        }
      },
      "AssetType": {
        "type": "string",
        "enum": [
          "texture",
          "model",
          "audio",
          "behavior",
          "bundle",
          "prefab",
          "other"
        ],
        "description": "Type classification for assets"
      },
      "AssetUsageInfo": {
        "type": "object",
        "description": "Information about asset usage",
        "required": [
          "sceneId",
          "sceneName",
          "nodeId",
          "nodeRefId"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene using the asset"
          },
          "sceneName": {
            "type": "string",
            "description": "Scene name"
          },
          "nodeId": {
            "type": "string",
            "format": "uuid",
            "description": "Node using the asset"
          },
          "nodeRefId": {
            "type": "string",
            "description": "refId of the node"
          },
          "nodeName": {
            "type": "string",
            "description": "Node name"
          },
          "nodeType": {
            "$ref": "#/components/schemas/NodeType",
            "description": "Type of the node"
          }
        }
      },
      "AssetVersion": {
        "description": "Metadata for a specific version of an asset",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "versionId",
          "createdAt",
          "size",
          "isArchived"
        ],
        "properties": {
          "versionId": {
            "type": "string",
            "description": "Unique version identifier"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when this version was created"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "File size in bytes for this version"
          },
          "isArchived": {
            "type": "boolean",
            "description": "Whether this version is in cold storage"
          }
        }
      },
      "AssetVersionList": {
        "description": "Paginated list of asset versions",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "assetId",
          "versions",
          "total",
          "limit",
          "offset"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Asset identifier"
          },
          "versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetVersion"
            },
            "description": "List of asset versions"
          },
          "total": {
            "type": "integer",
            "description": "Total number of versions available"
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of versions returned per page"
          },
          "offset": {
            "type": "integer",
            "description": "Number of versions skipped"
          }
        }
      },
      "AssetWithDownloadUrl": {
        "description": "Asset metadata with optional pre-signed download URL",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "assetId",
          "versionId",
          "size",
          "contentHash",
          "contentType",
          "metadata"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Unique asset identifier"
          },
          "versionId": {
            "type": "string",
            "description": "Version identifier for this specific asset version"
          },
          "downloadUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "Pre-signed download URL (only populated when requested)"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the download URL expires (only populated when requested)"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "File size in bytes"
          },
          "contentHash": {
            "type": "string",
            "description": "SHA256 hash of file contents"
          },
          "contentType": {
            "type": "string",
            "description": "MIME content type"
          },
          "metadata": {
            "$ref": "#/components/schemas/AssetMetadata",
            "description": "Complete asset metadata"
          }
        }
      },
      "AttachmentPoint": {
        "type": "object",
        "description": "A predefined location where child objects can be attached.\nUsed for decorating furniture, walls, and other objects with accessories.\nExample: A wall may have attachment points for paintings, shelves, or light fixtures.\n",
        "required": [
          "name",
          "localTransform"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Unique name for this attachment point within the node.\nExamples: wall_hook_left, shelf_1, lamp_socket\n"
          },
          "localTransform": {
            "$ref": "#/components/schemas/Transform",
            "description": "Position and orientation relative to the owning node"
          },
          "acceptsTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tags of assets that can attach here.\nExamples: wall_decoration, picture_frame, plant\n"
          },
          "defaultAsset": {
            "$ref": "#/components/schemas/AssetReference",
            "nullable": true,
            "description": "Default asset to display if no specific attachment is specified"
          },
          "attachedNodeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of the node currently attached at this point (runtime state)"
          }
        }
      },
      "AuthMethodInfo": {
        "type": "object",
        "description": "Information about a linked authentication method",
        "additionalProperties": false,
        "required": [
          "provider",
          "linkedAt"
        ],
        "properties": {
          "methodId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Unique identifier for the authentication method"
          },
          "provider": {
            "$ref": "#/components/schemas/AuthProvider",
            "description": "Authentication provider type"
          },
          "externalId": {
            "type": "string",
            "nullable": true,
            "description": "External user ID from the authentication provider"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Display name from the authentication provider"
          },
          "linkedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the authentication method was linked"
          }
        }
      },
      "AuthProvider": {
        "type": "string",
        "description": "All authentication provider types including email",
        "enum": [
          "email",
          "google",
          "discord",
          "twitch",
          "steam"
        ]
      },
      "AuthResponse": {
        "description": "Successful authentication response containing tokens and session information",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "accountId",
          "accessToken",
          "refreshToken",
          "expiresIn",
          "connectUrl"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the authenticated account"
          },
          "accessToken": {
            "type": "string",
            "description": "JWT access token for API authentication"
          },
          "refreshToken": {
            "type": "string",
            "description": "Token used to obtain new access tokens when the current one expires"
          },
          "expiresIn": {
            "type": "integer",
            "description": "Seconds until access token expires"
          },
          "connectUrl": {
            "type": "string",
            "format": "uri",
            "description": "WebSocket endpoint for Connect service"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "List of roles assigned to the authenticated user"
          }
        }
      },
      "AuthoringCheckoutRequest": {
        "type": "object",
        "description": "Request to checkout for authoring",
        "required": [
          "regionId",
          "kind",
          "editorId"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region to checkout"
          },
          "kind": {
            "$ref": "#/components/schemas/MapKind",
            "description": "Map kind to checkout"
          },
          "editorId": {
            "type": "string",
            "description": "Identifier for the editor/user"
          }
        }
      },
      "AuthoringCheckoutResponse": {
        "type": "object",
        "description": "Checkout response",
        "properties": {
          "authorityToken": {
            "type": "string",
            "description": "Token for publishing changes (if successful)",
            "nullable": true
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the checkout expires",
            "nullable": true
          },
          "lockedBy": {
            "type": "string",
            "description": "Who has the lock (if checkout failed)",
            "nullable": true
          },
          "lockedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the lock was acquired (if checkout failed)",
            "nullable": true
          }
        }
      },
      "AuthoringCommitRequest": {
        "type": "object",
        "description": "Request to commit authoring changes",
        "required": [
          "regionId",
          "kind",
          "authorityToken"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region being edited"
          },
          "kind": {
            "$ref": "#/components/schemas/MapKind",
            "description": "Map kind being edited"
          },
          "authorityToken": {
            "type": "string",
            "description": "Checkout authority token"
          },
          "commitMessage": {
            "type": "string",
            "description": "Optional commit message for history",
            "nullable": true
          }
        }
      },
      "AuthoringCommitResponse": {
        "type": "object",
        "description": "Commit response",
        "properties": {
          "version": {
            "type": "integer",
            "format": "int64",
            "description": "Committed version number",
            "nullable": true
          }
        }
      },
      "AuthoringReleaseRequest": {
        "type": "object",
        "description": "Request to release authoring checkout",
        "required": [
          "regionId",
          "kind",
          "authorityToken"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region being edited"
          },
          "kind": {
            "$ref": "#/components/schemas/MapKind",
            "description": "Map kind being edited"
          },
          "authorityToken": {
            "type": "string",
            "description": "Checkout authority token"
          }
        }
      },
      "AuthoringReleaseResponse": {
        "type": "object",
        "description": "Release response",
        "properties": {
          "released": {
            "type": "boolean",
            "description": "Whether checkout was released"
          }
        }
      },
      "AutoSpawnConfig": {
        "type": "object",
        "additionalProperties": false,
        "description": "Configuration for instantiate-on-access behavior",
        "properties": {
          "enabled": {
            "type": "boolean",
            "default": false,
            "description": "If true, accessing a non-existent actor creates it"
          },
          "idPattern": {
            "type": "string",
            "nullable": true,
            "description": "Regex pattern for actor IDs that trigger auto-spawn.\nExamples: \"npc-.*\" matches \"npc-grok\", \"npc-merchant-123\"\n"
          },
          "maxInstances": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum auto-spawned instances (0 = unlimited)"
          },
          "characterIdCaptureGroup": {
            "type": "integer",
            "minimum": 1,
            "nullable": true,
            "description": "1-based regex capture group index for extracting CharacterId from actor ID.\nExample: With idPattern \"npc-brain-([a-f0-9-]+)\" and characterIdCaptureGroup: 1,\nactor ID \"npc-brain-abc-123-def\" extracts \"abc-123-def\" as CharacterId (parsed as GUID).\n"
          }
        }
      },
      "AutogainInfo": {
        "type": "object",
        "description": "Autogain status for a balance",
        "additionalProperties": false,
        "required": [
          "lastCalculatedAt",
          "nextGainAt",
          "nextGainAmount",
          "mode"
        ],
        "properties": {
          "lastCalculatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When autogain was last calculated"
          },
          "nextGainAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the next autogain will apply"
          },
          "nextGainAmount": {
            "type": "number",
            "format": "double",
            "description": "Estimated next gain amount"
          },
          "mode": {
            "$ref": "#/components/schemas/AutogainMode",
            "description": "Current autogain mode"
          }
        }
      },
      "AutogainMode": {
        "type": "string",
        "description": "How autogain (energy/interest) is calculated",
        "enum": [
          "simple",
          "compound"
        ]
      },
      "BackstoryElement": {
        "type": "object",
        "description": "A machine-readable backstory element for behavior system consumption",
        "additionalProperties": false,
        "required": [
          "elementType",
          "key",
          "value"
        ],
        "properties": {
          "elementType": {
            "$ref": "#/components/schemas/BackstoryElementType",
            "description": "Category of this backstory element"
          },
          "key": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Machine-readable key (e.g., \"homeland\", \"trained_by\", \"past_job\").\nUsed by behavior system to query specific aspects.\n"
          },
          "value": {
            "type": "string",
            "minLength": 1,
            "maxLength": 500,
            "description": "Machine-readable value (e.g., \"northlands\", \"knights_guild\", \"blacksmith\").\nReferenced in behavior rules.\n"
          },
          "strength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.5,
            "description": "How strongly this element affects behavior (0.0 to 1.0).\nHigher strength = greater influence on decisions.\n"
          },
          "relatedEntityId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional related entity (location, organization, character)"
          },
          "relatedEntityType": {
            "type": "string",
            "nullable": true,
            "description": "Type of the related entity (if any)"
          }
        }
      },
      "BackstoryElementSnapshot": {
        "description": "Single backstory element",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "elementType",
          "key",
          "value",
          "strength"
        ],
        "properties": {
          "elementType": {
            "type": "string",
            "description": "Type of backstory element (ORIGIN, TRAUMA, GOAL, etc.)"
          },
          "key": {
            "type": "string",
            "description": "Machine-readable key (homeland, past_job, etc.)"
          },
          "value": {
            "type": "string",
            "description": "Machine-readable value (northlands, blacksmith, etc.)"
          },
          "strength": {
            "type": "number",
            "format": "float",
            "description": "How strongly this affects behavior (0.0 to 1.0)"
          }
        }
      },
      "BackstoryElementType": {
        "type": "string",
        "description": "Types of backstory elements. Each type represents a different aspect\nof the character's background that influences behavior.\n",
        "enum": [
          "ORIGIN",
          "OCCUPATION",
          "TRAINING",
          "TRAUMA",
          "ACHIEVEMENT",
          "SECRET",
          "GOAL",
          "FEAR",
          "BELIEF"
        ]
      },
      "BackstoryResponse": {
        "type": "object",
        "description": "Complete backstory data for a character",
        "additionalProperties": false,
        "required": [
          "characterId",
          "elements"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character this backstory belongs to"
          },
          "elements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BackstoryElement"
            },
            "description": "All backstory elements for this character"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this backstory was first created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this backstory was last modified"
          }
        }
      },
      "BackstorySnapshot": {
        "description": "Snapshot of backstory for enriched response",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "elements"
        ],
        "properties": {
          "elements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BackstoryElementSnapshot"
            },
            "description": "List of backstory elements"
          }
        }
      },
      "BalanceQuery": {
        "type": "object",
        "description": "A single balance query",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency definition ID"
          }
        }
      },
      "BalanceSummary": {
        "type": "object",
        "description": "Summary of a balance in a wallet",
        "additionalProperties": false,
        "required": [
          "currencyDefinitionId",
          "currencyCode",
          "amount",
          "lockedAmount",
          "effectiveAmount"
        ],
        "properties": {
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency definition ID"
          },
          "currencyCode": {
            "type": "string",
            "description": "Currency code for convenience"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Total balance amount"
          },
          "lockedAmount": {
            "type": "number",
            "format": "double",
            "description": "Amount reserved by authorization holds"
          },
          "effectiveAmount": {
            "type": "number",
            "format": "double",
            "description": "Available balance (amount - lockedAmount)"
          }
        }
      },
      "BanParticipantRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to ban a participant from a room",
        "required": [
          "roomId",
          "targetSessionId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID"
          },
          "targetSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Session ID of participant to ban"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for the ban"
          },
          "durationMinutes": {
            "type": "integer",
            "nullable": true,
            "description": "Ban duration in minutes (null for permanent)"
          }
        }
      },
      "BatchBalanceResult": {
        "type": "object",
        "description": "Result of a single balance query in a batch",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "lockedAmount",
          "effectiveAmount"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency definition ID"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Total balance"
          },
          "lockedAmount": {
            "type": "number",
            "format": "double",
            "description": "Amount in holds"
          },
          "effectiveAmount": {
            "type": "number",
            "format": "double",
            "description": "Available balance"
          }
        }
      },
      "BatchCreditOperation": {
        "type": "object",
        "description": "A single credit operation in a batch",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "transactionType"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Target wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to credit"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to credit"
          },
          "transactionType": {
            "$ref": "#/components/schemas/TransactionType",
            "description": "Faucet transaction type"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "Reference type"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference ID"
          }
        }
      },
      "BatchCreditRequest": {
        "type": "object",
        "description": "Request to credit multiple wallets",
        "additionalProperties": false,
        "required": [
          "operations",
          "idempotencyKey"
        ],
        "properties": {
          "operations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BatchCreditOperation"
            },
            "minItems": 1,
            "maxItems": 100,
            "description": "Credit operations to execute"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Unique key covering the entire batch"
          }
        }
      },
      "BatchCreditResponse": {
        "type": "object",
        "description": "Results of batch credit operations",
        "additionalProperties": false,
        "required": [
          "results"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BatchCreditResult"
            },
            "description": "Results for each operation"
          }
        }
      },
      "BatchCreditResult": {
        "type": "object",
        "description": "Result of a single credit in a batch",
        "additionalProperties": false,
        "required": [
          "index",
          "success"
        ],
        "properties": {
          "index": {
            "type": "integer",
            "description": "Index in the operations array"
          },
          "success": {
            "type": "boolean",
            "description": "Whether the operation succeeded"
          },
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "nullable": true,
            "description": "Transaction record if successful"
          },
          "error": {
            "type": "string",
            "nullable": true,
            "description": "Error code if failed"
          }
        }
      },
      "BatchGetBalancesRequest": {
        "type": "object",
        "description": "Request to get multiple balances",
        "additionalProperties": false,
        "required": [
          "queries"
        ],
        "properties": {
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BalanceQuery"
            },
            "minItems": 1,
            "maxItems": 100,
            "description": "Balance queries to execute"
          }
        }
      },
      "BatchGetBalancesResponse": {
        "type": "object",
        "description": "Results of batch balance queries",
        "additionalProperties": false,
        "required": [
          "balances"
        ],
        "properties": {
          "balances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BatchBalanceResult"
            },
            "description": "Balance results (same order as queries)"
          }
        }
      },
      "BatchGetItemInstancesRequest": {
        "type": "object",
        "description": "Request to get multiple item instances",
        "additionalProperties": false,
        "required": [
          "instanceIds"
        ],
        "properties": {
          "instanceIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "maxItems": 100,
            "description": "Instance IDs to retrieve"
          }
        }
      },
      "BatchGetItemInstancesResponse": {
        "type": "object",
        "description": "Multiple item instances",
        "additionalProperties": false,
        "required": [
          "items",
          "notFound"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ItemInstanceResponse"
            },
            "description": "Found items"
          },
          "notFound": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Instance IDs that were not found"
          }
        }
      },
      "BatchMessageEntry": {
        "type": "object",
        "additionalProperties": false,
        "description": "Individual message entry in a batch send operation",
        "required": [
          "content"
        ],
        "properties": {
          "content": {
            "$ref": "#/components/schemas/SendMessageContent",
            "description": "Message content matching the room format"
          },
          "senderType": {
            "type": "string",
            "nullable": true,
            "description": "Opaque sender type"
          },
          "senderId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Sender entity ID"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Sender display name"
          }
        }
      },
      "BehaviorTreeData": {
        "type": "object",
        "additionalProperties": false,
        "description": "Compiled behavior tree data with bytecode or download reference",
        "properties": {
          "bytecode": {
            "type": "string",
            "nullable": true,
            "description": "Base64-encoded compiled bytecode for the behavior tree"
          },
          "bytecodeSize": {
            "type": "integer",
            "description": "Size of the bytecode in bytes"
          },
          "downloadUrl": {
            "type": "string",
            "nullable": true,
            "description": "URL to download the compiled behavior asset"
          }
        }
      },
      "BindItemInstanceRequest": {
        "type": "object",
        "description": "Request to bind an item to a character",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "characterId"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Instance ID to bind"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to bind the item to"
          },
          "bindType": {
            "$ref": "#/components/schemas/SoulboundType",
            "description": "Type of binding to apply"
          }
        }
      },
      "BindRepositoryRequest": {
        "description": "Request to bind a Git repository for automatic documentation sync",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "repositoryUrl",
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "string",
            "description": "Owner of this binding. NOT a session ID.\nFor user-initiated bindings: the accountId (UUID format).\nFor service-initiated bindings: the service name (e.g., \"orchestrator\").\n"
          },
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to bind"
          },
          "repositoryUrl": {
            "type": "string",
            "description": "Git clone URL (HTTPS for public repos)"
          },
          "branch": {
            "type": "string",
            "default": "main",
            "description": "Branch to sync from"
          },
          "syncIntervalMinutes": {
            "type": "integer",
            "default": 60,
            "minimum": 5,
            "maximum": 1440,
            "description": "How often to sync (5 min to 24 hours)"
          },
          "filePatterns": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "default": [
              "**/*.md"
            ],
            "description": "Glob patterns for files to include (defaults to all markdown files if not provided)"
          },
          "excludePatterns": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "default": [
              ".git/**",
              ".obsidian/**",
              "node_modules/**"
            ],
            "description": "Glob patterns for files to exclude (defaults to common non-content directories if not provided)"
          },
          "categoryMapping": {
            "type": "object",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            },
            "description": "Map directory prefixes to categories (empty mapping if not provided)"
          },
          "defaultCategory": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "Default category for documents without mapping"
          },
          "archiveEnabled": {
            "type": "boolean",
            "default": false,
            "description": "Enable archive functionality"
          },
          "archiveOnSync": {
            "type": "boolean",
            "default": false,
            "description": "Create archive after each sync"
          }
        }
      },
      "BindRepositoryResponse": {
        "description": "Response confirming repository binding creation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bindingId",
          "namespace",
          "status"
        ],
        "properties": {
          "bindingId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the repository binding"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace the repository is bound to"
          },
          "repositoryUrl": {
            "type": "string",
            "description": "URL of the bound repository"
          },
          "branch": {
            "type": "string",
            "description": "Branch being synced"
          },
          "status": {
            "$ref": "#/components/schemas/BindingStatus",
            "description": "Current status of the binding"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the binding was created"
          }
        }
      },
      "BindingStatus": {
        "type": "string",
        "enum": [
          "pending",
          "syncing",
          "synced",
          "error",
          "disabled"
        ],
        "description": "Status of a repository binding"
      },
      "BlessingResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Full blessing record response",
        "required": [
          "blessingId",
          "deityId",
          "entityId",
          "entityType",
          "tier",
          "itemTemplateCode",
          "itemInstanceId",
          "reason",
          "grantedAt",
          "status"
        ],
        "properties": {
          "blessingId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique blessing identifier"
          },
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity that granted this blessing"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity that received this blessing"
          },
          "entityType": {
            "type": "string",
            "description": "Type of entity that received this blessing"
          },
          "tier": {
            "$ref": "#/components/schemas/BlessingTier",
            "description": "Tier of the blessing"
          },
          "itemTemplateCode": {
            "type": "string",
            "description": "Item template code for the blessing effect"
          },
          "itemInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item or collection entry instance backing this blessing"
          },
          "reason": {
            "type": "string",
            "description": "Why the blessing was granted"
          },
          "grantedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the blessing was granted"
          },
          "revokedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the blessing was revoked (null if still active)"
          },
          "status": {
            "$ref": "#/components/schemas/BlessingStatus",
            "description": "Current status of the blessing"
          }
        }
      },
      "BlessingStatus": {
        "type": "string",
        "description": "Current status of a granted blessing",
        "enum": [
          "active",
          "revoked"
        ]
      },
      "BlessingSummary": {
        "type": "object",
        "additionalProperties": false,
        "description": "Compact blessing record for list responses",
        "required": [
          "blessingId",
          "deityId",
          "entityId",
          "entityType",
          "tier",
          "itemInstanceId",
          "grantedAt",
          "status"
        ],
        "properties": {
          "blessingId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this blessing"
          },
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity that granted this blessing"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity that received this blessing"
          },
          "entityType": {
            "type": "string",
            "description": "Type of entity that received this blessing"
          },
          "tier": {
            "$ref": "#/components/schemas/BlessingTier",
            "description": "Tier of the blessing"
          },
          "itemInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item or collection entry instance backing this blessing"
          },
          "grantedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the blessing was granted"
          },
          "status": {
            "$ref": "#/components/schemas/BlessingStatus",
            "description": "Current status of the blessing"
          }
        }
      },
      "BlessingTier": {
        "type": "string",
        "description": "Tier of a blessing determining its power, cost, and storage mechanism",
        "enum": [
          "minor",
          "standard",
          "greater",
          "supreme"
        ]
      },
      "BoardNodeState": {
        "type": "object",
        "description": "State of a single license node on a board, including unlock status",
        "additionalProperties": false,
        "required": [
          "code",
          "position",
          "lpCost",
          "status",
          "itemTemplateId"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Unique license code within this board template"
          },
          "position": {
            "$ref": "#/components/schemas/GridPosition",
            "description": "Grid position of this license node"
          },
          "lpCost": {
            "type": "integer",
            "description": "License Point cost to unlock this node"
          },
          "status": {
            "$ref": "#/components/schemas/LicenseStatus",
            "description": "Current unlock status of this node"
          },
          "itemTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Item template that is created when this license is unlocked"
          },
          "itemInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Item instance ID if this license has been unlocked"
          },
          "prerequisites": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "License codes that must be unlocked before this one (non-adjacent)"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description of what this license grants"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Game-specific metadata for this license node"
          }
        }
      },
      "BoardResponse": {
        "type": "object",
        "description": "Board instance with all fields",
        "additionalProperties": false,
        "required": [
          "boardId",
          "ownerType",
          "ownerId",
          "boardTemplateId",
          "gameServiceId",
          "containerId",
          "createdAt"
        ],
        "properties": {
          "boardId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique board instance identifier"
          },
          "ownerType": {
            "type": "string",
            "description": "Type of entity that owns this board"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity that owns this board"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm context for this board. Null for realm-agnostic boards."
          },
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template this instance was created from"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this board belongs to"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Inventory container holding unlocked license items"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this board instance was created"
          }
        }
      },
      "BoardStateRequest": {
        "type": "object",
        "description": "Request to get the full board state",
        "additionalProperties": false,
        "required": [
          "boardId"
        ],
        "properties": {
          "boardId": {
            "type": "string",
            "format": "uuid",
            "description": "Board instance to get state for"
          }
        }
      },
      "BoardStateResponse": {
        "type": "object",
        "description": "Full board state with all node statuses for client UI rendering",
        "additionalProperties": false,
        "required": [
          "boardId",
          "ownerType",
          "ownerId",
          "boardTemplateId",
          "gridWidth",
          "gridHeight",
          "nodes"
        ],
        "properties": {
          "boardId": {
            "type": "string",
            "format": "uuid",
            "description": "Board instance identifier"
          },
          "ownerType": {
            "type": "string",
            "description": "Type of entity that owns this board (e.g., character, account, guild)"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity that owns this board"
          },
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template this instance was created from"
          },
          "gridWidth": {
            "type": "integer",
            "description": "Width of the board grid (columns)"
          },
          "gridHeight": {
            "type": "integer",
            "description": "Height of the board grid (rows)"
          },
          "nodes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BoardNodeState"
            },
            "description": "All license nodes with their current status"
          }
        }
      },
      "BoardTemplateResponse": {
        "type": "object",
        "description": "Board template with all fields",
        "additionalProperties": false,
        "required": [
          "boardTemplateId",
          "gameServiceId",
          "name",
          "gridWidth",
          "gridHeight",
          "startingNodes",
          "boardContractTemplateId",
          "adjacencyMode",
          "allowedOwnerTypes",
          "isActive",
          "createdAt"
        ],
        "properties": {
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique board template identifier"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this template belongs to"
          },
          "name": {
            "type": "string",
            "description": "Display name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description"
          },
          "gridWidth": {
            "type": "integer",
            "description": "Width of the board grid (columns)"
          },
          "gridHeight": {
            "type": "integer",
            "description": "Height of the board grid (rows)"
          },
          "startingNodes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GridPosition"
            },
            "description": "Grid positions where unlocking can begin without adjacency"
          },
          "boardContractTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract template that controls unlock behavior"
          },
          "adjacencyMode": {
            "$ref": "#/components/schemas/AdjacencyMode",
            "description": "Grid traversal mode for this template"
          },
          "allowedOwnerTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Owner types allowed to create boards from this template"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether the template is active (can create new board instances)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the template was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the template was last updated"
          }
        }
      },
      "BondParticipant": {
        "type": "object",
        "description": "A participant in a seed bond.",
        "required": [
          "seedId",
          "joinedAt"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "Participant seed ID."
          },
          "joinedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this seed joined the bond."
          },
          "role": {
            "type": "string",
            "nullable": true,
            "description": "Optional role within the bond."
          }
        }
      },
      "BondPartnersResponse": {
        "type": "object",
        "description": "Partner seed summaries for a bond.",
        "required": [
          "bondId",
          "partners"
        ],
        "properties": {
          "bondId": {
            "type": "string",
            "format": "uuid",
            "description": "The bond."
          },
          "partners": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartnerSummary"
            },
            "description": "Partner seed summaries."
          }
        }
      },
      "BondResponse": {
        "type": "object",
        "description": "Full bond record response.",
        "required": [
          "bondId",
          "seedTypeCode",
          "participants",
          "createdAt",
          "status",
          "bondStrength",
          "sharedGrowth"
        ],
        "properties": {
          "bondId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique bond identifier."
          },
          "seedTypeCode": {
            "type": "string",
            "description": "Seed type this bond connects."
          },
          "participants": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BondParticipant"
            },
            "description": "Seeds participating in this bond."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the bond was formed."
          },
          "status": {
            "$ref": "#/components/schemas/BondStatus",
            "description": "Current bond lifecycle status."
          },
          "bondStrength": {
            "type": "number",
            "format": "float",
            "description": "Grows with shared growth. Consumer-interpreted."
          },
          "sharedGrowth": {
            "type": "number",
            "format": "float",
            "description": "Total accumulated shared growth."
          }
        }
      },
      "BondStatus": {
        "type": "string",
        "description": "Lifecycle status of a seed bond.",
        "enum": [
          "PendingConfirmation",
          "Active"
        ]
      },
      "BondedPlayerGardenState": {
        "type": "object",
        "description": "Per-player garden state within a shared bond garden",
        "required": [
          "seedId",
          "accountId",
          "position"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "Seed ID of the bonded player"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the bonded player"
          },
          "position": {
            "$ref": "#/components/schemas/Vec3",
            "description": "Player position in shared garden space"
          }
        }
      },
      "BoundingBox3D": {
        "type": "object",
        "additionalProperties": false,
        "description": "Axis-aligned bounding box in world coordinates (meters, Y-up, right-handed)",
        "required": [
          "minX",
          "minY",
          "minZ",
          "maxX",
          "maxY",
          "maxZ"
        ],
        "properties": {
          "minX": {
            "type": "number",
            "format": "float",
            "description": "Minimum X bound in world space"
          },
          "minY": {
            "type": "number",
            "format": "float",
            "description": "Minimum Y bound in world space"
          },
          "minZ": {
            "type": "number",
            "format": "float",
            "description": "Minimum Z bound in world space"
          },
          "maxX": {
            "type": "number",
            "format": "float",
            "description": "Maximum X bound in world space"
          },
          "maxY": {
            "type": "number",
            "format": "float",
            "description": "Maximum Y bound in world space"
          },
          "maxZ": {
            "type": "number",
            "format": "float",
            "description": "Maximum Z bound in world space"
          }
        }
      },
      "Bounds": {
        "type": "object",
        "description": "An axis-aligned bounding box in 3D space",
        "required": [
          "min",
          "max"
        ],
        "properties": {
          "min": {
            "$ref": "#/components/schemas/Position3D",
            "description": "Minimum corner (lowest x, y, z values)"
          },
          "max": {
            "$ref": "#/components/schemas/Position3D",
            "description": "Maximum corner (highest x, y, z values)"
          }
        }
      },
      "BoundsPrecision": {
        "type": "string",
        "description": "Precision level of spatial bounds for a location",
        "enum": [
          "exact",
          "approximate",
          "none"
        ]
      },
      "BreachResponse": {
        "type": "object",
        "description": "Breach record details",
        "additionalProperties": false,
        "required": [
          "breachId",
          "contractId",
          "breachingEntityId",
          "breachingEntityType",
          "breachType",
          "status",
          "detectedAt"
        ],
        "properties": {
          "breachId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique breach identifier"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract that was breached"
          },
          "breachingEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity that breached"
          },
          "breachingEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of breaching entity"
          },
          "breachType": {
            "$ref": "#/components/schemas/BreachType",
            "description": "Type of breach"
          },
          "breachedTermOrMilestone": {
            "type": "string",
            "nullable": true,
            "description": "What was breached"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Breach description"
          },
          "status": {
            "$ref": "#/components/schemas/BreachStatus",
            "description": "Current status"
          },
          "detectedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When breach was detected"
          },
          "cureDeadline": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Deadline to cure breach"
          },
          "curedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When breach was cured"
          },
          "consequencesAppliedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When consequences were applied"
          }
        }
      },
      "BreachStatus": {
        "type": "string",
        "description": "Current status of a breach record",
        "enum": [
          "detected",
          "cure_period",
          "cured",
          "consequences_applied",
          "disputed",
          "forgiven"
        ]
      },
      "BreachSummary": {
        "type": "object",
        "description": "Brief breach information",
        "additionalProperties": false,
        "required": [
          "breachId",
          "breachType",
          "status"
        ],
        "properties": {
          "breachId": {
            "type": "string",
            "format": "uuid",
            "description": "Breach ID"
          },
          "breachType": {
            "$ref": "#/components/schemas/BreachType",
            "description": "Type of breach"
          },
          "status": {
            "$ref": "#/components/schemas/BreachStatus",
            "description": "Current status"
          }
        }
      },
      "BreachType": {
        "type": "string",
        "description": "Type of contract breach",
        "enum": [
          "term_violation",
          "milestone_missed",
          "milestone_deadline",
          "unauthorized_action",
          "non_payment"
        ]
      },
      "BroadcastConsentRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to initiate broadcast consent for a voice room",
        "required": [
          "roomId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Voice room to broadcast"
          },
          "requestingSessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Session ID of the participant requesting broadcast (server can derive from auth context)"
          }
        }
      },
      "BroadcastConsentResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response to a broadcast consent request from a participant",
        "required": [
          "roomId",
          "sessionId",
          "consented"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Voice room ID"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Session ID of the responding participant"
          },
          "consented": {
            "type": "boolean",
            "description": "True if participant consents to broadcasting"
          }
        }
      },
      "BroadcastConsentState": {
        "type": "string",
        "enum": [
          "Inactive",
          "Pending",
          "Approved"
        ],
        "description": "Current state of broadcast consent for a room. Inactive: No broadcast request pending. Pending: Consent request sent, awaiting all responses. Approved: All participants consented. Voice treats this as terminal.\n"
      },
      "BroadcastConsentStatus": {
        "type": "object",
        "additionalProperties": false,
        "description": "Current broadcast consent status for a voice room",
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Voice room ID"
          },
          "state": {
            "$ref": "#/components/schemas/BroadcastConsentState",
            "description": "Current broadcast consent state"
          },
          "requestedBySessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Who initiated the broadcast request (null if inactive)"
          },
          "consentedSessionIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Sessions that have consented so far"
          },
          "pendingSessionIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Sessions that haven't responded yet"
          },
          "rtpAudioEndpoint": {
            "type": "string",
            "nullable": true,
            "description": "RTP audio endpoint for the room's mixed audio output. Only populated when room is in scaled tier. Provided to lib-stream so it can connect its RTMP output to the voice room's audio.\n"
          }
        }
      },
      "BroadcastStatusRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get broadcast consent status for a voice room",
        "required": [
          "roomId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Voice room ID"
          }
        }
      },
      "BulkGetAssetsRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to retrieve metadata for multiple assets",
        "required": [
          "assetIds"
        ],
        "properties": {
          "assetIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Asset IDs to retrieve (max 100)"
          },
          "includeDownloadUrls": {
            "type": "boolean",
            "default": false,
            "description": "Whether to generate pre-signed download URLs"
          }
        }
      },
      "BulkGetAssetsResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Batch asset metadata response",
        "required": [
          "assets",
          "notFound"
        ],
        "properties": {
          "assets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetWithDownloadUrl"
            },
            "description": "Found assets with metadata"
          },
          "notFound": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Asset IDs that weren't found"
          }
        }
      },
      "BundleFormat": {
        "type": "string",
        "enum": [
          "bannou",
          "zip"
        ],
        "description": "Bundle file format"
      },
      "BundleInfo": {
        "type": "object",
        "additionalProperties": false,
        "description": "Complete metadata for an asset bundle (API response model)",
        "required": [
          "bundleId",
          "bundleType",
          "version",
          "metadataVersion",
          "realm",
          "status",
          "assetCount",
          "createdAt"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier (e.g., \"synty/polygon-adventure\", \"my-bundle-v1\")"
          },
          "bundleType": {
            "$ref": "#/components/schemas/BundleType",
            "description": "Whether source or metabundle"
          },
          "version": {
            "type": "string",
            "description": "Bundle content version string"
          },
          "metadataVersion": {
            "type": "integer",
            "description": "Metadata version number (increments on metadata changes)"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable bundle name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Bundle description"
          },
          "owner": {
            "type": "string",
            "nullable": true,
            "description": "Owner account ID or service name (null for system-owned bundles)"
          },
          "realm": {
            "$ref": "#/components/schemas/GameRealm",
            "description": "Game realm this bundle belongs to"
          },
          "tags": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Key-value tags for categorization and filtering"
          },
          "status": {
            "$ref": "#/components/schemas/BundleLifecycle",
            "description": "Bundle lifecycle status"
          },
          "assetCount": {
            "type": "integer",
            "description": "Number of assets in the bundle"
          },
          "sizeBytes": {
            "type": "integer",
            "format": "int64",
            "nullable": true,
            "description": "Bundle file size in bytes (null if not yet calculated)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the bundle was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the bundle metadata was last updated"
          },
          "deletedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the bundle was soft-deleted (null if active)"
          }
        }
      },
      "BundleLifecycle": {
        "type": "string",
        "enum": [
          "active",
          "deleted",
          "processing"
        ],
        "description": "Bundle lifecycle status:\n- active: Bundle is available for use\n- deleted: Bundle has been soft-deleted (within retention period)\n- processing: Bundle is being processed (metabundle creation)\n"
      },
      "BundleManifestPreview": {
        "type": "object",
        "additionalProperties": false,
        "description": "Preview of bundle manifest for validation",
        "required": [
          "bundleId",
          "version",
          "assetCount"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier from the manifest"
          },
          "version": {
            "type": "string",
            "description": "Bundle version from the manifest"
          },
          "assetCount": {
            "type": "integer",
            "description": "Number of assets declared in the manifest"
          }
        }
      },
      "BundleSummary": {
        "type": "object",
        "additionalProperties": false,
        "description": "Summary information about a bundle",
        "required": [
          "bundleId",
          "bundleType",
          "version",
          "assetCount",
          "realm"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier"
          },
          "bundleType": {
            "$ref": "#/components/schemas/BundleType",
            "description": "Source or metabundle"
          },
          "version": {
            "type": "string",
            "description": "Bundle version"
          },
          "assetCount": {
            "type": "integer",
            "description": "Number of assets in bundle"
          },
          "sizeBytes": {
            "type": "integer",
            "format": "int64",
            "nullable": true,
            "description": "Bundle file size"
          },
          "realm": {
            "$ref": "#/components/schemas/GameRealm",
            "description": "Game realm"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the bundle was created"
          }
        }
      },
      "BundleType": {
        "type": "string",
        "enum": [
          "source",
          "metabundle"
        ],
        "description": "Bundle category:\n- source: Original bundle (uploaded or server-created from assets)\n- metabundle: Composed from other bundles server-side\n"
      },
      "BundleUploadRequest": {
        "description": "Request to upload a pre-built asset bundle file",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "filename",
          "size",
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "string",
            "description": "Owner of this bundle upload. NOT a session ID.\nFor user-initiated uploads: the accountId (UUID format).\nFor service-initiated uploads: the service name (e.g., \"orchestrator\").\n"
          },
          "filename": {
            "type": "string",
            "description": "Must end with .bannou or .zip"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "Bundle file size in bytes"
          },
          "manifestPreview": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BundleManifestPreview"
              }
            ],
            "nullable": true,
            "description": "Optional preview of bundle manifest for validation"
          }
        }
      },
      "BundleVersionRecord": {
        "type": "object",
        "additionalProperties": false,
        "description": "A single version record in bundle history",
        "required": [
          "version",
          "createdAt",
          "createdBy",
          "changes"
        ],
        "properties": {
          "version": {
            "type": "integer",
            "description": "Version number"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this version was created"
          },
          "createdBy": {
            "type": "string",
            "description": "Account ID that made the change"
          },
          "changes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of changes in this version"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Reason provided for the change"
          },
          "snapshot": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BundleInfo"
              }
            ],
            "nullable": true,
            "description": "Full metadata snapshot at this version (only for current version)"
          }
        }
      },
      "BundleWithDownloadUrl": {
        "description": "Bundle metadata combined with a pre-signed download URL",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bundleId",
          "version",
          "downloadUrl",
          "format",
          "expiresAt",
          "size",
          "assetCount",
          "fromCache"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier (e.g., \"synty/polygon-adventure\", \"my-bundle-v1\")"
          },
          "version": {
            "type": "string",
            "description": "Bundle version string"
          },
          "downloadUrl": {
            "type": "string",
            "format": "uri",
            "description": "Pre-signed URL for downloading the bundle"
          },
          "format": {
            "$ref": "#/components/schemas/BundleFormat",
            "description": "Format of the downloadable bundle"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the download URL expires"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "Bundle file size in bytes"
          },
          "assetCount": {
            "type": "integer",
            "description": "Number of assets contained in the bundle"
          },
          "fromCache": {
            "type": "boolean",
            "description": "True if ZIP format was served from conversion cache"
          }
        }
      },
      "CachedBehaviorResponse": {
        "description": "Response containing a previously compiled behavior retrieved from cache",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "behaviorId",
          "compiledBehavior"
        ],
        "properties": {
          "behaviorId": {
            "type": "string",
            "description": "Unique identifier for the cached behavior"
          },
          "compiledBehavior": {
            "$ref": "#/components/schemas/CompiledBehavior",
            "description": "The compiled behavior data retrieved from cache"
          },
          "cacheTimestamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the behavior was cached"
          },
          "cacheHit": {
            "type": "boolean",
            "description": "Whether this was a cache hit or miss"
          }
        }
      },
      "CadenceInfo": {
        "description": "Information about a cadence",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "type",
          "position"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "authentic",
              "half",
              "plagal",
              "deceptive"
            ],
            "description": "Cadence type"
          },
          "position": {
            "type": "integer",
            "description": "Chord index where cadence ends"
          },
          "strength": {
            "type": "string",
            "enum": [
              "perfect",
              "imperfect"
            ],
            "nullable": true,
            "description": "Cadence strength"
          }
        }
      },
      "CalculateConversionRequest": {
        "type": "object",
        "description": "Request to preview a currency conversion",
        "additionalProperties": false,
        "required": [
          "fromCurrencyId",
          "toCurrencyId",
          "fromAmount"
        ],
        "properties": {
          "fromCurrencyId": {
            "type": "string",
            "format": "uuid",
            "description": "Source currency definition ID"
          },
          "toCurrencyId": {
            "type": "string",
            "format": "uuid",
            "description": "Target currency definition ID"
          },
          "fromAmount": {
            "type": "number",
            "format": "double",
            "description": "Amount to convert"
          }
        }
      },
      "CalculateConversionResponse": {
        "type": "object",
        "description": "Conversion preview result",
        "additionalProperties": false,
        "required": [
          "toAmount",
          "effectiveRate",
          "baseCurrency"
        ],
        "properties": {
          "toAmount": {
            "type": "number",
            "format": "double",
            "description": "Amount that would be received"
          },
          "effectiveRate": {
            "type": "number",
            "format": "double",
            "description": "Effective conversion rate applied"
          },
          "conversionPath": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConversionStep"
            },
            "description": "Steps in the conversion"
          },
          "baseCurrency": {
            "type": "string",
            "description": "Base currency used for conversion"
          }
        }
      },
      "CanUseBehavior": {
        "type": "string",
        "description": "Controls CanUse validation behavior.\n- disabled: Skip CanUse validation even if template is configured\n- block: CanUse failure prevents use (default)\n- warn_and_proceed: CanUse failure logs warning but proceeds with use\n",
        "enum": [
          "disabled",
          "block",
          "warn_and_proceed"
        ]
      },
      "CancelJobRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to cancel an async metabundle creation job",
        "required": [
          "jobId"
        ],
        "properties": {
          "jobId": {
            "type": "string",
            "format": "uuid",
            "description": "Job ID from the createMetabundle response"
          }
        }
      },
      "CancelJobResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of job cancellation attempt",
        "required": [
          "jobId",
          "cancelled",
          "status"
        ],
        "properties": {
          "jobId": {
            "type": "string",
            "format": "uuid",
            "description": "Job identifier"
          },
          "cancelled": {
            "type": "boolean",
            "description": "Whether the job was successfully cancelled"
          },
          "status": {
            "type": "string",
            "enum": [
              "queued",
              "processing",
              "ready",
              "failed",
              "cancelled"
            ],
            "description": "Current job status after cancellation attempt"
          },
          "message": {
            "type": "string",
            "nullable": true,
            "description": "Additional context about the cancellation result"
          }
        }
      },
      "CancelRequest": {
        "type": "object",
        "description": "Request to cancel escrow before fully funded",
        "required": [
          "escrowId",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Reason for cancellation"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "CancelResponse": {
        "type": "object",
        "description": "Response from cancelling an escrow",
        "required": [
          "escrow",
          "refunds"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Cancelled escrow agreement"
          },
          "refunds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RefundResult"
            },
            "description": "Refund results for any deposits"
          }
        }
      },
      "CancelSubscriptionRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to cancel a subscription",
        "required": [
          "subscriptionId"
        ],
        "properties": {
          "subscriptionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the subscription to cancel"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "maxLength": 500,
            "description": "Optional reason for cancellation"
          }
        }
      },
      "CapOverflowBehavior": {
        "type": "string",
        "description": "What happens when a credit would exceed the wallet cap",
        "enum": [
          "reject",
          "cap_and_lose",
          "cap_and_return"
        ]
      },
      "Capability": {
        "type": "object",
        "description": "A single capability entry in the manifest.",
        "required": [
          "capabilityCode",
          "domain",
          "fidelity",
          "unlocked"
        ],
        "properties": {
          "capabilityCode": {
            "type": "string",
            "description": "Unique capability identifier. Consumer-interpreted (e.g., UX module ID, spawning permission, faction action).\n"
          },
          "domain": {
            "type": "string",
            "description": "Growth domain this capability maps to."
          },
          "fidelity": {
            "type": "number",
            "format": "float",
            "description": "Capability fidelity from 0.0 to 1.0. Higher values mean the seed has more developed capability in this area.\n"
          },
          "unlocked": {
            "type": "boolean",
            "description": "Whether this capability is available at all."
          }
        }
      },
      "CapabilityManifestResponse": {
        "type": "object",
        "description": "Computed capability manifest for a seed.",
        "required": [
          "seedId",
          "seedTypeCode",
          "computedAt",
          "version",
          "capabilities"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed this manifest belongs to."
          },
          "seedTypeCode": {
            "type": "string",
            "description": "The seed type for consumer interpretation."
          },
          "computedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this manifest was last computed."
          },
          "version": {
            "type": "integer",
            "description": "Monotonically increasing version number."
          },
          "capabilities": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Capability"
            },
            "description": "List of capabilities with availability and fidelity."
          }
        }
      },
      "CapabilityRule": {
        "type": "object",
        "description": "Maps a growth domain to a capability with unlock threshold and fidelity formula.",
        "required": [
          "capabilityCode",
          "domain",
          "unlockThreshold",
          "fidelityFormula"
        ],
        "properties": {
          "capabilityCode": {
            "type": "string",
            "description": "Unique capability identifier (e.g., \"combat.stance\")."
          },
          "domain": {
            "type": "string",
            "description": "Which growth domain this capability maps to."
          },
          "unlockThreshold": {
            "type": "number",
            "format": "float",
            "description": "Minimum domain depth to unlock this capability."
          },
          "fidelityFormula": {
            "type": "string",
            "description": "How domain depth maps to fidelity (0.0-1.0). Values: \"linear\", \"logarithmic\", \"step\". Consumers may define additional formulas.\n"
          }
        }
      },
      "CaptureHoldRequest": {
        "type": "object",
        "description": "Request to capture (finalize) a hold",
        "additionalProperties": false,
        "required": [
          "holdId",
          "captureAmount",
          "idempotencyKey"
        ],
        "properties": {
          "holdId": {
            "type": "string",
            "format": "uuid",
            "description": "Hold ID to capture"
          },
          "captureAmount": {
            "type": "number",
            "format": "double",
            "description": "Final amount to debit (may be less than hold amount)"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Idempotency key"
          }
        }
      },
      "CaptureHoldResponse": {
        "type": "object",
        "description": "Result of hold capture",
        "additionalProperties": false,
        "required": [
          "hold",
          "transaction",
          "newBalance",
          "amountReleased"
        ],
        "properties": {
          "hold": {
            "$ref": "#/components/schemas/HoldRecord",
            "description": "Updated hold record"
          },
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Debit transaction"
          },
          "newBalance": {
            "type": "number",
            "format": "double",
            "description": "Balance after capture"
          },
          "amountReleased": {
            "type": "number",
            "format": "double",
            "description": "Difference between hold and capture (released back)"
          }
        }
      },
      "CategoryStats": {
        "type": "object",
        "description": "Completion statistics for a single category",
        "additionalProperties": false,
        "required": [
          "total",
          "unlocked",
          "percentage"
        ],
        "properties": {
          "total": {
            "type": "integer",
            "description": "Total entries in this category"
          },
          "unlocked": {
            "type": "integer",
            "description": "Unlocked entries in this category"
          },
          "percentage": {
            "type": "number",
            "format": "double",
            "description": "Completion percentage for this category"
          }
        }
      },
      "ChainScenarioRequest": {
        "type": "object",
        "description": "Request to chain from one scenario to another",
        "required": [
          "accountId",
          "currentScenarioInstanceId",
          "targetTemplateId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account chaining scenarios"
          },
          "currentScenarioInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Currently active scenario instance"
          },
          "targetTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template to chain into"
          }
        }
      },
      "CharacterArchive": {
        "description": "Compressed archive of a dead character.\nContains text summaries instead of structured data for long-term storage.\nSelf-contained with no external references (suitable for cleanup).\n",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId",
          "name",
          "realmId",
          "speciesId",
          "birthDate",
          "deathDate",
          "compressedAt"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Original character ID"
          },
          "name": {
            "type": "string",
            "description": "Character display name"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm the character belonged to"
          },
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "description": "Character's species"
          },
          "birthDate": {
            "type": "string",
            "format": "date-time",
            "description": "In-game birth date"
          },
          "deathDate": {
            "type": "string",
            "format": "date-time",
            "description": "In-game death date"
          },
          "compressedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this archive was created"
          },
          "personalitySummary": {
            "type": "string",
            "nullable": true,
            "description": "Text summary of personality traits.\nExample: \"Brave and loyal, somewhat hot-tempered with a strong sense of justice\"\n"
          },
          "keyBackstoryPoints": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Key backstory elements as text.\nExample: [\"Trained by the Knights Guild\", \"Born in the Northlands\"]\n"
          },
          "majorLifeEvents": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Significant life events as text.\nExample: [\"Fought in the Battle of Stormgate (Hero)\", \"Survived the Great Flood\"]\n"
          },
          "familySummary": {
            "type": "string",
            "nullable": true,
            "description": "Text summary of family relationships.\nExample: \"Father of 3, married to Elena, orphaned at young age\"\n"
          }
        }
      },
      "CharacterBaseArchive": {
        "type": "object",
        "x-archive-type": true,
        "description": "Core character data for archive storage and storyline SDK consumption.\nInherits base archive properties from ResourceArchiveBase.\nThe characterId field equals resourceId for convenience.\n\nNote: This is distinct from CharacterArchive which contains text summaries\nfor cleanup. CharacterBaseArchive contains structured data for SDK consumption.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/ResourceArchiveBase"
          }
        ],
        "additionalProperties": false,
        "required": [
          "characterId",
          "name",
          "realmId",
          "speciesId",
          "birthDate",
          "deathDate",
          "status"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the character (equals resourceId)"
          },
          "name": {
            "type": "string",
            "description": "Display name of the character"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID (partition key)"
          },
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "description": "Species ID (foreign key to Species service)"
          },
          "birthDate": {
            "type": "string",
            "format": "date-time",
            "description": "In-game birth timestamp"
          },
          "deathDate": {
            "type": "string",
            "format": "date-time",
            "description": "In-game death timestamp (required for compression)"
          },
          "status": {
            "$ref": "#/components/schemas/CharacterStatus",
            "description": "Current lifecycle status (must be dead for compression)"
          },
          "familySummary": {
            "type": "string",
            "nullable": true,
            "description": "Text summary of family relationships.\nExample: \"Father of 3, married to Elena, orphaned at young age\"\n"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Real-world creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Real-world last update timestamp"
          }
        }
      },
      "CharacterContext": {
        "type": "object",
        "additionalProperties": false,
        "description": "Context information about a character for behavior resolution",
        "properties": {
          "npcId": {
            "type": "string",
            "nullable": true,
            "description": "Unique identifier for the NPC",
            "example": "npc_12345"
          },
          "culture": {
            "type": "string",
            "nullable": true,
            "description": "Cultural background identifier",
            "example": "european_medieval"
          },
          "profession": {
            "type": "string",
            "nullable": true,
            "description": "Character profession identifier",
            "example": "blacksmith"
          },
          "stats": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            },
            "nullable": true,
            "description": "Character statistics and attributes",
            "example": {
              "energy": 0.8,
              "health": 1.0,
              "hunger": 0.3
            }
          },
          "skills": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            },
            "nullable": true,
            "description": "Character skill levels",
            "example": {
              "blacksmithing": 85,
              "trading": 42
            }
          },
          "location": {
            "$ref": "#/components/schemas/Location",
            "nullable": true,
            "description": "Current location information for the character"
          },
          "relationships": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            },
            "nullable": true,
            "description": "Relationship values with other characters"
          },
          "worldState": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Relevant world state information"
          }
        }
      },
      "CharacterEncounterArchive": {
        "type": "object",
        "x-archive-type": true,
        "description": "Complete encounter data for archive storage and storyline SDK consumption.\nInherits base archive properties from ResourceArchiveBase.\nThe characterId field equals resourceId for convenience.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/ResourceArchiveBase"
          }
        ],
        "additionalProperties": false,
        "required": [
          "characterId",
          "hasEncounters",
          "encounterCount"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character this data belongs to (equals resourceId)"
          },
          "hasEncounters": {
            "type": "boolean",
            "description": "Whether encounters exist for this character"
          },
          "encounterCount": {
            "type": "integer",
            "description": "Number of encounters archived"
          },
          "encounters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EncounterResponse"
            },
            "description": "Encounters with perspectives (empty if hasEncounters=false)"
          },
          "aggregateSentiment": {
            "type": "object",
            "additionalProperties": {
              "type": "number",
              "format": "float"
            },
            "description": "Map of target characterId to aggregate sentiment.\nPreserves sentiment relationships for historical reference.\n",
            "nullable": true
          }
        }
      },
      "CharacterHistoryArchive": {
        "type": "object",
        "x-archive-type": true,
        "description": "Complete history data for archive storage and storyline SDK consumption.\nInherits base archive properties from ResourceArchiveBase.\nThe characterId field equals resourceId for convenience.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/ResourceArchiveBase"
          }
        ],
        "additionalProperties": false,
        "required": [
          "characterId",
          "hasParticipations",
          "hasBackstory"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character this data belongs to (equals resourceId)"
          },
          "hasParticipations": {
            "type": "boolean",
            "description": "Whether historical participations exist"
          },
          "participations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HistoricalParticipation"
            },
            "description": "Historical event participations (empty if hasParticipations=false)"
          },
          "hasBackstory": {
            "type": "boolean",
            "description": "Whether backstory elements exist"
          },
          "backstory": {
            "$ref": "#/components/schemas/BackstoryResponse",
            "nullable": true,
            "description": "Backstory data (null if hasBackstory=false)"
          },
          "summaries": {
            "$ref": "#/components/schemas/HistorySummaryResponse",
            "nullable": true,
            "description": "Text summaries for reference"
          }
        }
      },
      "CharacterListResponse": {
        "description": "Paginated list of characters with metadata for navigation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characters",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "characters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CharacterResponse"
            },
            "description": "List of characters matching the query"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of characters matching the filter criteria"
          },
          "page": {
            "type": "integer",
            "description": "Current page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether there are more results after this page"
          },
          "hasPreviousPage": {
            "type": "boolean",
            "description": "Whether there are results before this page"
          }
        }
      },
      "CharacterMembershipEntry": {
        "type": "object",
        "description": "A character's membership in a faction with faction details",
        "additionalProperties": false,
        "required": [
          "factionId",
          "factionName",
          "factionCode",
          "role",
          "joinedAt"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction the character belongs to"
          },
          "factionName": {
            "type": "string",
            "description": "Display name of the faction"
          },
          "factionCode": {
            "type": "string",
            "description": "Unique code of the faction"
          },
          "role": {
            "$ref": "#/components/schemas/FactionMemberRole",
            "description": "Character's role in this faction"
          },
          "joinedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the character joined this faction"
          }
        }
      },
      "CharacterPersonalityArchive": {
        "type": "object",
        "x-archive-type": true,
        "description": "Complete personality data for archive storage and storyline SDK consumption.\nInherits base archive properties from ResourceArchiveBase.\nThe characterId field equals resourceId for convenience.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/ResourceArchiveBase"
          }
        ],
        "additionalProperties": false,
        "required": [
          "characterId",
          "hasPersonality",
          "hasCombatPreferences"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character this data belongs to (equals resourceId)"
          },
          "hasPersonality": {
            "type": "boolean",
            "description": "Whether personality traits exist"
          },
          "personality": {
            "$ref": "#/components/schemas/PersonalityResponse",
            "nullable": true,
            "description": "Personality traits (null if hasPersonality=false)"
          },
          "hasCombatPreferences": {
            "type": "boolean",
            "description": "Whether combat preferences exist"
          },
          "combatPreferences": {
            "$ref": "#/components/schemas/CombatPreferencesResponse",
            "nullable": true,
            "description": "Combat preferences (null if hasCombatPreferences=false)"
          }
        }
      },
      "CharacterResponse": {
        "description": "Complete character data returned from character operations",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId",
          "name",
          "realmId",
          "speciesId",
          "birthDate",
          "status",
          "createdAt"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the character"
          },
          "name": {
            "type": "string",
            "description": "Display name of the character"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID (partition key)"
          },
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "description": "Species ID (foreign key to Species service)"
          },
          "birthDate": {
            "type": "string",
            "format": "date-time",
            "description": "In-game birth timestamp"
          },
          "deathDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "In-game death timestamp"
          },
          "status": {
            "$ref": "#/components/schemas/CharacterStatus",
            "description": "Current lifecycle status of the character"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Real-world creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Real-world last update timestamp"
          }
        }
      },
      "CharacterStateSnapshot": {
        "type": "object",
        "additionalProperties": false,
        "description": "Snapshot of character state for condition evaluation",
        "properties": {
          "age": {
            "type": "integer",
            "nullable": true,
            "description": "Character age in years"
          },
          "traits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TraitSnapshot"
            },
            "nullable": true,
            "description": "Current personality traits"
          },
          "backstoryElements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BackstorySnapshot"
            },
            "nullable": true,
            "description": "Current backstory elements"
          },
          "relationships": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RelationshipSnapshot"
            },
            "nullable": true,
            "description": "Current relationships"
          }
        }
      },
      "CharacterStatus": {
        "type": "string",
        "description": "Character lifecycle status",
        "enum": [
          "alive",
          "dead",
          "dormant"
        ]
      },
      "ChatMessageRequest": {
        "description": "Request to send a chat message to players in a game session",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "sessionId",
          "accountId",
          "gameType",
          "message"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID of the sender. Provided by shortcut system."
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the sender. Provided by shortcut system."
          },
          "gameType": {
            "type": "string",
            "description": "Game type for the chat. Determines which lobby's players receive the message. Provided by shortcut system."
          },
          "message": {
            "type": "string",
            "maxLength": 500,
            "description": "Content of the chat message"
          },
          "messageType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChatMessageType"
              }
            ],
            "default": "public",
            "description": "Type of message (public to all, whisper to one player, or system announcement)"
          },
          "targetPlayerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "For whisper messages"
          }
        }
      },
      "ChatMessageResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "A chat message with metadata and content",
        "required": [
          "messageId",
          "roomId",
          "timestamp",
          "roomTypeCode",
          "isPinned"
        ],
        "properties": {
          "messageId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique message identifier"
          },
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room the message belongs to"
          },
          "senderType": {
            "type": "string",
            "nullable": true,
            "description": "Opaque sender type"
          },
          "senderId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Sender entity ID"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Sender display name"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When the message was sent"
          },
          "roomTypeCode": {
            "type": "string",
            "description": "Room type code for this message"
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SendMessageContent"
              }
            ],
            "nullable": true,
            "description": "Message content (null for deleted messages)"
          },
          "isPinned": {
            "type": "boolean",
            "description": "Whether the message is pinned"
          }
        }
      },
      "ChatMessageType": {
        "type": "string",
        "description": "Type of chat message",
        "enum": [
          "public",
          "whisper",
          "system"
        ]
      },
      "ChatParticipantRole": {
        "type": "string",
        "description": "Participant role within a chat room determining moderation privileges",
        "enum": [
          "Owner",
          "Moderator",
          "Member",
          "ReadOnly"
        ]
      },
      "ChatRoomResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Chat room details including status and participant count",
        "required": [
          "roomId",
          "roomTypeCode",
          "status",
          "participantCount",
          "isArchived",
          "createdAt"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique room identifier"
          },
          "roomTypeCode": {
            "type": "string",
            "description": "Room type code"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Connect session ID if companion room"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Governing contract ID"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable room name"
          },
          "status": {
            "$ref": "#/components/schemas/ChatRoomStatus",
            "description": "Current room status"
          },
          "participantCount": {
            "type": "integer",
            "description": "Current number of participants"
          },
          "maxParticipants": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum participant limit"
          },
          "isArchived": {
            "type": "boolean",
            "description": "Whether the room has been archived"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the room was created"
          },
          "metadata": {
            "type": "string",
            "nullable": true,
            "description": "Arbitrary JSON metadata"
          }
        }
      },
      "ChatRoomStatus": {
        "type": "string",
        "description": "Current state of a chat room",
        "enum": [
          "Active",
          "Locked",
          "Archived"
        ]
      },
      "CheckAssetRequirementsRequest": {
        "type": "object",
        "description": "Request to check asset requirement clauses",
        "additionalProperties": false,
        "required": [
          "contractInstanceId"
        ],
        "properties": {
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          }
        }
      },
      "CheckAssetRequirementsResponse": {
        "type": "object",
        "description": "Response from checking asset requirements",
        "additionalProperties": false,
        "required": [
          "allSatisfied",
          "byParty"
        ],
        "properties": {
          "allSatisfied": {
            "type": "boolean",
            "description": "Whether all requirements across all parties are satisfied"
          },
          "byParty": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartyAssetRequirementStatus"
            },
            "description": "Status broken down by party"
          }
        }
      },
      "CheckConstraintRequest": {
        "type": "object",
        "description": "Request to check constraint",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "constraintType"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity to check"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type"
          },
          "constraintType": {
            "$ref": "#/components/schemas/ConstraintType",
            "description": "Type of constraint to check"
          },
          "proposedAction": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "What the entity wants to do"
          }
        }
      },
      "CheckConstraintResponse": {
        "type": "object",
        "description": "Constraint check result",
        "additionalProperties": false,
        "required": [
          "allowed"
        ],
        "properties": {
          "allowed": {
            "type": "boolean",
            "description": "Whether action is allowed"
          },
          "conflictingContracts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContractSummary"
            },
            "nullable": true,
            "description": "Contracts that would be violated"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Explanation if not allowed"
          }
        }
      },
      "CheckMembershipRequest": {
        "type": "object",
        "description": "Request to check faction membership",
        "additionalProperties": false,
        "required": [
          "factionId",
          "characterId"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction to check membership in"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to check"
          }
        }
      },
      "CheckMembershipResponse": {
        "type": "object",
        "description": "Result of a membership check",
        "additionalProperties": false,
        "required": [
          "factionId",
          "characterId",
          "isMember"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction that was checked"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character that was checked"
          },
          "isMember": {
            "type": "boolean",
            "description": "Whether the character is a member"
          },
          "role": {
            "$ref": "#/components/schemas/FactionMemberRole",
            "nullable": true,
            "description": "Member's role (null if not a member)"
          }
        }
      },
      "CheckReferencesRequest": {
        "description": "Request to check reference count for a character",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to check references for"
          }
        }
      },
      "CheckReferencesResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response containing reference status for a resource",
        "required": [
          "resourceType",
          "resourceId",
          "refCount",
          "isCleanupEligible"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource checked"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource checked"
          },
          "refCount": {
            "type": "integer",
            "description": "Current reference count"
          },
          "sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResourceReference"
            },
            "nullable": true,
            "description": "List of entities referencing this resource (optional, for diagnostics)"
          },
          "isCleanupEligible": {
            "type": "boolean",
            "description": "True if refCount=0 and grace period has passed"
          },
          "gracePeriodEndsAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When grace period ends (null if refCount > 0 or already passed)"
          },
          "lastZeroTimestamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When refCount last became zero"
          }
        }
      },
      "CheckUnlockableRequest": {
        "type": "object",
        "description": "Request to check if a license can be unlocked",
        "additionalProperties": false,
        "required": [
          "boardId",
          "licenseCode"
        ],
        "properties": {
          "boardId": {
            "type": "string",
            "format": "uuid",
            "description": "Board instance to check on"
          },
          "licenseCode": {
            "type": "string",
            "description": "License code to check"
          }
        }
      },
      "CheckUnlockableResponse": {
        "type": "object",
        "description": "Result of unlockability check",
        "additionalProperties": false,
        "required": [
          "unlockable",
          "adjacencyMet",
          "prerequisitesMet",
          "requiredLp"
        ],
        "properties": {
          "unlockable": {
            "type": "boolean",
            "description": "Whether the license can be unlocked (all conditions met)"
          },
          "adjacencyMet": {
            "type": "boolean",
            "description": "Whether adjacency requirement is satisfied"
          },
          "prerequisitesMet": {
            "type": "boolean",
            "description": "Whether all non-adjacent prerequisites are unlocked"
          },
          "lpSufficient": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether the owner has enough LP. Null if LP check is not applicable for this owner type."
          },
          "currentLp": {
            "type": "number",
            "nullable": true,
            "description": "Current LP balance of the owner (null if balance check failed or not applicable)"
          },
          "requiredLp": {
            "type": "integer",
            "description": "LP cost for this license"
          }
        }
      },
      "CheckoutRequest": {
        "type": "object",
        "description": "Request to checkout a scene for editing",
        "required": [
          "sceneId"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene to checkout"
          },
          "editorId": {
            "type": "string",
            "nullable": true,
            "description": "Optional editor identifier (defaults to caller identity)"
          },
          "ttlMinutes": {
            "type": "integer",
            "nullable": true,
            "description": "Custom lock TTL (uses default if not specified)"
          }
        }
      },
      "CheckoutResponse": {
        "type": "object",
        "description": "Response containing checkout token and scene",
        "required": [
          "checkoutToken",
          "scene",
          "expiresAt"
        ],
        "properties": {
          "checkoutToken": {
            "type": "string",
            "description": "Token required for commit/discard/heartbeat"
          },
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "Current scene document"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the checkout lock expires"
          }
        }
      },
      "ChordEvent": {
        "description": "A chord with timing information",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "chord",
          "startTick",
          "durationTicks"
        ],
        "properties": {
          "chord": {
            "$ref": "#/components/schemas/ChordSymbol",
            "description": "Chord symbol"
          },
          "startTick": {
            "type": "integer",
            "minimum": 0,
            "description": "Start position in ticks"
          },
          "durationTicks": {
            "type": "integer",
            "minimum": 1,
            "description": "Duration in ticks"
          },
          "romanNumeral": {
            "type": "string",
            "nullable": true,
            "description": "Roman numeral analysis (e.g., \"IV\", \"V7\")"
          }
        }
      },
      "ChordSymbol": {
        "description": "A chord symbol with root and quality",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "root",
          "quality"
        ],
        "properties": {
          "root": {
            "$ref": "#/components/schemas/PitchClass",
            "description": "Chord root"
          },
          "quality": {
            "type": "string",
            "enum": [
              "major",
              "minor",
              "diminished",
              "augmented",
              "dominant7",
              "major7",
              "minor7",
              "diminished7",
              "halfDiminished7",
              "augmented7",
              "sus2",
              "sus4"
            ],
            "description": "Chord quality"
          },
          "bass": {
            "$ref": "#/components/schemas/PitchClass",
            "nullable": true,
            "description": "Bass note (for inversions/slash chords)"
          },
          "extensions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Chord extensions (e.g., \"9\", \"11\", \"13\")"
          }
        }
      },
      "ClaimTerritoryRequest": {
        "type": "object",
        "description": "Request to claim a location as faction territory",
        "additionalProperties": false,
        "required": [
          "factionId",
          "locationId"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction claiming the territory"
          },
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "Location to claim"
          }
        }
      },
      "ClauseAssetStatus": {
        "type": "object",
        "description": "Status of a single clause's asset requirements",
        "additionalProperties": false,
        "required": [
          "clauseId",
          "satisfied",
          "required",
          "current",
          "missing"
        ],
        "properties": {
          "clauseId": {
            "type": "string",
            "description": "Clause identifier"
          },
          "satisfied": {
            "type": "boolean",
            "description": "Whether requirement is satisfied"
          },
          "required": {
            "$ref": "#/components/schemas/AssetRequirementInfo",
            "description": "What the clause requires"
          },
          "current": {
            "type": "number",
            "description": "Current amount present"
          },
          "missing": {
            "type": "number",
            "description": "Amount still needed (0 if satisfied)"
          }
        }
      },
      "ClauseCategory": {
        "type": "string",
        "description": "Category of clause type",
        "enum": [
          "validation",
          "execution",
          "both"
        ]
      },
      "ClauseDistributionResult": {
        "type": "object",
        "description": "Outcome of a single clause distribution during contract execution.\nUsed in ContractExecutedEvent to provide per-clause success/failure details.\nDeliberately excludes wallet/container IDs - consumers tracking these should\ncorrelate via clauseId to their own records.\n",
        "additionalProperties": false,
        "required": [
          "clauseId",
          "clauseType",
          "assetType",
          "amount",
          "succeeded"
        ],
        "properties": {
          "clauseId": {
            "type": "string",
            "format": "uuid",
            "description": "The clause that was executed"
          },
          "clauseType": {
            "type": "string",
            "description": "Type of clause (e.g., currency_transfer, item_transfer, fee)"
          },
          "assetType": {
            "type": "string",
            "description": "Descriptive type of asset involved (e.g., \"currency\", \"item\").\nProvides human-readable context for what was transferred.\n"
          },
          "amount": {
            "type": "number",
            "description": "Quantity transferred (currency amount, item count, etc.)"
          },
          "succeeded": {
            "type": "boolean",
            "description": "Whether this clause executed successfully"
          },
          "failureReason": {
            "type": "string",
            "nullable": true,
            "description": "If succeeded is false, describes what went wrong"
          }
        }
      },
      "ClauseTypeSummary": {
        "type": "object",
        "description": "Summary of a clause type",
        "additionalProperties": false,
        "required": [
          "typeCode",
          "description",
          "category",
          "hasValidationHandler",
          "hasExecutionHandler",
          "isBuiltIn"
        ],
        "properties": {
          "typeCode": {
            "type": "string",
            "description": "Unique identifier"
          },
          "description": {
            "type": "string",
            "description": "Human-readable description"
          },
          "category": {
            "$ref": "#/components/schemas/ClauseCategory",
            "description": "Clause category"
          },
          "hasValidationHandler": {
            "type": "boolean",
            "description": "Whether a validation handler is registered"
          },
          "hasExecutionHandler": {
            "type": "boolean",
            "description": "Whether an execution handler is registered"
          },
          "isBuiltIn": {
            "type": "boolean",
            "description": "Whether this is a built-in type"
          }
        }
      },
      "CleanupByCharacterRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to cleanup actors referencing a deleted character",
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character that was deleted"
          }
        }
      },
      "CleanupByCharacterResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response from character cleanup operation",
        "required": [
          "actorsCleanedUp",
          "success"
        ],
        "properties": {
          "actorsCleanedUp": {
            "type": "integer",
            "description": "Number of actors that were stopped and cleaned up"
          },
          "actorIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "IDs of actors that were cleaned up"
          },
          "success": {
            "type": "boolean",
            "description": "Whether cleanup completed successfully"
          }
        }
      },
      "CleanupByEntityRequest": {
        "description": "Request to end all relationships referencing a deleted entity during cascading resource cleanup",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the deleted entity whose relationships should be ended"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the deleted entity (e.g., Character, Realm)"
          }
        }
      },
      "CleanupByEntityResponse": {
        "description": "Response summarizing the results of a cascading relationship cleanup operation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "relationshipsEnded",
          "success"
        ],
        "properties": {
          "relationshipsEnded": {
            "type": "integer",
            "description": "Number of active relationships that were ended during cleanup"
          },
          "alreadyEnded": {
            "type": "integer",
            "description": "Number of relationships that were already ended (skipped)"
          },
          "success": {
            "type": "boolean",
            "description": "Whether the cleanup completed without errors"
          }
        }
      },
      "CleanupByGameServiceRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to cleanup divine data for a deleted game service (called by lib-resource)",
        "required": [
          "gameServiceId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service whose divine data to clean up"
          }
        }
      },
      "CleanupByLocationRequest": {
        "type": "object",
        "description": "Request to cleanup territory claims for a deleted location",
        "additionalProperties": false,
        "required": [
          "locationId"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the location that was deleted"
          }
        }
      },
      "CleanupByLocationResponse": {
        "type": "object",
        "description": "Result of location territory claim cleanup",
        "additionalProperties": false,
        "required": [
          "claimsRemoved",
          "success"
        ],
        "properties": {
          "claimsRemoved": {
            "type": "integer",
            "minimum": 0,
            "description": "Number of territory claims removed"
          },
          "success": {
            "type": "boolean",
            "description": "Whether cleanup completed successfully"
          }
        }
      },
      "CleanupByOwnerRequest": {
        "type": "object",
        "description": "Request to cleanup all boards for a deleted owner entity",
        "additionalProperties": false,
        "required": [
          "ownerType",
          "ownerId"
        ],
        "properties": {
          "ownerType": {
            "type": "string",
            "description": "Type of entity whose boards should be cleaned up"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity whose boards should be cleaned up"
          }
        }
      },
      "CleanupByOwnerResponse": {
        "type": "object",
        "description": "Result of owner board cleanup",
        "additionalProperties": false,
        "required": [
          "ownerType",
          "ownerId",
          "boardsDeleted"
        ],
        "properties": {
          "ownerType": {
            "type": "string",
            "description": "Type of entity that was cleaned up"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity that was cleaned up"
          },
          "boardsDeleted": {
            "type": "integer",
            "description": "Number of boards deleted during cleanup"
          }
        }
      },
      "CleanupByRealmRequest": {
        "type": "object",
        "description": "Request to cleanup faction data for a deleted realm",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the realm that was deleted"
          }
        }
      },
      "CleanupByRealmResponse": {
        "type": "object",
        "description": "Result of realm faction data cleanup",
        "additionalProperties": false,
        "required": [
          "factionsRemoved",
          "membershipsRemoved",
          "territoryClaimsRemoved",
          "normsRemoved",
          "success"
        ],
        "properties": {
          "factionsRemoved": {
            "type": "integer",
            "minimum": 0,
            "description": "Number of factions removed"
          },
          "membershipsRemoved": {
            "type": "integer",
            "minimum": 0,
            "description": "Number of memberships removed across all factions"
          },
          "territoryClaimsRemoved": {
            "type": "integer",
            "minimum": 0,
            "description": "Number of territory claims removed"
          },
          "normsRemoved": {
            "type": "integer",
            "minimum": 0,
            "description": "Number of norm definitions removed"
          },
          "success": {
            "type": "boolean",
            "description": "Whether cleanup completed successfully"
          }
        }
      },
      "CleanupCallbackResult": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of executing a single cleanup callback",
        "required": [
          "sourceType",
          "serviceName",
          "endpoint",
          "success"
        ],
        "properties": {
          "sourceType": {
            "type": "string",
            "description": "Source type that was cleaned up (opaque identifier)"
          },
          "serviceName": {
            "type": "string",
            "description": "Service that was called"
          },
          "endpoint": {
            "type": "string",
            "description": "Endpoint that was called"
          },
          "success": {
            "type": "boolean",
            "description": "Whether callback succeeded"
          },
          "statusCode": {
            "type": "integer",
            "nullable": true,
            "description": "HTTP status code from callback"
          },
          "errorMessage": {
            "type": "string",
            "nullable": true,
            "description": "Error message if callback failed"
          },
          "durationMs": {
            "type": "integer",
            "description": "Callback execution time in milliseconds"
          }
        }
      },
      "CleanupCallbackSummary": {
        "type": "object",
        "additionalProperties": false,
        "description": "Summary of a registered cleanup callback",
        "required": [
          "resourceType",
          "sourceType",
          "onDeleteAction",
          "serviceName",
          "callbackEndpoint",
          "registeredAt"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource this callback handles"
          },
          "sourceType": {
            "type": "string",
            "description": "Type of entity that will be cleaned up"
          },
          "onDeleteAction": {
            "$ref": "#/components/schemas/OnDeleteAction",
            "description": "Action taken when resource is deleted"
          },
          "serviceName": {
            "type": "string",
            "description": "Target service for callback invocation"
          },
          "callbackEndpoint": {
            "type": "string",
            "description": "Endpoint path called during cleanup"
          },
          "registeredAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this callback was registered"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description"
          }
        }
      },
      "CleanupPolicy": {
        "type": "string",
        "enum": [
          "BEST_EFFORT",
          "ALL_REQUIRED"
        ],
        "description": "Policy for cleanup callback execution.\nBEST_EFFORT: Proceed with deletion even if some callbacks fail\nALL_REQUIRED: Abort deletion if any callback fails\n"
      },
      "CleanupResponse": {
        "type": "object",
        "description": "Result of an owner cleanup operation",
        "additionalProperties": false,
        "required": [
          "statusesRemoved",
          "containersDeleted"
        ],
        "properties": {
          "statusesRemoved": {
            "type": "integer",
            "description": "Number of status instances removed"
          },
          "containersDeleted": {
            "type": "integer",
            "description": "Number of status containers deleted"
          }
        }
      },
      "ClearEntityPositionRequest": {
        "description": "Request to clear an entity's presence from its current location",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "entityType",
          "entityId"
        ],
        "properties": {
          "entityType": {
            "type": "string",
            "description": "Type of entity (opaque string - character, actor, npc, player, etc.)"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity to clear"
          }
        }
      },
      "ClearEntityPositionResponse": {
        "description": "Result of clearing entity presence",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "cleared"
        ],
        "properties": {
          "cleared": {
            "type": "boolean",
            "description": "Whether the entity had an active presence that was cleared"
          },
          "previousLocationId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Location the entity was removed from (null if entity had no active presence)"
          }
        }
      },
      "ClientCapabilitiesResponse": {
        "description": "Response containing the client's capability manifest with available API endpoints and shortcuts",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "sessionId",
          "capabilities",
          "version",
          "generatedAt"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Session ID this capability manifest belongs to"
          },
          "capabilities": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ClientCapability"
            },
            "description": "Available API capabilities for this client"
          },
          "shortcuts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ClientShortcut"
            },
            "description": "Pre-bound API calls available for this session.\nShortcuts are invoked like normal capabilities but Connect injects\na pre-bound payload instead of using the client's payload.\n",
            "nullable": true
          },
          "version": {
            "type": "integer",
            "description": "Capability manifest version (increments on changes)"
          },
          "generatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this capability manifest was generated"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When these capabilities expire and need refresh",
            "nullable": true
          }
        }
      },
      "ClientCapability": {
        "description": "A single API capability available to the client, mapping a client-salted GUID to a service endpoint",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "guid",
          "service",
          "endpoint",
          "method"
        ],
        "properties": {
          "guid": {
            "type": "string",
            "format": "uuid",
            "description": "Client-salted GUID for this API endpoint (unique per session)"
          },
          "service": {
            "type": "string",
            "description": "Service name (e.g., \"account\", \"auth\")"
          },
          "endpoint": {
            "type": "string",
            "description": "API endpoint path (e.g., \"/account/create\")"
          },
          "method": {
            "type": "string",
            "enum": [
              "GET",
              "POST",
              "PUT",
              "DELETE",
              "PATCH"
            ],
            "description": "HTTP method for this endpoint"
          },
          "description": {
            "type": "string",
            "description": "Human-readable description of this capability",
            "nullable": true
          },
          "channel": {
            "type": "integer",
            "format": "uint16",
            "description": "Preferred WebSocket channel for this capability",
            "default": 0
          }
        }
      },
      "ClientShortcut": {
        "type": "object",
        "description": "Session shortcut information sent to clients in the capability manifest.\nShortcuts appear as invocable capabilities but Connect injects a pre-bound\npayload when the shortcut GUID is used, replacing any client-provided payload.\n",
        "additionalProperties": false,
        "required": [
          "guid",
          "targetService",
          "targetEndpoint",
          "name"
        ],
        "properties": {
          "guid": {
            "type": "string",
            "format": "uuid",
            "description": "GUID to use in WebSocket message header when invoking this shortcut.\nUses UUID version 7 bits to distinguish from regular service GUIDs (version 5).\n"
          },
          "targetService": {
            "type": "string",
            "description": "The service this shortcut invokes (for client display purposes)."
          },
          "targetEndpoint": {
            "type": "string",
            "description": "The endpoint this shortcut invokes (for client display purposes)."
          },
          "name": {
            "type": "string",
            "description": "Machine-readable shortcut identifier (e.g., \"get_my_stats\", \"join_game\")."
          },
          "description": {
            "type": "string",
            "description": "Human-readable description of what this shortcut does.",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "User-friendly name for display in client UIs.",
            "nullable": true
          },
          "sourceService": {
            "type": "string",
            "description": "The service that created this shortcut.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Categorization tags for client-side organization.",
            "nullable": true
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this shortcut expires (if time-limited).",
            "nullable": true
          }
        }
      },
      "CloneBoardRequest": {
        "type": "object",
        "description": "Request to clone a board's unlock state to a new owner (developer tooling)",
        "additionalProperties": false,
        "required": [
          "sourceBoardId",
          "targetOwnerType",
          "targetOwnerId"
        ],
        "properties": {
          "sourceBoardId": {
            "type": "string",
            "format": "uuid",
            "description": "Source board instance to clone unlock state from"
          },
          "targetOwnerType": {
            "type": "string",
            "description": "Type of entity to clone the board to (must be in template's allowedOwnerTypes)"
          },
          "targetOwnerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the target entity"
          },
          "targetRealmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm context for the cloned board. Required for character owners (auto-resolved from character). For realm owners, must equal targetOwnerId. Null for realm-agnostic boards."
          }
        }
      },
      "CloneBoardResponse": {
        "type": "object",
        "description": "Result of a board clone operation",
        "additionalProperties": false,
        "required": [
          "sourceBoardId",
          "targetBoardId",
          "targetOwnerType",
          "targetOwnerId",
          "targetContainerId",
          "licensesCloned"
        ],
        "properties": {
          "sourceBoardId": {
            "type": "string",
            "format": "uuid",
            "description": "Source board that was cloned from"
          },
          "targetBoardId": {
            "type": "string",
            "format": "uuid",
            "description": "New board instance created for the target"
          },
          "targetOwnerType": {
            "type": "string",
            "description": "Type of entity the board was cloned to"
          },
          "targetOwnerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity the board was cloned to"
          },
          "targetContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "Inventory container created for the cloned board"
          },
          "licensesCloned": {
            "type": "integer",
            "description": "Number of licenses cloned (item instances created)"
          }
        }
      },
      "CollapseDeltasRequest": {
        "type": "object",
        "description": "Request to collapse a delta chain into a full snapshot",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID that owns the save slot"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Name of the slot containing deltas to collapse"
          },
          "versionNumber": {
            "type": "integer",
            "nullable": true,
            "description": "Version to collapse to (latest if null)"
          },
          "deleteIntermediates": {
            "type": "boolean",
            "default": true,
            "description": "Delete intermediate delta versions after collapse"
          }
        }
      },
      "CollectionDomainMapping": {
        "type": "object",
        "description": "Maps a tag prefix on a collection entry to a growth domain and amount. When an entry is unlocked, its tags are matched against tagPrefix. Matching tags determine the growth domain (tagPrefix becomes the domain path) and the growth amount to record.\n",
        "required": [
          "tagPrefix",
          "baseAmount"
        ],
        "properties": {
          "tagPrefix": {
            "type": "string",
            "description": "Tag prefix to match against entry tags. An entry tag \"combat.melee.sword\" matches prefix \"combat\" and \"combat.melee\". The full matching tag becomes the growth domain path.\n"
          },
          "baseAmount": {
            "type": "number",
            "format": "float",
            "description": "Base growth amount to record when a tag matches this prefix."
          },
          "discoveryBonusPerLevel": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "description": "Additional growth amount per discovery level of the entry. Total growth = baseAmount + (discoveryLevel * discoveryBonusPerLevel). Null or 0 means no discovery bonus.\n"
          }
        }
      },
      "CollectionGrowthMapping": {
        "type": "object",
        "description": "Maps a collection type to growth domain mappings. When a collection entry is unlocked, Seed uses these mappings to determine which growth domains receive growth and how much. Matched by collection type code.\n",
        "required": [
          "collectionType",
          "domainMappings"
        ],
        "properties": {
          "collectionType": {
            "type": "string",
            "description": "Collection type code to match against (e.g., \"bestiary\", \"music_library\")."
          },
          "domainMappings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CollectionDomainMapping"
            },
            "minItems": 1,
            "description": "Mappings from entry tag prefixes to growth domains."
          }
        }
      },
      "CollectionResponse": {
        "type": "object",
        "description": "Collection instance with summary",
        "additionalProperties": false,
        "required": [
          "collectionId",
          "ownerId",
          "ownerType",
          "collectionType",
          "gameServiceId",
          "containerId",
          "entryCount",
          "createdAt"
        ],
        "properties": {
          "collectionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique collection instance identifier"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity that owns this collection"
          },
          "ownerType": {
            "type": "string",
            "description": "Entity type discriminator"
          },
          "collectionType": {
            "$ref": "#/components/schemas/CollectionType",
            "description": "Type of collection"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this collection is scoped to"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Inventory container holding unlocked entry items"
          },
          "entryCount": {
            "type": "integer",
            "description": "Number of unlocked entries in this collection"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this collection was created"
          }
        }
      },
      "CollectionType": {
        "type": "string",
        "description": "Opaque string code identifying the type of collection content.\nCollection types are game-defined and extensible \u2014 new types can be\nregistered without schema changes. Common conventions include\nvoice_gallery, scene_archive, music_library, bestiary, recipe_book,\nbut any string code is valid.\n"
      },
      "CombatPreferences": {
        "type": "object",
        "description": "Combat behavior preferences that influence tactical decisions.\nThese values affect GOAP action selection, retreat conditions,\nand group coordination behavior.\n",
        "additionalProperties": false,
        "required": [
          "style",
          "preferredRange",
          "groupRole",
          "riskTolerance",
          "retreatThreshold",
          "protectAllies"
        ],
        "properties": {
          "style": {
            "$ref": "#/components/schemas/CombatStyle",
            "description": "Overall combat approach"
          },
          "preferredRange": {
            "$ref": "#/components/schemas/PreferredRange",
            "description": "Preferred engagement distance"
          },
          "groupRole": {
            "$ref": "#/components/schemas/GroupRole",
            "description": "Role when fighting in groups"
          },
          "riskTolerance": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "Willingness to take dangerous actions (0.0 = very cautious, 1.0 = reckless).\nAffects ability selection and target prioritization.\n"
          },
          "retreatThreshold": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "Health percentage at which retreat is considered (0.0 = fight to death,\n0.5 = retreat at half health, 1.0 = retreat at any damage).\n"
          },
          "protectAllies": {
            "type": "boolean",
            "description": "Whether to prioritize ally protection over self-preservation.\nAffects target selection and positioning decisions.\n"
          }
        }
      },
      "CombatPreferencesResponse": {
        "type": "object",
        "description": "Combat preferences profile for behavior system consumption",
        "additionalProperties": false,
        "required": [
          "characterId",
          "preferences",
          "version",
          "createdAt"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character these preferences belong to"
          },
          "preferences": {
            "$ref": "#/components/schemas/CombatPreferences",
            "description": "The combat preferences values"
          },
          "version": {
            "type": "integer",
            "description": "Preferences version number (increments on each evolution)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When these preferences were first created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When these preferences were last modified"
          }
        }
      },
      "CombatPreferencesSnapshot": {
        "description": "Snapshot of combat preferences for enriched response",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "style",
          "preferredRange",
          "groupRole",
          "riskTolerance",
          "retreatThreshold",
          "protectAllies"
        ],
        "properties": {
          "style": {
            "type": "string",
            "description": "Combat style (DEFENSIVE, BALANCED, AGGRESSIVE, BERSERKER, TACTICAL)"
          },
          "preferredRange": {
            "type": "string",
            "description": "Preferred engagement distance (MELEE, CLOSE, MEDIUM, RANGED)"
          },
          "groupRole": {
            "type": "string",
            "description": "Role in group combat (FRONTLINE, SUPPORT, FLANKER, LEADER, SOLO)"
          },
          "riskTolerance": {
            "type": "number",
            "format": "float",
            "description": "Willingness to take risky actions (0.0 to 1.0)"
          },
          "retreatThreshold": {
            "type": "number",
            "format": "float",
            "description": "Health percentage at which retreat is considered (0.0 to 1.0)"
          },
          "protectAllies": {
            "type": "boolean",
            "description": "Whether to prioritize ally protection"
          }
        }
      },
      "CombatStyle": {
        "type": "string",
        "description": "Overall approach to combat situations. Affects target selection,\nability usage, and engagement decisions.\n",
        "enum": [
          "DEFENSIVE",
          "BALANCED",
          "AGGRESSIVE",
          "BERSERKER",
          "TACTICAL"
        ]
      },
      "CommitRequest": {
        "type": "object",
        "description": "Request to commit checkout changes",
        "required": [
          "sceneId",
          "checkoutToken",
          "scene"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene being committed"
          },
          "checkoutToken": {
            "type": "string",
            "description": "Checkout token from checkout response"
          },
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "Updated scene document"
          },
          "changesSummary": {
            "type": "string",
            "nullable": true,
            "description": "Optional summary of changes for audit"
          }
        }
      },
      "CommitResponse": {
        "type": "object",
        "description": "Response confirming commit",
        "required": [
          "committed",
          "newVersion"
        ],
        "properties": {
          "committed": {
            "type": "boolean",
            "description": "Whether commit was successful"
          },
          "newVersion": {
            "type": "string",
            "description": "New version after commit"
          },
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "nullable": true,
            "description": "Committed scene with updated metadata"
          }
        }
      },
      "ComparisonOperator": {
        "type": "string",
        "description": "Comparison operators for numeric conditions",
        "enum": [
          "eq",
          "ne",
          "gt",
          "gte",
          "lt",
          "lte"
        ]
      },
      "CompilationOptions": {
        "description": "Options controlling the ABML compilation process including optimizations and caching",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "enableOptimizations": {
            "type": "boolean",
            "default": true,
            "description": "Enable behavior tree optimizations"
          },
          "cacheCompiledResult": {
            "type": "boolean",
            "default": true,
            "description": "Cache the compiled behavior for reuse"
          },
          "strictValidation": {
            "type": "boolean",
            "default": false,
            "description": "Enable strict validation mode"
          },
          "culturalAdaptations": {
            "type": "boolean",
            "default": true,
            "description": "Apply cultural adaptations during compilation"
          },
          "goapIntegration": {
            "type": "boolean",
            "default": true,
            "description": "Generate GOAP goals from behaviors"
          }
        }
      },
      "CompileBehaviorRequest": {
        "description": "Request to compile an ABML behavior definition into executable behavior trees",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "abmlContent"
        ],
        "properties": {
          "abmlContent": {
            "type": "string",
            "description": "Raw ABML YAML content to compile",
            "example": "version: \"1.0.0\"\nmetadata:\n  id: \"example_behavior\"\n  category: \"basic\"\nbehaviors:\n  example:\n    triggers:\n      - condition: \"true\"\n    actions:\n      - log:\n          message: \"Hello World\"\n"
          },
          "behaviorName": {
            "type": "string",
            "nullable": true,
            "description": "Optional human-readable name for the behavior.\nIf not provided, extracted from ABML metadata.id or generated from content hash.\n",
            "example": "blacksmith_daily_routine"
          },
          "behaviorCategory": {
            "type": "string",
            "description": "Category for organizing behaviors (e.g., profession, cultural, situational).\nUsed for filtering and grouping in bundles.\n",
            "enum": [
              "base",
              "cultural",
              "professional",
              "personal",
              "situational",
              "ambient"
            ],
            "nullable": true,
            "example": "professional"
          },
          "bundleId": {
            "type": "string",
            "nullable": true,
            "description": "Optional bundle identifier for grouping related behaviors.\nWhen specified, the compiled behavior will be added to a bundle with this ID.\nClients can then download entire bundles for efficient bulk loading.\nIf the bundle doesn't exist, it will be created.\n",
            "example": "blacksmith-behaviors-v1"
          },
          "characterContext": {
            "$ref": "#/components/schemas/CharacterContext",
            "nullable": true,
            "description": "Character context for context variable resolution during compilation"
          },
          "compilationOptions": {
            "$ref": "#/components/schemas/CompilationOptions",
            "nullable": true,
            "description": "Options controlling the compilation process"
          }
        }
      },
      "CompileBehaviorResponse": {
        "description": "Response containing the results of an ABML behavior compilation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "behaviorId"
        ],
        "properties": {
          "behaviorId": {
            "type": "string",
            "description": "Unique identifier for the compiled behavior (content-addressable hash)",
            "example": "behavior-a1b2c3d4e5f6g7h8"
          },
          "behaviorName": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable name of the behavior",
            "example": "blacksmith_daily_routine"
          },
          "compiledBehavior": {
            "$ref": "#/components/schemas/CompiledBehavior",
            "nullable": true,
            "description": "The compiled behavior data including behavior tree and metadata"
          },
          "compilationTimeMs": {
            "type": "integer",
            "description": "Time taken to compile the behavior in milliseconds"
          },
          "assetId": {
            "type": "string",
            "nullable": true,
            "description": "Asset service ID where the compiled bytecode is stored. Null only when caching is explicitly disabled."
          },
          "bundleId": {
            "type": "string",
            "nullable": true,
            "description": "Bundle ID if the behavior was added to a bundle. Null if not bundled."
          },
          "isUpdate": {
            "type": "boolean",
            "description": "True if this replaced an existing behavior with the same content hash"
          },
          "warnings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Non-fatal warnings during compilation"
          }
        }
      },
      "CompiledBehavior": {
        "description": "Compiled behavior containing behavior tree, context schema, and GOAP integration data",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "behaviorTree",
          "contextSchema"
        ],
        "properties": {
          "behaviorTree": {
            "$ref": "#/components/schemas/BehaviorTreeData",
            "description": "Compiled behavior tree data with bytecode or download reference"
          },
          "contextSchema": {
            "$ref": "#/components/schemas/ContextSchemaData",
            "description": "Schema defining required context variables for execution"
          },
          "serviceDependencies": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "List of required services for this behavior"
          },
          "goapGoals": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GoapGoal"
            },
            "nullable": true,
            "description": "GOAP goals extracted from the behavior"
          },
          "executionMetadata": {
            "$ref": "#/components/schemas/ExecutionMetadata",
            "nullable": true,
            "description": "Metadata for behavior execution including performance hints and resource requirements"
          }
        }
      },
      "CompleteMilestoneRequest": {
        "type": "object",
        "description": "Request to complete a milestone",
        "additionalProperties": false,
        "required": [
          "contractId",
          "milestoneCode"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "milestoneCode": {
            "type": "string",
            "description": "Milestone to complete"
          },
          "evidence": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Evidence of completion"
          }
        }
      },
      "CompleteScenarioRequest": {
        "type": "object",
        "description": "Request to complete a scenario",
        "required": [
          "accountId",
          "scenarioInstanceId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account completing the scenario"
          },
          "scenarioInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Scenario instance to complete"
          }
        }
      },
      "CompleteUploadRequest": {
        "description": "Request to finalize an upload and trigger asset processing",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "uploadId"
        ],
        "properties": {
          "uploadId": {
            "type": "string",
            "format": "uuid",
            "description": "Upload session ID from requestUpload"
          },
          "parts": {
            "type": "array",
            "nullable": true,
            "description": "For multipart uploads - ETags of completed parts (null for single-file uploads)",
            "items": {
              "$ref": "#/components/schemas/CompletedPart"
            }
          }
        }
      },
      "CompletedPart": {
        "description": "Information about a completed part in a multipart upload",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "partNumber",
          "etag"
        ],
        "properties": {
          "partNumber": {
            "type": "integer",
            "description": "Part number (1-based)"
          },
          "etag": {
            "type": "string",
            "description": "ETag returned from part upload"
          }
        }
      },
      "CompletionStatsResponse": {
        "type": "object",
        "description": "Completion statistics for a collection",
        "additionalProperties": false,
        "required": [
          "collectionType",
          "totalEntries",
          "unlockedEntries",
          "completionPercentage"
        ],
        "properties": {
          "collectionType": {
            "$ref": "#/components/schemas/CollectionType",
            "description": "Type of collection"
          },
          "totalEntries": {
            "type": "integer",
            "description": "Total number of entry templates available"
          },
          "unlockedEntries": {
            "type": "integer",
            "description": "Number of entries unlocked by this owner"
          },
          "completionPercentage": {
            "type": "number",
            "format": "double",
            "description": "Completion percentage (0.0 to 100.0)"
          },
          "byCategory": {
            "type": "object",
            "nullable": true,
            "additionalProperties": {
              "$ref": "#/components/schemas/CategoryStats"
            },
            "description": "Completion breakdown by category"
          }
        }
      },
      "ComposeConstraints": {
        "type": "object",
        "additionalProperties": false,
        "description": "Constraints on storyline composition",
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm to anchor the storyline in"
          },
          "locationId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional starting location"
          },
          "maxEntities": {
            "type": "integer",
            "minimum": 1,
            "maximum": 50,
            "nullable": true,
            "description": "Maximum entities the plan can require (default from config)"
          },
          "maxPhases": {
            "type": "integer",
            "minimum": 1,
            "maximum": 10,
            "nullable": true,
            "description": "Maximum phases in the plan (default unlimited)"
          }
        }
      },
      "ComposeRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to compose a storyline plan",
        "required": [
          "seedSources",
          "goal"
        ],
        "properties": {
          "seedSources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SeedSource"
            },
            "minItems": 1,
            "maxItems": 10,
            "description": "Archive or snapshot sources to seed the storyline.\nAt least one source is required. Mix of archives and snapshots allowed.\n"
          },
          "goal": {
            "$ref": "#/components/schemas/StorylineGoal",
            "description": "The high-level goal driving arc selection"
          },
          "constraints": {
            "$ref": "#/components/schemas/ComposeConstraints",
            "nullable": true,
            "description": "Optional constraints on composition"
          },
          "genre": {
            "type": "string",
            "nullable": true,
            "description": "Genre filter (e.g., \"crime\", \"action\", \"romance\").\nIf omitted, inferred from archive data.\n"
          },
          "arcType": {
            "$ref": "#/components/schemas/ArcType",
            "nullable": true,
            "description": "Specific arc type to use. If omitted, selected based on goal.\n"
          },
          "urgency": {
            "$ref": "#/components/schemas/PlanningUrgency",
            "nullable": true,
            "description": "Planning urgency level. Defaults to configuration value.\n"
          },
          "seed": {
            "type": "integer",
            "nullable": true,
            "description": "Random seed for deterministic output (enables caching)"
          }
        }
      },
      "ComposeResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Composed storyline plan",
        "required": [
          "planId",
          "confidence",
          "goal",
          "arcType",
          "primarySpectrum",
          "phases",
          "generationTimeMs",
          "cached"
        ],
        "properties": {
          "planId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique plan identifier"
          },
          "confidence": {
            "type": "number",
            "format": "double",
            "minimum": 0,
            "maximum": 1,
            "description": "Plan viability score (0-1)"
          },
          "goal": {
            "$ref": "#/components/schemas/StorylineGoal",
            "description": "The goal that was used"
          },
          "genre": {
            "type": "string",
            "nullable": true,
            "description": "Inferred or specified genre"
          },
          "arcType": {
            "$ref": "#/components/schemas/ArcType",
            "description": "Emotional arc type used"
          },
          "primarySpectrum": {
            "$ref": "#/components/schemas/SpectrumType",
            "description": "Primary Life Value spectrum"
          },
          "themes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Inferred thematic elements"
          },
          "phases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StorylinePlanPhase"
            },
            "description": "Planned phases with actions"
          },
          "entitiesToSpawn": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityRequirement"
            },
            "nullable": true,
            "description": "Entities required for this storyline (descriptions only).\nCallers decide whether to spawn them.\n"
          },
          "links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StorylineLink"
            },
            "nullable": true,
            "description": "Links between entities in the plan"
          },
          "risks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StorylineRisk"
            },
            "nullable": true,
            "description": "Identified risks or weak points in the plan"
          },
          "generationTimeMs": {
            "type": "integer",
            "description": "Time taken to generate in milliseconds"
          },
          "cached": {
            "type": "boolean",
            "description": "Whether this was returned from cache"
          }
        }
      },
      "CompositionMetadata": {
        "description": "Metadata about a generated composition",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "styleId": {
            "type": "string",
            "nullable": true,
            "description": "Style used"
          },
          "key": {
            "$ref": "#/components/schemas/KeySignature",
            "nullable": true,
            "description": "Key signature"
          },
          "tempo": {
            "type": "integer",
            "nullable": true,
            "description": "Tempo in BPM"
          },
          "bars": {
            "type": "integer",
            "nullable": true,
            "description": "Number of bars"
          },
          "tuneType": {
            "type": "string",
            "nullable": true,
            "description": "Tune type if applicable"
          },
          "seed": {
            "type": "integer",
            "nullable": true,
            "description": "Random seed used"
          }
        }
      },
      "CompressCallbackResult": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of a single compression callback",
        "required": [
          "sourceType",
          "serviceName",
          "endpoint",
          "success",
          "durationMs"
        ],
        "properties": {
          "sourceType": {
            "type": "string",
            "description": "Source type that provided data"
          },
          "serviceName": {
            "type": "string",
            "description": "Service that was called"
          },
          "endpoint": {
            "type": "string",
            "description": "Endpoint that was called"
          },
          "success": {
            "type": "boolean",
            "description": "Whether callback succeeded"
          },
          "statusCode": {
            "type": "integer",
            "nullable": true,
            "description": "HTTP status code from callback"
          },
          "errorMessage": {
            "type": "string",
            "nullable": true,
            "description": "Error message if callback failed"
          },
          "dataSize": {
            "type": "integer",
            "nullable": true,
            "description": "Size of compressed data in bytes"
          },
          "durationMs": {
            "type": "integer",
            "description": "Callback execution time in milliseconds"
          }
        }
      },
      "CompressCallbackSummary": {
        "type": "object",
        "additionalProperties": false,
        "description": "Summary of a registered compression callback",
        "required": [
          "resourceType",
          "sourceType",
          "serviceName",
          "compressEndpoint",
          "priority",
          "registeredAt"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource this callback handles"
          },
          "sourceType": {
            "type": "string",
            "description": "Type of data being compressed"
          },
          "serviceName": {
            "type": "string",
            "description": "Target service for callback invocation"
          },
          "compressEndpoint": {
            "type": "string",
            "description": "Endpoint called during compression"
          },
          "decompressEndpoint": {
            "type": "string",
            "nullable": true,
            "description": "Endpoint called during decompression"
          },
          "priority": {
            "type": "integer",
            "description": "Execution order (lower = earlier)"
          },
          "registeredAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this callback was registered"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description"
          }
        }
      },
      "CompressionPolicy": {
        "type": "string",
        "enum": [
          "BEST_EFFORT",
          "ALL_REQUIRED"
        ],
        "description": "Policy for compression callback execution.\nBEST_EFFORT: Create archive even if some callbacks fail (partial archive)\nALL_REQUIRED: Abort compression if any callback fails\n"
      },
      "CompressionType": {
        "type": "string",
        "enum": [
          "lz4",
          "lzma",
          "none"
        ],
        "description": "Compression algorithm for bundles"
      },
      "ConditionResult": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of evaluating a single condition",
        "required": [
          "conditionType",
          "met"
        ],
        "properties": {
          "conditionType": {
            "$ref": "#/components/schemas/TriggerConditionType",
            "description": "Condition type"
          },
          "met": {
            "type": "boolean",
            "description": "Whether condition was met"
          },
          "actualValue": {
            "type": "string",
            "nullable": true,
            "description": "Actual value found"
          },
          "expectedValue": {
            "type": "string",
            "nullable": true,
            "description": "Expected value"
          },
          "details": {
            "type": "string",
            "nullable": true,
            "description": "Additional details"
          }
        }
      },
      "ConfirmBondRequest": {
        "type": "object",
        "description": "Request to confirm a pending bond.",
        "required": [
          "bondId",
          "confirmingSeedId"
        ],
        "properties": {
          "bondId": {
            "type": "string",
            "format": "uuid",
            "description": "The bond to confirm."
          },
          "confirmingSeedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed confirming the bond."
          }
        }
      },
      "ConfirmRefundRequest": {
        "type": "object",
        "description": "Request to confirm receipt of refunded assets",
        "additionalProperties": false,
        "required": [
          "escrowId",
          "partyId"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "The escrow being confirmed."
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "The party confirming receipt of refund."
          },
          "notes": {
            "type": "string",
            "nullable": true,
            "description": "Optional confirmation notes."
          }
        }
      },
      "ConfirmRefundResponse": {
        "type": "object",
        "description": "Response from confirming refund receipt",
        "additionalProperties": false,
        "required": [
          "escrowId",
          "confirmed",
          "allPartiesConfirmed"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "The escrow ID."
          },
          "confirmed": {
            "type": "boolean",
            "description": "Whether this party's confirmation was recorded."
          },
          "allPartiesConfirmed": {
            "type": "boolean",
            "description": "Whether all parties have now confirmed (triggers Refunded transition)."
          },
          "status": {
            "$ref": "#/components/schemas/EscrowStatus",
            "description": "Current escrow status after confirmation.",
            "nullable": true
          }
        }
      },
      "ConfirmReleaseRequest": {
        "type": "object",
        "description": "Request to confirm receipt of released assets",
        "additionalProperties": false,
        "required": [
          "escrowId",
          "partyId",
          "releaseToken"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "The escrow being confirmed."
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "The party confirming receipt."
          },
          "releaseToken": {
            "type": "string",
            "description": "The party's release token (received via confirmation shortcut)."
          },
          "notes": {
            "type": "string",
            "nullable": true,
            "description": "Optional confirmation notes."
          }
        }
      },
      "ConfirmReleaseResponse": {
        "type": "object",
        "description": "Response from confirming release receipt",
        "additionalProperties": false,
        "required": [
          "escrowId",
          "confirmed",
          "allPartiesConfirmed"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "The escrow ID."
          },
          "confirmed": {
            "type": "boolean",
            "description": "Whether this party's confirmation was recorded."
          },
          "allPartiesConfirmed": {
            "type": "boolean",
            "description": "Whether all parties have now confirmed (triggers Released transition)."
          },
          "status": {
            "$ref": "#/components/schemas/EscrowStatus",
            "description": "Current escrow status after confirmation.",
            "nullable": true
          }
        }
      },
      "ConflictingBundleEntry": {
        "type": "object",
        "additionalProperties": false,
        "description": "A bundle entry in an asset conflict",
        "required": [
          "bundleId",
          "contentHash"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Bundle containing this version"
          },
          "contentHash": {
            "type": "string",
            "description": "Content hash of asset in this bundle"
          }
        }
      },
      "ConnectivityMode": {
        "type": "string",
        "enum": [
          "Isolated",
          "WorldSlice",
          "Persistent"
        ],
        "description": "How a scenario instance connects to the broader game world"
      },
      "ConsentRequest": {
        "type": "object",
        "description": "Request to record party consent for release or refund",
        "required": [
          "escrowId",
          "partyId",
          "partyType",
          "consentType",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party giving consent"
          },
          "partyType": {
            "description": "Type of entity (Account, Character, etc.)",
            "$ref": "#/components/schemas/EntityType"
          },
          "consentType": {
            "$ref": "#/components/schemas/EscrowConsentType",
            "description": "Type of consent being given"
          },
          "releaseToken": {
            "type": "string",
            "nullable": true,
            "description": "Release token (required for full_consent)"
          },
          "notes": {
            "type": "string",
            "nullable": true,
            "description": "Optional notes"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "ConsentResponse": {
        "type": "object",
        "description": "Response from recording party consent",
        "required": [
          "escrow",
          "consentRecorded",
          "triggered",
          "newStatus"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Updated escrow agreement"
          },
          "consentRecorded": {
            "type": "boolean",
            "description": "Whether consent was recorded"
          },
          "triggered": {
            "type": "boolean",
            "description": "Whether this consent triggered completion"
          },
          "newStatus": {
            "$ref": "#/components/schemas/EscrowStatus",
            "description": "New escrow status after consent"
          }
        }
      },
      "ConsentStatus": {
        "type": "string",
        "description": "Party's consent status",
        "enum": [
          "pending",
          "consented",
          "declined",
          "implicit"
        ]
      },
      "ConsentToContractRequest": {
        "type": "object",
        "description": "Request to consent to a contract",
        "additionalProperties": false,
        "required": [
          "contractId",
          "partyEntityId",
          "partyEntityType"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract to consent to"
          },
          "partyEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID of consenting party"
          },
          "partyEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type of consenting party"
          }
        }
      },
      "ConstraintType": {
        "type": "string",
        "description": "Type of constraint to check",
        "enum": [
          "exclusivity",
          "non_compete",
          "time_commitment"
        ]
      },
      "ContactRequest": {
        "description": "User-submitted contact form data",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "email",
          "subject",
          "message"
        ],
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "description": "Sender email address for replies"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "Name of the person submitting the form"
          },
          "subject": {
            "type": "string",
            "minLength": 5,
            "maxLength": 200,
            "description": "Subject line of the contact message"
          },
          "message": {
            "type": "string",
            "minLength": 10,
            "maxLength": 2000,
            "description": "Body content of the contact message"
          },
          "category": {
            "type": "string",
            "enum": [
              "general",
              "support",
              "bug",
              "feedback",
              "business"
            ],
            "default": "general",
            "description": "Category to route the contact request"
          }
        }
      },
      "ContactResponse": {
        "description": "Confirmation response after submitting a contact form",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "ticketId",
          "message"
        ],
        "properties": {
          "ticketId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the created support ticket"
          },
          "message": {
            "type": "string",
            "default": "Thank you for contacting us. We will respond within 24-48 hours.",
            "description": "Confirmation message displayed to the user"
          }
        }
      },
      "ContainerConstraintModel": {
        "type": "string",
        "description": "Container capacity constraint type",
        "enum": [
          "slot_only",
          "weight_only",
          "slot_and_weight",
          "grid",
          "volumetric",
          "unlimited"
        ]
      },
      "ContainerItem": {
        "type": "object",
        "description": "Item in a container",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "templateId",
          "quantity"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance ID"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Item template ID"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "description": "Item quantity"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Slot position"
          },
          "slotX": {
            "type": "integer",
            "nullable": true,
            "description": "Grid X position"
          },
          "slotY": {
            "type": "integer",
            "nullable": true,
            "description": "Grid Y position"
          },
          "rotated": {
            "type": "boolean",
            "nullable": true,
            "description": "Rotated in grid"
          }
        }
      },
      "ContainerOwnerType": {
        "type": "string",
        "description": "Type of entity that owns this container",
        "enum": [
          "character",
          "account",
          "location",
          "vehicle",
          "guild",
          "escrow",
          "mail",
          "other"
        ]
      },
      "ContainerResponse": {
        "type": "object",
        "description": "Container details",
        "additionalProperties": false,
        "required": [
          "containerId",
          "ownerId",
          "ownerType",
          "containerType",
          "constraintModel",
          "isEquipmentSlot",
          "canContainContainers",
          "nestingDepth",
          "selfWeight",
          "weightContribution",
          "slotCost",
          "contentsWeight",
          "totalWeight",
          "createdAt"
        ],
        "properties": {
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container unique identifier"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner entity ID"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Owner type"
          },
          "containerType": {
            "type": "string",
            "description": "Container type"
          },
          "constraintModel": {
            "$ref": "#/components/schemas/ContainerConstraintModel",
            "description": "Constraint model"
          },
          "isEquipmentSlot": {
            "type": "boolean",
            "description": "Whether this is an equipment slot"
          },
          "equipmentSlotName": {
            "type": "string",
            "nullable": true,
            "description": "Equipment slot name"
          },
          "maxSlots": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum slots"
          },
          "usedSlots": {
            "type": "integer",
            "nullable": true,
            "description": "Current used slots"
          },
          "maxWeight": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Maximum weight"
          },
          "gridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "Internal grid width"
          },
          "gridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "Internal grid height"
          },
          "maxVolume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Maximum volume"
          },
          "currentVolume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Current volume used"
          },
          "parentContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Parent container ID"
          },
          "nestingDepth": {
            "type": "integer",
            "description": "Depth in container hierarchy"
          },
          "canContainContainers": {
            "type": "boolean",
            "description": "Whether can hold containers"
          },
          "maxNestingDepth": {
            "type": "integer",
            "nullable": true,
            "description": "Max nesting depth"
          },
          "selfWeight": {
            "type": "number",
            "format": "double",
            "description": "Empty container weight"
          },
          "weightContribution": {
            "$ref": "#/components/schemas/WeightContribution",
            "description": "Weight propagation mode"
          },
          "slotCost": {
            "type": "integer",
            "description": "Slots used in parent"
          },
          "parentGridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "Width in parent grid"
          },
          "parentGridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "Height in parent grid"
          },
          "parentVolume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Volume in parent"
          },
          "contentsWeight": {
            "type": "number",
            "format": "double",
            "description": "Weight of direct contents"
          },
          "totalWeight": {
            "type": "number",
            "format": "double",
            "description": "Total weight including self"
          },
          "allowedCategories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Allowed categories"
          },
          "forbiddenCategories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Forbidden categories"
          },
          "allowedTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Required tags"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm ID"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Container tags"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "description": "Game-specific data"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "modifiedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last modification"
          }
        }
      },
      "ContainerWithContentsResponse": {
        "type": "object",
        "description": "Container with item contents",
        "additionalProperties": false,
        "required": [
          "container",
          "items"
        ],
        "properties": {
          "container": {
            "$ref": "#/components/schemas/ContainerResponse",
            "description": "Container details"
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContainerItem"
            },
            "description": "Items in container"
          }
        }
      },
      "ContentSelectionResponse": {
        "type": "object",
        "description": "Selected content entry for an area",
        "additionalProperties": false,
        "required": [
          "entryCode",
          "displayName",
          "matchedThemes"
        ],
        "properties": {
          "entryCode": {
            "type": "string",
            "description": "Code of the selected entry"
          },
          "displayName": {
            "type": "string",
            "description": "Display name of the selected entry"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Category of the selected entry"
          },
          "assetId": {
            "type": "string",
            "nullable": true,
            "description": "Primary asset identifier for the entry"
          },
          "thumbnailAssetId": {
            "type": "string",
            "nullable": true,
            "description": "Thumbnail asset identifier for the entry"
          },
          "themes": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Theme tags of the selected entry"
          },
          "matchedThemes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Themes that matched the area configuration"
          }
        }
      },
      "ContextSchemaData": {
        "type": "object",
        "description": "Schema defining required context variables for behavior execution",
        "additionalProperties": true
      },
      "ContractBindingType": {
        "type": "string",
        "description": "Type of contract binding on an item instance.\n- none: No contract bound\n- session: Temporary binding for multi-step use (managed by Item service)\n- lifecycle: Persistent binding for status effects, licenses, etc. (managed by external orchestrators)\n",
        "enum": [
          "none",
          "session",
          "lifecycle"
        ]
      },
      "ContractInstanceResponse": {
        "type": "object",
        "description": "Contract instance details",
        "additionalProperties": false,
        "required": [
          "contractId",
          "templateId",
          "status",
          "parties",
          "createdAt"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique contract identifier"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Source template ID"
          },
          "templateCode": {
            "type": "string",
            "description": "Source template code"
          },
          "status": {
            "$ref": "#/components/schemas/ContractStatus",
            "description": "Current contract status"
          },
          "parties": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContractPartyResponse"
            },
            "description": "Contract parties"
          },
          "terms": {
            "$ref": "#/components/schemas/ContractTerms",
            "nullable": true,
            "description": "Contract terms"
          },
          "milestones": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MilestoneInstanceResponse"
            },
            "nullable": true,
            "description": "Milestone progress"
          },
          "currentMilestoneIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Index of current milestone"
          },
          "escrowIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "Related escrow IDs"
          },
          "proposedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When contract was proposed"
          },
          "acceptedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When all parties consented"
          },
          "effectiveFrom": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When contract became active"
          },
          "effectiveUntil": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When contract expires"
          },
          "terminatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When contract was terminated"
          },
          "gameMetadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Game-specific metadata"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last update timestamp"
          }
        }
      },
      "ContractInstanceStatusResponse": {
        "type": "object",
        "description": "Contract status summary",
        "additionalProperties": false,
        "required": [
          "contractId",
          "status",
          "milestoneProgress"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "status": {
            "$ref": "#/components/schemas/ContractStatus",
            "description": "Current status"
          },
          "milestoneProgress": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MilestoneProgressSummary"
            },
            "description": "Milestone progress summary"
          },
          "pendingConsents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PendingConsentSummary"
            },
            "nullable": true,
            "description": "Parties who haven't consented"
          },
          "activeBreaches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BreachSummary"
            },
            "nullable": true,
            "description": "Active breach records"
          },
          "daysUntilExpiration": {
            "type": "integer",
            "nullable": true,
            "description": "Days until natural expiration"
          }
        }
      },
      "ContractMetadataResponse": {
        "type": "object",
        "description": "Contract metadata",
        "additionalProperties": false,
        "required": [
          "contractId"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "instanceData": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Instance-level metadata"
          },
          "runtimeState": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Runtime state metadata"
          }
        }
      },
      "ContractPartyInput": {
        "type": "object",
        "description": "Party input for contract creation",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "role"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type"
          },
          "role": {
            "type": "string",
            "description": "Role from template"
          }
        }
      },
      "ContractPartyResponse": {
        "type": "object",
        "description": "Contract party details",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "role",
          "consentStatus"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type"
          },
          "role": {
            "type": "string",
            "description": "Role in contract"
          },
          "consentStatus": {
            "$ref": "#/components/schemas/ConsentStatus",
            "description": "Consent status"
          },
          "consentedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When consent was given"
          }
        }
      },
      "ContractRoomAction": {
        "type": "string",
        "description": "Action to take on a contract-governed room when contract state changes",
        "enum": [
          "Continue",
          "Lock",
          "Archive",
          "Delete"
        ]
      },
      "ContractStatus": {
        "type": "string",
        "description": "Current status of a contract instance",
        "enum": [
          "draft",
          "proposed",
          "pending",
          "active",
          "fulfilled",
          "expired",
          "terminated",
          "breached",
          "suspended",
          "disputed",
          "declined"
        ]
      },
      "ContractSummary": {
        "type": "object",
        "description": "Brief contract information",
        "additionalProperties": false,
        "required": [
          "contractId",
          "templateCode",
          "status",
          "role"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract ID"
          },
          "templateCode": {
            "type": "string",
            "description": "Template code"
          },
          "templateName": {
            "type": "string",
            "nullable": true,
            "description": "Template name"
          },
          "status": {
            "$ref": "#/components/schemas/ContractStatus",
            "description": "Current status"
          },
          "role": {
            "type": "string",
            "description": "Entity's role in contract"
          },
          "effectiveUntil": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When contract expires"
          }
        }
      },
      "ContractTemplateResponse": {
        "type": "object",
        "description": "Contract template details",
        "additionalProperties": false,
        "required": [
          "templateId",
          "code",
          "name",
          "minParties",
          "maxParties",
          "partyRoles",
          "defaultEnforcementMode",
          "isActive",
          "createdAt"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique template identifier"
          },
          "code": {
            "type": "string",
            "description": "Unique template code"
          },
          "name": {
            "type": "string",
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Detailed description"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm ID if realm-specific"
          },
          "minParties": {
            "type": "integer",
            "description": "Minimum parties required"
          },
          "maxParties": {
            "type": "integer",
            "description": "Maximum parties allowed"
          },
          "partyRoles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartyRoleDefinition"
            },
            "description": "Party role definitions"
          },
          "defaultTerms": {
            "$ref": "#/components/schemas/ContractTerms",
            "nullable": true,
            "description": "Default contract terms"
          },
          "milestones": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MilestoneDefinition"
            },
            "nullable": true,
            "description": "Milestone definitions"
          },
          "defaultEnforcementMode": {
            "$ref": "#/components/schemas/EnforcementMode",
            "description": "Default enforcement mode"
          },
          "transferable": {
            "type": "boolean",
            "description": "Whether contracts can be transferred"
          },
          "gameMetadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Game-specific metadata"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether template is active"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last update timestamp"
          }
        }
      },
      "ContractTerms": {
        "type": "object",
        "description": "Configurable contract terms",
        "additionalProperties": false,
        "properties": {
          "duration": {
            "type": "string",
            "nullable": true,
            "description": "Contract duration (ISO 8601 duration, null for perpetual)"
          },
          "paymentSchedule": {
            "$ref": "#/components/schemas/PaymentSchedule",
            "nullable": true,
            "description": "When payments occur"
          },
          "paymentFrequency": {
            "type": "string",
            "nullable": true,
            "description": "Recurring payment frequency (ISO 8601 duration)"
          },
          "terminationPolicy": {
            "$ref": "#/components/schemas/TerminationPolicy",
            "nullable": true,
            "description": "How contract can be terminated"
          },
          "terminationNoticePeriod": {
            "type": "string",
            "nullable": true,
            "description": "Required notice for termination (ISO 8601 duration)"
          },
          "breachThreshold": {
            "type": "integer",
            "minimum": 0,
            "nullable": true,
            "description": "Breaches before auto-termination (0 for no auto)"
          },
          "gracePeriodForCure": {
            "type": "string",
            "nullable": true,
            "description": "Time to cure breach (ISO 8601 duration)"
          },
          "customTerms": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Game-specific custom terms"
          }
        }
      },
      "ControllingFactionResponse": {
        "type": "object",
        "description": "The faction controlling a location",
        "additionalProperties": false,
        "required": [
          "locationId",
          "faction",
          "claimId",
          "claimedAt"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "Location that is controlled"
          },
          "faction": {
            "$ref": "#/components/schemas/FactionResponse",
            "description": "The controlling faction"
          },
          "claimId": {
            "type": "string",
            "format": "uuid",
            "description": "Territory claim record ID"
          },
          "claimedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the territory was claimed"
          }
        }
      },
      "ConversionStep": {
        "type": "object",
        "description": "A step in the conversion path",
        "additionalProperties": false,
        "required": [
          "from",
          "to",
          "rate"
        ],
        "properties": {
          "from": {
            "type": "string",
            "description": "Source currency code"
          },
          "to": {
            "type": "string",
            "description": "Target currency code"
          },
          "rate": {
            "type": "number",
            "format": "double",
            "description": "Rate applied in this step"
          }
        }
      },
      "CoordinateMode": {
        "type": "string",
        "description": "How this location's coordinate system relates to its parent",
        "enum": [
          "inherit",
          "local",
          "portal"
        ]
      },
      "Coordinates": {
        "type": "object",
        "additionalProperties": false,
        "description": "3D spatial coordinates representing a position in the game world",
        "properties": {
          "x": {
            "type": "number",
            "description": "X coordinate position"
          },
          "y": {
            "type": "number",
            "description": "Y coordinate position"
          },
          "z": {
            "type": "number",
            "description": "Z coordinate position"
          }
        }
      },
      "CopySaveRequest": {
        "description": "Request to copy save data from one slot to another, optionally across different entities or games.",
        "type": "object",
        "required": [
          "sourceGameId",
          "sourceOwnerId",
          "sourceOwnerType",
          "sourceSlotName",
          "targetGameId",
          "targetOwnerId",
          "targetOwnerType",
          "targetSlotName"
        ],
        "properties": {
          "sourceGameId": {
            "type": "string",
            "description": "Game identifier of the source save"
          },
          "sourceOwnerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID that owns the source save"
          },
          "sourceOwnerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns the source save"
          },
          "sourceSlotName": {
            "type": "string",
            "description": "Name of the source slot to copy from"
          },
          "sourceVersion": {
            "type": "integer",
            "nullable": true,
            "description": "Version to copy (latest if null)"
          },
          "targetGameId": {
            "type": "string",
            "description": "Game identifier for the target save"
          },
          "targetOwnerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID that will own the copied save"
          },
          "targetOwnerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that will own the copied save"
          },
          "targetSlotName": {
            "type": "string",
            "description": "Name of the target slot to copy to"
          },
          "targetCategory": {
            "$ref": "#/components/schemas/SaveCategory",
            "description": "Category for new slot if auto-created"
          }
        }
      },
      "CountItemsRequest": {
        "type": "object",
        "description": "Request to count items",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "templateId"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner to count for"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Owner type"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template to count"
          }
        }
      },
      "CountItemsResponse": {
        "type": "object",
        "description": "Count result",
        "additionalProperties": false,
        "required": [
          "templateId",
          "totalQuantity",
          "stackCount"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Counted template"
          },
          "totalQuantity": {
            "type": "number",
            "format": "double",
            "description": "Total quantity"
          },
          "stackCount": {
            "type": "integer",
            "description": "Number of stacks"
          }
        }
      },
      "CoverageAnalysis": {
        "type": "object",
        "additionalProperties": false,
        "description": "Statistics about asset resolution coverage",
        "required": [
          "totalRequested",
          "resolvedViaBundles",
          "resolvedStandalone",
          "unresolvedCount"
        ],
        "properties": {
          "totalRequested": {
            "type": "integer",
            "description": "Total number of assets requested"
          },
          "resolvedViaBundles": {
            "type": "integer",
            "description": "Assets resolved through bundle downloads"
          },
          "resolvedStandalone": {
            "type": "integer",
            "description": "Assets resolved as standalone downloads"
          },
          "unresolvedCount": {
            "type": "integer",
            "description": "Assets that could not be found"
          },
          "bundleEfficiency": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "description": "Ratio of assets provided to bundle downloads (higher is better)"
          }
        }
      },
      "CreateAchievementDefinitionRequest": {
        "type": "object",
        "description": "Request to create a new achievement",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "achievementId",
          "displayName",
          "description"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service owning this achievement"
          },
          "achievementId": {
            "type": "string",
            "maxLength": 64,
            "pattern": "^[a-z0-9_-]+$",
            "description": "Unique identifier for this achievement (lowercase, no spaces)"
          },
          "displayName": {
            "type": "string",
            "maxLength": 100,
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "maxLength": 500,
            "description": "Description of how to earn this achievement"
          },
          "hiddenDescription": {
            "type": "string",
            "maxLength": 500,
            "nullable": true,
            "description": "Description shown before achievement is earned (for hidden types)"
          },
          "achievementType": {
            "$ref": "#/components/schemas/AchievementType",
            "default": "standard",
            "description": "Classification of the achievement (affects visibility and progress behavior)"
          },
          "entityTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityType"
            },
            "description": "Which entity types can earn this achievement"
          },
          "progressTarget": {
            "type": "integer",
            "nullable": true,
            "description": "Target value for progressive achievements"
          },
          "points": {
            "type": "integer",
            "default": 10,
            "description": "Point value of this achievement"
          },
          "iconUrl": {
            "type": "string",
            "nullable": true,
            "description": "URL to achievement icon"
          },
          "platforms": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Platform"
            },
            "description": "Platforms where this achievement exists"
          },
          "platformIds": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Platform-specific achievement IDs (e.g., {\"steam\": \"ACH_001\"})"
          },
          "prerequisites": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Achievement IDs that must be unlocked first"
          },
          "isActive": {
            "type": "boolean",
            "default": true,
            "description": "Whether this achievement can be earned"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional achievement-specific metadata"
          }
        }
      },
      "CreateActorTemplateRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to create a new actor template definition",
        "required": [
          "category",
          "behaviorRef"
        ],
        "properties": {
          "category": {
            "type": "string",
            "description": "Category identifier (e.g., \"npc-brain\", \"world-admin\", \"cron-cleanup\")"
          },
          "behaviorRef": {
            "type": "string",
            "description": "Reference to behavior in lib-assets (e.g., \"asset://behaviors/npc-brain-v1\")"
          },
          "configuration": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Default configuration passed to behavior execution"
          },
          "autoSpawn": {
            "description": "Auto-spawn configuration for instantiate-on-access",
            "nullable": true,
            "$ref": "#/components/schemas/AutoSpawnConfig"
          },
          "tickIntervalMs": {
            "type": "integer",
            "default": 1000,
            "description": "Milliseconds between behavior loop iterations"
          },
          "autoSaveIntervalSeconds": {
            "type": "integer",
            "default": 60,
            "description": "Seconds between automatic state saves (0 to disable)"
          },
          "maxInstancesPerNode": {
            "type": "integer",
            "default": 100,
            "description": "Maximum actors of this category per pool node"
          },
          "cognitionTemplateId": {
            "type": "string",
            "nullable": true,
            "description": "Cognition template ID for this actor type. Primary source for cognition\npipeline resolution. When null, falls back to ABML metadata, then category default.\nExamples: \"humanoid-cognition-base\", \"creature-cognition-base\", \"object-cognition-base\"\n"
          },
          "cognitionOverrides": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Static template-level cognition overrides. Applied as the first layer\nin the three-layer override composition (template \u2192 instance \u2192 ABML metadata).\n"
          }
        }
      },
      "CreateArchiveRequest": {
        "description": "Request to create a point-in-time snapshot of namespace documentation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "string",
            "description": "Owner of this archive. NOT a session ID.\nFor user-initiated archives: the accountId (UUID format).\nFor service-initiated archives: the service name (e.g., \"orchestrator\").\n"
          },
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to archive"
          },
          "description": {
            "type": "string",
            "maxLength": 500,
            "description": "Optional description for the archive"
          }
        }
      },
      "CreateArchiveResponse": {
        "description": "Response containing the created archive details",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "archiveId",
          "namespace"
        ],
        "properties": {
          "archiveId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the created archive"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace that was archived"
          },
          "bundleAssetId": {
            "type": "string",
            "format": "uuid",
            "description": "Asset ID in Asset Service"
          },
          "documentCount": {
            "type": "integer",
            "description": "Number of documents in the archive"
          },
          "sizeBytes": {
            "type": "integer",
            "description": "Total size of the archive in bytes"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the archive was created"
          },
          "commitHash": {
            "type": "string",
            "nullable": true,
            "description": "Git commit hash if namespace is bound"
          }
        }
      },
      "CreateBoardRequest": {
        "type": "object",
        "description": "Request to create a board instance for an owner entity",
        "additionalProperties": false,
        "required": [
          "ownerType",
          "ownerId",
          "boardTemplateId",
          "gameServiceId"
        ],
        "properties": {
          "ownerType": {
            "type": "string",
            "description": "Type of entity that owns this board (e.g., character, account, realm, guild)"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity that owns this board"
          },
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template to instantiate"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service context for validation"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm context for item creation. Required for character owners (validated against character realm). For realm owners, must equal ownerId. Null for realm-agnostic boards."
          }
        }
      },
      "CreateBoardTemplateRequest": {
        "type": "object",
        "description": "Request to create a new board template",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "name",
          "gridWidth",
          "gridHeight",
          "startingNodes",
          "boardContractTemplateId",
          "allowedOwnerTypes"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this board template belongs to"
          },
          "name": {
            "type": "string",
            "description": "Display name for the board template"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description of this board template"
          },
          "gridWidth": {
            "type": "integer",
            "minimum": 1,
            "maximum": 50,
            "description": "Width of the board grid (columns)"
          },
          "gridHeight": {
            "type": "integer",
            "minimum": 1,
            "maximum": 50,
            "description": "Height of the board grid (rows)"
          },
          "startingNodes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GridPosition"
            },
            "minItems": 1,
            "description": "Grid positions where unlocking can begin without adjacency"
          },
          "boardContractTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract template that controls unlock behavior (LP deduction, ability grants)"
          },
          "adjacencyMode": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AdjacencyMode"
              }
            ],
            "nullable": true,
            "description": "Grid traversal mode. Defaults to eight_way if not specified."
          },
          "allowedOwnerTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "description": "Owner types allowed to create boards from this template. Each must map to a supported container owner type (e.g., character, account, location, guild)."
          }
        }
      },
      "CreateBundleRequest": {
        "description": "Request to create a new asset bundle from multiple assets",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bundleId",
          "assetIds",
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "string",
            "description": "Owner of this bundle. NOT a session ID.\nFor user-initiated bundles: the accountId (UUID format).\nFor service-initiated bundles: the service name (e.g., \"orchestrator\").\n"
          },
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier (e.g., \"synty/polygon-adventure\", \"my-bundle-v1\")"
          },
          "version": {
            "type": "string",
            "default": "1.0.0",
            "description": "Bundle version string"
          },
          "realm": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GameRealm"
              }
            ],
            "nullable": true,
            "description": "Game realm this bundle belongs to.\nDefaults to 'shared' if not specified.\n"
          },
          "assetIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of asset IDs to include in the bundle"
          },
          "compression": {
            "$ref": "#/components/schemas/CompressionType",
            "description": "Compression algorithm to use for the bundle"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Custom metadata for the bundle (null if none)"
          }
        }
      },
      "CreateBundleResponse": {
        "description": "Response with bundle creation status and estimated size",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bundleId",
          "status",
          "estimatedSize"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier (e.g., \"synty/polygon-adventure\", \"my-bundle-v1\")"
          },
          "status": {
            "type": "string",
            "enum": [
              "queued",
              "processing",
              "ready",
              "failed"
            ],
            "description": "Bundle creation status"
          },
          "estimatedSize": {
            "type": "integer",
            "format": "int64",
            "description": "Estimated bundle size in bytes"
          }
        }
      },
      "CreateCollectionRequest": {
        "type": "object",
        "description": "Request to create a collection for an owner",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "collectionType",
          "gameServiceId"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity that owns this collection"
          },
          "ownerType": {
            "type": "string",
            "description": "Entity type discriminator (e.g., account, character)"
          },
          "collectionType": {
            "$ref": "#/components/schemas/CollectionType",
            "description": "Type of collection to create"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this collection is scoped to"
          }
        }
      },
      "CreateContainerRequest": {
        "type": "object",
        "description": "Request to create a new container",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "containerType",
          "constraintModel"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity that owns this container"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Type of the owning entity"
          },
          "containerType": {
            "type": "string",
            "maxLength": 64,
            "description": "Game-defined container type (e.g., inventory, bank, equipment_slot)"
          },
          "constraintModel": {
            "$ref": "#/components/schemas/ContainerConstraintModel",
            "description": "Capacity constraint model"
          },
          "isEquipmentSlot": {
            "type": "boolean",
            "default": false,
            "description": "Whether this container is an equipment slot"
          },
          "equipmentSlotName": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Equipment slot name if isEquipmentSlot is true"
          },
          "maxSlots": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum slots for slot-based containers"
          },
          "maxWeight": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Maximum weight capacity"
          },
          "gridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "Internal grid width for grid containers"
          },
          "gridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "Internal grid height for grid containers"
          },
          "maxVolume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Maximum volume for volumetric containers"
          },
          "parentContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Parent container ID for nested containers"
          },
          "canContainContainers": {
            "type": "boolean",
            "default": false,
            "description": "Whether this container can hold other containers"
          },
          "maxNestingDepth": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum nesting depth (null uses global default)"
          },
          "selfWeight": {
            "type": "number",
            "format": "double",
            "default": 0,
            "description": "Empty container weight"
          },
          "weightContribution": {
            "$ref": "#/components/schemas/WeightContribution",
            "description": "How weight propagates to parent"
          },
          "slotCost": {
            "type": "integer",
            "default": 1,
            "description": "Slots used in slot-based parent"
          },
          "parentGridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "Width footprint in grid-based parent"
          },
          "parentGridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "Height footprint in grid-based parent"
          },
          "parentVolume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Volume footprint in volumetric parent"
          },
          "allowedCategories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Allowed item categories (null allows all)"
          },
          "forbiddenCategories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Forbidden item categories"
          },
          "allowedTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Required item tags for placement"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm this container belongs to (null for account-level)"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Container tags for filtering"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "description": "Game-specific container data"
          }
        }
      },
      "CreateContractInstanceRequest": {
        "type": "object",
        "description": "Request to create a contract instance",
        "additionalProperties": false,
        "required": [
          "templateId",
          "parties"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template to create instance from"
          },
          "parties": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContractPartyInput"
            },
            "minItems": 2,
            "description": "Parties to this contract"
          },
          "terms": {
            "$ref": "#/components/schemas/ContractTerms",
            "nullable": true,
            "description": "Terms overriding template defaults"
          },
          "effectiveFrom": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When contract becomes active (null for immediate)"
          },
          "effectiveUntil": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When contract expires (null for perpetual)"
          },
          "escrowIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "Related escrow IDs"
          },
          "gameMetadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Instance-level game metadata"
          }
        }
      },
      "CreateDefinitionRequest": {
        "type": "object",
        "description": "Request to create a map definition",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "description": "Description of the map template",
            "nullable": true
          },
          "layers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LayerDefinition"
            },
            "description": "Layer configurations",
            "nullable": true
          },
          "defaultBounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Default bounds for regions using this definition",
            "nullable": true
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "description": "Additional metadata",
            "nullable": true
          }
        }
      },
      "CreateDeityRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to create a new deity entity",
        "required": [
          "gameServiceId",
          "code",
          "displayName",
          "description",
          "domains",
          "personalityTraits"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this deity belongs to"
          },
          "code": {
            "type": "string",
            "description": "Unique code for this deity within the game service (e.g., mnemosyne, nexius)"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable display name"
          },
          "description": {
            "type": "string",
            "description": "Description of the deity's nature and role"
          },
          "domains": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/DomainInfluence"
            },
            "description": "Domain influences (at least one required)"
          },
          "personalityTraits": {
            "$ref": "#/components/schemas/DeityPersonalityTraits",
            "description": "Personality traits influencing behavior decisions"
          },
          "maxAttentionSlots": {
            "type": "integer",
            "minimum": 1,
            "default": 10,
            "description": "Maximum characters this deity can actively monitor simultaneously"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Home realm for this deity (null if not realm-bound)"
          }
        }
      },
      "CreateEntryTemplateRequest": {
        "type": "object",
        "description": "Request to create a new entry template",
        "additionalProperties": false,
        "required": [
          "code",
          "collectionType",
          "gameServiceId",
          "displayName",
          "itemTemplateId"
        ],
        "properties": {
          "code": {
            "type": "string",
            "maxLength": 128,
            "description": "Unique code within this collection type and game service"
          },
          "collectionType": {
            "$ref": "#/components/schemas/CollectionType",
            "description": "Type of collection this entry belongs to"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this entry template is scoped to"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable display name for this entry"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Category within the collection type (e.g., boss, ambient, battle)"
          },
          "tags": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Searchable tags for filtering entries"
          },
          "assetId": {
            "type": "string",
            "nullable": true,
            "description": "Primary asset identifier for this entry (audio, video, image)"
          },
          "thumbnailAssetId": {
            "type": "string",
            "nullable": true,
            "description": "Thumbnail or preview asset identifier"
          },
          "unlockHint": {
            "type": "string",
            "nullable": true,
            "description": "Hint text shown to users about how to unlock this entry"
          },
          "hideWhenLocked": {
            "type": "boolean",
            "default": false,
            "description": "Whether this entry should be hidden from users until unlocked (spoiler protection)"
          },
          "itemTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Item template used when granting this entry to a collection"
          },
          "discoveryLevels": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/DiscoveryLevel"
            },
            "description": "Progressive discovery levels for bestiary-style entries"
          },
          "themes": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Theme tags for content selection matching (e.g., battle, peaceful, forest)"
          },
          "duration": {
            "type": "string",
            "nullable": true,
            "description": "Duration of the content (ISO 8601 duration or human-readable)"
          },
          "loopPoint": {
            "type": "string",
            "nullable": true,
            "description": "Loop point for seamless playback (ISO 8601 duration or timestamp)"
          },
          "composer": {
            "type": "string",
            "nullable": true,
            "description": "Composer or creator name"
          }
        }
      },
      "CreateEscrowPartyInput": {
        "type": "object",
        "description": "Input for defining a party in escrow creation",
        "required": [
          "partyId",
          "partyType",
          "role"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party entity ID"
          },
          "partyType": {
            "description": "Type of entity (Account, Character, etc.)",
            "$ref": "#/components/schemas/EntityType"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Display name"
          },
          "role": {
            "$ref": "#/components/schemas/EscrowPartyRole",
            "description": "Role of this party in the escrow"
          },
          "consentRequired": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether consent is required (defaults based on role)"
          },
          "walletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Party wallet for currency operations"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Party container for item operations"
          }
        }
      },
      "CreateEscrowRequest": {
        "type": "object",
        "description": "Request to create a new escrow agreement",
        "required": [
          "escrowType",
          "trustMode",
          "parties",
          "expectedDeposits",
          "idempotencyKey"
        ],
        "properties": {
          "escrowType": {
            "$ref": "#/components/schemas/EscrowType",
            "description": "Type of escrow agreement"
          },
          "trustMode": {
            "$ref": "#/components/schemas/EscrowTrustMode",
            "description": "Trust mode for the escrow"
          },
          "trustedPartyId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "For single_party_trusted mode"
          },
          "trustedPartyType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EntityType"
              }
            ],
            "nullable": true,
            "description": "Type of the trusted party"
          },
          "parties": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateEscrowPartyInput"
            },
            "description": "Parties in the escrow"
          },
          "expectedDeposits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExpectedDepositInput"
            },
            "description": "Expected deposits from parties"
          },
          "releaseAllocations": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/ReleaseAllocationInput"
            },
            "description": "Optional explicit release allocations"
          },
          "boundContractId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract governing this escrow"
          },
          "requiredConsentsForRelease": {
            "type": "integer",
            "nullable": true,
            "description": "Number of consents required (-1 for all)"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Optional expiration time"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "Reference type (trade, auction, etc.)"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference entity ID"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Application metadata"
          },
          "releaseMode": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ReleaseMode"
              }
            ],
            "nullable": true,
            "description": "How release confirmation is handled. Defaults to service_only if not specified.\nOnly applies to unbound escrows; contract-bound escrows follow contract fulfillment.\n"
          },
          "refundMode": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RefundMode"
              }
            ],
            "nullable": true,
            "description": "How refund confirmation is handled. Defaults to immediate if not specified."
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key for this operation"
          }
        }
      },
      "CreateEscrowResponse": {
        "type": "object",
        "description": "Response from creating an escrow agreement",
        "required": [
          "escrow",
          "depositTokens"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Created escrow agreement"
          },
          "depositTokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartyToken"
            },
            "description": "Deposit tokens for each party (full_consent mode)"
          }
        }
      },
      "CreateFactionRequest": {
        "type": "object",
        "description": "Request to create a new faction",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "name",
          "code",
          "realmId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service to scope this faction to"
          },
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 256,
            "description": "Display name for the faction"
          },
          "code": {
            "type": "string",
            "minLength": 1,
            "maxLength": 128,
            "description": "Unique code within the game service (e.g., \"thieves_guild\")"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "maxLength": 2048,
            "description": "Human-readable description of the faction"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm this faction belongs to"
          },
          "parentFactionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Parent faction for hierarchy (null for top-level)"
          }
        }
      },
      "CreateHoldRequest": {
        "type": "object",
        "description": "Request to create an authorization hold",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "expiresAt",
          "idempotencyKey"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet to hold funds in"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to hold"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to reserve"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the hold auto-releases"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "Reference type (e.g. dining, hotel, gas)"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference entity ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Idempotency key"
          }
        }
      },
      "CreateItemInstanceRequest": {
        "type": "object",
        "description": "Request to create a new item instance",
        "additionalProperties": false,
        "required": [
          "templateId",
          "containerId",
          "realmId",
          "quantity",
          "originType"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template to instantiate"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container to place the item in"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm this instance exists in"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "minimum": 0,
            "exclusiveMinimum": true,
            "description": "Item quantity (respects template's quantityModel)"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Slot position in slot-based containers"
          },
          "slotX": {
            "type": "integer",
            "nullable": true,
            "description": "X position in grid-based containers"
          },
          "slotY": {
            "type": "integer",
            "nullable": true,
            "description": "Y position in grid-based containers"
          },
          "rotated": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether item is rotated in grid"
          },
          "currentDurability": {
            "type": "integer",
            "nullable": true,
            "description": "Initial durability (defaults to template's maxDurability)"
          },
          "customStats": {
            "type": "object",
            "nullable": true,
            "description": "Instance-specific stat modifications"
          },
          "customName": {
            "type": "string",
            "maxLength": 128,
            "nullable": true,
            "description": "Player-assigned custom name"
          },
          "instanceMetadata": {
            "type": "object",
            "nullable": true,
            "description": "Any other instance-specific data"
          },
          "originType": {
            "$ref": "#/components/schemas/ItemOriginType",
            "description": "How this item instance was created"
          },
          "originId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Source entity ID (quest ID, creature ID, etc.)"
          },
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Bound contract instance ID. For persistent item-contract bindings (status effects,\nlicenses, memberships), this references the controlling contract. NULL for items\nwithout persistent contract relationships.\n"
          },
          "contractBindingType": {
            "$ref": "#/components/schemas/ContractBindingType",
            "nullable": true,
            "description": "Type of contract binding. When contractInstanceId is provided, this indicates\nwhether it's a lifecycle binding (managed externally) or session binding\n(managed by Item service). Defaults to 'lifecycle' when contractInstanceId is set.\n"
          }
        }
      },
      "CreateItemTemplateRequest": {
        "type": "object",
        "description": "Request to create a new item template",
        "additionalProperties": false,
        "required": [
          "code",
          "gameId",
          "name",
          "category",
          "quantityModel",
          "maxStackSize",
          "scope"
        ],
        "properties": {
          "code": {
            "type": "string",
            "maxLength": 64,
            "pattern": "^[a-z][a-z0-9_]{1,63}$",
            "description": "Unique code within the game (immutable after creation)"
          },
          "gameId": {
            "type": "string",
            "maxLength": 64,
            "description": "Game service this template belongs to (immutable after creation)"
          },
          "name": {
            "type": "string",
            "maxLength": 128,
            "description": "Human-readable display name"
          },
          "description": {
            "type": "string",
            "maxLength": 1000,
            "nullable": true,
            "description": "Detailed description of this item"
          },
          "category": {
            "$ref": "#/components/schemas/ItemCategory",
            "description": "Item classification category"
          },
          "subcategory": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Game-defined subcategory (e.g., sword, helmet)"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string",
              "maxLength": 32
            },
            "nullable": true,
            "description": "Flexible filtering tags"
          },
          "rarity": {
            "$ref": "#/components/schemas/ItemRarity",
            "nullable": true,
            "description": "Item rarity tier (defaults to config when not specified)"
          },
          "quantityModel": {
            "$ref": "#/components/schemas/QuantityModel",
            "description": "How quantities are tracked for this item"
          },
          "maxStackSize": {
            "type": "integer",
            "minimum": 1,
            "description": "Maximum stack size (1 for unique items)"
          },
          "unitOfMeasure": {
            "type": "string",
            "maxLength": 32,
            "nullable": true,
            "description": "Unit for continuous quantities (e.g., liters, kg)"
          },
          "weightPrecision": {
            "$ref": "#/components/schemas/WeightPrecision",
            "nullable": true,
            "description": "Precision for weight values (defaults to config when not specified)"
          },
          "weight": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Weight value (interpreted per weightPrecision)"
          },
          "volume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Volume for volumetric inventories"
          },
          "gridWidth": {
            "type": "integer",
            "minimum": 1,
            "nullable": true,
            "description": "Width in grid-based inventories"
          },
          "gridHeight": {
            "type": "integer",
            "minimum": 1,
            "nullable": true,
            "description": "Height in grid-based inventories"
          },
          "canRotate": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether item can be rotated in grid"
          },
          "baseValue": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Reference price for vendors/markets"
          },
          "tradeable": {
            "type": "boolean",
            "default": true,
            "description": "Whether item can be traded/auctioned"
          },
          "destroyable": {
            "type": "boolean",
            "default": true,
            "description": "Whether item can be destroyed/discarded"
          },
          "soulboundType": {
            "$ref": "#/components/schemas/SoulboundType",
            "nullable": true,
            "description": "Binding behavior when item is acquired (defaults to config when not specified)"
          },
          "hasDurability": {
            "type": "boolean",
            "default": false,
            "description": "Whether item has durability tracking"
          },
          "maxDurability": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum durability value"
          },
          "scope": {
            "$ref": "#/components/schemas/ItemScope",
            "description": "Realm availability scope"
          },
          "availableRealms": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "Realm IDs where this template is available (for realm_specific or multi_realm)"
          },
          "stats": {
            "type": "object",
            "nullable": true,
            "description": "Game-defined stats (e.g., attack, defense)"
          },
          "effects": {
            "type": "object",
            "nullable": true,
            "description": "Game-defined effects (e.g., on_use, on_equip)"
          },
          "requirements": {
            "type": "object",
            "nullable": true,
            "description": "Game-defined requirements (e.g., level, strength)"
          },
          "display": {
            "type": "object",
            "nullable": true,
            "description": "Display properties (e.g., iconId, modelId)"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "description": "Any other game-specific data"
          },
          "useBehaviorContractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract template ID for executable item behavior. When set, the item can be \"used\" via /item/use, which creates a transient contract instance, completes its \"use\" milestone (triggering prebound APIs), and optionally consumes the item."
          },
          "canUseBehaviorContractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract template for pre-use validation. When set, /item/use first executes\nthis contract's \"validate\" milestone before proceeding. If validation fails,\nthe item is NOT consumed and the main use behavior is NOT executed.\n"
          },
          "onUseFailedBehaviorContractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract template executed when the main use behavior fails. Enables cleanup,\npartial rollback, or consequence application. Item is NOT consumed on failure\nregardless of this template's outcome.\n"
          },
          "itemUseBehavior": {
            "$ref": "#/components/schemas/ItemUseBehavior",
            "nullable": true,
            "description": "How the item should behave when used (defaults to destroy_on_success)"
          },
          "canUseBehavior": {
            "$ref": "#/components/schemas/CanUseBehavior",
            "nullable": true,
            "description": "How CanUse validation failures should be handled (defaults to block)"
          }
        }
      },
      "CreateLeaderboardDefinitionRequest": {
        "type": "object",
        "description": "Request to create a new leaderboard",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId",
          "displayName"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service owning this leaderboard"
          },
          "leaderboardId": {
            "type": "string",
            "maxLength": 64,
            "pattern": "^[a-z0-9_-]+$",
            "description": "Unique identifier for this leaderboard (lowercase, no spaces)"
          },
          "displayName": {
            "type": "string",
            "maxLength": 100,
            "description": "Human-readable name for the leaderboard"
          },
          "description": {
            "type": "string",
            "maxLength": 500,
            "nullable": true,
            "description": "Description of what this leaderboard tracks"
          },
          "entityTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityType"
            },
            "description": "Which entity types can appear on this leaderboard"
          },
          "sortOrder": {
            "$ref": "#/components/schemas/SortOrder",
            "default": "descending",
            "description": "Sort order (descending for high scores, ascending for times)"
          },
          "updateMode": {
            "$ref": "#/components/schemas/UpdateMode",
            "default": "replace",
            "description": "How to handle score updates"
          },
          "isSeasonal": {
            "type": "boolean",
            "default": false,
            "description": "Whether this leaderboard resets each season"
          },
          "isPublic": {
            "type": "boolean",
            "default": true,
            "description": "Whether the leaderboard is publicly visible"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional leaderboard-specific metadata"
          }
        }
      },
      "CreateMetabundleRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to create a metabundle from source bundles and/or standalone assets.\nAt least one of sourceBundleIds or standaloneAssetIds must be provided.\nThis enables packaging behaviors/scripts with 3D assets as a complete unit.\n",
        "required": [
          "metabundleId",
          "owner",
          "realm"
        ],
        "properties": {
          "metabundleId": {
            "type": "string",
            "description": "Human-readable identifier for the new metabundle (e.g., \"game-assets-v1\")"
          },
          "sourceBundleIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Human-readable source bundle IDs (e.g., \"synty/polygon-adventure\") to pull assets from.\nCan cherry-pick specific assets using assetFilter, or include all if assetFilter is null.\n"
          },
          "standaloneAssetIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Individual asset IDs (not in bundles) to include directly.\nUseful for including behaviors, scripts, or metadata files\nalongside bundled 3D assets.\n"
          },
          "version": {
            "type": "string",
            "default": "1.0.0",
            "description": "Metabundle version string"
          },
          "owner": {
            "type": "string",
            "description": "Owner of this metabundle. NOT a session ID.\nFor user-initiated: the accountId (UUID format).\nFor service-initiated: the service name.\n"
          },
          "realm": {
            "$ref": "#/components/schemas/GameRealm",
            "description": "Game realm for this metabundle"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description"
          },
          "assetFilter": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Optional subset of asset IDs to include FROM SOURCE BUNDLES.\nIf null, all assets from source bundles are included.\nStandalone assets are always included regardless of this filter.\n"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Custom metadata for the metabundle"
          }
        }
      },
      "CreateMetabundleResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response from metabundle creation.\nFor synchronous creation (small jobs): status=ready with downloadUrl.\nFor async creation (large jobs): status=queued with jobId for polling.\n",
        "required": [
          "metabundleId",
          "status",
          "assetCount",
          "sizeBytes"
        ],
        "properties": {
          "metabundleId": {
            "type": "string",
            "description": "Human-readable metabundle identifier"
          },
          "jobId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Job ID for async processing. Only present when status is 'queued' or 'processing'.\nUse /bundles/job/status to poll for completion, or wait for\nMetabundleCreationCompleteEvent via WebSocket.\n"
          },
          "status": {
            "type": "string",
            "enum": [
              "queued",
              "processing",
              "ready",
              "failed"
            ],
            "description": "Creation status.\n- queued: Job accepted for async processing (poll with jobId)\n- processing: Job is actively running\n- ready: Metabundle created and available for download\n- failed: Creation failed (see conflicts for details)\n"
          },
          "downloadUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "Pre-signed download URL (only present when status is 'ready')"
          },
          "assetCount": {
            "type": "integer",
            "description": "Number of assets in the metabundle"
          },
          "standaloneAssetCount": {
            "type": "integer",
            "nullable": true,
            "description": "Number of standalone assets included directly (not from bundles)"
          },
          "sizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Total size in bytes"
          },
          "sourceBundles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SourceBundleReference"
            },
            "description": "Provenance data for the metabundle"
          },
          "conflicts": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/AssetConflict"
            },
            "description": "Present if creation failed due to asset conflicts"
          }
        }
      },
      "CreateQuestDefinitionRequest": {
        "type": "object",
        "description": "Request to create a new quest definition with objectives and rewards",
        "additionalProperties": false,
        "required": [
          "code",
          "name",
          "objectives"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Unique quest code (uppercase, underscores)"
          },
          "name": {
            "type": "string",
            "description": "Display name of the quest"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Quest description for players"
          },
          "category": {
            "description": "Quest category for organization",
            "$ref": "#/components/schemas/QuestCategory"
          },
          "difficulty": {
            "description": "Difficulty rating of the quest",
            "$ref": "#/components/schemas/QuestDifficulty"
          },
          "levelRequirement": {
            "type": "integer",
            "nullable": true,
            "description": "Minimum character level required"
          },
          "repeatable": {
            "type": "boolean",
            "default": false,
            "description": "Whether quest can be repeated"
          },
          "cooldownSeconds": {
            "type": "integer",
            "nullable": true,
            "description": "Cooldown in seconds for repeatable quests"
          },
          "deadlineSeconds": {
            "type": "integer",
            "nullable": true,
            "description": "Time limit in seconds (null for no deadline)"
          },
          "maxQuestors": {
            "type": "integer",
            "default": 1,
            "description": "Maximum party members (1 for solo)"
          },
          "objectives": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ObjectiveDefinition"
            },
            "description": "List of quest objectives (ordered)"
          },
          "prerequisites": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/PrerequisiteDefinition"
            },
            "description": "Requirements to accept the quest"
          },
          "rewards": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/RewardDefinition"
            },
            "description": "Rewards granted on completion"
          },
          "tags": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Tags for filtering and organization"
          },
          "questGiverCharacterId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Character who offers this quest (null for any)"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this quest belongs to"
          }
        }
      },
      "CreateRoomRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to create a new chat room",
        "required": [
          "roomTypeCode"
        ],
        "properties": {
          "roomTypeCode": {
            "type": "string",
            "description": "Room type code determining message format and validation"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Connect session ID for companion rooms"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Governing contract ID for lifecycle management"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable room name"
          },
          "maxParticipants": {
            "type": "integer",
            "nullable": true,
            "description": "Participant limit override (null uses type default)"
          },
          "contractFulfilledAction": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContractRoomAction"
              }
            ],
            "nullable": true,
            "description": "Action when governing contract is fulfilled (null uses service default)"
          },
          "contractBreachAction": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContractRoomAction"
              }
            ],
            "nullable": true,
            "description": "Action when governing contract is breached (null uses service default)"
          },
          "contractTerminatedAction": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContractRoomAction"
              }
            ],
            "nullable": true,
            "description": "Action when governing contract is terminated (null uses service default)"
          },
          "contractExpiredAction": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContractRoomAction"
              }
            ],
            "nullable": true,
            "description": "Action when governing contract expires (null uses service default)"
          },
          "metadata": {
            "type": "string",
            "nullable": true,
            "description": "Arbitrary JSON metadata for client rendering hints"
          }
        }
      },
      "CreateScenarioDefinitionRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to create a scenario definition",
        "required": [
          "code",
          "name",
          "triggerConditions",
          "phases"
        ],
        "properties": {
          "code": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Human-readable scenario code (uppercase with underscores)"
          },
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 200,
            "description": "Display name for the scenario"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Detailed scenario description"
          },
          "triggerConditions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TriggerCondition"
            },
            "minItems": 1,
            "description": "Conditions that must ALL be met to trigger"
          },
          "phases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScenarioPhase"
            },
            "minItems": 1,
            "description": "Execution phases in order"
          },
          "mutations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScenarioMutation"
            },
            "nullable": true,
            "description": "State mutations to apply on completion"
          },
          "questHooks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScenarioQuestHook"
            },
            "nullable": true,
            "description": "Quests to spawn on completion"
          },
          "cooldownSeconds": {
            "type": "integer",
            "minimum": 0,
            "nullable": true,
            "description": "Per-character cooldown in seconds"
          },
          "exclusivityTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Tags for mutual exclusivity checking"
          },
          "priority": {
            "type": "integer",
            "default": 0,
            "description": "Higher priority scenarios are checked first"
          },
          "enabled": {
            "type": "boolean",
            "default": true,
            "description": "Whether scenario can be triggered"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm scope (null means all realms)"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game service scope (null means all games)"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Classification tags for filtering"
          }
        }
      },
      "CreateSceneRequest": {
        "type": "object",
        "description": "Request to create a new scene",
        "required": [
          "scene"
        ],
        "properties": {
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "The scene document to create"
          }
        }
      },
      "CreateSeedRequest": {
        "type": "object",
        "description": "Request to create a new seed.",
        "required": [
          "ownerId",
          "ownerType",
          "seedTypeCode"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "The entity that owns this seed."
          },
          "ownerType": {
            "type": "string",
            "description": "Entity type discriminator (e.g., \"account\", \"actor\", \"realm\", \"character\", \"relationship\").\n"
          },
          "seedTypeCode": {
            "type": "string",
            "description": "Registered seed type code (e.g., \"guardian\", \"dungeon_core\")."
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game service this seed is scoped to. Null for cross-game seed types that are not scoped to any single game service."
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable name. Auto-generated if omitted."
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Seed-type-specific initial metadata."
          }
        }
      },
      "CreateSlotRequest": {
        "description": "Request to create a new save slot for an entity.",
        "type": "object",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName",
          "category"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "minLength": 1,
            "maxLength": 32,
            "pattern": "^[a-z][a-z0-9-]*$",
            "description": "Game identifier for namespace isolation (e.g., \"game-1\", \"game-2\")"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64,
            "pattern": "^[a-z0-9]([a-z0-9-]*[a-z0-9])?$",
            "description": "Slot name (lowercase alphanumeric with hyphens, single char like \"q\" allowed)"
          },
          "category": {
            "$ref": "#/components/schemas/SaveCategory",
            "description": "Save category determining retention and cleanup behavior"
          },
          "maxVersions": {
            "type": "integer",
            "nullable": true,
            "minimum": 1,
            "maximum": 100,
            "description": "Override default max versions for this category (null = use category default)"
          },
          "retentionDays": {
            "type": "integer",
            "nullable": true,
            "minimum": 1,
            "description": "Days to retain versions (null = indefinite)"
          },
          "compressionType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CompressionType"
              }
            ],
            "nullable": true,
            "description": "Compression algorithm to use for save data (null = use category default)"
          },
          "tags": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string",
              "maxLength": 32
            },
            "maxItems": 20,
            "description": "Searchable tags for slot categorization (e.g., \"boss-fight\", \"chapter-3\")"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom key-value metadata for the slot"
          }
        }
      },
      "CreateStatusTemplateRequest": {
        "type": "object",
        "description": "Request to create a new status template",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "code",
          "displayName",
          "description",
          "category",
          "stackable",
          "itemTemplateId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this template is scoped to"
          },
          "code": {
            "type": "string",
            "maxLength": 128,
            "description": "Unique status code within this game service"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable display name for this status effect"
          },
          "description": {
            "type": "string",
            "description": "Detailed description of what this status effect does"
          },
          "category": {
            "$ref": "#/components/schemas/StatusCategory",
            "description": "Classification of this status effect"
          },
          "stackable": {
            "type": "boolean",
            "description": "Whether this status can stack (multiple applications)"
          },
          "maxStacks": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Maximum number of stacks when stackable is true"
          },
          "stackBehavior": {
            "$ref": "#/components/schemas/StackBehavior",
            "description": "How multiple applications interact (defaults to ignore)"
          },
          "contractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract template for lifecycle management (null for simple TTL statuses). When set, granting this status creates a contract instance with milestones matching the template's defined structure. The contract template should define milestones for status lifecycle phases (e.g., activation, expiration). Template values receive the grant request's metadata map, allowing callers to parameterize contract behavior per grant."
          },
          "itemTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Item template used when granting this status as an inventory item"
          },
          "defaultDurationSeconds": {
            "type": "integer",
            "minimum": 1,
            "nullable": true,
            "description": "Default duration in seconds for non-contract TTL management (null for permanent)"
          },
          "iconAssetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Asset identifier for this status effect's icon"
          }
        }
      },
      "CreateTemplateRequest": {
        "type": "object",
        "description": "Request to create a scenario template",
        "required": [
          "code",
          "displayName",
          "description",
          "category",
          "domainWeights"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Unique template code for reference"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable template name"
          },
          "description": {
            "type": "string",
            "description": "Template description"
          },
          "category": {
            "$ref": "#/components/schemas/ScenarioCategory",
            "description": "Primary gameplay category"
          },
          "subcategory": {
            "type": "string",
            "nullable": true,
            "description": "Optional subcategory within the primary category"
          },
          "domainWeights": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DomainWeight"
            },
            "description": "Growth domain weights awarded on completion"
          },
          "minGrowthPhase": {
            "type": "string",
            "nullable": true,
            "description": "Minimum seed growth phase for soft-gating scenario availability"
          },
          "connectivityMode": {
            "$ref": "#/components/schemas/ConnectivityMode",
            "description": "How this scenario connects to the game world",
            "default": "Isolated"
          },
          "allowedPhases": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/DeploymentPhase"
            },
            "description": "Deployment phases in which this template is available. Null or empty means available in all phases."
          },
          "maxConcurrentInstances": {
            "type": "integer",
            "default": 100,
            "description": "Maximum concurrent active instances of this template"
          },
          "estimatedDurationMinutes": {
            "type": "integer",
            "nullable": true,
            "description": "Estimated scenario duration in minutes"
          },
          "prerequisites": {
            "$ref": "#/components/schemas/ScenarioPrerequisites",
            "nullable": true,
            "description": "Requirements that must be met before entering"
          },
          "chaining": {
            "$ref": "#/components/schemas/ScenarioChaining",
            "nullable": true,
            "description": "Chaining configuration"
          },
          "multiplayer": {
            "$ref": "#/components/schemas/ScenarioMultiplayer",
            "nullable": true,
            "description": "Multiplayer support configuration"
          },
          "content": {
            "$ref": "#/components/schemas/ScenarioContent",
            "nullable": true,
            "description": "Game content references"
          }
        }
      },
      "CreateWalletRequest": {
        "type": "object",
        "description": "Request to create a new wallet",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner entity ID"
          },
          "ownerType": {
            "$ref": "#/components/schemas/WalletOwnerType",
            "description": "Type of owner entity"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm ID for realm-scoped wallets (null for global)"
          }
        }
      },
      "CreditCurrencyRequest": {
        "type": "object",
        "description": "Request to credit currency to a wallet",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "transactionType",
          "idempotencyKey"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Target wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to credit"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to credit (must be positive)"
          },
          "transactionType": {
            "$ref": "#/components/schemas/TransactionType",
            "description": "Must be a faucet type (mint, quest_reward, loot_drop, etc.)"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "What triggered this transaction (quest, admin, etc.)"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference entity ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Unique key to prevent duplicate processing"
          },
          "bypassEarnCap": {
            "type": "boolean",
            "default": false,
            "description": "Skip earn cap enforcement (admin use)"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Free-form transaction metadata"
          }
        }
      },
      "CreditCurrencyResponse": {
        "type": "object",
        "description": "Result of credit operation",
        "additionalProperties": false,
        "required": [
          "transaction",
          "newBalance",
          "earnCapApplied",
          "walletCapApplied"
        ],
        "properties": {
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Created transaction record"
          },
          "newBalance": {
            "type": "number",
            "format": "double",
            "description": "Balance after credit"
          },
          "earnCapApplied": {
            "type": "boolean",
            "description": "Whether earn cap limited the credit"
          },
          "earnCapAmountLimited": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Amount reduced by earn cap"
          },
          "walletCapApplied": {
            "type": "boolean",
            "description": "Whether wallet cap limited the credit"
          },
          "walletCapAmountLost": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Amount lost due to wallet cap (cap_and_lose behavior)"
          }
        }
      },
      "CreditDivinityRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to credit divinity to a deity's wallet",
        "required": [
          "deityId",
          "amount",
          "source"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity to credit"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "minimum": 0.0,
            "exclusiveMinimum": true,
            "description": "Amount of divinity to credit (must be positive)"
          },
          "source": {
            "type": "string",
            "description": "Source of the divinity gain (e.g., mortal_action, domain_event, manual)"
          },
          "sourceEventId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Triggering event identifier if applicable"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description of the credit reason"
          }
        }
      },
      "CureBreachRequest": {
        "type": "object",
        "description": "Request to cure a breach",
        "additionalProperties": false,
        "required": [
          "breachId"
        ],
        "properties": {
          "breachId": {
            "type": "string",
            "format": "uuid",
            "description": "Breach to cure"
          },
          "cureEvidence": {
            "type": "string",
            "maxLength": 2000,
            "nullable": true,
            "description": "Evidence of cure"
          }
        }
      },
      "CurrencyDefinitionResponse": {
        "type": "object",
        "description": "Currency definition details",
        "additionalProperties": false,
        "required": [
          "definitionId",
          "code",
          "name",
          "scope",
          "precision",
          "transferable",
          "tradeable",
          "autogainEnabled",
          "expires",
          "linkedToItem",
          "isBaseCurrency",
          "isActive",
          "createdAt"
        ],
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique definition identifier"
          },
          "code": {
            "type": "string",
            "description": "Unique currency code"
          },
          "name": {
            "type": "string",
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Detailed description"
          },
          "scope": {
            "$ref": "#/components/schemas/CurrencyScope",
            "description": "Realm availability scope"
          },
          "realmsAvailable": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "Available realm IDs"
          },
          "precision": {
            "$ref": "#/components/schemas/CurrencyPrecision",
            "description": "Decimal precision"
          },
          "transferable": {
            "type": "boolean",
            "description": "Whether transferable between wallets"
          },
          "tradeable": {
            "type": "boolean",
            "description": "Whether usable in trades"
          },
          "allowNegative": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether negative balance allowed (null uses plugin default)"
          },
          "perWalletCap": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Maximum per-wallet balance"
          },
          "capOverflowBehavior": {
            "$ref": "#/components/schemas/CapOverflowBehavior",
            "nullable": true,
            "description": "Overflow behavior when cap exceeded"
          },
          "globalSupplyCap": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Global supply cap"
          },
          "dailyEarnCap": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Daily earn cap"
          },
          "weeklyEarnCap": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Weekly earn cap"
          },
          "earnCapResetTime": {
            "type": "string",
            "nullable": true,
            "description": "Earn cap reset time"
          },
          "autogainEnabled": {
            "type": "boolean",
            "description": "Whether autogain is enabled"
          },
          "autogainMode": {
            "$ref": "#/components/schemas/AutogainMode",
            "nullable": true,
            "description": "Autogain calculation mode"
          },
          "autogainAmount": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Autogain amount per interval"
          },
          "autogainInterval": {
            "type": "string",
            "nullable": true,
            "description": "Autogain interval duration"
          },
          "autogainCap": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Autogain balance cap"
          },
          "expires": {
            "type": "boolean",
            "description": "Whether currency can expire"
          },
          "expirationPolicy": {
            "$ref": "#/components/schemas/ExpirationPolicy",
            "nullable": true,
            "description": "Expiration policy"
          },
          "expirationDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Fixed expiration date"
          },
          "expirationDuration": {
            "type": "string",
            "nullable": true,
            "description": "Expiration duration"
          },
          "seasonId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Season ID for expiration"
          },
          "linkedToItem": {
            "type": "boolean",
            "description": "Whether linked to inventory item"
          },
          "linkedItemTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Linked item template ID"
          },
          "linkageMode": {
            "$ref": "#/components/schemas/ItemLinkageMode",
            "nullable": true,
            "description": "Item linkage mode"
          },
          "isBaseCurrency": {
            "type": "boolean",
            "description": "Whether this is the base currency"
          },
          "exchangeRateToBase": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Exchange rate to base currency"
          },
          "exchangeRateUpdatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When exchange rate was last updated"
          },
          "iconAssetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Icon asset ID"
          },
          "displayFormat": {
            "type": "string",
            "nullable": true,
            "description": "Display format string"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether definition is active"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "modifiedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last modification timestamp"
          }
        }
      },
      "CurrencyPrecision": {
        "type": "string",
        "description": "How the currency handles decimal values (immutable after creation)",
        "enum": [
          "integer",
          "decimal_2",
          "decimal_4",
          "decimal_8",
          "decimal_full",
          "big_integer"
        ]
      },
      "CurrencyScope": {
        "type": "string",
        "description": "Scope of currency availability across realms",
        "enum": [
          "global",
          "realm_specific",
          "multi_realm"
        ]
      },
      "CurrencyTransactionRecord": {
        "type": "object",
        "description": "Immutable record of a currency transaction",
        "additionalProperties": false,
        "required": [
          "transactionId",
          "currencyDefinitionId",
          "amount",
          "transactionType",
          "idempotencyKey",
          "timestamp"
        ],
        "properties": {
          "transactionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique transaction identifier"
          },
          "sourceWalletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Source wallet (null for faucets)"
          },
          "targetWalletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Target wallet (null for sinks)"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency definition ID"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Transaction amount (always positive)"
          },
          "transactionType": {
            "$ref": "#/components/schemas/TransactionType",
            "description": "Transaction classification"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "What triggered this transaction"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference entity ID"
          },
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Associated escrow ID"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When transaction occurred"
          },
          "sourceBalanceBefore": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Source balance before transaction"
          },
          "sourceBalanceAfter": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Source balance after transaction"
          },
          "targetBalanceBefore": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Target balance before transaction"
          },
          "targetBalanceAfter": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Target balance after transaction"
          },
          "autogainPeriodsApplied": {
            "type": "integer",
            "nullable": true,
            "description": "Number of autogain periods applied"
          },
          "overflowAmountLost": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Amount lost to cap overflow"
          },
          "earnCapAmountLimited": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Amount limited by earn cap"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Free-form metadata"
          }
        }
      },
      "CustomAffordance": {
        "type": "object",
        "description": "Custom affordance definition for novel scenarios",
        "properties": {
          "description": {
            "type": "string",
            "description": "Human-readable description of this affordance",
            "nullable": true
          },
          "requires": {
            "type": "object",
            "additionalProperties": true,
            "description": "Required criteria. Object types, property constraints.\nExample: { \"objectTypes\": [\"boulder\"], \"cover_rating\": { \"min\": 0.5 } }\n",
            "nullable": true
          },
          "prefers": {
            "type": "object",
            "additionalProperties": true,
            "description": "Preferred criteria (boost score but not required).\nExample: { \"elevation\": { \"prefer_higher\": true } }\n",
            "nullable": true
          },
          "excludes": {
            "type": "object",
            "additionalProperties": true,
            "description": "Exclusion criteria. Reject candidates matching these.\nExample: { \"hazards\": true, \"contested\": true }\n",
            "nullable": true
          }
        }
      },
      "CustomScripts": {
        "description": "Custom script injection configuration for adding JavaScript to pages",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "head": {
            "type": "string",
            "nullable": true,
            "description": "Custom scripts to inject in the HTML head"
          },
          "bodyStart": {
            "type": "string",
            "nullable": true,
            "description": "Custom scripts to inject at the start of the body"
          },
          "bodyEnd": {
            "type": "string",
            "nullable": true,
            "description": "Custom scripts to inject at the end of the body"
          }
        }
      },
      "DeactivateDeityRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to deactivate an active deity",
        "required": [
          "deityId"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity to deactivate"
          }
        }
      },
      "DebitCurrencyRequest": {
        "type": "object",
        "description": "Request to debit currency from a wallet",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "transactionType",
          "idempotencyKey"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Source wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to debit"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to debit (must be positive)"
          },
          "transactionType": {
            "$ref": "#/components/schemas/TransactionType",
            "description": "Must be a sink type (burn, vendor_purchase, fee, etc.)"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "What triggered this transaction"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference entity ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Unique key to prevent duplicate processing"
          },
          "allowNegative": {
            "type": "boolean",
            "nullable": true,
            "description": "Override negative balance allowance for this transaction"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Free-form transaction metadata"
          }
        }
      },
      "DebitCurrencyResponse": {
        "type": "object",
        "description": "Result of debit operation",
        "additionalProperties": false,
        "required": [
          "transaction",
          "newBalance"
        ],
        "properties": {
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Created transaction record"
          },
          "newBalance": {
            "type": "number",
            "format": "double",
            "description": "Balance after debit"
          }
        }
      },
      "DebitDivinityRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to debit divinity from a deity's wallet",
        "required": [
          "deityId",
          "amount",
          "purpose"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity to debit"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "minimum": 0.0,
            "exclusiveMinimum": true,
            "description": "Amount of divinity to debit (must be positive)"
          },
          "purpose": {
            "type": "string",
            "description": "Purpose of the expenditure (e.g., blessing_grant, miracle, intervention)"
          },
          "targetCharacterId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Target character if the expenditure is blessing-related"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description of the debit reason"
          }
        }
      },
      "DeclineMatchRequest": {
        "type": "object",
        "description": "Request to decline a formed match",
        "additionalProperties": false,
        "required": [
          "webSocketSessionId",
          "accountId",
          "matchId"
        ],
        "properties": {
          "webSocketSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player"
          },
          "matchId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the match to decline"
          }
        }
      },
      "DeclinePoiRequest": {
        "type": "object",
        "description": "Request to decline a POI",
        "required": [
          "accountId",
          "poiId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account declining the POI"
          },
          "poiId": {
            "type": "string",
            "format": "uuid",
            "description": "POI to decline"
          }
        }
      },
      "DeclinePoiResponse": {
        "type": "object",
        "description": "Response after declining a POI",
        "required": [
          "poiId",
          "acknowledged"
        ],
        "properties": {
          "poiId": {
            "type": "string",
            "format": "uuid",
            "description": "POI that was declined"
          },
          "acknowledged": {
            "type": "boolean",
            "description": "Whether the decline was processed"
          }
        }
      },
      "DefineNormRequest": {
        "type": "object",
        "description": "Request to define a behavioral norm for a faction",
        "additionalProperties": false,
        "required": [
          "factionId",
          "violationType",
          "basePenalty",
          "severity",
          "scope"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction to define the norm for"
          },
          "violationType": {
            "type": "string",
            "minLength": 1,
            "maxLength": 128,
            "description": "Violation type code (e.g., \"theft\", \"deception\", \"violence\")"
          },
          "basePenalty": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "description": "Base GOAP cost penalty for violating this norm"
          },
          "severity": {
            "$ref": "#/components/schemas/NormSeverity",
            "description": "Enforcement intensity level"
          },
          "scope": {
            "$ref": "#/components/schemas/NormScope",
            "description": "Whether norm applies to member-only or all interactions"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "maxLength": 1024,
            "description": "Human-readable description of the norm"
          }
        }
      },
      "DeityPersonalityTraits": {
        "type": "object",
        "additionalProperties": false,
        "description": "Machine-readable personality traits influencing deity behavior decisions",
        "required": [
          "temperament",
          "attentionBias",
          "generosity",
          "jealousy"
        ],
        "properties": {
          "temperament": {
            "type": "string",
            "description": "Primary temperament descriptor (e.g., wrathful, benevolent, capricious)"
          },
          "attentionBias": {
            "type": "string",
            "description": "What type of mortal actions draw this deity's attention (e.g., combat, devotion, craft)"
          },
          "generosity": {
            "type": "number",
            "format": "double",
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "How freely the deity grants blessings (0.0 miserly, 1.0 lavish)"
          },
          "jealousy": {
            "type": "number",
            "format": "double",
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "How possessive the deity is of followers (0.0 tolerant, 1.0 vengeful)"
          }
        }
      },
      "DeityResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Full deity entity response",
        "required": [
          "deityId",
          "gameServiceId",
          "code",
          "displayName",
          "description",
          "domains",
          "personalityTraits",
          "maxAttentionSlots",
          "status",
          "followerCount",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique deity identifier"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this deity belongs to"
          },
          "code": {
            "type": "string",
            "description": "Unique code within the game service"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable display name"
          },
          "description": {
            "type": "string",
            "description": "Description of the deity"
          },
          "domains": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DomainInfluence"
            },
            "description": "Domain influences"
          },
          "personalityTraits": {
            "$ref": "#/components/schemas/DeityPersonalityTraits",
            "description": "Personality traits"
          },
          "maxAttentionSlots": {
            "type": "integer",
            "description": "Maximum characters the deity can actively monitor"
          },
          "actorId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Associated actor ID for the deity watcher brain (null if no watcher started)"
          },
          "seedId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Domain power seed ID (null if seed creation failed or pending)"
          },
          "currencyWalletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Divinity currency wallet ID (null if wallet creation failed or pending)"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Home realm for this deity (null if not realm-bound)"
          },
          "status": {
            "$ref": "#/components/schemas/DeityStatus",
            "description": "Current lifecycle status"
          },
          "followerCount": {
            "type": "integer",
            "description": "Number of active followers"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the deity was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the deity was last updated"
          }
        }
      },
      "DeityStatus": {
        "type": "string",
        "description": "Lifecycle status of a deity entity",
        "enum": [
          "active",
          "dormant",
          "archived"
        ]
      },
      "DeleteAchievementDefinitionRequest": {
        "type": "object",
        "description": "Request to delete an achievement",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "achievementId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "achievementId": {
            "type": "string",
            "description": "ID of the achievement to delete"
          }
        }
      },
      "DeleteActionMappingRequest": {
        "type": "object",
        "description": "Request to delete an action tag mapping",
        "additionalProperties": false,
        "required": [
          "tag"
        ],
        "properties": {
          "tag": {
            "type": "string",
            "minLength": 1,
            "maxLength": 128,
            "description": "The GOAP action tag whose mapping should be deleted"
          }
        }
      },
      "DeleteActorTemplateRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to delete an actor template",
        "required": [
          "templateId"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the template to delete"
          },
          "forceStopActors": {
            "type": "boolean",
            "default": false,
            "description": "If true, stops all running actors using this template"
          }
        }
      },
      "DeleteActorTemplateResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response confirming template deletion",
        "required": [
          "deleted",
          "stoppedActorCount"
        ],
        "properties": {
          "deleted": {
            "type": "boolean",
            "description": "Whether the template was successfully deleted"
          },
          "stoppedActorCount": {
            "type": "integer",
            "description": "Number of running actors that were stopped"
          }
        }
      },
      "DeleteBoardRequest": {
        "type": "object",
        "description": "Request to delete a board instance",
        "additionalProperties": false,
        "required": [
          "boardId"
        ],
        "properties": {
          "boardId": {
            "type": "string",
            "format": "uuid",
            "description": "Board instance to delete"
          }
        }
      },
      "DeleteBoardTemplateRequest": {
        "type": "object",
        "description": "Request to delete a board template",
        "additionalProperties": false,
        "required": [
          "boardTemplateId"
        ],
        "properties": {
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template to delete"
          }
        }
      },
      "DeleteBundleRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to delete a bundle",
        "required": [
          "bundleId"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier to delete"
          },
          "permanent": {
            "type": "boolean",
            "default": false,
            "description": "If true, permanently delete (admin only). If false, soft-delete."
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for deletion (recorded in version history)"
          }
        }
      },
      "DeleteBundleResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of bundle deletion",
        "required": [
          "bundleId",
          "status",
          "deletedAt"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier that was deleted"
          },
          "status": {
            "type": "string",
            "enum": [
              "deleted",
              "permanently_deleted"
            ],
            "description": "Deletion status"
          },
          "deletedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the bundle was deleted"
          },
          "retentionUntil": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When soft-deleted bundle will be permanently removed (null for permanent deletes)"
          }
        }
      },
      "DeleteCollectionRequest": {
        "type": "object",
        "description": "Request to delete a collection",
        "additionalProperties": false,
        "required": [
          "collectionId"
        ],
        "properties": {
          "collectionId": {
            "type": "string",
            "format": "uuid",
            "description": "Collection instance to delete"
          }
        }
      },
      "DeleteDeityRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to permanently delete a deity and all dependent data",
        "required": [
          "deityId"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity to delete"
          }
        }
      },
      "DeleteEntryTemplateRequest": {
        "type": "object",
        "description": "Request to delete an entry template",
        "additionalProperties": false,
        "required": [
          "entryTemplateId"
        ],
        "properties": {
          "entryTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Entry template to delete"
          }
        }
      },
      "DeleteLeaderboardDefinitionRequest": {
        "type": "object",
        "description": "Request to delete a leaderboard",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard to delete"
          }
        }
      },
      "DeleteMessageRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to delete a message from a room",
        "required": [
          "roomId",
          "messageId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room the message belongs to"
          },
          "messageId": {
            "type": "string",
            "format": "uuid",
            "description": "Message ID to delete"
          }
        }
      },
      "DeleteNormRequest": {
        "type": "object",
        "description": "Request to delete a norm definition",
        "additionalProperties": false,
        "required": [
          "normId"
        ],
        "properties": {
          "normId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the norm to delete"
          }
        }
      },
      "DeleteRoomRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to permanently delete a room and all its messages",
        "required": [
          "roomId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID to delete"
          }
        }
      },
      "DeleteSceneRequest": {
        "type": "object",
        "description": "Request to delete a scene",
        "required": [
          "sceneId"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the scene to delete"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for deletion (included in event)"
          }
        }
      },
      "DeleteSceneResponse": {
        "type": "object",
        "description": "Response confirming scene deletion",
        "required": [
          "deleted"
        ],
        "properties": {
          "deleted": {
            "type": "boolean",
            "description": "Whether the scene was successfully deleted"
          },
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the deleted scene"
          },
          "referencingScenes": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "If deletion failed, IDs of scenes that reference this one"
          }
        }
      },
      "DeleteSeedTypeRequest": {
        "type": "object",
        "description": "Request to hard-delete a deprecated seed type with no remaining non-archived seeds.",
        "additionalProperties": false,
        "required": [
          "seedTypeCode"
        ],
        "properties": {
          "seedTypeCode": {
            "type": "string",
            "description": "The seed type to delete."
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "The game service scope. Null for cross-game seed types."
          }
        }
      },
      "DeleteSlotRequest": {
        "type": "object",
        "description": "Request to permanently delete a save slot and all its versions",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "minLength": 1,
            "maxLength": 32,
            "pattern": "^[a-z][a-z0-9-]*$",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          }
        }
      },
      "DeleteSlotResponse": {
        "type": "object",
        "description": "Result of a slot deletion operation with cleanup statistics",
        "required": [
          "deleted",
          "versionsDeleted",
          "bytesFreed"
        ],
        "properties": {
          "deleted": {
            "type": "boolean",
            "description": "Whether slot was deleted"
          },
          "versionsDeleted": {
            "type": "integer",
            "description": "Number of versions deleted"
          },
          "bytesFreed": {
            "type": "integer",
            "format": "int64",
            "description": "Storage freed in bytes"
          }
        }
      },
      "DeleteTemplateRequest": {
        "type": "object",
        "description": "Request to permanently delete a deprecated template",
        "required": [
          "scenarioTemplateId"
        ],
        "properties": {
          "scenarioTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template ID to delete"
          }
        }
      },
      "DeleteVersionRequest": {
        "type": "object",
        "description": "Request to permanently delete a specific save version",
        "required": [
          "ownerId",
          "ownerType",
          "slotName",
          "versionNumber"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Version to delete"
          }
        }
      },
      "DeleteVersionResponse": {
        "type": "object",
        "description": "Result of a version deletion operation with storage freed",
        "required": [
          "deleted",
          "bytesFreed"
        ],
        "properties": {
          "deleted": {
            "type": "boolean",
            "description": "Whether version was deleted"
          },
          "bytesFreed": {
            "type": "integer",
            "format": "int64",
            "description": "Storage freed in bytes"
          }
        }
      },
      "DeltaAlgorithm": {
        "type": "string",
        "enum": [
          "JSON_PATCH",
          "BSDIFF",
          "XDELTA"
        ],
        "default": "JSON_PATCH",
        "description": "Algorithm used for delta computation.\nJSON_PATCH: RFC 6902, best for structured JSON data\nBSDIFF: Binary diff, good for general binary data\nXDELTA: RFC 3284 VCDIFF, efficient for large binary files\n"
      },
      "DeploymentPhase": {
        "type": "string",
        "enum": [
          "Alpha",
          "Beta",
          "Release"
        ],
        "description": "Current deployment phase for scenario availability gating"
      },
      "DepositRequest": {
        "type": "object",
        "description": "Request to deposit assets into an escrow",
        "required": [
          "escrowId",
          "partyId",
          "partyType",
          "assets",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party depositing"
          },
          "partyType": {
            "description": "Type of entity (Account, Character, etc.)",
            "$ref": "#/components/schemas/EntityType"
          },
          "assets": {
            "$ref": "#/components/schemas/EscrowAssetBundleInput",
            "description": "Assets to deposit"
          },
          "depositToken": {
            "type": "string",
            "nullable": true,
            "description": "Deposit token (required for full_consent)"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "DepositResponse": {
        "type": "object",
        "description": "Response from depositing assets into an escrow",
        "required": [
          "escrow",
          "deposit",
          "fullyFunded",
          "releaseTokens"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Updated escrow agreement"
          },
          "deposit": {
            "$ref": "#/components/schemas/EscrowDeposit",
            "description": "Deposit record"
          },
          "fullyFunded": {
            "type": "boolean",
            "description": "Whether escrow is now fully funded"
          },
          "releaseTokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartyToken"
            },
            "description": "Release tokens (issued when fully funded)"
          }
        }
      },
      "DeprecateFactionRequest": {
        "type": "object",
        "description": "Request to deprecate a faction",
        "additionalProperties": false,
        "required": [
          "factionId"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the faction to deprecate"
          }
        }
      },
      "DeprecateQuestDefinitionRequest": {
        "type": "object",
        "description": "Request to mark a quest definition as deprecated",
        "additionalProperties": false,
        "required": [
          "definitionId"
        ],
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Definition to deprecate"
          }
        }
      },
      "DeprecateRoomTypeRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to deprecate a room type (prevents new room creation)",
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Room type code to deprecate"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game service scope for the type"
          }
        }
      },
      "DeprecateScenarioDefinitionRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to deprecate a scenario definition",
        "required": [
          "scenarioId"
        ],
        "properties": {
          "scenarioId": {
            "type": "string",
            "format": "uuid",
            "description": "Scenario to deprecate"
          }
        }
      },
      "DeprecateSeedTypeRequest": {
        "type": "object",
        "description": "Request to deprecate a seed type, preventing new seed creation.",
        "additionalProperties": false,
        "required": [
          "seedTypeCode"
        ],
        "properties": {
          "seedTypeCode": {
            "type": "string",
            "description": "The seed type to deprecate."
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "The game service scope. Null for cross-game seed types."
          },
          "reason": {
            "type": "string",
            "maxLength": 500,
            "nullable": true,
            "description": "Optional reason for deprecation (for audit purposes)."
          }
        }
      },
      "DeprecateTemplateRequest": {
        "type": "object",
        "description": "Request to deprecate a template",
        "required": [
          "scenarioTemplateId"
        ],
        "properties": {
          "scenarioTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template ID to deprecate"
          }
        }
      },
      "DesignateRealmBaselineRequest": {
        "type": "object",
        "description": "Request to designate a faction as the realm baseline",
        "additionalProperties": false,
        "required": [
          "factionId"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the faction to designate as realm baseline"
          }
        }
      },
      "DestroyItemInstanceRequest": {
        "type": "object",
        "description": "Request to destroy an item instance",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "reason"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Instance ID to destroy"
          },
          "reason": {
            "type": "string",
            "description": "Reason for destruction (consumed, destroyed, expired, admin)"
          }
        }
      },
      "DestroyItemInstanceResponse": {
        "type": "object",
        "description": "Response after destroying an item instance",
        "additionalProperties": false,
        "required": [
          "destroyed",
          "instanceId",
          "templateId"
        ],
        "properties": {
          "destroyed": {
            "type": "boolean",
            "description": "Whether destruction was successful"
          },
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Destroyed instance ID"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template of destroyed instance"
          }
        }
      },
      "DeviceInfo": {
        "description": "Information about the client device used for authentication or session tracking",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "deviceType": {
            "type": "string",
            "enum": [
              "desktop",
              "mobile",
              "tablet",
              "console"
            ],
            "nullable": true,
            "description": "Category of the device"
          },
          "platform": {
            "type": "string",
            "nullable": true,
            "description": "Operating system or platform name"
          },
          "browser": {
            "type": "string",
            "nullable": true,
            "description": "Browser name and version if applicable"
          },
          "appVersion": {
            "type": "string",
            "nullable": true,
            "description": "Version of the client application"
          }
        }
      },
      "DiscardRequest": {
        "type": "object",
        "description": "Request to discard checkout",
        "required": [
          "sceneId",
          "checkoutToken"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene to discard changes for"
          },
          "checkoutToken": {
            "type": "string",
            "description": "Checkout token"
          }
        }
      },
      "DiscardResponse": {
        "type": "object",
        "description": "Response confirming discard",
        "required": [
          "discarded"
        ],
        "properties": {
          "discarded": {
            "type": "boolean",
            "description": "Whether discard was successful"
          }
        }
      },
      "DiscoveryLevel": {
        "type": "object",
        "description": "A discovery level defining what information is revealed at this level",
        "additionalProperties": false,
        "required": [
          "level",
          "reveals"
        ],
        "properties": {
          "level": {
            "type": "integer",
            "minimum": 0,
            "description": "Discovery level number (zero-indexed)"
          },
          "reveals": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of field or information keys revealed at this level"
          }
        }
      },
      "DisputeRequest": {
        "type": "object",
        "description": "Request to raise a dispute on a funded escrow",
        "required": [
          "escrowId",
          "partyId",
          "partyType",
          "reason",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party raising dispute"
          },
          "partyType": {
            "description": "Type of entity (Account, Character, etc.)",
            "$ref": "#/components/schemas/EntityType"
          },
          "reason": {
            "type": "string",
            "description": "Reason for dispute"
          },
          "releaseToken": {
            "type": "string",
            "nullable": true,
            "description": "Release token (proves party identity)"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "DisputeResponse": {
        "type": "object",
        "description": "Response from raising a dispute on an escrow",
        "required": [
          "escrow"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Disputed escrow agreement"
          }
        }
      },
      "DivinityBalanceResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Current divinity balance for a deity",
        "required": [
          "deityId",
          "balance",
          "currencyCode",
          "walletId"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity this balance belongs to"
          },
          "balance": {
            "type": "number",
            "format": "double",
            "description": "Current divinity balance"
          },
          "currencyCode": {
            "type": "string",
            "description": "Currency code for the divinity type"
          },
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency wallet ID"
          }
        }
      },
      "DivinityHistoryResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Paginated divinity transaction history",
        "required": [
          "transactions",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "transactions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DivinityTransaction"
            },
            "description": "Transactions in the current page"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of transactions"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          }
        }
      },
      "DivinityTransaction": {
        "type": "object",
        "additionalProperties": false,
        "description": "A single divinity transaction record from the currency wallet history",
        "required": [
          "transactionId",
          "walletId",
          "amount",
          "transactionType",
          "createdAt"
        ],
        "properties": {
          "transactionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique transaction identifier"
          },
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet the transaction belongs to"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Transaction amount (positive for credits, negative for debits)"
          },
          "transactionType": {
            "type": "string",
            "description": "Type of transaction (e.g., mortal_action, blessing_grant, manual_credit)"
          },
          "targetType": {
            "type": "string",
            "nullable": true,
            "description": "Type of entity involved in this transaction (e.g., character, deity)"
          },
          "targetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Entity ID involved in this transaction (e.g., the blessed character, the rival deity)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the transaction was recorded"
          }
        }
      },
      "Document": {
        "description": "Complete document with all metadata and content",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "documentId",
          "namespace",
          "slug",
          "title",
          "category",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "documentId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the document"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace the document belongs to"
          },
          "slug": {
            "type": "string",
            "description": "URL-friendly unique identifier"
          },
          "title": {
            "type": "string",
            "description": "Display title of the document"
          },
          "category": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "Category for organizing the document"
          },
          "content": {
            "type": "string",
            "description": "Full markdown content of the document"
          },
          "summary": {
            "type": "string",
            "nullable": true,
            "description": "Brief text summary of the document"
          },
          "voiceSummary": {
            "type": "string",
            "nullable": true,
            "description": "Concise summary optimized for voice AI"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tags for filtering and search"
          },
          "relatedDocuments": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "IDs of related documents"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "description": "Custom metadata key-value pairs"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the document was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the document was last updated"
          }
        }
      },
      "DocumentCategory": {
        "type": "string",
        "enum": [
          "getting-started",
          "api-reference",
          "architecture",
          "deployment",
          "troubleshooting",
          "tutorials",
          "game-systems",
          "world-lore",
          "npc-ai",
          "other"
        ],
        "description": "Fixed categories for type-safe filtering"
      },
      "DocumentResult": {
        "description": "Search result with relevance scoring and match highlights",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "documentId",
          "slug",
          "title",
          "relevanceScore"
        ],
        "properties": {
          "documentId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the document"
          },
          "slug": {
            "type": "string",
            "description": "URL-friendly unique identifier"
          },
          "title": {
            "type": "string",
            "description": "Display title of the document"
          },
          "category": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "Category of the document"
          },
          "summary": {
            "type": "string",
            "nullable": true,
            "description": "Brief text summary of the document"
          },
          "voiceSummary": {
            "type": "string",
            "nullable": true,
            "description": "Concise summary optimized for voice AI"
          },
          "content": {
            "type": "string",
            "nullable": true,
            "description": "Full document content if requested"
          },
          "relevanceScore": {
            "type": "number",
            "format": "float",
            "description": "Relevance score from 0.0 to 1.0"
          },
          "matchHighlights": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Text snippets showing where matches occurred"
          }
        }
      },
      "DocumentSummary": {
        "description": "Lightweight document representation for listings and references",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "documentId",
          "slug",
          "title",
          "category"
        ],
        "properties": {
          "documentId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the document"
          },
          "slug": {
            "type": "string",
            "description": "URL-friendly unique identifier"
          },
          "title": {
            "type": "string",
            "description": "Display title of the document"
          },
          "category": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "Category of the document"
          },
          "summary": {
            "type": "string",
            "nullable": true,
            "description": "Brief text summary of the document"
          },
          "voiceSummary": {
            "type": "string",
            "nullable": true,
            "description": "Concise summary optimized for voice AI"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tags associated with the document"
          }
        }
      },
      "DomainInfluence": {
        "type": "object",
        "additionalProperties": false,
        "description": "A deity's influence in a specific domain with a weight representing strength",
        "required": [
          "domain",
          "weight"
        ],
        "properties": {
          "domain": {
            "type": "string",
            "description": "Opaque domain code (e.g., war, knowledge, nature). Game-defined, not an enum."
          },
          "weight": {
            "type": "number",
            "format": "double",
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "Strength of influence in this domain (0.0-1.0)"
          }
        }
      },
      "DomainWeight": {
        "type": "object",
        "description": "Domain name and weight pair for scenario template growth weighting",
        "required": [
          "domain",
          "weight"
        ],
        "properties": {
          "domain": {
            "type": "string",
            "description": "Growth domain path (e.g. combat.melee, exploration.caves)"
          },
          "weight": {
            "type": "number",
            "format": "float",
            "description": "Weight applied to this domain on scenario completion"
          }
        }
      },
      "DownloadInfo": {
        "description": "Download details for a specific game client version and platform",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "platform",
          "version",
          "url",
          "size",
          "checksum"
        ],
        "properties": {
          "platform": {
            "description": "Target platform for this download",
            "$ref": "#/components/schemas/Platform"
          },
          "version": {
            "type": "string",
            "description": "Version number of the game client"
          },
          "url": {
            "type": "string",
            "format": "uri",
            "description": "Download URL for the game client"
          },
          "size": {
            "type": "integer",
            "description": "File size in bytes"
          },
          "checksum": {
            "type": "string",
            "description": "SHA256 checksum"
          },
          "releaseNotes": {
            "type": "string",
            "nullable": true,
            "description": "Release notes or changelog for this version"
          },
          "minimumRequirements": {
            "type": "object",
            "additionalProperties": true,
            "description": "Minimum system requirements for the client"
          }
        }
      },
      "DownloadsResponse": {
        "description": "Collection of available game client downloads by platform",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "clients"
        ],
        "properties": {
          "clients": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DownloadInfo"
            },
            "description": "Available game client downloads"
          }
        }
      },
      "DuplicateSceneRequest": {
        "type": "object",
        "description": "Request to duplicate a scene",
        "required": [
          "sourceSceneId",
          "newName"
        ],
        "properties": {
          "sourceSceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene to duplicate"
          },
          "newName": {
            "type": "string",
            "description": "Name for the duplicate"
          },
          "newGameId": {
            "type": "string",
            "nullable": true,
            "description": "Optional different game ID"
          },
          "newSceneType": {
            "$ref": "#/components/schemas/SceneType",
            "nullable": true,
            "description": "Optional different scene type"
          }
        }
      },
      "EarnCapInfo": {
        "type": "object",
        "description": "Current earn cap status for a balance",
        "additionalProperties": false,
        "required": [
          "dailyEarned",
          "dailyRemaining",
          "dailyResetsAt",
          "weeklyEarned",
          "weeklyRemaining",
          "weeklyResetsAt"
        ],
        "properties": {
          "dailyEarned": {
            "type": "number",
            "format": "double",
            "description": "Amount earned today"
          },
          "dailyRemaining": {
            "type": "number",
            "format": "double",
            "description": "Remaining daily earn allowance"
          },
          "dailyResetsAt": {
            "type": "string",
            "format": "date-time",
            "description": "When daily counter resets"
          },
          "weeklyEarned": {
            "type": "number",
            "format": "double",
            "description": "Amount earned this week"
          },
          "weeklyRemaining": {
            "type": "number",
            "format": "double",
            "description": "Remaining weekly earn allowance"
          },
          "weeklyResetsAt": {
            "type": "string",
            "format": "date-time",
            "description": "When weekly counter resets"
          }
        }
      },
      "EffectCardinality": {
        "x-sdk-type": "BeyondImmersion.Bannou.StorylineStoryteller.Actions.EffectCardinality",
        "type": "string",
        "enum": [
          "Exclusive",
          "Additive"
        ],
        "description": "Cardinality for effect application.\nExclusive: Replaces existing value at key\nAdditive: Adds to collection at key\n"
      },
      "EffectSource": {
        "type": "string",
        "description": "Whether an effect comes from a status item or a seed capability.\n- item_based: temporary effect stored as an item in a status container\n- seed_derived: passive capability computed from seed growth state\n",
        "enum": [
          "item_based",
          "seed_derived"
        ]
      },
      "EmotionalImpact": {
        "type": "string",
        "description": "How the encounter emotionally affected the character",
        "enum": [
          "GRATITUDE",
          "ANGER",
          "FEAR",
          "RESPECT",
          "CONTEMPT",
          "AFFECTION",
          "RIVALRY",
          "INDIFFERENCE",
          "GUILT",
          "PRIDE"
        ]
      },
      "EmotionalStateInput": {
        "description": "6-dimensional emotional state input (all values 0-1)",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "tension": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "nullable": true,
            "description": "Tension level (0=resolved, 1=maximum tension)"
          },
          "brightness": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "nullable": true,
            "description": "Brightness level (0=dark, 1=bright)"
          },
          "energy": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "nullable": true,
            "description": "Energy level (0=calm, 1=energetic)"
          },
          "warmth": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "nullable": true,
            "description": "Warmth level (0=distant, 1=intimate)"
          },
          "stability": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "nullable": true,
            "description": "Stability level (0=unstable, 1=grounded)"
          },
          "valence": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "nullable": true,
            "description": "Valence level (0=negative, 1=positive)"
          }
        }
      },
      "EmotionalStateSnapshot": {
        "description": "Snapshot of emotional state at a specific point in the composition",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bar",
          "tension",
          "brightness",
          "energy"
        ],
        "properties": {
          "bar": {
            "type": "integer",
            "description": "Bar number where this snapshot was taken"
          },
          "phaseName": {
            "type": "string",
            "nullable": true,
            "description": "Name of the narrative phase at this point"
          },
          "tension": {
            "type": "number",
            "description": "Tension level (0-1)"
          },
          "brightness": {
            "type": "number",
            "description": "Brightness level (0-1)"
          },
          "energy": {
            "type": "number",
            "description": "Energy level (0-1)"
          },
          "warmth": {
            "type": "number",
            "description": "Warmth level (0-1)"
          },
          "stability": {
            "type": "number",
            "description": "Stability level (0-1)"
          },
          "valence": {
            "type": "number",
            "description": "Valence level (0-1)"
          }
        }
      },
      "EncounterListResponse": {
        "type": "object",
        "description": "Paginated list of encounters",
        "additionalProperties": false,
        "required": [
          "encounters",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "encounters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EncounterResponse"
            },
            "description": "List of encounters with perspectives"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total matching encounters"
          },
          "page": {
            "type": "integer",
            "description": "Current page (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "description": "Results per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether more results exist"
          },
          "hasPreviousPage": {
            "type": "boolean",
            "description": "Whether previous results exist"
          }
        }
      },
      "EncounterModel": {
        "type": "object",
        "description": "Core encounter record representing a memorable interaction",
        "additionalProperties": false,
        "required": [
          "encounterId",
          "timestamp",
          "realmId",
          "encounterTypeCode",
          "outcome",
          "participantIds",
          "createdAt"
        ],
        "properties": {
          "encounterId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this encounter"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "In-game time when the encounter occurred"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm where the encounter took place"
          },
          "locationId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Specific location within the realm (optional)"
          },
          "encounterTypeCode": {
            "type": "string",
            "description": "Type code for this encounter (e.g., COMBAT, TRADE)"
          },
          "context": {
            "type": "string",
            "maxLength": 500,
            "nullable": true,
            "description": "What triggered or contextualized the encounter"
          },
          "outcome": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EncounterOutcome"
              }
            ],
            "description": "Outcome of the encounter (POSITIVE, NEGATIVE, NEUTRAL, MEMORABLE, TRANSFORMATIVE)"
          },
          "participantIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "minItems": 2,
            "description": "All character IDs involved in the encounter"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional encounter-specific data"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "System timestamp when record was created"
          }
        }
      },
      "EncounterOutcome": {
        "type": "string",
        "description": "Overall outcome of an encounter",
        "enum": [
          "POSITIVE",
          "NEGATIVE",
          "NEUTRAL",
          "MEMORABLE",
          "TRANSFORMATIVE"
        ]
      },
      "EncounterPerspectiveModel": {
        "type": "object",
        "description": "A character's individual perspective on an encounter",
        "additionalProperties": false,
        "required": [
          "perspectiveId",
          "encounterId",
          "characterId",
          "emotionalImpact",
          "memoryStrength",
          "createdAt"
        ],
        "properties": {
          "perspectiveId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this perspective"
          },
          "encounterId": {
            "type": "string",
            "format": "uuid",
            "description": "Reference to the shared encounter record"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character holding this perspective"
          },
          "emotionalImpact": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EmotionalImpact"
              }
            ],
            "description": "Primary emotional response to the encounter"
          },
          "impactIntensity": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "Intensity of emotional impact (0.0-1.0). Used for kernel extraction threshold (>0.7 indicates high-impact encounter)."
          },
          "sentimentShift": {
            "type": "number",
            "format": "float",
            "minimum": -1.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Opinion change toward other participants (-1.0 to +1.0)"
          },
          "memoryStrength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "How strongly remembered (0.0-1.0, decays over time)"
          },
          "rememberedAs": {
            "type": "string",
            "maxLength": 200,
            "nullable": true,
            "description": "Short description from this character's POV"
          },
          "lastDecayedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When memory decay was last applied"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "System timestamp when record was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last modification timestamp"
          }
        }
      },
      "EncounterResponse": {
        "type": "object",
        "description": "Response containing an encounter with perspectives",
        "additionalProperties": false,
        "required": [
          "encounter",
          "perspectives"
        ],
        "properties": {
          "encounter": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EncounterModel"
              }
            ],
            "description": "The shared encounter record"
          },
          "perspectives": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EncounterPerspectiveModel"
            },
            "description": "All perspectives on this encounter"
          }
        }
      },
      "EncounterTypeListResponse": {
        "type": "object",
        "description": "Response containing a list of encounter types",
        "additionalProperties": false,
        "required": [
          "types",
          "totalCount"
        ],
        "properties": {
          "types": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EncounterTypeResponse"
            },
            "description": "List of encounter types"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of types"
          }
        }
      },
      "EncounterTypeResponse": {
        "type": "object",
        "description": "Response containing an encounter type",
        "additionalProperties": false,
        "required": [
          "typeId",
          "code",
          "name",
          "isBuiltIn",
          "sortOrder",
          "isActive",
          "createdAt"
        ],
        "properties": {
          "typeId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier"
          },
          "code": {
            "type": "string",
            "description": "Unique code"
          },
          "name": {
            "type": "string",
            "description": "Display name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Description"
          },
          "isBuiltIn": {
            "type": "boolean",
            "description": "Whether this is a built-in type"
          },
          "defaultEmotionalImpact": {
            "$ref": "#/components/schemas/EmotionalImpact",
            "nullable": true,
            "description": "Suggested emotional response"
          },
          "sortOrder": {
            "type": "integer",
            "description": "Display ordering"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether the type is active"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the type was created"
          }
        }
      },
      "EndEncounterRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to end an active encounter",
        "required": [
          "actorId"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "ID of the Event Brain actor managing the encounter"
          }
        }
      },
      "EndEncounterResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response after ending an encounter",
        "required": [
          "actorId",
          "encounterId"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "ID of the actor"
          },
          "encounterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the ended encounter"
          },
          "durationMs": {
            "type": "integer",
            "nullable": true,
            "description": "Duration of the encounter in milliseconds"
          }
        }
      },
      "EnforcementMode": {
        "type": "string",
        "description": "How contract breaches are handled",
        "enum": [
          "advisory",
          "event_only",
          "consequence_based",
          "community"
        ]
      },
      "EnrichedCharacterResponse": {
        "description": "Character data with optional enriched fields.\nFields are only populated if the corresponding include flag was set in the request.\n",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId",
          "name",
          "realmId",
          "speciesId",
          "birthDate",
          "status",
          "createdAt"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the character"
          },
          "name": {
            "type": "string",
            "description": "Display name of the character"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID (partition key)"
          },
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "description": "Species ID (foreign key to Species service)"
          },
          "birthDate": {
            "type": "string",
            "format": "date-time",
            "description": "In-game birth timestamp"
          },
          "deathDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "In-game death timestamp"
          },
          "status": {
            "$ref": "#/components/schemas/CharacterStatus",
            "description": "Current lifecycle status of the character"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Real-world creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Real-world last update timestamp"
          },
          "personality": {
            "$ref": "#/components/schemas/PersonalitySnapshot",
            "nullable": true,
            "description": "Personality traits (included if includePersonality=true)"
          },
          "backstory": {
            "$ref": "#/components/schemas/BackstorySnapshot",
            "nullable": true,
            "description": "Backstory elements (included if includeBackstory=true)"
          },
          "familyTree": {
            "$ref": "#/components/schemas/FamilyTreeResponse",
            "nullable": true,
            "description": "Family relationships (included if includeFamilyTree=true)"
          },
          "combatPreferences": {
            "$ref": "#/components/schemas/CombatPreferencesSnapshot",
            "nullable": true,
            "description": "Combat preferences (included if includeCombatPreferences=true)"
          }
        }
      },
      "EnterGardenRequest": {
        "type": "object",
        "description": "Request to enter the garden",
        "required": [
          "accountId",
          "sessionId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account entering the garden"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Current WebSocket session ID"
          }
        }
      },
      "EnterScenarioRequest": {
        "type": "object",
        "description": "Request to enter a scenario",
        "required": [
          "accountId",
          "scenarioTemplateId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account entering the scenario"
          },
          "scenarioTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template to instantiate"
          },
          "poiId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "POI that triggered this scenario entry, if any"
          },
          "promptChoice": {
            "type": "string",
            "nullable": true,
            "description": "Selected prompt choice for prompted POIs"
          }
        }
      },
      "EnterTogetherRequest": {
        "type": "object",
        "description": "Request for bonded players to enter a scenario together",
        "required": [
          "bondId",
          "scenarioTemplateId"
        ],
        "properties": {
          "bondId": {
            "type": "string",
            "format": "uuid",
            "description": "Bond ID linking the participants"
          },
          "scenarioTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template to instantiate for the bond"
          }
        }
      },
      "EntityPresenceEntry": {
        "description": "An entity currently present at a location",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "entityType",
          "entityId"
        ],
        "properties": {
          "entityType": {
            "type": "string",
            "description": "Type of entity (opaque string)"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "reportedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the presence was last reported"
          },
          "reportedBy": {
            "type": "string",
            "nullable": true,
            "description": "Identifier of the last reporter"
          }
        }
      },
      "EntityRankResponse": {
        "type": "object",
        "description": "Entity's rank on a leaderboard",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "score",
          "rank",
          "totalEntries"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type for the ranked entity"
          },
          "score": {
            "type": "number",
            "format": "double",
            "description": "Entity's current score"
          },
          "rank": {
            "type": "integer",
            "format": "int64",
            "description": "Entity's current rank (1-based)"
          },
          "totalEntries": {
            "type": "integer",
            "format": "int64",
            "description": "Total entries on the leaderboard"
          },
          "percentile": {
            "type": "number",
            "format": "double",
            "description": "Percentile ranking (0-100)"
          }
        }
      },
      "EntityRequirement": {
        "type": "object",
        "additionalProperties": false,
        "description": "An entity required for the storyline",
        "required": [
          "role",
          "entityType",
          "description"
        ],
        "properties": {
          "role": {
            "type": "string",
            "description": "Role in the story (e.g., \"witness\", \"informant\", \"target\")"
          },
          "entityType": {
            "type": "string",
            "description": "Type of entity needed (e.g., \"character\", \"location\", \"item\")"
          },
          "description": {
            "type": "string",
            "description": "Description of what's needed"
          },
          "constraints": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Constraints on entity selection/creation"
          },
          "sourceArchiveId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "If derived from an archive, that archive's ID"
          }
        }
      },
      "EntityType": {
        "type": "string",
        "description": "Universal entity type identifier used across Bannou services.\nProvides first-class support for various kinds of entities in analytics,\nachievements, leaderboards, contracts, relationships, and other systems.\n",
        "enum": [
          "system",
          "account",
          "character",
          "actor",
          "guild",
          "organization",
          "government",
          "faction",
          "location",
          "realm",
          "item",
          "monster",
          "custom",
          "other"
        ]
      },
      "EntryMetadata": {
        "type": "object",
        "description": "Metadata for an unlocked entry instance tracking usage and discovery state",
        "additionalProperties": false,
        "properties": {
          "unlockedIn": {
            "type": "string",
            "nullable": true,
            "description": "Context where the entry was unlocked (e.g., location code)"
          },
          "unlockedDuring": {
            "type": "string",
            "nullable": true,
            "description": "Event or activity during which the entry was unlocked"
          },
          "playCount": {
            "type": "integer",
            "default": 0,
            "description": "Number of times this entry has been played or viewed"
          },
          "lastAccessedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this entry was last accessed or played"
          },
          "favorited": {
            "type": "boolean",
            "default": false,
            "description": "Whether this entry has been favorited by the owner"
          },
          "discoveryLevel": {
            "type": "integer",
            "default": 0,
            "description": "Current discovery level for progressive reveal entries"
          },
          "killCount": {
            "type": "integer",
            "default": 0,
            "description": "Kill count for bestiary entries"
          },
          "customData": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Arbitrary custom data for game-specific metadata"
          }
        }
      },
      "EntryTemplateResponse": {
        "type": "object",
        "description": "Entry template with all fields",
        "additionalProperties": false,
        "required": [
          "entryTemplateId",
          "code",
          "collectionType",
          "gameServiceId",
          "displayName",
          "hideWhenLocked",
          "itemTemplateId",
          "createdAt"
        ],
        "properties": {
          "entryTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique entry template identifier"
          },
          "code": {
            "type": "string",
            "description": "Unique code within this collection type and game service"
          },
          "collectionType": {
            "$ref": "#/components/schemas/CollectionType",
            "description": "Type of collection this entry belongs to"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this entry template is scoped to"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable display name"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Category within the collection type"
          },
          "tags": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Searchable tags"
          },
          "assetId": {
            "type": "string",
            "nullable": true,
            "description": "Primary asset identifier"
          },
          "thumbnailAssetId": {
            "type": "string",
            "nullable": true,
            "description": "Thumbnail or preview asset identifier"
          },
          "unlockHint": {
            "type": "string",
            "nullable": true,
            "description": "Hint text about how to unlock this entry"
          },
          "hideWhenLocked": {
            "type": "boolean",
            "description": "Whether this entry is hidden until unlocked"
          },
          "itemTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Item template used when granting this entry"
          },
          "discoveryLevels": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/DiscoveryLevel"
            },
            "description": "Progressive discovery levels"
          },
          "themes": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Theme tags for music entries"
          },
          "duration": {
            "type": "string",
            "nullable": true,
            "description": "Duration of the content"
          },
          "loopPoint": {
            "type": "string",
            "nullable": true,
            "description": "Loop point for music entries"
          },
          "composer": {
            "type": "string",
            "nullable": true,
            "description": "Composer or creator name"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this entry template was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this entry template was last updated"
          }
        }
      },
      "EscrowAgreement": {
        "type": "object",
        "description": "Main escrow agreement record",
        "required": [
          "id",
          "escrowType",
          "trustMode",
          "parties",
          "expectedDeposits",
          "deposits",
          "consents",
          "status",
          "requiredConsentsForRelease",
          "createdAt",
          "createdBy",
          "createdByType",
          "expiresAt"
        ],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique escrow agreement identifier"
          },
          "escrowType": {
            "$ref": "#/components/schemas/EscrowType",
            "description": "Type of escrow agreement"
          },
          "trustMode": {
            "$ref": "#/components/schemas/EscrowTrustMode",
            "description": "Trust mode for the escrow"
          },
          "trustedPartyId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "For single_party_trusted - which party has authority"
          },
          "trustedPartyType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EntityType"
              }
            ],
            "nullable": true,
            "description": "Type of the trusted party"
          },
          "initiatorServiceId": {
            "type": "string",
            "nullable": true,
            "description": "For initiator_trusted - which service created this"
          },
          "parties": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowParty"
            },
            "description": "All parties involved in the escrow"
          },
          "expectedDeposits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExpectedDeposit"
            },
            "description": "What deposits are expected from each party"
          },
          "deposits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowDeposit"
            },
            "description": "Actual deposits received"
          },
          "releaseAllocations": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/ReleaseAllocation"
            },
            "description": "How assets should be distributed on release"
          },
          "boundContractId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract governing conditions for this escrow"
          },
          "consents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowConsent"
            },
            "description": "Consent decisions from parties"
          },
          "status": {
            "$ref": "#/components/schemas/EscrowStatus",
            "description": "Current escrow status"
          },
          "requiredConsentsForRelease": {
            "type": "integer",
            "description": "How many parties must consent for release (-1 = all required)"
          },
          "lastValidatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the escrow was last validated"
          },
          "validationFailures": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/ValidationFailure"
            },
            "description": "Any validation failures detected"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the escrow was created"
          },
          "createdBy": {
            "type": "string",
            "format": "uuid",
            "description": "Who created the escrow"
          },
          "createdByType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the creator entity"
          },
          "fundedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When all expected deposits were received"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "Auto-refund if not completed by this time"
          },
          "completedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the escrow reached terminal state"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "What this escrow is for (e.g., trade, auction, contract)"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of the referenced entity"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Game/application specific metadata"
          },
          "resolution": {
            "$ref": "#/components/schemas/EscrowResolution",
            "description": "How the escrow was resolved",
            "nullable": true
          },
          "resolutionNotes": {
            "type": "string",
            "nullable": true,
            "description": "Notes about the resolution"
          },
          "releaseMode": {
            "$ref": "#/components/schemas/ReleaseMode",
            "description": "How release confirmation is handled for this escrow."
          },
          "refundMode": {
            "$ref": "#/components/schemas/RefundMode",
            "description": "How refund confirmation is handled for this escrow."
          },
          "confirmationDeadline": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Deadline for party confirmations when in Releasing/Refunding state."
          }
        }
      },
      "EscrowAsset": {
        "type": "object",
        "description": "An asset held in escrow",
        "required": [
          "assetType",
          "sourceOwnerId",
          "sourceOwnerType"
        ],
        "properties": {
          "assetType": {
            "$ref": "#/components/schemas/AssetType",
            "description": "Type of asset held in escrow"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "For assetType=currency - currency definition ID"
          },
          "currencyCode": {
            "type": "string",
            "nullable": true,
            "description": "Denormalized currency code for display"
          },
          "currencyAmount": {
            "type": "number",
            "nullable": true,
            "description": "Amount of currency"
          },
          "itemInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "For assetType=item - unique item instance ID"
          },
          "itemName": {
            "type": "string",
            "nullable": true,
            "description": "Denormalized item name for display"
          },
          "itemTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "For assetType=item_stack - stackable item template"
          },
          "itemTemplateName": {
            "type": "string",
            "nullable": true,
            "description": "Denormalized template name for display"
          },
          "itemQuantity": {
            "type": "integer",
            "nullable": true,
            "description": "For assetType=item_stack - quantity"
          },
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "For assetType=contract - contract instance ID"
          },
          "contractTemplateCode": {
            "type": "string",
            "nullable": true,
            "description": "Denormalized contract template code"
          },
          "contractDescription": {
            "type": "string",
            "nullable": true,
            "description": "Description of the contract"
          },
          "contractPartyRole": {
            "type": "string",
            "nullable": true,
            "description": "Which party role in the contract is being escrowed"
          },
          "customAssetType": {
            "type": "string",
            "nullable": true,
            "description": "For assetType=custom - registered handler type"
          },
          "customAssetId": {
            "type": "string",
            "nullable": true,
            "description": "Custom asset identifier"
          },
          "customAssetData": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Handler-specific data"
          },
          "sourceOwnerId": {
            "type": "string",
            "format": "uuid",
            "description": "Where this asset came from (for refunds)"
          },
          "sourceOwnerType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the source owner"
          },
          "sourceContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Source wallet/container ID"
          }
        }
      },
      "EscrowAssetBundle": {
        "type": "object",
        "description": "Groups multiple assets for a single deposit or release",
        "required": [
          "bundleId",
          "assets"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "format": "uuid",
            "description": "Bundle identifier"
          },
          "assets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAsset"
            },
            "description": "Assets in this bundle"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Summary for display"
          },
          "estimatedValue": {
            "type": "number",
            "nullable": true,
            "description": "Optional valuation for UI display"
          }
        }
      },
      "EscrowAssetBundleInput": {
        "type": "object",
        "description": "Input for specifying a bundle of assets",
        "required": [
          "assets"
        ],
        "properties": {
          "assets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAssetInput"
            },
            "description": "Assets to deposit"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Bundle description"
          },
          "estimatedValue": {
            "type": "number",
            "nullable": true,
            "description": "Estimated value"
          }
        }
      },
      "EscrowAssetInput": {
        "type": "object",
        "description": "Input for specifying an asset in escrow operations",
        "required": [
          "assetType"
        ],
        "properties": {
          "assetType": {
            "$ref": "#/components/schemas/AssetType",
            "description": "Type of asset to deposit"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Currency definition ID"
          },
          "currencyCode": {
            "type": "string",
            "nullable": true,
            "description": "Currency code"
          },
          "currencyAmount": {
            "type": "number",
            "nullable": true,
            "description": "Currency amount"
          },
          "itemInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Item instance ID"
          },
          "itemName": {
            "type": "string",
            "nullable": true,
            "description": "Item name"
          },
          "itemTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Item template ID (for stacks)"
          },
          "itemTemplateName": {
            "type": "string",
            "nullable": true,
            "description": "Item template name"
          },
          "itemQuantity": {
            "type": "integer",
            "nullable": true,
            "description": "Item quantity (for stacks)"
          },
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract instance ID"
          },
          "contractTemplateCode": {
            "type": "string",
            "nullable": true,
            "description": "Contract template code"
          },
          "contractDescription": {
            "type": "string",
            "nullable": true,
            "description": "Contract description"
          },
          "contractPartyRole": {
            "type": "string",
            "nullable": true,
            "description": "Contract party role being escrowed"
          },
          "customAssetType": {
            "type": "string",
            "nullable": true,
            "description": "Custom asset type"
          },
          "customAssetId": {
            "type": "string",
            "nullable": true,
            "description": "Custom asset ID"
          },
          "customAssetData": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Custom asset data"
          }
        }
      },
      "EscrowConsent": {
        "type": "object",
        "description": "Records a party consent decision",
        "required": [
          "partyId",
          "partyType",
          "consentType",
          "consentedAt"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party giving consent"
          },
          "partyType": {
            "description": "Type of entity (Account, Character, etc.)",
            "$ref": "#/components/schemas/EntityType"
          },
          "consentType": {
            "$ref": "#/components/schemas/EscrowConsentType",
            "description": "Type of consent given"
          },
          "consentedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When consent was given"
          },
          "releaseTokenUsed": {
            "type": "string",
            "nullable": true,
            "description": "Token used (for audit)"
          },
          "notes": {
            "type": "string",
            "nullable": true,
            "description": "Optional notes"
          }
        }
      },
      "EscrowConsentType": {
        "type": "string",
        "description": "Type of consent being given.\n- release: Agrees to release assets to recipients\n- refund: Agrees to refund assets to depositors\n- dispute: Raises a dispute\n- reaffirm: Re-affirms after validation failure\n",
        "enum": [
          "release",
          "refund",
          "dispute",
          "reaffirm"
        ]
      },
      "EscrowDeposit": {
        "type": "object",
        "description": "Records an actual deposit",
        "required": [
          "id",
          "escrowId",
          "partyId",
          "partyType",
          "assets",
          "depositedAt",
          "idempotencyKey"
        ],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Deposit record identifier"
          },
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow this deposit belongs to"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party who deposited"
          },
          "partyType": {
            "description": "Type of entity (Account, Character, etc.)",
            "$ref": "#/components/schemas/EntityType"
          },
          "assets": {
            "$ref": "#/components/schemas/EscrowAssetBundle",
            "description": "Assets deposited"
          },
          "depositedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the deposit was made"
          },
          "depositTokenUsed": {
            "type": "string",
            "nullable": true,
            "description": "Token used (for audit)"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key for this deposit"
          }
        }
      },
      "EscrowDepositRequest": {
        "type": "object",
        "description": "Request from lib-escrow to debit wallet for deposit",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "escrowId",
          "idempotencyKey"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet to debit"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to debit"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to debit for escrow"
          },
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Associated escrow agreement ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Idempotency key"
          }
        }
      },
      "EscrowDepositResponse": {
        "type": "object",
        "description": "Result of escrow deposit (wallet debit)",
        "additionalProperties": false,
        "required": [
          "transaction",
          "newBalance"
        ],
        "properties": {
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Debit transaction record"
          },
          "newBalance": {
            "type": "number",
            "format": "double",
            "description": "Wallet balance after debit"
          }
        }
      },
      "EscrowParty": {
        "type": "object",
        "description": "A party in the escrow agreement",
        "required": [
          "partyId",
          "partyType",
          "role",
          "consentRequired",
          "depositTokenUsed",
          "releaseTokenUsed"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party entity identifier"
          },
          "partyType": {
            "description": "Type of entity (Account, Character, etc.)",
            "$ref": "#/components/schemas/EntityType"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Display name for UI/logging"
          },
          "role": {
            "$ref": "#/components/schemas/EscrowPartyRole",
            "description": "Role of this party in the escrow"
          },
          "consentRequired": {
            "type": "boolean",
            "description": "Whether this party consent is required for release"
          },
          "walletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Party own wallet (where currency comes from/returns to)"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Party own container (where items come from/return to)"
          },
          "escrowWalletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Escrow wallet for THIS party deposits (owned by escrow)"
          },
          "escrowContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Escrow container for THIS party deposits (owned by escrow)"
          },
          "depositToken": {
            "type": "string",
            "nullable": true,
            "description": "Token for depositing (full_consent mode)"
          },
          "depositTokenUsed": {
            "type": "boolean",
            "description": "Whether the deposit token has been used"
          },
          "depositTokenUsedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the deposit token was used"
          },
          "releaseToken": {
            "type": "string",
            "nullable": true,
            "description": "Token for consenting to release"
          },
          "releaseTokenUsed": {
            "type": "boolean",
            "description": "Whether the release token has been used"
          },
          "releaseTokenUsedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the release token was used"
          }
        }
      },
      "EscrowPartyRole": {
        "type": "string",
        "description": "Role of a party in the escrow.\n- depositor: Deposits assets into escrow\n- recipient: Receives assets when released\n- depositor_recipient: Both deposits and can receive (typical for trades)\n- arbiter: Can resolve disputes, does not deposit or receive\n- observer: Can view status but cannot act\n",
        "enum": [
          "depositor",
          "recipient",
          "depositor_recipient",
          "arbiter",
          "observer"
        ]
      },
      "EscrowRefundRequest": {
        "type": "object",
        "description": "Request from lib-escrow to credit depositor on refund",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "escrowId",
          "idempotencyKey"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Depositor wallet to credit"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to credit"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to refund"
          },
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Associated escrow agreement ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Idempotency key"
          }
        }
      },
      "EscrowRefundResponse": {
        "type": "object",
        "description": "Result of escrow refund (depositor credit)",
        "additionalProperties": false,
        "required": [
          "transaction",
          "newBalance"
        ],
        "properties": {
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Credit transaction record"
          },
          "newBalance": {
            "type": "number",
            "format": "double",
            "description": "Depositor balance after credit"
          }
        }
      },
      "EscrowReleaseRequest": {
        "type": "object",
        "description": "Request from lib-escrow to credit recipient on completion",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "escrowId",
          "idempotencyKey"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Recipient wallet to credit"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to credit"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to credit"
          },
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Associated escrow agreement ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Idempotency key"
          }
        }
      },
      "EscrowReleaseResponse": {
        "type": "object",
        "description": "Result of escrow release (recipient credit)",
        "additionalProperties": false,
        "required": [
          "transaction",
          "newBalance"
        ],
        "properties": {
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Credit transaction record"
          },
          "newBalance": {
            "type": "number",
            "format": "double",
            "description": "Recipient balance after credit"
          }
        }
      },
      "EscrowResolution": {
        "type": "string",
        "description": "How the escrow was resolved.\n- released: Assets went to designated recipients\n- refunded: Assets returned to depositors\n- split: Arbiter split assets between parties\n- expired_refunded: Timed out, auto-refunded\n- cancelled_refunded: Cancelled, deposits refunded\n- violation_refunded: Validation failure caused refund\n",
        "enum": [
          "released",
          "refunded",
          "split",
          "expired_refunded",
          "cancelled_refunded",
          "violation_refunded"
        ]
      },
      "EscrowStatus": {
        "type": "string",
        "description": "Current status of the escrow agreement.\n- pending_deposits: Waiting for parties to deposit\n- partially_funded: Some but not all deposits received\n- funded: All deposits received, awaiting consent/condition\n- pending_consent: Some consents received, waiting for more\n- pending_condition: Waiting for contract fulfillment or external verification\n- finalizing: Running contract finalizer prebound APIs (transient)\n- releasing: Release in progress (transient)\n- released: Assets transferred to recipients\n- refunding: Refund in progress (transient)\n- refunded: Assets returned to depositors\n- disputed: In dispute, arbiter must resolve\n- expired: Timed out without completion\n- cancelled: Cancelled before funding complete\n- validation_failed: Held assets changed, awaiting re-affirmation\n",
        "enum": [
          "pending_deposits",
          "partially_funded",
          "funded",
          "pending_consent",
          "pending_condition",
          "finalizing",
          "releasing",
          "released",
          "refunding",
          "refunded",
          "disputed",
          "expired",
          "cancelled",
          "validation_failed"
        ]
      },
      "EscrowTrustMode": {
        "type": "string",
        "description": "Trust model for the escrow agreement.\n- full_consent: All parties must explicitly consent using tokens\n- initiator_trusted: The service that created the escrow can complete unilaterally\n- single_party_trusted: A designated party can complete unilaterally\n",
        "enum": [
          "full_consent",
          "initiator_trusted",
          "single_party_trusted"
        ]
      },
      "EscrowType": {
        "type": "string",
        "description": "Type of escrow agreement.\n- two_party: Simple trade escrow between Party A and Party B\n- multi_party: N parties with complex deposit/receive rules\n- conditional: Release based on external condition or contract fulfillment\n- auction: Winner-takes-all with refunds to losers\n",
        "enum": [
          "two_party",
          "multi_party",
          "conditional",
          "auction"
        ]
      },
      "EventCategory": {
        "type": "string",
        "description": "Categories of historical events that characters can participate in",
        "enum": [
          "WAR",
          "NATURAL_DISASTER",
          "POLITICAL",
          "ECONOMIC",
          "RELIGIOUS",
          "CULTURAL",
          "PERSONAL"
        ]
      },
      "ExecuteCleanupRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to execute cleanup for a resource",
        "required": [
          "resourceType",
          "resourceId"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource to clean up (opaque identifier)"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource to clean up"
          },
          "gracePeriodSeconds": {
            "type": "integer",
            "nullable": true,
            "description": "Override grace period in seconds (uses default if not specified, 0 to skip)"
          },
          "cleanupPolicy": {
            "$ref": "#/components/schemas/CleanupPolicy",
            "nullable": true,
            "description": "Override cleanup policy (uses resource default if not specified)"
          },
          "dryRun": {
            "type": "boolean",
            "nullable": true,
            "description": "If true, returns what callbacks WOULD execute without actually\nexecuting them. Useful for pre-deletion validation and debugging.\nDefaults to false.\n"
          }
        }
      },
      "ExecuteCleanupResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response after attempting to execute cleanup",
        "required": [
          "resourceType",
          "resourceId",
          "success",
          "dryRun",
          "callbackResults"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource cleaned up"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource cleaned up"
          },
          "success": {
            "type": "boolean",
            "description": "True if cleanup completed (per cleanup policy)"
          },
          "abortReason": {
            "type": "string",
            "nullable": true,
            "description": "Why cleanup was aborted (refcount changed, callback failed with ALL_REQUIRED, etc.)"
          },
          "callbackResults": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CleanupCallbackResult"
            },
            "description": "Results of each cleanup callback"
          },
          "cleanupDurationMs": {
            "type": "integer",
            "description": "Total cleanup execution time in milliseconds"
          },
          "dryRun": {
            "type": "boolean",
            "description": "True if this was a preview (no callbacks were actually executed)"
          }
        }
      },
      "ExecuteCompressRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to compress a resource",
        "required": [
          "resourceType",
          "resourceId"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource to compress"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource to compress"
          },
          "deleteSourceData": {
            "type": "boolean",
            "default": false,
            "description": "If true, invoke cleanup callbacks after successful archival"
          },
          "compressionPolicy": {
            "$ref": "#/components/schemas/CompressionPolicy",
            "nullable": true,
            "description": "Override policy (uses default from config if not specified)"
          },
          "dryRun": {
            "type": "boolean",
            "default": false,
            "description": "If true, return what would be compressed without executing"
          }
        }
      },
      "ExecuteCompressResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Compression execution result",
        "required": [
          "resourceType",
          "resourceId",
          "success",
          "dryRun",
          "callbackResults",
          "compressionDurationMs"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource compressed"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource compressed"
          },
          "success": {
            "type": "boolean",
            "description": "True if compression completed successfully"
          },
          "archiveId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of created archive (null if failed or dryRun)"
          },
          "abortReason": {
            "type": "string",
            "nullable": true,
            "description": "Why compression was aborted"
          },
          "callbackResults": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CompressCallbackResult"
            },
            "description": "Results of each compression callback"
          },
          "sourceDataDeleted": {
            "type": "boolean",
            "description": "Whether cleanup callbacks were executed after archival"
          },
          "dryRun": {
            "type": "boolean",
            "description": "True if this was a preview (no callbacks actually executed)"
          },
          "compressionDurationMs": {
            "type": "integer",
            "description": "Total compression execution time in milliseconds"
          }
        }
      },
      "ExecuteContractRequest": {
        "type": "object",
        "description": "Request to execute contract clauses",
        "additionalProperties": false,
        "required": [
          "contractInstanceId"
        ],
        "properties": {
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Idempotency key for the execution"
          }
        }
      },
      "ExecuteContractResponse": {
        "type": "object",
        "description": "Response from executing a contract",
        "additionalProperties": false,
        "required": [
          "executed",
          "alreadyExecuted"
        ],
        "properties": {
          "executed": {
            "type": "boolean",
            "description": "Whether execution was successful"
          },
          "alreadyExecuted": {
            "type": "boolean",
            "description": "True if this was a repeat call (idempotency)"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "distributions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ClauseDistributionResult"
            },
            "nullable": true,
            "description": "Per-clause distribution outcomes with success/failure details"
          },
          "executedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When execution occurred"
          }
        }
      },
      "ExecuteConversionRequest": {
        "type": "object",
        "description": "Request to execute a currency conversion",
        "additionalProperties": false,
        "required": [
          "walletId",
          "fromCurrencyId",
          "toCurrencyId",
          "fromAmount",
          "idempotencyKey"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet to perform conversion in"
          },
          "fromCurrencyId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to debit"
          },
          "toCurrencyId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to credit"
          },
          "fromAmount": {
            "type": "number",
            "format": "double",
            "description": "Amount to convert"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Unique key for idempotency"
          }
        }
      },
      "ExecuteConversionResponse": {
        "type": "object",
        "description": "Result of conversion execution",
        "additionalProperties": false,
        "required": [
          "debitTransaction",
          "creditTransaction",
          "fromDebited",
          "toCredited",
          "effectiveRate"
        ],
        "properties": {
          "debitTransaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Debit transaction (conversion_debit)"
          },
          "creditTransaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Credit transaction (conversion_credit)"
          },
          "fromDebited": {
            "type": "number",
            "format": "double",
            "description": "Amount debited"
          },
          "toCredited": {
            "type": "number",
            "format": "double",
            "description": "Amount credited"
          },
          "effectiveRate": {
            "type": "number",
            "format": "double",
            "description": "Rate applied"
          }
        }
      },
      "ExecuteSnapshotRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to create an ephemeral snapshot of a living resource",
        "required": [
          "resourceType",
          "resourceId"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource to snapshot (opaque identifier).\nMust match compression callback registrations.\n"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource to snapshot"
          },
          "snapshotType": {
            "type": "string",
            "description": "Optional label for the snapshot purpose (e.g., \"storyline_seed\", \"analytics\").\nStored in metadata for filtering/debugging.\n"
          },
          "ttlSeconds": {
            "type": "integer",
            "nullable": true,
            "description": "Time-to-live in seconds for the snapshot.\nIf not specified, uses the configured default (RESOURCE_SNAPSHOT_DEFAULT_TTL_SECONDS).\nValue is clamped to configured min/max range.\nSnapshot is automatically deleted by Redis after TTL expires.\n"
          },
          "compressionPolicy": {
            "$ref": "#/components/schemas/CompressionPolicy",
            "nullable": true,
            "description": "Policy for callback execution.\nIf not specified, uses the configured default (RESOURCE_DEFAULT_COMPRESSION_POLICY).\n"
          },
          "dryRun": {
            "type": "boolean",
            "default": false,
            "description": "If true, return what would be captured without storing"
          },
          "filterSourceTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Optional list of source types to include in the snapshot.\nOnly compression callbacks matching these source types will be executed.\nIf omitted or empty, all registered compression callbacks are executed.\nExample: [\"character-personality\", \"character-history\"]\n"
          }
        }
      },
      "ExecuteSnapshotResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of snapshot execution",
        "required": [
          "resourceType",
          "resourceId",
          "success",
          "dryRun",
          "snapshotDurationMs"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource snapshotted"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource snapshotted"
          },
          "success": {
            "type": "boolean",
            "description": "True if snapshot completed successfully"
          },
          "dryRun": {
            "type": "boolean",
            "description": "True if this was a dry run"
          },
          "snapshotId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Unique ID for this snapshot (null on failure or dry run)"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this snapshot will expire (null on failure or dry run)"
          },
          "abortReason": {
            "type": "string",
            "nullable": true,
            "description": "Why snapshot was aborted"
          },
          "callbackResults": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CompressCallbackResult"
            },
            "description": "Results of each compression callback"
          },
          "snapshotDurationMs": {
            "type": "integer",
            "description": "Total snapshot execution time in milliseconds"
          }
        }
      },
      "ExecutionMetadata": {
        "type": "object",
        "additionalProperties": false,
        "description": "Metadata about behavior execution requirements including timing, resources, and interrupt conditions",
        "properties": {
          "estimatedDuration": {
            "type": "integer",
            "description": "Estimated execution time in seconds"
          },
          "resourceRequirements": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            },
            "nullable": true,
            "description": "Resource requirements for behavior execution"
          },
          "interruptConditions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Conditions that can interrupt behavior execution"
          }
        }
      },
      "ExpectedDeposit": {
        "type": "object",
        "description": "Defines what a party should deposit",
        "required": [
          "partyId",
          "partyType",
          "expectedAssets",
          "optional",
          "fulfilled"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party who should deposit"
          },
          "partyType": {
            "description": "Type of depositing party",
            "$ref": "#/components/schemas/EntityType"
          },
          "expectedAssets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAsset"
            },
            "description": "Expected assets from this party"
          },
          "optional": {
            "type": "boolean",
            "description": "Is this deposit optional"
          },
          "depositDeadline": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Deadline for this specific deposit"
          },
          "fulfilled": {
            "type": "boolean",
            "description": "Has this party fulfilled their deposit requirement"
          }
        }
      },
      "ExpectedDepositInput": {
        "type": "object",
        "description": "Input for defining expected deposits from a party",
        "required": [
          "partyId",
          "partyType",
          "expectedAssets"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party who should deposit"
          },
          "partyType": {
            "description": "Type of depositing party",
            "$ref": "#/components/schemas/EntityType"
          },
          "expectedAssets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAssetInput"
            },
            "description": "Expected assets"
          },
          "optional": {
            "type": "boolean",
            "nullable": true,
            "description": "Is this deposit optional"
          },
          "depositDeadline": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Specific deadline for this deposit"
          }
        }
      },
      "ExpirationPolicy": {
        "type": "string",
        "description": "How currency expiration is determined",
        "enum": [
          "fixed_date",
          "duration_from_earn",
          "end_of_season"
        ]
      },
      "ExportSavesRequest": {
        "type": "object",
        "description": "Request to export all saves for an owner to a downloadable archive",
        "required": [
          "gameId",
          "ownerId",
          "ownerType"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID that owns the saves to export"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns the saves to export"
          },
          "slotNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Specific slots to export (all if null)"
          }
        }
      },
      "ExportSavesResponse": {
        "type": "object",
        "description": "Response with pre-signed URL for downloading exported save archive",
        "required": [
          "downloadUrl",
          "expiresAt",
          "sizeBytes"
        ],
        "properties": {
          "downloadUrl": {
            "type": "string",
            "format": "uri",
            "description": "Pre-signed URL to download export archive"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the download URL expires"
          },
          "sizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Archive size"
          }
        }
      },
      "FactionArchive": {
        "type": "object",
        "x-archive-type": true,
        "description": "Complete faction membership data for archive storage and storyline SDK consumption.\nInherits base archive properties from ResourceArchiveBase.\nThe characterId field equals resourceId for convenience.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/ResourceArchiveBase"
          }
        ],
        "additionalProperties": false,
        "required": [
          "characterId",
          "hasMemberships",
          "membershipCount"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character this data belongs to (equals resourceId)"
          },
          "hasMemberships": {
            "type": "boolean",
            "description": "Whether any faction memberships exist"
          },
          "membershipCount": {
            "type": "integer",
            "minimum": 0,
            "description": "Number of membership records in archive"
          },
          "memberships": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/FactionMemberResponse"
            },
            "description": "Faction membership records (null if hasMemberships is false)"
          }
        }
      },
      "FactionMemberResponse": {
        "type": "object",
        "description": "Faction membership record linking a character to a faction with a role",
        "additionalProperties": false,
        "required": [
          "factionId",
          "characterId",
          "role",
          "joinedAt"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction the character belongs to"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character who is a member"
          },
          "role": {
            "$ref": "#/components/schemas/FactionMemberRole",
            "description": "Member's role in the faction"
          },
          "joinedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the character joined the faction"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the membership was last updated (role change)"
          }
        }
      },
      "FactionMemberRole": {
        "type": "string",
        "description": "Role hierarchy for faction membership",
        "enum": [
          "Leader",
          "Officer",
          "Member",
          "Recruit"
        ]
      },
      "FactionResponse": {
        "type": "object",
        "description": "Complete faction entity with seed growth status",
        "additionalProperties": false,
        "required": [
          "factionId",
          "gameServiceId",
          "name",
          "code",
          "realmId",
          "isRealmBaseline",
          "status",
          "memberCount",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the faction"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this faction belongs to"
          },
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 256,
            "description": "Display name of the faction"
          },
          "code": {
            "type": "string",
            "minLength": 1,
            "maxLength": 128,
            "description": "Unique code within the game service (e.g., \"thieves_guild\")"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "maxLength": 2048,
            "description": "Human-readable description of the faction"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm this faction belongs to"
          },
          "isRealmBaseline": {
            "type": "boolean",
            "description": "Whether this faction is the realm's baseline cultural faction"
          },
          "parentFactionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Parent faction in hierarchy (null for top-level factions)"
          },
          "seedId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Associated seed for growth tracking (null if seed creation failed)"
          },
          "status": {
            "$ref": "#/components/schemas/FactionStatus",
            "description": "Current lifecycle status"
          },
          "currentPhase": {
            "type": "string",
            "nullable": true,
            "maxLength": 64,
            "description": "Current seed growth phase (denormalized from lib-seed for convenience)"
          },
          "memberCount": {
            "type": "integer",
            "minimum": 0,
            "description": "Current number of members in this faction"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this faction was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this faction was last updated"
          }
        }
      },
      "FactionStatus": {
        "type": "string",
        "description": "Lifecycle status of a faction entity",
        "enum": [
          "Active",
          "Deprecated",
          "Dissolved"
        ]
      },
      "FailMilestoneRequest": {
        "type": "object",
        "description": "Request to fail a milestone",
        "additionalProperties": false,
        "required": [
          "contractId",
          "milestoneCode"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "milestoneCode": {
            "type": "string",
            "description": "Milestone that failed"
          },
          "reason": {
            "type": "string",
            "maxLength": 1000,
            "nullable": true,
            "description": "Reason for failure"
          }
        }
      },
      "FamilyMember": {
        "description": "Reference to a family member",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId",
          "relationshipType"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the related character"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "Display name (if available)"
          },
          "relationshipType": {
            "type": "string",
            "description": "Specific relationship type (MOTHER, FATHER, SON, DAUGHTER, etc.)"
          },
          "isAlive": {
            "type": "boolean",
            "description": "Whether the related character is alive"
          }
        }
      },
      "FamilyTreeResponse": {
        "description": "Family relationships for a character",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "parents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FamilyMember"
            },
            "description": "Parent relationships (biological and adoptive)"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FamilyMember"
            },
            "description": "Child relationships"
          },
          "siblings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FamilyMember"
            },
            "description": "Sibling relationships (including half-siblings)"
          },
          "spouses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FamilyMember"
            },
            "description": "Spousal relationships (spouse, husband, wife)"
          },
          "pastLives": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PastLifeReference"
            },
            "description": "Previous incarnations (if reincarnation tracked)"
          }
        }
      },
      "FinalizerResult": {
        "type": "object",
        "description": "Result from a contract finalizer API call",
        "required": [
          "endpoint",
          "success"
        ],
        "properties": {
          "endpoint": {
            "type": "string",
            "description": "Finalizer endpoint"
          },
          "success": {
            "type": "boolean",
            "description": "Whether it succeeded"
          },
          "error": {
            "type": "string",
            "nullable": true,
            "description": "Error message if failed"
          }
        }
      },
      "FindAssetUsageRequest": {
        "type": "object",
        "description": "Request to find asset usage",
        "required": [
          "assetId"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "format": "uuid",
            "description": "Asset ID to find usage of"
          },
          "gameId": {
            "type": "string",
            "nullable": true,
            "description": "Optional game filter"
          }
        }
      },
      "FindAssetUsageResponse": {
        "type": "object",
        "description": "Scenes using the asset",
        "required": [
          "usages"
        ],
        "properties": {
          "usages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetUsageInfo"
            },
            "description": "Asset usage instances"
          }
        }
      },
      "FindReferencesRequest": {
        "type": "object",
        "description": "Request to find referencing scenes",
        "required": [
          "sceneId"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene ID to find references to"
          }
        }
      },
      "FindReferencesResponse": {
        "type": "object",
        "description": "Scenes that reference the target",
        "required": [
          "referencingScenes"
        ],
        "properties": {
          "referencingScenes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ReferenceInfo"
            },
            "description": "Scenes containing references"
          }
        }
      },
      "FindSpaceRequest": {
        "type": "object",
        "description": "Request to find space for item",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "templateId"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner to search"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Owner type"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Item template"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "default": 1,
            "description": "Quantity to place"
          },
          "preferStackable": {
            "type": "boolean",
            "default": true,
            "description": "Prefer existing stacks"
          }
        }
      },
      "FindSpaceResponse": {
        "type": "object",
        "description": "Find space result",
        "additionalProperties": false,
        "required": [
          "hasSpace",
          "candidates"
        ],
        "properties": {
          "hasSpace": {
            "type": "boolean",
            "description": "Whether space found"
          },
          "candidates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpaceCandidate"
            },
            "description": "Potential placements"
          }
        }
      },
      "FollowerResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Follower record linking a character to a deity",
        "required": [
          "characterId",
          "deityId",
          "registeredAt",
          "relationshipId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Follower character ID"
          },
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity being followed"
          },
          "registeredAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the follower relationship was created"
          },
          "relationshipId": {
            "type": "string",
            "format": "uuid",
            "description": "Underlying relationship record ID from lib-relationship"
          }
        }
      },
      "FormTemplate": {
        "description": "A musical form structure template",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "name",
          "sections"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Form name (e.g., \"AABB\", \"verse-chorus\")"
          },
          "sections": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Section sequence (e.g., [\"A\", \"A\", \"B\", \"B\"])"
          },
          "barsPerSection": {
            "type": "integer",
            "minimum": 1,
            "maximum": 64,
            "default": 8,
            "description": "Default bars per section"
          }
        }
      },
      "GameActionRequest": {
        "description": "Request to perform a game action such as movement or combat",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "sessionId",
          "accountId",
          "gameType",
          "actionType"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID of the client. Provided by shortcut system."
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player. Provided by shortcut system."
          },
          "gameType": {
            "type": "string",
            "description": "Game type for the action. Determines which lobby to apply the action. Provided by shortcut system."
          },
          "actionType": {
            "$ref": "#/components/schemas/GameActionType",
            "description": "Type of game action to perform"
          },
          "actionData": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Action-specific data"
          },
          "targetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Target of the action (if applicable)"
          }
        }
      },
      "GameActionResponse": {
        "description": "Response indicating the result of a game action with any state changes",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "actionId"
        ],
        "properties": {
          "actionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this action instance"
          },
          "result": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Action result data"
          },
          "newGameState": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Updated game state (if applicable)"
          }
        }
      },
      "GameActionType": {
        "type": "string",
        "description": "Type of game action",
        "enum": [
          "move",
          "interact",
          "attack",
          "cast_spell",
          "use_item"
        ]
      },
      "GamePlayer": {
        "description": "Information about a player currently participating in a game session",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "accountId",
          "sessionId",
          "joinedAt",
          "role"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the player's account"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID that joined the game. Chat and events are delivered to this specific session only."
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Display name shown to other players"
          },
          "role": {
            "$ref": "#/components/schemas/PlayerRole",
            "description": "Role of the player in the game session"
          },
          "joinedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the player joined the session"
          },
          "characterData": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Game-specific character data for this player (null if none provided)"
          },
          "voiceSessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Voice participant session ID (if player has joined voice)"
          }
        }
      },
      "GameRealm": {
        "type": "string",
        "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\nUse \"shared\" for assets that are available across all realms.\n"
      },
      "GameSessionResponse": {
        "description": "Complete details of a game session including players and settings",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "sessionId",
          "gameType",
          "status",
          "createdAt",
          "sessionType"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the game session"
          },
          "gameType": {
            "$ref": "#/components/schemas/GameType",
            "description": "Type of game for this session"
          },
          "sessionType": {
            "$ref": "#/components/schemas/SessionType",
            "description": "Type of session - lobby or matchmade"
          },
          "sessionName": {
            "type": "string",
            "nullable": true,
            "description": "Display name for the session"
          },
          "status": {
            "$ref": "#/components/schemas/SessionStatus",
            "description": "Current status of the game session"
          },
          "maxPlayers": {
            "type": "integer",
            "description": "Maximum number of players allowed in the session"
          },
          "currentPlayers": {
            "type": "integer",
            "description": "Current number of players in the session"
          },
          "isPrivate": {
            "type": "boolean",
            "description": "Whether the session requires a password to join"
          },
          "owner": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the session owner"
          },
          "players": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GamePlayer"
            },
            "description": "List of players currently in the session"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the session was created"
          },
          "gameSettings": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Game-specific configuration settings"
          },
          "reservations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ReservationInfo"
            },
            "nullable": true,
            "description": "For matchmade sessions - reservation tokens for expected players"
          },
          "reservationExpiresAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "For matchmade sessions - when reservations expire"
          }
        }
      },
      "GameType": {
        "type": "string",
        "description": "Game service stub name for this session. Use the game service's stubName property (e.g., \"my-game\"). Use \"generic\" for non-game-specific sessions."
      },
      "GardenStateResponse": {
        "type": "object",
        "description": "Current garden instance state for a player",
        "required": [
          "gardenInstanceId",
          "seedId",
          "accountId",
          "position",
          "activePois"
        ],
        "properties": {
          "gardenInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this garden instance"
          },
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "Active seed for this garden session"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account in the garden"
          },
          "position": {
            "$ref": "#/components/schemas/Vec3",
            "description": "Current player position"
          },
          "activePois": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PoiSummary"
            },
            "description": "Currently active POIs in this garden instance"
          }
        }
      },
      "GenerateCompositionRequest": {
        "description": "Request to generate a complete musical composition",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "styleId"
        ],
        "properties": {
          "styleId": {
            "type": "string",
            "description": "ID of the style to use for generation",
            "example": "celtic"
          },
          "durationBars": {
            "type": "integer",
            "minimum": 4,
            "maximum": 256,
            "default": 32,
            "description": "Target duration in bars"
          },
          "key": {
            "$ref": "#/components/schemas/KeySignature",
            "nullable": true,
            "description": "Key signature (random if not specified)"
          },
          "tempo": {
            "type": "integer",
            "minimum": 40,
            "maximum": 240,
            "description": "Tempo in BPM (uses style default if not specified)"
          },
          "mood": {
            "type": "string",
            "enum": [
              "bright",
              "dark",
              "neutral",
              "melancholic",
              "triumphant"
            ],
            "nullable": true,
            "description": "Mood constraint for generation"
          },
          "tuneType": {
            "type": "string",
            "nullable": true,
            "description": "Style-specific tune type (e.g., \"reel\", \"jig\" for Celtic)",
            "example": "reel"
          },
          "seed": {
            "type": "integer",
            "nullable": true,
            "description": "Random seed for reproducible generation"
          },
          "narrative": {
            "$ref": "#/components/schemas/NarrativeOptions",
            "nullable": true,
            "description": "Narrative/emotional arc options for storyteller-driven composition.\nIf omitted, narrative is inferred from mood. When provided, enables\nfine-grained control over emotional journey and tension curves.\n"
          }
        }
      },
      "GenerateCompositionResponse": {
        "description": "Response containing the generated composition",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "compositionId",
          "midiJson"
        ],
        "properties": {
          "compositionId": {
            "type": "string",
            "description": "Unique identifier for the composition"
          },
          "midiJson": {
            "$ref": "#/components/schemas/MidiJson",
            "description": "Generated MIDI-JSON output"
          },
          "metadata": {
            "$ref": "#/components/schemas/CompositionMetadata",
            "nullable": true,
            "description": "Metadata about the generation"
          },
          "generationTimeMs": {
            "type": "integer",
            "description": "Time taken to generate in milliseconds"
          },
          "narrativeUsed": {
            "type": "string",
            "nullable": true,
            "description": "ID of the narrative template used for composition"
          },
          "emotionalJourney": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EmotionalStateSnapshot"
            },
            "nullable": true,
            "description": "Emotional state at each section boundary"
          },
          "tensionCurve": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "nullable": true,
            "description": "Tension values at bar boundaries (0-1 scale)"
          }
        }
      },
      "GenerateMelodyRequest": {
        "description": "Request to generate a melody over harmony",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "harmony"
        ],
        "properties": {
          "harmony": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChordEvent"
            },
            "description": "Chord progression to generate melody over"
          },
          "styleId": {
            "type": "string",
            "nullable": true,
            "description": "Style for melodic preferences"
          },
          "range": {
            "$ref": "#/components/schemas/PitchRange",
            "nullable": true,
            "description": "Pitch range for the melody"
          },
          "contour": {
            "type": "string",
            "enum": [
              "arch",
              "wave",
              "ascending",
              "descending",
              "static"
            ],
            "nullable": true,
            "description": "Overall melodic contour"
          },
          "rhythmDensity": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Note density (0=sparse, 1=dense)"
          },
          "syncopation": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Amount of syncopation"
          },
          "seed": {
            "type": "integer",
            "nullable": true,
            "description": "Random seed for reproducibility"
          }
        }
      },
      "GenerateMelodyResponse": {
        "description": "Response containing a generated melody",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "notes"
        ],
        "properties": {
          "notes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NoteEvent"
            },
            "description": "Generated note events"
          },
          "analysis": {
            "$ref": "#/components/schemas/MelodyAnalysis",
            "nullable": true,
            "description": "Analysis of the melody"
          }
        }
      },
      "GenerateProgressionRequest": {
        "description": "Request to generate a chord progression",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "key",
          "length"
        ],
        "properties": {
          "key": {
            "$ref": "#/components/schemas/KeySignature",
            "description": "Key for the progression"
          },
          "length": {
            "type": "integer",
            "minimum": 2,
            "maximum": 64,
            "description": "Number of chords in the progression"
          },
          "styleId": {
            "type": "string",
            "nullable": true,
            "description": "Style to use for harmonic preferences"
          },
          "startChord": {
            "type": "string",
            "nullable": true,
            "description": "Starting chord (roman numeral, e.g., \"I\")"
          },
          "endChord": {
            "type": "string",
            "nullable": true,
            "description": "Ending chord (roman numeral, e.g., \"I\")"
          },
          "cadenceType": {
            "type": "string",
            "enum": [
              "authentic",
              "half",
              "plagal",
              "deceptive"
            ],
            "nullable": true,
            "description": "Cadence type for ending"
          },
          "allowSecondaryDominants": {
            "type": "boolean",
            "default": true,
            "description": "Allow secondary dominant chords"
          },
          "allowModalInterchange": {
            "type": "boolean",
            "default": false,
            "description": "Allow borrowed chords from parallel modes"
          },
          "seed": {
            "type": "integer",
            "nullable": true,
            "description": "Random seed for reproducibility"
          }
        }
      },
      "GenerateProgressionResponse": {
        "description": "Response containing a generated chord progression",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "chords"
        ],
        "properties": {
          "chords": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChordEvent"
            },
            "description": "Generated chord events"
          },
          "analysis": {
            "$ref": "#/components/schemas/ProgressionAnalysis",
            "nullable": true,
            "description": "Analysis of the progression"
          }
        }
      },
      "GetAccountSubscriptionsRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get subscriptions for an account",
        "required": [
          "accountId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the account to get subscriptions for"
          },
          "includeInactive": {
            "type": "boolean",
            "default": false,
            "description": "If true, include cancelled subscriptions"
          },
          "includeExpired": {
            "type": "boolean",
            "default": false,
            "description": "If true, include expired subscriptions"
          }
        }
      },
      "GetAchievementProgressRequest": {
        "type": "object",
        "description": "Request to get achievement progress",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "entityId",
          "entityType"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type whose progress is requested"
          },
          "achievementId": {
            "type": "string",
            "nullable": true,
            "description": "Specific achievement ID (null for all)"
          }
        }
      },
      "GetActiveScenariosRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request for active scenarios",
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to query"
          }
        }
      },
      "GetActiveScenariosResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Active scenario executions",
        "required": [
          "executions"
        ],
        "properties": {
          "executions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScenarioExecution"
            },
            "description": "Active scenario executions"
          }
        }
      },
      "GetAncestorsRequest": {
        "description": "Request to retrieve all ancestor types in the hierarchy chain from a relationship type up to the root",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "typeId"
        ],
        "properties": {
          "typeId": {
            "type": "string",
            "format": "uuid",
            "description": "The relationship type to get ancestors for"
          }
        }
      },
      "GetArchiveRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to retrieve a compressed archive",
        "required": [
          "resourceType",
          "resourceId"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource"
          },
          "archiveId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Specific version (latest if not specified)"
          }
        }
      },
      "GetArchiveResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response containing archive data",
        "required": [
          "resourceType",
          "resourceId",
          "found"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource"
          },
          "found": {
            "type": "boolean",
            "description": "True if archive exists"
          },
          "archive": {
            "$ref": "#/components/schemas/ResourceArchive",
            "nullable": true,
            "description": "The archive data (null if not found)"
          }
        }
      },
      "GetAreaContentConfigRequest": {
        "type": "object",
        "description": "Request to get an area content config",
        "additionalProperties": false,
        "required": [
          "areaCode",
          "gameServiceId",
          "collectionType"
        ],
        "properties": {
          "areaCode": {
            "type": "string",
            "description": "Area code to look up"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service scope"
          },
          "collectionType": {
            "$ref": "#/components/schemas/CollectionType",
            "description": "Type of collection"
          }
        }
      },
      "GetAssetRequest": {
        "description": "Request to retrieve asset metadata and download URL",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "assetId"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Asset identifier"
          },
          "version": {
            "type": "string",
            "default": "latest",
            "description": "Version ID or 'latest'"
          }
        }
      },
      "GetBackstoryRequest": {
        "type": "object",
        "description": "Request payload for getting a character's backstory",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to get backstory for"
          },
          "elementTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BackstoryElementType"
            },
            "nullable": true,
            "description": "Filter by element types (null for all)"
          },
          "minimumStrength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Filter by minimum strength"
          }
        }
      },
      "GetBalanceRequest": {
        "type": "object",
        "description": "Request to get a specific currency balance",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency definition ID"
          }
        }
      },
      "GetBalanceResponse": {
        "type": "object",
        "description": "Detailed balance information",
        "additionalProperties": false,
        "required": [
          "walletId",
          "currencyDefinitionId",
          "amount",
          "lockedAmount",
          "effectiveAmount"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency definition ID"
          },
          "currencyCode": {
            "type": "string",
            "description": "Currency code"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Total balance"
          },
          "lockedAmount": {
            "type": "number",
            "format": "double",
            "description": "Amount in authorization holds"
          },
          "effectiveAmount": {
            "type": "number",
            "format": "double",
            "description": "Available balance (amount - lockedAmount)"
          },
          "earnCapInfo": {
            "$ref": "#/components/schemas/EarnCapInfo",
            "nullable": true,
            "description": "Earn cap status (null if no caps configured)"
          },
          "autogainInfo": {
            "$ref": "#/components/schemas/AutogainInfo",
            "nullable": true,
            "description": "Autogain status (null if autogain not enabled)"
          }
        }
      },
      "GetBlessingRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get a blessing by ID",
        "required": [
          "blessingId"
        ],
        "properties": {
          "blessingId": {
            "type": "string",
            "format": "uuid",
            "description": "Blessing to retrieve"
          }
        }
      },
      "GetBoardRequest": {
        "type": "object",
        "description": "Request to get a board instance by ID",
        "additionalProperties": false,
        "required": [
          "boardId"
        ],
        "properties": {
          "boardId": {
            "type": "string",
            "format": "uuid",
            "description": "Board instance identifier"
          }
        }
      },
      "GetBoardTemplateRequest": {
        "type": "object",
        "description": "Request to get a board template by ID",
        "additionalProperties": false,
        "required": [
          "boardTemplateId"
        ],
        "properties": {
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template identifier"
          }
        }
      },
      "GetBondForSeedRequest": {
        "type": "object",
        "description": "Request to get the bond for a specific seed.",
        "required": [
          "seedId"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed whose bond to retrieve."
          }
        }
      },
      "GetBondPartnersRequest": {
        "type": "object",
        "description": "Request to get partner seed information.",
        "required": [
          "seedId"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "The requesting seed (returns partner info)."
          }
        }
      },
      "GetBondRequest": {
        "type": "object",
        "description": "Request to get a bond by ID.",
        "required": [
          "bondId"
        ],
        "properties": {
          "bondId": {
            "type": "string",
            "format": "uuid",
            "description": "The bond to retrieve."
          }
        }
      },
      "GetBreachRequest": {
        "type": "object",
        "description": "Request to get breach details",
        "additionalProperties": false,
        "required": [
          "breachId"
        ],
        "properties": {
          "breachId": {
            "type": "string",
            "format": "uuid",
            "description": "Breach ID"
          }
        }
      },
      "GetBundleRequest": {
        "description": "Request to retrieve bundle metadata and download URL",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bundleId"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier to retrieve"
          },
          "format": {
            "$ref": "#/components/schemas/BundleFormat",
            "description": "Desired download format (bannou or zip)"
          }
        }
      },
      "GetCachedBehaviorRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get a cached compiled behavior",
        "required": [
          "behaviorId"
        ],
        "properties": {
          "behaviorId": {
            "type": "string",
            "description": "Unique identifier for the cached behavior"
          }
        }
      },
      "GetCapabilityManifestRequest": {
        "type": "object",
        "description": "Request to get the capability manifest.",
        "required": [
          "seedId"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed whose manifest to retrieve."
          }
        }
      },
      "GetCharacterArchiveRequest": {
        "description": "Request to retrieve a character's compressed archive",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to get archive for"
          }
        }
      },
      "GetCharacterRequest": {
        "description": "Request payload for retrieving a single character by ID",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to retrieve"
          }
        }
      },
      "GetCharactersByRealmRequest": {
        "description": "Request payload for retrieving all characters within a specific realm",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID to query (uses partition key for efficiency)"
          },
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by species"
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CharacterStatus"
              }
            ],
            "nullable": true,
            "description": "Optional status filter"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "GetChildRelationshipTypesRequest": {
        "description": "Request to retrieve all child relationship types for a given parent type",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "parentTypeId"
        ],
        "properties": {
          "parentTypeId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the parent relationship type"
          },
          "recursive": {
            "type": "boolean",
            "default": false,
            "description": "Include all descendants, not just direct children"
          }
        }
      },
      "GetClientCapabilitiesRequest": {
        "type": "object",
        "description": "Request to get capability manifest for a connected session (debugging endpoint)",
        "additionalProperties": false,
        "required": [
          "sessionId"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Session ID to retrieve capabilities for (must have active WebSocket connection)"
          },
          "serviceFilter": {
            "type": "string",
            "description": "Optional filter by service name prefix",
            "nullable": true
          },
          "includeMetadata": {
            "type": "boolean",
            "description": "Include additional metadata about each capability",
            "default": false
          }
        }
      },
      "GetCollectionRequest": {
        "type": "object",
        "description": "Request to get a collection by ID",
        "additionalProperties": false,
        "required": [
          "collectionId"
        ],
        "properties": {
          "collectionId": {
            "type": "string",
            "format": "uuid",
            "description": "Collection instance identifier"
          }
        }
      },
      "GetCombatPreferencesRequest": {
        "type": "object",
        "description": "Request payload for retrieving combat preferences",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to get combat preferences for"
          }
        }
      },
      "GetCompletionStatsRequest": {
        "type": "object",
        "description": "Request to get completion statistics",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "gameServiceId",
          "collectionType"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity that owns the collection"
          },
          "ownerType": {
            "type": "string",
            "description": "Entity type discriminator"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service scope"
          },
          "collectionType": {
            "$ref": "#/components/schemas/CollectionType",
            "description": "Type of collection to get stats for"
          }
        }
      },
      "GetCompressDataRequest": {
        "description": "Request to get character data for compression",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to get compress data for"
          }
        }
      },
      "GetConsentStatusRequest": {
        "type": "object",
        "description": "Request to get consent status for all parties",
        "required": [
          "escrowId"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          }
        }
      },
      "GetConsentStatusResponse": {
        "type": "object",
        "description": "Response containing consent status for all parties",
        "required": [
          "partiesRequiringConsent",
          "consentsReceived",
          "consentsRequired",
          "canRelease",
          "canRefund"
        ],
        "properties": {
          "partiesRequiringConsent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartyConsentStatus"
            },
            "description": "Consent status per party"
          },
          "consentsReceived": {
            "type": "integer",
            "description": "Number of consents received"
          },
          "consentsRequired": {
            "type": "integer",
            "description": "Number of consents required"
          },
          "canRelease": {
            "type": "boolean",
            "description": "Whether release can proceed"
          },
          "canRefund": {
            "type": "boolean",
            "description": "Whether refund can proceed"
          }
        }
      },
      "GetContainerRequest": {
        "type": "object",
        "description": "Request to get a container",
        "additionalProperties": false,
        "required": [
          "containerId"
        ],
        "properties": {
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container ID to retrieve"
          },
          "includeContents": {
            "type": "boolean",
            "default": true,
            "description": "Whether to include item contents"
          }
        }
      },
      "GetContractInstanceRequest": {
        "type": "object",
        "description": "Request to get a contract instance",
        "additionalProperties": false,
        "required": [
          "contractId"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          }
        }
      },
      "GetContractInstanceStatusRequest": {
        "type": "object",
        "description": "Request to get contract status",
        "additionalProperties": false,
        "required": [
          "contractId"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          }
        }
      },
      "GetContractMetadataRequest": {
        "type": "object",
        "description": "Request to get contract metadata",
        "additionalProperties": false,
        "required": [
          "contractId"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          }
        }
      },
      "GetContractTemplateRequest": {
        "type": "object",
        "description": "Request to get a contract template",
        "additionalProperties": false,
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Template ID (provide this or code)"
          },
          "code": {
            "type": "string",
            "nullable": true,
            "description": "Template code (provide this or templateId)"
          }
        }
      },
      "GetControllingFactionRequest": {
        "type": "object",
        "description": "Request to get the controlling faction for a location",
        "additionalProperties": false,
        "required": [
          "locationId"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "Location to find the controlling faction for"
          }
        }
      },
      "GetCurrencyDefinitionRequest": {
        "type": "object",
        "description": "Request to get a currency definition",
        "additionalProperties": false,
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Definition ID (provide this or code)"
          },
          "code": {
            "type": "string",
            "nullable": true,
            "description": "Currency code (provide this or definitionId)"
          }
        }
      },
      "GetDefinitionRequest": {
        "type": "object",
        "description": "Request to get a map definition",
        "required": [
          "definitionId"
        ],
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Definition ID to retrieve"
          }
        }
      },
      "GetDeityByCodeRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to retrieve a deity by code within a game service",
        "required": [
          "gameServiceId",
          "code"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service to search within"
          },
          "code": {
            "type": "string",
            "description": "Deity code to look up"
          }
        }
      },
      "GetDeityRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to retrieve a deity by ID",
        "required": [
          "deityId"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the deity to retrieve"
          }
        }
      },
      "GetDepositStatusRequest": {
        "type": "object",
        "description": "Request to get deposit status for a party",
        "required": [
          "escrowId",
          "partyId",
          "partyType"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party ID"
          },
          "partyType": {
            "description": "Type of entity (Account, Character, etc.)",
            "$ref": "#/components/schemas/EntityType"
          }
        }
      },
      "GetDepositStatusResponse": {
        "type": "object",
        "description": "Response containing party deposit status",
        "required": [
          "expectedAssets",
          "depositedAssets",
          "fulfilled"
        ],
        "properties": {
          "expectedAssets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAsset"
            },
            "description": "Expected assets from this party"
          },
          "depositedAssets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAsset"
            },
            "description": "Actually deposited assets"
          },
          "fulfilled": {
            "type": "boolean",
            "description": "Whether deposit requirement is fulfilled"
          },
          "depositToken": {
            "type": "string",
            "nullable": true,
            "description": "Deposit token (if not yet used)"
          },
          "depositDeadline": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Deposit deadline"
          }
        }
      },
      "GetDivinityBalanceRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get a deity's divinity balance",
        "required": [
          "deityId"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity whose balance to retrieve"
          }
        }
      },
      "GetDivinityHistoryRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get divinity transaction history",
        "required": [
          "deityId"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity whose history to retrieve"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 50,
            "description": "Number of results per page"
          }
        }
      },
      "GetDocumentRequest": {
        "description": "Request to retrieve a specific document by ID or slug",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace containing the document"
          },
          "documentId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Unique identifier of the document to retrieve (null if using slug)"
          },
          "slug": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "nullable": true,
            "description": "URL-friendly slug of the document to retrieve (null if using documentId)"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional session ID for tracking document views (null if not tracking)"
          },
          "includeRelated": {
            "$ref": "#/components/schemas/RelatedDepth",
            "nullable": true,
            "description": "How deep to fetch related documents (null for no related documents)"
          },
          "includeContent": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include full document content"
          },
          "renderHtml": {
            "type": "boolean",
            "default": false,
            "description": "Whether to render markdown content as HTML"
          }
        }
      },
      "GetDocumentResponse": {
        "description": "Response containing the requested document and optional related documents",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "document"
        ],
        "properties": {
          "document": {
            "$ref": "#/components/schemas/Document",
            "description": "The requested document"
          },
          "relatedDocuments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentSummary"
            },
            "description": "List of related documents based on includeRelated depth"
          },
          "contentFormat": {
            "type": "string",
            "enum": [
              "markdown",
              "html",
              "none"
            ],
            "description": "Format of the content field in the response"
          }
        }
      },
      "GetEffectsRequest": {
        "type": "object",
        "description": "Request to get unified effects for an entity",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity to get effects for"
          },
          "entityType": {
            "type": "string",
            "description": "Entity type discriminator"
          },
          "includePassive": {
            "type": "boolean",
            "default": true,
            "description": "Whether to include seed-derived passive effects. Defaults to true because GetEffects is the unified query endpoint designed to return all active effects. Set to false to retrieve only item-based statuses from this endpoint."
          }
        }
      },
      "GetEffectsResponse": {
        "type": "object",
        "description": "Unified view of all active effects for an entity",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "itemBasedCount",
          "seedDerivedCount",
          "effects"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity these effects belong to"
          },
          "entityType": {
            "type": "string",
            "description": "Entity type discriminator"
          },
          "itemBasedCount": {
            "type": "integer",
            "description": "Number of item-based status effects"
          },
          "seedDerivedCount": {
            "type": "integer",
            "description": "Number of seed-derived passive effects"
          },
          "effects": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StatusEffectSummary"
            },
            "description": "All active effects with source attribution"
          }
        }
      },
      "GetEncounterTypeRequest": {
        "type": "object",
        "description": "Request to retrieve an encounter type by code",
        "additionalProperties": false,
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Unique code of the encounter type"
          }
        }
      },
      "GetEnrichedCharacterRequest": {
        "description": "Request payload for retrieving a character with optional related data.\nEach include flag fetches data from its respective service (zero overhead if not requested).\n",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to retrieve"
          },
          "includePersonality": {
            "type": "boolean",
            "default": false,
            "description": "Include personality traits from character-personality service"
          },
          "includeBackstory": {
            "type": "boolean",
            "default": false,
            "description": "Include backstory elements from character-history service"
          },
          "includeFamilyTree": {
            "type": "boolean",
            "default": false,
            "description": "Include family relationships from relationship service"
          },
          "includeCombatPreferences": {
            "type": "boolean",
            "default": false,
            "description": "Include combat preferences from character-personality service"
          }
        }
      },
      "GetEntityLocationRequest": {
        "description": "Request to query an entity's current location",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "entityType",
          "entityId"
        ],
        "properties": {
          "entityType": {
            "type": "string",
            "description": "Type of entity (opaque string - character, actor, npc, player, etc.)"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity to look up"
          }
        }
      },
      "GetEntityLocationResponse": {
        "description": "Result of querying an entity's current location",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "found"
        ],
        "properties": {
          "found": {
            "type": "boolean",
            "description": "Whether a non-expired presence binding exists for this entity"
          },
          "locationId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of the location the entity is currently at"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of the realm the location belongs to"
          },
          "entityType": {
            "type": "string",
            "nullable": true,
            "description": "Type of entity (echoed back)"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of the entity (echoed back)"
          },
          "reportedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the presence was last reported"
          },
          "reportedBy": {
            "type": "string",
            "nullable": true,
            "description": "Identifier of the last reporter"
          }
        }
      },
      "GetEntityRankRequest": {
        "type": "object",
        "description": "Request to get an entity's rank",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId",
          "entityId",
          "entityType"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type whose rank is requested"
          }
        }
      },
      "GetEntryTemplateRequest": {
        "type": "object",
        "description": "Request to get an entry template by ID",
        "additionalProperties": false,
        "required": [
          "entryTemplateId"
        ],
        "properties": {
          "entryTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Entry template identifier"
          }
        }
      },
      "GetEscrowRequest": {
        "type": "object",
        "description": "Request to retrieve an escrow agreement by ID",
        "required": [
          "escrowId"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID to retrieve"
          }
        }
      },
      "GetEscrowResponse": {
        "type": "object",
        "description": "Response containing escrow agreement details",
        "required": [
          "escrow"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Escrow agreement details"
          }
        }
      },
      "GetEventParticipantsRequest": {
        "type": "object",
        "description": "Request payload for getting participants of an event",
        "additionalProperties": false,
        "required": [
          "eventId"
        ],
        "properties": {
          "eventId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the historical event"
          },
          "role": {
            "$ref": "#/components/schemas/ParticipationRole",
            "nullable": true,
            "description": "Filter by participation role"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "GetExchangeRateRequest": {
        "type": "object",
        "description": "Request to get exchange rate between currencies",
        "additionalProperties": false,
        "required": [
          "fromCurrencyId",
          "toCurrencyId"
        ],
        "properties": {
          "fromCurrencyId": {
            "type": "string",
            "format": "uuid",
            "description": "Source currency ID"
          },
          "toCurrencyId": {
            "type": "string",
            "format": "uuid",
            "description": "Target currency ID"
          }
        }
      },
      "GetExchangeRateResponse": {
        "type": "object",
        "description": "Exchange rate information",
        "additionalProperties": false,
        "required": [
          "rate",
          "inverseRate",
          "baseCurrency",
          "fromCurrencyRateToBase",
          "toCurrencyRateToBase"
        ],
        "properties": {
          "rate": {
            "type": "number",
            "format": "double",
            "description": "Conversion rate (from -> to)"
          },
          "inverseRate": {
            "type": "number",
            "format": "double",
            "description": "Inverse rate (to -> from)"
          },
          "baseCurrency": {
            "type": "string",
            "description": "Base currency code"
          },
          "fromCurrencyRateToBase": {
            "type": "number",
            "format": "double",
            "description": "Source currency rate to base"
          },
          "toCurrencyRateToBase": {
            "type": "number",
            "format": "double",
            "description": "Target currency rate to base"
          }
        }
      },
      "GetFactionByCodeRequest": {
        "type": "object",
        "description": "Request to get a faction by code within a game service",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "code"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service scope for code lookup"
          },
          "code": {
            "type": "string",
            "minLength": 1,
            "maxLength": 128,
            "description": "Faction code to look up"
          }
        }
      },
      "GetFactionRequest": {
        "type": "object",
        "description": "Request to get a faction by ID",
        "additionalProperties": false,
        "required": [
          "factionId"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the faction to retrieve"
          }
        }
      },
      "GetFollowersRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get followers of a deity",
        "required": [
          "deityId"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity whose followers to list"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 50,
            "description": "Number of results per page"
          }
        }
      },
      "GetGameSessionRequest": {
        "type": "object",
        "description": "Request to get a specific game session",
        "additionalProperties": false,
        "required": [
          "sessionId"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game session to retrieve"
          }
        }
      },
      "GetGardenStateRequest": {
        "type": "object",
        "description": "Request to get current garden state",
        "required": [
          "accountId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account whose garden state to retrieve"
          }
        }
      },
      "GetGlobalSupplyRequest": {
        "type": "object",
        "description": "Request to get global supply stats",
        "additionalProperties": false,
        "required": [
          "currencyDefinitionId"
        ],
        "properties": {
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to query"
          }
        }
      },
      "GetGlobalSupplyResponse": {
        "type": "object",
        "description": "Global supply statistics",
        "additionalProperties": false,
        "required": [
          "totalSupply",
          "inCirculation",
          "inEscrow",
          "totalMinted",
          "totalBurned"
        ],
        "properties": {
          "totalSupply": {
            "type": "number",
            "format": "double",
            "description": "Sum of all positive balances"
          },
          "inCirculation": {
            "type": "number",
            "format": "double",
            "description": "Total in wallets"
          },
          "inEscrow": {
            "type": "number",
            "format": "double",
            "description": "Locked in escrow"
          },
          "totalMinted": {
            "type": "number",
            "format": "double",
            "description": "All-time faucet total"
          },
          "totalBurned": {
            "type": "number",
            "format": "double",
            "description": "All-time sink total"
          },
          "supplyCap": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Global supply cap (null if none)"
          },
          "supplyCapRemaining": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Remaining supply before cap"
          }
        }
      },
      "GetGrowthPhaseRequest": {
        "type": "object",
        "description": "Request to get the current growth phase.",
        "required": [
          "seedId"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed whose phase to retrieve."
          }
        }
      },
      "GetGrowthRequest": {
        "type": "object",
        "description": "Request to get growth data for a seed.",
        "required": [
          "seedId"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed whose growth to retrieve."
          }
        }
      },
      "GetHoldRequest": {
        "type": "object",
        "description": "Request to get hold details",
        "additionalProperties": false,
        "required": [
          "holdId"
        ],
        "properties": {
          "holdId": {
            "type": "string",
            "format": "uuid",
            "description": "Hold ID"
          }
        }
      },
      "GetItemInstanceRequest": {
        "type": "object",
        "description": "Request to get an item instance",
        "additionalProperties": false,
        "required": [
          "instanceId"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Instance ID to retrieve"
          }
        }
      },
      "GetItemTemplateRequest": {
        "type": "object",
        "description": "Request to get an item template",
        "additionalProperties": false,
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Template ID (provide this or code+gameId)"
          },
          "code": {
            "type": "string",
            "nullable": true,
            "description": "Item code (provide with gameId)"
          },
          "gameId": {
            "type": "string",
            "nullable": true,
            "description": "Game service ID (provide with code)"
          }
        }
      },
      "GetJobStatusRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get the status of an async metabundle creation job",
        "required": [
          "jobId"
        ],
        "properties": {
          "jobId": {
            "type": "string",
            "format": "uuid",
            "description": "Job ID from the createMetabundle response"
          }
        }
      },
      "GetJobStatusResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Status of an async metabundle creation job.\nWhen status is 'ready', the response includes the full metabundle details.\n",
        "required": [
          "jobId",
          "metabundleId",
          "status"
        ],
        "properties": {
          "jobId": {
            "type": "string",
            "format": "uuid",
            "description": "Job identifier"
          },
          "metabundleId": {
            "type": "string",
            "description": "Human-readable metabundle identifier being created"
          },
          "status": {
            "type": "string",
            "enum": [
              "queued",
              "processing",
              "ready",
              "failed",
              "cancelled"
            ],
            "description": "Current job status.\n- queued: Waiting for processing resources\n- processing: Actively being processed\n- ready: Completed successfully\n- failed: Creation failed\n- cancelled: Job was cancelled\n"
          },
          "progress": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100,
            "nullable": true,
            "description": "Progress percentage (0-100) when status is 'processing'"
          },
          "downloadUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "Pre-signed download URL (only when status is 'ready')"
          },
          "assetCount": {
            "type": "integer",
            "nullable": true,
            "description": "Number of assets in metabundle (when ready)"
          },
          "standaloneAssetCount": {
            "type": "integer",
            "nullable": true,
            "description": "Number of standalone assets included (when ready)"
          },
          "sizeBytes": {
            "type": "integer",
            "format": "int64",
            "nullable": true,
            "description": "Total size in bytes (when ready)"
          },
          "sourceBundles": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/SourceBundleReference"
            },
            "description": "Provenance data (when ready)"
          },
          "errorCode": {
            "type": "string",
            "nullable": true,
            "description": "Error code (when status is 'failed')"
          },
          "errorMessage": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable error description (when status is 'failed')"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the job was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the job was last updated"
          },
          "processingTimeMs": {
            "type": "integer",
            "format": "int64",
            "nullable": true,
            "description": "Total processing time in milliseconds (when complete)"
          }
        }
      },
      "GetLicenseDefinitionRequest": {
        "type": "object",
        "description": "Request to get a license definition by board template ID and code",
        "additionalProperties": false,
        "required": [
          "boardTemplateId",
          "code"
        ],
        "properties": {
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template containing the definition"
          },
          "code": {
            "type": "string",
            "description": "License code to look up"
          }
        }
      },
      "GetLocationAncestorsRequest": {
        "description": "Request to retrieve the full ancestry chain of a location up to the root",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "locationId"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "The location to get ancestors for"
          }
        }
      },
      "GetLocationByCodeRequest": {
        "description": "Request to retrieve a location by its code within a specific realm",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "code",
          "realmId"
        ],
        "properties": {
          "code": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "pattern": "^[A-Z][A-Z0-9_]*$",
            "description": "Unique code for the location within the realm"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID to scope the code lookup"
          }
        }
      },
      "GetLocationDescendantsRequest": {
        "description": "Request to retrieve all descendants of a location (children, grandchildren, etc.)",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "locationId"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "The location to get descendants for"
          },
          "locationType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LocationType"
              }
            ],
            "nullable": true,
            "description": "Optional filter by location type"
          },
          "maxDepth": {
            "type": "integer",
            "minimum": 1,
            "maximum": 10,
            "nullable": true,
            "description": "Maximum depth of descendants to return (null = all)"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated locations in the response"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "GetLocationRequest": {
        "description": "Request to retrieve a location by its unique identifier",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "locationId"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the location"
          }
        }
      },
      "GetMatchmakingStatsRequest": {
        "type": "object",
        "description": "Request to get matchmaking statistics",
        "additionalProperties": false,
        "properties": {
          "queueId": {
            "type": "string",
            "nullable": true,
            "description": "Filter by specific queue (null for all queues)"
          },
          "gameId": {
            "type": "string",
            "nullable": true,
            "description": "Filter by game ID"
          }
        }
      },
      "GetMatchmakingStatusRequest": {
        "type": "object",
        "description": "Request to get matchmaking status",
        "additionalProperties": false,
        "required": [
          "webSocketSessionId",
          "accountId",
          "ticketId"
        ],
        "properties": {
          "webSocketSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player"
          },
          "ticketId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the ticket to query"
          }
        }
      },
      "GetMilestoneRequest": {
        "type": "object",
        "description": "Request to get milestone details",
        "additionalProperties": false,
        "required": [
          "contractId",
          "milestoneCode"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "milestoneCode": {
            "type": "string",
            "description": "Milestone code"
          }
        }
      },
      "GetObjectiveProgressRequest": {
        "type": "object",
        "description": "Request to get detailed progress for a specific objective",
        "additionalProperties": false,
        "required": [
          "questInstanceId",
          "objectiveCode"
        ],
        "properties": {
          "questInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Quest instance"
          },
          "objectiveCode": {
            "type": "string",
            "description": "Objective code"
          }
        }
      },
      "GetOrCreateContainerRequest": {
        "type": "object",
        "description": "Request to get or create a container",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "containerType",
          "constraintModel"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner entity ID"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Owner type"
          },
          "containerType": {
            "type": "string",
            "description": "Container type to find or create"
          },
          "constraintModel": {
            "$ref": "#/components/schemas/ContainerConstraintModel",
            "description": "Constraint model for new container"
          },
          "maxSlots": {
            "type": "integer",
            "nullable": true,
            "description": "Default max slots if creating"
          },
          "maxWeight": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Default max weight if creating"
          },
          "gridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "Default grid width if creating"
          },
          "gridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "Default grid height if creating"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm for new container"
          }
        }
      },
      "GetOrCreateWalletRequest": {
        "type": "object",
        "description": "Request to get or create a wallet",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner entity ID"
          },
          "ownerType": {
            "$ref": "#/components/schemas/WalletOwnerType",
            "description": "Type of owner entity"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm ID for realm-scoped wallets"
          }
        }
      },
      "GetOrCreateWalletResponse": {
        "type": "object",
        "description": "Result of get-or-create operation",
        "additionalProperties": false,
        "required": [
          "wallet",
          "balances",
          "created"
        ],
        "properties": {
          "wallet": {
            "$ref": "#/components/schemas/WalletResponse",
            "description": "Wallet details"
          },
          "balances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BalanceSummary"
            },
            "description": "All non-zero balances"
          },
          "created": {
            "type": "boolean",
            "description": "Whether a new wallet was created"
          }
        }
      },
      "GetParticipationRequest": {
        "type": "object",
        "description": "Request payload for getting a character's event participation",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to get participation for"
          },
          "eventCategory": {
            "$ref": "#/components/schemas/EventCategory",
            "nullable": true,
            "description": "Filter by event category"
          },
          "minimumSignificance": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Filter by minimum significance"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "GetPersonalityRequest": {
        "type": "object",
        "description": "Request payload for retrieving a character's personality",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to get personality for"
          }
        }
      },
      "GetPerspectiveRequest": {
        "type": "object",
        "description": "Request to get a character's perspective on an encounter",
        "additionalProperties": false,
        "required": [
          "encounterId",
          "characterId"
        ],
        "properties": {
          "encounterId": {
            "type": "string",
            "format": "uuid",
            "description": "Encounter to get perspective for"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character whose perspective to retrieve"
          }
        }
      },
      "GetPhaseConfigRequest": {
        "type": "object",
        "description": "Request to get deployment phase configuration",
        "properties": {}
      },
      "GetPhaseMetricsRequest": {
        "type": "object",
        "description": "Request to get phase metrics",
        "properties": {}
      },
      "GetPlanRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to retrieve a cached plan",
        "required": [
          "planId"
        ],
        "properties": {
          "planId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the plan to retrieve"
          }
        }
      },
      "GetPlanResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Retrieved plan",
        "required": [
          "found"
        ],
        "properties": {
          "found": {
            "type": "boolean",
            "description": "Whether the plan was found"
          },
          "plan": {
            "$ref": "#/components/schemas/ComposeResponse",
            "nullable": true,
            "description": "The plan (null if not found)"
          }
        }
      },
      "GetQuestDefinitionRequest": {
        "type": "object",
        "description": "Request to retrieve a quest definition by ID or code",
        "additionalProperties": false,
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Definition ID (provide either this or code)"
          },
          "code": {
            "type": "string",
            "nullable": true,
            "description": "Quest code (provide either this or definitionId)"
          }
        }
      },
      "GetQuestLogRequest": {
        "type": "object",
        "description": "Request to get a player-facing quest log summary",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to get log for"
          }
        }
      },
      "GetQuestRequest": {
        "type": "object",
        "description": "Request to get details of a quest instance",
        "additionalProperties": false,
        "required": [
          "questInstanceId"
        ],
        "properties": {
          "questInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Quest instance ID"
          }
        }
      },
      "GetQueueRequest": {
        "type": "object",
        "description": "Request to get details of a specific queue",
        "additionalProperties": false,
        "required": [
          "queueId"
        ],
        "properties": {
          "queueId": {
            "type": "string",
            "description": "ID of the queue to retrieve"
          }
        }
      },
      "GetRanksAroundRequest": {
        "type": "object",
        "description": "Request to get entries around an entity",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId",
          "entityId",
          "entityType"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity to center on"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type of the anchor entry"
          },
          "countBefore": {
            "type": "integer",
            "default": 5,
            "maximum": 50,
            "description": "Entries to show before the entity"
          },
          "countAfter": {
            "type": "integer",
            "default": 5,
            "maximum": 50,
            "description": "Entries to show after the entity"
          }
        }
      },
      "GetRealmBaselineRequest": {
        "type": "object",
        "description": "Request to get the realm baseline faction",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the realm to get the baseline faction for"
          }
        }
      },
      "GetRealmByCodeRequest": {
        "description": "Request to retrieve a realm by its unique code identifier",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "minLength": 1,
            "maxLength": 50,
            "pattern": "^[A-Z][A-Z0-9_]*$",
            "description": "Unique code for the realm (e.g., \"REALM_1\", \"REALM_2\")"
          }
        }
      },
      "GetRealmEventParticipantsRequest": {
        "type": "object",
        "description": "Request payload for getting participants of an event",
        "additionalProperties": false,
        "required": [
          "eventId"
        ],
        "properties": {
          "eventId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the historical event"
          },
          "role": {
            "$ref": "#/components/schemas/RealmEventRole",
            "nullable": true,
            "description": "Filter by participation role"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "GetRealmLoreRequest": {
        "type": "object",
        "description": "Request payload for getting a realm's lore",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the realm to get lore for"
          },
          "elementTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RealmLoreElementType"
            },
            "nullable": true,
            "description": "Filter by element types (null for all)"
          },
          "minimumStrength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Filter by minimum strength"
          }
        }
      },
      "GetRealmParticipationRequest": {
        "type": "object",
        "description": "Request payload for getting a realm's event participation",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the realm to get participation for"
          },
          "eventCategory": {
            "$ref": "#/components/schemas/RealmEventCategory",
            "nullable": true,
            "description": "Filter by event category"
          },
          "minimumImpact": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Filter by minimum impact"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "GetRealmRequest": {
        "description": "Request to retrieve a specific realm by its unique identifier",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the realm"
          }
        }
      },
      "GetRelationshipRequest": {
        "description": "Request to retrieve a specific relationship by its ID",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "relationshipId"
        ],
        "properties": {
          "relationshipId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the relationship to retrieve"
          }
        }
      },
      "GetRelationshipTypeByCodeRequest": {
        "description": "Request to retrieve a relationship type by its unique code string",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "minLength": 1,
            "maxLength": 50,
            "pattern": "^[A-Z][A-Z0-9_]*$",
            "description": "Unique code for the relationship type (e.g., \"SON\", \"MOTHER\", \"FRIEND\")"
          }
        }
      },
      "GetRelationshipTypeRequest": {
        "description": "Request to retrieve a relationship type by its unique identifier",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "relationshipTypeId"
        ],
        "properties": {
          "relationshipTypeId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the relationship type"
          }
        }
      },
      "GetRelationshipsBetweenRequest": {
        "description": "Request to get all relationships between two specific entities",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "entity1Id",
          "entity1Type",
          "entity2Id",
          "entity2Type"
        ],
        "properties": {
          "entity1Id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the first entity to check relationships for"
          },
          "entity1Type": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the first entity"
          },
          "entity2Id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the second entity to check relationships for"
          },
          "entity2Type": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the second entity"
          },
          "relationshipTypeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional filter by relationship type"
          },
          "includeEnded": {
            "type": "boolean",
            "default": false,
            "description": "Include relationships that have ended"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for paginated results (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page (max 100)"
          }
        }
      },
      "GetRoomRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to retrieve a room by ID",
        "required": [
          "roomId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID to look up"
          }
        }
      },
      "GetRoomTypeRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to retrieve a room type by code",
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Room type code to look up"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game service scope (null for global types)"
          }
        }
      },
      "GetScenarioDefinitionRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to retrieve a scenario definition",
        "properties": {
          "scenarioId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Scenario ID to retrieve"
          },
          "code": {
            "type": "string",
            "nullable": true,
            "description": "Scenario code to retrieve (if ID not provided)"
          }
        }
      },
      "GetScenarioDefinitionResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response with scenario definition",
        "required": [
          "found"
        ],
        "properties": {
          "found": {
            "type": "boolean",
            "description": "Whether the scenario was found"
          },
          "scenario": {
            "$ref": "#/components/schemas/ScenarioDefinition",
            "nullable": true,
            "description": "The scenario definition (null if not found)"
          }
        }
      },
      "GetScenarioHistoryRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request for scenario execution history",
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to query"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Max results"
          },
          "offset": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Pagination offset"
          }
        }
      },
      "GetScenarioHistoryResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Scenario execution history",
        "required": [
          "executions",
          "totalCount"
        ],
        "properties": {
          "executions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScenarioExecution"
            },
            "description": "Historical executions"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total count for pagination"
          }
        }
      },
      "GetScenarioStateRequest": {
        "type": "object",
        "description": "Request to get current scenario state",
        "required": [
          "accountId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account whose scenario state to retrieve"
          }
        }
      },
      "GetSceneRequest": {
        "type": "object",
        "description": "Request to retrieve a scene",
        "required": [
          "sceneId"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the scene to retrieve"
          },
          "version": {
            "type": "string",
            "nullable": true,
            "description": "Specific version to retrieve (null = latest)"
          },
          "resolveReferences": {
            "type": "boolean",
            "default": false,
            "description": "Whether to resolve and embed referenced scenes"
          },
          "maxReferenceDepth": {
            "type": "integer",
            "default": 3,
            "minimum": 1,
            "maximum": 10,
            "description": "Maximum depth for reference resolution (prevents infinite recursion)"
          }
        }
      },
      "GetSceneResponse": {
        "type": "object",
        "description": "Response containing a scene and resolution metadata",
        "required": [
          "scene"
        ],
        "properties": {
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "The retrieved scene"
          },
          "resolvedReferences": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResolvedReference"
            },
            "nullable": true,
            "description": "List of resolved references (if resolveReferences was true)"
          },
          "unresolvedReferences": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UnresolvedReference"
            },
            "nullable": true,
            "description": "References that could not be resolved (circular, missing, depth exceeded)"
          },
          "resolutionErrors": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Error messages for reference resolution issues"
          }
        }
      },
      "GetSeasonRequest": {
        "type": "object",
        "description": "Request to get season information",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard"
          },
          "seasonNumber": {
            "type": "integer",
            "nullable": true,
            "description": "Specific season number (null for current)"
          }
        }
      },
      "GetSeedEffectsRequest": {
        "type": "object",
        "description": "Request to get seed-derived passive effects for an entity",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity to get seed effects for"
          },
          "entityType": {
            "type": "string",
            "description": "Entity type discriminator"
          }
        }
      },
      "GetSeedRequest": {
        "type": "object",
        "description": "Request to get a seed by ID.",
        "required": [
          "seedId"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed to retrieve."
          }
        }
      },
      "GetSeedTypeRequest": {
        "type": "object",
        "description": "Request to get a seed type definition.",
        "required": [
          "seedTypeCode"
        ],
        "properties": {
          "seedTypeCode": {
            "type": "string",
            "description": "The seed type code."
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "The game service scope. Null for cross-game seed types."
          }
        }
      },
      "GetSeedsByOwnerRequest": {
        "type": "object",
        "description": "Request to get seeds by owner.",
        "required": [
          "ownerId",
          "ownerType"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "The owner entity ID."
          },
          "ownerType": {
            "type": "string",
            "description": "The owner entity type."
          },
          "seedTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Filter by seed type."
          },
          "includeArchived": {
            "type": "boolean",
            "description": "Whether to include archived seeds.",
            "default": false
          }
        }
      },
      "GetSentimentRequest": {
        "type": "object",
        "description": "Request to get aggregate sentiment toward another character",
        "additionalProperties": false,
        "required": [
          "characterId",
          "targetCharacterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character whose sentiment to query"
          },
          "targetCharacterId": {
            "type": "string",
            "format": "uuid",
            "description": "Target character to measure sentiment toward"
          }
        }
      },
      "GetServiceRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get a service by ID or stub name (provide either one)",
        "properties": {
          "serviceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of the service to retrieve (null if using stubName)"
          },
          "stubName": {
            "type": "string",
            "nullable": true,
            "description": "Stub name of the service to retrieve (null if using serviceId)"
          }
        }
      },
      "GetSharedGardenRequest": {
        "type": "object",
        "description": "Request to get shared garden state for bonded players",
        "required": [
          "bondId"
        ],
        "properties": {
          "bondId": {
            "type": "string",
            "format": "uuid",
            "description": "Bond ID to look up shared garden state"
          }
        }
      },
      "GetSlotRequest": {
        "type": "object",
        "description": "Request to retrieve metadata for a specific save slot",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "minLength": 1,
            "maxLength": 32,
            "pattern": "^[a-z][a-z0-9-]*$",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          }
        }
      },
      "GetSnapshotRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to retrieve a snapshot",
        "required": [
          "snapshotId"
        ],
        "properties": {
          "snapshotId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the snapshot to retrieve"
          },
          "filterSourceTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Optional filter for which entries to return from the snapshot.\nOnly entries with matching source types are returned.\nIf omitted or empty, all entries are returned.\n"
          }
        }
      },
      "GetSnapshotResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response containing snapshot data",
        "required": [
          "snapshotId",
          "found"
        ],
        "properties": {
          "snapshotId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the snapshot"
          },
          "found": {
            "type": "boolean",
            "description": "True if snapshot exists (hasn't expired)"
          },
          "snapshot": {
            "$ref": "#/components/schemas/ResourceSnapshot",
            "nullable": true,
            "description": "The snapshot data (null if not found/expired)"
          }
        }
      },
      "GetSpeciesByCodeRequest": {
        "description": "Request to retrieve a species by its unique code identifier",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "minLength": 1,
            "maxLength": 50,
            "pattern": "^[A-Z][A-Z0-9_]*$",
            "description": "Unique code for the species (e.g., \"HUMAN\", \"ELF\", \"DWARF\")"
          }
        }
      },
      "GetSpeciesRequest": {
        "description": "Request to retrieve a single species by its unique identifier",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "speciesId"
        ],
        "properties": {
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the species"
          }
        }
      },
      "GetStatusRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request for service status (currently empty, reserved for future filters)",
        "properties": {}
      },
      "GetStatusTemplateByCodeRequest": {
        "type": "object",
        "description": "Request to get a status template by game service and code",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "code"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service the template is scoped to"
          },
          "code": {
            "type": "string",
            "description": "Unique status code within this game service"
          }
        }
      },
      "GetStatusTemplateRequest": {
        "type": "object",
        "description": "Request to get a status template by ID",
        "additionalProperties": false,
        "required": [
          "statusTemplateId"
        ],
        "properties": {
          "statusTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Status template identifier"
          }
        }
      },
      "GetStyleRequest": {
        "description": "Request to get a style definition",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "styleId": {
            "type": "string",
            "nullable": true,
            "description": "Style ID to retrieve"
          },
          "styleName": {
            "type": "string",
            "nullable": true,
            "description": "Style name to retrieve (alternative to ID)"
          }
        }
      },
      "GetSubscriptionRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to get a specific subscription",
        "required": [
          "subscriptionId"
        ],
        "properties": {
          "subscriptionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the subscription to retrieve"
          }
        }
      },
      "GetTemplateByCodeRequest": {
        "type": "object",
        "description": "Request to get a template by code",
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Template code to look up"
          }
        }
      },
      "GetTemplateRequest": {
        "type": "object",
        "description": "Request to get a template by ID",
        "required": [
          "scenarioTemplateId"
        ],
        "properties": {
          "scenarioTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template ID to retrieve"
          }
        }
      },
      "GetTopRanksRequest": {
        "type": "object",
        "description": "Request to get top leaderboard entries",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard"
          },
          "count": {
            "type": "integer",
            "default": 100,
            "maximum": 1000,
            "description": "Number of entries to return"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Number of entries to skip"
          }
        }
      },
      "GetTransactionHistoryRequest": {
        "type": "object",
        "description": "Request to get transaction history",
        "additionalProperties": false,
        "required": [
          "walletId"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet to query"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by currency"
          },
          "transactionTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransactionType"
            },
            "nullable": true,
            "description": "Filter by transaction types"
          },
          "fromDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Start of date range"
          },
          "toDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "End of date range"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 50,
            "description": "Results per page"
          },
          "offset": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Result offset"
          }
        }
      },
      "GetTransactionHistoryResponse": {
        "type": "object",
        "description": "Paginated transaction history",
        "additionalProperties": false,
        "required": [
          "transactions",
          "totalCount"
        ],
        "properties": {
          "transactions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CurrencyTransactionRecord"
            },
            "description": "Transaction records"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total matching transactions"
          }
        }
      },
      "GetTransactionRequest": {
        "type": "object",
        "description": "Request to get a transaction by ID",
        "additionalProperties": false,
        "required": [
          "transactionId"
        ],
        "properties": {
          "transactionId": {
            "type": "string",
            "format": "uuid",
            "description": "Transaction ID"
          }
        }
      },
      "GetTransactionsByReferenceRequest": {
        "type": "object",
        "description": "Request to get transactions by reference",
        "additionalProperties": false,
        "required": [
          "referenceType",
          "referenceId"
        ],
        "properties": {
          "referenceType": {
            "type": "string",
            "description": "Reference type"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "description": "Reference ID"
          }
        }
      },
      "GetTransactionsByReferenceResponse": {
        "type": "object",
        "description": "Transactions for a reference",
        "additionalProperties": false,
        "required": [
          "transactions"
        ],
        "properties": {
          "transactions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CurrencyTransactionRecord"
            },
            "description": "Matching transactions"
          }
        }
      },
      "GetValidationRulesRequest": {
        "type": "object",
        "description": "Request to get validation rules",
        "required": [
          "gameId",
          "sceneType"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game ID"
          },
          "sceneType": {
            "$ref": "#/components/schemas/SceneType",
            "description": "Scene type"
          }
        }
      },
      "GetValidationRulesResponse": {
        "type": "object",
        "description": "Response containing validation rules",
        "required": [
          "gameId",
          "sceneType"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game ID"
          },
          "sceneType": {
            "$ref": "#/components/schemas/SceneType",
            "description": "Scene type"
          },
          "rules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationRule"
            },
            "description": "Registered rules (empty if none)"
          }
        }
      },
      "GetWalletRequest": {
        "type": "object",
        "description": "Request to get a wallet",
        "additionalProperties": false,
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Wallet ID (provide this or ownerId+ownerType)"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Owner ID (requires ownerType)"
          },
          "ownerType": {
            "$ref": "#/components/schemas/WalletOwnerType",
            "nullable": true,
            "description": "Owner type (requires ownerId)"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm ID (required if using ownerId lookup)"
          }
        }
      },
      "GoapGoal": {
        "description": "Goal definition for GOAP planning with conditions and priority",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "name",
          "conditions",
          "priority"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the goal",
            "example": "satisfy_hunger"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description of the goal"
          },
          "conditions": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "World state conditions that satisfy this goal (literal conditions)",
            "example": {
              "hunger": "<= 0.3",
              "gold": ">= 50"
            }
          },
          "priority": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "description": "Priority of this goal relative to others"
          },
          "preconditions": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "World state conditions required to pursue this goal"
          }
        }
      },
      "GoapPlanRequest": {
        "description": "Request to generate a GOAP plan to achieve a goal from current world state",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "goal",
          "worldState",
          "behaviorId"
        ],
        "properties": {
          "agentId": {
            "type": "string",
            "nullable": true,
            "description": "Unique identifier for the agent requesting the plan"
          },
          "goal": {
            "$ref": "#/components/schemas/GoapGoal",
            "description": "The goal to achieve through planning"
          },
          "worldState": {
            "type": "object",
            "additionalProperties": true,
            "description": "Current world state as key-value pairs",
            "example": {
              "hunger": 0.8,
              "gold": 50,
              "location": "home"
            }
          },
          "behaviorId": {
            "type": "string",
            "description": "ID of compiled behavior containing GOAP actions"
          },
          "options": {
            "$ref": "#/components/schemas/GoapPlanningOptions",
            "nullable": true,
            "description": "Options controlling the planning process"
          }
        }
      },
      "GoapPlanResponse": {
        "description": "Response containing the generated GOAP plan. If no plan could be found, plan is null and failureReason explains why.",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "plan": {
            "$ref": "#/components/schemas/GoapPlanResult",
            "nullable": true,
            "description": "The generated plan if successful"
          },
          "planningTimeMs": {
            "type": "integer",
            "description": "Time spent planning in milliseconds"
          },
          "nodesExpanded": {
            "type": "integer",
            "description": "Number of nodes expanded during A* search"
          },
          "failureReason": {
            "type": "string",
            "nullable": true,
            "description": "Reason for planning failure if unsuccessful",
            "example": "No plan found - goal unreachable"
          }
        }
      },
      "GoapPlanResult": {
        "description": "Result of GOAP planning containing the ordered sequence of actions to achieve a goal",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "goalId",
          "actions",
          "totalCost"
        ],
        "properties": {
          "goalId": {
            "type": "string",
            "description": "ID of the goal this plan achieves"
          },
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PlannedActionResponse"
            },
            "description": "Ordered sequence of actions to execute"
          },
          "totalCost": {
            "type": "number",
            "format": "float",
            "description": "Total cost of all actions in the plan"
          }
        }
      },
      "GoapPlanningOptions": {
        "description": "Options controlling the GOAP planning process including depth and timeout limits",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "maxDepth": {
            "type": "integer",
            "default": 10,
            "description": "Maximum plan depth (number of actions)"
          },
          "maxNodes": {
            "type": "integer",
            "default": 1000,
            "description": "Maximum nodes to expand during search"
          },
          "timeoutMs": {
            "type": "integer",
            "default": 100,
            "description": "Planning timeout in milliseconds"
          }
        }
      },
      "GrantBlessingRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to grant a blessing from a deity to an entity",
        "required": [
          "deityId",
          "entityId",
          "entityType",
          "tier",
          "itemTemplateCode",
          "reason"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity granting the blessing"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity receiving the blessing"
          },
          "entityType": {
            "type": "string",
            "description": "Type of entity receiving the blessing (e.g., character, account, deity)"
          },
          "tier": {
            "$ref": "#/components/schemas/BlessingTier",
            "description": "Tier of the blessing (determines cost and storage mechanism)"
          },
          "itemTemplateCode": {
            "type": "string",
            "description": "Item template code for the blessing effect"
          },
          "reason": {
            "type": "string",
            "description": "Why the deity is granting this blessing"
          }
        }
      },
      "GrantEntryRequest": {
        "type": "object",
        "description": "Request to grant/unlock an entry in a collection",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "gameServiceId",
          "entryCode",
          "collectionType"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity that owns the collection"
          },
          "ownerType": {
            "type": "string",
            "description": "Entity type discriminator"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service scope"
          },
          "entryCode": {
            "type": "string",
            "description": "Entry template code to grant"
          },
          "collectionType": {
            "$ref": "#/components/schemas/CollectionType",
            "description": "Type of collection to grant into"
          },
          "metadata": {
            "$ref": "#/components/schemas/EntryMetadata",
            "description": "Optional initial metadata for the unlocked entry"
          }
        }
      },
      "GrantEntryResponse": {
        "type": "object",
        "description": "Result of a grant operation",
        "additionalProperties": false,
        "required": [
          "entryTemplateId",
          "code",
          "collectionId",
          "itemInstanceId",
          "alreadyUnlocked",
          "unlockedAt"
        ],
        "properties": {
          "entryTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Entry template that was granted"
          },
          "code": {
            "type": "string",
            "description": "Entry code that was granted"
          },
          "collectionId": {
            "type": "string",
            "format": "uuid",
            "description": "Collection the entry was granted to"
          },
          "itemInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance created for this entry"
          },
          "alreadyUnlocked": {
            "type": "boolean",
            "description": "Whether this entry was already unlocked (idempotent return)"
          },
          "unlockedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the entry was unlocked"
          }
        }
      },
      "GrantResult": {
        "type": "string",
        "description": "How a successful status grant was resolved.\n- granted: new status applied (no prior instance)\n- stacked: stack count increased on existing instance\n- refreshed: timer reset on existing instance\n- replaced: existing instance removed and new one created\n",
        "enum": [
          "granted",
          "stacked",
          "refreshed",
          "replaced"
        ]
      },
      "GrantStatusRequest": {
        "type": "object",
        "description": "Request to grant a status effect to an entity",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "gameServiceId",
          "statusTemplateCode"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity to receive the status effect"
          },
          "entityType": {
            "type": "string",
            "description": "Entity type discriminator (e.g., character, account)"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service scope for template lookup"
          },
          "statusTemplateCode": {
            "type": "string",
            "description": "Status template code to grant"
          },
          "sourceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "What granted this status (for cascading removal via remove-by-source)"
          },
          "durationOverrideSeconds": {
            "type": "integer",
            "minimum": 1,
            "nullable": true,
            "description": "Override the template's default duration in seconds"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Arbitrary key-value data passed to contract template values and stored on the status instance. Convention for Divine integration - set metadata.blessingTier to the blessing tier string (e.g., minor, standard, greater, supreme) so the Divine service can query active blessings by tier."
          }
        }
      },
      "GrantStatusResponse": {
        "type": "object",
        "description": "Result of a successful status grant operation",
        "additionalProperties": false,
        "required": [
          "statusInstanceId",
          "statusTemplateCode",
          "stackCount",
          "itemInstanceId",
          "grantedAt",
          "grantResult"
        ],
        "properties": {
          "statusInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Status instance that was created or updated"
          },
          "statusTemplateCode": {
            "type": "string",
            "description": "Status template code that was granted"
          },
          "stackCount": {
            "type": "integer",
            "description": "Current stack count after grant"
          },
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract instance managing this status lifecycle (null if not contract-managed)"
          },
          "itemInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance created in the status container"
          },
          "grantedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this status was granted"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this status expires (null for permanent statuses)"
          },
          "grantResult": {
            "$ref": "#/components/schemas/GrantResult",
            "description": "How the grant was resolved (granted, stacked, refreshed, replaced)"
          }
        }
      },
      "GridPosition": {
        "type": "object",
        "description": "A position on the board grid (zero-indexed)",
        "additionalProperties": false,
        "required": [
          "x",
          "y"
        ],
        "properties": {
          "x": {
            "type": "integer",
            "description": "Horizontal grid coordinate (zero-indexed)"
          },
          "y": {
            "type": "integer",
            "description": "Vertical grid coordinate (zero-indexed)"
          }
        }
      },
      "GroupRole": {
        "type": "string",
        "description": "Preferred role when fighting in groups. Affects positioning,\ntarget priority, and coordination behavior.\n",
        "enum": [
          "FRONTLINE",
          "SUPPORT",
          "FLANKER",
          "LEADER",
          "SOLO"
        ]
      },
      "GrowthEntry": {
        "type": "object",
        "description": "A single domain-amount pair for batch growth recording.",
        "required": [
          "domain",
          "amount"
        ],
        "properties": {
          "domain": {
            "type": "string",
            "description": "Dot-separated domain path."
          },
          "amount": {
            "type": "number",
            "format": "float",
            "description": "Growth amount to add."
          }
        }
      },
      "GrowthPhaseDefinition": {
        "type": "object",
        "description": "Defines a growth phase with its threshold.",
        "required": [
          "phaseCode",
          "displayName",
          "minTotalGrowth"
        ],
        "properties": {
          "phaseCode": {
            "type": "string",
            "description": "Machine-readable phase identifier (e.g., \"nascent\", \"awakening\")."
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable phase label."
          },
          "minTotalGrowth": {
            "type": "number",
            "format": "float",
            "description": "Minimum total growth to enter this phase."
          }
        }
      },
      "GrowthPhaseResponse": {
        "type": "object",
        "description": "Current growth phase information for a seed.",
        "required": [
          "seedId",
          "phaseCode",
          "displayName",
          "totalGrowth"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed."
          },
          "phaseCode": {
            "type": "string",
            "description": "Current phase code."
          },
          "displayName": {
            "type": "string",
            "description": "Current phase display name."
          },
          "totalGrowth": {
            "type": "number",
            "format": "float",
            "description": "Current total growth."
          },
          "nextPhaseCode": {
            "type": "string",
            "nullable": true,
            "description": "Next phase code, null if at maximum."
          },
          "nextPhaseThreshold": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "description": "Growth needed for next phase, null if at maximum."
          }
        }
      },
      "GrowthResponse": {
        "type": "object",
        "description": "Growth domain data for a seed.",
        "required": [
          "seedId",
          "totalGrowth",
          "domains"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed this growth belongs to."
          },
          "totalGrowth": {
            "type": "number",
            "format": "float",
            "description": "Aggregate growth across all domains."
          },
          "domains": {
            "type": "object",
            "additionalProperties": {
              "type": "number",
              "format": "float"
            },
            "description": "Map of domain path to depth value. Keys are dot-separated (e.g., \"combat.melee.sword\"). Values are floating-point depth scores.\n"
          }
        }
      },
      "HarmonyStyle": {
        "description": "Harmonic progression style preferences",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "primaryCadence": {
            "type": "string",
            "enum": [
              "authentic",
              "plagal",
              "half",
              "deceptive"
            ],
            "default": "authentic",
            "description": "Most common cadence type"
          },
          "dominantPrepProbability": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.6,
            "description": "Probability of pre-dominant before dominant"
          },
          "secondaryDominantProbability": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.3,
            "description": "Probability of secondary dominants"
          },
          "modalInterchangeProbability": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.1,
            "description": "Probability of borrowed chords"
          },
          "commonProgressions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Common chord progressions as roman numeral strings"
          }
        }
      },
      "HasEntryRequest": {
        "type": "object",
        "description": "Request to check if an entry is unlocked",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "gameServiceId",
          "entryCode",
          "collectionType"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity that owns the collection"
          },
          "ownerType": {
            "type": "string",
            "description": "Entity type discriminator"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service scope"
          },
          "entryCode": {
            "type": "string",
            "description": "Entry template code to check"
          },
          "collectionType": {
            "$ref": "#/components/schemas/CollectionType",
            "description": "Type of collection to check"
          }
        }
      },
      "HasEntryResponse": {
        "type": "object",
        "description": "Result of entry ownership check",
        "additionalProperties": false,
        "required": [
          "hasEntry"
        ],
        "properties": {
          "hasEntry": {
            "type": "boolean",
            "description": "Whether the owner has this entry unlocked"
          },
          "unlockedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the entry was unlocked (null if not unlocked)"
          }
        }
      },
      "HasItemResult": {
        "type": "object",
        "description": "Individual item check result",
        "additionalProperties": false,
        "required": [
          "templateId",
          "required",
          "available",
          "satisfied"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template checked"
          },
          "required": {
            "type": "number",
            "format": "double",
            "description": "Required quantity"
          },
          "available": {
            "type": "number",
            "format": "double",
            "description": "Available quantity"
          },
          "satisfied": {
            "type": "boolean",
            "description": "Whether requirement met"
          }
        }
      },
      "HasItemsRequest": {
        "type": "object",
        "description": "Request to check for items",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "requirements"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner to check"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Owner type"
          },
          "requirements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ItemRequirement"
            },
            "description": "Required items"
          }
        }
      },
      "HasItemsResponse": {
        "type": "object",
        "description": "Has items result",
        "additionalProperties": false,
        "required": [
          "hasAll",
          "results"
        ],
        "properties": {
          "hasAll": {
            "type": "boolean",
            "description": "Whether all requirements met"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HasItemResult"
            },
            "description": "Per-item results"
          }
        }
      },
      "HasMetRequest": {
        "type": "object",
        "description": "Request to check if two characters have met",
        "additionalProperties": false,
        "required": [
          "characterIdA",
          "characterIdB"
        ],
        "properties": {
          "characterIdA": {
            "type": "string",
            "format": "uuid",
            "description": "First character"
          },
          "characterIdB": {
            "type": "string",
            "format": "uuid",
            "description": "Second character"
          }
        }
      },
      "HasMetResponse": {
        "type": "object",
        "description": "Response for has-met check",
        "additionalProperties": false,
        "required": [
          "hasMet",
          "encounterCount"
        ],
        "properties": {
          "hasMet": {
            "type": "boolean",
            "description": "Whether the characters have any recorded encounters"
          },
          "encounterCount": {
            "type": "integer",
            "description": "Total number of encounters between them"
          }
        }
      },
      "HasStatusRequest": {
        "type": "object",
        "description": "Request to check if an entity has a specific status",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "statusCode"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity to check"
          },
          "entityType": {
            "type": "string",
            "description": "Entity type discriminator"
          },
          "statusCode": {
            "type": "string",
            "description": "Status template code to check for"
          }
        }
      },
      "HasStatusResponse": {
        "type": "object",
        "description": "Result of a status existence check",
        "additionalProperties": false,
        "required": [
          "hasStatus"
        ],
        "properties": {
          "hasStatus": {
            "type": "boolean",
            "description": "Whether the entity has this status active"
          },
          "statusInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Status instance ID if found (null if not present)"
          },
          "stackCount": {
            "type": "integer",
            "nullable": true,
            "description": "Current stack count if found (null if not present)"
          }
        }
      },
      "HazardInfo": {
        "type": "object",
        "additionalProperties": true,
        "description": "Information about a hazard in range",
        "properties": {
          "hazardType": {
            "type": "string",
            "description": "Type of hazard (fire, poison, radiation, deep_water, etc.)"
          },
          "distance": {
            "type": "number",
            "format": "float",
            "description": "Distance to hazard edge"
          },
          "severity": {
            "type": "number",
            "format": "float",
            "minimum": 0,
            "maximum": 1,
            "description": "Hazard severity (0-1)"
          },
          "direction": {
            "type": "string",
            "nullable": true,
            "description": "Direction to hazard center"
          }
        }
      },
      "HeartbeatRequest": {
        "type": "object",
        "description": "Request to extend checkout lock",
        "required": [
          "sceneId",
          "checkoutToken"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene being edited"
          },
          "checkoutToken": {
            "type": "string",
            "description": "Checkout token"
          }
        }
      },
      "HeartbeatResponse": {
        "type": "object",
        "description": "Response confirming lock extension",
        "required": [
          "extended",
          "newExpiresAt"
        ],
        "properties": {
          "extended": {
            "type": "boolean",
            "description": "Whether extension was successful"
          },
          "newExpiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "New expiration time"
          },
          "extensionsRemaining": {
            "type": "integer",
            "description": "Number of extensions remaining"
          }
        }
      },
      "HistoricalParticipation": {
        "type": "object",
        "description": "Record of a character's participation in a historical event",
        "additionalProperties": false,
        "required": [
          "participationId",
          "characterId",
          "eventId",
          "eventName",
          "eventCategory",
          "role",
          "eventDate",
          "createdAt"
        ],
        "properties": {
          "participationId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique ID for this participation record"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character who participated"
          },
          "eventId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the historical event"
          },
          "eventName": {
            "type": "string",
            "description": "Name of the event (for display and summarization)"
          },
          "eventCategory": {
            "$ref": "#/components/schemas/EventCategory",
            "description": "Category of the historical event"
          },
          "role": {
            "$ref": "#/components/schemas/ParticipationRole",
            "description": "How the character participated"
          },
          "eventDate": {
            "type": "string",
            "format": "date-time",
            "description": "In-game date when the event occurred"
          },
          "significance": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.5,
            "description": "How significant this event was for the character (0.0 to 1.0).\nAffects behavior system weighting of this memory.\n"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Event-specific details for behavior decisions"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this record was created"
          }
        }
      },
      "HistoryRequest": {
        "type": "object",
        "description": "Request for scene version history",
        "required": [
          "sceneId"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene to get history for"
          },
          "limit": {
            "type": "integer",
            "default": 10,
            "description": "Maximum versions to return"
          }
        }
      },
      "HistoryResponse": {
        "type": "object",
        "description": "Scene version history",
        "required": [
          "sceneId",
          "versions"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene ID"
          },
          "currentVersion": {
            "type": "string",
            "description": "Current active version"
          },
          "versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VersionInfo"
            },
            "description": "Version history entries"
          }
        }
      },
      "HistorySummaryResponse": {
        "type": "object",
        "description": "Generated text summaries for character compression",
        "additionalProperties": false,
        "required": [
          "characterId",
          "keyBackstoryPoints",
          "majorLifeEvents"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character summarized"
          },
          "keyBackstoryPoints": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Key backstory elements as text summaries.\ne.g., [\"Trained by Knights Guild\", \"Born in the Northlands\"]\n"
          },
          "majorLifeEvents": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Major historical events as text summaries.\ne.g., [\"Fought in the Battle of Stormgate (Hero)\", \"Survived the Great Flood\"]\n"
          }
        }
      },
      "HoldRecord": {
        "type": "object",
        "description": "Authorization hold record",
        "additionalProperties": false,
        "required": [
          "holdId",
          "walletId",
          "currencyDefinitionId",
          "amount",
          "status",
          "createdAt",
          "expiresAt"
        ],
        "properties": {
          "holdId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique hold identifier"
          },
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Wallet with held funds"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency held"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount reserved"
          },
          "status": {
            "$ref": "#/components/schemas/HoldStatus",
            "description": "Current hold status"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When hold was created"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When hold auto-releases"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "Reference type"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference ID"
          },
          "capturedAmount": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Amount actually captured (may differ from held amount)"
          },
          "completedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When hold was captured/released/expired"
          }
        }
      },
      "HoldResponse": {
        "type": "object",
        "description": "Hold details",
        "additionalProperties": false,
        "required": [
          "hold"
        ],
        "properties": {
          "hold": {
            "$ref": "#/components/schemas/HoldRecord",
            "description": "Hold record"
          }
        }
      },
      "HoldStatus": {
        "type": "string",
        "description": "Current status of an authorization hold",
        "enum": [
          "active",
          "captured",
          "released",
          "expired"
        ]
      },
      "InitiateBondRequest": {
        "type": "object",
        "description": "Request to initiate a bond between seeds.",
        "required": [
          "initiatorSeedId",
          "targetSeedId"
        ],
        "properties": {
          "initiatorSeedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed initiating the bond."
          },
          "targetSeedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed being invited to bond."
          }
        }
      },
      "InjectPerceptionRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to inject a perception event into an actor's queue",
        "required": [
          "actorId",
          "perception"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "Target actor to inject perception into"
          },
          "perception": {
            "description": "Perception data to inject",
            "$ref": "#/components/schemas/PerceptionData"
          }
        }
      },
      "InjectPerceptionResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response confirming perception injection",
        "required": [
          "queued",
          "queueDepth"
        ],
        "properties": {
          "queued": {
            "type": "boolean",
            "description": "Whether the perception was successfully queued"
          },
          "queueDepth": {
            "type": "integer",
            "description": "Current depth of the perception queue"
          }
        }
      },
      "InteractWithPoiRequest": {
        "type": "object",
        "description": "Request to interact with a POI",
        "required": [
          "accountId",
          "poiId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account interacting with the POI"
          },
          "poiId": {
            "type": "string",
            "format": "uuid",
            "description": "POI to interact with"
          }
        }
      },
      "IntervalPreferences": {
        "description": "Melodic interval preference weights",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "stepWeight": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.5,
            "description": "Weight for stepwise motion (M2, m2)"
          },
          "thirdWeight": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.25,
            "description": "Weight for thirds (M3, m3)"
          },
          "leapWeight": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.15,
            "description": "Weight for larger leaps (P4, P5)"
          },
          "largeLeapWeight": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.1,
            "description": "Weight for leaps larger than P5"
          }
        }
      },
      "InvalidateCacheRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to invalidate a cached behavior",
        "required": [
          "behaviorId"
        ],
        "properties": {
          "behaviorId": {
            "type": "string",
            "description": "Unique identifier for the cached behavior to invalidate"
          }
        }
      },
      "InvalidateCacheResponse": {
        "type": "object",
        "description": "Result of cache invalidation and rebuild",
        "additionalProperties": false,
        "required": [
          "characterId",
          "obligationsRefreshed",
          "success"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character whose cache was rebuilt"
          },
          "obligationsRefreshed": {
            "type": "integer",
            "minimum": 0,
            "maximum": 10000,
            "description": "Number of obligations found and cached"
          },
          "success": {
            "type": "boolean",
            "description": "Whether the cache rebuild completed successfully"
          }
        }
      },
      "ItemCategory": {
        "type": "string",
        "description": "Item classification category",
        "enum": [
          "weapon",
          "armor",
          "accessory",
          "consumable",
          "material",
          "container",
          "quest",
          "currency_like",
          "misc",
          "custom"
        ]
      },
      "ItemInstanceResponse": {
        "type": "object",
        "description": "Item instance details",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "templateId",
          "containerId",
          "realmId",
          "quantity",
          "originType",
          "createdAt"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique instance identifier"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Reference to the item template"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container holding this item"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm this instance exists in"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "description": "Item quantity"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Slot position in slot-based containers"
          },
          "slotX": {
            "type": "integer",
            "nullable": true,
            "description": "X position in grid-based containers"
          },
          "slotY": {
            "type": "integer",
            "nullable": true,
            "description": "Y position in grid-based containers"
          },
          "rotated": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether item is rotated in grid"
          },
          "currentDurability": {
            "type": "integer",
            "nullable": true,
            "description": "Current durability"
          },
          "boundToId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Character ID this item is bound to"
          },
          "boundAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When item was bound"
          },
          "customStats": {
            "type": "object",
            "nullable": true,
            "description": "Instance-specific stat modifications"
          },
          "customName": {
            "type": "string",
            "nullable": true,
            "description": "Player-assigned custom name"
          },
          "instanceMetadata": {
            "type": "object",
            "nullable": true,
            "description": "Other instance-specific data"
          },
          "originType": {
            "$ref": "#/components/schemas/ItemOriginType",
            "description": "How this item instance was created"
          },
          "originId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Source entity ID"
          },
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Bound contract instance ID. For persistent item-contract bindings or active\nmulti-step use sessions, this references the controlling contract.\n"
          },
          "contractBindingType": {
            "$ref": "#/components/schemas/ContractBindingType",
            "nullable": true,
            "description": "Type of contract binding. 'session' for multi-step use in progress,\n'lifecycle' for external orchestrator-managed bindings, null/none otherwise.\n"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Instance creation timestamp"
          },
          "modifiedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last modification timestamp"
          }
        }
      },
      "ItemLinkageMode": {
        "type": "string",
        "description": "How currency is linked to inventory items",
        "enum": [
          "none",
          "visual_only",
          "reference_only"
        ]
      },
      "ItemOriginType": {
        "type": "string",
        "description": "How an item instance was created",
        "enum": [
          "loot",
          "quest",
          "craft",
          "trade",
          "purchase",
          "spawn",
          "other"
        ]
      },
      "ItemRarity": {
        "type": "string",
        "description": "Item rarity tier",
        "enum": [
          "common",
          "uncommon",
          "rare",
          "epic",
          "legendary",
          "custom"
        ]
      },
      "ItemRequirement": {
        "type": "object",
        "description": "Required item and quantity",
        "additionalProperties": false,
        "required": [
          "templateId",
          "quantity"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Required template"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "minimum": 1,
            "description": "Required quantity"
          }
        }
      },
      "ItemScope": {
        "type": "string",
        "description": "Realm availability scope (consistent with CurrencyScope)",
        "enum": [
          "global",
          "realm_specific",
          "multi_realm"
        ]
      },
      "ItemTemplateResponse": {
        "type": "object",
        "description": "Item template details",
        "additionalProperties": false,
        "required": [
          "templateId",
          "code",
          "gameId",
          "name",
          "category",
          "quantityModel",
          "maxStackSize",
          "scope",
          "tradeable",
          "destroyable",
          "soulboundType",
          "hasDurability",
          "isActive",
          "isDeprecated",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique template identifier"
          },
          "code": {
            "type": "string",
            "description": "Unique code within the game"
          },
          "gameId": {
            "type": "string",
            "description": "Game service this template belongs to"
          },
          "name": {
            "type": "string",
            "description": "Human-readable display name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Detailed description"
          },
          "category": {
            "$ref": "#/components/schemas/ItemCategory",
            "description": "Item classification category"
          },
          "subcategory": {
            "type": "string",
            "nullable": true,
            "description": "Game-defined subcategory"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Filtering tags"
          },
          "rarity": {
            "$ref": "#/components/schemas/ItemRarity",
            "description": "Item rarity tier"
          },
          "quantityModel": {
            "$ref": "#/components/schemas/QuantityModel",
            "description": "How quantities are tracked"
          },
          "maxStackSize": {
            "type": "integer",
            "description": "Maximum stack size"
          },
          "unitOfMeasure": {
            "type": "string",
            "nullable": true,
            "description": "Unit for continuous quantities"
          },
          "weightPrecision": {
            "$ref": "#/components/schemas/WeightPrecision",
            "description": "Precision for weight values"
          },
          "weight": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Weight value"
          },
          "volume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Volume for volumetric inventories"
          },
          "gridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "Width in grid-based inventories"
          },
          "gridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "Height in grid-based inventories"
          },
          "canRotate": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether item can be rotated in grid"
          },
          "baseValue": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Reference price"
          },
          "tradeable": {
            "type": "boolean",
            "description": "Whether item can be traded"
          },
          "destroyable": {
            "type": "boolean",
            "description": "Whether item can be destroyed"
          },
          "soulboundType": {
            "$ref": "#/components/schemas/SoulboundType",
            "description": "Binding behavior type"
          },
          "hasDurability": {
            "type": "boolean",
            "description": "Whether item has durability"
          },
          "maxDurability": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum durability value"
          },
          "scope": {
            "$ref": "#/components/schemas/ItemScope",
            "description": "Realm availability scope"
          },
          "availableRealms": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "Available realms"
          },
          "stats": {
            "type": "object",
            "nullable": true,
            "description": "Game-defined stats"
          },
          "effects": {
            "type": "object",
            "nullable": true,
            "description": "Game-defined effects"
          },
          "requirements": {
            "type": "object",
            "nullable": true,
            "description": "Game-defined requirements"
          },
          "display": {
            "type": "object",
            "nullable": true,
            "description": "Display properties"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "description": "Other game-specific data"
          },
          "useBehaviorContractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract template ID for executable item behavior (null if not usable)"
          },
          "canUseBehaviorContractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract template for pre-use validation (null if not configured)"
          },
          "onUseFailedBehaviorContractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract template for use failure handling (null if not configured)"
          },
          "itemUseBehavior": {
            "$ref": "#/components/schemas/ItemUseBehavior",
            "nullable": true,
            "description": "How the item behaves when used (null defaults to destroy_on_success)"
          },
          "canUseBehavior": {
            "$ref": "#/components/schemas/CanUseBehavior",
            "nullable": true,
            "description": "How CanUse validation failures are handled (null defaults to block)"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether template is active"
          },
          "isDeprecated": {
            "type": "boolean",
            "description": "Whether template is deprecated"
          },
          "deprecatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When template was deprecated"
          },
          "migrationTargetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Migration target template"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Last update timestamp"
          }
        }
      },
      "ItemUseBehavior": {
        "type": "string",
        "description": "Controls item consumption on use.\n- disabled: Item cannot be used (/item/use returns 400)\n- destroy_on_success: Item consumed only if use behavior succeeds (default)\n- destroy_always: Item consumed regardless of success/failure\n",
        "enum": [
          "disabled",
          "destroy_on_success",
          "destroy_always"
        ]
      },
      "JoinMatchmakingRequest": {
        "type": "object",
        "description": "Request to join a matchmaking queue",
        "additionalProperties": false,
        "required": [
          "webSocketSessionId",
          "accountId",
          "queueId"
        ],
        "properties": {
          "webSocketSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID for event delivery"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player joining"
          },
          "queueId": {
            "type": "string",
            "description": "ID of the queue to join"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Party ID if joining as part of a party"
          },
          "partyMembers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartyMemberInfo"
            },
            "nullable": true,
            "description": "Party member information (required if partyId provided)"
          },
          "stringProperties": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "String properties for query matching"
          },
          "numericProperties": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            },
            "nullable": true,
            "description": "Numeric properties for query matching"
          },
          "query": {
            "type": "string",
            "nullable": true,
            "maxLength": 1000,
            "description": "Lucene-like query for opponent matching"
          },
          "tournamentId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Tournament ID if joining tournament queue"
          }
        }
      },
      "JoinMatchmakingResponse": {
        "type": "object",
        "description": "Response after joining a matchmaking queue",
        "additionalProperties": false,
        "required": [
          "ticketId",
          "queueId",
          "estimatedWaitSeconds"
        ],
        "properties": {
          "ticketId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this matchmaking ticket"
          },
          "queueId": {
            "type": "string",
            "description": "Queue that was joined"
          },
          "estimatedWaitSeconds": {
            "type": "integer",
            "nullable": true,
            "description": "Estimated wait time based on current queue (null if unknown)"
          },
          "position": {
            "type": "integer",
            "nullable": true,
            "description": "Approximate position in queue (null if not tracked)"
          }
        }
      },
      "JoinRoomRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to join a chat room as a participant",
        "required": [
          "roomId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID to join"
          },
          "senderType": {
            "type": "string",
            "nullable": true,
            "description": "Opaque sender type identifier (e.g., \"session\", \"character\", \"system\")"
          },
          "senderId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Sender entity ID (nullable for anonymous)"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable display name"
          },
          "role": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChatParticipantRole"
              }
            ],
            "nullable": true,
            "description": "Requested role (defaults to Member if not specified)"
          }
        }
      },
      "JsonPatchOperation": {
        "type": "object",
        "required": [
          "op",
          "path"
        ],
        "description": "JSON Patch operation per RFC 6902.\nUses JsonPatch.Net library (MIT licensed).\n",
        "properties": {
          "op": {
            "type": "string",
            "enum": [
              "add",
              "remove",
              "replace",
              "move",
              "copy",
              "test"
            ],
            "description": "Operation type"
          },
          "path": {
            "type": "string",
            "description": "JSON Pointer to target location"
          },
          "from": {
            "type": "string",
            "nullable": true,
            "description": "Source path (for move/copy operations)"
          },
          "value": {
            "description": "Value to use (for add/replace/test operations)"
          }
        }
      },
      "KeySignature": {
        "description": "A key signature with tonic and mode",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "tonic",
          "mode"
        ],
        "properties": {
          "tonic": {
            "$ref": "#/components/schemas/PitchClass",
            "description": "Tonic pitch class"
          },
          "mode": {
            "type": "string",
            "enum": [
              "major",
              "minor",
              "dorian",
              "phrygian",
              "lydian",
              "mixolydian",
              "aeolian",
              "locrian"
            ],
            "description": "Mode/scale type"
          }
        }
      },
      "KeySignatureEvent": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.KeySignatureEvent",
        "description": "A key signature change event",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "tick",
          "tonic",
          "mode"
        ],
        "properties": {
          "tick": {
            "type": "integer",
            "minimum": 0,
            "description": "Tick position"
          },
          "tonic": {
            "$ref": "#/components/schemas/PitchClass",
            "description": "Tonic pitch class"
          },
          "mode": {
            "$ref": "#/components/schemas/ModeType",
            "description": "Mode/scale type"
          }
        }
      },
      "KickParticipantRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to remove a participant from a room",
        "required": [
          "roomId",
          "targetSessionId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID"
          },
          "targetSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Session ID of participant to kick"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for the kick"
          }
        }
      },
      "LayerDefinition": {
        "type": "object",
        "description": "Configuration for a specific layer within a map definition",
        "required": [
          "kind"
        ],
        "properties": {
          "kind": {
            "$ref": "#/components/schemas/MapKind",
            "description": "The layer kind"
          },
          "storageMode": {
            "type": "string",
            "enum": [
              "durable",
              "cached",
              "ephemeral"
            ],
            "default": "cached",
            "description": "How this layer's data should be stored"
          },
          "ttlSeconds": {
            "type": "integer",
            "description": "TTL for cached/ephemeral data (0 = no TTL)",
            "nullable": true
          },
          "defaultNonAuthorityHandling": {
            "$ref": "#/components/schemas/NonAuthorityHandlingMode",
            "description": "Default non-authority handling for channels using this layer"
          },
          "cellSize": {
            "type": "number",
            "format": "double",
            "description": "Spatial cell size for indexing (default from config if not set)",
            "nullable": true
          }
        }
      },
      "LeaderboardDefinitionResponse": {
        "type": "object",
        "description": "Leaderboard definition details",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId",
          "displayName",
          "sortOrder",
          "updateMode",
          "isSeasonal",
          "isPublic",
          "createdAt"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning game service"
          },
          "leaderboardId": {
            "type": "string",
            "description": "Unique identifier for this leaderboard"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Description of the leaderboard"
          },
          "entityTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityType"
            },
            "description": "Allowed entity types"
          },
          "sortOrder": {
            "$ref": "#/components/schemas/SortOrder",
            "description": "Ordering used when ranking scores (descending for high scores, ascending for low)"
          },
          "updateMode": {
            "$ref": "#/components/schemas/UpdateMode",
            "description": "Rule applied when new scores are submitted (replace/increment/max/min)"
          },
          "isSeasonal": {
            "type": "boolean",
            "description": "Whether the leaderboard is seasonal"
          },
          "isPublic": {
            "type": "boolean",
            "description": "Whether the leaderboard is publicly visible"
          },
          "currentSeason": {
            "type": "integer",
            "nullable": true,
            "description": "Current season number (if seasonal)"
          },
          "entryCount": {
            "type": "integer",
            "format": "int64",
            "description": "Number of entries on the leaderboard"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the leaderboard was created"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional metadata"
          }
        }
      },
      "LeaderboardEntriesResponse": {
        "type": "object",
        "description": "Response containing leaderboard entries",
        "additionalProperties": false,
        "required": [
          "leaderboardId",
          "entries",
          "totalEntries"
        ],
        "properties": {
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard"
          },
          "entries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LeaderboardEntry"
            },
            "description": "List of leaderboard entries"
          },
          "totalEntries": {
            "type": "integer",
            "format": "int64",
            "description": "Total entries on the leaderboard"
          }
        }
      },
      "LeaderboardEntry": {
        "type": "object",
        "description": "A single entry on a leaderboard",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "score",
          "rank"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type for this leaderboard entry"
          },
          "score": {
            "type": "number",
            "format": "double",
            "description": "Entity's score"
          },
          "rank": {
            "type": "integer",
            "format": "int64",
            "description": "Entity's rank (1-based)"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Cached display name for the entity"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Entry metadata"
          }
        }
      },
      "LeaveGameSessionByIdRequest": {
        "type": "object",
        "description": "Request to leave a specific game session by ID",
        "additionalProperties": false,
        "required": [
          "accountId",
          "gameSessionId"
        ],
        "properties": {
          "webSocketSessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "WebSocket session ID of the client leaving. Null for server-side cleanup operations (e.g., scenario lifecycle worker) where no real WebSocket session exists."
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player leaving."
          },
          "gameSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game session to leave."
          }
        }
      },
      "LeaveGameSessionRequest": {
        "type": "object",
        "description": "Request to leave a game session",
        "additionalProperties": false,
        "required": [
          "sessionId",
          "accountId",
          "gameType"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID of the client leaving. Provided by shortcut system."
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player leaving. Provided by shortcut system."
          },
          "gameType": {
            "type": "string",
            "description": "Game type being left. Determines which lobby to leave. Provided by shortcut system."
          }
        }
      },
      "LeaveGardenRequest": {
        "type": "object",
        "description": "Request to leave the garden",
        "required": [
          "accountId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account leaving the garden"
          }
        }
      },
      "LeaveGardenResponse": {
        "type": "object",
        "description": "Response after leaving the garden",
        "required": [
          "accountId",
          "sessionDurationSeconds"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account that left the garden"
          },
          "sessionDurationSeconds": {
            "type": "number",
            "format": "float",
            "description": "Total duration of the garden session in seconds"
          }
        }
      },
      "LeaveMatchmakingRequest": {
        "type": "object",
        "description": "Request to leave a matchmaking queue",
        "additionalProperties": false,
        "required": [
          "webSocketSessionId",
          "accountId",
          "ticketId"
        ],
        "properties": {
          "webSocketSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the player"
          },
          "ticketId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the ticket to cancel"
          }
        }
      },
      "LeaveRoomRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to leave a chat room",
        "required": [
          "roomId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID to leave"
          }
        }
      },
      "LicenseDefinitionResponse": {
        "type": "object",
        "description": "License definition with all fields",
        "additionalProperties": false,
        "required": [
          "licenseDefinitionId",
          "boardTemplateId",
          "code",
          "position",
          "lpCost",
          "itemTemplateId",
          "createdAt"
        ],
        "properties": {
          "licenseDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique license definition identifier"
          },
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template this definition belongs to"
          },
          "code": {
            "type": "string",
            "description": "Unique license code within this board template"
          },
          "position": {
            "$ref": "#/components/schemas/GridPosition",
            "description": "Grid position of this license node"
          },
          "lpCost": {
            "type": "integer",
            "description": "License Point cost to unlock this node"
          },
          "itemTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Item template created when this license is unlocked"
          },
          "prerequisites": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "License codes that must be unlocked before this one"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description of what this license grants"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Game-specific metadata for this license node"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this definition was created"
          }
        }
      },
      "LicenseStatus": {
        "type": "string",
        "description": "Unlock status of a license node on a board.\n- locked: Not adjacent to any unlocked node (cannot be unlocked)\n- unlockable: Adjacent to an unlocked node or is a starting node (can be unlocked)\n- unlocked: Already unlocked (item placed at this position)\n",
        "enum": [
          "locked",
          "unlockable",
          "unlocked"
        ]
      },
      "ListAchievementDefinitionsRequest": {
        "type": "object",
        "description": "Request to list achievement definitions",
        "additionalProperties": false,
        "required": [
          "gameServiceId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "platform": {
            "$ref": "#/components/schemas/Platform",
            "nullable": true,
            "description": "Filter by platform"
          },
          "achievementType": {
            "$ref": "#/components/schemas/AchievementType",
            "nullable": true,
            "description": "Filter by achievement classification"
          },
          "isActive": {
            "type": "boolean",
            "nullable": true,
            "description": "Filter by active status"
          },
          "includeHidden": {
            "type": "boolean",
            "default": false,
            "description": "Include hidden achievements in response"
          }
        }
      },
      "ListAchievementDefinitionsResponse": {
        "type": "object",
        "description": "Response containing achievement definitions",
        "additionalProperties": false,
        "required": [
          "achievements"
        ],
        "properties": {
          "achievements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AchievementDefinitionResponse"
            },
            "description": "List of achievement definitions"
          }
        }
      },
      "ListActionMappingsRequest": {
        "type": "object",
        "description": "Request to list action tag mappings with pagination",
        "additionalProperties": false,
        "properties": {
          "searchTerm": {
            "type": "string",
            "nullable": true,
            "maxLength": 256,
            "description": "Optional text search across tag names and descriptions"
          },
          "cursor": {
            "type": "string",
            "nullable": true,
            "maxLength": 512,
            "description": "Pagination cursor from a previous response"
          },
          "pageSize": {
            "type": "integer",
            "default": 20,
            "minimum": 1,
            "maximum": 100,
            "description": "Number of mappings to return per page"
          }
        }
      },
      "ListActionMappingsResponse": {
        "type": "object",
        "description": "Paginated list of action tag mappings",
        "additionalProperties": false,
        "required": [
          "mappings",
          "hasMore"
        ],
        "properties": {
          "mappings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ActionMappingResponse"
            },
            "description": "Action tag mappings for this page"
          },
          "nextCursor": {
            "type": "string",
            "nullable": true,
            "maxLength": 512,
            "description": "Cursor for the next page (null if no more pages)"
          },
          "hasMore": {
            "type": "boolean",
            "description": "Whether more pages are available"
          }
        }
      },
      "ListArchivesRequest": {
        "description": "Request to list available archives for a namespace",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to list archives for"
          },
          "limit": {
            "type": "integer",
            "default": 20,
            "minimum": 1,
            "maximum": 100,
            "description": "Maximum number of archives to return"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "minimum": 0,
            "description": "Number of archives to skip"
          }
        }
      },
      "ListArchivesResponse": {
        "description": "Response containing a paginated list of archives",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "archives",
          "total"
        ],
        "properties": {
          "archives": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ArchiveInfo"
            },
            "description": "List of archives for the namespace"
          },
          "total": {
            "type": "integer",
            "description": "Total number of archives"
          }
        }
      },
      "ListAreaContentConfigsRequest": {
        "type": "object",
        "description": "Request to list area content configs for a game service",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "collectionType"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service to list area configs for"
          },
          "collectionType": {
            "$ref": "#/components/schemas/CollectionType",
            "description": "Type of collection to list configs for"
          }
        }
      },
      "ListAreaContentConfigsResponse": {
        "type": "object",
        "description": "List of area content configurations",
        "additionalProperties": false,
        "required": [
          "configs"
        ],
        "properties": {
          "configs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AreaContentConfigResponse"
            },
            "description": "Area content configurations for this game service"
          }
        }
      },
      "ListAvailableQuestsRequest": {
        "type": "object",
        "description": "Request to list quests available for a character to accept",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to check availability for"
          },
          "questGiverCharacterId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by quest giver"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by game service"
          }
        }
      },
      "ListAvailableQuestsResponse": {
        "type": "object",
        "description": "List of quest definitions available for acceptance",
        "additionalProperties": false,
        "required": [
          "available"
        ],
        "properties": {
          "available": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QuestDefinitionResponse"
            },
            "description": "Available quest definitions"
          }
        }
      },
      "ListBlessingsByDeityRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list blessings granted by a deity",
        "required": [
          "deityId"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity whose granted blessings to list"
          },
          "tier": {
            "$ref": "#/components/schemas/BlessingTier",
            "nullable": true,
            "description": "Optional tier filter"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 50,
            "description": "Number of results per page"
          }
        }
      },
      "ListBlessingsByEntityRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list blessings for an entity",
        "required": [
          "entityId",
          "entityType"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity whose blessings to list"
          },
          "entityType": {
            "type": "string",
            "description": "Type of entity (e.g., character, account, deity)"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 50,
            "description": "Number of results per page"
          }
        }
      },
      "ListBlessingsResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Paginated list of blessings",
        "required": [
          "blessings",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "blessings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BlessingSummary"
            },
            "description": "Blessings in the current page"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching blessings"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          }
        }
      },
      "ListBoardTemplatesRequest": {
        "type": "object",
        "description": "Request to list board templates with cursor-based pagination",
        "additionalProperties": false,
        "required": [
          "gameServiceId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Filter by game service"
          },
          "cursor": {
            "type": "string",
            "nullable": true,
            "description": "Opaque cursor from previous response. Null for first page."
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "nullable": true,
            "description": "Number of items per page. Uses service default if not specified."
          }
        }
      },
      "ListBoardTemplatesResponse": {
        "type": "object",
        "description": "Paginated list of board templates",
        "additionalProperties": false,
        "required": [
          "templates",
          "hasMore"
        ],
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BoardTemplateResponse"
            },
            "description": "Board templates in this page"
          },
          "nextCursor": {
            "type": "string",
            "nullable": true,
            "description": "Cursor for next page. Null if no more results."
          },
          "hasMore": {
            "type": "boolean",
            "description": "Whether more results exist beyond this page"
          }
        }
      },
      "ListBoardsByOwnerRequest": {
        "type": "object",
        "description": "Request to list board instances for an owner entity",
        "additionalProperties": false,
        "required": [
          "ownerType",
          "ownerId"
        ],
        "properties": {
          "ownerType": {
            "type": "string",
            "description": "Type of entity that owns the boards"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity to list boards for"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional filter by game service"
          }
        }
      },
      "ListBoardsByOwnerResponse": {
        "type": "object",
        "description": "List of board instances for an owner entity",
        "additionalProperties": false,
        "required": [
          "boards"
        ],
        "properties": {
          "boards": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BoardResponse"
            },
            "description": "Board instances for this owner"
          }
        }
      },
      "ListBundleVersionsRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list bundle version history",
        "required": [
          "bundleId"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier to get history for"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Maximum versions to return"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          }
        }
      },
      "ListBundleVersionsResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Bundle version history",
        "required": [
          "bundleId",
          "currentVersion",
          "versions",
          "totalCount"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier"
          },
          "currentVersion": {
            "type": "integer",
            "description": "Current version number"
          },
          "versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BundleVersionRecord"
            },
            "description": "Version history records (newest first)"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of versions"
          }
        }
      },
      "ListCharactersRequest": {
        "description": "Request payload for listing characters with filtering and pagination",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm to list characters from (required for efficiency)"
          },
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by species"
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CharacterStatus"
              }
            ],
            "nullable": true,
            "description": "Filter by status"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "ListClauseTypesRequest": {
        "type": "object",
        "description": "Request to list clause types",
        "additionalProperties": false,
        "properties": {
          "category": {
            "$ref": "#/components/schemas/ClauseCategory",
            "nullable": true,
            "description": "Filter by category"
          },
          "includeBuiltIn": {
            "type": "boolean",
            "default": true,
            "description": "Include built-in types in response"
          }
        }
      },
      "ListClauseTypesResponse": {
        "type": "object",
        "description": "Response containing list of clause types",
        "additionalProperties": false,
        "required": [
          "clauseTypes"
        ],
        "properties": {
          "clauseTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ClauseTypeSummary"
            },
            "description": "List of registered clause types"
          }
        }
      },
      "ListCleanupCallbacksRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list registered cleanup callbacks",
        "properties": {
          "resourceType": {
            "type": "string",
            "nullable": true,
            "description": "Filter by resource type (list all if not specified)"
          },
          "sourceType": {
            "type": "string",
            "nullable": true,
            "description": "Filter by source type (requires resourceType)"
          }
        }
      },
      "ListCleanupCallbacksResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "List of registered cleanup callbacks",
        "required": [
          "callbacks",
          "totalCount"
        ],
        "properties": {
          "callbacks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CleanupCallbackSummary"
            },
            "description": "Registered callbacks matching filter"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of callbacks returned"
          }
        }
      },
      "ListCollectionsRequest": {
        "type": "object",
        "description": "Request to list collections for an owner",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity to list collections for"
          },
          "ownerType": {
            "type": "string",
            "description": "Entity type discriminator"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional filter by game service"
          }
        }
      },
      "ListCollectionsResponse": {
        "type": "object",
        "description": "List of collections for an owner",
        "additionalProperties": false,
        "required": [
          "collections"
        ],
        "properties": {
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CollectionResponse"
            },
            "description": "Collection instances for this owner"
          }
        }
      },
      "ListCompressCallbacksRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list registered compression callbacks",
        "properties": {
          "resourceType": {
            "type": "string",
            "nullable": true,
            "description": "Filter by resource type (list all if not specified)"
          },
          "sourceType": {
            "type": "string",
            "nullable": true,
            "description": "Filter by source type (requires resourceType)"
          }
        }
      },
      "ListCompressCallbacksResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "List of registered compression callbacks",
        "required": [
          "callbacks",
          "totalCount"
        ],
        "properties": {
          "callbacks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CompressCallbackSummary"
            },
            "description": "Registered callbacks matching filter"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of callbacks returned"
          }
        }
      },
      "ListContainersRequest": {
        "type": "object",
        "description": "Request to list containers for an owner",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner entity ID"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Owner type"
          },
          "containerType": {
            "type": "string",
            "nullable": true,
            "description": "Filter by container type"
          },
          "includeEquipmentSlots": {
            "type": "boolean",
            "default": true,
            "description": "Include equipment slot containers"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by realm"
          }
        }
      },
      "ListContainersResponse": {
        "type": "object",
        "description": "List of containers",
        "additionalProperties": false,
        "required": [
          "containers",
          "totalCount"
        ],
        "properties": {
          "containers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContainerResponse"
            },
            "description": "List of containers"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total count"
          }
        }
      },
      "ListContractTemplatesRequest": {
        "type": "object",
        "description": "Request to list contract templates with cursor-based pagination.",
        "additionalProperties": false,
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by realm (null includes cross-realm templates)."
          },
          "isActive": {
            "type": "boolean",
            "nullable": true,
            "description": "Filter by active status."
          },
          "searchTerm": {
            "type": "string",
            "nullable": true,
            "description": "Search in name and description."
          },
          "cursor": {
            "type": "string",
            "nullable": true,
            "description": "Opaque cursor from previous response. Null for first page."
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "nullable": true,
            "description": "Number of items per page. Uses service default if not specified."
          }
        }
      },
      "ListContractTemplatesResponse": {
        "type": "object",
        "description": "Paginated list of contract templates.",
        "additionalProperties": false,
        "required": [
          "templates",
          "hasMore"
        ],
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContractTemplateResponse"
            },
            "description": "Templates in this page."
          },
          "nextCursor": {
            "type": "string",
            "nullable": true,
            "description": "Cursor for next page. Null if no more results."
          },
          "hasMore": {
            "type": "boolean",
            "description": "Whether more results exist beyond this page."
          }
        }
      },
      "ListCurrencyDefinitionsRequest": {
        "type": "object",
        "description": "Request to list currency definitions",
        "additionalProperties": false,
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by realm availability"
          },
          "scope": {
            "$ref": "#/components/schemas/CurrencyScope",
            "nullable": true,
            "description": "Filter by scope"
          },
          "includeInactive": {
            "type": "boolean",
            "default": false,
            "description": "Include inactive definitions"
          },
          "isBaseCurrency": {
            "type": "boolean",
            "nullable": true,
            "description": "Filter by base currency flag"
          }
        }
      },
      "ListCurrencyDefinitionsResponse": {
        "type": "object",
        "description": "List of currency definitions",
        "additionalProperties": false,
        "required": [
          "definitions"
        ],
        "properties": {
          "definitions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CurrencyDefinitionResponse"
            },
            "description": "Currency definitions matching filter"
          }
        }
      },
      "ListDefinitionsRequest": {
        "type": "object",
        "description": "Request to list map definitions",
        "properties": {
          "nameFilter": {
            "type": "string",
            "description": "Filter by name (partial match)",
            "nullable": true
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Max results to return"
          }
        }
      },
      "ListDefinitionsResponse": {
        "type": "object",
        "description": "Response containing list of map definitions",
        "properties": {
          "definitions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapDefinition"
            },
            "description": "List of definitions"
          },
          "total": {
            "type": "integer",
            "description": "Total count matching filter"
          },
          "offset": {
            "type": "integer",
            "description": "Current offset"
          },
          "limit": {
            "type": "integer",
            "description": "Results limit used"
          }
        }
      },
      "ListDeitiesRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list deities with optional filters",
        "required": [
          "gameServiceId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service to list deities for"
          },
          "domainCode": {
            "type": "string",
            "nullable": true,
            "description": "Filter by domain code (returns deities with this domain in their influences)"
          },
          "status": {
            "$ref": "#/components/schemas/DeityStatus",
            "nullable": true,
            "description": "Filter by deity status"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 50,
            "description": "Number of results per page"
          }
        }
      },
      "ListDeitiesResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Paginated list of deities",
        "required": [
          "deities",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "deities": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeityResponse"
            },
            "description": "Deities in the current page"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching deities"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          }
        }
      },
      "ListDocumentsRequest": {
        "description": "Request to list documents with optional filtering and pagination",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to list documents from"
          },
          "category": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "Filter to a specific category"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by tags (null to skip tag filtering)"
          },
          "tagsMatch": {
            "type": "string",
            "enum": [
              "all",
              "any"
            ],
            "default": "all",
            "description": "Whether documents must match all tags or any tag"
          },
          "createdAfter": {
            "type": "string",
            "format": "date-time",
            "description": "Filter to documents created after this timestamp"
          },
          "createdBefore": {
            "type": "string",
            "format": "date-time",
            "description": "Filter to documents created before this timestamp"
          },
          "updatedAfter": {
            "type": "string",
            "format": "date-time",
            "description": "Filter to documents updated after this timestamp"
          },
          "updatedBefore": {
            "type": "string",
            "format": "date-time",
            "description": "Filter to documents updated before this timestamp"
          },
          "titlesOnly": {
            "type": "boolean",
            "default": false,
            "description": "Return only document titles without summaries"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "minimum": 1,
            "description": "Page number for pagination"
          },
          "pageSize": {
            "type": "integer",
            "default": 20,
            "minimum": 1,
            "maximum": 100,
            "description": "Number of documents per page"
          },
          "sortBy": {
            "$ref": "#/components/schemas/ListSortField",
            "description": "Field to sort results by"
          },
          "sortOrder": {
            "type": "string",
            "enum": [
              "asc",
              "desc"
            ],
            "default": "desc",
            "description": "Sort order direction"
          }
        }
      },
      "ListDocumentsResponse": {
        "description": "Response containing a paginated list of documents",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "documents"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "description": "The namespace that was listed"
          },
          "documents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentSummary"
            },
            "description": "List of documents in the namespace"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of documents matching filters"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of documents per page"
          },
          "totalPages": {
            "type": "integer",
            "description": "Total number of pages available"
          }
        }
      },
      "ListEncounterTypesRequest": {
        "type": "object",
        "description": "Request to list encounter types with optional filtering",
        "additionalProperties": false,
        "properties": {
          "includeInactive": {
            "type": "boolean",
            "default": false,
            "description": "Include soft-deleted types"
          },
          "builtInOnly": {
            "type": "boolean",
            "default": false,
            "description": "Only return built-in types"
          },
          "customOnly": {
            "type": "boolean",
            "default": false,
            "description": "Only return custom types"
          }
        }
      },
      "ListEntitiesAtLocationRequest": {
        "description": "Request to list entities at a specific location",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "locationId"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the location to query"
          },
          "entityType": {
            "type": "string",
            "nullable": true,
            "description": "Optional filter by entity type (opaque string)"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "description": "Page number (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "default": 50,
            "description": "Number of entities per page"
          }
        }
      },
      "ListEntitiesAtLocationResponse": {
        "description": "Result of listing entities at a location",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "entities",
          "totalCount",
          "locationId"
        ],
        "properties": {
          "entities": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityPresenceEntry"
            },
            "description": "Entities currently present at the location"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of entities matching the query"
          },
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the queried location"
          }
        }
      },
      "ListEntryTemplatesRequest": {
        "type": "object",
        "description": "Request to list entry templates with filtering and pagination",
        "additionalProperties": false,
        "required": [
          "collectionType",
          "gameServiceId"
        ],
        "properties": {
          "collectionType": {
            "$ref": "#/components/schemas/CollectionType",
            "description": "Filter by collection type"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Filter by game service"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Optional filter by category"
          },
          "cursor": {
            "type": "string",
            "nullable": true,
            "description": "Opaque cursor from previous response for pagination"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "nullable": true,
            "description": "Number of items per page (uses service default if not specified)"
          }
        }
      },
      "ListEntryTemplatesResponse": {
        "type": "object",
        "description": "Paginated list of entry templates",
        "additionalProperties": false,
        "required": [
          "templates",
          "hasMore"
        ],
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntryTemplateResponse"
            },
            "description": "Entry templates in this page"
          },
          "nextCursor": {
            "type": "string",
            "nullable": true,
            "description": "Cursor for next page (null if no more results)"
          },
          "hasMore": {
            "type": "boolean",
            "description": "Whether more results exist beyond this page"
          }
        }
      },
      "ListEscrowsRequest": {
        "type": "object",
        "description": "Request to list escrow agreements with optional filters",
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by party"
          },
          "partyType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EntityType"
              }
            ],
            "nullable": true,
            "description": "Party type filter"
          },
          "status": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/EscrowStatus"
            },
            "description": "Filter by status"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "Filter by reference type"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by reference ID"
          },
          "fromDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter from date"
          },
          "toDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter to date"
          },
          "limit": {
            "type": "integer",
            "nullable": true,
            "description": "Limit results"
          },
          "offset": {
            "type": "integer",
            "nullable": true,
            "description": "Offset for pagination"
          }
        }
      },
      "ListEscrowsResponse": {
        "type": "object",
        "description": "Response containing list of escrow agreements",
        "required": [
          "escrows",
          "totalCount"
        ],
        "properties": {
          "escrows": {
            "type": "array",
            "description": "List of escrow agreements matching the query",
            "items": {
              "$ref": "#/components/schemas/EscrowAgreement"
            }
          },
          "totalCount": {
            "type": "integer",
            "description": "Total count for pagination"
          }
        }
      },
      "ListFactionsRequest": {
        "type": "object",
        "description": "Request to list factions with filters",
        "additionalProperties": false,
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by game service"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by realm"
          },
          "status": {
            "$ref": "#/components/schemas/FactionStatus",
            "nullable": true,
            "description": "Filter by lifecycle status"
          },
          "parentFactionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by parent faction (null returns top-level factions only when isTopLevelOnly is true)"
          },
          "isTopLevelOnly": {
            "type": "boolean",
            "default": false,
            "description": "When true, returns only factions with no parent"
          },
          "isRealmBaseline": {
            "type": "boolean",
            "nullable": true,
            "description": "Filter by realm baseline status"
          },
          "cursor": {
            "type": "string",
            "nullable": true,
            "maxLength": 512,
            "description": "Pagination cursor from a previous response"
          },
          "pageSize": {
            "type": "integer",
            "default": 20,
            "minimum": 1,
            "maximum": 100,
            "description": "Number of factions to return per page"
          }
        }
      },
      "ListFactionsResponse": {
        "type": "object",
        "description": "Paginated list of factions",
        "additionalProperties": false,
        "required": [
          "factions",
          "hasMore"
        ],
        "properties": {
          "factions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FactionResponse"
            },
            "description": "Factions for this page"
          },
          "nextCursor": {
            "type": "string",
            "nullable": true,
            "maxLength": 512,
            "description": "Cursor for the next page (null if no more pages)"
          },
          "hasMore": {
            "type": "boolean",
            "description": "Whether more pages are available"
          }
        }
      },
      "ListFollowersResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Paginated list of deity followers",
        "required": [
          "followers",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "followers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FollowerResponse"
            },
            "description": "Followers in the current page"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of followers"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          }
        }
      },
      "ListItemTemplatesRequest": {
        "type": "object",
        "description": "Request to list item templates",
        "additionalProperties": false,
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Filter by game service"
          },
          "category": {
            "$ref": "#/components/schemas/ItemCategory",
            "description": "Filter by item category"
          },
          "subcategory": {
            "type": "string",
            "nullable": true,
            "description": "Filter by subcategory"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by tags (items must have all specified tags)"
          },
          "rarity": {
            "$ref": "#/components/schemas/ItemRarity",
            "description": "Filter by rarity tier"
          },
          "scope": {
            "$ref": "#/components/schemas/ItemScope",
            "description": "Filter by realm scope"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by realm availability"
          },
          "includeInactive": {
            "type": "boolean",
            "default": false,
            "description": "Include inactive templates"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Include deprecated templates"
          },
          "search": {
            "type": "string",
            "nullable": true,
            "description": "Search in name and description"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "maximum": 200,
            "description": "Maximum results to return"
          }
        }
      },
      "ListItemTemplatesResponse": {
        "type": "object",
        "description": "Paginated list of item templates",
        "additionalProperties": false,
        "required": [
          "templates",
          "totalCount"
        ],
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ItemTemplateResponse"
            },
            "description": "List of templates"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching templates"
          }
        }
      },
      "ListItemsByContainerRequest": {
        "type": "object",
        "description": "Request to list items in a container",
        "additionalProperties": false,
        "required": [
          "containerId"
        ],
        "properties": {
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container to list items from"
          }
        }
      },
      "ListItemsResponse": {
        "type": "object",
        "description": "List of item instances",
        "additionalProperties": false,
        "required": [
          "items",
          "totalCount",
          "wasTruncated"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ItemInstanceResponse"
            },
            "description": "List of items"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching items (actual count, may exceed items returned)"
          },
          "wasTruncated": {
            "type": "boolean",
            "description": "True if the result was truncated due to MaxInstancesPerQuery limit",
            "default": false
          }
        }
      },
      "ListLicenseDefinitionsRequest": {
        "type": "object",
        "description": "Request to list all license definitions for a board template",
        "additionalProperties": false,
        "required": [
          "boardTemplateId"
        ],
        "properties": {
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template to list definitions for"
          }
        }
      },
      "ListLicenseDefinitionsResponse": {
        "type": "object",
        "description": "All license definitions for a board template",
        "additionalProperties": false,
        "required": [
          "boardTemplateId",
          "definitions"
        ],
        "properties": {
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template these definitions belong to"
          },
          "definitions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LicenseDefinitionResponse"
            },
            "description": "All license definitions for this board template"
          }
        }
      },
      "ListLocationsByParentRequest": {
        "description": "Request to list all child locations of a specified parent location",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "parentLocationId"
        ],
        "properties": {
          "parentLocationId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the parent location"
          },
          "locationType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LocationType"
              }
            ],
            "nullable": true,
            "description": "Optional filter by location type"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated locations in the response"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "ListLocationsByRealmRequest": {
        "description": "Request to list all locations within a specific realm with optional filtering",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID to query"
          },
          "locationType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LocationType"
              }
            ],
            "nullable": true,
            "description": "Optional type filter"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated locations in the response"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "ListLocationsRequest": {
        "description": "Request to list locations within a realm with optional type and deprecation filtering",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID to query (required - locations are partitioned by realm)"
          },
          "locationType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LocationType"
              }
            ],
            "nullable": true,
            "description": "Filter by location type"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated locations in the response"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "ListMembersRequest": {
        "type": "object",
        "description": "Request to list members of a faction",
        "additionalProperties": false,
        "required": [
          "factionId"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction to list members for"
          },
          "role": {
            "$ref": "#/components/schemas/FactionMemberRole",
            "nullable": true,
            "description": "Filter by role"
          },
          "cursor": {
            "type": "string",
            "nullable": true,
            "maxLength": 512,
            "description": "Pagination cursor from a previous response"
          },
          "pageSize": {
            "type": "integer",
            "default": 20,
            "minimum": 1,
            "maximum": 100,
            "description": "Number of members to return per page"
          }
        }
      },
      "ListMembersResponse": {
        "type": "object",
        "description": "Paginated list of faction members",
        "additionalProperties": false,
        "required": [
          "members",
          "hasMore"
        ],
        "properties": {
          "members": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FactionMemberResponse"
            },
            "description": "Members for this page"
          },
          "nextCursor": {
            "type": "string",
            "nullable": true,
            "maxLength": 512,
            "description": "Cursor for the next page (null if no more pages)"
          },
          "hasMore": {
            "type": "boolean",
            "description": "Whether more pages are available"
          }
        }
      },
      "ListMembershipsByCharacterRequest": {
        "type": "object",
        "description": "Request to list a character's faction memberships",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to list memberships for"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by game service"
          }
        }
      },
      "ListMembershipsByCharacterResponse": {
        "type": "object",
        "description": "All faction memberships for a character",
        "additionalProperties": false,
        "required": [
          "characterId",
          "memberships"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character these memberships belong to"
          },
          "memberships": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CharacterMembershipEntry"
            },
            "description": "All faction memberships for the character"
          }
        }
      },
      "ListNormsRequest": {
        "type": "object",
        "description": "Request to list norms defined by a faction",
        "additionalProperties": false,
        "required": [
          "factionId"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction to list norms for"
          },
          "severity": {
            "$ref": "#/components/schemas/NormSeverity",
            "nullable": true,
            "description": "Filter by severity level"
          },
          "scope": {
            "$ref": "#/components/schemas/NormScope",
            "nullable": true,
            "description": "Filter by scope"
          }
        }
      },
      "ListNormsResponse": {
        "type": "object",
        "description": "List of norm definitions for a faction",
        "additionalProperties": false,
        "required": [
          "factionId",
          "norms"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction these norms belong to"
          },
          "norms": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NormDefinitionResponse"
            },
            "description": "All matching norm definitions"
          }
        }
      },
      "ListParticipantsRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list participants in a room",
        "required": [
          "roomId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID to list participants for"
          }
        }
      },
      "ListPlansRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list cached plans",
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by realm (optional)"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Maximum plans to return"
          },
          "offset": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Pagination offset"
          }
        }
      },
      "ListPlansResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "List of plans",
        "required": [
          "plans",
          "totalCount"
        ],
        "properties": {
          "plans": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PlanSummary"
            },
            "description": "Plan summaries"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total matching plans"
          }
        }
      },
      "ListPoisRequest": {
        "type": "object",
        "description": "Request to list active POIs",
        "required": [
          "accountId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account whose POIs to list"
          }
        }
      },
      "ListPoisResponse": {
        "type": "object",
        "description": "List of active POIs in a garden instance",
        "required": [
          "gardenInstanceId",
          "pois"
        ],
        "properties": {
          "gardenInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Garden instance these POIs belong to"
          },
          "pois": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PoiSummary"
            },
            "description": "Active POIs"
          }
        }
      },
      "ListQuestDefinitionsRequest": {
        "type": "object",
        "description": "Request to list quest definitions with optional filtering",
        "additionalProperties": false,
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by game service"
          },
          "category": {
            "description": "Filter by quest category",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/QuestCategory"
              }
            ]
          },
          "difficulty": {
            "description": "Filter by difficulty rating",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/QuestDifficulty"
              }
            ]
          },
          "tags": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Filter by tags (any match)"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Include deprecated definitions"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Max results"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          }
        }
      },
      "ListQuestDefinitionsResponse": {
        "type": "object",
        "description": "Paginated list of quest definitions",
        "additionalProperties": false,
        "required": [
          "definitions",
          "total"
        ],
        "properties": {
          "definitions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QuestDefinitionResponse"
            },
            "description": "List of definitions"
          },
          "total": {
            "type": "integer",
            "description": "Total count for pagination"
          }
        }
      },
      "ListQuestsRequest": {
        "type": "object",
        "description": "Request to list quests for a character with optional status filtering",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to list quests for"
          },
          "statuses": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/QuestStatus"
            },
            "description": "Filter by statuses (null for all)"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Max results"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          }
        }
      },
      "ListQuestsResponse": {
        "type": "object",
        "description": "Paginated list of quest instances",
        "additionalProperties": false,
        "required": [
          "quests",
          "total"
        ],
        "properties": {
          "quests": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QuestInstanceResponse"
            },
            "description": "Quest instances"
          },
          "total": {
            "type": "integer",
            "description": "Total count"
          }
        }
      },
      "ListQueuesRequest": {
        "type": "object",
        "description": "Request to list available matchmaking queues",
        "additionalProperties": false,
        "properties": {
          "gameId": {
            "type": "string",
            "nullable": true,
            "description": "Filter by game ID (null for all games)"
          },
          "includeDisabled": {
            "type": "boolean",
            "default": false,
            "description": "Include disabled queues in the list (admin only)"
          }
        }
      },
      "ListQueuesResponse": {
        "type": "object",
        "description": "Response containing available matchmaking queues",
        "additionalProperties": false,
        "required": [
          "queues"
        ],
        "properties": {
          "queues": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueueSummary"
            },
            "description": "List of available queues"
          }
        }
      },
      "ListRealmsRequest": {
        "description": "Request to list realms with optional filtering and pagination",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Filter by category (e.g., \"MAIN\", \"SPECIAL\", \"TEST\")"
          },
          "isActive": {
            "type": "boolean",
            "nullable": true,
            "description": "Filter by active status"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated realms in the response"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of realms to return per page"
          }
        }
      },
      "ListReferencesRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list all references to a resource",
        "required": [
          "resourceType",
          "resourceId"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource to list references for (opaque identifier)"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource to list references for"
          },
          "filterSourceType": {
            "type": "string",
            "nullable": true,
            "description": "Optional filter by source type (opaque identifier)"
          },
          "limit": {
            "type": "integer",
            "default": 100,
            "description": "Maximum references to return"
          }
        }
      },
      "ListReferencesResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response containing list of references to a resource",
        "required": [
          "resourceType",
          "resourceId",
          "references",
          "totalCount"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource listed"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource listed"
          },
          "references": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResourceReference"
            },
            "description": "List of references"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total reference count (may exceed returned list if limit applied)"
          }
        }
      },
      "ListRelationshipTypesRequest": {
        "description": "Request to list relationship types with optional filtering by category, hierarchy, and deprecation status",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Filter by category (e.g., \"FAMILY\", \"SOCIAL\", \"ECONOMIC\") (null to include all)"
          },
          "rootsOnly": {
            "type": "boolean",
            "default": false,
            "description": "Only return types with no parent (root types)"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated types in the response"
          }
        }
      },
      "ListRelationshipsByEntityRequest": {
        "description": "Request to list all relationships for a specific entity with optional filters",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity to get relationships for"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the entity to get relationships for"
          },
          "relationshipTypeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional filter by relationship type"
          },
          "otherEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "nullable": true,
            "description": "Optional filter by the other entity's type"
          },
          "includeEnded": {
            "type": "boolean",
            "default": false,
            "description": "Include relationships that have ended"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for paginated results (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page (max 100)"
          }
        }
      },
      "ListRelationshipsByTypeRequest": {
        "description": "Request to list all relationships of a specific relationship type",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "relationshipTypeId"
        ],
        "properties": {
          "relationshipTypeId": {
            "type": "string",
            "format": "uuid",
            "description": "Relationship type to filter by"
          },
          "entity1Type": {
            "$ref": "#/components/schemas/EntityType",
            "nullable": true,
            "description": "Optional filter by entity1 type"
          },
          "entity2Type": {
            "$ref": "#/components/schemas/EntityType",
            "nullable": true,
            "description": "Optional filter by entity2 type"
          },
          "includeEnded": {
            "type": "boolean",
            "default": false,
            "description": "Include relationships that have ended"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for paginated results (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page (max 100)"
          }
        }
      },
      "ListRepositoryBindingsRequest": {
        "description": "Request to list all repository bindings with optional filtering",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "status": {
            "$ref": "#/components/schemas/BindingStatus",
            "description": "Filter by binding status"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "minimum": 1,
            "maximum": 100,
            "description": "Maximum number of bindings to return"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "minimum": 0,
            "description": "Number of bindings to skip"
          }
        }
      },
      "ListRepositoryBindingsResponse": {
        "description": "Response containing a list of repository bindings",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bindings",
          "total"
        ],
        "properties": {
          "bindings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RepositoryBindingInfo"
            },
            "description": "List of repository bindings"
          },
          "total": {
            "type": "integer",
            "description": "Total number of bindings matching filter"
          }
        }
      },
      "ListRoomTypesRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list room types with optional filters and pagination",
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by game service scope"
          },
          "messageFormat": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MessageFormat"
              }
            ],
            "nullable": true,
            "description": "Filter by message format"
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RoomTypeStatus"
              }
            ],
            "nullable": true,
            "description": "Filter by status"
          },
          "page": {
            "type": "integer",
            "default": 0,
            "description": "Page number (zero-based)"
          },
          "pageSize": {
            "type": "integer",
            "default": 20,
            "description": "Number of items per page"
          }
        }
      },
      "ListRoomTypesResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Paginated list of room type definitions",
        "required": [
          "items",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "items": {
            "type": "array",
            "description": "Room type definitions matching the filter",
            "items": {
              "$ref": "#/components/schemas/RoomTypeResponse"
            }
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching room types"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Items per page"
          }
        }
      },
      "ListRoomsRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list rooms with optional filters and pagination",
        "properties": {
          "roomTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Filter by room type code"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by Connect session ID"
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChatRoomStatus"
              }
            ],
            "nullable": true,
            "description": "Filter by room status"
          },
          "page": {
            "type": "integer",
            "default": 0,
            "description": "Page number (zero-based)"
          },
          "pageSize": {
            "type": "integer",
            "default": 20,
            "description": "Number of items per page"
          }
        }
      },
      "ListRoomsResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Paginated list of chat rooms",
        "required": [
          "items",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "items": {
            "type": "array",
            "description": "Rooms matching the filter",
            "items": {
              "$ref": "#/components/schemas/ChatRoomResponse"
            }
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching rooms"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Items per page"
          }
        }
      },
      "ListRootLocationsRequest": {
        "description": "Request to list all top-level locations (without parents) in a realm",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm ID to get root locations for"
          },
          "locationType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LocationType"
              }
            ],
            "nullable": true,
            "description": "Optional filter by location type"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated locations in the response"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "ListScenarioDefinitionsRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list scenario definitions",
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by realm"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by game service"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by tags (OR logic)"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Include deprecated scenarios"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Maximum scenarios to return"
          },
          "offset": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Pagination offset"
          }
        }
      },
      "ListScenarioDefinitionsResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "List of scenario definitions",
        "required": [
          "scenarios",
          "totalCount"
        ],
        "properties": {
          "scenarios": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScenarioDefinitionSummary"
            },
            "description": "Scenario definition summaries"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total matching scenarios"
          }
        }
      },
      "ListScenesRequest": {
        "type": "object",
        "description": "Request to list scenes with optional filters",
        "properties": {
          "gameId": {
            "type": "string",
            "nullable": true,
            "description": "Filter by game ID"
          },
          "sceneType": {
            "$ref": "#/components/schemas/SceneType",
            "nullable": true,
            "description": "Filter by single scene type"
          },
          "sceneTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SceneType"
            },
            "nullable": true,
            "description": "Filter by multiple scene types (OR)"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by tags (scenes must have ALL specified tags)"
          },
          "nameContains": {
            "type": "string",
            "nullable": true,
            "description": "Filter by name containing this substring (case-insensitive)"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "minimum": 0,
            "description": "Pagination offset"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "minimum": 1,
            "maximum": 200,
            "description": "Maximum results to return"
          }
        }
      },
      "ListScenesResponse": {
        "type": "object",
        "description": "Response containing scene list and pagination info",
        "required": [
          "scenes",
          "total"
        ],
        "properties": {
          "scenes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SceneSummary"
            },
            "description": "List of scene summaries (not full documents)"
          },
          "total": {
            "type": "integer",
            "description": "Total number of matching scenes"
          },
          "offset": {
            "type": "integer",
            "description": "Current offset"
          },
          "limit": {
            "type": "integer",
            "description": "Applied limit"
          }
        }
      },
      "ListSchemasRequest": {
        "type": "object",
        "description": "Request to list all registered schemas for a namespace",
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Schema namespace to list"
          }
        }
      },
      "ListSchemasResponse": {
        "type": "object",
        "description": "List of registered schemas with latest version indicator",
        "required": [
          "schemas"
        ],
        "properties": {
          "schemas": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SchemaResponse"
            },
            "description": "Registered schemas"
          },
          "latestVersion": {
            "type": "string",
            "nullable": true,
            "description": "Latest schema version"
          }
        }
      },
      "ListSeedTypesRequest": {
        "type": "object",
        "description": "Request to list seed types, optionally filtered by game service.",
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game service to filter seed types for. Null returns cross-game types."
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated seed types in the response."
          }
        }
      },
      "ListSeedTypesResponse": {
        "type": "object",
        "description": "List of registered seed types.",
        "required": [
          "seedTypes"
        ],
        "properties": {
          "seedTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SeedTypeResponse"
            },
            "description": "Registered seed types."
          }
        }
      },
      "ListSeedsRequest": {
        "type": "object",
        "description": "Request to list seeds with optional filters.",
        "properties": {
          "seedTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Filter by seed type."
          },
          "ownerType": {
            "type": "string",
            "nullable": true,
            "description": "Filter by owner type."
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by game service."
          },
          "growthPhase": {
            "type": "string",
            "nullable": true,
            "description": "Filter by current growth phase code."
          },
          "status": {
            "$ref": "#/components/schemas/SeedStatus",
            "nullable": true,
            "description": "Filter by seed status."
          },
          "page": {
            "type": "integer",
            "description": "Page number (1-based).",
            "default": 1
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page.",
            "default": 50
          }
        }
      },
      "ListSeedsResponse": {
        "type": "object",
        "description": "Paginated list of seeds.",
        "required": [
          "seeds",
          "totalCount"
        ],
        "properties": {
          "seeds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SeedResponse"
            },
            "description": "Seeds matching the query."
          },
          "totalCount": {
            "type": "integer",
            "description": "Total matching seeds across all pages."
          }
        }
      },
      "ListServicesRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to list all game services with optional pagination",
        "properties": {
          "activeOnly": {
            "type": "boolean",
            "default": false,
            "description": "If true, only return active services"
          },
          "skip": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Number of services to skip for pagination (offset)"
          },
          "take": {
            "type": "integer",
            "minimum": 1,
            "maximum": 200,
            "default": 50,
            "description": "Maximum number of services to return (limit)"
          }
        }
      },
      "ListServicesResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response containing list of game services",
        "required": [
          "services",
          "totalCount"
        ],
        "properties": {
          "services": {
            "type": "array",
            "description": "List of game services matching the request criteria",
            "items": {
              "$ref": "#/components/schemas/ServiceInfo"
            }
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of services matching the filter"
          }
        }
      },
      "ListSlotsRequest": {
        "type": "object",
        "description": "Request to list all save slots belonging to a specific owner",
        "required": [
          "gameId",
          "ownerId",
          "ownerType"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "minLength": 1,
            "maxLength": 32,
            "pattern": "^[a-z][a-z0-9-]*$",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns the save slots to list"
          },
          "category": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SaveCategory"
              }
            ],
            "nullable": true,
            "description": "Optional filter by save category"
          },
          "includeVersionCount": {
            "type": "boolean",
            "default": true,
            "description": "Include version count in response"
          }
        }
      },
      "ListSlotsResponse": {
        "type": "object",
        "description": "Response containing a list of save slots for an owner",
        "required": [
          "slots"
        ],
        "properties": {
          "slots": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SlotResponse"
            },
            "description": "List of slots"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of slots for owner"
          }
        }
      },
      "ListSortField": {
        "type": "string",
        "enum": [
          "created_at",
          "updated_at",
          "title"
        ],
        "default": "updated_at",
        "description": "Fields available for sorting document lists"
      },
      "ListSpeciesByRealmRequest": {
        "description": "Request to list species available within a specific realm",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the realm to filter by"
          },
          "isPlayable": {
            "type": "boolean",
            "nullable": true,
            "description": "Filter by playable status"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of items per page"
          }
        }
      },
      "ListSpeciesRequest": {
        "description": "Request to list species with optional filtering and pagination",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Filter by category (e.g., \"HUMANOID\", \"BEAST\", \"MAGICAL\")"
          },
          "isPlayable": {
            "type": "boolean",
            "nullable": true,
            "description": "Filter by playable status"
          },
          "includeDeprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include deprecated species in the response"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of items per page"
          }
        }
      },
      "ListStatusTemplatesRequest": {
        "type": "object",
        "description": "Request to list status templates with filtering and pagination",
        "additionalProperties": false,
        "required": [
          "gameServiceId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Filter by game service"
          },
          "category": {
            "nullable": true,
            "description": "Optional filter by status category",
            "allOf": [
              {
                "$ref": "#/components/schemas/StatusCategory"
              }
            ]
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number (one-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 50,
            "description": "Number of items per page"
          }
        }
      },
      "ListStatusTemplatesResponse": {
        "type": "object",
        "description": "Paginated list of status templates",
        "additionalProperties": false,
        "required": [
          "templates",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StatusTemplateResponse"
            },
            "description": "Status templates in this page"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of templates matching the filter"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of items per page"
          }
        }
      },
      "ListStatusesRequest": {
        "type": "object",
        "description": "Request to list active statuses for an entity",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity to list statuses for"
          },
          "entityType": {
            "type": "string",
            "description": "Entity type discriminator"
          },
          "category": {
            "nullable": true,
            "description": "Optional filter by status category",
            "allOf": [
              {
                "$ref": "#/components/schemas/StatusCategory"
              }
            ]
          },
          "includePassive": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include seed-derived passive effects in results. Defaults to false because ListStatuses is typically used for UI display of item-based status effects only. Use GetEffects for unified queries that include seed-derived capabilities."
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number (one-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 50,
            "description": "Number of items per page"
          }
        }
      },
      "ListStatusesResponse": {
        "type": "object",
        "description": "Paginated list of active status effects",
        "additionalProperties": false,
        "required": [
          "statuses",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "statuses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StatusEffectSummary"
            },
            "description": "Active status effects (item-based and optionally seed-derived)"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of effects matching the filter"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of items per page"
          }
        }
      },
      "ListStylesRequest": {
        "description": "Request to list available styles",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Filter by category (e.g., \"folk\", \"classical\", \"jazz\")"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 50,
            "description": "Maximum number of styles to return"
          },
          "offset": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Pagination offset"
          }
        }
      },
      "ListStylesResponse": {
        "description": "Response containing a list of styles",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "styles",
          "total"
        ],
        "properties": {
          "styles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StyleSummary"
            },
            "description": "Style summaries"
          },
          "total": {
            "type": "integer",
            "description": "Total number of styles matching filter"
          }
        }
      },
      "ListTemplatesRequest": {
        "type": "object",
        "description": "Request to list templates with optional filters",
        "properties": {
          "category": {
            "$ref": "#/components/schemas/ScenarioCategory",
            "nullable": true,
            "description": "Filter by category"
          },
          "connectivityMode": {
            "$ref": "#/components/schemas/ConnectivityMode",
            "nullable": true,
            "description": "Filter by connectivity mode"
          },
          "deploymentPhase": {
            "$ref": "#/components/schemas/DeploymentPhase",
            "nullable": true,
            "description": "Filter by deployment phase availability"
          },
          "status": {
            "$ref": "#/components/schemas/TemplateStatus",
            "nullable": true,
            "description": "Filter by template status"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "description": "Page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "default": 50,
            "description": "Items per page"
          }
        }
      },
      "ListTemplatesResponse": {
        "type": "object",
        "description": "Paginated list of scenario templates",
        "required": [
          "templates",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScenarioTemplateResponse"
            },
            "description": "Templates on this page"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching templates"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Items per page"
          }
        }
      },
      "ListTerritoryClaimsRequest": {
        "type": "object",
        "description": "Request to list territory claims for a faction",
        "additionalProperties": false,
        "required": [
          "factionId"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction to list claims for"
          },
          "status": {
            "$ref": "#/components/schemas/TerritoryClaimStatus",
            "nullable": true,
            "description": "Filter by claim status"
          },
          "cursor": {
            "type": "string",
            "nullable": true,
            "maxLength": 512,
            "description": "Pagination cursor from a previous response"
          },
          "pageSize": {
            "type": "integer",
            "default": 20,
            "minimum": 1,
            "maximum": 100,
            "description": "Number of claims to return per page"
          }
        }
      },
      "ListTerritoryClaimsResponse": {
        "type": "object",
        "description": "Paginated list of territory claims",
        "additionalProperties": false,
        "required": [
          "claims",
          "hasMore"
        ],
        "properties": {
          "claims": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TerritoryClaimResponse"
            },
            "description": "Territory claims for this page"
          },
          "nextCursor": {
            "type": "string",
            "nullable": true,
            "maxLength": 512,
            "description": "Cursor for the next page (null if no more pages)"
          },
          "hasMore": {
            "type": "boolean",
            "description": "Whether more pages are available"
          }
        }
      },
      "ListUnlockedAchievementsRequest": {
        "type": "object",
        "description": "Request to list unlocked achievements",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "entityId",
          "entityType"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type whose unlocked achievements are listed"
          },
          "platform": {
            "$ref": "#/components/schemas/Platform",
            "nullable": true,
            "description": "Filter by platform"
          }
        }
      },
      "ListUnlockedAchievementsResponse": {
        "type": "object",
        "description": "Response containing unlocked achievements",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "achievements",
          "totalPoints"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type for the returned unlocked achievements"
          },
          "achievements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UnlockedAchievement"
            },
            "description": "List of unlocked achievements"
          },
          "totalPoints": {
            "type": "integer",
            "description": "Total points earned"
          }
        }
      },
      "ListVersionsRequest": {
        "description": "Request to list all versions of an asset with pagination",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "assetId"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Asset identifier to list versions for"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Maximum number of versions to return"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Number of versions to skip for pagination"
          }
        }
      },
      "ListVersionsResponse": {
        "type": "object",
        "description": "Paginated list of save versions within a slot",
        "required": [
          "versions",
          "totalCount"
        ],
        "properties": {
          "versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VersionResponse"
            },
            "description": "List of versions"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total version count in slot"
          }
        }
      },
      "LoadRequest": {
        "type": "object",
        "description": "Request to load save data from a specific slot and version",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "minLength": 1,
            "maxLength": 32,
            "pattern": "^[a-z][a-z0-9-]*$",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          },
          "versionNumber": {
            "type": "integer",
            "nullable": true,
            "description": "Specific version to load (defaults to latest)"
          },
          "checkpointName": {
            "type": "string",
            "nullable": true,
            "description": "Load by checkpoint name instead of version number"
          },
          "includeMetadata": {
            "type": "boolean",
            "default": true,
            "description": "Include version metadata in response"
          }
        }
      },
      "LoadResponse": {
        "type": "object",
        "description": "Response containing loaded save data with integrity verification",
        "required": [
          "slotId",
          "versionNumber",
          "data",
          "contentHash"
        ],
        "properties": {
          "slotId": {
            "type": "string",
            "format": "uuid",
            "description": "Slot identifier"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Version number loaded"
          },
          "data": {
            "type": "string",
            "format": "byte",
            "description": "Base64-encoded save data (decompressed)"
          },
          "contentHash": {
            "type": "string",
            "description": "SHA-256 hash for integrity verification"
          },
          "schemaVersion": {
            "type": "string",
            "nullable": true,
            "description": "Schema version of this save"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable name"
          },
          "pinned": {
            "type": "boolean",
            "description": "Whether this version is pinned"
          },
          "checkpointName": {
            "type": "string",
            "nullable": true,
            "description": "Checkpoint name if pinned"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Save timestamp"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom metadata"
          }
        }
      },
      "Location": {
        "type": "object",
        "additionalProperties": false,
        "description": "Character location information including current position, region, and 3D coordinates",
        "properties": {
          "current": {
            "type": "string",
            "nullable": true,
            "description": "Current location name or identifier"
          },
          "region": {
            "type": "string",
            "nullable": true,
            "description": "Region or zone the character is in"
          },
          "coordinates": {
            "$ref": "#/components/schemas/Coordinates",
            "nullable": true,
            "description": "3D spatial coordinates of the character's position in the game world"
          }
        }
      },
      "LocationExistsRequest": {
        "description": "Request to check if a location exists and is active",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "locationId"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the location to validate"
          }
        }
      },
      "LocationExistsResponse": {
        "description": "Response indicating whether a location exists and its active status",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "exists",
          "isActive"
        ],
        "properties": {
          "exists": {
            "type": "boolean",
            "description": "Whether the location exists"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether the location is active (false if deprecated or not found)"
          },
          "locationId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "The location ID if found"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "The realm ID if location found"
          }
        }
      },
      "LocationListResponse": {
        "description": "Paginated list of locations with metadata for navigation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "locations",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "locations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LocationResponse"
            },
            "description": "List of locations matching the query"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of locations matching the query (across all pages)"
          },
          "page": {
            "type": "integer",
            "description": "Current page number (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether there are more pages after the current page"
          },
          "hasPreviousPage": {
            "type": "boolean",
            "description": "Whether there are pages before the current page"
          }
        }
      },
      "LocationResponse": {
        "description": "Complete location data returned from API operations",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "locationId",
          "realmId",
          "code",
          "name",
          "locationType",
          "depth",
          "isDeprecated",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the location"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm this location belongs to"
          },
          "code": {
            "type": "string",
            "description": "Unique code for the location within its realm"
          },
          "name": {
            "type": "string",
            "description": "Display name of the location"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Optional description of the location"
          },
          "locationType": {
            "$ref": "#/components/schemas/LocationType",
            "description": "Type classification of the location"
          },
          "parentLocationId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Parent location ID (null for root locations)"
          },
          "depth": {
            "type": "integer",
            "description": "Depth in hierarchy (0 for root locations)"
          },
          "isDeprecated": {
            "type": "boolean",
            "description": "Whether this location is deprecated and cannot be used"
          },
          "deprecatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Timestamp when this location was deprecated"
          },
          "deprecationReason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for deprecation"
          },
          "bounds": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BoundingBox3D"
              }
            ],
            "nullable": true,
            "description": "Optional spatial extent in world coordinates"
          },
          "boundsPrecision": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BoundsPrecision"
              }
            ],
            "description": "Precision level of spatial bounds"
          },
          "coordinateMode": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CoordinateMode"
              }
            ],
            "description": "How this location's coordinate system relates to its parent"
          },
          "localOrigin": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Position3D"
              }
            ],
            "nullable": true,
            "description": "Origin point for local or inherited coordinate systems"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional metadata for the location (JSON)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the location was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the location was last updated"
          }
        }
      },
      "LocationType": {
        "type": "string",
        "description": "Type classification for locations",
        "enum": [
          "CONTINENT",
          "REGION",
          "CITY",
          "DISTRICT",
          "BUILDING",
          "ROOM",
          "LANDMARK",
          "WILDERNESS",
          "DUNGEON",
          "OTHER"
        ]
      },
      "LockContractRequest": {
        "type": "object",
        "description": "Request to lock a contract under guardian custody",
        "additionalProperties": false,
        "required": [
          "contractInstanceId",
          "guardianId",
          "guardianType"
        ],
        "properties": {
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID to lock"
          },
          "guardianId": {
            "type": "string",
            "format": "uuid",
            "description": "Guardian entity ID (e.g., escrow agreement ID)"
          },
          "guardianType": {
            "type": "string",
            "maxLength": 64,
            "description": "Guardian entity type (e.g., \"escrow\")"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Optional idempotency key for the operation"
          }
        }
      },
      "LockContractResponse": {
        "type": "object",
        "description": "Response from locking a contract",
        "additionalProperties": false,
        "required": [
          "locked",
          "contractId"
        ],
        "properties": {
          "locked": {
            "type": "boolean",
            "description": "Whether the contract was locked"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "guardianId": {
            "type": "string",
            "format": "uuid",
            "description": "Guardian entity ID"
          },
          "lockedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the contract was locked"
          }
        }
      },
      "LoginRequest": {
        "description": "Request to authenticate a user with email and password credentials",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "email",
          "password"
        ],
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "maxLength": 254,
            "description": "Email address for authentication"
          },
          "password": {
            "type": "string",
            "format": "password",
            "description": "User password for authentication"
          },
          "rememberMe": {
            "type": "boolean",
            "default": false,
            "description": "Whether to extend the session duration for persistent login"
          },
          "deviceInfo": {
            "$ref": "#/components/schemas/DeviceInfo",
            "nullable": true,
            "description": "Information about the client device (optional)"
          }
        }
      },
      "LoginResponse": {
        "type": "object",
        "description": "Response from email/password login. May contain full tokens (no MFA) or a challenge token (MFA required).",
        "additionalProperties": false,
        "required": [
          "accountId",
          "requiresMfa"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID (always present regardless of MFA status)"
          },
          "requiresMfa": {
            "type": "boolean",
            "description": "If true, client must complete MFA via /auth/mfa/verify before receiving tokens"
          },
          "mfaChallengeToken": {
            "type": "string",
            "nullable": true,
            "description": "Short-lived challenge token for /auth/mfa/verify (only present when requiresMfa is true)"
          },
          "accessToken": {
            "type": "string",
            "nullable": true,
            "description": "JWT access token (only present when requiresMfa is false)"
          },
          "refreshToken": {
            "type": "string",
            "nullable": true,
            "description": "Refresh token (only present when requiresMfa is false)"
          },
          "expiresIn": {
            "type": "integer",
            "nullable": true,
            "description": "Seconds until access token expires (only present when requiresMfa is false)"
          },
          "connectUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "WebSocket connect URL (only present when requiresMfa is false)"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Account roles (only present when requiresMfa is false)"
          }
        }
      },
      "Logo": {
        "description": "Site logo configuration including image URL and accessibility text",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "url": {
            "type": "string",
            "format": "uri",
            "description": "URL of the site logo image"
          },
          "alt": {
            "type": "string",
            "description": "Alt text for the logo image"
          }
        }
      },
      "LogoutRequest": {
        "description": "Request to logout and invalidate authentication tokens",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "allSessions": {
            "type": "boolean",
            "default": false,
            "description": "Logout from all sessions/devices"
          }
        }
      },
      "MapDefinition": {
        "type": "object",
        "description": "A map definition template that describes the structure of a region",
        "required": [
          "definitionId",
          "name",
          "createdAt"
        ],
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this definition"
          },
          "name": {
            "type": "string",
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "description": "Description of the map template",
            "nullable": true
          },
          "layers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LayerDefinition"
            },
            "description": "Layer configurations for this map",
            "nullable": true
          },
          "defaultBounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Default bounds for regions using this definition",
            "nullable": true
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "description": "Additional metadata (schema-less)",
            "nullable": true
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the definition was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the definition was last updated",
            "nullable": true
          }
        }
      },
      "MapKind": {
        "type": "string",
        "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
        "enum": [
          "terrain",
          "static_geometry",
          "navigation",
          "resources",
          "spawn_points",
          "points_of_interest",
          "dynamic_objects",
          "hazards",
          "weather_effects",
          "ownership",
          "combat_effects",
          "visual_effects"
        ]
      },
      "MapObject": {
        "type": "object",
        "description": "A stored map object with full metadata",
        "required": [
          "objectId",
          "regionId",
          "kind",
          "objectType",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "objectId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this object"
          },
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region this object belongs to"
          },
          "kind": {
            "$ref": "#/components/schemas/MapKind",
            "description": "Map kind this object is stored under"
          },
          "objectType": {
            "type": "string",
            "description": "Publisher-defined type"
          },
          "position": {
            "$ref": "#/components/schemas/Position3D",
            "description": "Position for point objects",
            "nullable": true
          },
          "bounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Bounding box for area objects",
            "nullable": true
          },
          "data": {
            "type": "object",
            "additionalProperties": true,
            "description": "Schema-less object data (publisher-defined)",
            "nullable": true
          },
          "version": {
            "type": "integer",
            "format": "int64",
            "description": "Monotonic version for ordering"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the object was first created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the object was last updated"
          }
        }
      },
      "MarkerType": {
        "type": "string",
        "description": "Types of marker nodes for spawn points, waypoints, and other positional markers.",
        "enum": [
          "generic",
          "spawn_point",
          "npc_spawn",
          "waypoint",
          "camera_point",
          "light_point",
          "audio_point",
          "trigger_point"
        ]
      },
      "MatchesHierarchyRequest": {
        "description": "Request to check if a relationship type matches or descends from an ancestor type in the hierarchy",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "typeId",
          "ancestorTypeId"
        ],
        "properties": {
          "typeId": {
            "type": "string",
            "format": "uuid",
            "description": "The relationship type to check"
          },
          "ancestorTypeId": {
            "type": "string",
            "format": "uuid",
            "description": "The potential ancestor type"
          }
        }
      },
      "MatchesHierarchyResponse": {
        "description": "Response indicating whether a type matches an ancestor in the hierarchy and the depth between them",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "matches"
        ],
        "properties": {
          "matches": {
            "type": "boolean",
            "description": "True if typeId equals or descends from ancestorTypeId"
          },
          "depth": {
            "type": "integer",
            "description": "Number of levels between the types (0 if same, -1 if no match)"
          }
        }
      },
      "MatchmakingStatsResponse": {
        "type": "object",
        "description": "Matchmaking operational statistics",
        "additionalProperties": false,
        "required": [
          "timestamp",
          "queueStats"
        ],
        "properties": {
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When these stats were collected"
          },
          "queueStats": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueueStats"
            },
            "description": "Statistics per queue"
          }
        }
      },
      "MatchmakingStatusResponse": {
        "type": "object",
        "description": "Current matchmaking status for a ticket",
        "additionalProperties": false,
        "required": [
          "ticketId",
          "queueId",
          "status",
          "intervalsElapsed",
          "createdAt"
        ],
        "properties": {
          "ticketId": {
            "type": "string",
            "format": "uuid",
            "description": "Ticket identifier"
          },
          "queueId": {
            "type": "string",
            "description": "Queue the ticket is in"
          },
          "status": {
            "$ref": "#/components/schemas/TicketStatus",
            "description": "Current ticket status"
          },
          "intervalsElapsed": {
            "type": "integer",
            "description": "Number of processing intervals elapsed"
          },
          "currentSkillRange": {
            "type": "integer",
            "nullable": true,
            "description": "Current skill matching range (null if skill not used)"
          },
          "estimatedWaitSeconds": {
            "type": "integer",
            "nullable": true,
            "description": "Updated estimated wait time"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the ticket was created"
          },
          "matchId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Match ID if a match has been found"
          }
        }
      },
      "MelodyAnalysis": {
        "description": "Analysis of a melody",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "range": {
            "$ref": "#/components/schemas/PitchRange",
            "nullable": true,
            "description": "Pitch range used"
          },
          "intervalDistribution": {
            "type": "object",
            "additionalProperties": {
              "type": "number",
              "format": "float"
            },
            "nullable": true,
            "description": "Distribution of interval sizes"
          },
          "contour": {
            "type": "string",
            "nullable": true,
            "description": "Detected contour shape"
          },
          "noteCount": {
            "type": "integer",
            "description": "Total number of notes"
          },
          "averageNoteDuration": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "description": "Average note duration in ticks"
          }
        }
      },
      "MergeStacksRequest": {
        "type": "object",
        "description": "Request to merge stacks",
        "additionalProperties": false,
        "required": [
          "sourceInstanceId",
          "targetInstanceId"
        ],
        "properties": {
          "sourceInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Stack to merge from (destroyed)"
          },
          "targetInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Stack to merge into"
          }
        }
      },
      "MergeStacksResponse": {
        "type": "object",
        "description": "Response after merging",
        "additionalProperties": false,
        "required": [
          "success",
          "targetInstanceId",
          "newQuantity",
          "sourceDestroyed"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether merge succeeded"
          },
          "targetInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Merged stack ID"
          },
          "newQuantity": {
            "type": "number",
            "format": "double",
            "description": "New quantity"
          },
          "sourceDestroyed": {
            "type": "boolean",
            "description": "Whether source was destroyed"
          },
          "overflowQuantity": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Quantity that didn't fit"
          }
        }
      },
      "MessageFormat": {
        "type": "string",
        "description": "Determines what kind of content a room accepts",
        "enum": [
          "Text",
          "Sentiment",
          "Emoji",
          "Custom"
        ]
      },
      "MessageHistoryRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to retrieve message history for a room with cursor pagination",
        "required": [
          "roomId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID to get history for"
          },
          "before": {
            "type": "string",
            "nullable": true,
            "description": "Cursor for pagination (message ID to fetch before)"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Maximum number of messages to return"
          }
        }
      },
      "MessageHistoryResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Paginated message history with cursor for next page",
        "required": [
          "messages",
          "hasMore"
        ],
        "properties": {
          "messages": {
            "type": "array",
            "description": "Messages in reverse chronological order",
            "items": {
              "$ref": "#/components/schemas/ChatMessageResponse"
            }
          },
          "hasMore": {
            "type": "boolean",
            "description": "Whether more messages exist before the returned set"
          },
          "nextCursor": {
            "type": "string",
            "nullable": true,
            "description": "Cursor for fetching the next page"
          }
        }
      },
      "MetadataType": {
        "type": "string",
        "description": "Type of metadata to update",
        "enum": [
          "instance_data",
          "runtime_state"
        ]
      },
      "MfaDisableRequest": {
        "type": "object",
        "description": "Request to disable MFA. Exactly one of totpCode or recoveryCode must be provided.",
        "additionalProperties": false,
        "properties": {
          "totpCode": {
            "type": "string",
            "nullable": true,
            "minLength": 6,
            "maxLength": 6,
            "pattern": "^\\d{6}$",
            "description": "Current 6-digit TOTP code from authenticator app"
          },
          "recoveryCode": {
            "type": "string",
            "nullable": true,
            "description": "Single-use recovery code (format xxxx-xxxx)"
          }
        }
      },
      "MfaEnableRequest": {
        "type": "object",
        "description": "Request to confirm MFA setup with a valid TOTP code proving authenticator is configured",
        "additionalProperties": false,
        "required": [
          "setupToken",
          "totpCode"
        ],
        "properties": {
          "setupToken": {
            "type": "string",
            "description": "Setup token from /auth/mfa/setup response"
          },
          "totpCode": {
            "type": "string",
            "minLength": 6,
            "maxLength": 6,
            "pattern": "^\\d{6}$",
            "description": "6-digit TOTP code from authenticator app"
          }
        }
      },
      "MfaSetupResponse": {
        "type": "object",
        "description": "MFA setup data containing TOTP URI for QR code and recovery codes",
        "additionalProperties": false,
        "required": [
          "setupToken",
          "totpUri",
          "recoveryCodes"
        ],
        "properties": {
          "setupToken": {
            "type": "string",
            "description": "Token to pass to /auth/mfa/enable to confirm setup"
          },
          "totpUri": {
            "type": "string",
            "description": "otpauth:// URI for authenticator app QR code scanning"
          },
          "recoveryCodes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "10 single-use recovery codes (shown only once, user must save them)"
          }
        }
      },
      "MfaVerifyRequest": {
        "type": "object",
        "description": "Request to verify MFA during login. Exactly one of totpCode or recoveryCode must be provided.",
        "additionalProperties": false,
        "required": [
          "challengeToken"
        ],
        "properties": {
          "challengeToken": {
            "type": "string",
            "description": "Challenge token from LoginResponse when requiresMfa was true"
          },
          "totpCode": {
            "type": "string",
            "nullable": true,
            "minLength": 6,
            "maxLength": 6,
            "pattern": "^\\d{6}$",
            "description": "6-digit TOTP code from authenticator app"
          },
          "recoveryCode": {
            "type": "string",
            "nullable": true,
            "description": "Single-use recovery code (format xxxx-xxxx)"
          }
        }
      },
      "MidiEvent": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.MidiEvent",
        "description": "A single MIDI event",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "tick",
          "type"
        ],
        "properties": {
          "tick": {
            "type": "integer",
            "minimum": 0,
            "description": "Absolute tick position"
          },
          "type": {
            "$ref": "#/components/schemas/MidiEventType",
            "description": "Event type"
          },
          "note": {
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "nullable": true,
            "description": "MIDI note number (for note events)"
          },
          "velocity": {
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "nullable": true,
            "description": "Note velocity (for note events)"
          },
          "duration": {
            "type": "integer",
            "minimum": 1,
            "nullable": true,
            "description": "Note duration in ticks (for noteOn with implicit noteOff)"
          },
          "program": {
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "nullable": true,
            "description": "Program number (for programChange)"
          },
          "controller": {
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "nullable": true,
            "description": "Controller number (for controlChange)"
          },
          "value": {
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "nullable": true,
            "description": "Controller value (for controlChange)"
          }
        }
      },
      "MidiEventType": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.MidiEventType",
        "description": "MIDI event type",
        "type": "string",
        "enum": [
          "NoteOn",
          "NoteOff",
          "ProgramChange",
          "ControlChange"
        ]
      },
      "MidiHeader": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.MidiHeader",
        "description": "MIDI file header information",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "format": {
            "type": "integer",
            "minimum": 0,
            "maximum": 2,
            "default": 1,
            "description": "MIDI format type (0, 1, or 2)"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "Composition name"
          },
          "tempos": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TempoEvent"
            },
            "nullable": true,
            "description": "Tempo changes"
          },
          "timeSignatures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TimeSignatureEvent"
            },
            "nullable": true,
            "description": "Time signature changes"
          },
          "keySignatures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KeySignatureEvent"
            },
            "nullable": true,
            "description": "Key signature changes"
          }
        }
      },
      "MidiJson": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.MidiJson",
        "description": "MIDI-JSON format representation of a musical piece",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "tracks",
          "ticksPerBeat"
        ],
        "properties": {
          "header": {
            "$ref": "#/components/schemas/MidiHeader",
            "nullable": true,
            "description": "MIDI header information"
          },
          "ticksPerBeat": {
            "type": "integer",
            "minimum": 24,
            "maximum": 960,
            "default": 480,
            "description": "Ticks per beat (PPQN)"
          },
          "tracks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MidiTrack"
            },
            "description": "MIDI tracks"
          }
        }
      },
      "MidiTrack": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.MidiTrack",
        "description": "A single MIDI track containing events",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "events"
        ],
        "properties": {
          "name": {
            "type": "string",
            "nullable": true,
            "description": "Track name"
          },
          "channel": {
            "type": "integer",
            "minimum": 0,
            "maximum": 15,
            "default": 0,
            "description": "MIDI channel"
          },
          "instrument": {
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "nullable": true,
            "description": "GM instrument number"
          },
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MidiEvent"
            },
            "description": "Track events"
          }
        }
      },
      "MigrateSaveRequest": {
        "type": "object",
        "description": "Request to migrate a save to a newer schema version",
        "required": [
          "ownerId",
          "ownerType",
          "slotName",
          "targetSchemaVersion"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Specific version to migrate (defaults to latest)"
          },
          "targetSchemaVersion": {
            "type": "string",
            "description": "Target schema version to migrate to"
          },
          "dryRun": {
            "type": "boolean",
            "default": false,
            "description": "Validate migration without saving"
          }
        }
      },
      "MigrateSaveResponse": {
        "type": "object",
        "description": "Result of a schema migration operation with version path details",
        "required": [
          "success",
          "fromSchemaVersion",
          "toSchemaVersion"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether migration succeeded"
          },
          "fromSchemaVersion": {
            "type": "string",
            "description": "Original schema version"
          },
          "toSchemaVersion": {
            "type": "string",
            "description": "Target schema version"
          },
          "newVersionNumber": {
            "type": "integer",
            "nullable": true,
            "description": "New version number (null if dry run)"
          },
          "migrationPath": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Migration path applied (list of versions)"
          },
          "warnings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Non-fatal migration warnings"
          }
        }
      },
      "MilestoneDeadlineBehavior": {
        "type": "string",
        "description": "Behavior when optional milestone deadline passes",
        "enum": [
          "skip",
          "warn",
          "breach"
        ]
      },
      "MilestoneDefinition": {
        "type": "object",
        "description": "Milestone definition in a template",
        "additionalProperties": false,
        "required": [
          "code",
          "name",
          "sequence",
          "required"
        ],
        "properties": {
          "code": {
            "type": "string",
            "maxLength": 64,
            "description": "Unique milestone code within template"
          },
          "name": {
            "type": "string",
            "maxLength": 200,
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "maxLength": 1000,
            "nullable": true,
            "description": "What this milestone represents"
          },
          "sequence": {
            "type": "integer",
            "minimum": 0,
            "description": "Order in the contract flow"
          },
          "required": {
            "type": "boolean",
            "description": "Whether milestone must be completed"
          },
          "deadline": {
            "type": "string",
            "nullable": true,
            "description": "Relative deadline (ISO 8601 duration)"
          },
          "deadlineBehavior": {
            "$ref": "#/components/schemas/MilestoneDeadlineBehavior",
            "nullable": true,
            "description": "Behavior when deadline passes for optional milestones (default skip). Required milestones always trigger breach."
          },
          "onComplete": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreboundApi"
            },
            "nullable": true,
            "description": "APIs to call on completion"
          },
          "onExpire": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreboundApi"
            },
            "nullable": true,
            "description": "APIs to call if deadline passes"
          }
        }
      },
      "MilestoneInstanceResponse": {
        "type": "object",
        "description": "Milestone instance status",
        "additionalProperties": false,
        "required": [
          "code",
          "name",
          "sequence",
          "required",
          "status"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Milestone code"
          },
          "name": {
            "type": "string",
            "description": "Milestone name"
          },
          "sequence": {
            "type": "integer",
            "description": "Order in flow"
          },
          "required": {
            "type": "boolean",
            "description": "Whether required"
          },
          "status": {
            "$ref": "#/components/schemas/MilestoneStatus",
            "description": "Current status"
          },
          "completedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When completed"
          },
          "failedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When failed"
          },
          "activatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this milestone became active"
          },
          "deadline": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Absolute deadline (computed from activatedAt + duration)"
          },
          "deadlineBehavior": {
            "$ref": "#/components/schemas/MilestoneDeadlineBehavior",
            "nullable": true,
            "description": "Behavior when deadline passes for optional milestones"
          }
        }
      },
      "MilestoneProgressSummary": {
        "type": "object",
        "description": "Brief milestone progress",
        "additionalProperties": false,
        "required": [
          "code",
          "status"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Milestone code"
          },
          "status": {
            "$ref": "#/components/schemas/MilestoneStatus",
            "description": "Current status"
          }
        }
      },
      "MilestoneResponse": {
        "type": "object",
        "description": "Milestone details",
        "additionalProperties": false,
        "required": [
          "contractId",
          "milestone"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "milestone": {
            "$ref": "#/components/schemas/MilestoneInstanceResponse",
            "description": "Milestone details"
          }
        }
      },
      "MilestoneStatus": {
        "type": "string",
        "description": "Current status of a milestone",
        "enum": [
          "pending",
          "active",
          "completed",
          "failed",
          "skipped"
        ]
      },
      "ModeDistribution": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Style.ModeDistribution",
        "description": "Probability distribution over musical modes",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "major": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of major mode"
          },
          "minor": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of natural minor"
          },
          "dorian": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of dorian mode"
          },
          "phrygian": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of phrygian mode"
          },
          "lydian": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of lydian mode"
          },
          "mixolydian": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of mixolydian mode"
          },
          "aeolian": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of aeolian mode"
          },
          "locrian": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Probability of locrian mode"
          }
        }
      },
      "ModeType": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Collections.ModeType",
        "description": "Musical mode/scale type",
        "type": "string",
        "enum": [
          "Major",
          "Minor",
          "Dorian",
          "Phrygian",
          "Lydian",
          "Mixolydian",
          "Aeolian",
          "Locrian",
          "HarmonicMinor",
          "MelodicMinor",
          "MajorPentatonic",
          "MinorPentatonic",
          "Blues",
          "WholeTone",
          "Chromatic"
        ]
      },
      "ModifyItemInstanceRequest": {
        "type": "object",
        "description": "Request to modify item instance state",
        "additionalProperties": false,
        "required": [
          "instanceId"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Instance ID to modify"
          },
          "durabilityDelta": {
            "type": "integer",
            "nullable": true,
            "description": "Change to durability (positive to repair, negative for damage)"
          },
          "customStats": {
            "type": "object",
            "nullable": true,
            "description": "New custom stats (merges with existing)"
          },
          "customName": {
            "type": "string",
            "maxLength": 128,
            "nullable": true,
            "description": "New custom name"
          },
          "quantityDelta": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Change to quantity (positive to add, negative to subtract). Only valid for stackable items."
          },
          "instanceMetadata": {
            "type": "object",
            "nullable": true,
            "description": "New instance metadata (merges with existing)"
          },
          "newContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Move item to a different container. Used by inventory service for item movement."
          },
          "newSlotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "New slot index within the container"
          },
          "newSlotX": {
            "type": "integer",
            "nullable": true,
            "description": "New X position for grid-based containers"
          },
          "newSlotY": {
            "type": "integer",
            "nullable": true,
            "description": "New Y position for grid-based containers"
          }
        }
      },
      "MoveItemRequest": {
        "type": "object",
        "description": "Request to move item",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "targetContainerId"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance ID to move"
          },
          "targetContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "Target container ID"
          },
          "targetSlotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Target slot"
          },
          "targetSlotX": {
            "type": "integer",
            "nullable": true,
            "description": "Target grid X"
          },
          "targetSlotY": {
            "type": "integer",
            "nullable": true,
            "description": "Target grid Y"
          },
          "rotated": {
            "type": "boolean",
            "nullable": true,
            "description": "Rotate in target"
          }
        }
      },
      "MoveItemResponse": {
        "type": "object",
        "description": "Response after moving item",
        "additionalProperties": false,
        "required": [
          "success",
          "instanceId",
          "sourceContainerId",
          "targetContainerId"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether move succeeded"
          },
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Moved item ID"
          },
          "sourceContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "Previous container"
          },
          "targetContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "New container"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "New slot"
          },
          "slotX": {
            "type": "integer",
            "nullable": true,
            "description": "New grid X"
          },
          "slotY": {
            "type": "integer",
            "nullable": true,
            "description": "New grid Y"
          }
        }
      },
      "MultipartConfig": {
        "description": "Configuration for multipart uploads of large files",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "required": {
            "type": "boolean",
            "description": "Whether multipart upload is required for this file size"
          },
          "partSize": {
            "type": "integer",
            "description": "Size of each part in bytes"
          },
          "maxParts": {
            "type": "integer",
            "description": "Maximum number of parts"
          },
          "uploadUrls": {
            "type": "array",
            "nullable": true,
            "description": "Pre-signed URLs for each part of the multipart upload",
            "items": {
              "$ref": "#/components/schemas/PartUploadInfo"
            }
          }
        }
      },
      "MutationType": {
        "type": "string",
        "enum": [
          "PersonalityEvolve",
          "BackstoryAdd",
          "RelationshipCreate",
          "RelationshipEnd",
          "Custom"
        ],
        "description": "Types of state mutations a scenario can apply.\nPersonalityEvolve: Apply experience to evolve personality traits\nBackstoryAdd: Add backstory element to character history\nRelationshipCreate: Create relationship between entities\nRelationshipEnd: End existing relationship\nCustom: Custom mutation (not executed server-side)\n"
      },
      "MuteParticipantRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to mute a participant in a room",
        "required": [
          "roomId",
          "targetSessionId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID"
          },
          "targetSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Session ID of participant to mute"
          },
          "durationMinutes": {
            "type": "integer",
            "nullable": true,
            "description": "Mute duration in minutes (null for permanent)"
          }
        }
      },
      "NarrativeEffect": {
        "x-sdk-type": "BeyondImmersion.Bannou.StorylineStoryteller.Actions.NarrativeEffect",
        "type": "object",
        "additionalProperties": false,
        "description": "Narrative effect on the emotional arc (SDK type)",
        "properties": {
          "primarySpectrumDelta": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Delta to apply to the primary spectrum"
          },
          "secondarySpectrumDelta": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Delta to apply to the secondary spectrum"
          },
          "positionAdvance": {
            "type": "string",
            "nullable": true,
            "description": "Position advance type (micro, standard, macro)"
          }
        }
      },
      "NarrativeOptions": {
        "description": "Options for narrative-driven composition using the Storyteller engine",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "templateId": {
            "type": "string",
            "nullable": true,
            "description": "Specific narrative template ID (e.g., 'journey_and_return', 'tension_and_release', 'simple_arc').\nIf not specified, template is inferred from mood or defaults to 'simple_arc'.\n"
          },
          "initialEmotion": {
            "$ref": "#/components/schemas/EmotionalStateInput",
            "nullable": true,
            "description": "Starting emotional state for the composition"
          },
          "targetEmotion": {
            "$ref": "#/components/schemas/EmotionalStateInput",
            "nullable": true,
            "description": "Target emotional state for the ending"
          },
          "tensionProfile": {
            "type": "string",
            "enum": [
              "gradual_build",
              "early_climax",
              "late_climax",
              "sustained",
              "wave"
            ],
            "nullable": true,
            "description": "Preferred tension curve shape throughout the composition"
          }
        }
      },
      "NavigationItem": {
        "description": "A navigation menu entry with optional nested children for dropdowns",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "label",
          "url",
          "order"
        ],
        "properties": {
          "label": {
            "type": "string",
            "description": "Display text for the navigation link"
          },
          "url": {
            "type": "string",
            "description": "Target URL or path for the navigation link"
          },
          "order": {
            "type": "integer",
            "description": "Sort order for the navigation item"
          },
          "target": {
            "type": "string",
            "enum": [
              "_self",
              "_blank"
            ],
            "default": "_self",
            "description": "Link target attribute for opening behavior"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NavigationItem"
            },
            "description": "Nested child navigation items for dropdowns"
          }
        }
      },
      "NearbyObject": {
        "type": "object",
        "additionalProperties": true,
        "description": "Information about a nearby object perceived by the character",
        "properties": {
          "objectId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the object"
          },
          "objectType": {
            "type": "string",
            "description": "Type of object (boulder_cluster, tree, building, etc.)"
          },
          "distance": {
            "type": "number",
            "format": "float",
            "description": "Distance from character in game units"
          },
          "direction": {
            "type": "string",
            "description": "Relative direction (north, south, east, west, above, below, etc.)"
          },
          "position": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Position3D"
              }
            ],
            "nullable": true,
            "description": "Optional absolute position"
          }
        }
      },
      "NewsItem": {
        "description": "A single news article or announcement entry",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "id",
          "title",
          "summary",
          "publishedAt"
        ],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the news item"
          },
          "title": {
            "type": "string",
            "description": "Headline of the news item"
          },
          "summary": {
            "type": "string",
            "description": "Brief summary or excerpt of the news content"
          },
          "content": {
            "type": "string",
            "nullable": true,
            "description": "Full content body of the news item"
          },
          "author": {
            "type": "string",
            "description": "Name of the news item author"
          },
          "publishedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Date and time when the news was published"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Category tags associated with the news item"
          },
          "imageUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "URL of the featured image for the news item"
          }
        }
      },
      "NewsResponse": {
        "description": "Paginated list of news items with total count",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "items",
          "total"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NewsItem"
            },
            "description": "List of news items for the current page"
          },
          "total": {
            "type": "integer",
            "description": "Total number of news items available"
          },
          "hasMore": {
            "type": "boolean",
            "description": "Whether more news items are available beyond this page"
          }
        }
      },
      "NodeType": {
        "type": "string",
        "description": "Structural node type. Indicates what kind of data the node contains,\nnot how it will be used at runtime. Consumers interpret nodes according\nto their own needs via tags and annotations.\n",
        "enum": [
          "group",
          "mesh",
          "marker",
          "volume",
          "emitter",
          "reference",
          "custom"
        ]
      },
      "NonAuthorityHandlingMode": {
        "type": "string",
        "description": "How to handle publish attempts from non-authority sources",
        "enum": [
          "reject_and_alert",
          "accept_and_alert",
          "reject_silent"
        ],
        "default": "reject_and_alert"
      },
      "NormDefinitionResponse": {
        "type": "object",
        "description": "A behavioral norm definition stored in a faction",
        "additionalProperties": false,
        "required": [
          "normId",
          "factionId",
          "violationType",
          "basePenalty",
          "severity",
          "scope",
          "createdAt"
        ],
        "properties": {
          "normId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this norm definition"
          },
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction that owns this norm"
          },
          "violationType": {
            "type": "string",
            "minLength": 1,
            "maxLength": 128,
            "description": "Violation type code mapping to lib-obligation vocabulary (e.g., \"theft\", \"deception\")"
          },
          "basePenalty": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "description": "Base GOAP cost penalty for violating this norm"
          },
          "severity": {
            "$ref": "#/components/schemas/NormSeverity",
            "description": "Enforcement intensity level"
          },
          "scope": {
            "$ref": "#/components/schemas/NormScope",
            "description": "Whether norm applies to member-only or all interactions"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "maxLength": 1024,
            "description": "Human-readable description of the norm"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this norm was defined"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this norm was last updated"
          }
        }
      },
      "NormScope": {
        "type": "string",
        "description": "Applicability scope for a behavioral norm",
        "enum": [
          "Internal",
          "External"
        ]
      },
      "NormSeverity": {
        "type": "string",
        "description": "Enforcement intensity level for a behavioral norm",
        "enum": [
          "Advisory",
          "Standard",
          "Strict"
        ]
      },
      "NoteEvent": {
        "description": "A musical note event with timing and pitch",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "pitch",
          "startTick",
          "durationTicks"
        ],
        "properties": {
          "pitch": {
            "$ref": "#/components/schemas/Pitch",
            "description": "Note pitch"
          },
          "startTick": {
            "type": "integer",
            "minimum": 0,
            "description": "Start position in ticks"
          },
          "durationTicks": {
            "type": "integer",
            "minimum": 1,
            "description": "Duration in ticks"
          },
          "velocity": {
            "type": "integer",
            "minimum": 1,
            "maximum": 127,
            "default": 80,
            "description": "Note velocity"
          }
        }
      },
      "OAuthCallbackRequest": {
        "description": "Request containing OAuth provider callback data to complete authentication",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Authorization code returned by the OAuth provider"
          },
          "state": {
            "type": "string",
            "nullable": true,
            "description": "State parameter for CSRF protection, must match the value sent in the init request"
          },
          "deviceInfo": {
            "$ref": "#/components/schemas/DeviceInfo",
            "nullable": true,
            "description": "Information about the client device (optional)"
          }
        }
      },
      "ObjectiveDefinition": {
        "type": "object",
        "description": "Definition of a single quest objective with tracking parameters",
        "additionalProperties": false,
        "required": [
          "code",
          "name",
          "objectiveType",
          "requiredCount"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Unique objective code within quest"
          },
          "name": {
            "type": "string",
            "description": "Display name of the objective"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Objective description"
          },
          "objectiveType": {
            "description": "Type of objective determining progress tracking logic",
            "$ref": "#/components/schemas/ObjectiveType"
          },
          "requiredCount": {
            "type": "integer",
            "description": "Count needed to complete"
          },
          "targetEntityType": {
            "type": "string",
            "nullable": true,
            "description": "Entity type for kill/collect objectives"
          },
          "targetEntitySubtype": {
            "type": "string",
            "nullable": true,
            "description": "Subtype filter (e.g., species:wolf)"
          },
          "targetLocationId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Location for travel/deliver objectives"
          },
          "hidden": {
            "type": "boolean",
            "default": false,
            "description": "Whether objective is hidden initially"
          },
          "revealBehavior": {
            "description": "When a hidden objective is revealed in the quest log",
            "$ref": "#/components/schemas/ObjectiveRevealBehavior"
          },
          "optional": {
            "type": "boolean",
            "default": false,
            "description": "Whether objective is optional for completion"
          }
        }
      },
      "ObjectiveProgress": {
        "type": "object",
        "description": "Current progress state of a quest objective",
        "additionalProperties": false,
        "required": [
          "code",
          "name",
          "objectiveType",
          "currentCount",
          "requiredCount",
          "isComplete",
          "progressPercent",
          "hidden",
          "optional"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Objective code"
          },
          "name": {
            "type": "string",
            "description": "Objective name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Objective description"
          },
          "objectiveType": {
            "description": "Type of objective determining progress tracking logic",
            "$ref": "#/components/schemas/ObjectiveType"
          },
          "currentCount": {
            "type": "integer",
            "description": "Current progress count"
          },
          "requiredCount": {
            "type": "integer",
            "description": "Required count"
          },
          "isComplete": {
            "type": "boolean",
            "description": "Whether complete"
          },
          "progressPercent": {
            "type": "number",
            "format": "float",
            "description": "Progress percentage (0-100)"
          },
          "hidden": {
            "type": "boolean",
            "description": "Whether currently hidden"
          },
          "optional": {
            "type": "boolean",
            "description": "Whether optional"
          }
        }
      },
      "ObjectiveProgressResponse": {
        "type": "object",
        "description": "Response with objective progress and milestone completion status",
        "additionalProperties": false,
        "required": [
          "questInstanceId",
          "objective",
          "milestoneCompleted"
        ],
        "properties": {
          "questInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Quest instance ID"
          },
          "objective": {
            "description": "Current progress state of the objective",
            "$ref": "#/components/schemas/ObjectiveProgress"
          },
          "milestoneCompleted": {
            "type": "boolean",
            "description": "Whether this progress completed the milestone"
          }
        }
      },
      "ObjectiveRevealBehavior": {
        "type": "string",
        "enum": [
          "ALWAYS",
          "ON_PROGRESS",
          "ON_COMPLETE",
          "NEVER"
        ],
        "description": "When a hidden objective is revealed in the quest log"
      },
      "ObjectiveType": {
        "type": "string",
        "enum": [
          "KILL",
          "COLLECT",
          "DELIVER",
          "TRAVEL",
          "DISCOVER",
          "TALK",
          "CRAFT",
          "ESCORT",
          "DEFEND",
          "CUSTOM"
        ],
        "description": "Type of objective determining progress tracking logic"
      },
      "ObligationArchive": {
        "type": "object",
        "x-archive-type": true,
        "description": "Complete obligation data for archive storage and storyline SDK consumption.\nInherits base archive properties from ResourceArchiveBase.\nThe characterId field equals resourceId for convenience.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/ResourceArchiveBase"
          }
        ],
        "additionalProperties": false,
        "required": [
          "characterId",
          "hasViolations",
          "violationCount"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character this data belongs to (equals resourceId)"
          },
          "hasViolations": {
            "type": "boolean",
            "description": "Whether any violation records exist"
          },
          "violationCount": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100000,
            "description": "Number of violation records in archive"
          },
          "violations": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/ViolationRecord"
            },
            "description": "Violation history records (null if hasViolations=false)"
          }
        }
      },
      "OnDeleteAction": {
        "type": "string",
        "enum": [
          "CASCADE",
          "RESTRICT",
          "DETACH"
        ],
        "description": "Action to take when the referenced resource is deleted.\nCASCADE: Delete dependent entities when resource is deleted\nRESTRICT: Block resource deletion if references exist\nDETACH: Set reference to null when resource is deleted\n"
      },
      "OwnerType": {
        "type": "string",
        "enum": [
          "ACCOUNT",
          "CHARACTER",
          "SESSION",
          "REALM"
        ],
        "description": "Type of entity that owns this save slot"
      },
      "PageContent": {
        "description": "Full content and metadata for a CMS-managed page",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "slug",
          "title",
          "content",
          "contentType",
          "published",
          "lastModified"
        ],
        "properties": {
          "slug": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "description": "URL-friendly identifier for the page"
          },
          "title": {
            "type": "string",
            "description": "Display title of the page"
          },
          "content": {
            "type": "string",
            "description": "HTML, Markdown, or custom template content"
          },
          "contentType": {
            "type": "string",
            "enum": [
              "html",
              "markdown",
              "blazor"
            ],
            "description": "Format of the page content"
          },
          "template": {
            "type": "string",
            "nullable": true,
            "description": "Template name for custom layouts"
          },
          "published": {
            "type": "boolean",
            "description": "Whether the page is publicly visible"
          },
          "publishedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Date and time when the page was published"
          },
          "lastModified": {
            "type": "string",
            "format": "date-time",
            "description": "Date and time of the last modification"
          },
          "author": {
            "type": "string",
            "nullable": true,
            "description": "Name or identifier of the page author"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "description": "Custom metadata for the page"
          },
          "seo": {
            "$ref": "#/components/schemas/SEOMetadata",
            "description": "Search engine optimization settings for the page"
          }
        }
      },
      "PageMetadata": {
        "description": "Summary metadata for a CMS page without full content",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "slug",
          "title",
          "published",
          "lastModified"
        ],
        "properties": {
          "slug": {
            "type": "string",
            "description": "URL-friendly identifier for the page"
          },
          "title": {
            "type": "string",
            "description": "Display title of the page"
          },
          "published": {
            "type": "boolean",
            "description": "Whether the page is publicly visible"
          },
          "publishedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Date and time when the page was published"
          },
          "lastModified": {
            "type": "string",
            "format": "date-time",
            "description": "Date and time of the last modification"
          },
          "author": {
            "type": "string",
            "nullable": true,
            "description": "Name or identifier of the page author"
          }
        }
      },
      "PartUploadInfo": {
        "description": "Upload information for a single part in a multipart upload",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "partNumber",
          "uploadUrl"
        ],
        "properties": {
          "partNumber": {
            "type": "integer",
            "description": "Part number (1-based)"
          },
          "uploadUrl": {
            "type": "string",
            "format": "uri",
            "description": "Pre-signed URL for uploading this part"
          },
          "minSize": {
            "type": "integer",
            "format": "int64",
            "description": "Minimum size for this part"
          },
          "maxSize": {
            "type": "integer",
            "format": "int64",
            "description": "Maximum size for this part"
          }
        }
      },
      "ParticipantInfo": {
        "type": "object",
        "additionalProperties": false,
        "description": "Details about a chat room participant",
        "required": [
          "sessionId",
          "role",
          "joinedAt",
          "isMuted"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Participant Connect session ID"
          },
          "senderType": {
            "type": "string",
            "nullable": true,
            "description": "Opaque sender type"
          },
          "senderId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Sender entity ID"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Display name"
          },
          "role": {
            "$ref": "#/components/schemas/ChatParticipantRole",
            "description": "Participant role in the room"
          },
          "joinedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the participant joined"
          },
          "isMuted": {
            "type": "boolean",
            "description": "Whether the participant is currently muted"
          }
        }
      },
      "ParticipantsResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "List of participants in a room",
        "required": [
          "roomId",
          "participants"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID"
          },
          "participants": {
            "type": "array",
            "description": "Current room participants",
            "items": {
              "$ref": "#/components/schemas/ParticipantInfo"
            }
          }
        }
      },
      "ParticipationListResponse": {
        "type": "object",
        "description": "Paginated list of participation records",
        "additionalProperties": false,
        "required": [
          "participations",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "participations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HistoricalParticipation"
            },
            "description": "List of participation records"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching records"
          },
          "page": {
            "type": "integer",
            "description": "Current page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether there are more results after this page"
          },
          "hasPreviousPage": {
            "type": "boolean",
            "description": "Whether there are results before this page"
          }
        }
      },
      "ParticipationRole": {
        "type": "string",
        "description": "How the character participated in the historical event",
        "enum": [
          "LEADER",
          "COMBATANT",
          "VICTIM",
          "WITNESS",
          "BENEFICIARY",
          "CONSPIRATOR",
          "HERO",
          "SURVIVOR"
        ]
      },
      "PartnerSummary": {
        "type": "object",
        "description": "Public summary of a bond partner's seed.",
        "required": [
          "seedId",
          "ownerId",
          "ownerType",
          "growthPhase",
          "status"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "Partner seed ID."
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Partner's owner entity ID."
          },
          "ownerType": {
            "type": "string",
            "description": "Partner's owner entity type."
          },
          "growthPhase": {
            "type": "string",
            "description": "Partner's current growth phase."
          },
          "status": {
            "$ref": "#/components/schemas/SeedStatus",
            "description": "Partner's seed status."
          }
        }
      },
      "PartyAssetRequirementStatus": {
        "type": "object",
        "description": "Asset requirement status for a single party",
        "additionalProperties": false,
        "required": [
          "partyRole",
          "satisfied",
          "clauses"
        ],
        "properties": {
          "partyRole": {
            "type": "string",
            "description": "Party role (e.g., party_a, party_b)"
          },
          "satisfied": {
            "type": "boolean",
            "description": "Whether all party's requirements are satisfied"
          },
          "clauses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ClauseAssetStatus"
            },
            "description": "Status of each clause for this party"
          }
        }
      },
      "PartyConsentStatus": {
        "type": "object",
        "description": "Consent status for a single party",
        "required": [
          "partyId",
          "partyType",
          "consentGiven"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party ID"
          },
          "partyType": {
            "description": "Type of entity (Account, Character, etc.)",
            "$ref": "#/components/schemas/EntityType"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Party display name"
          },
          "consentGiven": {
            "type": "boolean",
            "description": "Whether consent was given"
          },
          "consentType": {
            "$ref": "#/components/schemas/EscrowConsentType",
            "description": "Type of consent given (if any)",
            "nullable": true
          },
          "consentedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When consent was given"
          }
        }
      },
      "PartyMemberInfo": {
        "type": "object",
        "description": "Information about a party member for matchmaking",
        "additionalProperties": false,
        "required": [
          "accountId",
          "webSocketSessionId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID of the party member"
          },
          "webSocketSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "WebSocket session ID for event delivery"
          },
          "skillRating": {
            "type": "number",
            "nullable": true,
            "description": "Pre-fetched skill rating (optional, will be looked up if not provided)"
          }
        }
      },
      "PartyRoleDefinition": {
        "type": "object",
        "description": "Definition of a party role in a contract template",
        "additionalProperties": false,
        "required": [
          "role",
          "minCount",
          "maxCount"
        ],
        "properties": {
          "role": {
            "type": "string",
            "maxLength": 64,
            "description": "Role identifier (employer, employee, buyer, seller, etc.)"
          },
          "minCount": {
            "type": "integer",
            "minimum": 0,
            "description": "Minimum entities required in this role"
          },
          "maxCount": {
            "type": "integer",
            "minimum": 1,
            "description": "Maximum entities allowed in this role"
          },
          "allowedEntityTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityType"
            },
            "nullable": true,
            "description": "Which entity types can fill this role (null for any)"
          }
        }
      },
      "PartySkillAggregation": {
        "type": "string",
        "description": "Method for aggregating party member skills",
        "enum": [
          "highest",
          "average",
          "weighted"
        ]
      },
      "PartyToken": {
        "type": "object",
        "description": "Token issued to a party for deposit or release operations",
        "required": [
          "partyId",
          "partyType",
          "token"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party ID"
          },
          "partyType": {
            "description": "Type of entity (Account, Character, etc.)",
            "$ref": "#/components/schemas/EntityType"
          },
          "token": {
            "type": "string",
            "description": "The token"
          }
        }
      },
      "PasswordResetConfirmRequest": {
        "description": "Request to confirm a password reset using the emailed token and new password",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "token",
          "newPassword"
        ],
        "properties": {
          "token": {
            "type": "string",
            "description": "Password reset token received via email"
          },
          "newPassword": {
            "type": "string",
            "format": "password",
            "minLength": 8,
            "description": "New password to set for the account"
          }
        }
      },
      "PasswordResetRequest": {
        "description": "Request to initiate a password reset by sending a reset link to the email",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "email"
        ],
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "maxLength": 254,
            "description": "Email address associated with the account to reset"
          }
        }
      },
      "PastLifeReference": {
        "description": "Reference to a past incarnation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the previous incarnation"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "Display name of the past life"
          },
          "deathDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the past life ended"
          }
        }
      },
      "PaymentSchedule": {
        "type": "string",
        "description": "When payments occur",
        "enum": [
          "one_time",
          "recurring",
          "milestone_based"
        ]
      },
      "PendingConsentSummary": {
        "type": "object",
        "description": "Summary of pending consent",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "role"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type"
          },
          "role": {
            "type": "string",
            "description": "Role in contract"
          }
        }
      },
      "PerceptionData": {
        "type": "object",
        "additionalProperties": false,
        "description": "Data representing a perception event for an actor.\n\nSpatial context can be provided in two ways (hybrid approach):\n1. Typed: Use the optional spatialContext field for structured spatial data\n2. Schema-less: Use perceptionType=\"spatial\" with data containing spatial info\n\nThe typed approach is recommended when game server has structured spatial data.\nThe schema-less approach allows flexibility for game-specific spatial formats.\n",
        "required": [
          "perceptionType",
          "sourceId"
        ],
        "properties": {
          "perceptionType": {
            "type": "string",
            "description": "Perception type. Common values: visual, auditory, tactile, olfactory,\nproprioceptive, spatial. Use \"spatial\" for schema-less spatial data in 'data' field.\n"
          },
          "sourceId": {
            "type": "string",
            "description": "ID of the entity causing this perception"
          },
          "sourceType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PerceptionSourceType"
              }
            ],
            "nullable": true,
            "description": "Type of source (character, npc, object, environment, coordinator, scheduled, message)"
          },
          "data": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Perception-specific data. For perceptionType=\"spatial\", this can contain\ngame-specific spatial context in any format the game server defines.\n"
          },
          "urgency": {
            "type": "number",
            "format": "float",
            "minimum": 0,
            "maximum": 1,
            "default": 0.5,
            "description": "How urgent this perception is (0-1)"
          },
          "spatialContext": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SpatialContext"
              }
            ],
            "nullable": true,
            "description": "Optional typed spatial context from game server's local spatial state.\nProvides structured information about terrain, nearby objects, hazards, etc.\nAlternative to using perceptionType=\"spatial\" with schema-less data.\n"
          }
        }
      },
      "PerceptionSourceType": {
        "type": "string",
        "description": "Type of source generating a perception event",
        "enum": [
          "character",
          "npc",
          "object",
          "environment",
          "coordinator",
          "scheduled",
          "message",
          "service",
          "system"
        ]
      },
      "PersistenceMode": {
        "type": "string",
        "description": "Whether room messages are stored in Redis (TTL) or MySQL (durable)",
        "enum": [
          "Ephemeral",
          "Persistent"
        ]
      },
      "PersonalityResponse": {
        "type": "object",
        "description": "Complete personality profile for behavior system consumption",
        "additionalProperties": false,
        "required": [
          "characterId",
          "traits",
          "version",
          "createdAt"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character this personality belongs to"
          },
          "traits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TraitValue"
            },
            "description": "All trait axis values for this character"
          },
          "version": {
            "type": "integer",
            "description": "Personality version number (increments on each evolution)"
          },
          "archetypeHint": {
            "type": "string",
            "nullable": true,
            "description": "Optional archetype code for behavior optimization (e.g., \"guardian\",\n\"merchant\", \"scholar\", \"trickster\"). Allows behavior system to use\npre-compiled behavior variants for common personality patterns.\n"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this personality was first created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this personality was last modified"
          }
        }
      },
      "PersonalitySnapshot": {
        "description": "Snapshot of personality traits for enriched response",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "traits",
          "version"
        ],
        "properties": {
          "traits": {
            "type": "object",
            "additionalProperties": {
              "type": "number",
              "format": "float"
            },
            "description": "Trait values keyed by trait name (OPENNESS, AGREEABLENESS, etc.)"
          },
          "version": {
            "type": "integer",
            "description": "Personality version number (increments on evolution)"
          }
        }
      },
      "PerspectiveResponse": {
        "type": "object",
        "description": "Response containing a perspective",
        "additionalProperties": false,
        "required": [
          "perspective"
        ],
        "properties": {
          "perspective": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EncounterPerspectiveModel"
              }
            ],
            "description": "The character's perspective on the encounter"
          }
        }
      },
      "PhaseConfigResponse": {
        "type": "object",
        "description": "Current deployment phase configuration",
        "required": [
          "currentPhase",
          "maxConcurrentScenariosGlobal",
          "persistentEntryEnabled",
          "gardenMinigamesEnabled"
        ],
        "properties": {
          "currentPhase": {
            "$ref": "#/components/schemas/DeploymentPhase",
            "description": "Current deployment phase"
          },
          "maxConcurrentScenariosGlobal": {
            "type": "integer",
            "description": "Maximum total active scenario instances"
          },
          "persistentEntryEnabled": {
            "type": "boolean",
            "description": "Whether persistent world entry is enabled"
          },
          "gardenMinigamesEnabled": {
            "type": "boolean",
            "description": "Whether garden minigames are enabled"
          }
        }
      },
      "PhaseMetricsResponse": {
        "type": "object",
        "description": "Current deployment phase metrics",
        "required": [
          "currentPhase",
          "activeGardenInstances",
          "activeScenarioInstances",
          "scenarioCapacityUtilization"
        ],
        "properties": {
          "currentPhase": {
            "$ref": "#/components/schemas/DeploymentPhase",
            "description": "Current deployment phase"
          },
          "activeGardenInstances": {
            "type": "integer",
            "description": "Number of currently active garden instances"
          },
          "activeScenarioInstances": {
            "type": "integer",
            "description": "Number of currently active scenario instances"
          },
          "scenarioCapacityUtilization": {
            "type": "number",
            "format": "float",
            "description": "Ratio of active scenarios to global capacity (0.0-1.0)"
          }
        }
      },
      "PhasePosition": {
        "x-sdk-type": "BeyondImmersion.Bannou.StorylineStoryteller.Templates.PhasePosition",
        "type": "object",
        "additionalProperties": false,
        "description": "Phase position constraints from Save the Cat beat timing (SDK type)",
        "required": [
          "stcCenter",
          "floor",
          "ceiling",
          "validationBand"
        ],
        "properties": {
          "stcCenter": {
            "type": "number",
            "format": "double",
            "description": "Target position from STC beat timing"
          },
          "floor": {
            "type": "number",
            "format": "double",
            "description": "Earliest advancement position (prevents speed-running)"
          },
          "ceiling": {
            "type": "number",
            "format": "double",
            "description": "Forced advancement position (prevents deadlock)"
          },
          "validationBand": {
            "type": "number",
            "format": "double",
            "description": "Validation tolerance (\u00b1)"
          }
        }
      },
      "PhaseTargetState": {
        "x-sdk-type": "BeyondImmersion.Bannou.StorylineStoryteller.Templates.PhaseTargetState",
        "type": "object",
        "additionalProperties": false,
        "description": "Target state for phase completion (SDK type)",
        "required": [
          "minPrimarySpectrum",
          "maxPrimarySpectrum"
        ],
        "properties": {
          "minPrimarySpectrum": {
            "type": "number",
            "format": "double",
            "description": "Minimum primary spectrum value for this phase"
          },
          "maxPrimarySpectrum": {
            "type": "number",
            "format": "double",
            "description": "Maximum primary spectrum value for this phase"
          },
          "rangeDescription": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description of this state range"
          }
        }
      },
      "PinMessageRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to pin a message in a room",
        "required": [
          "roomId",
          "messageId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room the message belongs to"
          },
          "messageId": {
            "type": "string",
            "format": "uuid",
            "description": "Message ID to pin"
          }
        }
      },
      "PinVersionRequest": {
        "type": "object",
        "description": "Request to pin a save version as a checkpoint to prevent cleanup",
        "required": [
          "ownerId",
          "ownerType",
          "slotName",
          "versionNumber"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Version to pin"
          },
          "checkpointName": {
            "type": "string",
            "maxLength": 64,
            "description": "Optional checkpoint name for easy retrieval"
          }
        }
      },
      "Pitch": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Pitch.Pitch",
        "description": "A specific pitch with pitch class and octave",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "pitchClass",
          "octave"
        ],
        "properties": {
          "pitchClass": {
            "$ref": "#/components/schemas/PitchClass",
            "description": "Pitch class (note name)"
          },
          "octave": {
            "type": "integer",
            "minimum": 0,
            "maximum": 9,
            "description": "Octave number (middle C = C4)"
          },
          "midiNumber": {
            "type": "integer",
            "minimum": 0,
            "maximum": 127,
            "description": "MIDI note number (computed if not provided)"
          }
        }
      },
      "PitchClass": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Pitch.PitchClass",
        "description": "A pitch class (note name without octave)",
        "type": "string",
        "enum": [
          "C",
          "Cs",
          "D",
          "Ds",
          "E",
          "F",
          "Fs",
          "G",
          "Gs",
          "A",
          "As",
          "B"
        ]
      },
      "PitchRange": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Pitch.PitchRange",
        "description": "A pitch range from low to high",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "low",
          "high"
        ],
        "properties": {
          "low": {
            "$ref": "#/components/schemas/Pitch",
            "description": "Lowest pitch (inclusive)"
          },
          "high": {
            "$ref": "#/components/schemas/Pitch",
            "description": "Highest pitch (inclusive)"
          }
        }
      },
      "PlanSummary": {
        "type": "object",
        "additionalProperties": false,
        "description": "Summary of a cached plan",
        "required": [
          "planId",
          "goal",
          "arcType",
          "confidence",
          "createdAt"
        ],
        "properties": {
          "planId": {
            "type": "string",
            "format": "uuid",
            "description": "Plan identifier"
          },
          "goal": {
            "$ref": "#/components/schemas/StorylineGoal",
            "description": "Story goal"
          },
          "arcType": {
            "$ref": "#/components/schemas/ArcType",
            "description": "Arc type"
          },
          "confidence": {
            "type": "number",
            "format": "double",
            "description": "Viability score"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Anchored realm (if any)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When plan was created"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When plan expires from cache"
          }
        }
      },
      "PlannedActionResponse": {
        "description": "Single action within a GOAP plan with position and cost information",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "actionId",
          "index",
          "cost"
        ],
        "properties": {
          "actionId": {
            "type": "string",
            "description": "ID of the action (flow name)"
          },
          "index": {
            "type": "integer",
            "description": "Position in the plan sequence"
          },
          "cost": {
            "type": "number",
            "format": "float",
            "description": "Cost of this action"
          }
        }
      },
      "PlanningUrgency": {
        "x-sdk-type": "BeyondImmersion.Bannou.StorylineStoryteller.Planning.PlanningUrgency",
        "type": "string",
        "enum": [
          "Low",
          "Medium",
          "High"
        ],
        "description": "GOAP planning urgency level affecting search parameters.\nLow: More iterations, wider beam (1000/20)\nMedium: Balanced (500/15)\nHigh: Fewer iterations, narrower beam (200/10)\n"
      },
      "Platform": {
        "type": "string",
        "description": "External platform for achievement sync",
        "enum": [
          "steam",
          "xbox",
          "playstation",
          "internal"
        ]
      },
      "PlayerRole": {
        "type": "string",
        "description": "Role of the player in the game session",
        "enum": [
          "player",
          "spectator",
          "moderator"
        ]
      },
      "PoiInteractionResponse": {
        "type": "object",
        "description": "Result of interacting with a POI",
        "required": [
          "poiId",
          "result"
        ],
        "properties": {
          "poiId": {
            "type": "string",
            "format": "uuid",
            "description": "POI that was interacted with"
          },
          "result": {
            "$ref": "#/components/schemas/PoiInteractionResult",
            "description": "Interaction outcome"
          },
          "scenarioTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Associated template ID if result involves a scenario"
          },
          "promptText": {
            "type": "string",
            "nullable": true,
            "description": "Prompt text for prompted POIs"
          },
          "promptChoices": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Available choices for prompted POIs"
          }
        }
      },
      "PoiInteractionResult": {
        "type": "string",
        "enum": [
          "ScenarioPrompt",
          "ScenarioEnter",
          "PoiUpdate",
          "ChainOffer"
        ],
        "description": "Outcome of interacting with a POI"
      },
      "PoiStatus": {
        "type": "string",
        "enum": [
          "Active",
          "Entered",
          "Declined",
          "Expired"
        ],
        "description": "Current lifecycle status of a POI"
      },
      "PoiSummary": {
        "type": "object",
        "description": "POI state summary for client display",
        "required": [
          "poiId",
          "position",
          "poiType",
          "triggerMode",
          "triggerRadius",
          "status"
        ],
        "properties": {
          "poiId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this POI"
          },
          "position": {
            "$ref": "#/components/schemas/Vec3",
            "description": "POI position in garden space"
          },
          "poiType": {
            "$ref": "#/components/schemas/PoiType",
            "description": "Sensory presentation type"
          },
          "visualHint": {
            "$ref": "#/components/schemas/ScenarioCategory",
            "nullable": true,
            "description": "Scenario category hint for client rendering"
          },
          "audioHint": {
            "type": "string",
            "nullable": true,
            "description": "Audio hint identifier for client rendering"
          },
          "intensityRamp": {
            "type": "number",
            "format": "float",
            "description": "Current intensity ramp value (0.0-1.0)",
            "default": 0.0
          },
          "triggerMode": {
            "$ref": "#/components/schemas/TriggerMode",
            "description": "How this POI is triggered"
          },
          "triggerRadius": {
            "type": "number",
            "format": "float",
            "description": "Trigger radius in garden space units"
          },
          "scenarioTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Associated scenario template if this POI leads to a scenario"
          },
          "status": {
            "$ref": "#/components/schemas/PoiStatus",
            "description": "Current lifecycle status"
          }
        }
      },
      "PoiType": {
        "type": "string",
        "enum": [
          "Visual",
          "Auditory",
          "Environmental",
          "Portal",
          "Social"
        ],
        "description": "Sensory presentation type for a point of interest in the garden"
      },
      "Position3D": {
        "type": "object",
        "additionalProperties": false,
        "description": "Position in world coordinates (meters, Y-up, right-handed)",
        "required": [
          "x",
          "y",
          "z"
        ],
        "properties": {
          "x": {
            "type": "number",
            "format": "float",
            "description": "X coordinate in world space (meters)"
          },
          "y": {
            "type": "number",
            "format": "float",
            "description": "Y coordinate (up axis) in world space (meters)"
          },
          "z": {
            "type": "number",
            "format": "float",
            "description": "Z coordinate in world space (meters)"
          }
        }
      },
      "PositionUpdateResponse": {
        "type": "object",
        "description": "Response to a position update",
        "required": [
          "acknowledged"
        ],
        "properties": {
          "acknowledged": {
            "type": "boolean",
            "description": "Whether the position update was processed"
          },
          "triggeredPois": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PoiSummary"
            },
            "nullable": true,
            "description": "POIs triggered by proximity to the new position"
          }
        }
      },
      "PreboundApi": {
        "type": "object",
        "description": "Pre-configured API call to execute on contract events",
        "additionalProperties": false,
        "required": [
          "serviceName",
          "endpoint",
          "payloadTemplate"
        ],
        "properties": {
          "serviceName": {
            "type": "string",
            "description": "Target service name"
          },
          "endpoint": {
            "type": "string",
            "description": "Target endpoint path"
          },
          "payloadTemplate": {
            "type": "string",
            "description": "JSON payload with variable placeholders"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description"
          },
          "executionMode": {
            "type": "string",
            "enum": [
              "sync",
              "async",
              "fire_and_forget"
            ],
            "default": "sync",
            "description": "How to execute the API call"
          },
          "responseValidation": {
            "$ref": "#/components/schemas/ResponseValidation",
            "nullable": true,
            "description": "Optional validation rules for the response"
          }
        }
      },
      "PredictedMutation": {
        "type": "object",
        "additionalProperties": false,
        "description": "Mutation that would be applied",
        "required": [
          "mutationType",
          "description"
        ],
        "properties": {
          "mutationType": {
            "$ref": "#/components/schemas/MutationType",
            "description": "Type of mutation"
          },
          "description": {
            "type": "string",
            "description": "Human-readable description"
          }
        }
      },
      "PreferredRange": {
        "type": "string",
        "description": "Preferred engagement distance. Influences positioning and\nability selection in combat.\n",
        "enum": [
          "MELEE",
          "CLOSE",
          "MEDIUM",
          "RANGED"
        ]
      },
      "PrerequisiteDefinition": {
        "type": "object",
        "description": "Requirement that must be met before a quest can be accepted",
        "additionalProperties": false,
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "description": "Type of prerequisite check",
            "$ref": "#/components/schemas/PrerequisiteType"
          },
          "questCode": {
            "type": "string",
            "nullable": true,
            "description": "Quest code for QUEST_COMPLETED type"
          },
          "minLevel": {
            "type": "integer",
            "nullable": true,
            "description": "Minimum level for CHARACTER_LEVEL type"
          },
          "factionCode": {
            "type": "string",
            "nullable": true,
            "description": "Faction code for REPUTATION type"
          },
          "minReputation": {
            "type": "integer",
            "nullable": true,
            "description": "Minimum reputation for REPUTATION type"
          },
          "itemCode": {
            "type": "string",
            "nullable": true,
            "description": "Item code for ITEM_OWNED type"
          },
          "currencyCode": {
            "type": "string",
            "nullable": true,
            "description": "Currency code for CURRENCY_AMOUNT type"
          },
          "minAmount": {
            "type": "integer",
            "nullable": true,
            "description": "Minimum amount for CURRENCY_AMOUNT type"
          }
        }
      },
      "PrerequisiteType": {
        "type": "string",
        "enum": [
          "QUEST_COMPLETED",
          "CHARACTER_LEVEL",
          "REPUTATION",
          "ITEM_OWNED",
          "CURRENCY_AMOUNT"
        ],
        "description": "Type of prerequisite check"
      },
      "ProcessingStatus": {
        "type": "string",
        "enum": [
          "pending",
          "processing",
          "complete",
          "failed"
        ],
        "description": "Asset processing pipeline status"
      },
      "ProgressionAnalysis": {
        "description": "Analysis of a chord progression",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "romanNumerals": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Roman numeral analysis"
          },
          "cadences": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CadenceInfo"
            },
            "nullable": true,
            "description": "Detected cadences"
          },
          "functionalAnalysis": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "tonic",
                "subdominant",
                "dominant",
                "predominant"
              ]
            },
            "nullable": true,
            "description": "Functional analysis per chord"
          }
        }
      },
      "PromoteVersionRequest": {
        "type": "object",
        "description": "Request to promote an older save version to be the latest",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName",
          "versionNumber"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Name of the slot containing the version to promote"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Old version to promote to latest"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Display name for promoted version"
          }
        }
      },
      "ProposeContractInstanceRequest": {
        "type": "object",
        "description": "Request to propose a contract to parties",
        "additionalProperties": false,
        "required": [
          "contractId"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance to propose"
          }
        }
      },
      "Provider": {
        "type": "string",
        "enum": [
          "google",
          "discord",
          "twitch",
          "steam"
        ],
        "description": "Authentication provider type"
      },
      "ProviderInfo": {
        "type": "object",
        "description": "Information about an available authentication provider",
        "additionalProperties": false,
        "required": [
          "name",
          "displayName",
          "authType"
        ],
        "properties": {
          "name": {
            "type": "string",
            "example": "discord",
            "description": "Internal identifier for the provider (matches Provider enum for OAuth)"
          },
          "displayName": {
            "type": "string",
            "example": "Discord",
            "description": "Human-readable name for the provider"
          },
          "authType": {
            "type": "string",
            "enum": [
              "oauth",
              "ticket"
            ],
            "description": "Authentication mechanism (oauth = browser redirect, ticket = game client token)"
          },
          "authUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "example": "https://discord.com/oauth2/authorize",
            "description": "URL to initiate OAuth authentication (null for ticket-based auth like Steam)"
          }
        }
      },
      "ProvidersResponse": {
        "type": "object",
        "description": "List of available authentication providers",
        "additionalProperties": false,
        "required": [
          "providers"
        ],
        "properties": {
          "providers": {
            "type": "array",
            "description": "Available authentication providers",
            "items": {
              "$ref": "#/components/schemas/ProviderInfo"
            }
          }
        }
      },
      "QuantityModel": {
        "type": "string",
        "description": "How quantities are tracked for this item type",
        "enum": [
          "discrete",
          "continuous",
          "unique"
        ]
      },
      "Quaternion": {
        "type": "object",
        "description": "Rotation represented as a quaternion",
        "required": [
          "x",
          "y",
          "z",
          "w"
        ],
        "properties": {
          "x": {
            "type": "number",
            "format": "double",
            "description": "X component"
          },
          "y": {
            "type": "number",
            "format": "double",
            "description": "Y component"
          },
          "z": {
            "type": "number",
            "format": "double",
            "description": "Z component"
          },
          "w": {
            "type": "number",
            "format": "double",
            "description": "W component (scalar)"
          }
        }
      },
      "QueryActiveContractsRequest": {
        "type": "object",
        "description": "Request to query active contracts",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity to query"
          },
          "entityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Entity type"
          },
          "templateCodes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by template codes"
          }
        }
      },
      "QueryActiveContractsResponse": {
        "type": "object",
        "description": "Active contracts for entity",
        "additionalProperties": false,
        "required": [
          "contracts"
        ],
        "properties": {
          "contracts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContractSummary"
            },
            "description": "Active contracts"
          }
        }
      },
      "QueryBetweenRequest": {
        "type": "object",
        "description": "Request to query encounters between two characters",
        "additionalProperties": false,
        "required": [
          "characterIdA",
          "characterIdB"
        ],
        "properties": {
          "characterIdA": {
            "type": "string",
            "format": "uuid",
            "description": "First character"
          },
          "characterIdB": {
            "type": "string",
            "format": "uuid",
            "description": "Second character"
          },
          "encounterTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Filter by encounter type"
          },
          "minimumMemoryStrength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Filter by minimum memory strength (for either character)"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Results per page"
          }
        }
      },
      "QueryBoundsRequest": {
        "type": "object",
        "description": "Query map data within bounds",
        "required": [
          "regionId",
          "bounds"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region to query"
          },
          "bounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Bounding box to query"
          },
          "kinds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapKind"
            },
            "description": "Kinds to query (default all)",
            "nullable": true
          },
          "maxObjects": {
            "type": "integer",
            "default": 500,
            "maximum": 5000,
            "description": "Maximum objects to return"
          }
        }
      },
      "QueryBoundsResponse": {
        "type": "object",
        "description": "Bounds query results",
        "properties": {
          "objects": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapObject"
            },
            "description": "Objects within bounds"
          },
          "bounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Queried bounds"
          },
          "truncated": {
            "type": "boolean",
            "description": "Whether results were truncated"
          }
        }
      },
      "QueryBundlesByAssetRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to find bundles containing a specific asset",
        "required": [
          "assetId",
          "realm"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Platform asset ID to search for"
          },
          "realm": {
            "$ref": "#/components/schemas/GameRealm",
            "description": "Game realm to search within"
          },
          "bundleType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BundleType"
              }
            ],
            "nullable": true,
            "description": "Filter by bundle type (optional, null for all types)"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Maximum results to return"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          }
        }
      },
      "QueryBundlesByAssetResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Bundles containing the requested asset",
        "required": [
          "assetId",
          "bundles",
          "total",
          "limit",
          "offset"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "The queried asset ID"
          },
          "bundles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BundleSummary"
            },
            "description": "Bundles containing this asset"
          },
          "total": {
            "type": "integer",
            "description": "Total matching bundles"
          },
          "limit": {
            "type": "integer",
            "description": "Page size"
          },
          "offset": {
            "type": "integer",
            "description": "Page offset"
          }
        }
      },
      "QueryBundlesRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Advanced bundle query with filters",
        "properties": {
          "tags": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by exact tag key-value matches"
          },
          "tagExists": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter bundles that have these tag keys (any value)"
          },
          "tagNotExists": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter bundles that do NOT have these tag keys"
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BundleLifecycle"
              }
            ],
            "nullable": true,
            "description": "Filter by lifecycle status (null for active only by default)"
          },
          "createdAfter": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter bundles created after this time"
          },
          "createdBefore": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter bundles created before this time"
          },
          "nameContains": {
            "type": "string",
            "nullable": true,
            "description": "Filter bundles with name containing this string (case-insensitive)"
          },
          "owner": {
            "type": "string",
            "nullable": true,
            "description": "Filter by bundle owner account ID"
          },
          "realm": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GameRealm"
              }
            ],
            "nullable": true,
            "description": "Filter by realm"
          },
          "bundleType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BundleType"
              }
            ],
            "nullable": true,
            "description": "Filter by bundle type (source or metabundle)"
          },
          "sortField": {
            "type": "string",
            "enum": [
              "created_at",
              "updated_at",
              "name",
              "size"
            ],
            "nullable": true,
            "description": "Field to sort by (default created_at)"
          },
          "sortOrder": {
            "type": "string",
            "enum": [
              "asc",
              "desc"
            ],
            "nullable": true,
            "description": "Sort order (default desc)"
          },
          "limit": {
            "type": "integer",
            "default": 100,
            "description": "Maximum results to return (max 1000)"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          },
          "includeDeleted": {
            "type": "boolean",
            "default": false,
            "description": "Include soft-deleted bundles in results"
          }
        }
      },
      "QueryBundlesResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Bundle query results",
        "required": [
          "bundles",
          "totalCount",
          "limit",
          "offset"
        ],
        "properties": {
          "bundles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BundleInfo"
            },
            "description": "Matching bundles"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching bundles (for pagination)"
          },
          "limit": {
            "type": "integer",
            "description": "Page size used"
          },
          "offset": {
            "type": "integer",
            "description": "Page offset used"
          }
        }
      },
      "QueryByCharacterRequest": {
        "type": "object",
        "description": "Request to query encounters by character",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to query encounters for"
          },
          "encounterTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Filter by encounter type"
          },
          "outcome": {
            "$ref": "#/components/schemas/EncounterOutcome",
            "nullable": true,
            "description": "Filter by outcome"
          },
          "minimumMemoryStrength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Filter by minimum memory strength"
          },
          "fromTimestamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter encounters after this time"
          },
          "toTimestamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter encounters before this time"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Results per page"
          }
        }
      },
      "QueryByLocationRequest": {
        "type": "object",
        "description": "Request to query recent encounters at a location",
        "additionalProperties": false,
        "required": [
          "locationId"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "Location to query"
          },
          "encounterTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Filter by encounter type"
          },
          "fromTimestamp": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter encounters after this time"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Results per page"
          }
        }
      },
      "QueryContractInstancesRequest": {
        "type": "object",
        "description": "Request to query contract instances with cursor-based pagination.",
        "additionalProperties": false,
        "properties": {
          "partyEntityId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by party entity ID."
          },
          "partyEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "nullable": true,
            "description": "Filter by party entity type."
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by template."
          },
          "statuses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContractStatus"
            },
            "nullable": true,
            "description": "Filter by statuses."
          },
          "cursor": {
            "type": "string",
            "nullable": true,
            "description": "Opaque cursor from previous response. Null for first page."
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "nullable": true,
            "description": "Number of items per page. Uses service default if not specified."
          }
        }
      },
      "QueryContractInstancesResponse": {
        "type": "object",
        "description": "Paginated list of contract instances.",
        "additionalProperties": false,
        "required": [
          "contracts",
          "hasMore"
        ],
        "properties": {
          "contracts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContractInstanceResponse"
            },
            "description": "Contracts in this page."
          },
          "nextCursor": {
            "type": "string",
            "nullable": true,
            "description": "Cursor for next page. Null if no more results."
          },
          "hasMore": {
            "type": "boolean",
            "description": "Whether more results exist beyond this page."
          }
        }
      },
      "QueryDocumentationRequest": {
        "description": "Request to search documentation using natural language queries",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "query"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to search within"
          },
          "query": {
            "type": "string",
            "minLength": 3,
            "maxLength": 500,
            "description": "Natural language query to search for"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Optional session ID for conversational context"
          },
          "category": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "Filter results to a specific category"
          },
          "maxResults": {
            "type": "integer",
            "default": 5,
            "minimum": 1,
            "maximum": 20,
            "description": "Maximum number of results to return"
          },
          "includeContent": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include full document content in results"
          },
          "maxSummaryLength": {
            "type": "integer",
            "default": 300,
            "minimum": 50,
            "maximum": 500,
            "description": "Maximum length of summaries in characters"
          },
          "minRelevanceScore": {
            "type": "number",
            "format": "float",
            "default": 0.3,
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "Minimum relevance score threshold for results"
          }
        }
      },
      "QueryDocumentationResponse": {
        "description": "Response containing search results and voice-friendly summaries",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "query",
          "results"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "description": "The namespace that was searched"
          },
          "query": {
            "type": "string",
            "description": "The original query string"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentResult"
            },
            "description": "List of matching documents"
          },
          "totalResults": {
            "type": "integer",
            "description": "Total number of matching documents"
          },
          "voiceSummary": {
            "type": "string",
            "description": "Concise spoken summary for voice AI"
          },
          "suggestedFollowups": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Suggested follow-up queries"
          },
          "noResultsMessage": {
            "type": "string",
            "description": "User-friendly message when no results found"
          }
        }
      },
      "QueryEntriesRequest": {
        "type": "object",
        "description": "Request to query unlocked entries",
        "additionalProperties": false,
        "required": [
          "collectionId"
        ],
        "properties": {
          "collectionId": {
            "type": "string",
            "format": "uuid",
            "description": "Collection to query entries from"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Filter by category"
          },
          "tags": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Filter by tags (entries matching any tag are included)"
          },
          "cursor": {
            "type": "string",
            "nullable": true,
            "description": "Opaque cursor from previous response for pagination"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "nullable": true,
            "description": "Number of items per page"
          }
        }
      },
      "QueryEntriesResponse": {
        "type": "object",
        "description": "Paginated list of unlocked entries",
        "additionalProperties": false,
        "required": [
          "entries",
          "hasMore"
        ],
        "properties": {
          "entries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UnlockedEntryResponse"
            },
            "description": "Unlocked entries matching the query"
          },
          "nextCursor": {
            "type": "string",
            "nullable": true,
            "description": "Cursor for next page"
          },
          "hasMore": {
            "type": "boolean",
            "description": "Whether more results exist"
          }
        }
      },
      "QueryItemsRequest": {
        "type": "object",
        "description": "Request to query items",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner to search"
          },
          "ownerType": {
            "$ref": "#/components/schemas/ContainerOwnerType",
            "description": "Owner type"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by template"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Filter by category"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Filter by tags"
          },
          "containerType": {
            "type": "string",
            "nullable": true,
            "description": "Filter by container type"
          },
          "excludeEquipmentSlots": {
            "type": "boolean",
            "default": false,
            "description": "Exclude equipment slots"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "maximum": 200,
            "description": "Max results"
          }
        }
      },
      "QueryItemsResponse": {
        "type": "object",
        "description": "Query results",
        "additionalProperties": false,
        "required": [
          "items",
          "totalCount"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryResultItem"
            },
            "description": "Found items"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total matching"
          }
        }
      },
      "QueryLocationsByPositionRequest": {
        "description": "Request to find all locations containing a spatial position",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "position",
          "realmId"
        ],
        "properties": {
          "position": {
            "$ref": "#/components/schemas/Position3D",
            "description": "Position to query in world coordinates"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm to search within"
          },
          "maxDepth": {
            "type": "integer",
            "minimum": 0,
            "nullable": true,
            "description": "Maximum hierarchy depth to search (null for all depths)"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "default": 1,
            "description": "Page number for pagination (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "description": "Number of results per page"
          }
        }
      },
      "QueryObjectsByTypeRequest": {
        "type": "object",
        "description": "Query objects by type",
        "required": [
          "regionId",
          "objectType"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region to query"
          },
          "objectType": {
            "type": "string",
            "description": "Object type to filter by"
          },
          "bounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Optional bounds filter",
            "nullable": true
          },
          "maxObjects": {
            "type": "integer",
            "default": 500,
            "maximum": 5000,
            "description": "Maximum objects to return"
          }
        }
      },
      "QueryObjectsByTypeResponse": {
        "type": "object",
        "description": "Object type query results",
        "properties": {
          "objects": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapObject"
            },
            "description": "Matching objects"
          },
          "objectType": {
            "type": "string",
            "description": "Queried object type"
          },
          "truncated": {
            "type": "boolean",
            "description": "Whether results were truncated"
          }
        }
      },
      "QueryPointRequest": {
        "type": "object",
        "description": "Query map data at a point",
        "required": [
          "regionId",
          "position"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region to query"
          },
          "position": {
            "$ref": "#/components/schemas/Position3D",
            "description": "Point to query at"
          },
          "kinds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapKind"
            },
            "description": "Kinds to query (default all)",
            "nullable": true
          },
          "radius": {
            "type": "number",
            "description": "Include objects within this radius",
            "nullable": true
          }
        }
      },
      "QueryPointResponse": {
        "type": "object",
        "description": "Point query results",
        "properties": {
          "objects": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapObject"
            },
            "description": "Objects at/near the point"
          },
          "position": {
            "$ref": "#/components/schemas/Position3D",
            "description": "Queried position"
          },
          "radius": {
            "type": "number",
            "description": "Applied radius filter",
            "nullable": true
          }
        }
      },
      "QueryResultItem": {
        "type": "object",
        "description": "Item in query results",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "templateId",
          "containerId",
          "quantity"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance ID"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template ID"
          },
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container ID"
          },
          "containerType": {
            "type": "string",
            "description": "Container type"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "description": "Quantity"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Slot position"
          }
        }
      },
      "QuerySavesRequest": {
        "type": "object",
        "description": "Advanced query for saves across multiple owners with filtering and sorting",
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by owner ID"
          },
          "ownerType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/OwnerType"
              }
            ],
            "nullable": true,
            "description": "Filter by owner type"
          },
          "category": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SaveCategory"
              }
            ],
            "nullable": true,
            "description": "Filter by save category"
          },
          "createdAfter": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter by creation date"
          },
          "createdBefore": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Filter by creation date"
          },
          "pinnedOnly": {
            "type": "boolean",
            "nullable": true,
            "description": "Only return pinned versions"
          },
          "schemaVersion": {
            "type": "string",
            "nullable": true,
            "description": "Filter by schema version"
          },
          "metadataFilter": {
            "type": "object",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            },
            "description": "Filter by metadata key-value pairs"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          },
          "limit": {
            "type": "integer",
            "default": 20,
            "maximum": 100,
            "description": "Maximum results"
          },
          "sortBy": {
            "type": "string",
            "enum": [
              "created_at",
              "size",
              "version_number"
            ],
            "default": "created_at",
            "description": "Sort field"
          },
          "sortOrder": {
            "type": "string",
            "enum": [
              "asc",
              "desc"
            ],
            "default": "desc",
            "description": "Sort order"
          }
        }
      },
      "QuerySavesResponse": {
        "type": "object",
        "description": "Paginated results from a save query operation",
        "required": [
          "results",
          "totalCount"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryResultItem"
            },
            "description": "Query results"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total matching results"
          }
        }
      },
      "QueryViolationsRequest": {
        "type": "object",
        "description": "Request to query violation history for a character",
        "additionalProperties": false,
        "required": [
          "characterId"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the character to query violations for"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Filter by specific contract"
          },
          "violationType": {
            "type": "string",
            "nullable": true,
            "maxLength": 128,
            "description": "Filter by violation type code"
          },
          "since": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Only return violations after this timestamp"
          },
          "cursor": {
            "type": "string",
            "nullable": true,
            "maxLength": 512,
            "description": "Pagination cursor from a previous response"
          },
          "pageSize": {
            "type": "integer",
            "default": 20,
            "minimum": 1,
            "maximum": 100,
            "description": "Number of violations to return per page"
          }
        }
      },
      "QueryViolationsResponse": {
        "type": "object",
        "description": "Paginated violation history for a character",
        "additionalProperties": false,
        "required": [
          "violations",
          "hasMore"
        ],
        "properties": {
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ViolationRecord"
            },
            "description": "Violation records for this page"
          },
          "nextCursor": {
            "type": "string",
            "nullable": true,
            "maxLength": 512,
            "description": "Cursor for the next page (null if no more pages)"
          },
          "hasMore": {
            "type": "boolean",
            "description": "Whether more pages are available"
          }
        }
      },
      "QuestArchive": {
        "type": "object",
        "x-archive-type": true,
        "description": "Complete quest data for archive storage and storyline SDK consumption.\nInherits base archive properties from ResourceArchiveBase.\nThe characterId field equals resourceId for convenience.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/ResourceArchiveBase"
          }
        ],
        "additionalProperties": false,
        "required": [
          "characterId",
          "activeQuests",
          "completedQuests",
          "questCategories"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character this data belongs to (equals resourceId)"
          },
          "activeQuests": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ActiveQuestSummary"
            },
            "description": "Summary of currently active quests"
          },
          "completedQuests": {
            "type": "integer",
            "minimum": 0,
            "description": "Total count of completed quests"
          },
          "questCategories": {
            "type": "object",
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Breakdown of completed quests by category (main, side, bounty, etc.)"
          }
        }
      },
      "QuestCategory": {
        "type": "string",
        "enum": [
          "MAIN",
          "SIDE",
          "BOUNTY",
          "DAILY",
          "WEEKLY",
          "EVENT",
          "TUTORIAL"
        ],
        "description": "Category of quest for organization"
      },
      "QuestDefinitionResponse": {
        "type": "object",
        "description": "Complete quest definition including objectives, prerequisites, and rewards",
        "additionalProperties": false,
        "required": [
          "definitionId",
          "contractTemplateId",
          "code",
          "name",
          "category",
          "difficulty",
          "repeatable",
          "maxQuestors",
          "objectives",
          "deprecated",
          "createdAt",
          "gameServiceId"
        ],
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique quest definition ID"
          },
          "contractTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Underlying contract template ID"
          },
          "code": {
            "type": "string",
            "description": "Quest code"
          },
          "name": {
            "type": "string",
            "description": "Quest name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Quest description"
          },
          "category": {
            "description": "Quest category for organization",
            "$ref": "#/components/schemas/QuestCategory"
          },
          "difficulty": {
            "description": "Difficulty rating of the quest",
            "$ref": "#/components/schemas/QuestDifficulty"
          },
          "levelRequirement": {
            "type": "integer",
            "nullable": true,
            "description": "Minimum level required"
          },
          "repeatable": {
            "type": "boolean",
            "description": "Whether repeatable"
          },
          "cooldownSeconds": {
            "type": "integer",
            "nullable": true,
            "description": "Cooldown for repeatable quests"
          },
          "deadlineSeconds": {
            "type": "integer",
            "nullable": true,
            "description": "Time limit"
          },
          "maxQuestors": {
            "type": "integer",
            "description": "Max party size"
          },
          "objectives": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ObjectiveDefinition"
            },
            "description": "Quest objectives"
          },
          "prerequisites": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/PrerequisiteDefinition"
            },
            "description": "Prerequisites"
          },
          "rewards": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/RewardDefinition"
            },
            "description": "Rewards"
          },
          "tags": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Tags"
          },
          "deprecated": {
            "type": "boolean",
            "description": "Whether deprecated"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service ID"
          }
        }
      },
      "QuestDifficulty": {
        "type": "string",
        "enum": [
          "TRIVIAL",
          "EASY",
          "NORMAL",
          "HARD",
          "HEROIC",
          "LEGENDARY"
        ],
        "description": "Difficulty rating of the quest"
      },
      "QuestInstanceResponse": {
        "type": "object",
        "description": "Active or completed quest instance with progress information",
        "additionalProperties": false,
        "required": [
          "questInstanceId",
          "definitionId",
          "contractInstanceId",
          "code",
          "name",
          "status",
          "questorCharacterIds",
          "objectives",
          "acceptedAt"
        ],
        "properties": {
          "questInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique instance ID"
          },
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Quest definition ID"
          },
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Underlying contract instance ID"
          },
          "code": {
            "type": "string",
            "description": "Quest code"
          },
          "name": {
            "type": "string",
            "description": "Quest name"
          },
          "status": {
            "description": "Current status of the quest",
            "$ref": "#/components/schemas/QuestStatus"
          },
          "questorCharacterIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Characters on the quest"
          },
          "questGiverCharacterId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Quest giver NPC"
          },
          "objectives": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ObjectiveProgress"
            },
            "description": "Objective progress"
          },
          "acceptedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When quest was accepted"
          },
          "deadline": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Quest deadline (null if none)"
          },
          "completedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When completed"
          }
        }
      },
      "QuestLogEntry": {
        "type": "object",
        "description": "Single entry in the quest log with progress summary",
        "additionalProperties": false,
        "required": [
          "questInstanceId",
          "code",
          "name",
          "category",
          "status",
          "overallProgress",
          "visibleObjectives",
          "acceptedAt"
        ],
        "properties": {
          "questInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Quest instance ID"
          },
          "code": {
            "type": "string",
            "description": "Quest code"
          },
          "name": {
            "type": "string",
            "description": "Quest name"
          },
          "category": {
            "description": "Quest category for organization",
            "$ref": "#/components/schemas/QuestCategory"
          },
          "status": {
            "description": "Current status of the quest",
            "$ref": "#/components/schemas/QuestStatus"
          },
          "overallProgress": {
            "type": "number",
            "format": "float",
            "description": "Overall progress percentage"
          },
          "visibleObjectives": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ObjectiveProgress"
            },
            "description": "Visible objectives (hidden ones excluded until revealed)"
          },
          "deadline": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Deadline if any"
          },
          "acceptedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When accepted"
          }
        }
      },
      "QuestLogResponse": {
        "type": "object",
        "description": "Player-facing quest log with active quests and completion counts",
        "additionalProperties": false,
        "required": [
          "activeQuests",
          "completedCount",
          "failedCount"
        ],
        "properties": {
          "activeQuests": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QuestLogEntry"
            },
            "description": "Active quests with progress"
          },
          "completedCount": {
            "type": "integer",
            "description": "Total completed quests"
          },
          "failedCount": {
            "type": "integer",
            "description": "Total failed quests"
          }
        }
      },
      "QuestStatus": {
        "type": "string",
        "enum": [
          "ACTIVE",
          "COMPLETED",
          "FAILED",
          "ABANDONED",
          "EXPIRED"
        ],
        "description": "Current status of a quest instance"
      },
      "QueueResponse": {
        "type": "object",
        "description": "Full configuration details of a matchmaking queue",
        "additionalProperties": false,
        "required": [
          "queueId",
          "gameId",
          "displayName",
          "enabled",
          "minCount",
          "maxCount",
          "countMultiple",
          "intervalSeconds",
          "maxIntervals",
          "createdAt"
        ],
        "properties": {
          "queueId": {
            "type": "string",
            "description": "Unique identifier for the queue"
          },
          "gameId": {
            "type": "string",
            "description": "Game this queue is for"
          },
          "sessionGameType": {
            "$ref": "#/components/schemas/SessionGameType",
            "description": "Game type for created sessions (maps to game-session service)"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable queue name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Detailed description of the queue"
          },
          "enabled": {
            "type": "boolean",
            "description": "Whether the queue is currently accepting tickets"
          },
          "minCount": {
            "type": "integer",
            "minimum": 2,
            "description": "Minimum players required for a match"
          },
          "maxCount": {
            "type": "integer",
            "maximum": 200,
            "description": "Maximum players in a match"
          },
          "countMultiple": {
            "type": "integer",
            "minimum": 1,
            "description": "Player count must be divisible by this (e.g., 2 for pairs)"
          },
          "intervalSeconds": {
            "type": "integer",
            "minimum": 1,
            "description": "Seconds between match processing intervals"
          },
          "maxIntervals": {
            "type": "integer",
            "minimum": 1,
            "description": "Maximum intervals before relaxing to minCount"
          },
          "skillExpansion": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SkillExpansionStep"
            },
            "nullable": true,
            "description": "Skill window expansion steps"
          },
          "partySkillAggregation": {
            "$ref": "#/components/schemas/PartySkillAggregation",
            "description": "How to calculate party skill rating"
          },
          "partySkillWeights": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "nullable": true,
            "description": "Weights for weighted party skill aggregation"
          },
          "partyMaxSize": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum party size for this queue"
          },
          "allowConcurrent": {
            "type": "boolean",
            "default": true,
            "description": "Whether players can be in multiple queues"
          },
          "exclusiveGroup": {
            "type": "string",
            "nullable": true,
            "description": "Exclusive group name (player can only be in one queue of the group)"
          },
          "useSkillRating": {
            "type": "boolean",
            "default": true,
            "description": "Whether to use lib-analytics skill rating for matching"
          },
          "ratingCategory": {
            "type": "string",
            "nullable": true,
            "description": "lib-analytics rating category to use"
          },
          "startWhenMinimumReached": {
            "type": "boolean",
            "default": false,
            "description": "Start match with minCount after maxIntervals (for large lobbies)"
          },
          "requiresRegistration": {
            "type": "boolean",
            "default": false,
            "description": "Whether players must be registered for a tournament"
          },
          "tournamentIdRequired": {
            "type": "boolean",
            "default": false,
            "description": "Whether a tournament ID is required to join"
          },
          "matchAcceptTimeoutSeconds": {
            "type": "integer",
            "default": 30,
            "description": "Seconds players have to accept/decline a formed match"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the queue was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the queue was last updated"
          }
        }
      },
      "QueueStats": {
        "type": "object",
        "description": "Statistics for a single matchmaking queue",
        "additionalProperties": false,
        "required": [
          "queueId",
          "currentTickets",
          "matchesFormedLastHour",
          "averageWaitSeconds"
        ],
        "properties": {
          "queueId": {
            "type": "string",
            "description": "Queue identifier"
          },
          "currentTickets": {
            "type": "integer",
            "description": "Number of active tickets"
          },
          "matchesFormedLastHour": {
            "type": "integer",
            "description": "Matches formed in the last hour"
          },
          "averageWaitSeconds": {
            "type": "number",
            "description": "Average wait time in seconds"
          },
          "medianWaitSeconds": {
            "type": "number",
            "nullable": true,
            "description": "Median wait time in seconds"
          },
          "timeoutRatePercent": {
            "type": "number",
            "nullable": true,
            "description": "Percentage of tickets that timed out"
          },
          "cancelRatePercent": {
            "type": "number",
            "nullable": true,
            "description": "Percentage of tickets cancelled by user"
          }
        }
      },
      "QueueSummary": {
        "type": "object",
        "description": "Summary information about a matchmaking queue",
        "additionalProperties": false,
        "required": [
          "queueId",
          "gameId",
          "displayName",
          "enabled",
          "minCount",
          "maxCount"
        ],
        "properties": {
          "queueId": {
            "type": "string",
            "description": "Unique identifier for the queue"
          },
          "gameId": {
            "type": "string",
            "description": "Game this queue is for"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable queue name"
          },
          "enabled": {
            "type": "boolean",
            "description": "Whether the queue is currently accepting tickets"
          },
          "minCount": {
            "type": "integer",
            "description": "Minimum players required for a match"
          },
          "maxCount": {
            "type": "integer",
            "description": "Maximum players in a match"
          },
          "currentTickets": {
            "type": "integer",
            "nullable": true,
            "description": "Current number of tickets in queue (if available)"
          },
          "averageWaitSeconds": {
            "type": "number",
            "nullable": true,
            "description": "Average wait time in seconds (if available)"
          }
        }
      },
      "ReaffirmRequest": {
        "type": "object",
        "description": "Request to re-affirm after validation failure",
        "required": [
          "escrowId",
          "partyId",
          "partyType",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party reaffirming"
          },
          "partyType": {
            "description": "Type of entity (Account, Character, etc.)",
            "$ref": "#/components/schemas/EntityType"
          },
          "releaseToken": {
            "type": "string",
            "nullable": true,
            "description": "Release token"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "ReaffirmResponse": {
        "type": "object",
        "description": "Response from party re-affirming after validation failure",
        "required": [
          "escrow",
          "allReaffirmed"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Reaffirmed escrow agreement"
          },
          "allReaffirmed": {
            "type": "boolean",
            "description": "Whether all parties have reaffirmed"
          }
        }
      },
      "RealmEventCategory": {
        "type": "string",
        "description": "Categories of historical events that realms can participate in",
        "enum": [
          "FOUNDING",
          "WAR",
          "TREATY",
          "CATACLYSM",
          "DISCOVERY",
          "MIGRATION",
          "CULTURAL_SHIFT",
          "ECONOMIC_CHANGE",
          "POLITICAL_UPHEAVAL"
        ]
      },
      "RealmEventRole": {
        "type": "string",
        "description": "How the realm participated in the historical event",
        "enum": [
          "ORIGIN",
          "AGGRESSOR",
          "DEFENDER",
          "MEDIATOR",
          "AFFECTED",
          "BENEFICIARY",
          "INSTIGATOR",
          "NEUTRAL_PARTY"
        ]
      },
      "RealmExistsRequest": {
        "description": "Request to check if a realm exists and is available for use",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the realm to validate"
          }
        }
      },
      "RealmExistsResponse": {
        "description": "Response indicating whether a realm exists and its active status",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "exists",
          "isActive"
        ],
        "properties": {
          "exists": {
            "type": "boolean",
            "description": "Whether the realm exists"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether the realm is active (false if deprecated or not found)"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "The realm ID if found"
          }
        }
      },
      "RealmHistoricalParticipation": {
        "type": "object",
        "description": "Record of a realm's participation in a historical event",
        "additionalProperties": false,
        "required": [
          "participationId",
          "realmId",
          "eventId",
          "eventName",
          "eventCategory",
          "role",
          "eventDate",
          "createdAt"
        ],
        "properties": {
          "participationId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique ID for this participation record"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the realm that participated"
          },
          "eventId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the historical event"
          },
          "eventName": {
            "type": "string",
            "description": "Name of the event (for display and summarization)"
          },
          "eventCategory": {
            "$ref": "#/components/schemas/RealmEventCategory",
            "description": "Category of the historical event"
          },
          "role": {
            "$ref": "#/components/schemas/RealmEventRole",
            "description": "How the realm participated"
          },
          "eventDate": {
            "type": "string",
            "format": "date-time",
            "description": "In-game date when the event occurred"
          },
          "impact": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.5,
            "description": "How significant this event was for the realm (0.0 to 1.0).\nAffects behavior system weighting.\n"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Event-specific details for behavior decisions"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this record was created"
          }
        }
      },
      "RealmListResponse": {
        "description": "Paginated list of realms with metadata for navigation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realms",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "realms": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RealmResponse"
            },
            "description": "List of realms matching the query criteria"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of realms matching the query (before pagination)"
          },
          "page": {
            "type": "integer",
            "description": "Current page number (1-indexed)"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of realms per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether there are more realms available on the next page"
          },
          "hasPreviousPage": {
            "type": "boolean",
            "description": "Whether there are realms available on the previous page"
          }
        }
      },
      "RealmLoreElement": {
        "type": "object",
        "description": "A machine-readable lore element for behavior system consumption",
        "additionalProperties": false,
        "required": [
          "elementType",
          "key",
          "value"
        ],
        "properties": {
          "elementType": {
            "$ref": "#/components/schemas/RealmLoreElementType",
            "description": "Category of this lore element"
          },
          "key": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Machine-readable key (e.g., \"founding_year\", \"primary_export\", \"capital_city\").\nUsed by behavior system to query specific aspects.\n"
          },
          "value": {
            "type": "string",
            "minLength": 1,
            "maxLength": 500,
            "description": "Machine-readable value (e.g., \"year_of_the_dragon\", \"iron_ore\", \"stormgate\").\nReferenced in behavior rules.\n"
          },
          "strength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.5,
            "description": "How strongly this element affects behavior (0.0 to 1.0).\nHigher strength = greater influence on decisions.\n"
          },
          "relatedEntityId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional related entity (location, organization, character)"
          },
          "relatedEntityType": {
            "type": "string",
            "nullable": true,
            "description": "Type of the related entity (if any)"
          }
        }
      },
      "RealmLoreElementType": {
        "type": "string",
        "description": "Types of lore elements. Each type represents a different aspect\nof the realm's background that influences behavior.\n",
        "enum": [
          "ORIGIN_MYTH",
          "CULTURAL_PRACTICE",
          "POLITICAL_SYSTEM",
          "ECONOMIC_BASE",
          "RELIGIOUS_TRADITION",
          "GEOGRAPHIC_FEATURE",
          "FAMOUS_FIGURE",
          "TECHNOLOGICAL_LEVEL"
        ]
      },
      "RealmLoreResponse": {
        "type": "object",
        "description": "Complete lore data for a realm",
        "additionalProperties": false,
        "required": [
          "realmId",
          "elements"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the realm this lore belongs to"
          },
          "elements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RealmLoreElement"
            },
            "description": "All lore elements for this realm"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this lore was first created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this lore was last modified"
          }
        }
      },
      "RealmParticipationListResponse": {
        "type": "object",
        "description": "Paginated list of participation records",
        "additionalProperties": false,
        "required": [
          "participations",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "participations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RealmHistoricalParticipation"
            },
            "description": "List of participation records"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of matching records"
          },
          "page": {
            "type": "integer",
            "description": "Current page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether there are more results after this page"
          },
          "hasPreviousPage": {
            "type": "boolean",
            "description": "Whether there are results before this page"
          }
        }
      },
      "RealmResponse": {
        "description": "Complete realm information returned from API operations",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmId",
          "code",
          "name",
          "gameServiceId",
          "isActive",
          "isDeprecated",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the realm"
          },
          "code": {
            "type": "string",
            "description": "Unique code for the realm (e.g., \"REALM_1\", \"REALM_2\")"
          },
          "name": {
            "type": "string",
            "description": "Display name for the realm"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service this realm belongs to"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Detailed description of the realm"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Category for grouping realms"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether the realm is currently active for gameplay"
          },
          "isDeprecated": {
            "type": "boolean",
            "description": "Whether this realm is deprecated and cannot be used for new entities"
          },
          "deprecatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Timestamp when this realm was deprecated"
          },
          "deprecationReason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for deprecation"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional custom metadata for the realm"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the realm was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the realm was last updated"
          }
        }
      },
      "RealmsExistBatchRequest": {
        "description": "Request to check if multiple realms exist and are available for use",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "realmIds"
        ],
        "properties": {
          "realmIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "minItems": 1,
            "maxItems": 100,
            "description": "List of realm IDs to validate (max 100)"
          }
        }
      },
      "RealmsExistBatchResponse": {
        "description": "Batch validation results for multiple realms",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "results",
          "allExist",
          "allActive"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RealmExistsResponse"
            },
            "description": "Validation result for each requested realm ID (in same order as request)"
          },
          "allExist": {
            "type": "boolean",
            "description": "True if all requested realms exist"
          },
          "allActive": {
            "type": "boolean",
            "description": "True if all requested realms exist AND are active (not deprecated)"
          },
          "invalidRealmIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "List of realm IDs that do not exist (empty if all exist)"
          },
          "deprecatedRealmIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "List of realm IDs that exist but are deprecated (empty if none deprecated)"
          }
        }
      },
      "RecordGrowthBatchRequest": {
        "type": "object",
        "description": "Request to record growth across multiple domains atomically.",
        "required": [
          "seedId",
          "entries",
          "source"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed to record growth for."
          },
          "entries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GrowthEntry"
            },
            "description": "Domain-amount pairs to record."
          },
          "source": {
            "type": "string",
            "description": "Identifier of the contributing service."
          }
        }
      },
      "RecordGrowthRequest": {
        "type": "object",
        "description": "Request to record growth in a specific domain.",
        "required": [
          "seedId",
          "domain",
          "amount",
          "source"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed to record growth for."
          },
          "domain": {
            "type": "string",
            "description": "Dot-separated domain path (e.g., \"combat.melee.sword\"). New domains are created automatically on first contribution.\n"
          },
          "amount": {
            "type": "number",
            "format": "float",
            "description": "Amount of growth to add."
          },
          "source": {
            "type": "string",
            "description": "Identifier of the contributing service (e.g., \"character-encounter\")."
          },
          "sourceEventId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional reference to the originating event."
          }
        }
      },
      "ReferenceInfo": {
        "type": "object",
        "description": "Information about a reference",
        "required": [
          "sceneId",
          "sceneName",
          "nodeId",
          "nodeRefId"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Scene containing the reference"
          },
          "sceneName": {
            "type": "string",
            "description": "Name of the referencing scene"
          },
          "nodeId": {
            "type": "string",
            "format": "uuid",
            "description": "Node containing the reference"
          },
          "nodeRefId": {
            "type": "string",
            "description": "refId of the referencing node"
          },
          "nodeName": {
            "type": "string",
            "description": "Name of the referencing node"
          }
        }
      },
      "RefreshRequest": {
        "description": "Request to obtain a new access token using a valid refresh token",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "refreshToken"
        ],
        "properties": {
          "refreshToken": {
            "type": "string",
            "description": "Refresh token issued during authentication to obtain a new access token"
          }
        }
      },
      "RefundMode": {
        "type": "string",
        "description": "Controls how refund confirmation is handled. Same semantics as ReleaseMode.\nRefunds typically use 'immediate' since parties get their own assets back.\n",
        "enum": [
          "immediate",
          "service_only",
          "party_required"
        ]
      },
      "RefundRequest": {
        "type": "object",
        "description": "Request to trigger escrow refund to depositors",
        "required": [
          "escrowId",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "initiatorServiceId": {
            "type": "string",
            "nullable": true,
            "description": "For initiator_trusted mode"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Reason for refund"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "RefundResponse": {
        "type": "object",
        "description": "Response from refunding escrow assets to depositors",
        "required": [
          "escrow",
          "refunds"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Refunded escrow agreement"
          },
          "refunds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RefundResult"
            },
            "description": "Refund results per depositor"
          }
        }
      },
      "RefundResult": {
        "type": "object",
        "description": "Result of refunding assets to a single depositor",
        "required": [
          "depositorPartyId",
          "success"
        ],
        "properties": {
          "depositorPartyId": {
            "type": "string",
            "format": "uuid",
            "description": "Depositor party ID"
          },
          "assets": {
            "$ref": "#/components/schemas/EscrowAssetBundle",
            "description": "Assets refunded (null if failed)",
            "nullable": true
          },
          "success": {
            "type": "boolean",
            "description": "Whether refund succeeded"
          },
          "error": {
            "type": "string",
            "nullable": true,
            "description": "Error message if failed"
          }
        }
      },
      "RegisterFollowerRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to register a character as a deity follower",
        "required": [
          "deityId",
          "characterId"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity to follow"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character becoming a follower"
          }
        }
      },
      "RegisterReferenceRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to register a reference to a resource",
        "required": [
          "resourceType",
          "resourceId",
          "sourceType",
          "sourceId"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource being referenced (opaque identifier, e.g., \"character\", \"realm\")"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource being referenced"
          },
          "sourceType": {
            "type": "string",
            "description": "Type of entity holding the reference (opaque identifier, e.g., \"actor\", \"scene\")"
          },
          "sourceId": {
            "type": "string",
            "description": "ID of the entity holding the reference (opaque string, supports non-Guid IDs)"
          }
        }
      },
      "RegisterReferenceResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response after registering a reference",
        "required": [
          "resourceType",
          "resourceId",
          "newRefCount",
          "alreadyRegistered"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource referenced"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource referenced"
          },
          "newRefCount": {
            "type": "integer",
            "description": "Reference count after registration"
          },
          "alreadyRegistered": {
            "type": "boolean",
            "description": "True if this exact reference was already registered"
          }
        }
      },
      "RegisterRequest": {
        "type": "object",
        "description": "Request to register a new user account",
        "additionalProperties": false,
        "required": [
          "username",
          "password",
          "email"
        ],
        "properties": {
          "username": {
            "type": "string",
            "description": "Unique username for the account",
            "minLength": 3,
            "maxLength": 32,
            "pattern": "^[a-zA-Z0-9_]+$",
            "example": "gameuser123"
          },
          "password": {
            "type": "string",
            "description": "Password for the account (will be hashed)",
            "minLength": 8,
            "format": "password",
            "example": "SecurePassword123!"
          },
          "email": {
            "type": "string",
            "format": "email",
            "description": "Email address for account recovery and notifications",
            "example": "user@example.com"
          }
        }
      },
      "RegisterResponse": {
        "type": "object",
        "description": "Response from successful user registration",
        "additionalProperties": false,
        "required": [
          "accountId",
          "accessToken",
          "connectUrl"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the newly created account"
          },
          "accessToken": {
            "type": "string",
            "description": "JWT access token for immediate authentication",
            "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJnYW1ldXNlcjEyMyIsImlhdCI6MTY0MDk5NTIwMCwiZXhwIjoxNjQwOTk4ODAwfQ.signature"
          },
          "refreshToken": {
            "type": "string",
            "description": "Refresh token for obtaining new access tokens",
            "nullable": true,
            "example": "refresh_token_abc123xyz789"
          },
          "connectUrl": {
            "type": "string",
            "format": "uri",
            "description": "WebSocket endpoint for Connect service"
          }
        }
      },
      "RegisterRoomTypeRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to register a new room type definition",
        "required": [
          "code",
          "displayName",
          "messageFormat",
          "persistenceMode",
          "allowAnonymousSenders"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Unique room type code (e.g., \"text\", \"guild_board\", \"trade_posting\")"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable name for the room type"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Optional description of the room type"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game service scope (null for global types)"
          },
          "messageFormat": {
            "$ref": "#/components/schemas/MessageFormat",
            "description": "Content format this room type accepts"
          },
          "validatorConfig": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ValidatorConfig"
              }
            ],
            "nullable": true,
            "description": "Validation rules for messages (null uses format defaults)"
          },
          "persistenceMode": {
            "$ref": "#/components/schemas/PersistenceMode",
            "description": "Message storage mode (ephemeral or persistent)"
          },
          "defaultMaxParticipants": {
            "type": "integer",
            "nullable": true,
            "description": "Default participant limit (null uses service default)"
          },
          "retentionDays": {
            "type": "integer",
            "nullable": true,
            "description": "Message retention in days (null uses service default)"
          },
          "defaultContractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Default contract template for rooms of this type"
          },
          "allowAnonymousSenders": {
            "type": "boolean",
            "description": "Whether null senderId is allowed in messages"
          },
          "rateLimitPerMinute": {
            "type": "integer",
            "nullable": true,
            "description": "Messages per minute per participant (null uses service default)"
          },
          "metadata": {
            "type": "string",
            "nullable": true,
            "description": "Arbitrary JSON metadata for client rendering hints"
          }
        }
      },
      "RegisterSchemaRequest": {
        "type": "object",
        "description": "Request to register a new save data schema with optional migration rules",
        "required": [
          "namespace",
          "schemaVersion",
          "schema"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Schema namespace (e.g., game identifier)"
          },
          "schemaVersion": {
            "type": "string",
            "description": "Schema version identifier"
          },
          "schema": {
            "type": "object",
            "description": "JSON Schema definition for validation"
          },
          "previousVersion": {
            "type": "string",
            "nullable": true,
            "description": "Previous version this migrates from"
          },
          "migrationPatch": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/JsonPatchOperation"
            },
            "description": "JSON Patch (RFC 6902) operations to migrate from previousVersion.\nUses JsonPatch.Net library (MIT licensed).\n"
          }
        }
      },
      "RegisterSeedTypeRequest": {
        "type": "object",
        "description": "Request to register a new seed type definition.",
        "required": [
          "seedTypeCode",
          "displayName",
          "description",
          "maxPerOwner",
          "allowedOwnerTypes",
          "growthPhases",
          "bondCardinality",
          "bondPermanent"
        ],
        "properties": {
          "seedTypeCode": {
            "type": "string",
            "description": "Unique code for this seed type (e.g., \"guardian\", \"dungeon_core\")."
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game service this type is scoped to. Null for cross-game seed types that are not scoped to any single game service."
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable name."
          },
          "description": {
            "type": "string",
            "description": "Description of what this seed type represents."
          },
          "maxPerOwner": {
            "type": "integer",
            "description": "Maximum seeds of this type per owner entity."
          },
          "allowedOwnerTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Entity types that can own seeds of this type."
          },
          "growthPhases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GrowthPhaseDefinition"
            },
            "description": "Ordered growth phase definitions with thresholds."
          },
          "bondCardinality": {
            "type": "integer",
            "description": "Max bond participants. 0 = no bonding, 1 = pair bonds, N = group bonds of up to N+1 participants.\n"
          },
          "bondPermanent": {
            "type": "boolean",
            "description": "Whether bonds of this type are permanent (cannot be dissolved). True for guardian spirit pair bonds, false for dungeon-master bonds that can end when the contract dissolves.\n",
            "default": false
          },
          "capabilityRules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CapabilityRule"
            },
            "nullable": true,
            "description": "Rules for computing capabilities from growth domains."
          },
          "growthDecayEnabled": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether unused growth domains decay over time for this seed type. Falls back to global config if null."
          },
          "growthDecayRatePerDay": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "description": "Daily decay rate for unused domains of this seed type. Falls back to global config if null."
          },
          "sameOwnerGrowthMultiplier": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "default": 0.0,
            "description": "Fraction of growth applied to other seeds of the same type owned by the same entity. 0.0 = no sharing (default), 1.0 = full mirror."
          },
          "collectionGrowthMappings": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/CollectionGrowthMapping"
            },
            "description": "Mappings from collection types to growth domains. When a collection entry is unlocked for an entity that owns seeds of this type, the entry's tags are matched against these mappings to determine growth contributions. Null means this seed type does not respond to collection unlocks.\n"
          }
        }
      },
      "RelatedDepth": {
        "type": "string",
        "enum": [
          "none",
          "direct",
          "extended"
        ],
        "default": "direct",
        "description": "How deep to traverse related document links:\n- none: No related documents included\n- direct: Only directly linked documents (depth 1)\n- extended: Related documents + their related documents (depth 2)\n"
      },
      "RelationshipListResponse": {
        "description": "Paginated list of relationships with metadata for navigation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "relationships",
          "totalCount",
          "page",
          "pageSize"
        ],
        "properties": {
          "relationships": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RelationshipResponse"
            },
            "description": "List of relationships matching the query"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of relationships matching the query"
          },
          "page": {
            "type": "integer",
            "description": "Current page number (1-based)"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          },
          "hasNextPage": {
            "type": "boolean",
            "description": "Whether there are more results on the next page"
          },
          "hasPreviousPage": {
            "type": "boolean",
            "description": "Whether there are results on the previous page"
          }
        }
      },
      "RelationshipResponse": {
        "description": "Complete details of a relationship between two entities",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "relationshipId",
          "entity1Id",
          "entity1Type",
          "entity2Id",
          "entity2Type",
          "relationshipTypeId",
          "startedAt",
          "createdAt"
        ],
        "properties": {
          "relationshipId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the relationship"
          },
          "entity1Id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the first entity in the relationship"
          },
          "entity1Type": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the first entity in the relationship"
          },
          "entity2Id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the second entity in the relationship"
          },
          "entity2Type": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the second entity in the relationship"
          },
          "relationshipTypeId": {
            "type": "string",
            "format": "uuid",
            "description": "Relationship type ID defining the kind of relationship"
          },
          "startedAt": {
            "type": "string",
            "format": "date-time",
            "description": "In-game timestamp when relationship started"
          },
          "endedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "In-game timestamp when relationship ended, null if still active"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Type-specific relationship data"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "System timestamp when the relationship record was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "System timestamp when the relationship record was last updated"
          }
        }
      },
      "RelationshipSnapshot": {
        "type": "object",
        "additionalProperties": false,
        "description": "Snapshot of a relationship",
        "required": [
          "relationshipTypeCode",
          "otherEntityId",
          "otherEntityType"
        ],
        "properties": {
          "relationshipTypeCode": {
            "type": "string",
            "description": "Relationship type code"
          },
          "otherEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of other entity"
          },
          "otherEntityType": {
            "type": "string",
            "description": "Type of other entity"
          }
        }
      },
      "RelationshipTypeListResponse": {
        "description": "Response containing a list of relationship types with total count",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "types",
          "totalCount"
        ],
        "properties": {
          "types": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RelationshipTypeResponse"
            },
            "description": "List of relationship types matching the query"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of relationship types returned"
          }
        }
      },
      "RelationshipTypeResponse": {
        "description": "Complete representation of a relationship type including hierarchy, inverse, and deprecation information",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "relationshipTypeId",
          "code",
          "name",
          "isBidirectional",
          "isDeprecated",
          "depth",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "relationshipTypeId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the relationship type"
          },
          "code": {
            "type": "string",
            "description": "Unique code for the relationship type (e.g., \"SON\", \"MOTHER\")"
          },
          "name": {
            "type": "string",
            "description": "Human-readable display name for the relationship type"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Detailed description of the relationship type"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Category for grouping relationship types (e.g., \"FAMILY\", \"SOCIAL\")"
          },
          "parentTypeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of the parent type in the hierarchy (null for root types)"
          },
          "parentTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Code of the parent type (for convenience)"
          },
          "inverseTypeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of the inverse relationship type (e.g., PARENT is inverse of CHILD)"
          },
          "inverseTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Code of the inverse relationship type (for convenience)"
          },
          "isBidirectional": {
            "type": "boolean",
            "description": "Whether the relationship is the same in both directions (e.g., SIBLING)"
          },
          "isDeprecated": {
            "type": "boolean",
            "description": "Whether this type is deprecated and cannot be used for new relationships"
          },
          "deprecatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Timestamp when this type was deprecated"
          },
          "deprecationReason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for deprecation"
          },
          "depth": {
            "type": "integer",
            "description": "Depth in the hierarchy (0 for root types)"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional custom metadata for the relationship type"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the relationship type was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the relationship type was last updated"
          }
        }
      },
      "ReleaseAllocation": {
        "type": "object",
        "description": "Defines who gets what on release",
        "required": [
          "recipientPartyId",
          "recipientPartyType",
          "assets"
        ],
        "properties": {
          "recipientPartyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party receiving assets"
          },
          "recipientPartyType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the recipient party"
          },
          "assets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAsset"
            },
            "description": "Assets this recipient should receive"
          },
          "destinationWalletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Where to deliver currency"
          },
          "destinationContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Where to deliver items"
          }
        }
      },
      "ReleaseAllocationInput": {
        "type": "object",
        "description": "Input for specifying how assets should be allocated on release",
        "required": [
          "recipientPartyId",
          "recipientPartyType",
          "assets"
        ],
        "properties": {
          "recipientPartyId": {
            "type": "string",
            "format": "uuid",
            "description": "Recipient party ID"
          },
          "recipientPartyType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Recipient party type"
          },
          "assets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAssetInput"
            },
            "description": "Assets to allocate"
          },
          "destinationWalletId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Destination wallet"
          },
          "destinationContainerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Destination container"
          }
        }
      },
      "ReleaseHoldRequest": {
        "type": "object",
        "description": "Request to release a hold",
        "additionalProperties": false,
        "required": [
          "holdId"
        ],
        "properties": {
          "holdId": {
            "type": "string",
            "format": "uuid",
            "description": "Hold ID to release"
          }
        }
      },
      "ReleaseMode": {
        "type": "string",
        "description": "Controls how release confirmation is handled:\n- immediate: Finalizing \u2192 Released (skip Releasing state entirely).\n  \u26a0\ufe0f WARNING: Use only for trusted/low-value scenarios (NPC vendors, system rewards).\n  Assets are marked as released BEFORE downstream services confirm transfers.\n  If downstream services fail, manual intervention may be required.\n- service_only: Wait for downstream services (currency, inventory) to confirm transfers complete.\n- party_required: Wait for all parties to call /confirm-release.\n- service_and_party: Wait for both service completion AND party confirmation.\n",
        "enum": [
          "immediate",
          "service_only",
          "party_required",
          "service_and_party"
        ]
      },
      "ReleaseRequest": {
        "type": "object",
        "description": "Request to trigger escrow release to recipients",
        "required": [
          "escrowId",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "initiatorServiceId": {
            "type": "string",
            "nullable": true,
            "description": "For initiator_trusted mode"
          },
          "notes": {
            "type": "string",
            "nullable": true,
            "description": "Optional notes"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "ReleaseResponse": {
        "type": "object",
        "description": "Response from releasing escrow assets to recipients",
        "required": [
          "escrow",
          "finalizerResults",
          "releases"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Released escrow agreement"
          },
          "finalizerResults": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FinalizerResult"
            },
            "description": "Results of contract finalizer APIs"
          },
          "releases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ReleaseResult"
            },
            "description": "Release results per recipient"
          }
        }
      },
      "ReleaseResult": {
        "type": "object",
        "description": "Result of releasing assets to a single recipient",
        "required": [
          "recipientPartyId",
          "success"
        ],
        "properties": {
          "recipientPartyId": {
            "type": "string",
            "format": "uuid",
            "description": "Recipient party ID"
          },
          "assets": {
            "$ref": "#/components/schemas/EscrowAssetBundle",
            "description": "Assets released (null if failed)",
            "nullable": true
          },
          "success": {
            "type": "boolean",
            "description": "Whether release succeeded"
          },
          "error": {
            "type": "string",
            "nullable": true,
            "description": "Error message if failed"
          }
        }
      },
      "ReleaseTerritoryRequest": {
        "type": "object",
        "description": "Request to release a territory claim",
        "additionalProperties": false,
        "required": [
          "claimId"
        ],
        "properties": {
          "claimId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the territory claim to release"
          }
        }
      },
      "RemoveByCategoryRequest": {
        "type": "object",
        "description": "Request to remove all statuses of a category for an entity (cleanse)",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "category",
          "reason"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity to cleanse statuses from"
          },
          "entityType": {
            "type": "string",
            "description": "Entity type discriminator"
          },
          "category": {
            "$ref": "#/components/schemas/StatusCategory",
            "description": "Category of statuses to remove"
          },
          "reason": {
            "$ref": "#/components/schemas/StatusRemoveReason",
            "description": "Why these statuses are being removed"
          }
        }
      },
      "RemoveBySourceRequest": {
        "type": "object",
        "description": "Request to remove all statuses from a specific source for an entity",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "sourceId"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity to remove statuses from"
          },
          "entityType": {
            "type": "string",
            "description": "Entity type discriminator"
          },
          "sourceId": {
            "type": "string",
            "format": "uuid",
            "description": "Source that originally granted the statuses"
          }
        }
      },
      "RemoveItemRequest": {
        "type": "object",
        "description": "Request to remove item from container",
        "additionalProperties": false,
        "required": [
          "instanceId"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance ID to remove"
          }
        }
      },
      "RemoveItemResponse": {
        "type": "object",
        "description": "Response after removing item",
        "additionalProperties": false,
        "required": [
          "success",
          "instanceId",
          "previousContainerId"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether remove succeeded"
          },
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Removed item ID"
          },
          "previousContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container removed from"
          }
        }
      },
      "RemoveLicenseDefinitionRequest": {
        "type": "object",
        "description": "Request to remove a license definition from a board template",
        "additionalProperties": false,
        "required": [
          "boardTemplateId",
          "code"
        ],
        "properties": {
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template containing the definition"
          },
          "code": {
            "type": "string",
            "description": "License code to remove"
          }
        }
      },
      "RemoveMemberRequest": {
        "type": "object",
        "description": "Request to remove a character from a faction",
        "additionalProperties": false,
        "required": [
          "factionId",
          "characterId"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction to remove the character from"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to remove"
          }
        }
      },
      "RemoveStatusRequest": {
        "type": "object",
        "description": "Request to remove a specific status instance",
        "additionalProperties": false,
        "required": [
          "statusInstanceId",
          "reason"
        ],
        "properties": {
          "statusInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Status instance to remove"
          },
          "reason": {
            "$ref": "#/components/schemas/StatusRemoveReason",
            "description": "Why this status is being removed"
          }
        }
      },
      "RemoveStatusesResponse": {
        "type": "object",
        "description": "Result of a bulk status removal operation",
        "additionalProperties": false,
        "required": [
          "statusesRemoved"
        ],
        "properties": {
          "statusesRemoved": {
            "type": "integer",
            "description": "Number of status instances removed"
          }
        }
      },
      "RenameSlotRequest": {
        "type": "object",
        "description": "Request to rename an existing save slot",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName",
          "newSlotName"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game identifier"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity ID that owns the slot"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Current slot name"
          },
          "newSlotName": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64,
            "pattern": "^[a-z0-9]([a-z0-9-]*[a-z0-9])?$",
            "description": "New slot name"
          }
        }
      },
      "ReportBreachRequest": {
        "type": "object",
        "description": "Request to report a breach",
        "additionalProperties": false,
        "required": [
          "contractId",
          "breachingEntityId",
          "breachingEntityType",
          "breachType"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract that was breached"
          },
          "breachingEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity that breached"
          },
          "breachingEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of breaching entity"
          },
          "breachType": {
            "$ref": "#/components/schemas/BreachType",
            "description": "Type of breach"
          },
          "breachedTermOrMilestone": {
            "type": "string",
            "nullable": true,
            "description": "Code of breached term or milestone"
          },
          "description": {
            "type": "string",
            "maxLength": 2000,
            "nullable": true,
            "description": "Breach description"
          }
        }
      },
      "ReportEntityPositionRequest": {
        "description": "Request to report an entity's presence at a location",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "entityType",
          "entityId",
          "locationId"
        ],
        "properties": {
          "entityType": {
            "type": "string",
            "description": "Type of entity (opaque string - character, actor, npc, player, etc.)"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the entity being reported"
          },
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the location the entity is at"
          },
          "previousLocationId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Caller hint for the entity's previous location (optimization to skip GET on refresh)"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of the realm the location belongs to (included in arrival events if provided)"
          },
          "reportedBy": {
            "type": "string",
            "nullable": true,
            "description": "Identifier of the reporter (service name or session ID)"
          }
        }
      },
      "ReportEntityPositionResponse": {
        "description": "Result of reporting entity presence",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "recorded"
        ],
        "properties": {
          "recorded": {
            "type": "boolean",
            "description": "Whether the position was successfully recorded"
          },
          "arrivedAt": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Location ID the entity arrived at (only set when location changed)"
          },
          "departedFrom": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Location ID the entity departed from (only set when location changed)"
          }
        }
      },
      "ReportProgressRequest": {
        "type": "object",
        "description": "Request to report progress on a quest objective",
        "additionalProperties": false,
        "required": [
          "questInstanceId",
          "objectiveCode",
          "incrementBy"
        ],
        "properties": {
          "questInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Quest instance"
          },
          "objectiveCode": {
            "type": "string",
            "description": "Objective code"
          },
          "incrementBy": {
            "type": "integer",
            "description": "Amount to increment progress"
          },
          "trackedEntityId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Entity that contributed to progress (for deduplication)"
          }
        }
      },
      "RepositoryBindingInfo": {
        "description": "Detailed repository binding configuration and status",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "bindingId",
          "namespace",
          "repositoryUrl",
          "status"
        ],
        "properties": {
          "bindingId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the repository binding"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace the repository is bound to"
          },
          "repositoryUrl": {
            "type": "string",
            "description": "URL of the bound repository"
          },
          "branch": {
            "type": "string",
            "description": "Branch being synced"
          },
          "status": {
            "$ref": "#/components/schemas/BindingStatus",
            "description": "Current status of the binding"
          },
          "syncEnabled": {
            "type": "boolean",
            "description": "Whether automatic sync is enabled"
          },
          "syncIntervalMinutes": {
            "type": "integer",
            "description": "Sync interval in minutes"
          },
          "documentCount": {
            "type": "integer",
            "description": "Number of documents from this repository"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the binding was created"
          },
          "owner": {
            "type": "string",
            "description": "Owner of this binding. NOT a session ID.\nContains either an accountId (UUID format) for user-initiated bindings\nor a service name for service-initiated bindings.\n"
          }
        }
      },
      "RepositoryStatusRequest": {
        "description": "Request to get current repository binding and sync status",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to get status for"
          }
        }
      },
      "RepositoryStatusResponse": {
        "description": "Response containing binding configuration and recent sync information",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "binding": {
            "$ref": "#/components/schemas/RepositoryBindingInfo",
            "description": "Current binding configuration and status"
          },
          "lastSync": {
            "$ref": "#/components/schemas/SyncInfo",
            "description": "Information about the most recent sync"
          }
        }
      },
      "RequestSnapshotRequest": {
        "type": "object",
        "description": "Request for full snapshot",
        "required": [
          "regionId"
        ],
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region to snapshot"
          },
          "kinds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapKind"
            },
            "description": "Which kinds to include (default all)",
            "nullable": true
          },
          "bounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "Optional bounds filter",
            "nullable": true
          },
          "authorityToken": {
            "type": "string",
            "description": "Optional authority token. If provided and valid, clears the\nRequiresConsumeBeforePublish flag for require_consume takeover mode.\n",
            "nullable": true
          }
        }
      },
      "RequestSnapshotResponse": {
        "type": "object",
        "description": "Snapshot response",
        "properties": {
          "regionId": {
            "type": "string",
            "format": "uuid",
            "description": "Region ID"
          },
          "objects": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MapObject"
            },
            "description": "All objects in snapshot"
          },
          "payloadRef": {
            "type": "string",
            "description": "For large snapshots, lib-asset reference",
            "nullable": true
          },
          "version": {
            "type": "integer",
            "format": "int64",
            "description": "Snapshot version"
          }
        }
      },
      "ReservationInfo": {
        "type": "object",
        "description": "Reservation token returned when creating a matchmade session",
        "additionalProperties": false,
        "required": [
          "accountId",
          "token",
          "expiresAt"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account ID this reservation is for"
          },
          "token": {
            "type": "string",
            "description": "Token to claim this reservation"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this reservation expires"
          }
        }
      },
      "ResolveBundlesRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to resolve optimal bundle downloads for requested assets",
        "required": [
          "assetIds",
          "realm"
        ],
        "properties": {
          "assetIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Platform asset IDs to resolve"
          },
          "realm": {
            "$ref": "#/components/schemas/GameRealm",
            "description": "Game realm to search within"
          },
          "preferMetabundles": {
            "type": "boolean",
            "default": true,
            "description": "Prefer metabundles when coverage is equal"
          },
          "includeStandalone": {
            "type": "boolean",
            "default": true,
            "description": "Include standalone assets not in any bundle"
          },
          "maxBundles": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum number of bundles to return (optimization limit)"
          }
        }
      },
      "ResolveBundlesResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Optimal bundle set for requested assets",
        "required": [
          "bundles",
          "standaloneAssets",
          "coverage"
        ],
        "properties": {
          "bundles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResolvedBundle"
            },
            "description": "Bundles to download"
          },
          "standaloneAssets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResolvedAsset"
            },
            "description": "Individual assets to download"
          },
          "coverage": {
            "$ref": "#/components/schemas/CoverageAnalysis",
            "description": "Coverage statistics"
          },
          "unresolved": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Asset IDs that couldn't be found (null if all resolved)"
          }
        }
      },
      "ResolveRequest": {
        "type": "object",
        "description": "Request for arbiter to resolve a disputed escrow",
        "required": [
          "escrowId",
          "arbiterId",
          "arbiterType",
          "resolution",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "arbiterId": {
            "type": "string",
            "format": "uuid",
            "description": "Arbiter ID"
          },
          "arbiterType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Arbiter type"
          },
          "resolution": {
            "$ref": "#/components/schemas/EscrowResolution",
            "description": "Resolution decision for the dispute"
          },
          "splitAllocations": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/SplitAllocation"
            },
            "description": "For split resolution"
          },
          "notes": {
            "type": "string",
            "nullable": true,
            "description": "Resolution notes"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "ResolveResponse": {
        "type": "object",
        "description": "Response from arbiter resolving a disputed escrow",
        "required": [
          "escrow",
          "transfers"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Resolved escrow agreement"
          },
          "transfers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransferResult"
            },
            "description": "Transfer results"
          }
        }
      },
      "ResolvedAsset": {
        "type": "object",
        "additionalProperties": false,
        "description": "A standalone asset selected for download",
        "required": [
          "assetId",
          "downloadUrl",
          "expiresAt",
          "size"
        ],
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Asset identifier"
          },
          "downloadUrl": {
            "type": "string",
            "format": "uri",
            "description": "Pre-signed download URL"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the download URL expires"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "Asset file size in bytes"
          },
          "contentHash": {
            "type": "string",
            "nullable": true,
            "description": "SHA256 hash of asset content"
          }
        }
      },
      "ResolvedBundle": {
        "type": "object",
        "additionalProperties": false,
        "description": "A bundle selected for download in resolution",
        "required": [
          "bundleId",
          "bundleType",
          "downloadUrl",
          "expiresAt",
          "size",
          "assetsProvided"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier"
          },
          "bundleType": {
            "$ref": "#/components/schemas/BundleType",
            "description": "Whether source or metabundle"
          },
          "version": {
            "type": "string",
            "nullable": true,
            "description": "Bundle version"
          },
          "downloadUrl": {
            "type": "string",
            "format": "uri",
            "description": "Pre-signed download URL"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the download URL expires"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "Bundle file size in bytes"
          },
          "assetsProvided": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Which of the requested assets this bundle provides"
          }
        }
      },
      "ResolvedReference": {
        "type": "object",
        "description": "A successfully resolved scene reference",
        "required": [
          "nodeId",
          "refId",
          "referencedSceneId",
          "scene"
        ],
        "properties": {
          "nodeId": {
            "type": "string",
            "format": "uuid",
            "description": "Node ID containing the reference"
          },
          "refId": {
            "type": "string",
            "description": "refId of the referencing node"
          },
          "referencedSceneId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the referenced scene"
          },
          "referencedVersion": {
            "type": "string",
            "nullable": true,
            "description": "Version that was resolved"
          },
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "The resolved scene content"
          },
          "depth": {
            "type": "integer",
            "description": "Depth level of this reference"
          }
        }
      },
      "ResourceArchive": {
        "type": "object",
        "additionalProperties": false,
        "description": "Bundled compressed archive",
        "required": [
          "archiveId",
          "resourceType",
          "resourceId",
          "version",
          "entries",
          "createdAt",
          "sourceDataDeleted"
        ],
        "properties": {
          "archiveId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this archive"
          },
          "resourceType": {
            "type": "string",
            "description": "Type of resource archived"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource archived"
          },
          "version": {
            "type": "integer",
            "description": "Archive version (increments on re-compression)"
          },
          "entries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ArchiveBundleEntry"
            },
            "description": "Data entries from each compression callback"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this archive was created"
          },
          "sourceDataDeleted": {
            "type": "boolean",
            "description": "Whether original source data was deleted after archival"
          }
        }
      },
      "ResourceArchiveBase": {
        "type": "object",
        "description": "Base schema for all resource archives that can be stored in\nthe resource service's archive bundles and consumed by the\nstoryline SDK's ArchiveExtractor.\n\nArchives implementing this base schema are marked with\nx-archive-type: true and are automatically collected by\nthe archive generation script for SDK model generation.\n",
        "required": [
          "resourceId",
          "resourceType",
          "archivedAt",
          "schemaVersion"
        ],
        "properties": {
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the archived resource"
          },
          "resourceType": {
            "type": "string",
            "description": "Type identifier (e.g., \"character\", \"character-personality\", \"realm-history\")"
          },
          "archivedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this archive was created"
          },
          "schemaVersion": {
            "type": "integer",
            "minimum": 1,
            "description": "Schema version for forward compatibility migration"
          },
          "nestedArchives": {
            "type": "array",
            "description": "Child archives from dependent resources (populated by lib-resource compression)",
            "items": {
              "$ref": "#/components/schemas/ResourceArchiveBase"
            }
          }
        }
      },
      "ResourceReference": {
        "type": "object",
        "additionalProperties": false,
        "description": "A reference from a source entity to a resource",
        "required": [
          "sourceType",
          "sourceId",
          "registeredAt"
        ],
        "properties": {
          "sourceType": {
            "type": "string",
            "description": "Type of entity holding the reference (opaque identifier)"
          },
          "sourceId": {
            "type": "string",
            "description": "ID of the entity holding the reference (opaque string, supports non-Guid IDs)"
          },
          "registeredAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this reference was registered"
          }
        }
      },
      "ResourceSnapshot": {
        "type": "object",
        "additionalProperties": false,
        "description": "Ephemeral snapshot of a living resource",
        "required": [
          "snapshotId",
          "resourceType",
          "resourceId",
          "snapshotType",
          "entries",
          "createdAt",
          "expiresAt"
        ],
        "properties": {
          "snapshotId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this snapshot"
          },
          "resourceType": {
            "type": "string",
            "description": "Type of resource snapshotted"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource snapshotted"
          },
          "snapshotType": {
            "type": "string",
            "description": "Label for snapshot purpose (e.g., \"storyline_seed\")"
          },
          "entries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ArchiveBundleEntry"
            },
            "description": "Data entries from each compression callback (same format as archives)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this snapshot was created"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this snapshot will expire"
          }
        }
      },
      "ResponseValidation": {
        "type": "object",
        "description": "Validation rules for API responses with three-outcome model.\nUsed by lib-contract to validate clause conditions without\nunderstanding the specific API semantics.\n",
        "additionalProperties": false,
        "properties": {
          "successConditions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationCondition"
            },
            "description": "Conditions that must ALL pass for success.\nIf any fail, checks permanent failure conditions.\n"
          },
          "permanentFailureConditions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationCondition"
            },
            "description": "Conditions that indicate permanent failure (clause violated).\nChecked when success conditions fail.\n"
          },
          "transientFailureStatusCodes": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "HTTP status codes that indicate transient failure (retry later).\nDefault: [408, 429, 502, 503, 504]\n"
          }
        }
      },
      "RestoreBundleRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to restore a soft-deleted bundle",
        "required": [
          "bundleId"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier to restore"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for restoration (recorded in version history)"
          }
        }
      },
      "RestoreBundleResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of bundle restoration",
        "required": [
          "bundleId",
          "status",
          "restoredAt",
          "restoredFromVersion"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier that was restored"
          },
          "status": {
            "type": "string",
            "description": "Current bundle status (should be \"active\")"
          },
          "restoredAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the bundle was restored"
          },
          "restoredFromVersion": {
            "type": "integer",
            "description": "Version number the bundle was restored from"
          }
        }
      },
      "RevokeBlessingRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to revoke an active blessing",
        "required": [
          "blessingId",
          "reason"
        ],
        "properties": {
          "blessingId": {
            "type": "string",
            "format": "uuid",
            "description": "Blessing to revoke"
          },
          "reason": {
            "type": "string",
            "description": "Why the blessing is being revoked"
          }
        }
      },
      "RewardDefinition": {
        "type": "object",
        "description": "Reward granted when a quest is completed",
        "additionalProperties": false,
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "CURRENCY",
              "ITEM",
              "EXPERIENCE",
              "REPUTATION"
            ],
            "description": "Type of reward"
          },
          "currencyCode": {
            "type": "string",
            "nullable": true,
            "description": "Currency code for CURRENCY rewards"
          },
          "amount": {
            "type": "integer",
            "nullable": true,
            "description": "Amount for CURRENCY/EXPERIENCE rewards"
          },
          "itemCode": {
            "type": "string",
            "nullable": true,
            "description": "Item code for ITEM rewards"
          },
          "quantity": {
            "type": "integer",
            "nullable": true,
            "description": "Quantity for ITEM rewards"
          },
          "factionCode": {
            "type": "string",
            "nullable": true,
            "description": "Faction code for REPUTATION rewards"
          }
        }
      },
      "RoomTypeResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Room type definition with current configuration and status",
        "required": [
          "code",
          "displayName",
          "messageFormat",
          "persistenceMode",
          "allowAnonymousSenders",
          "status",
          "createdAt"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Unique room type code"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Room type description"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game service scope (null for global)"
          },
          "messageFormat": {
            "$ref": "#/components/schemas/MessageFormat",
            "description": "Content format accepted by this room type"
          },
          "validatorConfig": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ValidatorConfig"
              }
            ],
            "nullable": true,
            "description": "Active validation rules"
          },
          "persistenceMode": {
            "$ref": "#/components/schemas/PersistenceMode",
            "description": "Message storage mode"
          },
          "defaultMaxParticipants": {
            "type": "integer",
            "nullable": true,
            "description": "Default participant limit"
          },
          "retentionDays": {
            "type": "integer",
            "nullable": true,
            "description": "Message retention in days"
          },
          "defaultContractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Default contract template ID"
          },
          "allowAnonymousSenders": {
            "type": "boolean",
            "description": "Whether anonymous senders are allowed"
          },
          "rateLimitPerMinute": {
            "type": "integer",
            "nullable": true,
            "description": "Messages per minute limit"
          },
          "metadata": {
            "type": "string",
            "nullable": true,
            "description": "Arbitrary JSON metadata"
          },
          "status": {
            "$ref": "#/components/schemas/RoomTypeStatus",
            "description": "Current lifecycle status of the room type"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the room type was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the room type was last updated"
          }
        }
      },
      "RoomTypeStatus": {
        "type": "string",
        "description": "Lifecycle status of a room type definition",
        "enum": [
          "Active",
          "Deprecated"
        ]
      },
      "SEOMetadata": {
        "description": "Search engine optimization and social media sharing metadata",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Meta description for search engines"
          },
          "keywords": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Keywords for search engine indexing"
          },
          "ogTitle": {
            "type": "string",
            "nullable": true,
            "description": "Open Graph title for social media sharing"
          },
          "ogDescription": {
            "type": "string",
            "nullable": true,
            "description": "Open Graph description for social media sharing"
          },
          "ogImage": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "Open Graph image URL for social media sharing"
          }
        }
      },
      "SaveCategory": {
        "type": "string",
        "enum": [
          "QUICK_SAVE",
          "AUTO_SAVE",
          "MANUAL_SAVE",
          "CHECKPOINT",
          "STATE_SNAPSHOT"
        ],
        "description": "Category of save with predefined behaviors.\nQUICK_SAVE: Single-slot fast save, overwritten frequently (max 1 version).\nAUTO_SAVE: System-triggered periodic saves (max 5 versions, rolling).\nMANUAL_SAVE: User-initiated named saves (max 10 versions, no auto-cleanup).\nCHECKPOINT: Progress markers (max 20 versions, rolling).\nSTATE_SNAPSHOT: Full state captures for debugging (max 3 versions, rolling).\n"
      },
      "SaveDeltaRequest": {
        "type": "object",
        "description": "Request to save incremental changes as a delta from a base version",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName",
          "baseVersion",
          "delta"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Name of the slot to save the delta to"
          },
          "baseVersion": {
            "type": "integer",
            "description": "Version number this delta is based on"
          },
          "delta": {
            "type": "string",
            "format": "byte",
            "description": "Base64-encoded delta/patch data.\nFor JSON_PATCH: Array of RFC 6902 operations\nFor BSDIFF/XDELTA: Binary patch data\n"
          },
          "algorithm": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DeltaAlgorithm"
              }
            ],
            "nullable": true,
            "description": "Delta computation algorithm to use (defaults to JSON_PATCH)"
          },
          "schemaVersion": {
            "type": "string",
            "nullable": true,
            "description": "Schema version of this save for migration tracking"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable name for this delta save"
          },
          "deviceId": {
            "type": "string",
            "nullable": true,
            "description": "Device identifier for cross-device sync conflict detection"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom key-value metadata for this delta version"
          }
        }
      },
      "SaveDeltaResponse": {
        "type": "object",
        "description": "Result of delta save operation with size and chain information",
        "required": [
          "slotId",
          "versionNumber",
          "baseVersion",
          "deltaSizeBytes",
          "estimatedFullSizeBytes",
          "createdAt"
        ],
        "properties": {
          "slotId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the save slot"
          },
          "versionNumber": {
            "type": "integer",
            "description": "New version number"
          },
          "baseVersion": {
            "type": "integer",
            "description": "Base version this delta is relative to"
          },
          "deltaSizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Size of stored delta"
          },
          "estimatedFullSizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Estimated size when reconstructed"
          },
          "chainLength": {
            "type": "integer",
            "description": "Number of deltas in chain to base snapshot"
          },
          "compressionSavings": {
            "type": "number",
            "format": "double",
            "description": "Storage savings vs full snapshot (0-1)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the delta version was created"
          }
        }
      },
      "SaveRequest": {
        "type": "object",
        "description": "Request to save game state data to a slot with optional compression and metadata",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName",
          "data"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name (auto-created if doesn't exist)"
          },
          "category": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SaveCategory"
              }
            ],
            "nullable": true,
            "description": "Category for auto-created slots (defaults to MANUAL_SAVE)"
          },
          "data": {
            "type": "string",
            "format": "byte",
            "description": "Base64-encoded save data"
          },
          "schemaVersion": {
            "type": "string",
            "nullable": true,
            "description": "Schema version identifier for migration tracking"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "maxLength": 128,
            "description": "Human-readable name for this save"
          },
          "thumbnail": {
            "type": "string",
            "format": "byte",
            "nullable": true,
            "description": "Optional preview image (JPEG/WebP). Max size configurable\n(default 256KB). Used for save slot previews in game UI.\n"
          },
          "deviceId": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Optional device identifier for cloud save conflict detection.\nWhen provided, saves are prefixed/tagged with device info,\nenabling opt-in cross-device sync with collision awareness.\n"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom metadata (e.g., level, playtime, location)"
          },
          "pinAsCheckpoint": {
            "type": "string",
            "nullable": true,
            "maxLength": 64,
            "description": "If provided, pin this version with checkpoint name"
          }
        }
      },
      "SaveResponse": {
        "type": "object",
        "description": "Result of a save operation including version info and conflict detection",
        "required": [
          "slotId",
          "versionNumber",
          "contentHash",
          "sizeBytes",
          "createdAt"
        ],
        "properties": {
          "slotId": {
            "type": "string",
            "format": "uuid",
            "description": "Slot identifier"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Assigned version number"
          },
          "contentHash": {
            "type": "string",
            "description": "SHA-256 hash of save data"
          },
          "sizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Size of save data in bytes"
          },
          "compressedSizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Compressed size (if compression applied)"
          },
          "compressionRatio": {
            "type": "number",
            "format": "double",
            "description": "Compression ratio (0-1)"
          },
          "pinned": {
            "type": "boolean",
            "description": "Whether version was pinned"
          },
          "checkpointName": {
            "type": "string",
            "nullable": true,
            "description": "Checkpoint name if pinned"
          },
          "thumbnailUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "Pre-signed URL to retrieve thumbnail (if provided)"
          },
          "conflictDetected": {
            "type": "boolean",
            "description": "True if this save overwrote a version from a different device.\nOnly relevant when deviceId is used for cloud sync.\n"
          },
          "conflictingDeviceId": {
            "type": "string",
            "nullable": true,
            "description": "Device ID of the overwritten version (if conflict)"
          },
          "conflictingVersion": {
            "type": "integer",
            "nullable": true,
            "description": "Version number that was overwritten (if conflict)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Save timestamp"
          },
          "versionsCleanedUp": {
            "type": "integer",
            "description": "Number of old versions cleaned up by rolling policy"
          },
          "uploadPending": {
            "type": "boolean",
            "description": "True if async upload is enabled and data is queued for MinIO upload.\nSave is immediately loadable from Redis cache, but not yet durable.\n"
          }
        }
      },
      "ScenarioCategory": {
        "type": "string",
        "enum": [
          "Combat",
          "Crafting",
          "Social",
          "Trade",
          "Exploration",
          "Magic",
          "Survival",
          "Mixed",
          "Narrative",
          "Tutorial"
        ],
        "description": "Primary gameplay category for a scenario template"
      },
      "ScenarioChaining": {
        "type": "object",
        "description": "Chaining configuration for linking scenarios together",
        "properties": {
          "leadsTo": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Template codes this scenario can chain into"
          },
          "chainProbabilities": {
            "type": "object",
            "additionalProperties": {
              "type": "number",
              "format": "float"
            },
            "nullable": true,
            "description": "Per-code probability weights for chain selection"
          },
          "maxChainDepth": {
            "type": "integer",
            "default": 3,
            "description": "Maximum chain depth allowed from the initial scenario"
          }
        }
      },
      "ScenarioCompletionResponse": {
        "type": "object",
        "description": "Response after completing a scenario",
        "required": [
          "scenarioInstanceId",
          "growthAwarded",
          "returnToGarden"
        ],
        "properties": {
          "scenarioInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Completed scenario instance ID"
          },
          "growthAwarded": {
            "type": "object",
            "additionalProperties": {
              "type": "number",
              "format": "float"
            },
            "description": "Growth awarded per domain"
          },
          "returnToGarden": {
            "type": "boolean",
            "description": "Whether the player should return to the garden"
          }
        }
      },
      "ScenarioContent": {
        "type": "object",
        "description": "Content references linking a scenario template to game assets",
        "properties": {
          "behaviorDocumentId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ABML behavior document ID for NPC orchestration"
          },
          "sceneDocumentId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Scene document ID for environment composition"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm ID where this scenario takes place"
          },
          "locationCode": {
            "type": "string",
            "nullable": true,
            "description": "Location code within the realm"
          }
        }
      },
      "ScenarioDefinition": {
        "type": "object",
        "additionalProperties": false,
        "description": "A scenario definition template that can be triggered when conditions are met",
        "required": [
          "scenarioId",
          "code",
          "name",
          "triggerConditions",
          "phases",
          "priority",
          "enabled",
          "createdAt"
        ],
        "properties": {
          "scenarioId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique scenario definition identifier"
          },
          "code": {
            "type": "string",
            "minLength": 1,
            "maxLength": 100,
            "description": "Human-readable scenario code (uppercase with underscores)"
          },
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 200,
            "description": "Display name for the scenario"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Detailed scenario description"
          },
          "triggerConditions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TriggerCondition"
            },
            "minItems": 1,
            "description": "Conditions that must ALL be met to trigger (AND logic)"
          },
          "phases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScenarioPhase"
            },
            "minItems": 1,
            "description": "Execution phases in order"
          },
          "mutations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScenarioMutation"
            },
            "nullable": true,
            "description": "State mutations to apply on completion"
          },
          "questHooks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScenarioQuestHook"
            },
            "nullable": true,
            "description": "Quests to spawn on completion"
          },
          "cooldownSeconds": {
            "type": "integer",
            "minimum": 0,
            "nullable": true,
            "description": "Per-character cooldown in seconds (null uses default from config)"
          },
          "exclusivityTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Tags for mutual exclusivity checking"
          },
          "priority": {
            "type": "integer",
            "default": 0,
            "description": "Higher priority scenarios are checked first"
          },
          "enabled": {
            "type": "boolean",
            "default": true,
            "description": "Whether scenario can be triggered"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm scope (null means all realms)"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game service scope (null means all games)"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Classification tags for filtering"
          },
          "deprecated": {
            "type": "boolean",
            "default": false,
            "description": "Whether scenario is soft-deleted"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When definition was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When definition was last modified"
          },
          "etag": {
            "type": "string",
            "nullable": true,
            "description": "ETag for optimistic concurrency"
          }
        }
      },
      "ScenarioDefinitionSummary": {
        "type": "object",
        "additionalProperties": false,
        "description": "Summary of a scenario definition",
        "required": [
          "scenarioId",
          "code",
          "name",
          "priority",
          "enabled",
          "createdAt"
        ],
        "properties": {
          "scenarioId": {
            "type": "string",
            "format": "uuid",
            "description": "Scenario identifier"
          },
          "code": {
            "type": "string",
            "description": "Scenario code"
          },
          "name": {
            "type": "string",
            "description": "Scenario name"
          },
          "priority": {
            "type": "integer",
            "description": "Scenario priority"
          },
          "enabled": {
            "type": "boolean",
            "description": "Whether enabled"
          },
          "deprecated": {
            "type": "boolean",
            "description": "Whether deprecated"
          },
          "conditionCount": {
            "type": "integer",
            "description": "Number of trigger conditions"
          },
          "phaseCount": {
            "type": "integer",
            "description": "Number of phases"
          },
          "mutationCount": {
            "type": "integer",
            "description": "Number of mutations"
          },
          "questHookCount": {
            "type": "integer",
            "description": "Number of quest hooks"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm scope"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game service scope"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Classification tags"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When created"
          }
        }
      },
      "ScenarioExecution": {
        "type": "object",
        "additionalProperties": false,
        "description": "A scenario execution instance",
        "required": [
          "executionId",
          "scenarioId",
          "code",
          "name",
          "status",
          "currentPhase",
          "totalPhases",
          "triggeredAt"
        ],
        "properties": {
          "executionId": {
            "type": "string",
            "format": "uuid",
            "description": "Execution instance ID"
          },
          "scenarioId": {
            "type": "string",
            "format": "uuid",
            "description": "Scenario definition ID"
          },
          "code": {
            "type": "string",
            "description": "Scenario code"
          },
          "name": {
            "type": "string",
            "description": "Scenario name"
          },
          "status": {
            "$ref": "#/components/schemas/ScenarioStatus",
            "description": "Current status"
          },
          "currentPhase": {
            "type": "integer",
            "description": "Current phase number"
          },
          "totalPhases": {
            "type": "integer",
            "description": "Total phases"
          },
          "triggeredAt": {
            "type": "string",
            "format": "date-time",
            "description": "When triggered"
          },
          "completedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When completed (if applicable)"
          }
        }
      },
      "ScenarioMultiplayer": {
        "type": "object",
        "description": "Multiplayer configuration for group scenarios",
        "required": [
          "minPlayers",
          "maxPlayers"
        ],
        "properties": {
          "minPlayers": {
            "type": "integer",
            "description": "Minimum number of players required"
          },
          "maxPlayers": {
            "type": "integer",
            "description": "Maximum number of players allowed"
          },
          "matchmakingQueueCode": {
            "type": "string",
            "nullable": true,
            "description": "Matchmaking queue code for automatic grouping"
          },
          "bondPreferred": {
            "type": "boolean",
            "default": false,
            "description": "Whether bonded players receive a scoring boost for this scenario"
          }
        }
      },
      "ScenarioMutation": {
        "type": "object",
        "additionalProperties": false,
        "description": "A state mutation to apply during scenario execution",
        "required": [
          "mutationType"
        ],
        "properties": {
          "mutationType": {
            "$ref": "#/components/schemas/MutationType",
            "description": "Type of mutation to apply"
          },
          "experienceType": {
            "type": "string",
            "nullable": true,
            "description": "Experience type for PersonalityEvolve (e.g., TRAUMA, VICTORY)"
          },
          "experienceIntensity": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Experience intensity for PersonalityEvolve (0.0-1.0)"
          },
          "backstoryElementType": {
            "type": "string",
            "nullable": true,
            "description": "Backstory element type for BackstoryAdd (e.g., TRAUMA, GOAL)"
          },
          "backstoryKey": {
            "type": "string",
            "nullable": true,
            "description": "Backstory element key for BackstoryAdd"
          },
          "backstoryValue": {
            "type": "string",
            "nullable": true,
            "description": "Backstory element value for BackstoryAdd"
          },
          "backstoryStrength": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "nullable": true,
            "description": "Backstory element strength for BackstoryAdd (0.0-1.0)"
          },
          "relationshipTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Relationship type code for RelationshipCreate/End"
          },
          "otherParticipantRole": {
            "type": "string",
            "nullable": true,
            "description": "Role name for other participant in multi-character scenarios"
          }
        }
      },
      "ScenarioPhase": {
        "type": "object",
        "additionalProperties": false,
        "description": "A phase in scenario execution",
        "required": [
          "phaseNumber",
          "name"
        ],
        "properties": {
          "phaseNumber": {
            "type": "integer",
            "minimum": 1,
            "description": "Phase sequence number (1-based)"
          },
          "name": {
            "type": "string",
            "description": "Phase name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "What happens in this phase"
          },
          "durationSeconds": {
            "type": "integer",
            "nullable": true,
            "description": "Expected duration in seconds (for pacing, not enforced)"
          },
          "dialogueHint": {
            "type": "string",
            "nullable": true,
            "description": "Hint for dialogue generation system"
          },
          "actionHint": {
            "type": "string",
            "nullable": true,
            "description": "Hint for behavior/GOAP system"
          }
        }
      },
      "ScenarioPrerequisites": {
        "type": "object",
        "description": "Prerequisite requirements for entering a scenario",
        "properties": {
          "requiredDomains": {
            "type": "object",
            "additionalProperties": {
              "type": "number",
              "format": "float"
            },
            "nullable": true,
            "description": "Minimum growth depth per domain (domain path to minimum depth)"
          },
          "requiredScenarios": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Scenario template codes that must be completed first"
          },
          "excludedScenarios": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Scenario template codes that disqualify the player"
          }
        }
      },
      "ScenarioQuestHook": {
        "type": "object",
        "additionalProperties": false,
        "description": "Quest to spawn on scenario completion",
        "required": [
          "questCode"
        ],
        "properties": {
          "questCode": {
            "type": "string",
            "description": "Quest definition code to spawn"
          },
          "delaySeconds": {
            "type": "integer",
            "default": 0,
            "description": "Delay before spawning quest (not implemented in Phase 1)"
          },
          "termOverrides": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Variable overrides for quest template"
          }
        }
      },
      "ScenarioStateResponse": {
        "type": "object",
        "description": "Current state of a scenario instance",
        "required": [
          "scenarioInstanceId",
          "scenarioTemplateId",
          "gameSessionId",
          "connectivityMode",
          "status",
          "createdAt",
          "chainDepth"
        ],
        "properties": {
          "scenarioInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this scenario instance"
          },
          "scenarioTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template this instance was created from"
          },
          "gameSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Backing game session ID"
          },
          "connectivityMode": {
            "$ref": "#/components/schemas/ConnectivityMode",
            "description": "How this scenario connects to the game world"
          },
          "status": {
            "$ref": "#/components/schemas/ScenarioStatus",
            "description": "Current lifecycle status"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this instance was created"
          },
          "chainedFrom": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Previous scenario instance if this was chained"
          },
          "chainDepth": {
            "type": "integer",
            "default": 0,
            "description": "Current chain depth from the initial scenario"
          }
        }
      },
      "ScenarioStatus": {
        "type": "string",
        "enum": [
          "Initializing",
          "Active",
          "Completing",
          "Completed",
          "Abandoned"
        ],
        "description": "Current lifecycle status of a scenario instance"
      },
      "ScenarioTemplateResponse": {
        "type": "object",
        "description": "Full scenario template with all fields",
        "required": [
          "scenarioTemplateId",
          "code",
          "displayName",
          "description",
          "category",
          "domainWeights",
          "connectivityMode",
          "allowedPhases",
          "maxConcurrentInstances",
          "status",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "scenarioTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this template"
          },
          "code": {
            "type": "string",
            "description": "Unique template code"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable name"
          },
          "description": {
            "type": "string",
            "description": "Template description"
          },
          "category": {
            "$ref": "#/components/schemas/ScenarioCategory",
            "description": "Primary gameplay category"
          },
          "subcategory": {
            "type": "string",
            "nullable": true,
            "description": "Subcategory within the primary category"
          },
          "domainWeights": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DomainWeight"
            },
            "description": "Growth domain weights"
          },
          "minGrowthPhase": {
            "type": "string",
            "nullable": true,
            "description": "Minimum seed growth phase"
          },
          "connectivityMode": {
            "$ref": "#/components/schemas/ConnectivityMode",
            "description": "World connectivity mode"
          },
          "allowedPhases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeploymentPhase"
            },
            "description": "Deployment phases where this template is available. Always contains explicit values (never empty)."
          },
          "maxConcurrentInstances": {
            "type": "integer",
            "description": "Maximum concurrent active instances"
          },
          "estimatedDurationMinutes": {
            "type": "integer",
            "nullable": true,
            "description": "Estimated scenario duration in minutes"
          },
          "prerequisites": {
            "$ref": "#/components/schemas/ScenarioPrerequisites",
            "nullable": true,
            "description": "Entry requirements"
          },
          "chaining": {
            "$ref": "#/components/schemas/ScenarioChaining",
            "nullable": true,
            "description": "Chaining configuration"
          },
          "multiplayer": {
            "$ref": "#/components/schemas/ScenarioMultiplayer",
            "nullable": true,
            "description": "Multiplayer support"
          },
          "content": {
            "$ref": "#/components/schemas/ScenarioContent",
            "nullable": true,
            "description": "Content references"
          },
          "status": {
            "$ref": "#/components/schemas/TemplateStatus",
            "description": "Current lifecycle status"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this template was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this template was last updated"
          }
        }
      },
      "Scene": {
        "type": "object",
        "description": "A complete scene document with hierarchical node structure",
        "required": [
          "sceneId",
          "gameId",
          "sceneType",
          "name",
          "version",
          "root"
        ],
        "properties": {
          "schema": {
            "type": "string",
            "description": "Schema identifier for validation",
            "default": "bannou://schemas/scene/v1"
          },
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique scene identifier"
          },
          "gameId": {
            "type": "string",
            "description": "Game service identifier for partitioning. Treated as opaque string.\nDefault is the nil UUID for unpartitioned scenes.\n",
            "default": "00000000-0000-0000-0000-000000000000"
          },
          "sceneType": {
            "$ref": "#/components/schemas/SceneType",
            "description": "Scene classification for querying and validation"
          },
          "name": {
            "type": "string",
            "description": "Human-readable scene name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Optional scene description"
          },
          "version": {
            "type": "string",
            "pattern": "^\\d+\\.\\d+\\.\\d+$",
            "description": "Semantic version (MAJOR.MINOR.PATCH)"
          },
          "root": {
            "$ref": "#/components/schemas/SceneNode",
            "description": "Root node of the scene hierarchy"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Searchable tags for filtering scenes"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Scene-level metadata. Not interpreted by Scene service.\nExamples: author, thumbnail, editor preferences, generator config.\n"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the scene was first created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the scene was last modified"
          }
        }
      },
      "SceneNode": {
        "type": "object",
        "description": "A node in the scene hierarchy. Nodes can contain children to form\na tree structure. Each node has a local transform relative to its parent.\n",
        "required": [
          "nodeId",
          "refId",
          "name",
          "nodeType",
          "localTransform"
        ],
        "properties": {
          "nodeId": {
            "type": "string",
            "format": "uuid",
            "description": "Globally unique node identifier"
          },
          "refId": {
            "type": "string",
            "pattern": "^[a-z][a-z0-9_]*$",
            "description": "Scene-local reference identifier. Must be unique within the scene.\nUsed for scripting and cross-referencing. Examples: main_door, npc_spawn_1\n"
          },
          "parentNodeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Parent node ID. Null for the root node only."
          },
          "name": {
            "type": "string",
            "description": "Human-readable display name for the node"
          },
          "nodeType": {
            "$ref": "#/components/schemas/NodeType",
            "description": "The structural type of this node"
          },
          "localTransform": {
            "$ref": "#/components/schemas/Transform",
            "description": "Transform relative to parent node"
          },
          "asset": {
            "$ref": "#/components/schemas/AssetReference",
            "nullable": true,
            "description": "Optional asset binding (mesh, sound, particle effect)"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SceneNode"
            },
            "description": "Child nodes in the hierarchy"
          },
          "enabled": {
            "type": "boolean",
            "default": true,
            "description": "Whether this node is active in the scene definition"
          },
          "sortOrder": {
            "type": "integer",
            "default": 0,
            "description": "Ordering among siblings for deterministic iteration"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive)"
          },
          "annotations": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Consumer-specific data stored without interpretation.\nUse namespaced keys (e.g., render.castShadows, game.interactionType).\n"
          },
          "attachmentPoints": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AttachmentPoint"
            },
            "description": "Predefined locations for attaching child objects.\nUsed by Scene Composer for furniture decoration, wall accessories, etc.\n"
          },
          "affordances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Affordance"
            },
            "description": "Interaction capabilities of this node.\nUsed by AI navigation and character controllers.\n"
          },
          "assetSlot": {
            "$ref": "#/components/schemas/AssetSlot",
            "nullable": true,
            "description": "Procedural asset swapping configuration.\nDefines which assets can substitute for this node's asset.\n"
          },
          "markerType": {
            "$ref": "#/components/schemas/MarkerType",
            "nullable": true,
            "description": "Type of marker for marker nodes.\nOnly relevant when nodeType is 'marker'.\n"
          },
          "volumeShape": {
            "$ref": "#/components/schemas/VolumeShape",
            "nullable": true,
            "description": "Shape of volume for volume nodes.\nOnly relevant when nodeType is 'volume'.\n"
          },
          "volumeSize": {
            "$ref": "#/components/schemas/Vector3",
            "nullable": true,
            "description": "Size/extents of the volume (interpretation depends on volumeShape).\nFor box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.\n"
          },
          "referenceSceneId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Scene ID to embed for reference nodes.\nOnly relevant when nodeType is 'reference'.\n"
          }
        }
      },
      "SceneResponse": {
        "type": "object",
        "description": "Standard response containing a scene",
        "required": [
          "scene"
        ],
        "properties": {
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "The scene document"
          }
        }
      },
      "SceneSummary": {
        "type": "object",
        "description": "Summary of a scene for list results (excludes full node tree)",
        "required": [
          "sceneId",
          "gameId",
          "sceneType",
          "name",
          "version"
        ],
        "properties": {
          "sceneId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique scene identifier"
          },
          "gameId": {
            "type": "string",
            "description": "Game service identifier"
          },
          "sceneType": {
            "$ref": "#/components/schemas/SceneType",
            "description": "Scene classification"
          },
          "name": {
            "type": "string",
            "description": "Scene name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Scene description"
          },
          "version": {
            "type": "string",
            "description": "Current version"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Scene tags"
          },
          "nodeCount": {
            "type": "integer",
            "description": "Total number of nodes in scene"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Last update timestamp"
          },
          "isCheckedOut": {
            "type": "boolean",
            "description": "Whether scene is currently checked out"
          }
        }
      },
      "SceneType": {
        "type": "string",
        "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
        "enum": [
          "unknown",
          "region",
          "city",
          "district",
          "lot",
          "building",
          "room",
          "dungeon",
          "arena",
          "vehicle",
          "prefab",
          "cutscene",
          "other"
        ]
      },
      "SchemaResponse": {
        "type": "object",
        "description": "Registered schema definition with version lineage information",
        "required": [
          "namespace",
          "schemaVersion",
          "createdAt"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Schema namespace"
          },
          "schemaVersion": {
            "type": "string",
            "description": "Schema version"
          },
          "schema": {
            "type": "object",
            "description": "JSON Schema definition"
          },
          "previousVersion": {
            "type": "string",
            "nullable": true,
            "description": "Previous version"
          },
          "hasMigration": {
            "type": "boolean",
            "description": "Whether migration script is registered"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Registration timestamp"
          }
        }
      },
      "SearchDocumentationRequest": {
        "description": "Request to search documentation using keyword matching",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "searchTerm"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to search within"
          },
          "searchTerm": {
            "type": "string",
            "minLength": 2,
            "maxLength": 200,
            "description": "Keyword or phrase to search for"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional session ID for tracking searches (null if not tracking)"
          },
          "category": {
            "$ref": "#/components/schemas/DocumentCategory",
            "nullable": true,
            "description": "Filter results to a specific category (null for all categories)"
          },
          "maxResults": {
            "type": "integer",
            "default": 10,
            "minimum": 1,
            "maximum": 50,
            "description": "Maximum number of results to return"
          },
          "searchIn": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchField"
            },
            "nullable": true,
            "description": "Fields to search within (null for default fields)"
          },
          "sortBy": {
            "type": "string",
            "enum": [
              "relevance",
              "recency",
              "alphabetical"
            ],
            "default": "relevance",
            "description": "How to sort the search results"
          },
          "includeContent": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include full document content in results"
          }
        }
      },
      "SearchDocumentationResponse": {
        "description": "Response containing keyword search results",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "results"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "description": "The namespace that was searched"
          },
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentResult"
            },
            "description": "List of matching documents"
          },
          "totalResults": {
            "type": "integer",
            "description": "Total number of matching documents"
          },
          "searchTerm": {
            "type": "string",
            "description": "The original search term"
          }
        }
      },
      "SearchField": {
        "type": "string",
        "enum": [
          "title",
          "content",
          "tags",
          "summary"
        ],
        "description": "Fields that can be searched within documents"
      },
      "SearchMatchType": {
        "type": "string",
        "description": "Where the search match was found",
        "enum": [
          "name",
          "description",
          "tag",
          "node_name"
        ]
      },
      "SearchMessagesRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to full-text search messages in a persistent room",
        "required": [
          "roomId",
          "query"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID to search in (must be a persistent room)"
          },
          "query": {
            "type": "string",
            "description": "Full-text search query string"
          },
          "limit": {
            "type": "integer",
            "default": 20,
            "description": "Maximum number of results to return"
          }
        }
      },
      "SearchMessagesResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Full-text search results with total match count",
        "required": [
          "messages",
          "totalMatches"
        ],
        "properties": {
          "messages": {
            "type": "array",
            "description": "Messages matching the search query",
            "items": {
              "$ref": "#/components/schemas/ChatMessageResponse"
            }
          },
          "totalMatches": {
            "type": "integer",
            "description": "Total number of matching messages"
          }
        }
      },
      "SearchResult": {
        "type": "object",
        "description": "A single search result",
        "required": [
          "scene",
          "matchType"
        ],
        "properties": {
          "scene": {
            "$ref": "#/components/schemas/SceneSummary",
            "description": "Matching scene summary"
          },
          "matchType": {
            "$ref": "#/components/schemas/SearchMatchType",
            "description": "Where the match was found"
          },
          "matchContext": {
            "type": "string",
            "nullable": true,
            "description": "Context around the match"
          }
        }
      },
      "SearchScenesRequest": {
        "type": "object",
        "description": "Request for full-text search",
        "required": [
          "query"
        ],
        "properties": {
          "query": {
            "type": "string",
            "description": "Search query text"
          },
          "gameId": {
            "type": "string",
            "nullable": true,
            "description": "Filter by game ID"
          },
          "sceneTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SceneType"
            },
            "nullable": true,
            "description": "Filter by scene types"
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "description": "Pagination offset"
          },
          "limit": {
            "type": "integer",
            "default": 50,
            "description": "Maximum results"
          }
        }
      },
      "SearchScenesResponse": {
        "type": "object",
        "description": "Search results",
        "required": [
          "results",
          "total"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchResult"
            },
            "description": "Matching scenes"
          },
          "total": {
            "type": "integer",
            "description": "Total matches"
          }
        }
      },
      "SeasonResponse": {
        "type": "object",
        "description": "Season information",
        "additionalProperties": false,
        "required": [
          "leaderboardId",
          "seasonNumber",
          "startedAt",
          "isActive"
        ],
        "properties": {
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard"
          },
          "seasonNumber": {
            "type": "integer",
            "description": "Season number"
          },
          "seasonName": {
            "type": "string",
            "nullable": true,
            "description": "Name of the season"
          },
          "startedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this season started"
          },
          "endedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this season ended (null if active)"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether this is the current season"
          },
          "entryCount": {
            "type": "integer",
            "format": "int64",
            "description": "Number of entries in this season"
          }
        }
      },
      "SeedBoardTemplateRequest": {
        "type": "object",
        "description": "Request to bulk seed a board template with license definitions",
        "additionalProperties": false,
        "required": [
          "boardTemplateId",
          "definitions"
        ],
        "properties": {
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template to seed with definitions"
          },
          "definitions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AddLicenseDefinitionRequest"
            },
            "description": "License definitions to add (boardTemplateId in each is ignored, uses top-level)"
          }
        }
      },
      "SeedBoardTemplateResponse": {
        "type": "object",
        "description": "Result of bulk seeding a board template",
        "additionalProperties": false,
        "required": [
          "boardTemplateId",
          "definitionsCreated",
          "definitions"
        ],
        "properties": {
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template that was seeded"
          },
          "definitionsCreated": {
            "type": "integer",
            "description": "Number of definitions created"
          },
          "definitions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LicenseDefinitionResponse"
            },
            "description": "All created license definitions"
          }
        }
      },
      "SeedEffectEntry": {
        "type": "object",
        "description": "A single seed-derived passive effect entry",
        "additionalProperties": false,
        "required": [
          "capabilityCode",
          "domain",
          "fidelity",
          "seedId",
          "seedTypeCode"
        ],
        "properties": {
          "capabilityCode": {
            "type": "string",
            "description": "Capability code from the seed's capability manifest"
          },
          "domain": {
            "type": "string",
            "description": "Seed domain this capability belongs to"
          },
          "fidelity": {
            "type": "number",
            "format": "float",
            "description": "Capability fidelity value (0.0 to 1.0)"
          },
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "Seed providing this capability"
          },
          "seedTypeCode": {
            "type": "string",
            "description": "Type code of the seed providing this capability"
          }
        }
      },
      "SeedEffectsResponse": {
        "type": "object",
        "description": "Seed-derived passive effects for an entity",
        "additionalProperties": false,
        "required": [
          "entityId",
          "entityType",
          "effects"
        ],
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity these effects belong to"
          },
          "entityType": {
            "type": "string",
            "description": "Entity type discriminator"
          },
          "effects": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SeedEffectEntry"
            },
            "description": "Seed-derived passive effects"
          }
        }
      },
      "SeedEntryTemplatesRequest": {
        "type": "object",
        "description": "Request to bulk seed entry templates",
        "additionalProperties": false,
        "required": [
          "templates"
        ],
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateEntryTemplateRequest"
            },
            "description": "Entry templates to create (duplicates are skipped)"
          }
        }
      },
      "SeedEntryTemplatesResponse": {
        "type": "object",
        "description": "Result of bulk seed operation",
        "additionalProperties": false,
        "required": [
          "created",
          "skipped"
        ],
        "properties": {
          "created": {
            "type": "integer",
            "description": "Number of entry templates successfully created"
          },
          "skipped": {
            "type": "integer",
            "description": "Number of templates skipped (duplicates)"
          }
        }
      },
      "SeedResponse": {
        "type": "object",
        "description": "Full seed entity response.",
        "required": [
          "seedId",
          "ownerId",
          "ownerType",
          "seedTypeCode",
          "createdAt",
          "growthPhase",
          "totalGrowth",
          "displayName",
          "status"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this seed."
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "The entity that owns this seed."
          },
          "ownerType": {
            "type": "string",
            "description": "Owner entity type discriminator."
          },
          "seedTypeCode": {
            "type": "string",
            "description": "Registered seed type code."
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game service this seed is scoped to. Null for cross-game seed types."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the seed was created."
          },
          "growthPhase": {
            "type": "string",
            "description": "Current computed growth phase code."
          },
          "totalGrowth": {
            "type": "number",
            "format": "float",
            "description": "Aggregate growth across all domains."
          },
          "bondId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Bond ID if this seed is bonded, null otherwise."
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable name."
          },
          "status": {
            "$ref": "#/components/schemas/SeedStatus",
            "description": "Current lifecycle status."
          }
        }
      },
      "SeedSource": {
        "type": "object",
        "additionalProperties": false,
        "description": "A source of seed data (archive or snapshot)",
        "properties": {
          "archiveId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of a compressed archive (dead entity)"
          },
          "snapshotId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "ID of a live snapshot (living entity)"
          },
          "role": {
            "type": "string",
            "nullable": true,
            "description": "Optional actant role hint (e.g., \"protagonist\", \"antagonist\", \"helper\").\nUsed for Greimas actant assignment if provided.\n"
          }
        }
      },
      "SeedStatus": {
        "type": "string",
        "description": "Lifecycle status of a seed.",
        "enum": [
          "Active",
          "Dormant",
          "Archived"
        ]
      },
      "SeedStatusTemplatesRequest": {
        "type": "object",
        "description": "Request to bulk seed status templates for a game service",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "templates"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service to seed templates for (all templates must belong to this game service)"
          },
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateStatusTemplateRequest"
            },
            "description": "Status templates to create (duplicates are skipped)"
          }
        }
      },
      "SeedStatusTemplatesResponse": {
        "type": "object",
        "description": "Result of bulk seed operation",
        "additionalProperties": false,
        "required": [
          "created",
          "skipped"
        ],
        "properties": {
          "created": {
            "type": "integer",
            "description": "Number of status templates successfully created"
          },
          "skipped": {
            "type": "integer",
            "description": "Number of templates skipped (duplicates)"
          }
        }
      },
      "SeedTypeResponse": {
        "type": "object",
        "description": "Full seed type definition response.",
        "required": [
          "seedTypeCode",
          "displayName",
          "description",
          "maxPerOwner",
          "allowedOwnerTypes",
          "growthPhases",
          "bondCardinality",
          "bondPermanent",
          "isDeprecated"
        ],
        "properties": {
          "seedTypeCode": {
            "type": "string",
            "description": "Unique type code."
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game service scope. Null for cross-game seed types."
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable name."
          },
          "description": {
            "type": "string",
            "description": "Type description."
          },
          "maxPerOwner": {
            "type": "integer",
            "description": "Maximum seeds of this type per owner."
          },
          "allowedOwnerTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Allowed owner entity types."
          },
          "growthPhases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GrowthPhaseDefinition"
            },
            "description": "Phase definitions with thresholds."
          },
          "bondCardinality": {
            "type": "integer",
            "description": "Bond participant limit."
          },
          "bondPermanent": {
            "type": "boolean",
            "description": "Whether bonds of this type are permanent."
          },
          "capabilityRules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CapabilityRule"
            },
            "nullable": true,
            "description": "Capability computation rules."
          },
          "growthDecayEnabled": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether unused growth domains decay over time for this seed type. Null means using global config."
          },
          "growthDecayRatePerDay": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "description": "Daily decay rate for unused domains of this seed type. Null means using global config."
          },
          "sameOwnerGrowthMultiplier": {
            "type": "number",
            "format": "float",
            "description": "Fraction of growth applied to other seeds of the same type owned by the same entity."
          },
          "collectionGrowthMappings": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/CollectionGrowthMapping"
            },
            "description": "Collection-to-growth-domain mappings for this seed type. Null if this type does not respond to collection unlocks."
          },
          "isDeprecated": {
            "type": "boolean",
            "description": "Whether this seed type is deprecated and cannot be used for new seeds."
          },
          "deprecatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Timestamp when this seed type was deprecated."
          },
          "deprecationReason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for deprecation."
          }
        }
      },
      "SelectContentForAreaRequest": {
        "type": "object",
        "description": "Request to select content for an area based on unlocked collection",
        "additionalProperties": false,
        "required": [
          "ownerId",
          "ownerType",
          "gameServiceId",
          "collectionType",
          "areaCode"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity whose collection to search"
          },
          "ownerType": {
            "type": "string",
            "description": "Entity type discriminator"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service scope"
          },
          "collectionType": {
            "$ref": "#/components/schemas/CollectionType",
            "description": "Type of collection to select content from"
          },
          "areaCode": {
            "type": "string",
            "description": "Area code to select content for"
          }
        }
      },
      "SendMessageBatchRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to send multiple messages to a room atomically",
        "required": [
          "roomId",
          "messages"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID to send messages to"
          },
          "messages": {
            "type": "array",
            "description": "Messages to send atomically",
            "items": {
              "$ref": "#/components/schemas/BatchMessageEntry"
            }
          }
        }
      },
      "SendMessageBatchResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of a batch message send operation",
        "required": [
          "messageCount"
        ],
        "properties": {
          "messageCount": {
            "type": "integer",
            "description": "Number of messages sent"
          }
        }
      },
      "SendMessageContent": {
        "type": "object",
        "additionalProperties": false,
        "description": "Message content discriminated by the room message format. Exactly one content field group must be set, matching the room type format.\n",
        "properties": {
          "text": {
            "type": "string",
            "nullable": true,
            "description": "Text content (for Text format rooms)"
          },
          "sentimentCategory": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SentimentCategory"
              }
            ],
            "nullable": true,
            "description": "Sentiment category (for Sentiment format rooms)"
          },
          "sentimentIntensity": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "Sentiment intensity 0.0-1.0 (for Sentiment format rooms)"
          },
          "emojiCode": {
            "type": "string",
            "nullable": true,
            "description": "Emoji code (Unicode or custom) for Emoji format rooms"
          },
          "emojiSetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Custom emoji set reference (null for Unicode)"
          },
          "customPayload": {
            "type": "string",
            "nullable": true,
            "description": "JSON string validated against room type validator config (for Custom format rooms)"
          }
        }
      },
      "SendMessageRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to send a message to a chat room",
        "required": [
          "roomId",
          "content"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID to send the message to"
          },
          "content": {
            "$ref": "#/components/schemas/SendMessageContent",
            "description": "Message content matching the room format"
          },
          "senderType": {
            "type": "string",
            "nullable": true,
            "description": "Opaque sender type for this message"
          },
          "senderId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Sender entity ID"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Sender display name for this message"
          }
        }
      },
      "SentimentCategory": {
        "type": "string",
        "description": "Standardized sentiment categories for anonymous audience and reaction data. Used by lib-chat for sentiment room messages and lib-stream for platform audience processing. Designed for privacy-safe communication where text content is inappropriate or unnecessary.\n",
        "enum": [
          "Excited",
          "Supportive",
          "Critical",
          "Curious",
          "Surprised",
          "Amused",
          "Bored",
          "Hostile"
        ]
      },
      "SentimentResponse": {
        "type": "object",
        "description": "Response containing aggregate sentiment",
        "additionalProperties": false,
        "required": [
          "characterId",
          "targetCharacterId",
          "sentiment",
          "encounterCount"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character whose sentiment was queried"
          },
          "targetCharacterId": {
            "type": "string",
            "format": "uuid",
            "description": "Target of the sentiment"
          },
          "sentiment": {
            "type": "number",
            "format": "float",
            "minimum": -1.0,
            "maximum": 1.0,
            "description": "Aggregate sentiment (-1.0 = hostile, +1.0 = friendly)"
          },
          "encounterCount": {
            "type": "integer",
            "description": "Number of encounters factored in"
          },
          "dominantEmotion": {
            "$ref": "#/components/schemas/EmotionalImpact",
            "nullable": true,
            "description": "Most common emotional impact across encounters"
          }
        }
      },
      "ServiceInfo": {
        "type": "object",
        "additionalProperties": false,
        "description": "Information about a game service",
        "required": [
          "serviceId",
          "stubName",
          "displayName",
          "isActive",
          "createdAt"
        ],
        "properties": {
          "serviceId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the service"
          },
          "stubName": {
            "type": "string",
            "description": "URL-safe identifier (e.g., \"my-game\")"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable name (e.g., \"My Game Online\")"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Optional description"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether the service is currently active"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the service was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the service was last updated"
          }
        }
      },
      "SessionGameType": {
        "type": "string",
        "description": "Game service stub name for created sessions. Use the game service's stubName property (e.g., \"my-game\"). Use \"generic\" for non-game-specific sessions.",
        "default": "generic"
      },
      "SessionInfo": {
        "description": "Information about an active user session including device and activity details",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "sessionId",
          "createdAt",
          "lastActive"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the session"
          },
          "deviceInfo": {
            "$ref": "#/components/schemas/DeviceInfo",
            "nullable": true,
            "description": "Information about the device used for this session"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the session was created"
          },
          "lastActive": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of the last activity in this session"
          },
          "ipAddress": {
            "type": "string",
            "nullable": true,
            "description": "IP address from which the session was initiated"
          },
          "location": {
            "type": "string",
            "nullable": true,
            "description": "Geographic location derived from the IP address"
          }
        }
      },
      "SessionStatus": {
        "type": "string",
        "description": "Current status of the game session",
        "enum": [
          "waiting",
          "active",
          "full",
          "finished"
        ]
      },
      "SessionType": {
        "type": "string",
        "description": "Type of game session - determines join behavior",
        "enum": [
          "lobby",
          "matchmade"
        ]
      },
      "SessionsResponse": {
        "description": "Response containing a list of all active sessions for an account",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "sessions"
        ],
        "properties": {
          "sessions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SessionInfo"
            },
            "description": "List of active sessions for the account"
          }
        }
      },
      "SetActionMappingRequest": {
        "type": "object",
        "description": "Request to create or update an action tag mapping",
        "additionalProperties": false,
        "required": [
          "tag",
          "violationTypes"
        ],
        "properties": {
          "tag": {
            "type": "string",
            "minLength": 1,
            "maxLength": 128,
            "description": "The GOAP action tag to map (e.g., \"steal_food\")"
          },
          "violationTypes": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 128
            },
            "minItems": 1,
            "maxItems": 20,
            "description": "Violation type codes this tag should map to"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "maxLength": 512,
            "description": "Human-readable description of this mapping"
          }
        }
      },
      "SetAreaContentConfigRequest": {
        "type": "object",
        "description": "Request to create or update an area content configuration",
        "additionalProperties": false,
        "required": [
          "areaCode",
          "gameServiceId",
          "collectionType",
          "themes",
          "defaultEntryCode"
        ],
        "properties": {
          "areaCode": {
            "type": "string",
            "description": "Area code to configure (unique per game service and collection type)"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this area config belongs to"
          },
          "collectionType": {
            "$ref": "#/components/schemas/CollectionType",
            "description": "Type of collection this area config applies to"
          },
          "themes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "description": "Theme tags for this area (matched against collection entry themes)"
          },
          "defaultEntryCode": {
            "type": "string",
            "description": "Default entry code to use when no matches are found"
          }
        }
      },
      "SetTemplateValuesRequest": {
        "type": "object",
        "description": "Request to set template values on a contract",
        "additionalProperties": false,
        "required": [
          "contractInstanceId",
          "templateValues"
        ],
        "properties": {
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "templateValues": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Key-value pairs for template substitution.\nKeys should follow pattern: EscrowId, PartyA_EscrowWalletId, etc.\n"
          }
        }
      },
      "SetTemplateValuesResponse": {
        "type": "object",
        "description": "Response from setting template values",
        "additionalProperties": false,
        "required": [
          "updated",
          "contractId"
        ],
        "properties": {
          "updated": {
            "type": "boolean",
            "description": "Whether values were updated"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "valueCount": {
            "type": "integer",
            "description": "Number of template values set"
          }
        }
      },
      "SharedGardenStateResponse": {
        "type": "object",
        "description": "Shared garden state for bonded players",
        "required": [
          "bondId",
          "participants",
          "sharedPois"
        ],
        "properties": {
          "bondId": {
            "type": "string",
            "format": "uuid",
            "description": "Bond linking the participants"
          },
          "participants": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BondedPlayerGardenState"
            },
            "description": "Per-player garden state"
          },
          "sharedPois": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PoiSummary"
            },
            "description": "POIs visible to all bond participants"
          }
        }
      },
      "SiteSettings": {
        "description": "Global website configuration including branding, languages, and integrations",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "siteName",
          "siteUrl",
          "defaultLanguage"
        ],
        "properties": {
          "siteName": {
            "type": "string",
            "description": "Display name of the website"
          },
          "siteUrl": {
            "type": "string",
            "format": "uri",
            "description": "Base URL of the website"
          },
          "tagline": {
            "type": "string",
            "nullable": true,
            "description": "Short slogan or description of the site"
          },
          "defaultLanguage": {
            "type": "string",
            "default": "en",
            "description": "Default language code for the website"
          },
          "supportedLanguages": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of supported language codes"
          },
          "maintenanceMode": {
            "type": "boolean",
            "default": false,
            "description": "Whether the site is in maintenance mode"
          },
          "maintenanceMessage": {
            "type": "string",
            "nullable": true,
            "description": "Message displayed during maintenance mode"
          },
          "contactEmail": {
            "type": "string",
            "format": "email",
            "description": "Primary contact email address for the site"
          },
          "socialLinks": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "format": "uri"
            },
            "description": "Map of social media platform names to profile URLs"
          },
          "analytics": {
            "description": "Analytics and tracking service configuration",
            "$ref": "#/components/schemas/Analytics"
          },
          "customScripts": {
            "description": "Custom JavaScript scripts to inject into pages",
            "$ref": "#/components/schemas/CustomScripts"
          }
        }
      },
      "SkillExpansionStep": {
        "type": "object",
        "description": "A step in the skill window expansion curve",
        "additionalProperties": false,
        "required": [
          "intervals"
        ],
        "properties": {
          "intervals": {
            "type": "integer",
            "minimum": 0,
            "description": "Number of intervals after which this step applies"
          },
          "range": {
            "type": "integer",
            "nullable": true,
            "minimum": 0,
            "description": "Skill range (null means any skill level)"
          }
        }
      },
      "SlotResponse": {
        "type": "object",
        "description": "Complete metadata for a save slot including version statistics",
        "required": [
          "slotId",
          "ownerId",
          "ownerType",
          "slotName",
          "category",
          "createdAt"
        ],
        "properties": {
          "slotId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique slot identifier"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          },
          "category": {
            "$ref": "#/components/schemas/SaveCategory",
            "description": "Save category determining retention and cleanup behavior"
          },
          "maxVersions": {
            "type": "integer",
            "description": "Maximum versions to retain"
          },
          "retentionDays": {
            "type": "integer",
            "nullable": true,
            "description": "Days to retain versions (null = indefinite)"
          },
          "compressionType": {
            "$ref": "#/components/schemas/CompressionType",
            "description": "Compression algorithm used for save data"
          },
          "versionCount": {
            "type": "integer",
            "description": "Current number of versions in slot"
          },
          "latestVersion": {
            "type": "integer",
            "nullable": true,
            "description": "Latest version number (null if empty)"
          },
          "totalSizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Total storage used by all versions"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Slot creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Last modification timestamp"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom key-value metadata"
          }
        }
      },
      "SortOrder": {
        "type": "string",
        "description": "How scores are sorted",
        "enum": [
          "descending",
          "ascending"
        ]
      },
      "SoulboundType": {
        "type": "string",
        "description": "When item becomes bound to a character",
        "enum": [
          "none",
          "on_pickup",
          "on_equip",
          "on_use"
        ]
      },
      "SourceBundleReference": {
        "type": "object",
        "additionalProperties": false,
        "description": "Provenance reference to a source bundle used in metabundle creation",
        "required": [
          "bundleId",
          "version",
          "assetIds",
          "contentHash"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Source bundle identifier"
          },
          "version": {
            "type": "string",
            "description": "Version of source bundle at composition time"
          },
          "assetIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Asset IDs contributed from this source bundle"
          },
          "contentHash": {
            "type": "string",
            "description": "Hash of source bundle at composition time (for integrity verification)"
          }
        }
      },
      "SpaceCandidate": {
        "type": "object",
        "description": "Potential placement location",
        "additionalProperties": false,
        "required": [
          "containerId",
          "containerType",
          "canFitQuantity"
        ],
        "properties": {
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container ID"
          },
          "containerType": {
            "type": "string",
            "description": "Container type"
          },
          "canFitQuantity": {
            "type": "number",
            "format": "double",
            "description": "How much can fit"
          },
          "slotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Available slot"
          },
          "slotX": {
            "type": "integer",
            "nullable": true,
            "description": "Available grid X"
          },
          "slotY": {
            "type": "integer",
            "nullable": true,
            "description": "Available grid Y"
          },
          "existingStackInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Stack to merge with"
          }
        }
      },
      "SpatialContext": {
        "type": "object",
        "additionalProperties": true,
        "description": "Spatial context derived from game server's authoritative spatial state.\nIncluded in perception events to give NPC actors awareness of their environment\nwithout requiring direct map subscriptions.\n\nNote: additionalProperties=true allows game-specific extensions.\n",
        "properties": {
          "terrainType": {
            "type": "string",
            "nullable": true,
            "description": "Terrain type at character position (grass, stone, water, etc.)"
          },
          "elevation": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "description": "Elevation at character position"
          },
          "nearbyObjects": {
            "type": "array",
            "nullable": true,
            "description": "Objects within perception radius",
            "items": {
              "$ref": "#/components/schemas/NearbyObject"
            }
          },
          "hazardsInRange": {
            "type": "array",
            "nullable": true,
            "description": "Active hazards within detection range",
            "items": {
              "$ref": "#/components/schemas/HazardInfo"
            }
          },
          "pathableDirections": {
            "type": "array",
            "nullable": true,
            "description": "Directions the character can move (for navigation awareness)",
            "items": {
              "type": "string",
              "description": "Cardinal or relative direction (north, south, east, west, forward, etc.)"
            }
          },
          "coverNearby": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether cover is available within close range"
          },
          "indoors": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether character is currently indoors/under roof"
          }
        }
      },
      "SpawnActorRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to spawn a new actor from a template",
        "required": [
          "templateId"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template to instantiate from"
          },
          "actorId": {
            "type": "string",
            "nullable": true,
            "description": "Optional custom actor ID (auto-generated if not provided)"
          },
          "configurationOverrides": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Override template defaults"
          },
          "initialState": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Initial state passed to behavior"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional character ID for NPC brain actors"
          }
        }
      },
      "SpeciesListResponse": {
        "description": "Paginated list of species with total count for pagination",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "species",
          "totalCount"
        ],
        "properties": {
          "species": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpeciesResponse"
            },
            "description": "List of species matching the query"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of species matching the query (for pagination)"
          },
          "page": {
            "type": "integer",
            "description": "Current page number"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of items per page"
          }
        }
      },
      "SpeciesResponse": {
        "description": "Complete species data including all attributes and realm associations",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "speciesId",
          "code",
          "name",
          "isPlayable",
          "isDeprecated",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "speciesId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the species"
          },
          "code": {
            "type": "string",
            "description": "Unique code for the species (e.g., \"HUMAN\", \"ELF\")"
          },
          "name": {
            "type": "string",
            "description": "Display name for the species"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Description of the species"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Category for grouping (e.g., \"HUMANOID\", \"BEAST\", \"MAGICAL\")"
          },
          "isPlayable": {
            "type": "boolean",
            "description": "Whether players can create characters of this species"
          },
          "isDeprecated": {
            "type": "boolean",
            "description": "Whether this species is deprecated and cannot be used for new characters"
          },
          "deprecatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Timestamp when this species was deprecated"
          },
          "deprecationReason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for deprecation"
          },
          "baseLifespan": {
            "type": "integer",
            "nullable": true,
            "description": "Base lifespan in game years"
          },
          "maturityAge": {
            "type": "integer",
            "nullable": true,
            "description": "Age at which the species reaches maturity"
          },
          "traitModifiers": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Base trait modifiers for this species"
          },
          "realmIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Realms where this species is available"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional metadata for the species"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the species was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the species was last updated"
          }
        }
      },
      "SpectrumType": {
        "x-sdk-type": "BeyondImmersion.Bannou.StorylineTheory.Spectrums.SpectrumType",
        "type": "string",
        "enum": [
          "LifeDeath",
          "HonorDishonor",
          "JusticeInjustice",
          "FreedomSubjugation",
          "LoveHate",
          "RespectShame",
          "PowerImpotence",
          "SuccessFailure",
          "AltruismSelfishness",
          "WisdomIgnorance"
        ],
        "description": "The 10 Story Grid Life Value spectrums.\nThese are bipolar axes for emotional progression.\n"
      },
      "SplitAllocation": {
        "type": "object",
        "description": "Allocation of assets to a party in a split resolution",
        "required": [
          "partyId",
          "partyType",
          "assets"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party ID"
          },
          "partyType": {
            "description": "Type of entity (Account, Character, etc.)",
            "$ref": "#/components/schemas/EntityType"
          },
          "assets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EscrowAssetInput"
            },
            "description": "Assets allocated to this party"
          }
        }
      },
      "SplitStackRequest": {
        "type": "object",
        "description": "Request to split a stack",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "quantity"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Stack to split"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "minimum": 1,
            "description": "Quantity to split off"
          },
          "targetSlotIndex": {
            "type": "integer",
            "nullable": true,
            "description": "Slot for new stack"
          },
          "targetSlotX": {
            "type": "integer",
            "nullable": true,
            "description": "Grid X for new stack"
          },
          "targetSlotY": {
            "type": "integer",
            "nullable": true,
            "description": "Grid Y for new stack"
          }
        }
      },
      "SplitStackResponse": {
        "type": "object",
        "description": "Response after splitting",
        "additionalProperties": false,
        "required": [
          "success",
          "originalInstanceId",
          "newInstanceId",
          "originalQuantity",
          "newQuantity"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether split succeeded"
          },
          "originalInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Original stack ID"
          },
          "newInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "New stack ID"
          },
          "originalQuantity": {
            "type": "number",
            "format": "double",
            "description": "Remaining quantity"
          },
          "newQuantity": {
            "type": "number",
            "format": "double",
            "description": "Split quantity"
          }
        }
      },
      "StackBehavior": {
        "type": "string",
        "description": "How multiple applications of the same status template interact.\n- refresh_duration: resets timer, preserves or increments stack count\n- independent: each application is a separate item with own timer\n- increase_intensity: stacks increase effect magnitude, shared timer reset\n- replace: new application replaces existing entirely\n- ignore: cannot apply if already present\n",
        "enum": [
          "refresh_duration",
          "independent",
          "increase_intensity",
          "replace",
          "ignore"
        ]
      },
      "StartEncounterRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to start an encounter managed by an Event Brain actor",
        "required": [
          "actorId",
          "encounterId",
          "encounterType",
          "participants"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "ID of the Event Brain actor that will manage this encounter"
          },
          "encounterId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this encounter"
          },
          "encounterType": {
            "type": "string",
            "description": "Type of encounter (e.g., \"combat\", \"conversation\", \"choreography\")"
          },
          "participants": {
            "type": "array",
            "description": "Character IDs of participants in the encounter",
            "items": {
              "type": "string",
              "format": "uuid"
            }
          },
          "initialData": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Optional initial data for the encounter"
          }
        }
      },
      "StartWatcherRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to start a regional watcher",
        "required": [
          "realmId",
          "watcherType"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm the watcher should monitor"
          },
          "watcherType": {
            "type": "string",
            "description": "Type of watcher to start (e.g., \"regional\", \"dungeon\", \"event\")"
          },
          "behaviorRef": {
            "type": "string",
            "nullable": true,
            "description": "Optional specific behavior document reference. If not provided, uses default for watcher type."
          }
        }
      },
      "StartWatcherResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response after starting a watcher",
        "required": [
          "watcher",
          "alreadyExisted"
        ],
        "properties": {
          "watcher": {
            "description": "The watcher that was started or already existed",
            "$ref": "#/components/schemas/WatcherInfo"
          },
          "alreadyExisted": {
            "type": "boolean",
            "description": "True if a matching watcher was already running"
          }
        }
      },
      "StartWatchersForRealmRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to start all relevant watchers for a realm",
        "required": [
          "realmId"
        ],
        "properties": {
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm to start watchers for"
          }
        }
      },
      "StartWatchersForRealmResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response after starting watchers for a realm",
        "required": [
          "watchersStarted",
          "watchers"
        ],
        "properties": {
          "watchersStarted": {
            "type": "integer",
            "description": "Number of new watchers started"
          },
          "watchersExisted": {
            "type": "integer",
            "description": "Number of watchers that already existed"
          },
          "watchers": {
            "type": "array",
            "description": "All watchers now active for this realm",
            "items": {
              "$ref": "#/components/schemas/WatcherInfo"
            }
          }
        }
      },
      "StatusCategory": {
        "type": "string",
        "description": "Classification of status effects for filtering and cleanse targeting.\n- buff: positive temporary effect (strength boost, speed increase)\n- debuff: negative temporary effect (poison, slow, weakness)\n- death: death penalty or incapacitation state\n- subscription: account-level subscription benefit\n- event: time-limited event effect (festival bonus, seasonal)\n- passive: seed-derived passive capability (used in unified queries)\n",
        "enum": [
          "buff",
          "debuff",
          "death",
          "subscription",
          "event",
          "passive"
        ]
      },
      "StatusEffectSummary": {
        "type": "object",
        "description": "Unified summary of an active effect from any source (item-based or seed-derived)",
        "additionalProperties": false,
        "required": [
          "statusCode",
          "category",
          "effectSource"
        ],
        "properties": {
          "statusCode": {
            "type": "string",
            "description": "Status template code (item-based) or capability code (seed-derived)"
          },
          "category": {
            "$ref": "#/components/schemas/StatusCategory",
            "description": "Status category for filtering"
          },
          "effectSource": {
            "$ref": "#/components/schemas/EffectSource",
            "description": "Whether this effect is item-based or seed-derived"
          },
          "stackCount": {
            "type": "integer",
            "nullable": true,
            "description": "Current stack count (null for seed-derived effects)"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this effect expires (null for permanent or seed-derived)"
          },
          "fidelity": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "description": "Seed capability fidelity value (null for item-based effects)"
          },
          "seedId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Seed providing this effect (null for item-based effects)"
          },
          "sourceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "What granted this status (null for seed-derived effects)"
          }
        }
      },
      "StatusInstanceResponse": {
        "type": "object",
        "description": "Full details of a status instance",
        "additionalProperties": false,
        "required": [
          "statusInstanceId",
          "entityId",
          "entityType",
          "statusTemplateCode",
          "category",
          "stackCount",
          "itemInstanceId",
          "grantedAt"
        ],
        "properties": {
          "statusInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique status instance identifier"
          },
          "entityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity this status is applied to"
          },
          "entityType": {
            "type": "string",
            "description": "Entity type discriminator"
          },
          "statusTemplateCode": {
            "type": "string",
            "description": "Status template code"
          },
          "category": {
            "$ref": "#/components/schemas/StatusCategory",
            "description": "Status category"
          },
          "stackCount": {
            "type": "integer",
            "description": "Current stack count"
          },
          "sourceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "What granted this status (null if no source tracking)"
          },
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract instance managing lifecycle (null if not contract-managed)"
          },
          "itemInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance in the status container"
          },
          "grantedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this status was granted"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this status expires (null for permanent)"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Arbitrary metadata associated with this status instance"
          }
        }
      },
      "StatusRemoveReason": {
        "type": "string",
        "description": "Why a status was removed from an entity.\n- expired: TTL or contract duration elapsed\n- cleansed: removed by category cleanse mechanic\n- cancelled: explicitly cancelled by service or admin\n- source_removed: source entity was deleted (cascading removal)\n- admin: removed by administrative action\n",
        "enum": [
          "expired",
          "cleansed",
          "cancelled",
          "source_removed",
          "admin"
        ]
      },
      "StatusResponse": {
        "description": "Health and version status information for the website service",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "status",
          "version",
          "uptime"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "healthy",
              "degraded",
              "maintenance"
            ],
            "description": "Current health status of the website service"
          },
          "version": {
            "type": "string",
            "example": "1.0.0",
            "description": "Current version of the website service"
          },
          "uptime": {
            "type": "integer",
            "description": "Uptime in seconds"
          },
          "maintenanceMessage": {
            "type": "string",
            "nullable": true,
            "description": "Message displayed during maintenance mode"
          }
        }
      },
      "StatusTemplateResponse": {
        "type": "object",
        "description": "Status template with all fields",
        "additionalProperties": false,
        "required": [
          "statusTemplateId",
          "gameServiceId",
          "code",
          "displayName",
          "description",
          "category",
          "stackable",
          "maxStacks",
          "stackBehavior",
          "itemTemplateId",
          "createdAt"
        ],
        "properties": {
          "statusTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique status template identifier"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "Game service this template is scoped to"
          },
          "code": {
            "type": "string",
            "description": "Unique status code within this game service"
          },
          "displayName": {
            "type": "string",
            "description": "Human-readable display name"
          },
          "description": {
            "type": "string",
            "description": "Detailed description of this status effect"
          },
          "category": {
            "$ref": "#/components/schemas/StatusCategory",
            "description": "Classification of this status effect"
          },
          "stackable": {
            "type": "boolean",
            "description": "Whether this status can stack"
          },
          "maxStacks": {
            "type": "integer",
            "description": "Maximum number of stacks"
          },
          "stackBehavior": {
            "$ref": "#/components/schemas/StackBehavior",
            "description": "How multiple applications interact"
          },
          "contractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract template for lifecycle management (null if not contract-managed)"
          },
          "itemTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Item template used when granting this status"
          },
          "defaultDurationSeconds": {
            "type": "integer",
            "nullable": true,
            "description": "Default duration in seconds (null for permanent statuses)"
          },
          "iconAssetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Asset identifier for this status effect's icon"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this template was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this template was last updated"
          }
        }
      },
      "SteamVerifyRequest": {
        "type": "object",
        "description": "Request to verify a Steam Session Ticket. The ticket is obtained client-side via\nISteamUser::GetAuthTicketForWebApi(\"bannou\"). SteamID is NOT included because\nit must be obtained from Steam's Web API response (never trust client-provided SteamID).\n",
        "additionalProperties": false,
        "required": [
          "ticket"
        ],
        "properties": {
          "ticket": {
            "type": "string",
            "pattern": "^[0-9A-Fa-f]+$",
            "minLength": 16,
            "description": "Hex-encoded Steam Session Ticket from ISteamUser::GetAuthTicketForWebApi().\nClient converts ticket bytes to hex string: BitConverter.ToString(ticketData).Replace(\"-\", \"\")\n",
            "example": "140000006A7B3C8E..."
          },
          "deviceInfo": {
            "$ref": "#/components/schemas/DeviceInfo",
            "nullable": true,
            "description": "Information about the client device (optional)"
          }
        }
      },
      "StopActorRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to stop a running actor",
        "required": [
          "actorId"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "ID of the actor to stop"
          },
          "graceful": {
            "type": "boolean",
            "default": true,
            "description": "If true, allows behavior to complete current iteration"
          }
        }
      },
      "StopActorResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response confirming actor stop operation",
        "required": [
          "stopped",
          "finalStatus"
        ],
        "properties": {
          "stopped": {
            "type": "boolean",
            "description": "Whether the actor was successfully stopped"
          },
          "finalStatus": {
            "description": "Final status of the actor after stopping",
            "$ref": "#/components/schemas/ActorStatus"
          }
        }
      },
      "StopBroadcastConsentRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to stop broadcasting from a voice room",
        "required": [
          "roomId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Voice room ID"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Session ID of the participant stopping the broadcast"
          }
        }
      },
      "StopWatcherRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to stop a regional watcher",
        "required": [
          "watcherId"
        ],
        "properties": {
          "watcherId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the watcher to stop"
          }
        }
      },
      "StopWatcherResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response after stopping a watcher",
        "required": [
          "stopped"
        ],
        "properties": {
          "stopped": {
            "type": "boolean",
            "description": "True if the watcher was found and stopped"
          }
        }
      },
      "StorylineArchive": {
        "type": "object",
        "x-archive-type": true,
        "description": "Complete storyline participation data for archive storage and SDK consumption.\nInherits base archive properties from ResourceArchiveBase.\nThe characterId field equals resourceId for convenience.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/ResourceArchiveBase"
          }
        ],
        "additionalProperties": false,
        "required": [
          "characterId",
          "participations",
          "activeArcs",
          "completedStorylines"
        ],
        "properties": {
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character this data belongs to (equals resourceId)"
          },
          "participations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StorylineParticipation"
            },
            "description": "All scenario participations (completed and active)"
          },
          "activeArcs": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Story arcs the character is currently involved in"
          },
          "completedStorylines": {
            "type": "integer",
            "minimum": 0,
            "description": "Total count of completed scenarios"
          }
        }
      },
      "StorylineGoal": {
        "type": "string",
        "enum": [
          "revenge",
          "resurrection",
          "legacy",
          "mystery",
          "peace"
        ],
        "description": "High-level story goal that drives arc selection.\nrevenge: Character seeks vengeance for past wrongs\nresurrection: Restoring something/someone lost\nlegacy: Creating or continuing a lasting impact\nmystery: Uncovering hidden truths\npeace: Resolving conflicts and finding harmony\n"
      },
      "StorylineLink": {
        "type": "object",
        "additionalProperties": false,
        "description": "A relationship link in the storyline",
        "required": [
          "sourceRole",
          "targetRole",
          "linkType"
        ],
        "properties": {
          "sourceRole": {
            "type": "string",
            "description": "Source entity role"
          },
          "targetRole": {
            "type": "string",
            "description": "Target entity role"
          },
          "linkType": {
            "type": "string",
            "description": "Type of relationship (e.g., \"opposes\", \"allies_with\", \"seeks\")"
          }
        }
      },
      "StorylineParticipation": {
        "type": "object",
        "description": "Summary of a scenario participation for archive purposes",
        "additionalProperties": false,
        "required": [
          "executionId",
          "scenarioCode",
          "role",
          "phase",
          "totalPhases",
          "status",
          "startedAt"
        ],
        "properties": {
          "executionId": {
            "type": "string",
            "format": "uuid",
            "description": "Scenario execution ID"
          },
          "scenarioId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Scenario definition ID (if available)"
          },
          "scenarioCode": {
            "type": "string",
            "description": "Scenario code for lookup"
          },
          "scenarioName": {
            "type": "string",
            "nullable": true,
            "description": "Scenario display name"
          },
          "role": {
            "type": "string",
            "description": "Character's role in the scenario (primary, secondary, witness)"
          },
          "phase": {
            "type": "integer",
            "minimum": 0,
            "description": "Current phase number (or final phase if completed)"
          },
          "totalPhases": {
            "type": "integer",
            "minimum": 0,
            "description": "Total number of phases in the scenario"
          },
          "status": {
            "$ref": "#/components/schemas/ScenarioStatus",
            "description": "Current status of the scenario execution"
          },
          "startedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the scenario was triggered"
          },
          "completedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the scenario completed (null if still active)"
          },
          "choices": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Key choices made during the scenario (for narrative hooks)"
          }
        }
      },
      "StorylinePlanAction": {
        "x-sdk-type": "BeyondImmersion.Bannou.StorylineStoryteller.Planning.StorylinePlanAction",
        "type": "object",
        "additionalProperties": false,
        "description": "A planned action in the storyline (SDK type)",
        "required": [
          "actionId",
          "sequenceIndex",
          "effects",
          "narrativeEffect",
          "isCoreEvent"
        ],
        "properties": {
          "actionId": {
            "type": "string",
            "description": "Action identifier from action registry"
          },
          "sequenceIndex": {
            "type": "integer",
            "description": "Sequence index within the plan"
          },
          "effects": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ActionEffect"
            },
            "description": "World state effects of this action"
          },
          "narrativeEffect": {
            "$ref": "#/components/schemas/NarrativeEffect",
            "description": "Narrative effect on the emotional arc"
          },
          "isCoreEvent": {
            "type": "boolean",
            "description": "Whether this is an obligatory scene"
          },
          "chainedFrom": {
            "type": "string",
            "nullable": true,
            "description": "If chained, the ID of the action it was chained from"
          }
        }
      },
      "StorylinePlanPhase": {
        "x-sdk-type": "BeyondImmersion.Bannou.StorylineStoryteller.Planning.StorylinePlanPhase",
        "type": "object",
        "additionalProperties": false,
        "description": "A phase in the storyline plan (SDK type)",
        "required": [
          "phaseNumber",
          "name",
          "actions",
          "targetState",
          "positionBounds"
        ],
        "properties": {
          "phaseNumber": {
            "type": "integer",
            "minimum": 1,
            "description": "1-based phase number"
          },
          "name": {
            "type": "string",
            "description": "Phase name"
          },
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StorylinePlanAction"
            },
            "description": "Actions in this phase"
          },
          "targetState": {
            "$ref": "#/components/schemas/PhaseTargetState",
            "description": "Target state for phase completion"
          },
          "positionBounds": {
            "$ref": "#/components/schemas/PhasePosition",
            "description": "Position bounds for this phase"
          }
        }
      },
      "StorylineRisk": {
        "type": "object",
        "additionalProperties": false,
        "description": "Identified risk in the plan",
        "required": [
          "riskType",
          "description",
          "severity"
        ],
        "properties": {
          "riskType": {
            "type": "string",
            "description": "Risk category (e.g., \"missing_entity\", \"low_tension\", \"weak_climax\")"
          },
          "description": {
            "type": "string",
            "description": "Risk description"
          },
          "severity": {
            "type": "string",
            "enum": [
              "low",
              "medium",
              "high"
            ],
            "description": "Risk severity"
          },
          "mitigation": {
            "type": "string",
            "nullable": true,
            "description": "Suggested mitigation"
          }
        }
      },
      "StyleDefinitionResponse": {
        "description": "Response containing a style definition",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "styleId",
          "name",
          "category"
        ],
        "properties": {
          "styleId": {
            "type": "string",
            "description": "Unique style identifier"
          },
          "name": {
            "type": "string",
            "description": "Style name"
          },
          "category": {
            "type": "string",
            "description": "Style category"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable description"
          },
          "modeDistribution": {
            "$ref": "#/components/schemas/ModeDistribution",
            "nullable": true,
            "description": "Mode probability distribution"
          },
          "intervalPreferences": {
            "$ref": "#/components/schemas/IntervalPreferences",
            "nullable": true,
            "description": "Interval preferences"
          },
          "formTemplates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FormTemplate"
            },
            "nullable": true,
            "description": "Available forms"
          },
          "tuneTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TuneType"
            },
            "nullable": true,
            "description": "Style-specific tune types"
          },
          "defaultTempo": {
            "type": "integer",
            "description": "Default tempo"
          },
          "harmonyStyle": {
            "$ref": "#/components/schemas/HarmonyStyle",
            "nullable": true,
            "description": "Harmony preferences"
          }
        }
      },
      "StyleSummary": {
        "description": "Brief style summary for listing",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "styleId",
          "name",
          "category"
        ],
        "properties": {
          "styleId": {
            "type": "string",
            "description": "Style identifier"
          },
          "name": {
            "type": "string",
            "description": "Style name"
          },
          "category": {
            "type": "string",
            "description": "Style category"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Brief description"
          }
        }
      },
      "SubscriptionInfo": {
        "type": "object",
        "additionalProperties": false,
        "description": "Information about a subscription",
        "required": [
          "subscriptionId",
          "accountId",
          "serviceId",
          "stubName",
          "startDate",
          "isActive",
          "createdAt"
        ],
        "properties": {
          "subscriptionId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the subscription"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the account this subscription belongs to"
          },
          "serviceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the subscribed service (game)"
          },
          "stubName": {
            "type": "string",
            "description": "Stub name of the service (denormalized for efficiency)"
          },
          "displayName": {
            "type": "string",
            "description": "Display name of the service (denormalized for efficiency)"
          },
          "startDate": {
            "type": "string",
            "format": "date-time",
            "description": "When the subscription started"
          },
          "expirationDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the subscription expires (null for unlimited)"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether the subscription is currently active"
          },
          "cancelledAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the subscription was cancelled (if applicable)"
          },
          "cancellationReason": {
            "type": "string",
            "nullable": true,
            "description": "Reason for cancellation (if applicable)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the subscription was created"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the subscription was last updated"
          }
        }
      },
      "SubscriptionListResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response containing list of subscriptions",
        "required": [
          "subscriptions",
          "totalCount"
        ],
        "properties": {
          "subscriptions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SubscriptionInfo"
            },
            "description": "List of subscriptions matching the filter criteria"
          },
          "totalCount": {
            "type": "integer",
            "description": "Total number of subscriptions matching the filter"
          }
        }
      },
      "SuggestRelatedRequest": {
        "description": "Request to get related topic suggestions based on a source",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "suggestionSource"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace for suggestions"
          },
          "suggestionSource": {
            "$ref": "#/components/schemas/SuggestionSource",
            "description": "Type of source to base suggestions on"
          },
          "sourceValue": {
            "type": "string",
            "description": "The value for the suggestion source (document ID, slug, topic, or category)"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Optional session ID for personalized suggestions"
          },
          "maxSuggestions": {
            "type": "integer",
            "default": 5,
            "minimum": 1,
            "maximum": 10,
            "description": "Maximum number of suggestions to return"
          },
          "excludeRecentlyViewed": {
            "type": "boolean",
            "default": true,
            "description": "Exclude documents viewed in current session"
          }
        }
      },
      "SuggestRelatedResponse": {
        "description": "Response containing suggested related topics for conversational flow",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace",
          "suggestions"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "description": "The namespace suggestions are from"
          },
          "suggestions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TopicSuggestion"
            },
            "description": "List of suggested related topics"
          },
          "voicePrompt": {
            "type": "string",
            "description": "Voice-friendly prompt for presenting suggestions"
          },
          "sessionInfluenced": {
            "type": "boolean",
            "description": "Whether suggestions were influenced by session history"
          }
        }
      },
      "SuggestionSource": {
        "type": "string",
        "enum": [
          "document_id",
          "slug",
          "topic",
          "category"
        ],
        "description": "Source type for generating related topic suggestions"
      },
      "SyncInfo": {
        "description": "Information about a repository sync operation",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "syncId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the sync operation"
          },
          "status": {
            "$ref": "#/components/schemas/SyncStatus",
            "description": "Result status of the sync"
          },
          "triggeredBy": {
            "$ref": "#/components/schemas/SyncTrigger",
            "description": "What triggered the sync"
          },
          "startedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when sync started"
          },
          "completedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when sync completed"
          },
          "commitHash": {
            "type": "string",
            "nullable": true,
            "description": "Git commit hash that was synced (null if sync failed or repo is empty)"
          },
          "documentsProcessed": {
            "type": "integer",
            "description": "Total documents processed in sync"
          }
        }
      },
      "SyncRepositoryRequest": {
        "description": "Request to trigger a manual repository sync",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace to sync"
          },
          "force": {
            "type": "boolean",
            "default": false,
            "description": "Force full re-sync even if commit hash unchanged"
          }
        }
      },
      "SyncRepositoryResponse": {
        "description": "Response containing sync operation results and statistics",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "syncId",
          "status"
        ],
        "properties": {
          "syncId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of this sync operation"
          },
          "status": {
            "$ref": "#/components/schemas/SyncStatus",
            "description": "Result status of the sync"
          },
          "commitHash": {
            "type": "string",
            "nullable": true,
            "description": "Git commit hash that was synced (null if sync failed or repo is empty)"
          },
          "documentsCreated": {
            "type": "integer",
            "description": "Number of new documents created"
          },
          "documentsUpdated": {
            "type": "integer",
            "description": "Number of existing documents updated"
          },
          "documentsDeleted": {
            "type": "integer",
            "description": "Number of documents deleted"
          },
          "documentsFailed": {
            "type": "integer",
            "description": "Number of documents that failed to process"
          },
          "durationMs": {
            "type": "integer",
            "description": "Time taken for sync in milliseconds"
          },
          "errorMessage": {
            "type": "string",
            "nullable": true,
            "description": "Error message if sync failed"
          }
        }
      },
      "SyncStatus": {
        "type": "string",
        "description": "Status of platform synchronization",
        "enum": [
          "pending",
          "synced",
          "failed",
          "not_linked"
        ]
      },
      "SyncTrigger": {
        "type": "string",
        "enum": [
          "manual",
          "scheduled"
        ],
        "description": "What triggered the sync operation"
      },
      "TemplateStatus": {
        "type": "string",
        "enum": [
          "Draft",
          "Active",
          "Deprecated"
        ],
        "description": "Current lifecycle status of a scenario template"
      },
      "TempoEvent": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.TempoEvent",
        "description": "A tempo change event",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "tick",
          "bpm"
        ],
        "properties": {
          "tick": {
            "type": "integer",
            "minimum": 0,
            "description": "Tick position"
          },
          "bpm": {
            "type": "number",
            "format": "float",
            "minimum": 20,
            "maximum": 400,
            "description": "Tempo in BPM"
          }
        }
      },
      "TempoRange": {
        "description": "A tempo range with min and max BPM",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "min",
          "max"
        ],
        "properties": {
          "min": {
            "type": "integer",
            "minimum": 20,
            "maximum": 400,
            "description": "Minimum tempo"
          },
          "max": {
            "type": "integer",
            "minimum": 20,
            "maximum": 400,
            "description": "Maximum tempo"
          }
        }
      },
      "TerminateContractInstanceRequest": {
        "type": "object",
        "description": "Request to terminate a contract",
        "additionalProperties": false,
        "required": [
          "contractId",
          "requestingEntityId",
          "requestingEntityType"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract to terminate"
          },
          "requestingEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "Entity requesting termination"
          },
          "requestingEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of requesting entity"
          },
          "reason": {
            "type": "string",
            "maxLength": 1000,
            "nullable": true,
            "description": "Reason for termination"
          }
        }
      },
      "TerminateSessionRequest": {
        "type": "object",
        "description": "Request to terminate a specific session",
        "additionalProperties": false,
        "required": [
          "sessionId"
        ],
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the session to terminate"
          }
        }
      },
      "TerminationPolicy": {
        "type": "string",
        "description": "How the contract can be terminated",
        "enum": [
          "mutual_consent",
          "unilateral_with_notice",
          "unilateral_immediate",
          "non_terminable"
        ]
      },
      "TerritoryClaimResponse": {
        "type": "object",
        "description": "A faction's territory claim on a location",
        "additionalProperties": false,
        "required": [
          "claimId",
          "factionId",
          "locationId",
          "status",
          "claimedAt"
        ],
        "properties": {
          "claimId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this territory claim"
          },
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction that holds this claim"
          },
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "Location that is claimed"
          },
          "status": {
            "$ref": "#/components/schemas/TerritoryClaimStatus",
            "description": "Current status of the territory claim"
          },
          "claimedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the territory was claimed"
          },
          "releasedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When the territory was released (null if still active)"
          }
        }
      },
      "TerritoryClaimStatus": {
        "type": "string",
        "description": "Lifecycle status of a territory claim",
        "enum": [
          "Active",
          "Contested",
          "Released"
        ]
      },
      "TerritoryMode": {
        "type": "string",
        "description": "Territory validation mode for constraint checking",
        "enum": [
          "exclusive",
          "inclusive"
        ]
      },
      "TestScenarioRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to dry-run scenario trigger",
        "required": [
          "scenarioId",
          "characterId",
          "characterState"
        ],
        "properties": {
          "scenarioId": {
            "type": "string",
            "format": "uuid",
            "description": "Scenario to test"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to test against"
          },
          "characterState": {
            "$ref": "#/components/schemas/CharacterStateSnapshot",
            "description": "Current character state"
          },
          "locationId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Location context"
          },
          "timeOfDay": {
            "type": "integer",
            "minimum": 0,
            "maximum": 23,
            "nullable": true,
            "description": "Current in-game hour"
          },
          "worldState": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "World state context"
          }
        }
      },
      "TestScenarioResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of scenario dry-run",
        "required": [
          "wouldTrigger",
          "conditionResults"
        ],
        "properties": {
          "wouldTrigger": {
            "type": "boolean",
            "description": "Whether scenario would trigger"
          },
          "conditionResults": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConditionResult"
            },
            "description": "Result of each condition check"
          },
          "predictedMutations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PredictedMutation"
            },
            "nullable": true,
            "description": "Mutations that would be applied"
          },
          "blockingReason": {
            "type": "string",
            "nullable": true,
            "description": "Why scenario would not trigger (cooldown, exclusivity, etc.)"
          }
        }
      },
      "ThemeConfig": {
        "description": "Visual theme configuration including colors, fonts, and navigation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "themeName",
          "primaryColor"
        ],
        "properties": {
          "themeName": {
            "type": "string",
            "description": "Name of the active theme"
          },
          "primaryColor": {
            "type": "string",
            "pattern": "^#[0-9A-Fa-f]{6}$",
            "description": "Primary brand color in hex format"
          },
          "secondaryColor": {
            "type": "string",
            "pattern": "^#[0-9A-Fa-f]{6}$",
            "description": "Secondary brand color in hex format"
          },
          "backgroundColor": {
            "type": "string",
            "pattern": "^#[0-9A-Fa-f]{6}$",
            "description": "Default background color in hex format"
          },
          "textColor": {
            "type": "string",
            "pattern": "^#[0-9A-Fa-f]{6}$",
            "description": "Default text color in hex format"
          },
          "fontFamily": {
            "type": "string",
            "description": "Primary font family for the site"
          },
          "customCSS": {
            "type": "string",
            "nullable": true,
            "description": "Additional custom CSS styles"
          },
          "logo": {
            "description": "Site logo configuration for branding",
            "$ref": "#/components/schemas/Logo"
          },
          "favicon": {
            "type": "string",
            "format": "uri",
            "nullable": true,
            "description": "URL of the site favicon"
          },
          "navigation": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NavigationItem"
            },
            "description": "Main navigation menu items"
          }
        }
      },
      "TicketStatus": {
        "type": "string",
        "description": "Current status of a matchmaking ticket",
        "enum": [
          "searching",
          "match_found",
          "match_accepted",
          "cancelled",
          "expired"
        ]
      },
      "TimeSignatureEvent": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Output.TimeSignatureEvent",
        "description": "A time signature change event",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "tick",
          "numerator",
          "denominator"
        ],
        "properties": {
          "tick": {
            "type": "integer",
            "minimum": 0,
            "description": "Tick position"
          },
          "numerator": {
            "type": "integer",
            "minimum": 1,
            "maximum": 32,
            "description": "Beats per measure"
          },
          "denominator": {
            "type": "integer",
            "minimum": 1,
            "maximum": 32,
            "description": "Beat unit (4 = quarter, 8 = eighth)"
          }
        }
      },
      "TopicSuggestion": {
        "description": "A suggested related topic with relevance context",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "documentId",
          "title"
        ],
        "properties": {
          "documentId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the suggested document"
          },
          "slug": {
            "type": "string",
            "description": "URL-friendly slug of the suggested document"
          },
          "title": {
            "type": "string",
            "description": "Title of the suggested document"
          },
          "category": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "Category of the suggested document"
          },
          "relevanceReason": {
            "type": "string",
            "description": "Explanation of why this document is relevant"
          }
        }
      },
      "TraitAxis": {
        "type": "string",
        "description": "Core personality trait axes. Each represents a spectrum from -1.0 to +1.0.\nBased on psychological research (Big Five + game-relevant extensions).\n",
        "enum": [
          "OPENNESS",
          "CONSCIENTIOUSNESS",
          "EXTRAVERSION",
          "AGREEABLENESS",
          "NEUROTICISM",
          "HONESTY",
          "AGGRESSION",
          "LOYALTY"
        ]
      },
      "TraitSnapshot": {
        "type": "object",
        "additionalProperties": false,
        "description": "Snapshot of a personality trait",
        "required": [
          "axis",
          "value"
        ],
        "properties": {
          "axis": {
            "type": "string",
            "description": "Trait axis name (e.g., AGGRESSION, OPENNESS)"
          },
          "value": {
            "type": "number",
            "format": "float",
            "description": "Trait value (-1.0 to 1.0)"
          }
        }
      },
      "TraitValue": {
        "type": "object",
        "description": "A single personality trait with its current value and evolution history",
        "additionalProperties": false,
        "required": [
          "axis",
          "value"
        ],
        "properties": {
          "axis": {
            "$ref": "#/components/schemas/TraitAxis",
            "description": "The personality axis this value represents"
          },
          "value": {
            "type": "number",
            "format": "float",
            "minimum": -1.0,
            "maximum": 1.0,
            "description": "Current trait value on the spectrum (-1.0 to +1.0)"
          },
          "lastChangedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When this trait last evolved (null if never changed since creation)"
          },
          "changeCount": {
            "type": "integer",
            "default": 0,
            "description": "Number of times this trait has evolved"
          }
        }
      },
      "TransactionResponse": {
        "type": "object",
        "description": "Transaction details",
        "additionalProperties": false,
        "required": [
          "transaction"
        ],
        "properties": {
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Transaction record"
          }
        }
      },
      "TransactionType": {
        "type": "string",
        "description": "Classification of the currency transaction",
        "enum": [
          "mint",
          "quest_reward",
          "loot_drop",
          "vendor_sale",
          "autogain",
          "refund",
          "conversion_credit",
          "burn",
          "vendor_purchase",
          "fee",
          "expiration",
          "cap_overflow",
          "conversion_debit",
          "transfer",
          "trade",
          "gift",
          "escrow_deposit",
          "escrow_release",
          "escrow_refund"
        ]
      },
      "TransferContractPartyRequest": {
        "type": "object",
        "description": "Request to transfer a party role to a new entity",
        "additionalProperties": false,
        "required": [
          "contractInstanceId",
          "fromEntityId",
          "fromEntityType",
          "toEntityId",
          "toEntityType",
          "guardianId",
          "guardianType"
        ],
        "properties": {
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "fromEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "Current party entity ID"
          },
          "fromEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Current party entity type"
          },
          "toEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "New entity ID to receive the role"
          },
          "toEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "New entity type"
          },
          "guardianId": {
            "type": "string",
            "format": "uuid",
            "description": "Guardian entity ID (must be current guardian)"
          },
          "guardianType": {
            "type": "string",
            "maxLength": 64,
            "description": "Guardian entity type"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Optional idempotency key for the operation"
          }
        }
      },
      "TransferContractPartyResponse": {
        "type": "object",
        "description": "Response from transferring a party role",
        "additionalProperties": false,
        "required": [
          "transferred",
          "contractId"
        ],
        "properties": {
          "transferred": {
            "type": "boolean",
            "description": "Whether the transfer was successful"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "role": {
            "type": "string",
            "description": "Role that was transferred"
          },
          "fromEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "Previous party entity ID"
          },
          "toEntityId": {
            "type": "string",
            "format": "uuid",
            "description": "New party entity ID"
          }
        }
      },
      "TransferCurrencyRequest": {
        "type": "object",
        "description": "Request to transfer currency between wallets",
        "additionalProperties": false,
        "required": [
          "sourceWalletId",
          "targetWalletId",
          "currencyDefinitionId",
          "amount",
          "transactionType",
          "idempotencyKey"
        ],
        "properties": {
          "sourceWalletId": {
            "type": "string",
            "format": "uuid",
            "description": "Source wallet ID"
          },
          "targetWalletId": {
            "type": "string",
            "format": "uuid",
            "description": "Target wallet ID"
          },
          "currencyDefinitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Currency to transfer"
          },
          "amount": {
            "type": "number",
            "format": "double",
            "description": "Amount to transfer (must be positive)"
          },
          "transactionType": {
            "$ref": "#/components/schemas/TransactionType",
            "description": "Must be a transfer type (transfer, trade, gift)"
          },
          "referenceType": {
            "type": "string",
            "nullable": true,
            "description": "What triggered this transfer"
          },
          "referenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Reference entity ID"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 128,
            "description": "Unique key to prevent duplicate processing"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Free-form transaction metadata"
          }
        }
      },
      "TransferCurrencyResponse": {
        "type": "object",
        "description": "Result of transfer operation",
        "additionalProperties": false,
        "required": [
          "transaction",
          "sourceNewBalance",
          "targetNewBalance",
          "targetCapApplied"
        ],
        "properties": {
          "transaction": {
            "$ref": "#/components/schemas/CurrencyTransactionRecord",
            "description": "Created transaction record"
          },
          "sourceNewBalance": {
            "type": "number",
            "format": "double",
            "description": "Source wallet balance after transfer"
          },
          "targetNewBalance": {
            "type": "number",
            "format": "double",
            "description": "Target wallet balance after transfer"
          },
          "targetCapApplied": {
            "type": "boolean",
            "description": "Whether target wallet cap was applied"
          },
          "targetCapAmountLost": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Amount lost due to target wallet cap"
          }
        }
      },
      "TransferItemRequest": {
        "type": "object",
        "description": "Request to transfer item ownership",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "targetContainerId"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance ID"
          },
          "targetContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "Target container ID"
          },
          "quantity": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Quantity to transfer (all if null)"
          }
        }
      },
      "TransferItemResponse": {
        "type": "object",
        "description": "Response after transfer",
        "additionalProperties": false,
        "required": [
          "success",
          "instanceId",
          "sourceContainerId",
          "targetContainerId",
          "quantityTransferred"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether transfer succeeded"
          },
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Transferred item ID"
          },
          "sourceContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "Previous container"
          },
          "targetContainerId": {
            "type": "string",
            "format": "uuid",
            "description": "New container"
          },
          "quantityTransferred": {
            "type": "number",
            "format": "double",
            "description": "Amount transferred"
          }
        }
      },
      "TransferResult": {
        "type": "object",
        "description": "Result of transferring assets to a party during resolution",
        "required": [
          "partyId",
          "success"
        ],
        "properties": {
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party ID"
          },
          "assets": {
            "$ref": "#/components/schemas/EscrowAssetBundle",
            "description": "Assets transferred (null if failed)",
            "nullable": true
          },
          "success": {
            "type": "boolean",
            "description": "Whether transfer succeeded"
          },
          "error": {
            "type": "string",
            "nullable": true,
            "description": "Error message if failed"
          }
        }
      },
      "Transform": {
        "type": "object",
        "description": "Position, rotation, and scale in 3D space",
        "required": [
          "position",
          "rotation",
          "scale"
        ],
        "properties": {
          "position": {
            "$ref": "#/components/schemas/Vector3",
            "description": "Position relative to parent"
          },
          "rotation": {
            "$ref": "#/components/schemas/Quaternion",
            "description": "Rotation relative to parent"
          },
          "scale": {
            "$ref": "#/components/schemas/Vector3",
            "description": "Scale relative to parent"
          }
        }
      },
      "TriggerCondition": {
        "type": "object",
        "additionalProperties": false,
        "description": "A condition that must be met for scenario triggering",
        "required": [
          "conditionType"
        ],
        "properties": {
          "conditionType": {
            "$ref": "#/components/schemas/TriggerConditionType",
            "description": "Type of condition to evaluate"
          },
          "traitAxis": {
            "type": "string",
            "nullable": true,
            "description": "Personality trait axis for TraitRange (e.g., AGGRESSION)"
          },
          "traitMin": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "description": "Minimum trait value for TraitRange (-1.0 to 1.0)"
          },
          "traitMax": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "description": "Maximum trait value for TraitRange (-1.0 to 1.0)"
          },
          "backstoryType": {
            "type": "string",
            "nullable": true,
            "description": "Backstory element type for BackstoryElement (e.g., TRAUMA)"
          },
          "backstoryKey": {
            "type": "string",
            "nullable": true,
            "description": "Backstory element key for BackstoryElement"
          },
          "relationshipTypeCode": {
            "type": "string",
            "nullable": true,
            "description": "Relationship type code for RelationshipExists/Missing"
          },
          "otherEntityType": {
            "type": "string",
            "nullable": true,
            "description": "Type of other entity in relationship check"
          },
          "ageMin": {
            "type": "integer",
            "nullable": true,
            "description": "Minimum character age for AgeRange"
          },
          "ageMax": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum character age for AgeRange"
          },
          "locationId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Required location ID for LocationAt"
          },
          "timeOfDayMin": {
            "type": "integer",
            "minimum": 0,
            "maximum": 23,
            "nullable": true,
            "description": "Minimum hour of day (0-23) for TimeOfDay"
          },
          "timeOfDayMax": {
            "type": "integer",
            "minimum": 0,
            "maximum": 23,
            "nullable": true,
            "description": "Maximum hour of day (0-23) for TimeOfDay"
          },
          "worldStateKey": {
            "type": "string",
            "nullable": true,
            "description": "Custom state key for WorldState/Custom"
          },
          "worldStateValue": {
            "type": "string",
            "nullable": true,
            "description": "Expected value for WorldState/Custom"
          }
        }
      },
      "TriggerConditionType": {
        "type": "string",
        "enum": [
          "TraitRange",
          "BackstoryElement",
          "RelationshipExists",
          "RelationshipMissing",
          "AgeRange",
          "LocationAt",
          "TimeOfDay",
          "WorldState",
          "Custom"
        ],
        "description": "Types of trigger conditions for scenario activation.\nTraitRange: Character trait within value range\nBackstoryElement: Character has specific backstory element\nRelationshipExists: Relationship exists between entities\nRelationshipMissing: Relationship does not exist\nAgeRange: Character age within range\nLocationAt: Character at specific location\nTimeOfDay: In-game time within range\nWorldState: Custom world state check\nCustom: Custom condition (not evaluated server-side)\n"
      },
      "TriggerMode": {
        "type": "string",
        "enum": [
          "Proximity",
          "Interaction",
          "Prompted",
          "Forced"
        ],
        "description": "How a POI is triggered by the player"
      },
      "TuneType": {
        "description": "A style-specific tune type definition",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "name",
          "meter"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Tune type name (e.g., \"reel\", \"jig\")"
          },
          "meter": {
            "$ref": "#/components/schemas/TimeSignatureEvent",
            "description": "Time signature for this tune type"
          },
          "tempoRange": {
            "$ref": "#/components/schemas/TempoRange",
            "nullable": true,
            "description": "Typical tempo range"
          },
          "defaultForm": {
            "type": "string",
            "nullable": true,
            "description": "Default form for this tune type"
          },
          "rhythmPatterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Rhythm pattern names to use"
          }
        }
      },
      "UnbanParticipantRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to remove a ban for a participant",
        "required": [
          "roomId",
          "targetSessionId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID"
          },
          "targetSessionId": {
            "type": "string",
            "format": "uuid",
            "description": "Session ID of participant to unban"
          }
        }
      },
      "UndeprecateFactionRequest": {
        "type": "object",
        "description": "Request to reactivate a deprecated faction",
        "additionalProperties": false,
        "required": [
          "factionId"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the faction to reactivate"
          }
        }
      },
      "UndeprecateSeedTypeRequest": {
        "type": "object",
        "description": "Request to restore a deprecated seed type to active status.",
        "additionalProperties": false,
        "required": [
          "seedTypeCode"
        ],
        "properties": {
          "seedTypeCode": {
            "type": "string",
            "description": "The seed type to restore."
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "The game service scope. Null for cross-game seed types."
          }
        }
      },
      "UnlockContractRequest": {
        "type": "object",
        "description": "Request to unlock a contract from guardian custody",
        "additionalProperties": false,
        "required": [
          "contractInstanceId",
          "guardianId",
          "guardianType"
        ],
        "properties": {
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID to unlock"
          },
          "guardianId": {
            "type": "string",
            "format": "uuid",
            "description": "Guardian entity ID (must match current guardian)"
          },
          "guardianType": {
            "type": "string",
            "maxLength": 64,
            "description": "Guardian entity type"
          },
          "idempotencyKey": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Optional idempotency key for the operation"
          }
        }
      },
      "UnlockContractResponse": {
        "type": "object",
        "description": "Response from unlocking a contract",
        "additionalProperties": false,
        "required": [
          "unlocked",
          "contractId"
        ],
        "properties": {
          "unlocked": {
            "type": "boolean",
            "description": "Whether the contract was unlocked"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          }
        }
      },
      "UnlockLicenseRequest": {
        "type": "object",
        "description": "Request to unlock a license on a board",
        "additionalProperties": false,
        "required": [
          "boardId",
          "licenseCode"
        ],
        "properties": {
          "boardId": {
            "type": "string",
            "format": "uuid",
            "description": "Board instance to unlock on"
          },
          "licenseCode": {
            "type": "string",
            "description": "License code to unlock"
          }
        }
      },
      "UnlockLicenseResponse": {
        "type": "object",
        "description": "Result of a successful license unlock",
        "additionalProperties": false,
        "required": [
          "boardId",
          "licenseCode",
          "position",
          "itemInstanceId",
          "contractInstanceId"
        ],
        "properties": {
          "boardId": {
            "type": "string",
            "format": "uuid",
            "description": "Board the license was unlocked on"
          },
          "licenseCode": {
            "type": "string",
            "description": "License code that was unlocked"
          },
          "position": {
            "$ref": "#/components/schemas/GridPosition",
            "description": "Grid position of the unlocked license"
          },
          "itemInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance created for this license"
          },
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance created for this unlock"
          }
        }
      },
      "UnlockedAchievement": {
        "type": "object",
        "description": "An unlocked achievement instance",
        "additionalProperties": false,
        "required": [
          "achievementId",
          "displayName",
          "points",
          "unlockedAt"
        ],
        "properties": {
          "achievementId": {
            "type": "string",
            "description": "Achievement identifier"
          },
          "displayName": {
            "type": "string",
            "description": "Achievement name"
          },
          "description": {
            "type": "string",
            "description": "Achievement description"
          },
          "points": {
            "type": "integer",
            "description": "Point value"
          },
          "iconUrl": {
            "type": "string",
            "nullable": true,
            "description": "Achievement icon"
          },
          "unlockedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When it was unlocked"
          }
        }
      },
      "UnlockedEntryResponse": {
        "type": "object",
        "description": "An unlocked entry with template info and metadata",
        "additionalProperties": false,
        "required": [
          "entryTemplateId",
          "code",
          "displayName",
          "itemInstanceId",
          "unlockedAt"
        ],
        "properties": {
          "entryTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Entry template identifier"
          },
          "code": {
            "type": "string",
            "description": "Entry code"
          },
          "displayName": {
            "type": "string",
            "description": "Display name from the template"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Category from the template"
          },
          "tags": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Tags from the template"
          },
          "itemInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance for this unlocked entry"
          },
          "unlockedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this entry was unlocked"
          },
          "metadata": {
            "$ref": "#/components/schemas/EntryMetadata",
            "description": "Entry instance metadata"
          }
        }
      },
      "UnpinMessageRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to unpin a message in a room",
        "required": [
          "roomId",
          "messageId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room the message belongs to"
          },
          "messageId": {
            "type": "string",
            "format": "uuid",
            "description": "Message ID to unpin"
          }
        }
      },
      "UnpinVersionRequest": {
        "type": "object",
        "description": "Request to unpin a previously pinned save version",
        "required": [
          "ownerId",
          "ownerType",
          "slotName",
          "versionNumber"
        ],
        "properties": {
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Slot name"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Version to unpin"
          }
        }
      },
      "UnregisterFollowerRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to unregister a character as a deity follower",
        "required": [
          "deityId",
          "characterId"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity to unfollow"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character to remove as follower"
          }
        }
      },
      "UnregisterReferenceRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to unregister a reference to a resource",
        "required": [
          "resourceType",
          "resourceId",
          "sourceType",
          "sourceId"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource being dereferenced (opaque identifier)"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource being dereferenced"
          },
          "sourceType": {
            "type": "string",
            "description": "Type of entity releasing the reference (opaque identifier)"
          },
          "sourceId": {
            "type": "string",
            "description": "ID of the entity releasing the reference (opaque string, supports non-Guid IDs)"
          }
        }
      },
      "UnregisterReferenceResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response after unregistering a reference",
        "required": [
          "resourceType",
          "resourceId",
          "newRefCount",
          "wasRegistered"
        ],
        "properties": {
          "resourceType": {
            "type": "string",
            "description": "Type of resource dereferenced"
          },
          "resourceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the resource dereferenced"
          },
          "newRefCount": {
            "type": "integer",
            "description": "Reference count after unregistration"
          },
          "wasRegistered": {
            "type": "boolean",
            "description": "True if this reference existed before unregistration"
          },
          "gracePeriodStartedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When grace period started (null if refCount > 0)"
          }
        }
      },
      "UnresolvedReference": {
        "type": "object",
        "description": "A scene reference that could not be resolved",
        "required": [
          "nodeId",
          "refId",
          "referencedSceneId",
          "reason"
        ],
        "properties": {
          "nodeId": {
            "type": "string",
            "format": "uuid",
            "description": "Node ID containing the reference"
          },
          "refId": {
            "type": "string",
            "description": "refId of the referencing node"
          },
          "referencedSceneId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the scene that could not be resolved"
          },
          "reason": {
            "$ref": "#/components/schemas/UnresolvedReferenceReason",
            "description": "Why the reference could not be resolved"
          },
          "cyclePath": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "For circular references, the cycle path (sceneId chain)"
          }
        }
      },
      "UnresolvedReferenceReason": {
        "type": "string",
        "description": "Reason why a scene reference could not be resolved",
        "enum": [
          "not_found",
          "circular_reference",
          "depth_exceeded",
          "access_denied"
        ]
      },
      "UpdateAchievementDefinitionRequest": {
        "type": "object",
        "description": "Request to update an achievement definition",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "achievementId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "achievementId": {
            "type": "string",
            "description": "ID of the achievement to update"
          },
          "displayName": {
            "type": "string",
            "maxLength": 100,
            "nullable": true,
            "description": "New display name"
          },
          "description": {
            "type": "string",
            "maxLength": 500,
            "nullable": true,
            "description": "New description"
          },
          "isActive": {
            "type": "boolean",
            "nullable": true,
            "description": "New active status"
          },
          "platformIds": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Updated platform ID mappings"
          }
        }
      },
      "UpdateActorTemplateRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to update an existing actor template",
        "required": [
          "templateId"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the template to update"
          },
          "behaviorRef": {
            "type": "string",
            "nullable": true,
            "description": "New behavior reference (triggers behavior.updated subscription)"
          },
          "configuration": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Updated configuration settings"
          },
          "autoSpawn": {
            "description": "Updated auto-spawn configuration",
            "nullable": true,
            "$ref": "#/components/schemas/AutoSpawnConfig"
          },
          "tickIntervalMs": {
            "type": "integer",
            "nullable": true,
            "description": "Updated tick interval in milliseconds"
          },
          "autoSaveIntervalSeconds": {
            "type": "integer",
            "nullable": true,
            "description": "Updated auto-save interval in seconds"
          },
          "cognitionTemplateId": {
            "type": "string",
            "nullable": true,
            "description": "Updated cognition template ID. Set to override the cognition pipeline\nfor actors created from this template.\n"
          },
          "cognitionOverrides": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Updated static template-level cognition overrides. Applied as the first layer\nin the three-layer override composition.\n"
          }
        }
      },
      "UpdateBoardTemplateRequest": {
        "type": "object",
        "description": "Request to update mutable fields of a board template",
        "additionalProperties": false,
        "required": [
          "boardTemplateId"
        ],
        "properties": {
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template to update"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "Updated display name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Updated description"
          },
          "isActive": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether the template is active (can create new board instances)"
          },
          "allowedOwnerTypes": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "description": "Updated allowed owner types. Narrowing checks for existing boards with removed types."
          }
        }
      },
      "UpdateBundleRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to update bundle metadata",
        "required": [
          "bundleId"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier to update"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "New bundle name (null to leave unchanged)"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "New bundle description (null to leave unchanged)"
          },
          "tags": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Replace all tags with these (null to leave unchanged)"
          },
          "addTags": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "Tags to add (merged with existing)"
          },
          "removeTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Tag keys to remove"
          },
          "reason": {
            "type": "string",
            "nullable": true,
            "description": "Optional reason for the update (recorded in version history)"
          }
        }
      },
      "UpdateBundleResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Result of bundle update operation",
        "required": [
          "bundleId",
          "version",
          "previousVersion",
          "changes"
        ],
        "properties": {
          "bundleId": {
            "type": "string",
            "description": "Human-readable bundle identifier that was updated"
          },
          "version": {
            "type": "integer",
            "description": "New version number after update"
          },
          "previousVersion": {
            "type": "integer",
            "description": "Version number before update"
          },
          "changes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of changes made (e.g., \"name changed\", \"tag 'env' added\")"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the update occurred"
          }
        }
      },
      "UpdateContainerRequest": {
        "type": "object",
        "description": "Request to update container properties",
        "additionalProperties": false,
        "required": [
          "containerId"
        ],
        "properties": {
          "containerId": {
            "type": "string",
            "format": "uuid",
            "description": "Container ID to update"
          },
          "maxSlots": {
            "type": "integer",
            "nullable": true,
            "description": "New max slots"
          },
          "maxWeight": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "New max weight"
          },
          "gridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "New grid width"
          },
          "gridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "New grid height"
          },
          "maxVolume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "New max volume"
          },
          "allowedCategories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New allowed categories"
          },
          "forbiddenCategories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New forbidden categories"
          },
          "allowedTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New allowed tags"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New container tags"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "description": "New metadata"
          }
        }
      },
      "UpdateContractMetadataRequest": {
        "type": "object",
        "description": "Request to update contract metadata",
        "additionalProperties": false,
        "required": [
          "contractId",
          "metadataType",
          "data"
        ],
        "properties": {
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance ID"
          },
          "metadataType": {
            "$ref": "#/components/schemas/MetadataType",
            "description": "Which metadata to update"
          },
          "data": {
            "type": "object",
            "additionalProperties": true,
            "description": "Metadata to set or merge"
          }
        }
      },
      "UpdateDefinitionRequest": {
        "type": "object",
        "description": "Request to update a map definition",
        "required": [
          "definitionId"
        ],
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Definition ID to update"
          },
          "name": {
            "type": "string",
            "description": "New name (optional)",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "New description (optional)",
            "nullable": true
          },
          "layers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LayerDefinition"
            },
            "description": "New layer configurations (replaces existing)",
            "nullable": true
          },
          "defaultBounds": {
            "$ref": "#/components/schemas/Bounds",
            "description": "New default bounds",
            "nullable": true
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "description": "New metadata (replaces existing)",
            "nullable": true
          }
        }
      },
      "UpdateDeityRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to update deity properties (partial update, only non-null fields applied)",
        "required": [
          "deityId"
        ],
        "properties": {
          "deityId": {
            "type": "string",
            "format": "uuid",
            "description": "Deity to update"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Updated display name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Updated description"
          },
          "domains": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/DomainInfluence"
            },
            "description": "Updated domain influences (replaces entire list)"
          },
          "personalityTraits": {
            "nullable": true,
            "description": "Updated personality traits",
            "allOf": [
              {
                "$ref": "#/components/schemas/DeityPersonalityTraits"
              }
            ]
          },
          "maxAttentionSlots": {
            "type": "integer",
            "nullable": true,
            "minimum": 1,
            "description": "Updated maximum attention slots"
          }
        }
      },
      "UpdateEncounterPhaseRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to update the phase of an active encounter",
        "required": [
          "actorId",
          "phase"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "ID of the Event Brain actor managing the encounter"
          },
          "phase": {
            "type": "string",
            "description": "New phase name for the encounter"
          }
        }
      },
      "UpdateEncounterPhaseResponse": {
        "type": "object",
        "additionalProperties": false,
        "description": "Response after updating encounter phase",
        "required": [
          "actorId",
          "currentPhase"
        ],
        "properties": {
          "actorId": {
            "type": "string",
            "description": "ID of the actor managing the encounter"
          },
          "previousPhase": {
            "type": "string",
            "nullable": true,
            "description": "Previous phase name"
          },
          "currentPhase": {
            "type": "string",
            "description": "Current phase name after update"
          }
        }
      },
      "UpdateEntryMetadataRequest": {
        "type": "object",
        "description": "Request to update metadata for an unlocked entry",
        "additionalProperties": false,
        "required": [
          "collectionId",
          "entryCode"
        ],
        "properties": {
          "collectionId": {
            "type": "string",
            "format": "uuid",
            "description": "Collection containing the entry"
          },
          "entryCode": {
            "type": "string",
            "description": "Entry code to update metadata for"
          },
          "playCount": {
            "type": "integer",
            "nullable": true,
            "description": "Updated play count (replaces current value)"
          },
          "killCount": {
            "type": "integer",
            "nullable": true,
            "description": "Updated kill count (replaces current value)"
          },
          "favorited": {
            "type": "boolean",
            "nullable": true,
            "description": "Updated favorite status"
          },
          "discoveryLevel": {
            "type": "integer",
            "nullable": true,
            "description": "Updated discovery level"
          },
          "customData": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Updated custom data (merged with existing)"
          }
        }
      },
      "UpdateEntryTemplateRequest": {
        "type": "object",
        "description": "Request to update mutable fields of an entry template",
        "additionalProperties": false,
        "required": [
          "entryTemplateId"
        ],
        "properties": {
          "entryTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Entry template to update"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Updated display name"
          },
          "category": {
            "type": "string",
            "nullable": true,
            "description": "Updated category"
          },
          "tags": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Updated tags"
          },
          "assetId": {
            "type": "string",
            "nullable": true,
            "description": "Updated primary asset identifier"
          },
          "thumbnailAssetId": {
            "type": "string",
            "nullable": true,
            "description": "Updated thumbnail asset identifier"
          },
          "unlockHint": {
            "type": "string",
            "nullable": true,
            "description": "Updated unlock hint text"
          },
          "hideWhenLocked": {
            "type": "boolean",
            "nullable": true,
            "description": "Updated spoiler protection flag"
          },
          "discoveryLevels": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/DiscoveryLevel"
            },
            "description": "Updated discovery levels"
          },
          "themes": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Updated theme tags for music entries"
          },
          "duration": {
            "type": "string",
            "nullable": true,
            "description": "Updated duration"
          },
          "loopPoint": {
            "type": "string",
            "nullable": true,
            "description": "Updated loop point"
          },
          "composer": {
            "type": "string",
            "nullable": true,
            "description": "Updated composer name"
          }
        }
      },
      "UpdateFactionRequest": {
        "type": "object",
        "description": "Request to update a faction",
        "additionalProperties": false,
        "required": [
          "factionId"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the faction to update"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "minLength": 1,
            "maxLength": 256,
            "description": "New display name (null to keep current)"
          },
          "code": {
            "type": "string",
            "nullable": true,
            "minLength": 1,
            "maxLength": 128,
            "description": "New code (null to keep current, must be unique within game service)"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "maxLength": 2048,
            "description": "New description (null to keep current)"
          }
        }
      },
      "UpdateItemTemplateRequest": {
        "type": "object",
        "description": "Request to update mutable fields of an item template",
        "additionalProperties": false,
        "required": [
          "templateId"
        ],
        "properties": {
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template ID to update"
          },
          "name": {
            "type": "string",
            "maxLength": 128,
            "nullable": true,
            "description": "New display name"
          },
          "description": {
            "type": "string",
            "maxLength": 1000,
            "nullable": true,
            "description": "New description"
          },
          "subcategory": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "New subcategory"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New tags (replaces existing)"
          },
          "rarity": {
            "$ref": "#/components/schemas/ItemRarity",
            "description": "New rarity tier"
          },
          "weight": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "New weight value"
          },
          "volume": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "New volume value"
          },
          "gridWidth": {
            "type": "integer",
            "nullable": true,
            "description": "New grid width"
          },
          "gridHeight": {
            "type": "integer",
            "nullable": true,
            "description": "New grid height"
          },
          "canRotate": {
            "type": "boolean",
            "nullable": true,
            "description": "New rotation setting"
          },
          "baseValue": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "New base value"
          },
          "tradeable": {
            "type": "boolean",
            "nullable": true,
            "description": "New tradeable setting"
          },
          "destroyable": {
            "type": "boolean",
            "nullable": true,
            "description": "New destroyable setting"
          },
          "maxDurability": {
            "type": "integer",
            "nullable": true,
            "description": "New max durability"
          },
          "availableRealms": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "description": "New available realms"
          },
          "stats": {
            "type": "object",
            "nullable": true,
            "description": "New stats"
          },
          "effects": {
            "type": "object",
            "nullable": true,
            "description": "New effects"
          },
          "requirements": {
            "type": "object",
            "nullable": true,
            "description": "New requirements"
          },
          "display": {
            "type": "object",
            "nullable": true,
            "description": "New display properties"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "description": "New metadata"
          },
          "isActive": {
            "type": "boolean",
            "nullable": true,
            "description": "Active status"
          },
          "useBehaviorContractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract template ID for executable item behavior (null to clear)"
          },
          "canUseBehaviorContractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract template for pre-use validation (null to clear)"
          },
          "onUseFailedBehaviorContractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Contract template for use failure handling (null to clear)"
          },
          "itemUseBehavior": {
            "$ref": "#/components/schemas/ItemUseBehavior",
            "nullable": true,
            "description": "How the item should behave when used"
          },
          "canUseBehavior": {
            "$ref": "#/components/schemas/CanUseBehavior",
            "nullable": true,
            "description": "How CanUse validation failures should be handled"
          }
        }
      },
      "UpdateLeaderboardDefinitionRequest": {
        "type": "object",
        "description": "Request to update a leaderboard definition",
        "additionalProperties": false,
        "required": [
          "gameServiceId",
          "leaderboardId"
        ],
        "properties": {
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the game service"
          },
          "leaderboardId": {
            "type": "string",
            "description": "ID of the leaderboard to update"
          },
          "displayName": {
            "type": "string",
            "maxLength": 100,
            "nullable": true,
            "description": "New display name"
          },
          "description": {
            "type": "string",
            "maxLength": 500,
            "nullable": true,
            "description": "New description"
          },
          "isPublic": {
            "type": "boolean",
            "nullable": true,
            "description": "New visibility setting"
          }
        }
      },
      "UpdateLicenseDefinitionRequest": {
        "type": "object",
        "description": "Request to update mutable fields of a license definition",
        "additionalProperties": false,
        "required": [
          "boardTemplateId",
          "code"
        ],
        "properties": {
          "boardTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Board template containing the definition"
          },
          "code": {
            "type": "string",
            "description": "License code to update"
          },
          "lpCost": {
            "type": "integer",
            "minimum": 0,
            "nullable": true,
            "description": "Updated LP cost"
          },
          "prerequisites": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "Updated prerequisite license codes"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Updated description"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Updated game-specific metadata"
          }
        }
      },
      "UpdateMemberRoleRequest": {
        "type": "object",
        "description": "Request to update a member's role",
        "additionalProperties": false,
        "required": [
          "factionId",
          "characterId",
          "role"
        ],
        "properties": {
          "factionId": {
            "type": "string",
            "format": "uuid",
            "description": "Faction containing the membership"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character whose role to update"
          },
          "role": {
            "$ref": "#/components/schemas/FactionMemberRole",
            "description": "New role to assign"
          }
        }
      },
      "UpdateMfaRequest": {
        "type": "object",
        "description": "Request to update MFA settings for an account",
        "additionalProperties": false,
        "required": [
          "accountId",
          "mfaEnabled"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the account to update"
          },
          "mfaEnabled": {
            "type": "boolean",
            "description": "Whether to enable or disable MFA"
          },
          "mfaSecret": {
            "type": "string",
            "nullable": true,
            "description": "Encrypted TOTP secret (set when enabling, null when disabling)"
          },
          "mfaRecoveryCodes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "BCrypt-hashed recovery codes (set when enabling, null when disabling)"
          }
        }
      },
      "UpdateMode": {
        "type": "string",
        "description": "How to handle score updates",
        "enum": [
          "replace",
          "increment",
          "max",
          "min"
        ]
      },
      "UpdateNormRequest": {
        "type": "object",
        "description": "Request to update an existing norm definition",
        "additionalProperties": false,
        "required": [
          "normId"
        ],
        "properties": {
          "normId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the norm to update"
          },
          "basePenalty": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "minimum": 0.0,
            "description": "New base penalty (null to keep current)"
          },
          "severity": {
            "$ref": "#/components/schemas/NormSeverity",
            "nullable": true,
            "description": "New severity level (null to keep current)"
          },
          "scope": {
            "$ref": "#/components/schemas/NormScope",
            "nullable": true,
            "description": "New scope (null to keep current)"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "maxLength": 1024,
            "description": "New description (null to keep current)"
          }
        }
      },
      "UpdatePasswordRequest": {
        "type": "object",
        "description": "Request to update an account password",
        "additionalProperties": false,
        "required": [
          "accountId",
          "passwordHash"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the account to update"
          },
          "passwordHash": {
            "type": "string",
            "description": "New pre-hashed password from Auth service"
          }
        }
      },
      "UpdatePhaseConfigRequest": {
        "type": "object",
        "description": "Request to update deployment phase configuration (non-null fields applied)",
        "properties": {
          "currentPhase": {
            "$ref": "#/components/schemas/DeploymentPhase",
            "nullable": true,
            "description": "New deployment phase"
          },
          "maxConcurrentScenariosGlobal": {
            "type": "integer",
            "nullable": true,
            "description": "Updated global scenario capacity"
          },
          "persistentEntryEnabled": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether persistent world entry is enabled"
          },
          "gardenMinigamesEnabled": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether garden minigames are enabled"
          }
        }
      },
      "UpdatePositionRequest": {
        "type": "object",
        "description": "Request to update player position in the garden",
        "required": [
          "accountId",
          "position",
          "velocity"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Account whose position to update"
          },
          "position": {
            "$ref": "#/components/schemas/Vec3",
            "description": "New position in garden space"
          },
          "velocity": {
            "$ref": "#/components/schemas/Vec3",
            "description": "Current velocity vector"
          }
        }
      },
      "UpdateProfileRequest": {
        "type": "object",
        "description": "Request to update an account profile",
        "additionalProperties": false,
        "required": [
          "accountId"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the account to update"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "maxLength": 100,
            "description": "New display name for the account"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Updated custom metadata for the account"
          }
        }
      },
      "UpdateQuestDefinitionRequest": {
        "type": "object",
        "description": "Request to update quest definition metadata",
        "additionalProperties": false,
        "required": [
          "definitionId"
        ],
        "properties": {
          "definitionId": {
            "type": "string",
            "format": "uuid",
            "description": "Definition to update"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "New name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "New description"
          },
          "category": {
            "description": "New quest category",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/QuestCategory"
              }
            ]
          },
          "difficulty": {
            "description": "New difficulty rating",
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/QuestDifficulty"
              }
            ]
          },
          "tags": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string"
            },
            "description": "New tags"
          }
        }
      },
      "UpdateRepositoryBindingRequest": {
        "description": "Request to update repository binding configuration",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9-]+$",
            "maxLength": 50,
            "description": "Documentation namespace of the binding to update"
          },
          "syncEnabled": {
            "type": "boolean",
            "description": "Enable or disable automatic syncing"
          },
          "syncIntervalMinutes": {
            "type": "integer",
            "minimum": 5,
            "maximum": 1440,
            "description": "New sync interval in minutes"
          },
          "filePatterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New glob patterns for files to include (null to keep unchanged)"
          },
          "excludePatterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New glob patterns for files to exclude (null to keep unchanged)"
          },
          "categoryMapping": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "description": "New directory-to-category mapping (null to keep unchanged)"
          },
          "defaultCategory": {
            "$ref": "#/components/schemas/DocumentCategory",
            "description": "New default category for unmapped documents"
          },
          "archiveEnabled": {
            "type": "boolean",
            "description": "Enable or disable archive functionality"
          },
          "archiveOnSync": {
            "type": "boolean",
            "description": "Enable or disable archiving after each sync"
          }
        }
      },
      "UpdateRepositoryBindingResponse": {
        "description": "Response containing the updated binding configuration",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "binding"
        ],
        "properties": {
          "binding": {
            "$ref": "#/components/schemas/RepositoryBindingInfo",
            "description": "Updated binding configuration"
          }
        }
      },
      "UpdateRoomRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to update room properties (null fields left unchanged)",
        "required": [
          "roomId"
        ],
        "properties": {
          "roomId": {
            "type": "string",
            "format": "uuid",
            "description": "Room ID to update"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Updated room name"
          },
          "maxParticipants": {
            "type": "integer",
            "nullable": true,
            "description": "Updated participant limit"
          },
          "metadata": {
            "type": "string",
            "nullable": true,
            "description": "Updated JSON metadata"
          }
        }
      },
      "UpdateRoomTypeRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to update room type properties (null fields left unchanged)",
        "required": [
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "Room type code to update"
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Game service scope for the type"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Updated display name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Updated description"
          },
          "validatorConfig": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ValidatorConfig"
              }
            ],
            "nullable": true,
            "description": "Updated validation rules"
          },
          "defaultMaxParticipants": {
            "type": "integer",
            "nullable": true,
            "description": "Updated default participant limit"
          },
          "retentionDays": {
            "type": "integer",
            "nullable": true,
            "description": "Updated message retention in days"
          },
          "defaultContractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Updated default contract template"
          },
          "allowAnonymousSenders": {
            "type": "boolean",
            "nullable": true,
            "description": "Updated anonymous sender policy"
          },
          "rateLimitPerMinute": {
            "type": "integer",
            "nullable": true,
            "description": "Updated rate limit"
          },
          "metadata": {
            "type": "string",
            "nullable": true,
            "description": "Updated JSON metadata"
          }
        }
      },
      "UpdateScenarioDefinitionRequest": {
        "type": "object",
        "additionalProperties": false,
        "description": "Request to update a scenario definition",
        "required": [
          "scenarioId",
          "etag"
        ],
        "properties": {
          "scenarioId": {
            "type": "string",
            "format": "uuid",
            "description": "Scenario to update"
          },
          "etag": {
            "type": "string",
            "description": "ETag for optimistic concurrency"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "New name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "New description"
          },
          "triggerConditions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TriggerCondition"
            },
            "nullable": true,
            "description": "New trigger conditions"
          },
          "phases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScenarioPhase"
            },
            "nullable": true,
            "description": "New phases"
          },
          "mutations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScenarioMutation"
            },
            "nullable": true,
            "description": "New mutations"
          },
          "questHooks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScenarioQuestHook"
            },
            "nullable": true,
            "description": "New quest hooks"
          },
          "cooldownSeconds": {
            "type": "integer",
            "minimum": 0,
            "nullable": true,
            "description": "New cooldown"
          },
          "exclusivityTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New exclusivity tags"
          },
          "priority": {
            "type": "integer",
            "nullable": true,
            "description": "New priority"
          },
          "enabled": {
            "type": "boolean",
            "nullable": true,
            "description": "New enabled state"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "New classification tags"
          }
        }
      },
      "UpdateSceneRequest": {
        "type": "object",
        "description": "Request to update an existing scene",
        "required": [
          "scene"
        ],
        "properties": {
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "The updated scene document (sceneId must match existing)"
          },
          "checkoutToken": {
            "type": "string",
            "nullable": true,
            "description": "Checkout token if updating via checkout workflow"
          }
        }
      },
      "UpdateSeedRequest": {
        "type": "object",
        "description": "Request to update a seed's mutable fields.",
        "required": [
          "seedId"
        ],
        "properties": {
          "seedId": {
            "type": "string",
            "format": "uuid",
            "description": "The seed to update."
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "New display name."
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Metadata fields to merge (set key to null to delete)."
          }
        }
      },
      "UpdateSeedTypeRequest": {
        "type": "object",
        "description": "Request to update a seed type definition.",
        "required": [
          "seedTypeCode"
        ],
        "properties": {
          "seedTypeCode": {
            "type": "string",
            "description": "The seed type to update."
          },
          "gameServiceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "The game service scope. Null for cross-game seed types."
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "New display name."
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "New description."
          },
          "maxPerOwner": {
            "type": "integer",
            "nullable": true,
            "description": "Updated maximum per owner."
          },
          "growthPhases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GrowthPhaseDefinition"
            },
            "nullable": true,
            "description": "Updated phase definitions."
          },
          "capabilityRules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CapabilityRule"
            },
            "nullable": true,
            "description": "Updated capability rules."
          },
          "growthDecayEnabled": {
            "type": "boolean",
            "nullable": true,
            "description": "Whether unused growth domains decay over time for this seed type. Falls back to global config if null."
          },
          "growthDecayRatePerDay": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "description": "Daily decay rate for unused domains of this seed type. Falls back to global config if null."
          },
          "sameOwnerGrowthMultiplier": {
            "type": "number",
            "format": "float",
            "nullable": true,
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "Updated fraction of growth applied to other seeds of the same type owned by the same entity."
          },
          "collectionGrowthMappings": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/CollectionGrowthMapping"
            },
            "description": "Updated collection growth mappings. Null means no change, empty array removes all mappings.\n"
          }
        }
      },
      "UpdateStatusTemplateRequest": {
        "type": "object",
        "description": "Request to update mutable fields of a status template (null fields are not updated)",
        "additionalProperties": false,
        "required": [
          "statusTemplateId"
        ],
        "properties": {
          "statusTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Status template to update"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Updated display name (null means no change)"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Updated description (null means no change)"
          },
          "category": {
            "nullable": true,
            "description": "Updated status category (null means no change)",
            "allOf": [
              {
                "$ref": "#/components/schemas/StatusCategory"
              }
            ]
          },
          "stackable": {
            "type": "boolean",
            "nullable": true,
            "description": "Updated stackable flag (null means no change)"
          },
          "maxStacks": {
            "type": "integer",
            "minimum": 1,
            "nullable": true,
            "description": "Updated maximum stack count (null means no change)"
          },
          "stackBehavior": {
            "nullable": true,
            "description": "Updated stacking behavior (null means no change)",
            "allOf": [
              {
                "$ref": "#/components/schemas/StackBehavior"
              }
            ]
          },
          "contractTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Updated contract template reference (null means no change)"
          },
          "defaultDurationSeconds": {
            "type": "integer",
            "minimum": 1,
            "nullable": true,
            "description": "Updated default duration in seconds (null means no change)"
          },
          "iconAssetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Updated icon asset reference (null means no change)"
          }
        }
      },
      "UpdateTemplateRequest": {
        "type": "object",
        "description": "Request to update a template (non-null fields are applied)",
        "required": [
          "scenarioTemplateId"
        ],
        "properties": {
          "scenarioTemplateId": {
            "type": "string",
            "format": "uuid",
            "description": "Template ID to update"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Updated display name"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Updated description"
          },
          "domainWeights": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DomainWeight"
            },
            "nullable": true,
            "description": "Updated domain weights"
          },
          "maxConcurrentInstances": {
            "type": "integer",
            "nullable": true,
            "description": "Updated max concurrent instances"
          },
          "prerequisites": {
            "$ref": "#/components/schemas/ScenarioPrerequisites",
            "nullable": true,
            "description": "Updated prerequisites"
          },
          "chaining": {
            "$ref": "#/components/schemas/ScenarioChaining",
            "nullable": true,
            "description": "Updated chaining configuration"
          },
          "multiplayer": {
            "$ref": "#/components/schemas/ScenarioMultiplayer",
            "nullable": true,
            "description": "Updated multiplayer configuration"
          },
          "content": {
            "$ref": "#/components/schemas/ScenarioContent",
            "nullable": true,
            "description": "Updated content references"
          }
        }
      },
      "UpdateVerificationRequest": {
        "type": "object",
        "description": "Request to update email verification status",
        "additionalProperties": false,
        "required": [
          "accountId",
          "emailVerified"
        ],
        "properties": {
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the account to update"
          },
          "emailVerified": {
            "type": "boolean",
            "description": "New email verification status"
          }
        }
      },
      "UploadRequest": {
        "description": "Request to initiate an asset upload and receive a pre-signed URL",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "filename",
          "size",
          "contentType",
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "string",
            "description": "Owner of this asset operation. NOT a session ID.\nFor user-initiated uploads: the accountId (UUID format).\nFor service-initiated uploads: the service name (e.g., \"behavior\", \"orchestrator\").\n"
          },
          "filename": {
            "type": "string",
            "description": "Original filename with extension"
          },
          "size": {
            "type": "integer",
            "format": "int64",
            "description": "File size in bytes"
          },
          "contentType": {
            "type": "string",
            "description": "MIME content type (e.g., image/png, model/gltf-binary)"
          },
          "metadata": {
            "$ref": "#/components/schemas/AssetMetadataInput",
            "description": "Optional metadata for asset categorization"
          }
        }
      },
      "UploadResponse": {
        "description": "Response containing pre-signed URL and configuration for uploading an asset",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "uploadId",
          "uploadUrl",
          "expiresAt"
        ],
        "properties": {
          "uploadId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique upload session identifier"
          },
          "uploadUrl": {
            "type": "string",
            "format": "uri",
            "description": "Pre-signed URL for uploading the file"
          },
          "expiresAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the upload URL expires"
          },
          "multipart": {
            "$ref": "#/components/schemas/MultipartConfig",
            "description": "Configuration for multipart uploads if file size requires it"
          },
          "requiredHeaders": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Headers the client must include when uploading to the pre-signed URL"
          }
        }
      },
      "UseItemRequest": {
        "type": "object",
        "description": "Request to use an item instance by executing its behavior contract",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "userId",
          "userType"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the item instance to use"
          },
          "userId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the entity using the item (character, account, or actor)"
          },
          "userType": {
            "type": "string",
            "maxLength": 64,
            "description": "Type of user entity performing the use action (e.g., character, account, actor)"
          },
          "targetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Optional unique identifier of the target entity for directional item effects"
          },
          "targetType": {
            "type": "string",
            "maxLength": 64,
            "nullable": true,
            "description": "Type of target entity when targetId is provided"
          },
          "context": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional context data passed to contract template value substitution"
          }
        }
      },
      "UseItemResponse": {
        "type": "object",
        "description": "Response containing the result of an item use attempt",
        "additionalProperties": false,
        "required": [
          "success",
          "instanceId",
          "templateId",
          "consumed"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether the item use behavior executed successfully"
          },
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the item instance that was used"
          },
          "templateId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier of the item template defining the used item"
          },
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Unique identifier of the contract instance created for this use (null if creation failed)"
          },
          "consumed": {
            "type": "boolean",
            "description": "Whether the item was consumed (quantity decremented or destroyed)"
          },
          "remainingQuantity": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "description": "Remaining quantity after use (null if item was fully consumed or destroyed)"
          },
          "failureReason": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable reason for failure when success is false"
          }
        }
      },
      "UseItemStepRequest": {
        "type": "object",
        "description": "Request to complete a step of a multi-step item use",
        "additionalProperties": false,
        "required": [
          "instanceId",
          "userId",
          "userType",
          "milestoneCode"
        ],
        "properties": {
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance being used"
          },
          "userId": {
            "type": "string",
            "format": "uuid",
            "description": "User performing the step"
          },
          "userType": {
            "type": "string",
            "maxLength": 64,
            "description": "Type of user entity (e.g., character, account, actor)"
          },
          "milestoneCode": {
            "type": "string",
            "maxLength": 64,
            "description": "Milestone code to complete in the use behavior contract"
          },
          "evidence": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Evidence data for this milestone completion (passed to contract)"
          },
          "context": {
            "type": "object",
            "additionalProperties": true,
            "nullable": true,
            "description": "Additional context data passed to contract template value substitution"
          }
        }
      },
      "UseItemStepResponse": {
        "type": "object",
        "description": "Response from completing a multi-step item use milestone",
        "additionalProperties": false,
        "required": [
          "success",
          "instanceId",
          "contractInstanceId",
          "completedMilestone",
          "isComplete",
          "consumed"
        ],
        "properties": {
          "success": {
            "type": "boolean",
            "description": "Whether the step completed successfully"
          },
          "instanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Item instance ID"
          },
          "contractInstanceId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract instance tracking this use session"
          },
          "completedMilestone": {
            "type": "string",
            "description": "The milestone that was completed"
          },
          "remainingMilestones": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Milestones still to be completed (null if complete or failed)"
          },
          "isComplete": {
            "type": "boolean",
            "description": "Whether all required milestones are complete"
          },
          "consumed": {
            "type": "boolean",
            "description": "Whether item was consumed (only true when all steps complete per itemUseBehavior)"
          },
          "failureReason": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable reason for failure when success is false"
          }
        }
      },
      "ValidateAbmlRequest": {
        "description": "Request to validate ABML YAML content against schema and semantic rules",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "abmlContent"
        ],
        "properties": {
          "abmlContent": {
            "type": "string",
            "description": "Raw ABML YAML content to validate"
          },
          "strictMode": {
            "type": "boolean",
            "default": false,
            "description": "Enable strict validation mode with enhanced checking"
          }
        }
      },
      "ValidateAbmlResponse": {
        "description": "Response containing the results of ABML validation including errors and warnings",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "isValid"
        ],
        "properties": {
          "isValid": {
            "type": "boolean",
            "description": "Whether the ABML definition is valid"
          },
          "validationErrors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "nullable": true,
            "description": "List of validation errors if invalid"
          },
          "semanticWarnings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Semantic warnings that don't prevent compilation"
          },
          "schemaVersion": {
            "type": "string",
            "nullable": true,
            "description": "ABML schema version used for validation"
          }
        }
      },
      "ValidateDepositRequest": {
        "type": "object",
        "description": "Request to validate a deposit without executing",
        "required": [
          "escrowId",
          "partyId",
          "partyType",
          "assets"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "partyId": {
            "type": "string",
            "format": "uuid",
            "description": "Party to validate"
          },
          "partyType": {
            "description": "Type of entity (Account, Character, etc.)",
            "$ref": "#/components/schemas/EntityType"
          },
          "assets": {
            "$ref": "#/components/schemas/EscrowAssetBundleInput",
            "description": "Assets to validate"
          }
        }
      },
      "ValidateDepositResponse": {
        "type": "object",
        "description": "Response from deposit validation",
        "required": [
          "valid",
          "errors",
          "warnings"
        ],
        "properties": {
          "valid": {
            "type": "boolean",
            "description": "Whether the deposit would be valid"
          },
          "errors": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Validation errors"
          },
          "warnings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Validation warnings"
          }
        }
      },
      "ValidateGoapPlanRequest": {
        "description": "Request to validate an existing GOAP plan against current world state",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "plan",
          "currentActionIndex",
          "worldState"
        ],
        "properties": {
          "plan": {
            "$ref": "#/components/schemas/GoapPlanResult",
            "description": "The plan to validate"
          },
          "currentActionIndex": {
            "type": "integer",
            "description": "Index of the action currently being executed"
          },
          "worldState": {
            "type": "object",
            "additionalProperties": true,
            "description": "Current world state"
          },
          "activeGoals": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GoapGoal"
            },
            "nullable": true,
            "description": "All active goals for priority checking"
          }
        }
      },
      "ValidateGoapPlanResponse": {
        "description": "Response indicating whether a GOAP plan is still valid and suggested next action",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "isValid",
          "reason",
          "suggestedAction"
        ],
        "properties": {
          "isValid": {
            "type": "boolean",
            "description": "Whether the plan is still valid"
          },
          "reason": {
            "type": "string",
            "enum": [
              "none",
              "preconditionInvalidated",
              "actionFailed",
              "betterGoalAvailable",
              "planCompleted",
              "goalAlreadySatisfied",
              "suboptimalPlan"
            ],
            "description": "Reason for the validation result"
          },
          "suggestedAction": {
            "type": "string",
            "enum": [
              "continue",
              "replan",
              "abort"
            ],
            "description": "Suggested action based on validation"
          },
          "invalidatedAtIndex": {
            "type": "integer",
            "description": "Index where plan became invalid (if applicable)"
          },
          "message": {
            "type": "string",
            "nullable": true,
            "description": "Additional details about the validation result. Null when no additional context is needed."
          }
        }
      },
      "ValidateMidiJsonRequest": {
        "description": "Request to validate MIDI-JSON structure",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "midiJson"
        ],
        "properties": {
          "midiJson": {
            "$ref": "#/components/schemas/MidiJson",
            "description": "MIDI-JSON structure to validate"
          },
          "strictMode": {
            "type": "boolean",
            "default": false,
            "description": "Enable strict validation with additional checks"
          }
        }
      },
      "ValidateMidiJsonResponse": {
        "description": "Response containing validation results",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "isValid"
        ],
        "properties": {
          "isValid": {
            "type": "boolean",
            "description": "Whether the MIDI-JSON is valid"
          },
          "errors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "nullable": true,
            "description": "Validation errors if invalid"
          },
          "warnings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Non-fatal warnings"
          }
        }
      },
      "ValidateSceneRequest": {
        "type": "object",
        "description": "Request to validate a scene structure",
        "required": [
          "scene"
        ],
        "properties": {
          "scene": {
            "$ref": "#/components/schemas/Scene",
            "description": "The scene to validate"
          },
          "applyGameRules": {
            "type": "boolean",
            "default": true,
            "description": "Whether to apply registered game-specific validation rules"
          }
        }
      },
      "ValidateTerritoryRequest": {
        "type": "object",
        "description": "Request to validate a location against territory boundaries",
        "additionalProperties": false,
        "required": [
          "locationId",
          "territoryLocationIds"
        ],
        "properties": {
          "locationId": {
            "type": "string",
            "format": "uuid",
            "description": "The location to validate"
          },
          "territoryLocationIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Territory boundary location IDs"
          },
          "territoryMode": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TerritoryMode"
              }
            ],
            "nullable": true,
            "description": "Validation mode (exclusive or inclusive). Defaults to exclusive."
          }
        }
      },
      "ValidateTerritoryResponse": {
        "type": "object",
        "description": "Territory validation result",
        "additionalProperties": false,
        "required": [
          "isValid"
        ],
        "properties": {
          "isValid": {
            "type": "boolean",
            "description": "True if location passes territory validation"
          },
          "violationReason": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable reason if validation failed"
          },
          "matchedTerritoryId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "The territory location that matched (for inclusive) or conflicted (for exclusive)"
          }
        }
      },
      "ValidateTokenResponse": {
        "description": "Response from token validation containing validity status and associated account details",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "valid",
          "accountId",
          "sessionKey"
        ],
        "properties": {
          "valid": {
            "type": "boolean",
            "description": "Whether the token is valid and not expired"
          },
          "accountId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the account associated with the token"
          },
          "sessionKey": {
            "type": "string",
            "format": "uuid",
            "description": "Internal session key used by Connect service for WebSocket connection tracking and service routing"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "List of roles assigned to the authenticated user"
          },
          "authorizations": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "description": "Authorization strings from active subscriptions.\nFormat: \"{stubName}:{state}\" (e.g., \"my-game:authorized\")\n"
          },
          "remainingTime": {
            "type": "integer",
            "description": "Seconds until expiration"
          }
        }
      },
      "ValidationCondition": {
        "type": "object",
        "description": "A single condition to check against an API response",
        "additionalProperties": false,
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ValidationConditionType"
              }
            ],
            "description": "The type of validation condition to check"
          },
          "jsonPath": {
            "type": "string",
            "nullable": true,
            "description": "JsonPath expression to extract value from response.\nRequired for jsonPathEquals, jsonPathExists, jsonPathNotExists.\nExample: \"$.balance\", \"$.items[0].status\"\n"
          },
          "expectedValue": {
            "type": "string",
            "nullable": true,
            "description": "Expected value for comparison conditions.\nType coercion applied: \"true\"/\"false\" for booleans, numeric strings for numbers.\n"
          },
          "operator": {
            "$ref": "#/components/schemas/ComparisonOperator",
            "nullable": true,
            "description": "Comparison operator for numeric comparisons"
          },
          "statusCodes": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "HTTP status codes for statusCodeIn condition"
          }
        }
      },
      "ValidationConditionType": {
        "type": "string",
        "description": "Type of validation condition",
        "enum": [
          "statusCodeIn",
          "jsonPathEquals",
          "jsonPathNotEquals",
          "jsonPathExists",
          "jsonPathNotExists",
          "jsonPathGreaterThan",
          "jsonPathLessThan",
          "jsonPathContains"
        ]
      },
      "ValidationError": {
        "description": "Detailed validation error with type, location, and message information",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "type",
          "message"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "syntax",
              "semantic",
              "schema",
              "context",
              "service_dependency"
            ],
            "description": "Type of validation error"
          },
          "message": {
            "type": "string",
            "description": "Human-readable error message"
          },
          "lineNumber": {
            "type": "integer",
            "description": "Line number where the error occurred (if applicable)"
          },
          "columnNumber": {
            "type": "integer",
            "description": "Column number where the error occurred (if applicable)"
          },
          "yamlPath": {
            "type": "string",
            "nullable": true,
            "description": "YAML path to the problematic element",
            "example": "behaviors.morning_startup.actions[0]"
          }
        }
      },
      "ValidationFailure": {
        "type": "object",
        "description": "Records a validation check failure",
        "required": [
          "detectedAt",
          "assetType",
          "assetDescription",
          "failureType",
          "affectedPartyId",
          "affectedPartyType"
        ],
        "properties": {
          "detectedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the failure was detected"
          },
          "assetType": {
            "$ref": "#/components/schemas/AssetType",
            "description": "Type of asset affected"
          },
          "assetDescription": {
            "type": "string",
            "description": "Description of the affected asset"
          },
          "failureType": {
            "$ref": "#/components/schemas/ValidationFailureType",
            "description": "Type of validation failure"
          },
          "affectedPartyId": {
            "type": "string",
            "format": "uuid",
            "description": "Which party deposit is affected"
          },
          "affectedPartyType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Type of the affected party"
          },
          "details": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Additional failure details"
          }
        }
      },
      "ValidationFailureType": {
        "type": "string",
        "description": "Type of validation failure detected.\n- asset_missing: Asset no longer exists in escrow custody\n- asset_mutated: Asset properties changed (e.g., item durability)\n- asset_expired: Asset has a time-based expiration that triggered\n- balance_mismatch: Wallet balance does not match expected held amount\n",
        "enum": [
          "asset_missing",
          "asset_mutated",
          "asset_expired",
          "balance_mismatch"
        ]
      },
      "ValidationResult": {
        "type": "object",
        "description": "Result of scene validation",
        "required": [
          "valid"
        ],
        "properties": {
          "valid": {
            "type": "boolean",
            "description": "Whether the scene passed all validation checks"
          },
          "errors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "nullable": true,
            "description": "Validation errors (severity = error)"
          },
          "warnings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "nullable": true,
            "description": "Validation warnings (severity = warning)"
          }
        }
      },
      "ValidationRule": {
        "type": "object",
        "description": "A validation rule definition",
        "required": [
          "ruleId",
          "description",
          "severity",
          "ruleType"
        ],
        "properties": {
          "ruleId": {
            "type": "string",
            "description": "Unique rule identifier within the gameId+sceneType"
          },
          "description": {
            "type": "string",
            "description": "Human-readable description of the rule"
          },
          "severity": {
            "$ref": "#/components/schemas/ValidationSeverity",
            "description": "Whether violation is an error or warning"
          },
          "ruleType": {
            "$ref": "#/components/schemas/ValidationRuleType",
            "description": "Type of validation check"
          },
          "config": {
            "$ref": "#/components/schemas/ValidationRuleConfig",
            "nullable": true,
            "description": "Rule-specific configuration"
          }
        }
      },
      "ValidationRuleConfig": {
        "type": "object",
        "description": "Configuration for a validation rule",
        "properties": {
          "nodeType": {
            "type": "string",
            "nullable": true,
            "description": "Filter to nodes of this type (for require_tag)"
          },
          "tag": {
            "type": "string",
            "nullable": true,
            "description": "Tag to check for"
          },
          "minCount": {
            "type": "integer",
            "nullable": true,
            "description": "Minimum occurrences required"
          },
          "maxCount": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum occurrences allowed"
          },
          "annotationPath": {
            "type": "string",
            "nullable": true,
            "description": "JSONPath to required annotation field (for require_annotation)"
          },
          "expression": {
            "type": "string",
            "nullable": true,
            "description": "Custom validation expression (for custom_expression)"
          }
        }
      },
      "ValidationRuleType": {
        "type": "string",
        "description": "Type of validation check to perform",
        "enum": [
          "require_tag",
          "require_node_type",
          "forbid_tag",
          "require_annotation",
          "custom_expression"
        ]
      },
      "ValidationSeverity": {
        "type": "string",
        "description": "Severity level of a validation issue",
        "enum": [
          "error",
          "warning"
        ]
      },
      "ValidatorConfig": {
        "type": "object",
        "additionalProperties": false,
        "description": "Validation rules applied to messages in rooms of this type",
        "properties": {
          "maxMessageLength": {
            "type": "integer",
            "nullable": true,
            "description": "Maximum message length in characters for text and custom formats"
          },
          "allowedPattern": {
            "type": "string",
            "nullable": true,
            "description": "Regex pattern for content validation"
          },
          "allowedValues": {
            "type": "array",
            "nullable": true,
            "description": "Whitelist of allowed values (emoji codes, etc.)",
            "items": {
              "type": "string",
              "description": "An allowed value"
            }
          },
          "requiredFields": {
            "type": "array",
            "nullable": true,
            "description": "Required JSON fields for Custom format messages",
            "items": {
              "type": "string",
              "description": "A required field name"
            }
          },
          "jsonSchema": {
            "type": "string",
            "nullable": true,
            "description": "Full JSON Schema string for complex Custom format validation"
          }
        }
      },
      "Vec3": {
        "type": "object",
        "description": "Three-dimensional spatial coordinates in garden space",
        "required": [
          "x",
          "y",
          "z"
        ],
        "properties": {
          "x": {
            "type": "number",
            "format": "float",
            "description": "X coordinate in garden space units"
          },
          "y": {
            "type": "number",
            "format": "float",
            "description": "Y coordinate in garden space units"
          },
          "z": {
            "type": "number",
            "format": "float",
            "description": "Z coordinate in garden space units"
          }
        }
      },
      "Vector3": {
        "type": "object",
        "description": "A point or direction in 3D space",
        "required": [
          "x",
          "y",
          "z"
        ],
        "properties": {
          "x": {
            "type": "number",
            "format": "double",
            "description": "X coordinate"
          },
          "y": {
            "type": "number",
            "format": "double",
            "description": "Y coordinate"
          },
          "z": {
            "type": "number",
            "format": "double",
            "description": "Z coordinate"
          }
        }
      },
      "VerifyConditionRequest": {
        "type": "object",
        "description": "Request to verify a condition for conditional escrow",
        "required": [
          "escrowId",
          "conditionMet",
          "verifierId",
          "verifierType",
          "idempotencyKey"
        ],
        "properties": {
          "escrowId": {
            "type": "string",
            "format": "uuid",
            "description": "Escrow ID"
          },
          "conditionMet": {
            "type": "boolean",
            "description": "Whether the condition was met"
          },
          "verifierId": {
            "type": "string",
            "format": "uuid",
            "description": "Verifier entity ID"
          },
          "verifierType": {
            "$ref": "#/components/schemas/EntityType",
            "description": "Verifier entity type"
          },
          "verificationData": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Proof/evidence data"
          },
          "idempotencyKey": {
            "type": "string",
            "description": "Idempotency key"
          }
        }
      },
      "VerifyConditionResponse": {
        "type": "object",
        "description": "Response from verifying a condition on an escrow",
        "required": [
          "escrow",
          "triggered"
        ],
        "properties": {
          "escrow": {
            "$ref": "#/components/schemas/EscrowAgreement",
            "description": "Updated escrow agreement"
          },
          "triggered": {
            "type": "boolean",
            "description": "Whether this triggered release/refund"
          }
        }
      },
      "VerifyIntegrityRequest": {
        "type": "object",
        "description": "Request to verify data integrity of a save version via hash comparison",
        "required": [
          "gameId",
          "ownerId",
          "ownerType",
          "slotName"
        ],
        "properties": {
          "gameId": {
            "type": "string",
            "description": "Game identifier for namespace isolation"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the owning entity"
          },
          "ownerType": {
            "$ref": "#/components/schemas/OwnerType",
            "description": "Type of entity that owns this save slot"
          },
          "slotName": {
            "type": "string",
            "description": "Name of the slot to verify"
          },
          "versionNumber": {
            "type": "integer",
            "nullable": true,
            "description": "Version to verify (latest if null)"
          }
        }
      },
      "VerifyIntegrityResponse": {
        "type": "object",
        "description": "Result of integrity verification with hash comparison details",
        "required": [
          "valid",
          "versionNumber"
        ],
        "properties": {
          "valid": {
            "type": "boolean",
            "description": "Whether integrity check passed"
          },
          "versionNumber": {
            "type": "integer",
            "description": "Version that was verified"
          },
          "expectedHash": {
            "type": "string",
            "description": "Expected SHA-256 hash"
          },
          "actualHash": {
            "type": "string",
            "nullable": true,
            "description": "Actual hash (null if data unavailable)"
          },
          "errorMessage": {
            "type": "string",
            "nullable": true,
            "description": "Error details if verification failed"
          }
        }
      },
      "VersionInfo": {
        "type": "object",
        "description": "Information about a specific version",
        "required": [
          "version",
          "createdAt"
        ],
        "properties": {
          "version": {
            "type": "string",
            "description": "Version string"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this version was created"
          },
          "createdBy": {
            "type": "string",
            "nullable": true,
            "description": "Who created this version"
          },
          "changesSummary": {
            "type": "string",
            "nullable": true,
            "description": "Summary of changes"
          },
          "nodeCount": {
            "type": "integer",
            "description": "Node count at this version"
          }
        }
      },
      "VersionResponse": {
        "type": "object",
        "description": "Metadata for a single save version including size and checkpoint info",
        "required": [
          "versionNumber",
          "contentHash",
          "sizeBytes",
          "createdAt"
        ],
        "properties": {
          "versionNumber": {
            "type": "integer",
            "description": "Version number"
          },
          "assetId": {
            "type": "string",
            "format": "uuid",
            "description": "Reference to asset in lib-asset"
          },
          "contentHash": {
            "type": "string",
            "description": "SHA-256 hash"
          },
          "sizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Size in bytes"
          },
          "compressedSizeBytes": {
            "type": "integer",
            "format": "int64",
            "description": "Compressed size if applicable"
          },
          "schemaVersion": {
            "type": "string",
            "nullable": true,
            "description": "Schema version"
          },
          "displayName": {
            "type": "string",
            "nullable": true,
            "description": "Human-readable name"
          },
          "pinned": {
            "type": "boolean",
            "description": "Whether version is pinned"
          },
          "checkpointName": {
            "type": "string",
            "nullable": true,
            "description": "Checkpoint name if pinned"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom metadata"
          }
        }
      },
      "ViolationRecord": {
        "type": "object",
        "description": "Record of a knowing obligation violation by a character",
        "additionalProperties": false,
        "required": [
          "violationId",
          "characterId",
          "contractId",
          "clauseCode",
          "violationType",
          "actionTag",
          "motivationScore",
          "violationCost",
          "breachReported",
          "timestamp"
        ],
        "properties": {
          "violationId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this violation record"
          },
          "characterId": {
            "type": "string",
            "format": "uuid",
            "description": "Character who committed the violation"
          },
          "contractId": {
            "type": "string",
            "format": "uuid",
            "description": "Contract that was violated"
          },
          "clauseCode": {
            "type": "string",
            "minLength": 1,
            "maxLength": 128,
            "description": "Code of the behavioral clause that was violated"
          },
          "violationType": {
            "type": "string",
            "minLength": 1,
            "maxLength": 128,
            "description": "Violation type code"
          },
          "actionTag": {
            "type": "string",
            "minLength": 1,
            "maxLength": 128,
            "description": "GOAP action tag that triggered the violation"
          },
          "motivationScore": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "Goal urgency that overrode the obligation (0.0-1.0)"
          },
          "violationCost": {
            "type": "number",
            "format": "float",
            "minimum": 0.0,
            "description": "Total violation cost that was accepted"
          },
          "breachReported": {
            "type": "boolean",
            "description": "Whether a breach was filed with the contract service"
          },
          "breachId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Breach record ID from contract service (null if breach not reported)"
          },
          "targetEntityId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Target entity of the violating action (null if no specific target)"
          },
          "targetEntityType": {
            "$ref": "#/components/schemas/EntityType",
            "nullable": true,
            "description": "Entity type of the target"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When the violation occurred"
          }
        }
      },
      "VoiceLeadRequest": {
        "description": "Request to apply voice leading to a chord sequence",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "chords",
          "voiceCount"
        ],
        "properties": {
          "chords": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChordSymbol"
            },
            "description": "Chord symbols to voice"
          },
          "voiceCount": {
            "type": "integer",
            "minimum": 2,
            "maximum": 8,
            "description": "Number of voices"
          },
          "ranges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PitchRange"
            },
            "nullable": true,
            "description": "Pitch range per voice (defaults based on voice count)"
          },
          "rules": {
            "$ref": "#/components/schemas/VoiceLeadingRules",
            "nullable": true,
            "description": "Voice leading rules to apply"
          }
        }
      },
      "VoiceLeadResponse": {
        "description": "Response containing voiced chords",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "voicings"
        ],
        "properties": {
          "voicings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VoicedChord"
            },
            "description": "Voiced chord realizations"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VoiceLeadingViolation"
            },
            "nullable": true,
            "description": "Voice leading rule violations (warnings)"
          }
        }
      },
      "VoiceLeadingRules": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Harmony.VoiceLeadingRules",
        "description": "Rules for voice leading",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "avoidParallelFifths": {
            "type": "boolean",
            "default": true,
            "description": "Avoid parallel perfect fifths"
          },
          "avoidParallelOctaves": {
            "type": "boolean",
            "default": true,
            "description": "Avoid parallel octaves"
          },
          "preferStepwiseMotion": {
            "type": "boolean",
            "default": true,
            "description": "Prefer stepwise voice motion"
          },
          "avoidVoiceCrossing": {
            "type": "boolean",
            "default": true,
            "description": "Avoid voice crossing"
          },
          "maxLeap": {
            "type": "integer",
            "minimum": 1,
            "maximum": 12,
            "default": 7,
            "description": "Maximum leap in semitones"
          }
        }
      },
      "VoiceLeadingViolation": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Harmony.VoiceLeadingViolation",
        "description": "A voice leading rule violation",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "type",
          "position",
          "voices",
          "isError",
          "message"
        ],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/VoiceLeadingViolationType",
            "description": "Type of violation"
          },
          "position": {
            "type": "integer",
            "description": "Position in the progression (0-based)"
          },
          "voices": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "Voice indices involved (0 = bass)"
          },
          "isError": {
            "type": "boolean",
            "description": "Severity (true = error, false = warning)"
          },
          "message": {
            "type": "string",
            "description": "Human-readable description"
          }
        }
      },
      "VoiceLeadingViolationType": {
        "x-sdk-type": "BeyondImmersion.Bannou.MusicTheory.Harmony.VoiceLeadingViolationType",
        "description": "Type of voice leading rule violation",
        "type": "string",
        "enum": [
          "ParallelFifths",
          "ParallelOctaves",
          "VoiceCrossing",
          "VoiceOverlap",
          "LargeLeap",
          "UnresolvedLeap",
          "DoubledLeadingTone"
        ]
      },
      "VoicedChord": {
        "description": "A chord with specific voice pitches",
        "type": "object",
        "additionalProperties": false,
        "required": [
          "symbol",
          "pitches"
        ],
        "properties": {
          "symbol": {
            "$ref": "#/components/schemas/ChordSymbol",
            "description": "Original chord symbol"
          },
          "pitches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Pitch"
            },
            "description": "Pitches from lowest to highest voice"
          }
        }
      },
      "VolumeShape": {
        "type": "string",
        "description": "Shape of a volume node for spatial bounds",
        "enum": [
          "box",
          "sphere",
          "capsule",
          "cylinder"
        ]
      },
      "WalletOwnerType": {
        "type": "string",
        "description": "Type of entity that owns a wallet",
        "enum": [
          "account",
          "character",
          "npc",
          "guild",
          "faction",
          "location",
          "system"
        ]
      },
      "WalletResponse": {
        "type": "object",
        "description": "Wallet details",
        "additionalProperties": false,
        "required": [
          "walletId",
          "ownerId",
          "ownerType",
          "status",
          "createdAt"
        ],
        "properties": {
          "walletId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique wallet identifier"
          },
          "ownerId": {
            "type": "string",
            "format": "uuid",
            "description": "Owner entity ID"
          },
          "ownerType": {
            "$ref": "#/components/schemas/WalletOwnerType",
            "description": "Owner type"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "description": "Realm ID"
          },
          "status": {
            "$ref": "#/components/schemas/WalletStatus",
            "description": "Current wallet status"
          },
          "frozenReason": {
            "type": "string",
            "nullable": true,
            "description": "Reason wallet was frozen"
          },
          "frozenAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "When wallet was frozen"
          },
          "frozenBy": {
            "type": "string",
            "nullable": true,
            "description": "Who froze the wallet"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation timestamp"
          },
          "lastActivityAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "description": "Last transaction timestamp"
          }
        }
      },
      "WalletStatus": {
        "type": "string",
        "description": "Current status of a wallet",
        "enum": [
          "active",
          "frozen",
          "closed"
        ]
      },
      "WalletWithBalancesResponse": {
        "type": "object",
        "description": "Wallet with all non-zero balances",
        "additionalProperties": false,
        "required": [
          "wallet",
          "balances"
        ],
        "properties": {
          "wallet": {
            "$ref": "#/components/schemas/WalletResponse",
            "description": "Wallet details"
          },
          "balances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BalanceSummary"
            },
            "description": "All non-zero balances in this wallet"
          }
        }
      },
      "WatcherInfo": {
        "type": "object",
        "additionalProperties": false,
        "description": "Information about an active regional watcher",
        "required": [
          "watcherId",
          "realmId",
          "watcherType",
          "startedAt"
        ],
        "properties": {
          "watcherId": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this watcher instance"
          },
          "realmId": {
            "type": "string",
            "format": "uuid",
            "description": "Realm this watcher monitors"
          },
          "watcherType": {
            "type": "string",
            "description": "Type of watcher (e.g., \"regional\", \"dungeon\", \"event\")"
          },
          "startedAt": {
            "type": "string",
            "format": "date-time",
            "description": "When this watcher was started"
          },
          "behaviorRef": {
            "type": "string",
            "nullable": true,
            "description": "Behavior document reference this watcher uses"
          },
          "actorId": {
            "type": "string",
            "nullable": true,
            "description": "Actor instance ID running this watcher's behavior"
          }
        }
      },
      "WeightContribution": {
        "type": "string",
        "description": "How container weight propagates to parent",
        "enum": [
          "none",
          "self_only",
          "self_plus_contents"
        ]
      },
      "WeightPrecision": {
        "type": "string",
        "description": "Precision for weight values (consistent with CurrencyPrecision)",
        "enum": [
          "integer",
          "decimal_1",
          "decimal_2",
          "decimal_3"
        ]
      }
    },
    "securitySchemes": {
      "BearerAuth": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "JWT",
        "description": "JWT access token obtained from /auth/login or OAuth flow"
      }
    }
  },
  "tags": [
    {
      "name": "ABML Behavior Management",
      "description": "Arcadia Behavior Markup Language (ABML) API for character behavior management."
    },
    {
      "name": "Actor",
      "description": "Distributed actor management and execution for NPC brains, event coordinators,"
    },
    {
      "name": "Asset",
      "description": "Asset management service for storage, versioning, and distribution of large binary assets."
    },
    {
      "name": "Bannou Account",
      "description": "Internal account management service (CRUD operations only, never exposed to internet)."
    },
    {
      "name": "Bannou Achievement",
      "description": "Achievement and trophy system with progress tracking and platform synchronization."
    },
    {
      "name": "Bannou Auth",
      "description": "Authentication and session management service (Internet-facing)."
    },
    {
      "name": "Bannou Character",
      "description": "Character management service for game worlds."
    },
    {
      "name": "Bannou Character Encounter",
      "description": "Character encounter tracking service for memorable interactions between characters."
    },
    {
      "name": "Bannou Character History",
      "description": "Historical event participation and backstory management for characters."
    },
    {
      "name": "Bannou Character Personality",
      "description": "Machine-readable personality traits for NPC behavior decisions."
    },
    {
      "name": "Bannou Connect",
      "description": "Real-time communication and WebSocket connection management for Bannou services."
    },
    {
      "name": "Bannou Divine",
      "description": "Pantheon management service (L4 GameFeatures) for deity entities, divinity economy,"
    },
    {
      "name": "Bannou Documentation",
      "description": "Knowledge base API for AI agents to query documentation."
    },
    {
      "name": "Bannou Faction",
      "description": "Faction management as seed-based living entities (L4 GameFeatures)."
    },
    {
      "name": "Bannou Game",
      "description": "Registry service for game services that users can subscribe to."
    },
    {
      "name": "Bannou Game Session",
      "description": "Minimal game session management for games."
    },
    {
      "name": "Bannou Gardener",
      "description": "Player experience orchestration service (L4 GameFeatures) for garden navigation,"
    },
    {
      "name": "Bannou Leaderboard",
      "description": "Real-time leaderboard management using Redis Sorted Sets for efficient ranking."
    },
    {
      "name": "Bannou Location",
      "description": "Location management service for game worlds."
    },
    {
      "name": "Bannou Mapping",
      "description": "Spatial data management service for game worlds."
    },
    {
      "name": "Bannou Matchmaking",
      "description": "Matchmaking service for competitive and casual game matching."
    },
    {
      "name": "Bannou Obligation",
      "description": "Contract-aware obligation tracking for NPC cognition (L4 GameFeatures)."
    },
    {
      "name": "Bannou Puppetmaster",
      "description": "Orchestration service for dynamic behaviors, regional watchers, and encounter coordination."
    },
    {
      "name": "Bannou Quest",
      "description": "Quest system providing objective-based gameplay progression as a thin orchestration"
    },
    {
      "name": "Bannou Realm",
      "description": "Realm management service for game worlds."
    },
    {
      "name": "Bannou Realm History",
      "description": "Historical event participation and lore management for realms."
    },
    {
      "name": "Bannou Scene",
      "description": "Hierarchical composition storage for game worlds."
    },
    {
      "name": "Bannou Species",
      "description": "Species management service for game worlds."
    },
    {
      "name": "Bannou Subscription",
      "description": "Manages user subscriptions to game services."
    },
    {
      "name": "Bannou Voice",
      "description": "Voice room coordination service. Internal service accessed by other services via lib-mesh."
    },
    {
      "name": "Bannou Website",
      "description": "Public-facing website service for registration, information, and account management."
    },
    {
      "name": "Chat",
      "description": "Typed message channel service (L1 AppFoundation) providing universal communication primitives. Channel type determines valid message formats: text, sentiment, emoji, or custom-validated payloads. Supports contract- governed room lifecycles, Connect companion rooms, and moderation primitives. Internal-only, never internet-facing."
    },
    {
      "name": "Collection",
      "description": "Universal content unlock and archive system for collectible content."
    },
    {
      "name": "Contract",
      "description": "Binding agreements between entities with milestone-based progression."
    },
    {
      "name": "Currency",
      "description": "Multi-currency management service for game economies."
    },
    {
      "name": "Escrow",
      "description": "Full-custody orchestration layer for multi-party asset exchanges."
    },
    {
      "name": "Inventory",
      "description": "Container and inventory management service for games."
    },
    {
      "name": "Item",
      "description": "Item template and instance management service."
    },
    {
      "name": "License",
      "description": "Grid-based progression boards via itemized contracts."
    },
    {
      "name": "Music Theory Engine",
      "description": "Pure computation music generation using formal music theory rules."
    },
    {
      "name": "Relationship",
      "description": "Relationship and relationship type management service for entity-to-entity"
    },
    {
      "name": "Resource Lifecycle",
      "description": "Resource reference tracking and lifecycle management."
    },
    {
      "name": "Save-Load",
      "description": "Generic save/load system for game state persistence."
    },
    {
      "name": "Seed",
      "description": "Generic progressive growth entity service (L2 GameFoundation). Seeds are entities that start empty and grow by accumulating metadata from external events, progressively gaining capabilities. Polymorphic ownership allows seeds to be bound to any entity type (accounts, actors, realms, characters, relationships). Growth domains are arbitrary key-value maps contributed by any consuming service via events, following the same pattern as Resource reference tracking. Capability manifests are computed from growth domains using configurable rules per seed type. The Seed service is agnostic to what seeds represent -- consumers (lib-gardener for player spirits, lib-actor for dungeon cores, etc.) provide the interpretation."
    },
    {
      "name": "Status",
      "description": "Unified entity effects query layer for temporary contract-managed statuses"
    },
    {
      "name": "Storyline Composer",
      "description": "Seeded narrative generation from compressed archives using the storyline SDKs."
    }
  ]
}
