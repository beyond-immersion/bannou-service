name: 'SDK Stable Release'

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (do not publish, just show what would happen)'
        required: false
        default: 'false'
        type: boolean

env:
  DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}

jobs:
  release:
    name: Create Stable SDK Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for tag detection

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Get Base Version and Last Release Tag
        id: base
        run: |
          # SDK_VERSION represents the last stable release (base for calculating next version)
          SDK_VERSION=$(cat sdks/SDK_VERSION | tr -d '[:space:]')
          echo "sdk_version=${SDK_VERSION}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ SDK_VERSION (last stable): ${SDK_VERSION}"

          # Parse version components for bump calculations
          IFS='.' read -r MAJOR MINOR PATCH <<< "$SDK_VERSION"
          echo "major=${MAJOR}" >> $GITHUB_OUTPUT
          echo "minor=${MINOR}" >> $GITHUB_OUTPUT
          echo "patch=${PATCH}" >> $GITHUB_OUTPUT

          # Find the last sdk release tag for changelog generation
          LAST_TAG=$(git tag -l 'sdk-v*' --sort=-v:refname | head -n 1)
          if [ -z "$LAST_TAG" ]; then
            echo "last_tag=" >> $GITHUB_OUTPUT
            echo "ðŸ“Œ No previous SDK release tag found - this will be the first stable release"
            LAST_REF=$(git rev-list --max-parents=0 HEAD | head -n 1)
          else
            echo "last_tag=${LAST_TAG}" >> $GITHUB_OUTPUT
            echo "ðŸ“Œ Last SDK release tag: ${LAST_TAG}"
            LAST_REF=$LAST_TAG
          fi
          echo "last_ref=${LAST_REF}" >> $GITHUB_OUTPUT

      - name: Analyze PR Labels Since Last Release
        id: analyze
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          LAST_REF="${{ steps.base.outputs.last_ref }}"
          echo "ðŸ” Analyzing PRs merged since ${LAST_REF}..."

          HAS_MAJOR=false
          HAS_MINOR=false
          HAS_PATCH=false
          PR_COUNT=0

          for COMMIT in $(git log ${LAST_REF}..HEAD --pretty=format:"%H" 2>/dev/null || echo ""); do
            PR_INFO=$(gh api repos/${{ github.repository }}/commits/${COMMIT}/pulls 2>/dev/null || echo "[]")
            PR_NUMBERS=$(echo "$PR_INFO" | jq -r '.[].number' 2>/dev/null || echo "")

            for PR_NUM in $PR_NUMBERS; do
              if [ -n "$PR_NUM" ] && [ "$PR_NUM" != "null" ]; then
                PR_COUNT=$((PR_COUNT + 1))

                # Get labels for this PR
                LABELS=$(gh pr view $PR_NUM --json labels --jq '.labels[].name' 2>/dev/null || echo "")

                if echo "$LABELS" | grep -q "sdk:major"; then
                  HAS_MAJOR=true
                  echo "  PR #${PR_NUM}: sdk:major (breaking changes)"
                elif echo "$LABELS" | grep -q "sdk:minor"; then
                  HAS_MINOR=true
                  echo "  PR #${PR_NUM}: sdk:minor (new features)"
                elif echo "$LABELS" | grep -q "sdk:patch"; then
                  HAS_PATCH=true
                  echo "  PR #${PR_NUM}: sdk:patch (bug fixes)"
                fi
              fi
            done
          done

          # Determine version bump type - biggest wins (semantic versioning)
          if [ "$HAS_MAJOR" = true ]; then
            BUMP_TYPE="major"
          elif [ "$HAS_MINOR" = true ]; then
            BUMP_TYPE="minor"
          else
            BUMP_TYPE="patch"
          fi

          echo ""
          echo "ðŸ“Š PRs included: ${PR_COUNT}"
          echo "ðŸŽ¯ Version bump type: ${BUMP_TYPE}"

          echo "pr_count=${PR_COUNT}" >> $GITHUB_OUTPUT
          echo "bump_type=${BUMP_TYPE}" >> $GITHUB_OUTPUT

      - name: Calculate Release Version
        id: release
        run: |
          MAJOR="${{ steps.base.outputs.major }}"
          MINOR="${{ steps.base.outputs.minor }}"
          PATCH="${{ steps.base.outputs.patch }}"
          BUMP_TYPE="${{ steps.analyze.outputs.bump_type }}"

          # Calculate release version based on bump type (semantic versioning)
          case $BUMP_TYPE in
            major)
              RELEASE_VERSION="$((MAJOR + 1)).0.0"
              ;;
            minor)
              RELEASE_VERSION="${MAJOR}.$((MINOR + 1)).0"
              ;;
            patch)
              RELEASE_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
              ;;
          esac

          echo "release_version=${RELEASE_VERSION}" >> $GITHUB_OUTPUT
          echo ""
          echo "ðŸ“¦ Release calculation:"
          echo "   SDK_VERSION (base): ${{ steps.base.outputs.sdk_version }}"
          echo "   Bump type: ${BUMP_TYPE}"
          echo "   Release version: ${RELEASE_VERSION}"

      - name: Validate Release
        run: |
          VERSION="${{ steps.release.outputs.release_version }}"
          if [ -z "$VERSION" ]; then
            echo "âŒ Cannot create release: Failed to calculate version"
            exit 1
          fi
          echo "âœ… Will release SDK version ${VERSION}"

      - name: Restore NuGet Packages
        run: |
          echo "ðŸ“¦ Restoring NuGet packages..."
          dotnet restore

      # Note: Generated files are committed to git, validated by ci.generation-check.yml
      # No regeneration needed - just use committed files

      - name: Build and Pack Stable SDKs
        run: |
          VERSION="${{ steps.release.outputs.release_version }}"
          echo "ðŸ“¦ Building SDKs v${VERSION}..."

          # Define all packable SDK projects (order matters - dependencies first)
          SDK_PROJECTS=(
            # Foundation packages (no Bannou dependencies)
            "sdks/core"
            "sdks/protocol"
            # Packages with foundation dependencies
            "sdks/transport"
            "sdks/bundle-format"
            # Public SDK packages
            "sdks/server"
            "sdks/client"
            "sdks/client-voice"
            "sdks/scene-composer"
            "sdks/scene-composer-stride"
            "sdks/scene-composer-godot"
            "sdks/asset-bundler"
            "sdks/asset-bundler-stride"
            "sdks/asset-bundler-godot"
            "sdks/asset-loader"
            "sdks/asset-loader-client"
            "sdks/asset-loader-server"
            "sdks/asset-loader-stride"
            "sdks/asset-loader-godot"
          )

          for PROJECT in "${SDK_PROJECTS[@]}"; do
            PROJECT_NAME=$(basename "$PROJECT")
            echo "ðŸ“¦ Building ${PROJECT_NAME}..."
            dotnet restore "$PROJECT"
            dotnet build "$PROJECT" --configuration Release --no-restore
            dotnet pack "$PROJECT" --configuration Release -p:PackageVersion=${VERSION} --output ./nuget-packages --no-build
          done

          echo "âœ… Packages built: ./nuget-packages/"
          ls -la ./nuget-packages/

      # Create tag BEFORE publishing - this marks the release point
      # If publish fails, tag exists but can be deleted; if we tagged after publish
      # and that failed, we'd have orphaned packages on NuGet
      - name: Create Git Tag
        if: inputs.dry_run == false
        run: |
          VERSION="${{ steps.release.outputs.release_version }}"
          TAG="sdk-v${VERSION}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git tag -a "$TAG" -m "SDK Release ${VERSION}"
          git push origin "$TAG"

          echo "âœ… Created and pushed tag: ${TAG}"

      - name: Publish to NuGet (Stable)
        if: inputs.dry_run == false
        run: |
          VERSION="${{ steps.release.outputs.release_version }}"
          echo "ðŸš€ Publishing stable release v${VERSION} to NuGet.org..."

          dotnet nuget push ./nuget-packages/*.nupkg \
            --api-key ${{ secrets.NUGET_API_KEY }} \
            --source https://api.nuget.org/v3/index.json \
            --skip-duplicate

          echo "âœ… Stable packages published!"

      # Update SDK_VERSION to the released version
      # Preview workflow adds +0.0.1 before the -preview suffix, so previews will be higher
      # e.g., SDK_VERSION=1.1.0 â†’ previews are 1.1.1-preview.X (> 1.1.0 stable)
      - name: Update SDK_VERSION to Released Version
        if: inputs.dry_run == false
        run: |
          RELEASED_VERSION="${{ steps.release.outputs.release_version }}"

          echo "${RELEASED_VERSION}" > sdks/SDK_VERSION
          echo "ðŸ“¦ Updated SDK_VERSION to ${RELEASED_VERSION}"

          git add sdks/SDK_VERSION
          git commit -m "chore: update SDK_VERSION to ${RELEASED_VERSION}

          Previews will now be based on this version (with +0.0.1 patch bump).
          e.g., next preview: ${RELEASED_VERSION%.*}.$((${RELEASED_VERSION##*.} + 1))-preview.X

          ðŸ¤– Generated by SDK Release workflow"

          git push

          echo "âœ… SDK_VERSION updated"

      - name: Create GitHub Release
        if: inputs.dry_run == false
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.release.outputs.release_version }}"
          TAG="sdk-v${VERSION}"
          PR_COUNT="${{ steps.analyze.outputs.pr_count }}"

          # Create release notes
          NOTES="## Bannou SDKs v${VERSION}

          **PRs Included:** ${PR_COUNT}

          ### Installation

          #### Core SDKs

          **For Game Servers** (with mesh service-to-service calls):
          \`\`\`bash
          dotnet add package BeyondImmersion.Bannou.Server --version ${VERSION}
          \`\`\`

          **For Game Clients** (WebSocket only):
          \`\`\`bash
          dotnet add package BeyondImmersion.Bannou.Client --version ${VERSION}
          \`\`\`

          **For Voice Communication**:
          \`\`\`bash
          dotnet add package BeyondImmersion.Bannou.Client.Voice --version ${VERSION}
          \`\`\`

          #### Scene Composer SDKs

          **Engine-Agnostic Scene Editing**:
          \`\`\`bash
          dotnet add package BeyondImmersion.Bannou.SceneComposer --version ${VERSION}
          \`\`\`

          **Stride Engine Extension**:
          \`\`\`bash
          dotnet add package BeyondImmersion.Bannou.SceneComposer.Stride --version ${VERSION}
          \`\`\`

          **Godot 4.x Extension**:
          \`\`\`bash
          dotnet add package BeyondImmersion.Bannou.SceneComposer.Godot --version ${VERSION}
          \`\`\`

          #### Asset Bundler SDKs

          **Core Asset Bundling** (engine-agnostic):
          \`\`\`bash
          dotnet add package BeyondImmersion.Bannou.AssetBundler --version ${VERSION}
          \`\`\`

          **Stride Asset Bundling**:
          \`\`\`bash
          dotnet add package BeyondImmersion.Bannou.AssetBundler.Stride --version ${VERSION}
          \`\`\`

          #### Asset Loader SDKs

          **Core Asset Loading** (engine-agnostic):
          \`\`\`bash
          dotnet add package BeyondImmersion.Bannou.AssetLoader --version ${VERSION}
          \`\`\`

          **For Game Clients** (WebSocket source):
          \`\`\`bash
          dotnet add package BeyondImmersion.Bannou.AssetLoader.Client --version ${VERSION}
          \`\`\`

          **For Game Servers** (Mesh source):
          \`\`\`bash
          dotnet add package BeyondImmersion.Bannou.AssetLoader.Server --version ${VERSION}
          \`\`\`

          **Stride Engine Loaders**:
          \`\`\`bash
          dotnet add package BeyondImmersion.Bannou.AssetLoader.Stride --version ${VERSION}
          \`\`\`

          **Godot 4.x Loaders**:
          \`\`\`bash
          dotnet add package BeyondImmersion.Bannou.AssetLoader.Godot --version ${VERSION}
          \`\`\`

          ### What's Changed

          See the [compare view](https://github.com/${{ github.repository }}/compare/${{ steps.base.outputs.last_tag }}...${TAG}) for all changes since the last release.
          "

          gh release create "$TAG" \
            --title "SDK v${VERSION}" \
            --notes "$NOTES" \
            ./nuget-packages/*.nupkg

      - name: Dry Run Summary
        if: inputs.dry_run == true
        run: |
          echo "ðŸ§ª DRY RUN SUMMARY"
          echo "=================="
          echo ""
          echo "SDK_VERSION (base): ${{ steps.base.outputs.sdk_version }}"
          echo "Bump type: ${{ steps.analyze.outputs.bump_type }}"
          echo "Release version: ${{ steps.release.outputs.release_version }}"
          echo "PRs included: ${{ steps.analyze.outputs.pr_count }}"
          echo ""
          echo "Actions that would be taken:"
          echo "  1. Build and pack SDKs with version ${{ steps.release.outputs.release_version }}"
          echo "  2. Create git tag: sdk-v${{ steps.release.outputs.release_version }}"
          echo "  3. Publish to NuGet"
          echo "  4. Update SDK_VERSION to ${{ steps.release.outputs.release_version }}"
          echo "  5. Create GitHub release"
          echo ""
          echo "Version calculation: ${{ steps.base.outputs.sdk_version }} + ${{ steps.analyze.outputs.bump_type }} = ${{ steps.release.outputs.release_version }}"
          echo ""
          echo "To perform the actual release, run this workflow again with dry_run=false"

      - name: Notify Discord
        if: always() && inputs.dry_run == false
        uses: ./.github/actions/discord-notify
        with:
          webhook-url: ${{ env.DISCORD_WEBHOOK }}
          stage-name: "SDK Stable Release v${{ steps.release.outputs.release_version }}"
          status: ${{ job.status }}
          commit-message: "SDK Release v${{ steps.release.outputs.release_version }}"
          commit-author: ${{ github.actor }}
          run-url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          repository-url: ${{ github.server_url }}/${{ github.repository }}
