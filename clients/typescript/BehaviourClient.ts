//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class BehaviourClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost/api/behaviour";
    }

    /**
     * Add new behavior tree
     * @return Behavior tree added successfully
     */
    addBehaviourTree(body: AddBehaviourTreeRequest): Promise<AddBehaviourTreeResponse> {
        let url_ = this.baseUrl + "/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddBehaviourTree(_response);
        });
    }

    protected processAddBehaviourTree(response: Response): Promise<AddBehaviourTreeResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddBehaviourTreeResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BehaviourErrorResponse.fromJS(resultData400);
            return throwException("Invalid behavior definition", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = BehaviourErrorResponse.fromJS(resultData403);
            return throwException("Forbidden - insufficient permissions", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = BehaviourErrorResponse.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AddBehaviourTreeResponse>(null as any);
    }

    /**
     * Validate behavior definition
     * @return Validation result
     */
    validateBehaviour(body: ValidateBehaviourRequest): Promise<ValidateBehaviourResponse> {
        let url_ = this.baseUrl + "/validate/behavior";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateBehaviour(_response);
        });
    }

    protected processValidateBehaviour(response: Response): Promise<ValidateBehaviourResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidateBehaviourResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidateBehaviourResponse>(null as any);
    }

    /**
     * Validate prerequisite definition
     * @return Validation result
     */
    validatePrerequisite(body: ValidatePrerequisiteRequest): Promise<ValidatePrerequisiteResponse> {
        let url_ = this.baseUrl + "/validate/prerequisite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidatePrerequisite(_response);
        });
    }

    protected processValidatePrerequisite(response: Response): Promise<ValidatePrerequisiteResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidatePrerequisiteResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidatePrerequisiteResponse>(null as any);
    }

    /**
     * Resolve behavior references
     * @return References resolved successfully
     */
    resolveBehaviourReferences(body: ResolveReferencesRequest): Promise<ResolveReferencesResponse> {
        let url_ = this.baseUrl + "/resolve/references";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResolveBehaviourReferences(_response);
        });
    }

    protected processResolveBehaviourReferences(response: Response): Promise<ResolveReferencesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResolveReferencesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BehaviourErrorResponse.fromJS(resultData400);
            return throwException("Unable to resolve references", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResolveReferencesResponse>(null as any);
    }
}

export class AddBehaviourTreeRequest implements IAddBehaviourTreeRequest {
    behavior!: BehaviorDefinition;

    [key: string]: any;

    constructor(data?: IAddBehaviourTreeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.behavior = new BehaviorDefinition();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.behavior = _data["behavior"] ? BehaviorDefinition.fromJS(_data["behavior"]) : new BehaviorDefinition();
        }
    }

    static fromJS(data: any): AddBehaviourTreeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddBehaviourTreeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["behavior"] = this.behavior ? this.behavior.toJSON() : undefined as any;
        return data;
    }
}

export interface IAddBehaviourTreeRequest {
    behavior: BehaviorDefinition;

    [key: string]: any;
}

export class ValidateBehaviourRequest implements IValidateBehaviourRequest {
    behavior!: BehaviorDefinition;

    [key: string]: any;

    constructor(data?: IValidateBehaviourRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.behavior = new BehaviorDefinition();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.behavior = _data["behavior"] ? BehaviorDefinition.fromJS(_data["behavior"]) : new BehaviorDefinition();
        }
    }

    static fromJS(data: any): ValidateBehaviourRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateBehaviourRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["behavior"] = this.behavior ? this.behavior.toJSON() : undefined as any;
        return data;
    }
}

export interface IValidateBehaviourRequest {
    behavior: BehaviorDefinition;

    [key: string]: any;
}

export class ValidatePrerequisiteRequest implements IValidatePrerequisiteRequest {
    prerequisite!: Prerequisite;

    [key: string]: any;

    constructor(data?: IValidatePrerequisiteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.prerequisite = new Prerequisite();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.prerequisite = _data["prerequisite"] ? Prerequisite.fromJS(_data["prerequisite"]) : new Prerequisite();
        }
    }

    static fromJS(data: any): ValidatePrerequisiteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ValidatePrerequisiteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["prerequisite"] = this.prerequisite ? this.prerequisite.toJSON() : undefined as any;
        return data;
    }
}

export interface IValidatePrerequisiteRequest {
    prerequisite: Prerequisite;

    [key: string]: any;
}

export class ResolveReferencesRequest implements IResolveReferencesRequest {
    /** Array of behavior definitions to resolve references for */
    behaviors!: BehaviorDefinition[];

    [key: string]: any;

    constructor(data?: IResolveReferencesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.behaviors = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["behaviors"])) {
                this.behaviors = [] as any;
                for (let item of _data["behaviors"])
                    this.behaviors!.push(BehaviorDefinition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResolveReferencesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveReferencesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.behaviors)) {
            data["behaviors"] = [];
            for (let item of this.behaviors)
                data["behaviors"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IResolveReferencesRequest {
    /** Array of behavior definitions to resolve references for */
    behaviors: BehaviorDefinition[];

    [key: string]: any;
}

export class AddBehaviourTreeResponse implements IAddBehaviourTreeResponse {
    /** Indicates if the operation was successful */
    success?: boolean;
    /** Success message */
    message?: string;
    /** Unique identifier for the added behavior tree */
    behavior_id?: string;

    [key: string]: any;

    constructor(data?: IAddBehaviourTreeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.success = _data["success"];
            this.message = _data["message"];
            this.behavior_id = _data["behavior_id"];
        }
    }

    static fromJS(data: any): AddBehaviourTreeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AddBehaviourTreeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["success"] = this.success;
        data["message"] = this.message;
        data["behavior_id"] = this.behavior_id;
        return data;
    }
}

export interface IAddBehaviourTreeResponse {
    /** Indicates if the operation was successful */
    success?: boolean;
    /** Success message */
    message?: string;
    /** Unique identifier for the added behavior tree */
    behavior_id?: string;

    [key: string]: any;
}

export class ValidateBehaviourResponse implements IValidateBehaviourResponse {
    /** Whether the behavior is valid */
    is_valid!: boolean;
    /** List of validation errors if behavior is invalid */
    validation_errors?: string[];
    /** Behavior with resolved references (if applicable) */
    resolved_behavior?: BehaviorDefinition;

    [key: string]: any;

    constructor(data?: IValidateBehaviourResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.is_valid = _data["is_valid"];
            if (Array.isArray(_data["validation_errors"])) {
                this.validation_errors = [] as any;
                for (let item of _data["validation_errors"])
                    this.validation_errors!.push(item);
            }
            this.resolved_behavior = _data["resolved_behavior"] ? BehaviorDefinition.fromJS(_data["resolved_behavior"]) : undefined as any;
        }
    }

    static fromJS(data: any): ValidateBehaviourResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateBehaviourResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["is_valid"] = this.is_valid;
        if (Array.isArray(this.validation_errors)) {
            data["validation_errors"] = [];
            for (let item of this.validation_errors)
                data["validation_errors"].push(item);
        }
        data["resolved_behavior"] = this.resolved_behavior ? this.resolved_behavior.toJSON() : undefined as any;
        return data;
    }
}

export interface IValidateBehaviourResponse {
    /** Whether the behavior is valid */
    is_valid: boolean;
    /** List of validation errors if behavior is invalid */
    validation_errors?: string[];
    /** Behavior with resolved references (if applicable) */
    resolved_behavior?: BehaviorDefinition;

    [key: string]: any;
}

export class ValidatePrerequisiteResponse implements IValidatePrerequisiteResponse {
    /** Whether the prerequisite is valid */
    is_valid!: boolean;
    /** List of validation errors if prerequisite is invalid */
    validation_errors?: string[];

    [key: string]: any;

    constructor(data?: IValidatePrerequisiteResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.is_valid = _data["is_valid"];
            if (Array.isArray(_data["validation_errors"])) {
                this.validation_errors = [] as any;
                for (let item of _data["validation_errors"])
                    this.validation_errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ValidatePrerequisiteResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidatePrerequisiteResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["is_valid"] = this.is_valid;
        if (Array.isArray(this.validation_errors)) {
            data["validation_errors"] = [];
            for (let item of this.validation_errors)
                data["validation_errors"].push(item);
        }
        return data;
    }
}

export interface IValidatePrerequisiteResponse {
    /** Whether the prerequisite is valid */
    is_valid: boolean;
    /** List of validation errors if prerequisite is invalid */
    validation_errors?: string[];

    [key: string]: any;
}

export class ResolveReferencesResponse implements IResolveReferencesResponse {
    /** Whether all references were resolved successfully */
    success!: boolean;
    /** Array of behaviors with resolved references */
    resolved_behaviors!: BehaviorDefinition[];
    /** List of references that could not be resolved */
    unresolved_references?: string[];
    /** Validation errors encountered during resolution */
    validation_errors?: string[];

    [key: string]: any;

    constructor(data?: IResolveReferencesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.resolved_behaviors = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.success = _data["success"];
            if (Array.isArray(_data["resolved_behaviors"])) {
                this.resolved_behaviors = [] as any;
                for (let item of _data["resolved_behaviors"])
                    this.resolved_behaviors!.push(BehaviorDefinition.fromJS(item));
            }
            if (Array.isArray(_data["unresolved_references"])) {
                this.unresolved_references = [] as any;
                for (let item of _data["unresolved_references"])
                    this.unresolved_references!.push(item);
            }
            if (Array.isArray(_data["validation_errors"])) {
                this.validation_errors = [] as any;
                for (let item of _data["validation_errors"])
                    this.validation_errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResolveReferencesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveReferencesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["success"] = this.success;
        if (Array.isArray(this.resolved_behaviors)) {
            data["resolved_behaviors"] = [];
            for (let item of this.resolved_behaviors)
                data["resolved_behaviors"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.unresolved_references)) {
            data["unresolved_references"] = [];
            for (let item of this.unresolved_references)
                data["unresolved_references"].push(item);
        }
        if (Array.isArray(this.validation_errors)) {
            data["validation_errors"] = [];
            for (let item of this.validation_errors)
                data["validation_errors"].push(item);
        }
        return data;
    }
}

export interface IResolveReferencesResponse {
    /** Whether all references were resolved successfully */
    success: boolean;
    /** Array of behaviors with resolved references */
    resolved_behaviors: BehaviorDefinition[];
    /** List of references that could not be resolved */
    unresolved_references?: string[];
    /** Validation errors encountered during resolution */
    validation_errors?: string[];

    [key: string]: any;
}

export class BehaviorDefinition implements IBehaviorDefinition {
    /** Unique name of the behavior */
    name!: string;
    /** Description of what the behavior does */
    description!: string;
    /** Type of behavior execution pattern */
    type!: BehaviorDefinitionType;
    /** Requirements that must be met before behavior can execute */
    prerequisites?: Prerequisite[];
    /** Sub-behaviors to execute (for sequence/repeat types) */
    steps?: BehaviorDefinition[];
    /** Description of the behavior's result */
    outcome?: string | undefined;
    /** Changes to character/world state after behavior execution */
    contextUpdates?: { [key: string]: string; } | undefined;

    [key: string]: any;

    constructor(data?: IBehaviorDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.description = _data["description"];
            this.type = _data["type"];
            if (Array.isArray(_data["prerequisites"])) {
                this.prerequisites = [] as any;
                for (let item of _data["prerequisites"])
                    this.prerequisites!.push(Prerequisite.fromJS(item));
            }
            if (Array.isArray(_data["steps"])) {
                this.steps = [] as any;
                for (let item of _data["steps"])
                    this.steps!.push(BehaviorDefinition.fromJS(item));
            }
            this.outcome = _data["outcome"];
            if (_data["contextUpdates"]) {
                this.contextUpdates = {} as any;
                for (let key in _data["contextUpdates"]) {
                    if (_data["contextUpdates"].hasOwnProperty(key))
                        (this.contextUpdates as any)![key] = _data["contextUpdates"][key];
                }
            }
        }
    }

    static fromJS(data: any): BehaviorDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new BehaviorDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        if (Array.isArray(this.prerequisites)) {
            data["prerequisites"] = [];
            for (let item of this.prerequisites)
                data["prerequisites"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.steps)) {
            data["steps"] = [];
            for (let item of this.steps)
                data["steps"].push(item ? item.toJSON() : undefined as any);
        }
        data["outcome"] = this.outcome;
        if (this.contextUpdates) {
            data["contextUpdates"] = {};
            for (let key in this.contextUpdates) {
                if (this.contextUpdates.hasOwnProperty(key))
                    (data["contextUpdates"] as any)[key] = (this.contextUpdates as any)[key];
            }
        }
        return data;
    }
}

export interface IBehaviorDefinition {
    /** Unique name of the behavior */
    name: string;
    /** Description of what the behavior does */
    description: string;
    /** Type of behavior execution pattern */
    type: BehaviorDefinitionType;
    /** Requirements that must be met before behavior can execute */
    prerequisites?: Prerequisite[];
    /** Sub-behaviors to execute (for sequence/repeat types) */
    steps?: BehaviorDefinition[];
    /** Description of the behavior's result */
    outcome?: string | undefined;
    /** Changes to character/world state after behavior execution */
    contextUpdates?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export class BehaviorReference implements IBehaviorReference {
    /** Reference to another behavior by name */
    $ref!: string;

    [key: string]: any;

    constructor(data?: IBehaviorReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.$ref = _data["$ref"];
        }
    }

    static fromJS(data: any): BehaviorReference {
        data = typeof data === 'object' ? data : {};
        let result = new BehaviorReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["$ref"] = this.$ref;
        return data;
    }
}

export interface IBehaviorReference {
    /** Reference to another behavior by name */
    $ref: string;

    [key: string]: any;
}

export class Prerequisite implements IPrerequisite {
    /** Name of the required resource, skill, or condition */
    name!: string;
    /** Category of prerequisite */
    type!: PrerequisiteType;
    /** Required quantity or level (defaults to 1) */
    value?: number;

    [key: string]: any;

    constructor(data?: IPrerequisite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.value = 1;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.type = _data["type"];
            this.value = _data["value"] !== undefined ? _data["value"] : 1;
        }
    }

    static fromJS(data: any): Prerequisite {
        data = typeof data === 'object' ? data : {};
        let result = new Prerequisite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

export interface IPrerequisite {
    /** Name of the required resource, skill, or condition */
    name: string;
    /** Category of prerequisite */
    type: PrerequisiteType;
    /** Required quantity or level (defaults to 1) */
    value?: number;

    [key: string]: any;
}

export class BehaviourErrorResponse implements IBehaviourErrorResponse {
    /** Error message */
    error!: string;
    /** Detailed error information */
    details?: string[];
    /** Schema validation errors */
    validation_errors?: string[];
    /** When the error occurred */
    timestamp?: Date;
    /** Unique identifier for the failed request */
    request_id?: string;

    [key: string]: any;

    constructor(data?: IBehaviourErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.error = _data["error"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details!.push(item);
            }
            if (Array.isArray(_data["validation_errors"])) {
                this.validation_errors = [] as any;
                for (let item of _data["validation_errors"])
                    this.validation_errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : undefined as any;
            this.request_id = _data["request_id"];
        }
    }

    static fromJS(data: any): BehaviourErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BehaviourErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["error"] = this.error;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item);
        }
        if (Array.isArray(this.validation_errors)) {
            data["validation_errors"] = [];
            for (let item of this.validation_errors)
                data["validation_errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : undefined as any;
        data["request_id"] = this.request_id;
        return data;
    }
}

export interface IBehaviourErrorResponse {
    /** Error message */
    error: string;
    /** Detailed error information */
    details?: string[];
    /** Schema validation errors */
    validation_errors?: string[];
    /** When the error occurred */
    timestamp?: Date;
    /** Unique identifier for the failed request */
    request_id?: string;

    [key: string]: any;
}

export enum BehaviorDefinitionType {
    Sequence = "sequence",
    Terminal = "terminal",
    Repeat = "repeat",
}

export enum PrerequisiteType {
    Item = "item",
    Tool = "tool",
    Skill = "skill",
    Milestone = "milestone",
    Knowledge = "knowledge",
    Status = "status",
    Other = "other",
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}