//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class ConnectClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost/api/connect";
    }

    /**
     * Establish WebSocket connection
     * @param connection Must be "Upgrade" to initiate WebSocket connection
     * @param upgrade Must be "websocket" to specify protocol upgrade
     * @param authorization JWT Bearer token for new connections: "Bearer <jwt_token>"
    Reconnect token for existing sessions: "Reconnect <reconnect_token>"
     */
    connectWebSocket(connection: Connection, upgrade: Upgrade, authorization: string): Promise<void> {
        let url_ = this.baseUrl + "/connect";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Connection": connection !== undefined && connection !== null ? "" + connection : "",
                "Upgrade": upgrade !== undefined && upgrade !== null ? "" + upgrade : "",
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConnectWebSocket(_response);
        });
    }

    protected processConnectWebSocket(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 101) {
            return response.text().then((_responseText) => {
            return throwException("WebSocket connection established successfully", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ConnectErrorResponse.fromJS(resultData400);
            return throwException("Bad request - missing required headers or invalid request format", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ConnectErrorResponse.fromJS(resultData403);
            return throwException("Forbidden - invalid JWT token or reconnection token", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ConnectErrorResponse.fromJS(resultData500);
            return throwException("Internal server error during connection setup", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Establish WebSocket connection (POST variant)
     * @param body (optional) Optional connection parameters
     */
    connectWebSocketPost(connection: Connection2, upgrade: Upgrade2, authorization: string, body: ConnectRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/connect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Connection": connection !== undefined && connection !== null ? "" + connection : "",
                "Upgrade": upgrade !== undefined && upgrade !== null ? "" + upgrade : "",
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConnectWebSocketPost(_response);
        });
    }

    protected processConnectWebSocketPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 101) {
            return response.text().then((_responseText) => {
            return throwException("WebSocket connection established successfully", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ConnectErrorResponse.fromJS(resultData400);
            return throwException("Bad request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ConnectErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ConnectErrorResponse.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

/** Request model for WebSocket connection establishment. Currently contains no specific fields but extends the base ApiRequest. */
export class ConnectRequest implements IConnectRequest {

    constructor(data?: IConnectRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ConnectRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** Request model for WebSocket connection establishment. Currently contains no specific fields but extends the base ApiRequest. */
export interface IConnectRequest {
}

/** Connection state data returned for connection service requests. Currently a placeholder for future connection metadata. */
export class ConnectionData implements IConnectionData {

    constructor(data?: IConnectionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ConnectionData {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** Connection state data returned for connection service requests. Currently a placeholder for future connection metadata. */
export interface IConnectionData {
}

export class ConnectErrorResponse implements IConnectErrorResponse {
    /** Error type identifier */
    error!: ConnectErrorResponseError;
    /** Human-readable error description */
    message!: string;
    /** HTTP status code */
    status_code!: ConnectErrorResponseStatus_code;

    constructor(data?: IConnectErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"];
            this.message = _data["message"];
            this.status_code = _data["status_code"];
        }
    }

    static fromJS(data: any): ConnectErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error;
        data["message"] = this.message;
        data["status_code"] = this.status_code;
        return data;
    }
}

export interface IConnectErrorResponse {
    /** Error type identifier */
    error: ConnectErrorResponseError;
    /** Human-readable error description */
    message: string;
    /** HTTP status code */
    status_code: ConnectErrorResponseStatus_code;
}

/** Response codes used in the binary protocol. **Success:** - 0: OK **Request Errors (10-19):** - 10: RequestError - 11: RequestTooLarge - 12: TooManyRequests - 13: InvalidRequestChannel **Authorization Errors (20-29):** - 20: Unauthorized **Not Found Errors (30-39):** - 30: ServiceNotFound - 31: ClientNotFound - 32: MessageNotFound **Service Errors (50-60):** - 50: Service_BadRequest - 51: Service_NotFound - 52: Service_Unauthorized - 60: Service_InternalServerError */
export enum ResponseCodes {
    _0 = 0,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _20 = 20,
    _30 = 30,
    _31 = 31,
    _32 = 32,
    _50 = 50,
    _51 = 51,
    _52 = 52,
    _60 = 60,
}

/** Structure of a service request message in the binary protocol. This schema is for documentation - actual messages are binary. */
export class ServiceRequestMessage implements IServiceRequestMessage {
    flags!: number;
    /** Unique identifier for request/response matching */
    message_id!: string;
    /** Channel for sequential message processing (0 = no channel) */
    message_channel!: number;
    /** Target service UUID for routing */
    service_id!: string;
    /** Message payload (JSON or binary data) */
    content!: string;

    [key: string]: any;

    constructor(data?: IServiceRequestMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.flags = _data["flags"];
            this.message_id = _data["message_id"];
            this.message_channel = _data["message_channel"];
            this.service_id = _data["service_id"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): ServiceRequestMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceRequestMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["flags"] = this.flags;
        data["message_id"] = this.message_id;
        data["message_channel"] = this.message_channel;
        data["service_id"] = this.service_id;
        data["content"] = this.content;
        return data;
    }
}

/** Structure of a service request message in the binary protocol. This schema is for documentation - actual messages are binary. */
export interface IServiceRequestMessage {
    flags: number;
    /** Unique identifier for request/response matching */
    message_id: string;
    /** Channel for sequential message processing (0 = no channel) */
    message_channel: number;
    /** Target service UUID for routing */
    service_id: string;
    /** Message payload (JSON or binary data) */
    content: string;

    [key: string]: any;
}

/** Structure of a service response message in the binary protocol. This schema is for documentation - actual messages are binary. */
export class ServiceResponseMessage implements IServiceResponseMessage {
    flags!: number;
    /** Matches the request message ID */
    message_id!: string;
    response_code!: ResponseCodes;
    /** Optional response payload */
    content?: string | undefined;

    [key: string]: any;

    constructor(data?: IServiceResponseMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.flags = _data["flags"];
            this.message_id = _data["message_id"];
            this.response_code = _data["response_code"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): ServiceResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["flags"] = this.flags;
        data["message_id"] = this.message_id;
        data["response_code"] = this.response_code;
        data["content"] = this.content;
        return data;
    }
}

/** Structure of a service response message in the binary protocol. This schema is for documentation - actual messages are binary. */
export interface IServiceResponseMessage {
    flags: number;
    /** Matches the request message ID */
    message_id: string;
    response_code: ResponseCodes;
    /** Optional response payload */
    content?: string | undefined;

    [key: string]: any;
}

/** Configuration options for the connect service. These are server-side settings and not directly exposed via API. */
export class ConnectionConfiguration implements IConnectionConfiguration {
    /** Return Unauthorized instead of NotFound for better security */
    obfuscate_not_found_response?: boolean;
    /** Maximum size for client requests in bytes */
    client_request_max_size?: number;
    /** Maximum size for client responses in bytes */
    client_response_max_size?: number;
    /** Time in seconds to allow client reconnection */
    client_reconnection_time?: number;
    /** Redis connection string for session management */
    redis_connection_string?: string;
    /** Base64-encoded RSA public key for JWT validation */
    token_public_key?: string;

    [key: string]: any;

    constructor(data?: IConnectionConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.obfuscate_not_found_response = true;
            this.client_request_max_size = 16384;
            this.client_response_max_size = 16384;
            this.client_reconnection_time = 30;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.obfuscate_not_found_response = _data["obfuscate_not_found_response"] !== undefined ? _data["obfuscate_not_found_response"] : true;
            this.client_request_max_size = _data["client_request_max_size"] !== undefined ? _data["client_request_max_size"] : 16384;
            this.client_response_max_size = _data["client_response_max_size"] !== undefined ? _data["client_response_max_size"] : 16384;
            this.client_reconnection_time = _data["client_reconnection_time"] !== undefined ? _data["client_reconnection_time"] : 30;
            this.redis_connection_string = _data["redis_connection_string"];
            this.token_public_key = _data["token_public_key"];
        }
    }

    static fromJS(data: any): ConnectionConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["obfuscate_not_found_response"] = this.obfuscate_not_found_response;
        data["client_request_max_size"] = this.client_request_max_size;
        data["client_response_max_size"] = this.client_response_max_size;
        data["client_reconnection_time"] = this.client_reconnection_time;
        data["redis_connection_string"] = this.redis_connection_string;
        data["token_public_key"] = this.token_public_key;
        return data;
    }
}

/** Configuration options for the connect service. These are server-side settings and not directly exposed via API. */
export interface IConnectionConfiguration {
    /** Return Unauthorized instead of NotFound for better security */
    obfuscate_not_found_response?: boolean;
    /** Maximum size for client requests in bytes */
    client_request_max_size?: number;
    /** Maximum size for client responses in bytes */
    client_response_max_size?: number;
    /** Time in seconds to allow client reconnection */
    client_reconnection_time?: number;
    /** Redis connection string for session management */
    redis_connection_string?: string;
    /** Base64-encoded RSA public key for JWT validation */
    token_public_key?: string;

    [key: string]: any;
}

export enum Connection {
    Upgrade = "Upgrade",
}

export enum Upgrade {
    Websocket = "websocket",
}

export enum Connection2 {
    Upgrade = "Upgrade",
}

export enum Upgrade2 {
    Websocket = "websocket",
}

export enum ConnectErrorResponseError {
    BadRequest = "BadRequest",
    Forbidden = "Forbidden",
    InternalServerError = "InternalServerError",
}

export enum ConnectErrorResponseStatus_code {
    _400 = 400,
    _403 = 403,
    _500 = 500,
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}