//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost/api/authorization";
    }

    /**
     * Register new user account
     * @return User registered successfully
     */
    register(body: RegisterRequest): Promise<RegisterResponse> {
        let url_ = this.baseUrl + "/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<RegisterResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = AuthErrorResponse.fromJS(resultData400);
            return throwException("Invalid request data (missing username/password)", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = AuthErrorResponse.fromJS(resultData403);
            return throwException("Registration forbidden (username taken, policy violation)", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = AuthErrorResponse.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegisterResponse>(null as any);
    }

    /**
     * Login with username and password (GET)
     * @param username Username for authentication
     * @param password Password for authentication
     * @return Login successful
     */
    loginWithCredentialsGet(username: string, password: string): Promise<LoginResponse> {
        let url_ = this.baseUrl + "/login/credentials";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "username": username !== undefined && username !== null ? "" + username : "",
                "password": password !== undefined && password !== null ? "" + password : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoginWithCredentialsGet(_response);
        });
    }

    protected processLoginWithCredentialsGet(response: Response): Promise<LoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = AuthErrorResponse.fromJS(resultData400);
            return throwException("Missing username or password", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = AuthErrorResponse.fromJS(resultData403);
            return throwException("Authentication failed (invalid credentials)", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = AuthErrorResponse.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResponse>(null as any);
    }

    /**
     * Login with username and password (POST)
     * @param username Username for authentication
     * @param password Password for authentication
     * @param body (optional) Optional login request body (currently unused)
     * @return Login successful
     */
    loginWithCredentialsPost(username: string, password: string, body: LoginRequest | undefined): Promise<LoginResponse> {
        let url_ = this.baseUrl + "/login/credentials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "username": username !== undefined && username !== null ? "" + username : "",
                "password": password !== undefined && password !== null ? "" + password : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoginWithCredentialsPost(_response);
        });
    }

    protected processLoginWithCredentialsPost(response: Response): Promise<LoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = AuthErrorResponse.fromJS(resultData400);
            return throwException("Missing username or password", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = AuthErrorResponse.fromJS(resultData403);
            return throwException("Authentication failed (invalid credentials)", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = AuthErrorResponse.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResponse>(null as any);
    }

    /**
     * Login with refresh token (GET)
     * @param token Refresh token for authentication
     * @return Token refresh successful
     */
    loginWithTokenGet(token: string): Promise<LoginResponse> {
        let url_ = this.baseUrl + "/login/token";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoginWithTokenGet(_response);
        });
    }

    protected processLoginWithTokenGet(response: Response): Promise<LoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = AuthErrorResponse.fromJS(resultData400);
            return throwException("Missing or invalid token format", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = AuthErrorResponse.fromJS(resultData403);
            return throwException("Token invalid or expired", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = AuthErrorResponse.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResponse>(null as any);
    }

    /**
     * Login with refresh token (POST)
     * @param token Refresh token for authentication
     * @param body (optional) Optional login request body (currently unused)
     * @return Token refresh successful
     */
    loginWithTokenPost(token: string, body: LoginRequest | undefined): Promise<LoginResponse> {
        let url_ = this.baseUrl + "/login/token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "token": token !== undefined && token !== null ? "" + token : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoginWithTokenPost(_response);
        });
    }

    protected processLoginWithTokenPost(response: Response): Promise<LoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = AuthErrorResponse.fromJS(resultData400);
            return throwException("Missing or invalid token format", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = AuthErrorResponse.fromJS(resultData403);
            return throwException("Token invalid or expired", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = AuthErrorResponse.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResponse>(null as any);
    }

    /**
     * Validate JWT access token
     * @return Token validation completed
     */
    validateToken(body: ValidateTokenRequest): Promise<ValidateTokenResponse> {
        let url_ = this.baseUrl + "/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateToken(_response);
        });
    }

    protected processValidateToken(response: Response): Promise<ValidateTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidateTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = AuthErrorResponse.fromJS(resultData400);
            return throwException("Invalid request (missing token)", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = AuthErrorResponse.fromJS(resultData401);
            return throwException("Token invalid or expired", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = AuthErrorResponse.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidateTokenResponse>(null as any);
    }
}

/** Request to register a new user account */
export class RegisterRequest implements IRegisterRequest {
    /** Unique username for the account */
    username!: string;
    /** Password for the account (will be securely hashed) */
    password!: string;
    /** Email address for the account (optional but recommended) */
    email?: string | undefined;

    [key: string]: any;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.username = _data["username"];
            this.password = _data["password"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["username"] = this.username;
        data["password"] = this.password;
        data["email"] = this.email;
        return data;
    }
}

/** Request to register a new user account */
export interface IRegisterRequest {
    /** Unique username for the account */
    username: string;
    /** Password for the account (will be securely hashed) */
    password: string;
    /** Email address for the account (optional but recommended) */
    email?: string | undefined;

    [key: string]: any;
}

/** Response from successful user registration */
export class RegisterResponse implements IRegisterResponse {
    /** JWT access token for immediate authentication */
    access_token!: string;
    /** Refresh token for obtaining new access tokens */
    refresh_token?: string | undefined;

    [key: string]: any;

    constructor(data?: IRegisterResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.access_token = _data["access_token"];
            this.refresh_token = _data["refresh_token"];
        }
    }

    static fromJS(data: any): RegisterResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["access_token"] = this.access_token;
        data["refresh_token"] = this.refresh_token;
        return data;
    }
}

/** Response from successful user registration */
export interface IRegisterResponse {
    /** JWT access token for immediate authentication */
    access_token: string;
    /** Refresh token for obtaining new access tokens */
    refresh_token?: string | undefined;

    [key: string]: any;
}

/** Login request body (currently unused - credentials passed via headers). Provided for future extensibility and consistency with API patterns. */
export class LoginRequest implements ILoginRequest {

    [key: string]: any;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

/** Login request body (currently unused - credentials passed via headers). Provided for future extensibility and consistency with API patterns. */
export interface ILoginRequest {

    [key: string]: any;
}

/** Response from successful user login */
export class LoginResponse implements ILoginResponse {
    /** JWT access token for authentication */
    access_token!: string;
    /** Refresh token for obtaining new access tokens */
    refresh_token?: string | undefined;

    [key: string]: any;

    constructor(data?: ILoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.access_token = _data["access_token"];
            this.refresh_token = _data["refresh_token"];
        }
    }

    static fromJS(data: any): LoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["access_token"] = this.access_token;
        data["refresh_token"] = this.refresh_token;
        return data;
    }
}

/** Response from successful user login */
export interface ILoginResponse {
    /** JWT access token for authentication */
    access_token: string;
    /** Refresh token for obtaining new access tokens */
    refresh_token?: string | undefined;

    [key: string]: any;
}

/** Request to validate a JWT access token */
export class ValidateTokenRequest implements IValidateTokenRequest {
    /** JWT access token to validate */
    token!: string;

    [key: string]: any;

    constructor(data?: IValidateTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ValidateTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["token"] = this.token;
        return data;
    }
}

/** Request to validate a JWT access token */
export interface IValidateTokenRequest {
    /** JWT access token to validate */
    token: string;

    [key: string]: any;
}

/** Response from token validation (currently minimal implementation). Future versions may include token claims, expiration info, and validation details. */
export class ValidateTokenResponse implements IValidateTokenResponse {
    /** Whether the token is valid */
    valid?: boolean;
    /** Token expiration timestamp */
    expires_at?: Date | undefined;
    /** Token subject (user identifier) */
    subject?: string | undefined;
    /** Token claims (roles, permissions, etc.) */
    claims?: any | undefined;

    [key: string]: any;

    constructor(data?: IValidateTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.valid = _data["valid"];
            this.expires_at = _data["expires_at"] ? new Date(_data["expires_at"].toString()) : undefined as any;
            this.subject = _data["subject"];
            this.claims = _data["claims"];
        }
    }

    static fromJS(data: any): ValidateTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["valid"] = this.valid;
        data["expires_at"] = this.expires_at ? this.expires_at.toISOString() : undefined as any;
        data["subject"] = this.subject;
        data["claims"] = this.claims;
        return data;
    }
}

/** Response from token validation (currently minimal implementation). Future versions may include token claims, expiration info, and validation details. */
export interface IValidateTokenResponse {
    /** Whether the token is valid */
    valid?: boolean;
    /** Token expiration timestamp */
    expires_at?: Date | undefined;
    /** Token subject (user identifier) */
    subject?: string | undefined;
    /** Token claims (roles, permissions, etc.) */
    claims?: any | undefined;

    [key: string]: any;
}

/** Internal access data structure containing authentication tokens. Used by service implementations but not directly exposed in API responses. */
export class AccessData implements IAccessData {
    /** JWT access token */
    access_token?: string | undefined;
    /** Refresh token for token renewal */
    refresh_token?: string | undefined;

    [key: string]: any;

    constructor(data?: IAccessData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.access_token = _data["access_token"];
            this.refresh_token = _data["refresh_token"];
        }
    }

    static fromJS(data: any): AccessData {
        data = typeof data === 'object' ? data : {};
        let result = new AccessData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["access_token"] = this.access_token;
        data["refresh_token"] = this.refresh_token;
        return data;
    }
}

/** Internal access data structure containing authentication tokens. Used by service implementations but not directly exposed in API responses. */
export interface IAccessData {
    /** JWT access token */
    access_token?: string | undefined;
    /** Refresh token for token renewal */
    refresh_token?: string | undefined;

    [key: string]: any;
}

/** Error response for failed requests */
export class AuthErrorResponse implements IAuthErrorResponse {
    /** Error type identifier */
    error!: AuthErrorResponseError;
    /** Human-readable error message */
    message!: string;
    /** Additional error context and details */
    details?: any | undefined;

    [key: string]: any;

    constructor(data?: IAuthErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.error = _data["error"];
            this.message = _data["message"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): AuthErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["error"] = this.error;
        data["message"] = this.message;
        data["details"] = this.details;
        return data;
    }
}

/** Error response for failed requests */
export interface IAuthErrorResponse {
    /** Error type identifier */
    error: AuthErrorResponseError;
    /** Human-readable error message */
    message: string;
    /** Additional error context and details */
    details?: any | undefined;

    [key: string]: any;
}

export enum AuthErrorResponseError {
    INVALID_REQUEST = "INVALID_REQUEST",
    MISSING_CREDENTIALS = "MISSING_CREDENTIALS",
    AUTHENTICATION_FAILED = "AUTHENTICATION_FAILED",
    TOKEN_INVALID = "TOKEN_INVALID",
    TOKEN_EXPIRED = "TOKEN_EXPIRED",
    USER_EXISTS = "USER_EXISTS",
    INTERNAL_ERROR = "INTERNAL_ERROR",
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}