//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Asset;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IAssetController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Request upload URL for a new asset
    /// </summary>

    /// <remarks>
    /// Generate a pre-signed URL for uploading a new asset directly to storage.
    /// <br/>For large files (&gt;50MB), returns multipart upload configuration.
    /// </remarks>

    /// <returns>Upload URL generated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestUploadAsync(UploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Mark upload as complete, trigger processing
    /// </summary>

    /// <remarks>
    /// Called after the client has uploaded the file to the pre-signed URL.
    /// <br/>Triggers the asset processing pipeline (texture conversion, model validation, etc.)
    /// <br/>and emits completion events via WebSocket.
    /// </remarks>

    /// <returns>Asset created, processing started</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetMetadata>> CompleteUploadAsync(CompleteUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get asset metadata and download URL
    /// </summary>

    /// <remarks>
    /// Retrieve asset metadata and generate a pre-signed download URL.
    /// <br/>Specify version to download a specific version, or omit for latest.
    /// </remarks>

    /// <returns>Asset metadata with download URL</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetWithDownloadUrl>> GetAssetAsync(GetAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all versions of an asset
    /// </summary>

    /// <remarks>
    /// Retrieve version history for an asset with pagination.
    /// <br/>Includes version IDs, creation timestamps, and archive status.
    /// </remarks>

    /// <returns>List of asset versions</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetVersionList>> ListAssetVersionsAsync(ListVersionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Search assets by tags, type, or realm
    /// </summary>

    /// <remarks>
    /// Search assets using various filters with pagination.
    /// <br/>All filters are optional and combine with AND logic.
    /// </remarks>

    /// <returns>Matching assets</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetSearchResult>> SearchAssetsAsync(AssetSearchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create asset bundle from multiple assets
    /// </summary>

    /// <remarks>
    /// Create a .bannou bundle containing multiple assets.
    /// <br/>For large bundles, processing is delegated to the processing pool.
    /// <br/>Completion notification sent via WebSocket event.
    /// </remarks>

    /// <returns>Bundle creation started</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateBundleResponse>> CreateBundleAsync(CreateBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get bundle manifest and download URL
    /// </summary>

    /// <remarks>
    /// Retrieve bundle metadata and generate a pre-signed download URL.
    /// <br/>Supports both native .bannou format and ZIP conversion (cached).
    /// </remarks>

    /// <returns>Bundle manifest with download URL</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BundleWithDownloadUrl>> GetBundleAsync(GetBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Request upload URL for a pre-made bundle
    /// </summary>

    /// <remarks>
    /// Upload a pre-built bundle (.bannou or .zip format).
    /// <br/>After upload, the bundle undergoes validation before registration.
    /// </remarks>

    /// <returns>Upload URL generated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestBundleUploadAsync(BundleUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class AssetController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IAssetService _implementation;

    public AssetController(IAssetService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.Created => Created("", result),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.Created => result != null ? Created("", result) : Created("", null),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Request upload URL for a new asset
    /// </summary>
    /// <remarks>
    /// Generate a pre-signed URL for uploading a new asset directly to storage.
    /// <br/>For large files (&gt;50MB), returns multipart upload configuration.
    /// </remarks>
    /// <returns>Upload URL generated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/upload/request")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestUpload([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RequestUploadAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Mark upload as complete, trigger processing
    /// </summary>
    /// <remarks>
    /// Called after the client has uploaded the file to the pre-signed URL.
    /// <br/>Triggers the asset processing pipeline (texture conversion, model validation, etc.)
    /// <br/>and emits completion events via WebSocket.
    /// </remarks>
    /// <returns>Asset created, processing started</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetMetadata>> CompleteUpload([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CompleteUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CompleteUploadAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get asset metadata and download URL
    /// </summary>
    /// <remarks>
    /// Retrieve asset metadata and generate a pre-signed download URL.
    /// <br/>Specify version to download a specific version, or omit for latest.
    /// </remarks>
    /// <returns>Asset metadata with download URL</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetWithDownloadUrl>> GetAsset([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetAssetAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List all versions of an asset
    /// </summary>
    /// <remarks>
    /// Retrieve version history for an asset with pagination.
    /// <br/>Includes version IDs, creation timestamps, and archive status.
    /// </remarks>
    /// <returns>List of asset versions</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/list-versions")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetVersionList>> ListAssetVersions([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListVersionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListAssetVersionsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Search assets by tags, type, or realm
    /// </summary>
    /// <remarks>
    /// Search assets using various filters with pagination.
    /// <br/>All filters are optional and combine with AND logic.
    /// </remarks>
    /// <returns>Matching assets</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/search")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetSearchResult>> SearchAssets([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AssetSearchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.SearchAssetsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Create asset bundle from multiple assets
    /// </summary>
    /// <remarks>
    /// Create a .bannou bundle containing multiple assets.
    /// <br/>For large bundles, processing is delegated to the processing pool.
    /// <br/>Completion notification sent via WebSocket event.
    /// </remarks>
    /// <returns>Bundle creation started</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateBundleResponse>> CreateBundle([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateBundleAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get bundle manifest and download URL
    /// </summary>
    /// <remarks>
    /// Retrieve bundle metadata and generate a pre-signed download URL.
    /// <br/>Supports both native .bannou format and ZIP conversion (cached).
    /// </remarks>
    /// <returns>Bundle manifest with download URL</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BundleWithDownloadUrl>> GetBundle([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetBundleAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Request upload URL for a pre-made bundle
    /// </summary>
    /// <remarks>
    /// Upload a pre-built bundle (.bannou or .zip format).
    /// <br/>After upload, the bundle undergoes validation before registration.
    /// </remarks>
    /// <returns>Upload URL generated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestBundleUpload([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BundleUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RequestBundleUploadAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }



    #region Meta Endpoints for RequestUpload

    private static readonly string _RequestUpload_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UploadRequest",
    "$defs": {
        "UploadRequest": {
            "description": "Request to initiate an asset upload and receive a pre-signed URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "filename",
                "size",
                "contentType",
                "owner"
            ],
            "properties": {
                "owner": {
                    "type": "string",
                    "description": "Owner of this asset operation. NOT a session ID.\nFor user-initiated uploads: the accountId (UUID format).\nFor service-initiated uploads: the service name (e.g., \"behavior\", \"orchestrator\").\n"
                },
                "filename": {
                    "type": "string",
                    "description": "Original filename with extension"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type (e.g., image/png, model/gltf-binary)"
                },
                "metadata": {
                    "$ref": "#/$defs/AssetMetadataInput",
                    "description": "Optional metadata for asset categorization"
                }
            }
        },
        "AssetMetadataInput": {
            "type": "object",
            "additionalProperties": false,
            "description": "User-provided metadata for asset categorization",
            "properties": {
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Type classification for the asset"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Game realm the asset belongs to"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for the asset"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        }
    }
}
""";

    private static readonly string _RequestUpload_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UploadResponse",
    "$defs": {
        "UploadResponse": {
            "description": "Response containing pre-signed URL and configuration for uploading an asset",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "uploadId",
                "uploadUrl",
                "expiresAt"
            ],
            "properties": {
                "uploadId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique upload session identifier"
                },
                "uploadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for uploading the file"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the upload URL expires"
                },
                "multipart": {
                    "$ref": "#/$defs/MultipartConfig",
                    "description": "Configuration for multipart uploads if file size requires it"
                },
                "requiredHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Headers the client must include when uploading to the pre-signed URL"
                }
            }
        },
        "MultipartConfig": {
            "description": "Configuration for multipart uploads of large files",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "required": {
                    "type": "boolean",
                    "description": "Whether multipart upload is required for this file size"
                },
                "partSize": {
                    "type": "integer",
                    "description": "Size of each part in bytes"
                },
                "maxParts": {
                    "type": "integer",
                    "description": "Maximum number of parts"
                },
                "uploadUrls": {
                    "type": "array",
                    "description": "Pre-signed URLs for each part of the multipart upload",
                    "items": {
                        "$ref": "#/$defs/PartUploadInfo"
                    }
                }
            }
        },
        "PartUploadInfo": {
            "description": "Upload information for a single part in a multipart upload",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "partNumber",
                "uploadUrl"
            ],
            "properties": {
                "partNumber": {
                    "type": "integer",
                    "description": "Part number (1-based)"
                },
                "uploadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for uploading this part"
                },
                "minSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Minimum size for this part"
                },
                "maxSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Maximum size for this part"
                }
            }
        }
    }
}
""";

    private static readonly string _RequestUpload_Info = """
{
    "summary": "Request upload URL for a new asset",
    "description": "Generate a pre-signed URL for uploading a new asset directly to storage.\nFor large files (>50MB), returns multipart upload configuration.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "requestUpload"
}
""";

    /// <summary>Returns endpoint information for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/request/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/upload/request",
            _RequestUpload_Info));

    /// <summary>Returns request schema for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/request/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/request",
            "request-schema",
            _RequestUpload_RequestSchema));

    /// <summary>Returns response schema for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/request/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/request",
            "response-schema",
            _RequestUpload_ResponseSchema));

    /// <summary>Returns full schema for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/request/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/request",
            _RequestUpload_Info,
            _RequestUpload_RequestSchema,
            _RequestUpload_ResponseSchema));

    #endregion

    #region Meta Endpoints for CompleteUpload

    private static readonly string _CompleteUpload_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CompleteUploadRequest",
    "$defs": {
        "CompleteUploadRequest": {
            "description": "Request to finalize an upload and trigger asset processing",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "uploadId"
            ],
            "properties": {
                "uploadId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Upload session ID from requestUpload"
                },
                "parts": {
                    "type": "array",
                    "nullable": true,
                    "description": "For multipart uploads - ETags of completed parts (null for single-file uploads)",
                    "items": {
                        "$ref": "#/$defs/CompletedPart"
                    }
                }
            }
        },
        "CompletedPart": {
            "description": "Information about a completed part in a multipart upload",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "partNumber",
                "etag"
            ],
            "properties": {
                "partNumber": {
                    "type": "integer",
                    "description": "Part number (1-based)"
                },
                "etag": {
                    "type": "string",
                    "description": "ETag returned from part upload"
                }
            }
        }
    }
}
""";

    private static readonly string _CompleteUpload_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetMetadata",
    "$defs": {
        "AssetMetadata": {
            "type": "object",
            "additionalProperties": false,
            "description": "Complete asset metadata including system-generated fields",
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "filename": {
                    "type": "string",
                    "description": "Original filename"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Type classification for the asset"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Game realm the asset belongs to"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for the asset"
                },
                "processingStatus": {
                    "$ref": "#/$defs/ProcessingStatus",
                    "description": "Current status of asset processing pipeline"
                },
                "isArchived": {
                    "type": "boolean",
                    "description": "Whether the asset is in cold/archival storage",
                    "default": false
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was last updated"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        },
        "ProcessingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "processing",
                "complete",
                "failed"
            ],
            "description": "Asset processing pipeline status"
        }
    }
}
""";

    private static readonly string _CompleteUpload_Info = """
{
    "summary": "Mark upload as complete, trigger processing",
    "description": "Called after the client has uploaded the file to the pre-signed URL.\nTriggers the asset processing pipeline (texture conversion, model validation, etc.)\nand emits completion events via WebSocket.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "completeUpload"
}
""";

    /// <summary>Returns endpoint information for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/upload/complete",
            _CompleteUpload_Info));

    /// <summary>Returns request schema for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/complete",
            "request-schema",
            _CompleteUpload_RequestSchema));

    /// <summary>Returns response schema for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/complete",
            "response-schema",
            _CompleteUpload_ResponseSchema));

    /// <summary>Returns full schema for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/complete",
            _CompleteUpload_Info,
            _CompleteUpload_RequestSchema,
            _CompleteUpload_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetAsset

    private static readonly string _GetAsset_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetAssetRequest",
    "$defs": {
        "GetAssetRequest": {
            "description": "Request to retrieve asset metadata and download URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Asset identifier"
                },
                "version": {
                    "type": "string",
                    "default": "latest",
                    "description": "Version ID or 'latest'"
                }
            }
        }
    }
}
""";

    private static readonly string _GetAsset_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetWithDownloadUrl",
    "$defs": {
        "AssetWithDownloadUrl": {
            "description": "Asset metadata combined with a pre-signed download URL",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "versionId": {
                    "type": "string",
                    "description": "Version identifier for this specific asset version"
                },
                "downloadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed download URL"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the download URL expires"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "metadata": {
                    "$ref": "#/$defs/AssetMetadata",
                    "description": "Complete asset metadata"
                }
            }
        },
        "AssetMetadata": {
            "type": "object",
            "additionalProperties": false,
            "description": "Complete asset metadata including system-generated fields",
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "filename": {
                    "type": "string",
                    "description": "Original filename"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Type classification for the asset"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Game realm the asset belongs to"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for the asset"
                },
                "processingStatus": {
                    "$ref": "#/$defs/ProcessingStatus",
                    "description": "Current status of asset processing pipeline"
                },
                "isArchived": {
                    "type": "boolean",
                    "description": "Whether the asset is in cold/archival storage",
                    "default": false
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was last updated"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        },
        "ProcessingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "processing",
                "complete",
                "failed"
            ],
            "description": "Asset processing pipeline status"
        }
    }
}
""";

    private static readonly string _GetAsset_Info = """
{
    "summary": "Get asset metadata and download URL",
    "description": "Retrieve asset metadata and generate a pre-signed download URL.\nSpecify version to download a specific version, or omit for latest.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "getAsset"
}
""";

    /// <summary>Returns endpoint information for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/get",
            _GetAsset_Info));

    /// <summary>Returns request schema for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/get",
            "request-schema",
            _GetAsset_RequestSchema));

    /// <summary>Returns response schema for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/get",
            "response-schema",
            _GetAsset_ResponseSchema));

    /// <summary>Returns full schema for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/get",
            _GetAsset_Info,
            _GetAsset_RequestSchema,
            _GetAsset_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListAssetVersions

    private static readonly string _ListAssetVersions_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListVersionsRequest",
    "$defs": {
        "ListVersionsRequest": {
            "description": "Request to list all versions of an asset with pagination",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Asset identifier to list versions for"
                },
                "limit": {
                    "type": "integer",
                    "default": 50,
                    "description": "Maximum number of versions to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Number of versions to skip for pagination"
                }
            }
        }
    }
}
""";

    private static readonly string _ListAssetVersions_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetVersionList",
    "$defs": {
        "AssetVersionList": {
            "description": "Paginated list of asset versions",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Asset identifier"
                },
                "versions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetVersion"
                    },
                    "description": "List of asset versions"
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of versions available"
                },
                "limit": {
                    "type": "integer",
                    "description": "Maximum number of versions returned per page"
                },
                "offset": {
                    "type": "integer",
                    "description": "Number of versions skipped"
                }
            }
        },
        "AssetVersion": {
            "description": "Metadata for a specific version of an asset",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "versionId": {
                    "type": "string",
                    "description": "Unique version identifier"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when this version was created"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes for this version"
                },
                "isArchived": {
                    "type": "boolean",
                    "description": "Whether this version is in cold storage"
                }
            }
        }
    }
}
""";

    private static readonly string _ListAssetVersions_Info = """
{
    "summary": "List all versions of an asset",
    "description": "Retrieve version history for an asset with pagination.\nIncludes version IDs, creation timestamps, and archive status.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "listAssetVersions"
}
""";

    /// <summary>Returns endpoint information for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/list-versions/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/list-versions",
            _ListAssetVersions_Info));

    /// <summary>Returns request schema for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/list-versions/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/list-versions",
            "request-schema",
            _ListAssetVersions_RequestSchema));

    /// <summary>Returns response schema for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/list-versions/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/list-versions",
            "response-schema",
            _ListAssetVersions_ResponseSchema));

    /// <summary>Returns full schema for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/list-versions/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/list-versions",
            _ListAssetVersions_Info,
            _ListAssetVersions_RequestSchema,
            _ListAssetVersions_ResponseSchema));

    #endregion

    #region Meta Endpoints for SearchAssets

    private static readonly string _SearchAssets_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetSearchRequest",
    "$defs": {
        "AssetSearchRequest": {
            "description": "Search criteria for filtering assets with pagination",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetType",
                "realm"
            ],
            "properties": {
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Filter by tags (assets must have all specified tags) (null to skip tag filtering)"
                },
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Filter by asset type"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Filter by game realm"
                },
                "contentType": {
                    "type": "string",
                    "nullable": true,
                    "description": "MIME content type filter (null to skip content type filtering)"
                },
                "limit": {
                    "type": "integer",
                    "default": 50,
                    "description": "Maximum number of results to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Number of results to skip for pagination"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        }
    }
}
""";

    private static readonly string _SearchAssets_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetSearchResult",
    "$defs": {
        "AssetSearchResult": {
            "description": "Paginated results from an asset search query",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "assets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetMetadata"
                    },
                    "description": "List of matching assets"
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of matching assets"
                },
                "limit": {
                    "type": "integer",
                    "description": "Maximum number of results returned per page"
                },
                "offset": {
                    "type": "integer",
                    "description": "Number of results skipped"
                }
            }
        },
        "AssetMetadata": {
            "type": "object",
            "additionalProperties": false,
            "description": "Complete asset metadata including system-generated fields",
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "filename": {
                    "type": "string",
                    "description": "Original filename"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Type classification for the asset"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Game realm the asset belongs to"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for the asset"
                },
                "processingStatus": {
                    "$ref": "#/$defs/ProcessingStatus",
                    "description": "Current status of asset processing pipeline"
                },
                "isArchived": {
                    "type": "boolean",
                    "description": "Whether the asset is in cold/archival storage",
                    "default": false
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was last updated"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        },
        "ProcessingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "processing",
                "complete",
                "failed"
            ],
            "description": "Asset processing pipeline status"
        }
    }
}
""";

    private static readonly string _SearchAssets_Info = """
{
    "summary": "Search assets by tags, type, or realm",
    "description": "Search assets using various filters with pagination.\nAll filters are optional and combine with AND logic.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "searchAssets"
}
""";

    /// <summary>Returns endpoint information for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/search/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/search",
            _SearchAssets_Info));

    /// <summary>Returns request schema for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/search/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/search",
            "request-schema",
            _SearchAssets_RequestSchema));

    /// <summary>Returns response schema for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/search/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/search",
            "response-schema",
            _SearchAssets_ResponseSchema));

    /// <summary>Returns full schema for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/search/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/search",
            _SearchAssets_Info,
            _SearchAssets_RequestSchema,
            _SearchAssets_ResponseSchema));

    #endregion

    #region Meta Endpoints for CreateBundle

    private static readonly string _CreateBundle_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateBundleRequest",
    "$defs": {
        "CreateBundleRequest": {
            "description": "Request to create a new asset bundle from multiple assets",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bundleId",
                "assetIds",
                "owner"
            ],
            "properties": {
                "owner": {
                    "type": "string",
                    "description": "Owner of this bundle. NOT a session ID.\nFor user-initiated bundles: the accountId (UUID format).\nFor service-initiated bundles: the service name (e.g., \"orchestrator\").\n"
                },
                "bundleId": {
                    "type": "string",
                    "description": "Unique bundle identifier"
                },
                "version": {
                    "type": "string",
                    "default": "1.0.0",
                    "description": "Bundle version string"
                },
                "assetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of asset IDs to include in the bundle"
                },
                "compression": {
                    "$ref": "#/$defs/CompressionType",
                    "description": "Compression algorithm to use for the bundle"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Custom metadata for the bundle (null if none)"
                }
            }
        },
        "CompressionType": {
            "type": "string",
            "enum": [
                "lz4",
                "lzma",
                "none"
            ],
            "description": "Compression algorithm for bundles"
        }
    }
}
""";

    private static readonly string _CreateBundle_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateBundleResponse",
    "$defs": {
        "CreateBundleResponse": {
            "description": "Response with bundle creation status and estimated size",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Unique bundle identifier"
                },
                "status": {
                    "type": "string",
                    "enum": [
                        "queued",
                        "processing",
                        "ready",
                        "failed"
                    ],
                    "description": "Bundle creation status"
                },
                "estimatedSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Estimated bundle size in bytes"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateBundle_Info = """
{
    "summary": "Create asset bundle from multiple assets",
    "description": "Create a .bannou bundle containing multiple assets.\nFor large bundles, processing is delegated to the processing pool.\ nCompletion notification sent via WebSocket event.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "createBundle"
}
""";

    /// <summary>Returns endpoint information for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "bundles/create",
            _CreateBundle_Info));

    /// <summary>Returns request schema for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/create",
            "request-schema",
            _CreateBundle_RequestSchema));

    /// <summary>Returns response schema for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/create",
            "response-schema",
            _CreateBundle_ResponseSchema));

    /// <summary>Returns full schema for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "bundles/create",
            _CreateBundle_Info,
            _CreateBundle_RequestSchema,
            _CreateBundle_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetBundle

    private static readonly string _GetBundle_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetBundleRequest",
    "$defs": {
        "GetBundleRequest": {
            "description": "Request to retrieve bundle metadata and download URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bundleId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Bundle identifier to retrieve"
                },
                "format": {
                    "$ref": "#/$defs/BundleFormat",
                    "description": "Desired download format (bannou or zip)"
                }
            }
        },
        "BundleFormat": {
            "type": "string",
            "enum": [
                "bannou",
                "zip"
            ],
            "description": "Bundle file format"
        }
    }
}
""";

    private static readonly string _GetBundle_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BundleWithDownloadUrl",
    "$defs": {
        "BundleWithDownloadUrl": {
            "description": "Bundle metadata combined with a pre-signed download URL",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Unique bundle identifier"
                },
                "version": {
                    "type": "string",
                    "description": "Bundle version string"
                },
                "downloadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for downloading the bundle"
                },
                "format": {
                    "$ref": "#/$defs/BundleFormat",
                    "description": "Format of the downloadable bundle"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the download URL expires"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Bundle file size in bytes"
                },
                "assetCount": {
                    "type": "integer",
                    "description": "Number of assets contained in the bundle"
                },
                "fromCache": {
                    "type": "boolean",
                    "description": "True if ZIP format was served from conversion cache"
                }
            }
        },
        "BundleFormat": {
            "type": "string",
            "enum": [
                "bannou",
                "zip"
            ],
            "description": "Bundle file format"
        }
    }
}
""";

    private static readonly string _GetBundle_Info = """
{
    "summary": "Get bundle manifest and download URL",
    "description": "Retrieve bundle metadata and generate a pre-signed download URL.\nSupports both native .bannou format and ZIP conversion (cached).\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "getBundle"
}
""";

    /// <summary>Returns endpoint information for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "bundles/get",
            _GetBundle_Info));

    /// <summary>Returns request schema for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/get",
            "request-schema",
            _GetBundle_RequestSchema));

    /// <summary>Returns response schema for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/get",
            "response-schema",
            _GetBundle_ResponseSchema));

    /// <summary>Returns full schema for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "bundles/get",
            _GetBundle_Info,
            _GetBundle_RequestSchema,
            _GetBundle_ResponseSchema));

    #endregion

    #region Meta Endpoints for RequestBundleUpload

    private static readonly string _RequestBundleUpload_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BundleUploadRequest",
    "$defs": {
        "BundleUploadRequest": {
            "description": "Request to upload a pre-built asset bundle file",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "filename",
                "size",
                "owner"
            ],
            "properties": {
                "owner": {
                    "type": "string",
                    "description": "Owner of this bundle upload. NOT a session ID.\nFor user-initiated uploads: the accountId (UUID format).\nFor service-initiated uploads: the service name (e.g., \"orchestrator\").\n"
                },
                "filename": {
                    "type": "string",
                    "description": "Must end with .bannou or .zip"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Bundle file size in bytes"
                },
                "manifestPreview": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/BundleManifestPreview"
                        }
                    ],
                    "nullable": true,
                    "description": "Optional preview of bundle manifest for validation"
                }
            }
        },
        "BundleManifestPreview": {
            "type": "object",
            "additionalProperties": false,
            "description": "Preview of bundle manifest for validation",
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Bundle identifier from the manifest"
                },
                "version": {
                    "type": "string",
                    "description": "Bundle version from the manifest"
                },
                "assetCount": {
                    "type": "integer",
                    "description": "Number of assets declared in the manifest"
                }
            }
        }
    }
}
""";

    private static readonly string _RequestBundleUpload_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UploadResponse",
    "$defs": {
        "UploadResponse": {
            "description": "Response containing pre-signed URL and configuration for uploading an asset",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "uploadId",
                "uploadUrl",
                "expiresAt"
            ],
            "properties": {
                "uploadId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique upload session identifier"
                },
                "uploadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for uploading the file"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the upload URL expires"
                },
                "multipart": {
                    "$ref": "#/$defs/MultipartConfig",
                    "description": "Configuration for multipart uploads if file size requires it"
                },
                "requiredHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Headers the client must include when uploading to the pre-signed URL"
                }
            }
        },
        "MultipartConfig": {
            "description": "Configuration for multipart uploads of large files",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "required": {
                    "type": "boolean",
                    "description": "Whether multipart upload is required for this file size"
                },
                "partSize": {
                    "type": "integer",
                    "description": "Size of each part in bytes"
                },
                "maxParts": {
                    "type": "integer",
                    "description": "Maximum number of parts"
                },
                "uploadUrls": {
                    "type": "array",
                    "description": "Pre-signed URLs for each part of the multipart upload",
                    "items": {
                        "$ref": "#/$defs/PartUploadInfo"
                    }
                }
            }
        },
        "PartUploadInfo": {
            "description": "Upload information for a single part in a multipart upload",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "partNumber",
                "uploadUrl"
            ],
            "properties": {
                "partNumber": {
                    "type": "integer",
                    "description": "Part number (1-based)"
                },
                "uploadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for uploading this part"
                },
                "minSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Minimum size for this part"
                },
                "maxSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Maximum size for this part"
                }
            }
        }
    }
}
""";

    private static readonly string _RequestBundleUpload_Info = """
{
    "summary": "Request upload URL for a pre-made bundle",
    "description": "Upload a pre-built bundle (.bannou or .zip format).\nAfter upload, the bundle undergoes validation before registration.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "requestBundleUpload"
}
""";

    /// <summary>Returns endpoint information for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "bundles/upload/request",
            _RequestBundleUpload_Info));

    /// <summary>Returns request schema for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/upload/request",
            "request-schema",
            _RequestBundleUpload_RequestSchema));

    /// <summary>Returns response schema for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/upload/request",
            "response-schema",
            _RequestBundleUpload_ResponseSchema));

    /// <summary>Returns full schema for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "bundles/upload/request",
            _RequestBundleUpload_Info,
            _RequestBundleUpload_RequestSchema,
            _RequestBundleUpload_ResponseSchema));

    #endregion

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765