//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#nullable enable

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8600 // Disable "CS8600 Converting null literal or possible null value to non-nullable type"
#pragma warning disable 8602 // Disable "CS8602 Dereference of a possibly null reference"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace BeyondImmersion.BannouService.Asset;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IAssetController : BeyondImmersion.BannouService.Controllers.IDaprController
{

    /// <summary>
    /// Request upload URL for a new asset
    /// </summary>

    /// <remarks>
    /// Generate a pre-signed URL for uploading a new asset directly to storage.
    /// <br/>For large files (&gt;50MB), returns multipart upload configuration.
    /// </remarks>

    /// <returns>Upload URL generated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestUploadAsync(UploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Mark upload as complete, trigger processing
    /// </summary>

    /// <remarks>
    /// Called after the client has uploaded the file to the pre-signed URL.
    /// <br/>Triggers the asset processing pipeline (texture conversion, model validation, etc.)
    /// <br/>and emits completion events via WebSocket.
    /// </remarks>

    /// <returns>Upload completed, processing started</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetMetadata>> CompleteUploadAsync(CompleteUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get asset metadata and download URL
    /// </summary>

    /// <remarks>
    /// Retrieve asset metadata and generate a pre-signed download URL.
    /// <br/>Specify version to download a specific version, or omit for latest.
    /// </remarks>

    /// <returns>Asset metadata with download URL</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetWithDownloadUrl>> GetAssetAsync(GetAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all versions of an asset
    /// </summary>

    /// <remarks>
    /// Retrieve version history for an asset with pagination.
    /// <br/>Includes version IDs, creation timestamps, and archive status.
    /// </remarks>

    /// <returns>List of asset versions</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetVersionList>> ListAssetVersionsAsync(ListVersionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Search assets by tags, type, or realm
    /// </summary>

    /// <remarks>
    /// Search assets using various filters with pagination.
    /// <br/>All filters are optional and combine with AND logic.
    /// </remarks>

    /// <returns>Matching assets</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetSearchResult>> SearchAssetsAsync(AssetSearchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create asset bundle from multiple assets
    /// </summary>

    /// <remarks>
    /// Create a .bannou bundle containing multiple assets.
    /// <br/>For large bundles, processing is delegated to the processing pool.
    /// <br/>Completion notification sent via WebSocket event.
    /// </remarks>

    /// <returns>Bundle creation started</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateBundleResponse>> CreateBundleAsync(CreateBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get bundle manifest and download URL
    /// </summary>

    /// <remarks>
    /// Retrieve bundle metadata and generate a pre-signed download URL.
    /// <br/>Supports both native .bannou format and ZIP conversion (cached).
    /// </remarks>

    /// <returns>Bundle manifest with download URL</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BundleWithDownloadUrl>> GetBundleAsync(GetBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Request upload URL for a pre-made bundle
    /// </summary>

    /// <remarks>
    /// Upload a pre-built bundle (.bannou or .zip format).
    /// <br/>After upload, the bundle undergoes validation before registration.
    /// </remarks>

    /// <returns>Upload URL generated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestBundleUploadAsync(BundleUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
[Microsoft.AspNetCore.Mvc.Route("v1.0/invoke/bannou/method")]

public partial class AssetController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IAssetService _implementation;

    public AssetController(IAssetService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.Created => Created("", result),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.Created => result != null ? Created("", result) : Created("", null),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Request upload URL for a new asset
    /// </summary>
    /// <remarks>
    /// Generate a pre-signed URL for uploading a new asset directly to storage.
    /// <br/>For large files (&gt;50MB), returns multipart upload configuration.
    /// </remarks>
    /// <returns>Upload URL generated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/upload/request")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestUpload([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RequestUploadAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Mark upload as complete, trigger processing
    /// </summary>
    /// <remarks>
    /// Called after the client has uploaded the file to the pre-signed URL.
    /// <br/>Triggers the asset processing pipeline (texture conversion, model validation, etc.)
    /// <br/>and emits completion events via WebSocket.
    /// </remarks>
    /// <returns>Upload completed, processing started</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetMetadata>> CompleteUpload([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CompleteUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CompleteUploadAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get asset metadata and download URL
    /// </summary>
    /// <remarks>
    /// Retrieve asset metadata and generate a pre-signed download URL.
    /// <br/>Specify version to download a specific version, or omit for latest.
    /// </remarks>
    /// <returns>Asset metadata with download URL</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetWithDownloadUrl>> GetAsset([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetAssetAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List all versions of an asset
    /// </summary>
    /// <remarks>
    /// Retrieve version history for an asset with pagination.
    /// <br/>Includes version IDs, creation timestamps, and archive status.
    /// </remarks>
    /// <returns>List of asset versions</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/list-versions")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetVersionList>> ListAssetVersions([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListVersionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListAssetVersionsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Search assets by tags, type, or realm
    /// </summary>
    /// <remarks>
    /// Search assets using various filters with pagination.
    /// <br/>All filters are optional and combine with AND logic.
    /// </remarks>
    /// <returns>Matching assets</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/search")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetSearchResult>> SearchAssets([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AssetSearchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.SearchAssetsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Create asset bundle from multiple assets
    /// </summary>
    /// <remarks>
    /// Create a .bannou bundle containing multiple assets.
    /// <br/>For large bundles, processing is delegated to the processing pool.
    /// <br/>Completion notification sent via WebSocket event.
    /// </remarks>
    /// <returns>Bundle creation started</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateBundleResponse>> CreateBundle([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateBundleAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get bundle manifest and download URL
    /// </summary>
    /// <remarks>
    /// Retrieve bundle metadata and generate a pre-signed download URL.
    /// <br/>Supports both native .bannou format and ZIP conversion (cached).
    /// </remarks>
    /// <returns>Bundle manifest with download URL</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BundleWithDownloadUrl>> GetBundle([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetBundleAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Request upload URL for a pre-made bundle
    /// </summary>
    /// <remarks>
    /// Upload a pre-built bundle (.bannou or .zip format).
    /// <br/>After upload, the bundle undergoes validation before registration.
    /// </remarks>
    /// <returns>Upload URL generated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestBundleUpload([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BundleUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RequestBundleUploadAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }


    #region Meta Endpoints for RequestUpload

    private static readonly string _RequestUpload_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/UploadRequest",
  "$defs": {
    "UploadRequest": {
      "type": "object",
      "required": [
        "filename",
        "size",
        "content_type"
      ],
      "properties": {
        "filename": {
          "type": "string",
          "description": "Original filename with extension"
        },
        "size": {
          "type": "integer",
          "format": "int64",
          "description": "File size in bytes"
        },
        "content_type": {
          "type": "string",
          "description": "MIME content type (e.g., image/png, model/gltf-binary)"
        },
        "metadata": {
          "$ref": "#/$defs/AssetMetadataInput"
        }
      }
    },
    "AssetMetadataInput": {
      "type": "object",
      "description": "User-provided metadata for asset categorization",
      "properties": {
        "asset_type": {
          "$ref": "#/$defs/AssetType"
        },
        "realm": {
          "$ref": "#/$defs/Realm"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Searchable tags for the asset"
        }
      }
    },
    "AssetType": {
      "type": "string",
      "enum": [
        "texture",
        "model",
        "audio",
        "behavior",
        "bundle",
        "prefab",
        "other"
      ],
      "description": "Type classification for assets"
    },
    "Realm": {
      "type": "string",
      "enum": [
        "omega",
        "arcadia",
        "fantasia",
        "shared"
      ],
      "description": "Game realm the asset belongs to"
    }
  }
}
""";

    private static readonly string _RequestUpload_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/UploadResponse",
  "$defs": {
    "UploadResponse": {
      "type": "object",
      "required": [
        "upload_id",
        "upload_url",
        "expires_at"
      ],
      "properties": {
        "upload_id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique upload session identifier"
        },
        "upload_url": {
          "type": "string",
          "format": "uri",
          "description": "Pre-signed URL for uploading the file"
        },
        "expires_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the upload URL expires"
        },
        "multipart": {
          "$ref": "#/$defs/MultipartConfig"
        }
      }
    },
    "MultipartConfig": {
      "type": "object",
      "properties": {
        "required": {
          "type": "boolean",
          "description": "Whether multipart upload is required for this file size"
        },
        "part_size": {
          "type": "integer",
          "description": "Size of each part in bytes"
        },
        "max_parts": {
          "type": "integer",
          "description": "Maximum number of parts"
        },
        "upload_urls": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/PartUploadInfo"
          }
        }
      }
    },
    "PartUploadInfo": {
      "type": "object",
      "required": [
        "part_number",
        "upload_url"
      ],
      "properties": {
        "part_number": {
          "type": "integer",
          "description": "Part number (1-based)"
        },
        "upload_url": {
          "type": "string",
          "format": "uri",
          "description": "Pre-signed URL for uploading this part"
        },
        "min_size": {
          "type": "integer",
          "format": "int64",
          "description": "Minimum size for this part"
        },
        "max_size": {
          "type": "integer",
          "format": "int64",
          "description": "Maximum size for this part"
        }
      }
    }
  }
}
""";

    private static readonly string _RequestUpload_Info = """
{
  "summary": "Request upload URL for a new asset",
  "description": "Generate a pre-signed URL for uploading a new asset directly to storage.\nFor large files (>50MB), returns multipart upload configuration.\n",
  "tags": [
    "Assets"
  ],
  "deprecated": false,
  "operationId": "requestUpload"
}
""";

    /// <summary>Returns endpoint information for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/request/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/upload/request",
            _RequestUpload_Info));

    /// <summary>Returns request schema for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/request/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/request",
            "request-schema",
            _RequestUpload_RequestSchema));

    /// <summary>Returns response schema for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/request/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/request",
            "response-schema",
            _RequestUpload_ResponseSchema));

    /// <summary>Returns full schema for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/request/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/request",
            _RequestUpload_Info,
            _RequestUpload_RequestSchema,
            _RequestUpload_ResponseSchema));

    #endregion

    #region Meta Endpoints for CompleteUpload

    private static readonly string _CompleteUpload_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/CompleteUploadRequest",
  "$defs": {
    "CompleteUploadRequest": {
      "type": "object",
      "required": [
        "upload_id"
      ],
      "properties": {
        "upload_id": {
          "type": "string",
          "format": "uuid",
          "description": "Upload session ID from requestUpload"
        },
        "parts": {
          "type": "array",
          "description": "For multipart uploads - ETags of completed parts",
          "items": {
            "$ref": "#/$defs/CompletedPart"
          }
        }
      }
    },
    "CompletedPart": {
      "type": "object",
      "required": [
        "part_number",
        "etag"
      ],
      "properties": {
        "part_number": {
          "type": "integer",
          "description": "Part number (1-based)"
        },
        "etag": {
          "type": "string",
          "description": "ETag returned from part upload"
        }
      }
    }
  }
}
""";

    private static readonly string _CompleteUpload_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/AssetMetadata",
  "$defs": {
    "AssetMetadata": {
      "type": "object",
      "description": "Complete asset metadata including system-generated fields",
      "properties": {
        "asset_id": {
          "type": "string",
          "description": "Unique asset identifier"
        },
        "content_hash": {
          "type": "string",
          "description": "SHA256 hash of file contents"
        },
        "filename": {
          "type": "string",
          "description": "Original filename"
        },
        "content_type": {
          "type": "string",
          "description": "MIME content type"
        },
        "size": {
          "type": "integer",
          "format": "int64",
          "description": "File size in bytes"
        },
        "asset_type": {
          "$ref": "#/$defs/AssetType"
        },
        "realm": {
          "$ref": "#/$defs/Realm"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "processing_status": {
          "$ref": "#/$defs/ProcessingStatus"
        },
        "is_archived": {
          "type": "boolean",
          "description": "Whether the asset is in cold/archival storage",
          "default": false
        },
        "created_at": {
          "type": "string",
          "format": "date-time"
        },
        "updated_at": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "AssetType": {
      "type": "string",
      "enum": [
        "texture",
        "model",
        "audio",
        "behavior",
        "bundle",
        "prefab",
        "other"
      ],
      "description": "Type classification for assets"
    },
    "Realm": {
      "type": "string",
      "enum": [
        "omega",
        "arcadia",
        "fantasia",
        "shared"
      ],
      "description": "Game realm the asset belongs to"
    },
    "ProcessingStatus": {
      "type": "string",
      "enum": [
        "pending",
        "processing",
        "complete",
        "failed"
      ],
      "description": "Asset processing pipeline status"
    }
  }
}
""";

    private static readonly string _CompleteUpload_Info = """
{
  "summary": "Mark upload as complete, trigger processing",
  "description": "Called after the client has uploaded the file to the pre-signed URL.\nTriggers the asset processing pipeline (texture conversion, model validation, etc.)\nand emits completion events via WebSocket.\n",
  "tags": [
    "Assets"
  ],
  "deprecated": false,
  "operationId": "completeUpload"
}
""";

    /// <summary>Returns endpoint information for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/upload/complete",
            _CompleteUpload_Info));

    /// <summary>Returns request schema for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/complete",
            "request-schema",
            _CompleteUpload_RequestSchema));

    /// <summary>Returns response schema for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/complete",
            "response-schema",
            _CompleteUpload_ResponseSchema));

    /// <summary>Returns full schema for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/complete",
            _CompleteUpload_Info,
            _CompleteUpload_RequestSchema,
            _CompleteUpload_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetAsset

    private static readonly string _GetAsset_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetAssetRequest",
  "$defs": {
    "GetAssetRequest": {
      "type": "object",
      "required": [
        "asset_id"
      ],
      "properties": {
        "asset_id": {
          "type": "string",
          "description": "Asset identifier"
        },
        "version": {
          "type": "string",
          "default": "latest",
          "description": "Version ID or 'latest'"
        }
      }
    }
  }
}
""";

    private static readonly string _GetAsset_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/AssetWithDownloadUrl",
  "$defs": {
    "AssetWithDownloadUrl": {
      "type": "object",
      "properties": {
        "asset_id": {
          "type": "string"
        },
        "version_id": {
          "type": "string"
        },
        "download_url": {
          "type": "string",
          "format": "uri",
          "description": "Pre-signed download URL"
        },
        "expires_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the download URL expires"
        },
        "size": {
          "type": "integer",
          "format": "int64"
        },
        "content_hash": {
          "type": "string"
        },
        "content_type": {
          "type": "string"
        },
        "metadata": {
          "$ref": "#/$defs/AssetMetadata"
        }
      }
    },
    "AssetMetadata": {
      "type": "object",
      "description": "Complete asset metadata including system-generated fields",
      "properties": {
        "asset_id": {
          "type": "string",
          "description": "Unique asset identifier"
        },
        "content_hash": {
          "type": "string",
          "description": "SHA256 hash of file contents"
        },
        "filename": {
          "type": "string",
          "description": "Original filename"
        },
        "content_type": {
          "type": "string",
          "description": "MIME content type"
        },
        "size": {
          "type": "integer",
          "format": "int64",
          "description": "File size in bytes"
        },
        "asset_type": {
          "$ref": "#/$defs/AssetType"
        },
        "realm": {
          "$ref": "#/$defs/Realm"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "processing_status": {
          "$ref": "#/$defs/ProcessingStatus"
        },
        "is_archived": {
          "type": "boolean",
          "description": "Whether the asset is in cold/archival storage",
          "default": false
        },
        "created_at": {
          "type": "string",
          "format": "date-time"
        },
        "updated_at": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "AssetType": {
      "type": "string",
      "enum": [
        "texture",
        "model",
        "audio",
        "behavior",
        "bundle",
        "prefab",
        "other"
      ],
      "description": "Type classification for assets"
    },
    "Realm": {
      "type": "string",
      "enum": [
        "omega",
        "arcadia",
        "fantasia",
        "shared"
      ],
      "description": "Game realm the asset belongs to"
    },
    "ProcessingStatus": {
      "type": "string",
      "enum": [
        "pending",
        "processing",
        "complete",
        "failed"
      ],
      "description": "Asset processing pipeline status"
    }
  }
}
""";

    private static readonly string _GetAsset_Info = """
{
  "summary": "Get asset metadata and download URL",
  "description": "Retrieve asset metadata and generate a pre-signed download URL.\nSpecify version to download a specific version, or omit for latest.\n",
  "tags": [
    "Assets"
  ],
  "deprecated": false,
  "operationId": "getAsset"
}
""";

    /// <summary>Returns endpoint information for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/get",
            _GetAsset_Info));

    /// <summary>Returns request schema for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/get",
            "request-schema",
            _GetAsset_RequestSchema));

    /// <summary>Returns response schema for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/get",
            "response-schema",
            _GetAsset_ResponseSchema));

    /// <summary>Returns full schema for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/get",
            _GetAsset_Info,
            _GetAsset_RequestSchema,
            _GetAsset_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListAssetVersions

    private static readonly string _ListAssetVersions_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListVersionsRequest",
  "$defs": {
    "ListVersionsRequest": {
      "type": "object",
      "required": [
        "asset_id"
      ],
      "properties": {
        "asset_id": {
          "type": "string"
        },
        "limit": {
          "type": "integer",
          "default": 50
        },
        "offset": {
          "type": "integer",
          "default": 0
        }
      }
    }
  }
}
""";

    private static readonly string _ListAssetVersions_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/AssetVersionList",
  "$defs": {
    "AssetVersionList": {
      "type": "object",
      "properties": {
        "asset_id": {
          "type": "string"
        },
        "versions": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/AssetVersion"
          }
        },
        "total": {
          "type": "integer"
        },
        "limit": {
          "type": "integer"
        },
        "offset": {
          "type": "integer"
        }
      }
    },
    "AssetVersion": {
      "type": "object",
      "properties": {
        "version_id": {
          "type": "string"
        },
        "created_at": {
          "type": "string",
          "format": "date-time"
        },
        "size": {
          "type": "integer",
          "format": "int64"
        },
        "is_archived": {
          "type": "boolean",
          "description": "Whether this version is in cold storage"
        }
      }
    }
  }
}
""";

    private static readonly string _ListAssetVersions_Info = """
{
  "summary": "List all versions of an asset",
  "description": "Retrieve version history for an asset with pagination.\nIncludes version IDs, creation timestamps, and archive status.\n",
  "tags": [
    "Assets"
  ],
  "deprecated": false,
  "operationId": "listAssetVersions"
}
""";

    /// <summary>Returns endpoint information for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/list-versions/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/list-versions",
            _ListAssetVersions_Info));

    /// <summary>Returns request schema for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/list-versions/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/list-versions",
            "request-schema",
            _ListAssetVersions_RequestSchema));

    /// <summary>Returns response schema for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/list-versions/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/list-versions",
            "response-schema",
            _ListAssetVersions_ResponseSchema));

    /// <summary>Returns full schema for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/list-versions/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/list-versions",
            _ListAssetVersions_Info,
            _ListAssetVersions_RequestSchema,
            _ListAssetVersions_ResponseSchema));

    #endregion

    #region Meta Endpoints for SearchAssets

    private static readonly string _SearchAssets_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/AssetSearchRequest",
  "$defs": {
    "AssetSearchRequest": {
      "type": "object",
      "properties": {
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "asset_type": {
          "$ref": "#/$defs/AssetType"
        },
        "realm": {
          "$ref": "#/$defs/Realm"
        },
        "content_type": {
          "type": "string",
          "description": "MIME content type filter"
        },
        "limit": {
          "type": "integer",
          "default": 50
        },
        "offset": {
          "type": "integer",
          "default": 0
        }
      }
    },
    "AssetType": {
      "type": "string",
      "enum": [
        "texture",
        "model",
        "audio",
        "behavior",
        "bundle",
        "prefab",
        "other"
      ],
      "description": "Type classification for assets"
    },
    "Realm": {
      "type": "string",
      "enum": [
        "omega",
        "arcadia",
        "fantasia",
        "shared"
      ],
      "description": "Game realm the asset belongs to"
    }
  }
}
""";

    private static readonly string _SearchAssets_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/AssetSearchResult",
  "$defs": {
    "AssetSearchResult": {
      "type": "object",
      "properties": {
        "assets": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/AssetMetadata"
          }
        },
        "total": {
          "type": "integer"
        },
        "limit": {
          "type": "integer"
        },
        "offset": {
          "type": "integer"
        }
      }
    },
    "AssetMetadata": {
      "type": "object",
      "description": "Complete asset metadata including system-generated fields",
      "properties": {
        "asset_id": {
          "type": "string",
          "description": "Unique asset identifier"
        },
        "content_hash": {
          "type": "string",
          "description": "SHA256 hash of file contents"
        },
        "filename": {
          "type": "string",
          "description": "Original filename"
        },
        "content_type": {
          "type": "string",
          "description": "MIME content type"
        },
        "size": {
          "type": "integer",
          "format": "int64",
          "description": "File size in bytes"
        },
        "asset_type": {
          "$ref": "#/$defs/AssetType"
        },
        "realm": {
          "$ref": "#/$defs/Realm"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "processing_status": {
          "$ref": "#/$defs/ProcessingStatus"
        },
        "is_archived": {
          "type": "boolean",
          "description": "Whether the asset is in cold/archival storage",
          "default": false
        },
        "created_at": {
          "type": "string",
          "format": "date-time"
        },
        "updated_at": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "AssetType": {
      "type": "string",
      "enum": [
        "texture",
        "model",
        "audio",
        "behavior",
        "bundle",
        "prefab",
        "other"
      ],
      "description": "Type classification for assets"
    },
    "Realm": {
      "type": "string",
      "enum": [
        "omega",
        "arcadia",
        "fantasia",
        "shared"
      ],
      "description": "Game realm the asset belongs to"
    },
    "ProcessingStatus": {
      "type": "string",
      "enum": [
        "pending",
        "processing",
        "complete",
        "failed"
      ],
      "description": "Asset processing pipeline status"
    }
  }
}
""";

    private static readonly string _SearchAssets_Info = """
{
  "summary": "Search assets by tags, type, or realm",
  "description": "Search assets using various filters with pagination.\nAll filters are optional and combine with AND logic.\n",
  "tags": [
    "Assets"
  ],
  "deprecated": false,
  "operationId": "searchAssets"
}
""";

    /// <summary>Returns endpoint information for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/search/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/search",
            _SearchAssets_Info));

    /// <summary>Returns request schema for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/search/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/search",
            "request-schema",
            _SearchAssets_RequestSchema));

    /// <summary>Returns response schema for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/search/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/search",
            "response-schema",
            _SearchAssets_ResponseSchema));

    /// <summary>Returns full schema for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/search/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/search",
            _SearchAssets_Info,
            _SearchAssets_RequestSchema,
            _SearchAssets_ResponseSchema));

    #endregion

    #region Meta Endpoints for CreateBundle

    private static readonly string _CreateBundle_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/CreateBundleRequest",
  "$defs": {
    "CreateBundleRequest": {
      "type": "object",
      "required": [
        "bundle_id",
        "asset_ids"
      ],
      "properties": {
        "bundle_id": {
          "type": "string",
          "description": "Unique bundle identifier"
        },
        "version": {
          "type": "string",
          "default": "1.0.0",
          "description": "Bundle version string"
        },
        "asset_ids": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of asset IDs to include in the bundle"
        },
        "compression": {
          "$ref": "#/$defs/CompressionType"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "description": "Custom metadata for the bundle"
        }
      }
    },
    "CompressionType": {
      "type": "string",
      "enum": [
        "lz4",
        "lzma",
        "none"
      ],
      "description": "Compression algorithm for bundles"
    }
  }
}
""";

    private static readonly string _CreateBundle_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/CreateBundleResponse",
  "$defs": {
    "CreateBundleResponse": {
      "type": "object",
      "properties": {
        "bundle_id": {
          "type": "string"
        },
        "status": {
          "type": "string",
          "enum": [
            "queued",
            "processing",
            "ready",
            "failed"
          ],
          "description": "Bundle creation status"
        },
        "estimated_size": {
          "type": "integer",
          "format": "int64",
          "description": "Estimated bundle size in bytes"
        }
      }
    }
  }
}
""";

    private static readonly string _CreateBundle_Info = """
{
  "summary": "Create asset bundle from multiple assets",
  "description": "Create a .bannou bundle containing multiple assets.\nFor large bundles, processing is delegated to the processing pool.\ nCompletion notification sent via WebSocket event.\n",
  "tags": [
    "Bundles"
  ],
  "deprecated": false,
  "operationId": "createBundle"
}
""";

    /// <summary>Returns endpoint information for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "bundles/create",
            _CreateBundle_Info));

    /// <summary>Returns request schema for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/create",
            "request-schema",
            _CreateBundle_RequestSchema));

    /// <summary>Returns response schema for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/create",
            "response-schema",
            _CreateBundle_ResponseSchema));

    /// <summary>Returns full schema for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "bundles/create",
            _CreateBundle_Info,
            _CreateBundle_RequestSchema,
            _CreateBundle_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetBundle

    private static readonly string _GetBundle_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetBundleRequest",
  "$defs": {
    "GetBundleRequest": {
      "type": "object",
      "required": [
        "bundle_id"
      ],
      "properties": {
        "bundle_id": {
          "type": "string"
        },
        "format": {
          "$ref": "#/$defs/BundleFormat"
        }
      }
    },
    "BundleFormat": {
      "type": "string",
      "enum": [
        "bannou",
        "zip"
      ],
      "description": "Bundle file format"
    }
  }
}
""";

    private static readonly string _GetBundle_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/BundleWithDownloadUrl",
  "$defs": {
    "BundleWithDownloadUrl": {
      "type": "object",
      "properties": {
        "bundle_id": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "download_url": {
          "type": "string",
          "format": "uri"
        },
        "format": {
          "$ref": "#/$defs/BundleFormat"
        },
        "expires_at": {
          "type": "string",
          "format": "date-time"
        },
        "size": {
          "type": "integer",
          "format": "int64"
        },
        "asset_count": {
          "type": "integer"
        },
        "from_cache": {
          "type": "boolean",
          "description": "True if ZIP format was served from conversion cache"
        }
      }
    },
    "BundleFormat": {
      "type": "string",
      "enum": [
        "bannou",
        "zip"
      ],
      "description": "Bundle file format"
    }
  }
}
""";

    private static readonly string _GetBundle_Info = """
{
  "summary": "Get bundle manifest and download URL",
  "description": "Retrieve bundle metadata and generate a pre-signed download URL.\nSupports both native .bannou format and ZIP conversion (cached).\n",
  "tags": [
    "Bundles"
  ],
  "deprecated": false,
  "operationId": "getBundle"
}
""";

    /// <summary>Returns endpoint information for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "bundles/get",
            _GetBundle_Info));

    /// <summary>Returns request schema for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/get",
            "request-schema",
            _GetBundle_RequestSchema));

    /// <summary>Returns response schema for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/get",
            "response-schema",
            _GetBundle_ResponseSchema));

    /// <summary>Returns full schema for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "bundles/get",
            _GetBundle_Info,
            _GetBundle_RequestSchema,
            _GetBundle_ResponseSchema));

    #endregion

    #region Meta Endpoints for RequestBundleUpload

    private static readonly string _RequestBundleUpload_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/BundleUploadRequest",
  "$defs": {
    "BundleUploadRequest": {
      "type": "object",
      "required": [
        "filename",
        "size"
      ],
      "properties": {
        "filename": {
          "type": "string",
          "description": "Must end with .bannou or .zip"
        },
        "size": {
          "type": "integer",
          "format": "int64"
        },
        "manifest_preview": {
          "$ref": "#/$defs/BundleManifestPreview"
        }
      }
    },
    "BundleManifestPreview": {
      "type": "object",
      "description": "Preview of bundle manifest for validation",
      "properties": {
        "bundle_id": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "asset_count": {
          "type": "integer"
        }
      }
    }
  }
}
""";

    private static readonly string _RequestBundleUpload_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/UploadResponse",
  "$defs": {
    "UploadResponse": {
      "type": "object",
      "required": [
        "upload_id",
        "upload_url",
        "expires_at"
      ],
      "properties": {
        "upload_id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique upload session identifier"
        },
        "upload_url": {
          "type": "string",
          "format": "uri",
          "description": "Pre-signed URL for uploading the file"
        },
        "expires_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the upload URL expires"
        },
        "multipart": {
          "$ref": "#/$defs/MultipartConfig"
        }
      }
    },
    "MultipartConfig": {
      "type": "object",
      "properties": {
        "required": {
          "type": "boolean",
          "description": "Whether multipart upload is required for this file size"
        },
        "part_size": {
          "type": "integer",
          "description": "Size of each part in bytes"
        },
        "max_parts": {
          "type": "integer",
          "description": "Maximum number of parts"
        },
        "upload_urls": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/PartUploadInfo"
          }
        }
      }
    },
    "PartUploadInfo": {
      "type": "object",
      "required": [
        "part_number",
        "upload_url"
      ],
      "properties": {
        "part_number": {
          "type": "integer",
          "description": "Part number (1-based)"
        },
        "upload_url": {
          "type": "string",
          "format": "uri",
          "description": "Pre-signed URL for uploading this part"
        },
        "min_size": {
          "type": "integer",
          "format": "int64",
          "description": "Minimum size for this part"
        },
        "max_size": {
          "type": "integer",
          "format": "int64",
          "description": "Maximum size for this part"
        }
      }
    }
  }
}
""";

    private static readonly string _RequestBundleUpload_Info = """
{
  "summary": "Request upload URL for a pre-made bundle",
  "description": "Upload a pre-built bundle (.bannou or .zip format).\nAfter upload, the bundle undergoes validation before registration.\n",
  "tags": [
    "Bundles"
  ],
  "deprecated": false,
  "operationId": "requestBundleUpload"
}
""";

    /// <summary>Returns endpoint information for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "bundles/upload/request",
            _RequestBundleUpload_Info));

    /// <summary>Returns request schema for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/upload/request",
            "request-schema",
            _RequestBundleUpload_RequestSchema));

    /// <summary>Returns response schema for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/upload/request",
            "response-schema",
            _RequestBundleUpload_ResponseSchema));

    /// <summary>Returns full schema for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "bundles/upload/request",
            _RequestBundleUpload_Info,
            _RequestBundleUpload_RequestSchema,
            _RequestBundleUpload_ResponseSchema));

    #endregion

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
