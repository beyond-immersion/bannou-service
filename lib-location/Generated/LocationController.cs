//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Location;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface ILocationController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Get location by ID
    /// </summary>


    /// <returns>Location retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> GetLocationAsync(GetLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get location by code and realm
    /// </summary>

    /// <remarks>
    /// Retrieve a location using its unique code within a specific realm
    /// </remarks>

    /// <returns>Location retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> GetLocationByCodeAsync(GetLocationByCodeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List locations with filtering
    /// </summary>

    /// <remarks>
    /// Retrieve locations with optional realm, parent, and type filtering
    /// </remarks>

    /// <returns>Locations retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationListResponse>> ListLocationsAsync(ListLocationsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all locations in a realm (primary query pattern)
    /// </summary>

    /// <remarks>
    /// Returns all locations within a specific realm, optionally filtered by
    /// <br/>location type and parent. This is the primary access pattern for
    /// <br/>realm-scoped location queries.
    /// </remarks>

    /// <returns>Locations retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationListResponse>> ListLocationsByRealmAsync(ListLocationsByRealmRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get child locations for a parent location
    /// </summary>

    /// <remarks>
    /// Retrieve all locations that have the specified location as their parent.
    /// <br/>Useful for getting all cities in a region, all buildings in a city, etc.
    /// </remarks>

    /// <returns>Child locations retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationListResponse>> ListLocationsByParentAsync(ListLocationsByParentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get root locations in a realm
    /// </summary>

    /// <remarks>
    /// Returns all top-level locations in a realm (locations with no parent).
    /// <br/>These are typically regions or major areas within the realm.
    /// </remarks>

    /// <returns>Root locations retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationListResponse>> ListRootLocationsAsync(ListRootLocationsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get all ancestors of a location
    /// </summary>

    /// <remarks>
    /// Returns the full ancestry chain from the specified location up to the
    /// <br/>root location (parentLocationId=null). For example, for a specific building
    /// <br/>might return [district, city, region].
    /// </remarks>

    /// <returns>Ancestors retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationListResponse>> GetLocationAncestorsAsync(GetLocationAncestorsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get all descendants of a location
    /// </summary>

    /// <remarks>
    /// Returns all locations that are descendants of the specified location
    /// <br/>(direct children, grandchildren, etc.). Useful for finding all places
    /// <br/>within a region or city.
    /// </remarks>

    /// <returns>Descendants retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationListResponse>> GetLocationDescendantsAsync(GetLocationDescendantsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create new location
    /// </summary>


    /// <returns>Location created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> CreateLocationAsync(CreateLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update location
    /// </summary>


    /// <returns>Location updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> UpdateLocationAsync(UpdateLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Set or change the parent of a location
    /// </summary>

    /// <remarks>
    /// Update a location's parent, moving it in the hierarchy.
    /// <br/>Validates that:
    /// <br/>- New parent exists and is in the same realm
    /// <br/>- No circular reference would be created
    /// <br/>- Updates depth for location and all descendants
    /// </remarks>

    /// <returns>Parent updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> SetLocationParentAsync(SetLocationParentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Remove parent from a location (make it a root location)
    /// </summary>

    /// <remarks>
    /// Remove the parent of a location, making it a top-level root location
    /// <br/>within its realm. Updates depth for location and all descendants.
    /// </remarks>

    /// <returns>Parent removed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> RemoveLocationParentAsync(RemoveLocationParentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete location
    /// </summary>

    /// <remarks>
    /// Hard delete a location. This will fail if the location:
    /// <br/>- Has child locations (must delete or reparent children first)
    /// <br/>- Is still referenced by other entities
    /// <br/>For safe removal, first deprecate the location, remove all children,
    /// <br/>then delete.
    /// </remarks>

    /// <returns>Location deleted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> DeleteLocationAsync(DeleteLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Deprecate a location
    /// </summary>

    /// <remarks>
    /// Soft-delete a location by marking it as deprecated.
    /// <br/>Deprecated locations:
    /// <br/>- Remain queryable for historical data
    /// <br/>- Cannot be used for placing new entities
    /// <br/>- Can be hard-deleted after all references are removed
    /// </remarks>

    /// <returns>Location deprecated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> DeprecateLocationAsync(DeprecateLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Restore a deprecated location
    /// </summary>

    /// <remarks>
    /// Remove the deprecated status from a location, making it
    /// <br/>available for entity placement again.
    /// </remarks>

    /// <returns>Location restored successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> UndeprecateLocationAsync(UndeprecateLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Check if location exists and is active
    /// </summary>

    /// <remarks>
    /// Fast validation endpoint for other services to check location validity.
    /// <br/>Returns true if location exists and is not deprecated, false otherwise.
    /// </remarks>

    /// <returns>Validation result</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationExistsResponse>> LocationExistsAsync(LocationExistsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Seed locations from configuration
    /// </summary>

    /// <remarks>
    /// Idempotent operation to seed locations from provided data.
    /// <br/>Creates locations that don't exist, optionally updates existing locations.
    /// <br/>Processes locations in dependency order (parents before children).
    /// <br/>Typically called at service startup with YAML-defined location hierarchies.
    /// </remarks>

    /// <returns>Seed operation completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SeedLocationsResponse>> SeedLocationsAsync(SeedLocationsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class LocationController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private ILocationService _implementation;

    public LocationController(ILocationService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.Created => Created("", result),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.Created => result != null ? Created("", result) : Created("", null),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Get location by ID
    /// </summary>
    /// <returns>Location retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> GetLocation([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetLocationAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get location by code and realm
    /// </summary>
    /// <remarks>
    /// Retrieve a location using its unique code within a specific realm
    /// </remarks>
    /// <returns>Location retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/get-by-code")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> GetLocationByCode([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetLocationByCodeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetLocationByCodeAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List locations with filtering
    /// </summary>
    /// <remarks>
    /// Retrieve locations with optional realm, parent, and type filtering
    /// </remarks>
    /// <returns>Locations retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationListResponse>> ListLocations([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListLocationsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListLocationsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List all locations in a realm (primary query pattern)
    /// </summary>
    /// <remarks>
    /// Returns all locations within a specific realm, optionally filtered by
    /// <br/>location type and parent. This is the primary access pattern for
    /// <br/>realm-scoped location queries.
    /// </remarks>
    /// <returns>Locations retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/list-by-realm")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationListResponse>> ListLocationsByRealm([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListLocationsByRealmRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListLocationsByRealmAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get child locations for a parent location
    /// </summary>
    /// <remarks>
    /// Retrieve all locations that have the specified location as their parent.
    /// <br/>Useful for getting all cities in a region, all buildings in a city, etc.
    /// </remarks>
    /// <returns>Child locations retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/list-by-parent")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationListResponse>> ListLocationsByParent([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListLocationsByParentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListLocationsByParentAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get root locations in a realm
    /// </summary>
    /// <remarks>
    /// Returns all top-level locations in a realm (locations with no parent).
    /// <br/>These are typically regions or major areas within the realm.
    /// </remarks>
    /// <returns>Root locations retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/list-root")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationListResponse>> ListRootLocations([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListRootLocationsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListRootLocationsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get all ancestors of a location
    /// </summary>
    /// <remarks>
    /// Returns the full ancestry chain from the specified location up to the
    /// <br/>root location (parentLocationId=null). For example, for a specific building
    /// <br/>might return [district, city, region].
    /// </remarks>
    /// <returns>Ancestors retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/get-ancestors")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationListResponse>> GetLocationAncestors([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetLocationAncestorsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetLocationAncestorsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get all descendants of a location
    /// </summary>
    /// <remarks>
    /// Returns all locations that are descendants of the specified location
    /// <br/>(direct children, grandchildren, etc.). Useful for finding all places
    /// <br/>within a region or city.
    /// </remarks>
    /// <returns>Descendants retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/get-descendants")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationListResponse>> GetLocationDescendants([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetLocationDescendantsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetLocationDescendantsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Create new location
    /// </summary>
    /// <returns>Location created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> CreateLocation([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateLocationAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Update location
    /// </summary>
    /// <returns>Location updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> UpdateLocation([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateLocationAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Set or change the parent of a location
    /// </summary>
    /// <remarks>
    /// Update a location's parent, moving it in the hierarchy.
    /// <br/>Validates that:
    /// <br/>- New parent exists and is in the same realm
    /// <br/>- No circular reference would be created
    /// <br/>- Updates depth for location and all descendants
    /// </remarks>
    /// <returns>Parent updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/set-parent")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> SetLocationParent([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SetLocationParentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.SetLocationParentAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Remove parent from a location (make it a root location)
    /// </summary>
    /// <remarks>
    /// Remove the parent of a location, making it a top-level root location
    /// <br/>within its realm. Updates depth for location and all descendants.
    /// </remarks>
    /// <returns>Parent removed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/remove-parent")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> RemoveLocationParent([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RemoveLocationParentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RemoveLocationParentAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Delete location
    /// </summary>
    /// <remarks>
    /// Hard delete a location. This will fail if the location:
    /// <br/>- Has child locations (must delete or reparent children first)
    /// <br/>- Is still referenced by other entities
    /// <br/>For safe removal, first deprecate the location, remove all children,
    /// <br/>then delete.
    /// </remarks>
    /// <returns>Location deleted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> DeleteLocation([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var statusCode = await _implementation.DeleteLocationAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode);
    }

    /// <summary>
    /// Deprecate a location
    /// </summary>
    /// <remarks>
    /// Soft-delete a location by marking it as deprecated.
    /// <br/>Deprecated locations:
    /// <br/>- Remain queryable for historical data
    /// <br/>- Cannot be used for placing new entities
    /// <br/>- Can be hard-deleted after all references are removed
    /// </remarks>
    /// <returns>Location deprecated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/deprecate")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> DeprecateLocation([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeprecateLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DeprecateLocationAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Restore a deprecated location
    /// </summary>
    /// <remarks>
    /// Remove the deprecated status from a location, making it
    /// <br/>available for entity placement again.
    /// </remarks>
    /// <returns>Location restored successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/undeprecate")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationResponse>> UndeprecateLocation([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UndeprecateLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UndeprecateLocationAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Check if location exists and is active
    /// </summary>
    /// <remarks>
    /// Fast validation endpoint for other services to check location validity.
    /// <br/>Returns true if location exists and is not deprecated, false otherwise.
    /// </remarks>
    /// <returns>Validation result</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/exists")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LocationExistsResponse>> LocationExists([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] LocationExistsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.LocationExistsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Seed locations from configuration
    /// </summary>
    /// <remarks>
    /// Idempotent operation to seed locations from provided data.
    /// <br/>Creates locations that don't exist, optionally updates existing locations.
    /// <br/>Processes locations in dependency order (parents before children).
    /// <br/>Typically called at service startup with YAML-defined location hierarchies.
    /// </remarks>
    /// <returns>Seed operation completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("location/seed")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SeedLocationsResponse>> SeedLocations([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SeedLocationsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.SeedLocationsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }



    #region Meta Endpoints for GetLocation

    private static readonly string _GetLocation_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetLocationRequest",
  "$defs": {
    "GetLocationRequest": {
      "description": "Request to retrieve a location by its unique identifier",
      "type": "object",
      "required": [
        "locationId"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier of the location"
        }
      }
    }
  }
}
""";

    private static readonly string _GetLocation_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationResponse",
  "$defs": {
    "LocationResponse": {
      "description": "Complete location data returned from API operations",
      "type": "object",
      "required": [
        "locationId",
        "realmId",
        "code",
        "name",
        "locationType",
        "depth",
        "isDeprecated",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "code": {
          "type": "string",
          "description": "Unique code for the location within its realm"
        },
        "name": {
          "type": "string",
          "description": "Display name of the location"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Optional description of the location"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification of the location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID (null for root locations)"
        },
        "depth": {
          "type": "integer",
          "description": "Depth in hierarchy (0 for root locations)"
        },
        "isDeprecated": {
          "type": "boolean",
          "description": "Whether this location is deprecated and cannot be used"
        },
        "deprecatedAt": {
          "type": "string",
          "format": "date-time",
          "nullable": true,
          "description": "Timestamp when this location was deprecated"
        },
        "deprecationReason": {
          "type": "string",
          "nullable": true,
          "description": "Optional reason for deprecation"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was created"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was last updated"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _GetLocation_Info = """
{
  "summary": "Get location by ID",
  "description": "",
  "tags": [
    "Location"
  ],
  "deprecated": false,
  "operationId": "getLocation"
}
""";

    /// <summary>Returns endpoint information for GetLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocation_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/get",
            _GetLocation_Info));

    /// <summary>Returns request schema for GetLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocation_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/get",
            "request-schema",
            _GetLocation_RequestSchema));

    /// <summary>Returns response schema for GetLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocation_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/get",
            "response-schema",
            _GetLocation_ResponseSchema));

    /// <summary>Returns full schema for GetLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocation_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/get",
            _GetLocation_Info,
            _GetLocation_RequestSchema,
            _GetLocation_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetLocationByCode

    private static readonly string _GetLocationByCode_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetLocationByCodeRequest",
  "$defs": {
    "GetLocationByCodeRequest": {
      "description": "Request to retrieve a location by its code within a specific realm",
      "type": "object",
      "required": [
        "code",
        "realmId"
      ],
      "properties": {
        "code": {
          "type": "string",
          "minLength": 1,
          "maxLength": 100,
          "pattern": "^[A-Z][A-Z0-9_]*$",
          "description": "Unique code for the location within the realm"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm ID to scope the code lookup"
        }
      }
    }
  }
}
""";

    private static readonly string _GetLocationByCode_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationResponse",
  "$defs": {
    "LocationResponse": {
      "description": "Complete location data returned from API operations",
      "type": "object",
      "required": [
        "locationId",
        "realmId",
        "code",
        "name",
        "locationType",
        "depth",
        "isDeprecated",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "code": {
          "type": "string",
          "description": "Unique code for the location within its realm"
        },
        "name": {
          "type": "string",
          "description": "Display name of the location"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Optional description of the location"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification of the location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID (null for root locations)"
        },
        "depth": {
          "type": "integer",
          "description": "Depth in hierarchy (0 for root locations)"
        },
        "isDeprecated": {
          "type": "boolean",
          "description": "Whether this location is deprecated and cannot be used"
        },
        "deprecatedAt": {
          "type": "string",
          "format": "date-time",
          "nullable": true,
          "description": "Timestamp when this location was deprecated"
        },
        "deprecationReason": {
          "type": "string",
          "nullable": true,
          "description": "Optional reason for deprecation"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was created"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was last updated"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _GetLocationByCode_Info = """
{
  "summary": "Get location by code and realm",
  "description": "Retrieve a location using its unique code within a specific realm",
  "tags": [
    "Location"
  ],
  "deprecated": false,
  "operationId": "getLocationByCode"
}
""";

    /// <summary>Returns endpoint information for GetLocationByCode</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get-by-code/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocationByCode_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/get-by-code",
            _GetLocationByCode_Info));

    /// <summary>Returns request schema for GetLocationByCode</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get-by-code/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocationByCode_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/get-by-code",
            "request-schema",
            _GetLocationByCode_RequestSchema));

    /// <summary>Returns response schema for GetLocationByCode</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get-by-code/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocationByCode_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/get-by-code",
            "response-schema",
            _GetLocationByCode_ResponseSchema));

    /// <summary>Returns full schema for GetLocationByCode</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get-by-code/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocationByCode_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/get-by-code",
            _GetLocationByCode_Info,
            _GetLocationByCode_RequestSchema,
            _GetLocationByCode_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListLocations

    private static readonly string _ListLocations_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListLocationsRequest",
  "$defs": {
    "ListLocationsRequest": {
      "description": "Request to list locations with optional filtering by realm, type, and deprecation status",
      "type": "object",
      "properties": {
        "realmId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Filter by realm"
        },
        "locationType": {
          "allOf": [
            {
              "$ref": "#/$defs/LocationType"
            }
          ],
          "nullable": true,
          "description": "Filter by location type"
        },
        "includeDeprecated": {
          "type": "boolean",
          "default": false,
          "description": "Whether to include deprecated locations in the response"
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "default": 1,
          "description": "Page number for pagination (1-indexed)"
        },
        "pageSize": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "default": 20,
          "description": "Number of results per page"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _ListLocations_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationListResponse",
  "$defs": {
    "LocationListResponse": {
      "description": "Paginated list of locations with metadata for navigation",
      "type": "object",
      "required": [
        "locations",
        "totalCount",
        "page",
        "pageSize"
      ],
      "properties": {
        "locations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/LocationResponse"
          },
          "description": "List of locations matching the query"
        },
        "totalCount": {
          "type": "integer",
          "description": "Total number of locations matching the query (across all pages)"
        },
        "page": {
          "type": "integer",
          "description": "Current page number (1-indexed)"
        },
        "pageSize": {
          "type": "integer",
          "description": "Number of results per page"
        },
        "hasNextPage": {
          "type": "boolean",
          "description": "Whether there are more pages after the current page"
        },
        "hasPreviousPage": {
          "type": "boolean",
          "description": "Whether there are pages before the current page"
        }
      }
    },
    "LocationResponse": {
      "description": "Complete location data returned from API operations",
      "type": "object",
      "required": [
        "locationId",
        "realmId",
        "code",
        "name",
        "locationType",
        "depth",
        "isDeprecated",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "code": {
          "type": "string",
          "description": "Unique code for the location within its realm"
        },
        "name": {
          "type": "string",
          "description": "Display name of the location"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Optional description of the location"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification of the location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID (null for root locations)"
        },
        "depth": {
          "type": "integer",
          "description": "Depth in hierarchy (0 for root locations)"
        },
        "isDeprecated": {
          "type": "boolean",
          "description": "Whether this location is deprecated and cannot be used"
        },
        "deprecatedAt": {
          "type": "string",
          "format": "date-time",
          "nullable": true,
          "description": "Timestamp when this location was deprecated"
        },
        "deprecationReason": {
          "type": "string",
          "nullable": true,
          "description": "Optional reason for deprecation"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was created"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was last updated"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _ListLocations_Info = """
{
  "summary": "List locations with filtering",
  "description": "Retrieve locations with optional realm, parent, and type filtering",
  "tags": [
    "Location"
  ],
  "deprecated": false,
  "operationId": "listLocations"
}
""";

    /// <summary>Returns endpoint information for ListLocations</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListLocations_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/list",
            _ListLocations_Info));

    /// <summary>Returns request schema for ListLocations</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListLocations_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/list",
            "request-schema",
            _ListLocations_RequestSchema));

    /// <summary>Returns response schema for ListLocations</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListLocations_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/list",
            "response-schema",
            _ListLocations_ResponseSchema));

    /// <summary>Returns full schema for ListLocations</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListLocations_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/list",
            _ListLocations_Info,
            _ListLocations_RequestSchema,
            _ListLocations_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListLocationsByRealm

    private static readonly string _ListLocationsByRealm_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListLocationsByRealmRequest",
  "$defs": {
    "ListLocationsByRealmRequest": {
      "description": "Request to list all locations within a specific realm with optional filtering",
      "type": "object",
      "required": [
        "realmId"
      ],
      "properties": {
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm ID to query"
        },
        "locationType": {
          "allOf": [
            {
              "$ref": "#/$defs/LocationType"
            }
          ],
          "nullable": true,
          "description": "Optional type filter"
        },
        "includeDeprecated": {
          "type": "boolean",
          "default": false,
          "description": "Whether to include deprecated locations in the response"
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "default": 1,
          "description": "Page number for pagination (1-indexed)"
        },
        "pageSize": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "default": 20,
          "description": "Number of results per page"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _ListLocationsByRealm_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationListResponse",
  "$defs": {
    "LocationListResponse": {
      "description": "Paginated list of locations with metadata for navigation",
      "type": "object",
      "required": [
        "locations",
        "totalCount",
        "page",
        "pageSize"
      ],
      "properties": {
        "locations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/LocationResponse"
          },
          "description": "List of locations matching the query"
        },
        "totalCount": {
          "type": "integer",
          "description": "Total number of locations matching the query (across all pages)"
        },
        "page": {
          "type": "integer",
          "description": "Current page number (1-indexed)"
        },
        "pageSize": {
          "type": "integer",
          "description": "Number of results per page"
        },
        "hasNextPage": {
          "type": "boolean",
          "description": "Whether there are more pages after the current page"
        },
        "hasPreviousPage": {
          "type": "boolean",
          "description": "Whether there are pages before the current page"
        }
      }
    },
    "LocationResponse": {
      "description": "Complete location data returned from API operations",
      "type": "object",
      "required": [
        "locationId",
        "realmId",
        "code",
        "name",
        "locationType",
        "depth",
        "isDeprecated",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "code": {
          "type": "string",
          "description": "Unique code for the location within its realm"
        },
        "name": {
          "type": "string",
          "description": "Display name of the location"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Optional description of the location"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification of the location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID (null for root locations)"
        },
        "depth": {
          "type": "integer",
          "description": "Depth in hierarchy (0 for root locations)"
        },
        "isDeprecated": {
          "type": "boolean",
          "description": "Whether this location is deprecated and cannot be used"
        },
        "deprecatedAt": {
          "type": "string",
          "format": "date-time",
          "nullable": true,
          "description": "Timestamp when this location was deprecated"
        },
        "deprecationReason": {
          "type": "string",
          "nullable": true,
          "description": "Optional reason for deprecation"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was created"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was last updated"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _ListLocationsByRealm_Info = """
{
  "summary": "List all locations in a realm (primary query pattern)",
  "description": "Returns all locations within a specific realm, optionally filtered by\nlocation type and parent. This is the primary access pattern for\nrealm-scoped location queries.\n",
  "tags": [
    "Location"
  ],
  "deprecated": false,
  "operationId": "listLocationsByRealm"
}
""";

    /// <summary>Returns endpoint information for ListLocationsByRealm</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list-by-realm/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListLocationsByRealm_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/list-by-realm",
            _ListLocationsByRealm_Info));

    /// <summary>Returns request schema for ListLocationsByRealm</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list-by-realm/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListLocationsByRealm_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/list-by-realm",
            "request-schema",
            _ListLocationsByRealm_RequestSchema));

    /// <summary>Returns response schema for ListLocationsByRealm</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list-by-realm/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListLocationsByRealm_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/list-by-realm",
            "response-schema",
            _ListLocationsByRealm_ResponseSchema));

    /// <summary>Returns full schema for ListLocationsByRealm</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list-by-realm/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListLocationsByRealm_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/list-by-realm",
            _ListLocationsByRealm_Info,
            _ListLocationsByRealm_RequestSchema,
            _ListLocationsByRealm_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListLocationsByParent

    private static readonly string _ListLocationsByParent_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListLocationsByParentRequest",
  "$defs": {
    "ListLocationsByParentRequest": {
      "description": "Request to list all child locations of a specified parent location",
      "type": "object",
      "required": [
        "parentLocationId"
      ],
      "properties": {
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the parent location"
        },
        "locationType": {
          "allOf": [
            {
              "$ref": "#/$defs/LocationType"
            }
          ],
          "nullable": true,
          "description": "Optional filter by location type"
        },
        "includeDeprecated": {
          "type": "boolean",
          "default": false,
          "description": "Whether to include deprecated locations in the response"
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "default": 1,
          "description": "Page number for pagination (1-indexed)"
        },
        "pageSize": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "default": 20,
          "description": "Number of results per page"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _ListLocationsByParent_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationListResponse",
  "$defs": {
    "LocationListResponse": {
      "description": "Paginated list of locations with metadata for navigation",
      "type": "object",
      "required": [
        "locations",
        "totalCount",
        "page",
        "pageSize"
      ],
      "properties": {
        "locations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/LocationResponse"
          },
          "description": "List of locations matching the query"
        },
        "totalCount": {
          "type": "integer",
          "description": "Total number of locations matching the query (across all pages)"
        },
        "page": {
          "type": "integer",
          "description": "Current page number (1-indexed)"
        },
        "pageSize": {
          "type": "integer",
          "description": "Number of results per page"
        },
        "hasNextPage": {
          "type": "boolean",
          "description": "Whether there are more pages after the current page"
        },
        "hasPreviousPage": {
          "type": "boolean",
          "description": "Whether there are pages before the current page"
        }
      }
    },
    "LocationResponse": {
      "description": "Complete location data returned from API operations",
      "type": "object",
      "required": [
        "locationId",
        "realmId",
        "code",
        "name",
        "locationType",
        "depth",
        "isDeprecated",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "code": {
          "type": "string",
          "description": "Unique code for the location within its realm"
        },
        "name": {
          "type": "string",
          "description": "Display name of the location"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Optional description of the location"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification of the location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID (null for root locations)"
        },
        "depth": {
          "type": "integer",
          "description": "Depth in hierarchy (0 for root locations)"
        },
        "isDeprecated": {
          "type": "boolean",
          "description": "Whether this location is deprecated and cannot be used"
        },
        "deprecatedAt": {
          "type": "string",
          "format": "date-time",
          "nullable": true,
          "description": "Timestamp when this location was deprecated"
        },
        "deprecationReason": {
          "type": "string",
          "nullable": true,
          "description": "Optional reason for deprecation"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was created"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was last updated"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _ListLocationsByParent_Info = """
{
  "summary": "Get child locations for a parent location",
  "description": "Retrieve all locations that have the specified location as their parent.\nUseful for getting all cities in a region, all buildings in a city, etc.\n",
  "tags": [
    "Location"
  ],
  "deprecated": false,
  "operationId": "listLocationsByParent"
}
""";

    /// <summary>Returns endpoint information for ListLocationsByParent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list-by-parent/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListLocationsByParent_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/list-by-parent",
            _ListLocationsByParent_Info));

    /// <summary>Returns request schema for ListLocationsByParent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list-by-parent/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListLocationsByParent_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/list-by-parent",
            "request-schema",
            _ListLocationsByParent_RequestSchema));

    /// <summary>Returns response schema for ListLocationsByParent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list-by-parent/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListLocationsByParent_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/list-by-parent",
            "response-schema",
            _ListLocationsByParent_ResponseSchema));

    /// <summary>Returns full schema for ListLocationsByParent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list-by-parent/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListLocationsByParent_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/list-by-parent",
            _ListLocationsByParent_Info,
            _ListLocationsByParent_RequestSchema,
            _ListLocationsByParent_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListRootLocations

    private static readonly string _ListRootLocations_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListRootLocationsRequest",
  "$defs": {
    "ListRootLocationsRequest": {
      "description": "Request to list all top-level locations (without parents) in a realm",
      "type": "object",
      "required": [
        "realmId"
      ],
      "properties": {
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm ID to get root locations for"
        },
        "locationType": {
          "allOf": [
            {
              "$ref": "#/$defs/LocationType"
            }
          ],
          "nullable": true,
          "description": "Optional filter by location type"
        },
        "includeDeprecated": {
          "type": "boolean",
          "default": false,
          "description": "Whether to include deprecated locations in the response"
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "default": 1,
          "description": "Page number for pagination (1-indexed)"
        },
        "pageSize": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "default": 20,
          "description": "Number of results per page"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _ListRootLocations_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationListResponse",
  "$defs": {
    "LocationListResponse": {
      "description": "Paginated list of locations with metadata for navigation",
      "type": "object",
      "required": [
        "locations",
        "totalCount",
        "page",
        "pageSize"
      ],
      "properties": {
        "locations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/LocationResponse"
          },
          "description": "List of locations matching the query"
        },
        "totalCount": {
          "type": "integer",
          "description": "Total number of locations matching the query (across all pages)"
        },
        "page": {
          "type": "integer",
          "description": "Current page number (1-indexed)"
        },
        "pageSize": {
          "type": "integer",
          "description": "Number of results per page"
        },
        "hasNextPage": {
          "type": "boolean",
          "description": "Whether there are more pages after the current page"
        },
        "hasPreviousPage": {
          "type": "boolean",
          "description": "Whether there are pages before the current page"
        }
      }
    },
    "LocationResponse": {
      "description": "Complete location data returned from API operations",
      "type": "object",
      "required": [
        "locationId",
        "realmId",
        "code",
        "name",
        "locationType",
        "depth",
        "isDeprecated",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "code": {
          "type": "string",
          "description": "Unique code for the location within its realm"
        },
        "name": {
          "type": "string",
          "description": "Display name of the location"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Optional description of the location"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification of the location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID (null for root locations)"
        },
        "depth": {
          "type": "integer",
          "description": "Depth in hierarchy (0 for root locations)"
        },
        "isDeprecated": {
          "type": "boolean",
          "description": "Whether this location is deprecated and cannot be used"
        },
        "deprecatedAt": {
          "type": "string",
          "format": "date-time",
          "nullable": true,
          "description": "Timestamp when this location was deprecated"
        },
        "deprecationReason": {
          "type": "string",
          "nullable": true,
          "description": "Optional reason for deprecation"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was created"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was last updated"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _ListRootLocations_Info = """
{
  "summary": "Get root locations in a realm",
  "description": "Returns all top-level locations in a realm (locations with no parent).\nThese are typically regions or major areas within the realm.\n",
  "tags": [
    "Location"
  ],
  "deprecated": false,
  "operationId": "listRootLocations"
}
""";

    /// <summary>Returns endpoint information for ListRootLocations</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list-root/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListRootLocations_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/list-root",
            _ListRootLocations_Info));

    /// <summary>Returns request schema for ListRootLocations</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list-root/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListRootLocations_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/list-root",
            "request-schema",
            _ListRootLocations_RequestSchema));

    /// <summary>Returns response schema for ListRootLocations</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list-root/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListRootLocations_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/list-root",
            "response-schema",
            _ListRootLocations_ResponseSchema));

    /// <summary>Returns full schema for ListRootLocations</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/list-root/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListRootLocations_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/list-root",
            _ListRootLocations_Info,
            _ListRootLocations_RequestSchema,
            _ListRootLocations_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetLocationAncestors

    private static readonly string _GetLocationAncestors_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetLocationAncestorsRequest",
  "$defs": {
    "GetLocationAncestorsRequest": {
      "description": "Request to retrieve the full ancestry chain of a location up to the root",
      "type": "object",
      "required": [
        "locationId"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "The location to get ancestors for"
        }
      }
    }
  }
}
""";

    private static readonly string _GetLocationAncestors_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationListResponse",
  "$defs": {
    "LocationListResponse": {
      "description": "Paginated list of locations with metadata for navigation",
      "type": "object",
      "required": [
        "locations",
        "totalCount",
        "page",
        "pageSize"
      ],
      "properties": {
        "locations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/LocationResponse"
          },
          "description": "List of locations matching the query"
        },
        "totalCount": {
          "type": "integer",
          "description": "Total number of locations matching the query (across all pages)"
        },
        "page": {
          "type": "integer",
          "description": "Current page number (1-indexed)"
        },
        "pageSize": {
          "type": "integer",
          "description": "Number of results per page"
        },
        "hasNextPage": {
          "type": "boolean",
          "description": "Whether there are more pages after the current page"
        },
        "hasPreviousPage": {
          "type": "boolean",
          "description": "Whether there are pages before the current page"
        }
      }
    },
    "LocationResponse": {
      "description": "Complete location data returned from API operations",
      "type": "object",
      "required": [
        "locationId",
        "realmId",
        "code",
        "name",
        "locationType",
        "depth",
        "isDeprecated",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "code": {
          "type": "string",
          "description": "Unique code for the location within its realm"
        },
        "name": {
          "type": "string",
          "description": "Display name of the location"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Optional description of the location"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification of the location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID (null for root locations)"
        },
        "depth": {
          "type": "integer",
          "description": "Depth in hierarchy (0 for root locations)"
        },
        "isDeprecated": {
          "type": "boolean",
          "description": "Whether this location is deprecated and cannot be used"
        },
        "deprecatedAt": {
          "type": "string",
          "format": "date-time",
          "nullable": true,
          "description": "Timestamp when this location was deprecated"
        },
        "deprecationReason": {
          "type": "string",
          "nullable": true,
          "description": "Optional reason for deprecation"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was created"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was last updated"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _GetLocationAncestors_Info = """
{
  "summary": "Get all ancestors of a location",
  "description": "Returns the full ancestry chain from the specified location up to the\nroot location (parentLocationId=null). For example, for a specific building\nmight return [district, city, region].\n",
  "tags": [
    "Location"
  ],
  "deprecated": false,
  "operationId": "getLocationAncestors"
}
""";

    /// <summary>Returns endpoint information for GetLocationAncestors</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get-ancestors/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocationAncestors_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/get-ancestors",
            _GetLocationAncestors_Info));

    /// <summary>Returns request schema for GetLocationAncestors</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get-ancestors/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocationAncestors_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/get-ancestors",
            "request-schema",
            _GetLocationAncestors_RequestSchema));

    /// <summary>Returns response schema for GetLocationAncestors</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get-ancestors/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocationAncestors_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/get-ancestors",
            "response-schema",
            _GetLocationAncestors_ResponseSchema));

    /// <summary>Returns full schema for GetLocationAncestors</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get-ancestors/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocationAncestors_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/get-ancestors",
            _GetLocationAncestors_Info,
            _GetLocationAncestors_RequestSchema,
            _GetLocationAncestors_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetLocationDescendants

    private static readonly string _GetLocationDescendants_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetLocationDescendantsRequest",
  "$defs": {
    "GetLocationDescendantsRequest": {
      "description": "Request to retrieve all descendants of a location (children, grandchildren, etc.)",
      "type": "object",
      "required": [
        "locationId"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "The location to get descendants for"
        },
        "locationType": {
          "allOf": [
            {
              "$ref": "#/$defs/LocationType"
            }
          ],
          "nullable": true,
          "description": "Optional filter by location type"
        },
        "maxDepth": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10,
          "nullable": true,
          "description": "Maximum depth of descendants to return (null = all)"
        },
        "includeDeprecated": {
          "type": "boolean",
          "default": false,
          "description": "Whether to include deprecated locations in the response"
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "default": 1,
          "description": "Page number for pagination (1-indexed)"
        },
        "pageSize": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "default": 20,
          "description": "Number of results per page"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _GetLocationDescendants_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationListResponse",
  "$defs": {
    "LocationListResponse": {
      "description": "Paginated list of locations with metadata for navigation",
      "type": "object",
      "required": [
        "locations",
        "totalCount",
        "page",
        "pageSize"
      ],
      "properties": {
        "locations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/LocationResponse"
          },
          "description": "List of locations matching the query"
        },
        "totalCount": {
          "type": "integer",
          "description": "Total number of locations matching the query (across all pages)"
        },
        "page": {
          "type": "integer",
          "description": "Current page number (1-indexed)"
        },
        "pageSize": {
          "type": "integer",
          "description": "Number of results per page"
        },
        "hasNextPage": {
          "type": "boolean",
          "description": "Whether there are more pages after the current page"
        },
        "hasPreviousPage": {
          "type": "boolean",
          "description": "Whether there are pages before the current page"
        }
      }
    },
    "LocationResponse": {
      "description": "Complete location data returned from API operations",
      "type": "object",
      "required": [
        "locationId",
        "realmId",
        "code",
        "name",
        "locationType",
        "depth",
        "isDeprecated",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "code": {
          "type": "string",
          "description": "Unique code for the location within its realm"
        },
        "name": {
          "type": "string",
          "description": "Display name of the location"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Optional description of the location"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification of the location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID (null for root locations)"
        },
        "depth": {
          "type": "integer",
          "description": "Depth in hierarchy (0 for root locations)"
        },
        "isDeprecated": {
          "type": "boolean",
          "description": "Whether this location is deprecated and cannot be used"
        },
        "deprecatedAt": {
          "type": "string",
          "format": "date-time",
          "nullable": true,
          "description": "Timestamp when this location was deprecated"
        },
        "deprecationReason": {
          "type": "string",
          "nullable": true,
          "description": "Optional reason for deprecation"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was created"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was last updated"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _GetLocationDescendants_Info = """
{
  "summary": "Get all descendants of a location",
  "description": "Returns all locations that are descendants of the specified location\n(direct children, grandchildren, etc.). Useful for finding all places\ nwithin a region or city.\n",
  "tags": [
    "Location"
  ],
  "deprecated": false,
  "operationId": "getLocationDescendants"
}
""";

    /// <summary>Returns endpoint information for GetLocationDescendants</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get-descendants/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocationDescendants_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/get-descendants",
            _GetLocationDescendants_Info));

    /// <summary>Returns request schema for GetLocationDescendants</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get-descendants/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocationDescendants_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/get-descendants",
            "request-schema",
            _GetLocationDescendants_RequestSchema));

    /// <summary>Returns response schema for GetLocationDescendants</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get-descendants/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocationDescendants_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/get-descendants",
            "response-schema",
            _GetLocationDescendants_ResponseSchema));

    /// <summary>Returns full schema for GetLocationDescendants</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/get-descendants/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLocationDescendants_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/get-descendants",
            _GetLocationDescendants_Info,
            _GetLocationDescendants_RequestSchema,
            _GetLocationDescendants_ResponseSchema));

    #endregion

    #region Meta Endpoints for CreateLocation

    private static readonly string _CreateLocation_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/CreateLocationRequest",
  "$defs": {
    "CreateLocationRequest": {
      "description": "Request to create a new location within a realm",
      "type": "object",
      "required": [
        "code",
        "name",
        "realmId",
        "locationType"
      ],
      "properties": {
        "code": {
          "type": "string",
          "minLength": 1,
          "maxLength": 100,
          "pattern": "^[A-Z][A-Z0-9_]*$",
          "description": "Unique code for the location within the realm"
        },
        "name": {
          "type": "string",
          "minLength": 1,
          "maxLength": 200,
          "description": "Display name for the location"
        },
        "description": {
          "type": "string",
          "maxLength": 2000,
          "nullable": true,
          "description": "Description of the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification for this location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID for hierarchy (null for root locations)"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _CreateLocation_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationResponse",
  "$defs": {
    "LocationResponse": {
      "description": "Complete location data returned from API operations",
      "type": "object",
      "required": [
        "locationId",
        "realmId",
        "code",
        "name",
        "locationType",
        "depth",
        "isDeprecated",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "code": {
          "type": "string",
          "description": "Unique code for the location within its realm"
        },
        "name": {
          "type": "string",
          "description": "Display name of the location"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Optional description of the location"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification of the location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID (null for root locations)"
        },
        "depth": {
          "type": "integer",
          "description": "Depth in hierarchy (0 for root locations)"
        },
        "isDeprecated": {
          "type": "boolean",
          "description": "Whether this location is deprecated and cannot be used"
        },
        "deprecatedAt": {
          "type": "string",
          "format": "date-time",
          "nullable": true,
          "description": "Timestamp when this location was deprecated"
        },
        "deprecationReason": {
          "type": "string",
          "nullable": true,
          "description": "Optional reason for deprecation"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was created"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was last updated"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _CreateLocation_Info = """
{
  "summary": "Create new location",
  "description": "",
  "tags": [
    "Location Admin"
  ],
  "deprecated": false,
  "operationId": "createLocation"
}
""";

    /// <summary>Returns endpoint information for CreateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateLocation_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/create",
            _CreateLocation_Info));

    /// <summary>Returns request schema for CreateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateLocation_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/create",
            "request-schema",
            _CreateLocation_RequestSchema));

    /// <summary>Returns response schema for CreateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateLocation_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/create",
            "response-schema",
            _CreateLocation_ResponseSchema));

    /// <summary>Returns full schema for CreateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateLocation_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/create",
            _CreateLocation_Info,
            _CreateLocation_RequestSchema,
            _CreateLocation_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateLocation

    private static readonly string _UpdateLocation_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/UpdateLocationRequest",
  "$defs": {
    "UpdateLocationRequest": {
      "description": "Request to update an existing location's properties",
      "type": "object",
      "required": [
        "locationId"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the location to update"
        },
        "name": {
          "type": "string",
          "minLength": 1,
          "maxLength": 200,
          "nullable": true,
          "description": "Display name for the location"
        },
        "description": {
          "type": "string",
          "maxLength": 2000,
          "nullable": true,
          "description": "Description of the location"
        },
        "locationType": {
          "allOf": [
            {
              "$ref": "#/$defs/LocationType"
            }
          ],
          "nullable": true,
          "description": "Type of location"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _UpdateLocation_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationResponse",
  "$defs": {
    "LocationResponse": {
      "description": "Complete location data returned from API operations",
      "type": "object",
      "required": [
        "locationId",
        "realmId",
        "code",
        "name",
        "locationType",
        "depth",
        "isDeprecated",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "code": {
          "type": "string",
          "description": "Unique code for the location within its realm"
        },
        "name": {
          "type": "string",
          "description": "Display name of the location"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Optional description of the location"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification of the location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID (null for root locations)"
        },
        "depth": {
          "type": "integer",
          "description": "Depth in hierarchy (0 for root locations)"
        },
        "isDeprecated": {
          "type": "boolean",
          "description": "Whether this location is deprecated and cannot be used"
        },
        "deprecatedAt": {
          "type": "string",
          "format": "date-time",
          "nullable": true,
          "description": "Timestamp when this location was deprecated"
        },
        "deprecationReason": {
          "type": "string",
          "nullable": true,
          "description": "Optional reason for deprecation"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was created"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was last updated"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _UpdateLocation_Info = """
{
  "summary": "Update location",
  "description": "",
  "tags": [
    "Location Admin"
  ],
  "deprecated": false,
  "operationId": "updateLocation"
}
""";

    /// <summary>Returns endpoint information for UpdateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateLocation_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/update",
            _UpdateLocation_Info));

    /// <summary>Returns request schema for UpdateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateLocation_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/update",
            "request-schema",
            _UpdateLocation_RequestSchema));

    /// <summary>Returns response schema for UpdateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateLocation_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/update",
            "response-schema",
            _UpdateLocation_ResponseSchema));

    /// <summary>Returns full schema for UpdateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateLocation_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/update",
            _UpdateLocation_Info,
            _UpdateLocation_RequestSchema,
            _UpdateLocation_ResponseSchema));

    #endregion

    #region Meta Endpoints for SetLocationParent

    private static readonly string _SetLocationParent_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/SetLocationParentRequest",
  "$defs": {
    "SetLocationParentRequest": {
      "description": "Request to set or change a location's parent in the hierarchy",
      "type": "object",
      "required": [
        "locationId",
        "parentLocationId"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the location to update"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the new parent location (must be in same realm)"
        }
      }
    }
  }
}
""";

    private static readonly string _SetLocationParent_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationResponse",
  "$defs": {
    "LocationResponse": {
      "description": "Complete location data returned from API operations",
      "type": "object",
      "required": [
        "locationId",
        "realmId",
        "code",
        "name",
        "locationType",
        "depth",
        "isDeprecated",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "code": {
          "type": "string",
          "description": "Unique code for the location within its realm"
        },
        "name": {
          "type": "string",
          "description": "Display name of the location"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Optional description of the location"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification of the location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID (null for root locations)"
        },
        "depth": {
          "type": "integer",
          "description": "Depth in hierarchy (0 for root locations)"
        },
        "isDeprecated": {
          "type": "boolean",
          "description": "Whether this location is deprecated and cannot be used"
        },
        "deprecatedAt": {
          "type": "string",
          "format": "date-time",
          "nullable": true,
          "description": "Timestamp when this location was deprecated"
        },
        "deprecationReason": {
          "type": "string",
          "nullable": true,
          "description": "Optional reason for deprecation"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was created"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was last updated"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _SetLocationParent_Info = """
{
  "summary": "Set or change the parent of a location",
  "description": "Update a location's parent, moving it in the hierarchy.\nValidates that:\n- New parent exists and is in the same realm\n- No circular reference would be created\n- Updates depth for location and all descendants\n",
  "tags": [
    "Location Admin"
  ],
  "deprecated": false,
  "operationId": "setLocationParent"
}
""";

    /// <summary>Returns endpoint information for SetLocationParent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/set-parent/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SetLocationParent_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/set-parent",
            _SetLocationParent_Info));

    /// <summary>Returns request schema for SetLocationParent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/set-parent/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SetLocationParent_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/set-parent",
            "request-schema",
            _SetLocationParent_RequestSchema));

    /// <summary>Returns response schema for SetLocationParent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/set-parent/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SetLocationParent_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/set-parent",
            "response-schema",
            _SetLocationParent_ResponseSchema));

    /// <summary>Returns full schema for SetLocationParent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/set-parent/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SetLocationParent_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/set-parent",
            _SetLocationParent_Info,
            _SetLocationParent_RequestSchema,
            _SetLocationParent_ResponseSchema));

    #endregion

    #region Meta Endpoints for RemoveLocationParent

    private static readonly string _RemoveLocationParent_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/RemoveLocationParentRequest",
  "$defs": {
    "RemoveLocationParentRequest": {
      "description": "Request to remove a location's parent, making it a root location",
      "type": "object",
      "required": [
        "locationId"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the location to make a root location"
        }
      }
    }
  }
}
""";

    private static readonly string _RemoveLocationParent_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationResponse",
  "$defs": {
    "LocationResponse": {
      "description": "Complete location data returned from API operations",
      "type": "object",
      "required": [
        "locationId",
        "realmId",
        "code",
        "name",
        "locationType",
        "depth",
        "isDeprecated",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "code": {
          "type": "string",
          "description": "Unique code for the location within its realm"
        },
        "name": {
          "type": "string",
          "description": "Display name of the location"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Optional description of the location"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification of the location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID (null for root locations)"
        },
        "depth": {
          "type": "integer",
          "description": "Depth in hierarchy (0 for root locations)"
        },
        "isDeprecated": {
          "type": "boolean",
          "description": "Whether this location is deprecated and cannot be used"
        },
        "deprecatedAt": {
          "type": "string",
          "format": "date-time",
          "nullable": true,
          "description": "Timestamp when this location was deprecated"
        },
        "deprecationReason": {
          "type": "string",
          "nullable": true,
          "description": "Optional reason for deprecation"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was created"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was last updated"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _RemoveLocationParent_Info = """
{
  "summary": "Remove parent from a location (make it a root location)",
  "description": "Remove the parent of a location, making it a top-level root location\nwithin its realm. Updates depth for location and all descendants.\n",
  "tags": [
    "Location Admin"
  ],
  "deprecated": false,
  "operationId": "removeLocationParent"
}
""";

    /// <summary>Returns endpoint information for RemoveLocationParent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/remove-parent/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RemoveLocationParent_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/remove-parent",
            _RemoveLocationParent_Info));

    /// <summary>Returns request schema for RemoveLocationParent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/remove-parent/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RemoveLocationParent_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/remove-parent",
            "request-schema",
            _RemoveLocationParent_RequestSchema));

    /// <summary>Returns response schema for RemoveLocationParent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/remove-parent/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RemoveLocationParent_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/remove-parent",
            "response-schema",
            _RemoveLocationParent_ResponseSchema));

    /// <summary>Returns full schema for RemoveLocationParent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/remove-parent/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RemoveLocationParent_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/remove-parent",
            _RemoveLocationParent_Info,
            _RemoveLocationParent_RequestSchema,
            _RemoveLocationParent_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeleteLocation

    private static readonly string _DeleteLocation_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/DeleteLocationRequest",
  "$defs": {
    "DeleteLocationRequest": {
      "description": "Request to permanently delete a location from the system",
      "type": "object",
      "required": [
        "locationId"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the location to delete"
        }
      }
    }
  }
}
""";

    private static readonly string _DeleteLocation_ResponseSchema = """
{}
""";

    private static readonly string _DeleteLocation_Info = """
{
  "summary": "Delete location",
  "description": "Hard delete a location. This will fail if the location:\n- Has child locations (must delete or reparent children first)\n- Is still referenced by other entities\nFor safe removal, first deprecate the location, remove all children,\nthen delete.\n",
  "tags": [
    "Location Admin"
  ],
  "deprecated": false,
  "operationId": "deleteLocation"
}
""";

    /// <summary>Returns endpoint information for DeleteLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteLocation_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/delete",
            _DeleteLocation_Info));

    /// <summary>Returns request schema for DeleteLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteLocation_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/delete",
            "request-schema",
            _DeleteLocation_RequestSchema));

    /// <summary>Returns response schema for DeleteLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteLocation_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/delete",
            "response-schema",
            _DeleteLocation_ResponseSchema));

    /// <summary>Returns full schema for DeleteLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteLocation_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/delete",
            _DeleteLocation_Info,
            _DeleteLocation_RequestSchema,
            _DeleteLocation_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeprecateLocation

    private static readonly string _DeprecateLocation_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/DeprecateLocationRequest",
  "$defs": {
    "DeprecateLocationRequest": {
      "description": "Request to soft-delete a location by marking it as deprecated",
      "type": "object",
      "required": [
        "locationId"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the location to deprecate"
        },
        "reason": {
          "type": "string",
          "maxLength": 500,
          "nullable": true,
          "description": "Optional reason for deprecation (for audit purposes)"
        }
      }
    }
  }
}
""";

    private static readonly string _DeprecateLocation_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationResponse",
  "$defs": {
    "LocationResponse": {
      "description": "Complete location data returned from API operations",
      "type": "object",
      "required": [
        "locationId",
        "realmId",
        "code",
        "name",
        "locationType",
        "depth",
        "isDeprecated",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "code": {
          "type": "string",
          "description": "Unique code for the location within its realm"
        },
        "name": {
          "type": "string",
          "description": "Display name of the location"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Optional description of the location"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification of the location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID (null for root locations)"
        },
        "depth": {
          "type": "integer",
          "description": "Depth in hierarchy (0 for root locations)"
        },
        "isDeprecated": {
          "type": "boolean",
          "description": "Whether this location is deprecated and cannot be used"
        },
        "deprecatedAt": {
          "type": "string",
          "format": "date-time",
          "nullable": true,
          "description": "Timestamp when this location was deprecated"
        },
        "deprecationReason": {
          "type": "string",
          "nullable": true,
          "description": "Optional reason for deprecation"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was created"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was last updated"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _DeprecateLocation_Info = """
{
  "summary": "Deprecate a location",
  "description": "Soft-delete a location by marking it as deprecated.\nDeprecated locations:\n- Remain queryable for historical data\n- Cannot be used for placing new entities\n- Can be hard-deleted after all references are removed\n",
  "tags": [
    "Location Admin"
  ],
  "deprecated": false,
  "operationId": "deprecateLocation"
}
""";

    /// <summary>Returns endpoint information for DeprecateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/deprecate/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeprecateLocation_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/deprecate",
            _DeprecateLocation_Info));

    /// <summary>Returns request schema for DeprecateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/deprecate/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeprecateLocation_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/deprecate",
            "request-schema",
            _DeprecateLocation_RequestSchema));

    /// <summary>Returns response schema for DeprecateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/deprecate/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeprecateLocation_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/deprecate",
            "response-schema",
            _DeprecateLocation_ResponseSchema));

    /// <summary>Returns full schema for DeprecateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/deprecate/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeprecateLocation_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/deprecate",
            _DeprecateLocation_Info,
            _DeprecateLocation_RequestSchema,
            _DeprecateLocation_ResponseSchema));

    #endregion

    #region Meta Endpoints for UndeprecateLocation

    private static readonly string _UndeprecateLocation_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/UndeprecateLocationRequest",
  "$defs": {
    "UndeprecateLocationRequest": {
      "description": "Request to restore a deprecated location back to active status",
      "type": "object",
      "required": [
        "locationId"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the location to restore"
        }
      }
    }
  }
}
""";

    private static readonly string _UndeprecateLocation_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationResponse",
  "$defs": {
    "LocationResponse": {
      "description": "Complete location data returned from API operations",
      "type": "object",
      "required": [
        "locationId",
        "realmId",
        "code",
        "name",
        "locationType",
        "depth",
        "isDeprecated",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the location"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "description": "Realm this location belongs to"
        },
        "code": {
          "type": "string",
          "description": "Unique code for the location within its realm"
        },
        "name": {
          "type": "string",
          "description": "Display name of the location"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Optional description of the location"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification of the location"
        },
        "parentLocationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "Parent location ID (null for root locations)"
        },
        "depth": {
          "type": "integer",
          "description": "Depth in hierarchy (0 for root locations)"
        },
        "isDeprecated": {
          "type": "boolean",
          "description": "Whether this location is deprecated and cannot be used"
        },
        "deprecatedAt": {
          "type": "string",
          "format": "date-time",
          "nullable": true,
          "description": "Timestamp when this location was deprecated"
        },
        "deprecationReason": {
          "type": "string",
          "nullable": true,
          "description": "Optional reason for deprecation"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was created"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the location was last updated"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _UndeprecateLocation_Info = """
{
  "summary": "Restore a deprecated location",
  "description": "Remove the deprecated status from a location, making it\navailable for entity placement again.\n",
  "tags": [
    "Location Admin"
  ],
  "deprecated": false,
  "operationId": "undeprecateLocation"
}
""";

    /// <summary>Returns endpoint information for UndeprecateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/undeprecate/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UndeprecateLocation_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/undeprecate",
            _UndeprecateLocation_Info));

    /// <summary>Returns request schema for UndeprecateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/undeprecate/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UndeprecateLocation_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/undeprecate",
            "request-schema",
            _UndeprecateLocation_RequestSchema));

    /// <summary>Returns response schema for UndeprecateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/undeprecate/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UndeprecateLocation_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/undeprecate",
            "response-schema",
            _UndeprecateLocation_ResponseSchema));

    /// <summary>Returns full schema for UndeprecateLocation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/undeprecate/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UndeprecateLocation_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/undeprecate",
            _UndeprecateLocation_Info,
            _UndeprecateLocation_RequestSchema,
            _UndeprecateLocation_ResponseSchema));

    #endregion

    #region Meta Endpoints for LocationExists

    private static readonly string _LocationExists_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationExistsRequest",
  "$defs": {
    "LocationExistsRequest": {
      "description": "Request to check if a location exists and is active",
      "type": "object",
      "required": [
        "locationId"
      ],
      "properties": {
        "locationId": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the location to validate"
        }
      }
    }
  }
}
""";

    private static readonly string _LocationExists_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LocationExistsResponse",
  "$defs": {
    "LocationExistsResponse": {
      "description": "Response indicating whether a location exists and its active status",
      "type": "object",
      "required": [
        "exists",
        "isActive"
      ],
      "properties": {
        "exists": {
          "type": "boolean",
          "description": "Whether the location exists"
        },
        "isActive": {
          "type": "boolean",
          "description": "Whether the location is active (false if deprecated or not found)"
        },
        "locationId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "The location ID if found"
        },
        "realmId": {
          "type": "string",
          "format": "uuid",
          "nullable": true,
          "description": "The realm ID if location found"
        }
      }
    }
  }
}
""";

    private static readonly string _LocationExists_Info = """
{
  "summary": "Check if location exists and is active",
  "description": "Fast validation endpoint for other services to check location validity.\nReturns true if location exists and is not deprecated, false otherwise.\n",
  "tags": [
    "Location"
  ],
  "deprecated": false,
  "operationId": "locationExists"
}
""";

    /// <summary>Returns endpoint information for LocationExists</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/exists/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> LocationExists_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/exists",
            _LocationExists_Info));

    /// <summary>Returns request schema for LocationExists</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/exists/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> LocationExists_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/exists",
            "request-schema",
            _LocationExists_RequestSchema));

    /// <summary>Returns response schema for LocationExists</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/exists/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> LocationExists_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/exists",
            "response-schema",
            _LocationExists_ResponseSchema));

    /// <summary>Returns full schema for LocationExists</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/exists/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> LocationExists_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/exists",
            _LocationExists_Info,
            _LocationExists_RequestSchema,
            _LocationExists_ResponseSchema));

    #endregion

    #region Meta Endpoints for SeedLocations

    private static readonly string _SeedLocations_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/SeedLocationsRequest",
  "$defs": {
    "SeedLocationsRequest": {
      "description": "Request to seed multiple locations from configuration data",
      "type": "object",
      "required": [
        "locations"
      ],
      "properties": {
        "locations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SeedLocation"
          },
          "description": "List of locations to seed (processed in dependency order)"
        },
        "updateExisting": {
          "type": "boolean",
          "default": false,
          "description": "Whether to update locations that already exist"
        }
      }
    },
    "SeedLocation": {
      "description": "Location data for seeding operations, using codes instead of IDs for references",
      "type": "object",
      "required": [
        "code",
        "name",
        "realmCode",
        "locationType"
      ],
      "properties": {
        "code": {
          "type": "string",
          "description": "Unique code for the location within realm"
        },
        "name": {
          "type": "string",
          "description": "Display name"
        },
        "description": {
          "type": "string",
          "nullable": true,
          "description": "Description"
        },
        "realmCode": {
          "type": "string",
          "description": "Code of the realm (resolved during seeding)"
        },
        "locationType": {
          "$ref": "#/$defs/LocationType",
          "description": "Type classification for this location"
        },
        "parentLocationCode": {
          "type": "string",
          "nullable": true,
          "description": "Code of the parent location (resolved during seeding)"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional metadata for the location (JSON)"
        }
      }
    },
    "LocationType": {
      "type": "string",
      "description": "Type classification for locations",
      "enum": [
        "CONTINENT",
        "REGION",
        "CITY",
        "DISTRICT",
        "BUILDING",
        "ROOM",
        "LANDMARK",
        "WILDERNESS",
        "DUNGEON",
        "OTHER"
      ]
    }
  }
}
""";

    private static readonly string _SeedLocations_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/SeedLocationsResponse",
  "$defs": {
    "SeedLocationsResponse": {
      "description": "Summary of a seed operation including counts of created, updated, and skipped locations",
      "type": "object",
      "required": [
        "created",
        "updated",
        "skipped",
        "errors"
      ],
      "properties": {
        "created": {
          "type": "integer",
          "description": "Number of new locations created"
        },
        "updated": {
          "type": "integer",
          "description": "Number of existing locations updated"
        },
        "skipped": {
          "type": "integer",
          "description": "Number of locations skipped (already exist, updateExisting=false)"
        },
        "errors": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of error messages for locations that failed to seed"
        }
      }
    }
  }
}
""";

    private static readonly string _SeedLocations_Info = """
{
  "summary": "Seed locations from configuration",
  "description": "Idempotent operation to seed locations from provided data.\nCreates locations that don't exist, optionally updates existing locations.\ nProcesses locations in dependency order (parents before children).\nTypically called at service startup with YAML-defined location hierarchies.\n",
  "tags": [
    "Location Admin"
  ],
  "deprecated": false,
  "operationId": "seedLocations"
}
""";

    /// <summary>Returns endpoint information for SeedLocations</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/seed/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SeedLocations_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Location",
            "Post",
            "location/seed",
            _SeedLocations_Info));

    /// <summary>Returns request schema for SeedLocations</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/seed/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SeedLocations_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/seed",
            "request-schema",
            _SeedLocations_RequestSchema));

    /// <summary>Returns response schema for SeedLocations</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/seed/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SeedLocations_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Location",
            "Post",
            "location/seed",
            "response-schema",
            _SeedLocations_ResponseSchema));

    /// <summary>Returns full schema for SeedLocations</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("location/seed/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SeedLocations_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Location",
            "Post",
            "location/seed",
            _SeedLocations_Info,
            _SeedLocations_RequestSchema,
            _SeedLocations_ResponseSchema));

    #endregion

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765