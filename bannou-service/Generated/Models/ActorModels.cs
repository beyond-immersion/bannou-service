//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable

using BeyondImmersion.BannouService;
using BeyondImmersion.BannouService.Actor;


namespace BeyondImmersion.BannouService.Actor;

using System = global::System;

/// <summary>
/// Request to create a new actor template definition
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class CreateActorTemplateRequest
{

    /// <summary>
    /// Category identifier (e.g., "npc-brain", "world-admin", "cron-cleanup")
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("category")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string Category { get; set; } = default!;

    /// <summary>
    /// Reference to behavior in lib-assets (e.g., "asset://behaviors/npc-brain-v1")
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("behaviorRef")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string BehaviorRef { get; set; } = default!;

    /// <summary>
    /// Default configuration passed to behavior execution
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("configuration")]
    public object? Configuration { get; set; } = default!;

    /// <summary>
    /// Auto-spawn configuration for instantiate-on-access
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("autoSpawn")]
    public AutoSpawnConfig? AutoSpawn { get; set; } = default!;

    /// <summary>
    /// Milliseconds between behavior loop iterations
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("tickIntervalMs")]
    public int TickIntervalMs { get; set; } = 1000;

    /// <summary>
    /// Seconds between automatic state saves (0 to disable)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("autoSaveIntervalSeconds")]
    public int AutoSaveIntervalSeconds { get; set; } = 60;

    /// <summary>
    /// Maximum actors of this category per pool node
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("maxInstancesPerNode")]
    public int MaxInstancesPerNode { get; set; } = 100;

}

/// <summary>
/// Configuration for instantiate-on-access behavior
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class AutoSpawnConfig
{

    /// <summary>
    /// If true, accessing a non-existent actor creates it
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("enabled")]
    public bool Enabled { get; set; } = false;

    /// <summary>
    /// Regex pattern for actor IDs that trigger auto-spawn.
    /// <br/>Examples: "npc-.*" matches "npc-grok", "npc-merchant-123"
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("idPattern")]
    public string? IdPattern { get; set; } = default!;

    /// <summary>
    /// Maximum auto-spawned instances (0 = unlimited)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("maxInstances")]
    public int? MaxInstances { get; set; } = default!;

    /// <summary>
    /// 1-based regex capture group index for extracting CharacterId from actor ID.
    /// <br/>Example: With idPattern "npc-brain-([a-f0-9-]+)" and characterIdCaptureGroup: 1,
    /// <br/>actor ID "npc-brain-abc-123-def" extracts "abc-123-def" as CharacterId (parsed as GUID).
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("characterIdCaptureGroup")]
    [System.ComponentModel.DataAnnotations.Range(1, int.MaxValue)]
    public int? CharacterIdCaptureGroup { get; set; } = default!;

}

/// <summary>
/// Response containing actor template details
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ActorTemplateResponse
{

    /// <summary>
    /// Unique template identifier
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("templateId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public System.Guid TemplateId { get; set; } = default!;

    /// <summary>
    /// Category identifier
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("category")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string Category { get; set; } = default!;

    /// <summary>
    /// Reference to behavior in lib-assets
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("behaviorRef")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string BehaviorRef { get; set; } = default!;

    /// <summary>
    /// Default configuration passed to behavior execution
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("configuration")]
    public object? Configuration { get; set; } = default!;

    /// <summary>
    /// Auto-spawn configuration for instantiate-on-access
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("autoSpawn")]
    public AutoSpawnConfig? AutoSpawn { get; set; } = default!;

    /// <summary>
    /// Milliseconds between behavior loop iterations
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("tickIntervalMs")]
    public int TickIntervalMs { get; set; } = default!;

    /// <summary>
    /// Seconds between automatic state saves
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("autoSaveIntervalSeconds")]
    public int AutoSaveIntervalSeconds { get; set; } = default!;

    /// <summary>
    /// Maximum actors of this category per pool node
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("maxInstancesPerNode")]
    public int MaxInstancesPerNode { get; set; } = default!;

    /// <summary>
    /// When the template was created
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("createdAt")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public System.DateTimeOffset CreatedAt { get; set; } = default!;

    /// <summary>
    /// When the template was last updated
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("updatedAt")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public System.DateTimeOffset UpdatedAt { get; set; } = default!;

}

/// <summary>
/// Request to get an actor template by ID or category
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class GetActorTemplateRequest
{

    /// <summary>
    /// Template ID to retrieve
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("templateId")]
    public System.Guid? TemplateId { get; set; } = default!;

    /// <summary>
    /// Or retrieve by category name
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("category")]
    public string? Category { get; set; } = default!;

}

/// <summary>
/// Request to list actor templates with pagination
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ListActorTemplatesRequest
{

    /// <summary>
    /// Maximum number of templates to return
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("limit")]
    public int Limit { get; set; } = 100;

    /// <summary>
    /// Number of templates to skip
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("offset")]
    public int Offset { get; set; } = 0;

}

/// <summary>
/// Response containing a list of actor templates
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ListActorTemplatesResponse
{

    /// <summary>
    /// List of actor templates
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("templates")]
    [System.ComponentModel.DataAnnotations.Required]
    [System.Text.Json.Serialization.JsonRequired]
    public System.Collections.Generic.ICollection<ActorTemplateResponse> Templates { get; set; } = new System.Collections.ObjectModel.Collection<ActorTemplateResponse>();

    /// <summary>
    /// Total number of templates available
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("total")]
    public int Total { get; set; } = default!;

}

/// <summary>
/// Request to update an existing actor template
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class UpdateActorTemplateRequest
{

    /// <summary>
    /// ID of the template to update
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("templateId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public System.Guid TemplateId { get; set; } = default!;

    /// <summary>
    /// New behavior reference (triggers behavior.updated subscription)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("behaviorRef")]
    public string? BehaviorRef { get; set; } = default!;

    /// <summary>
    /// Updated configuration settings
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("configuration")]
    public object? Configuration { get; set; } = default!;

    /// <summary>
    /// Updated auto-spawn configuration
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("autoSpawn")]
    public AutoSpawnConfig? AutoSpawn { get; set; } = default!;

    /// <summary>
    /// Updated tick interval in milliseconds
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("tickIntervalMs")]
    public int? TickIntervalMs { get; set; } = default!;

    /// <summary>
    /// Updated auto-save interval in seconds
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("autoSaveIntervalSeconds")]
    public int? AutoSaveIntervalSeconds { get; set; } = default!;

}

/// <summary>
/// Request to delete an actor template
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class DeleteActorTemplateRequest
{

    /// <summary>
    /// ID of the template to delete
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("templateId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public System.Guid TemplateId { get; set; } = default!;

    /// <summary>
    /// If true, stops all running actors using this template
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("forceStopActors")]
    public bool ForceStopActors { get; set; } = false;

}

/// <summary>
/// Response confirming template deletion
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class DeleteActorTemplateResponse
{

    /// <summary>
    /// Whether the template was successfully deleted
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("deleted")]
    public bool Deleted { get; set; } = default!;

    /// <summary>
    /// Number of running actors that were stopped
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("stoppedActorCount")]
    public int StoppedActorCount { get; set; } = default!;

}

/// <summary>
/// Request to spawn a new actor from a template
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class SpawnActorRequest
{

    /// <summary>
    /// Template to instantiate from
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("templateId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public System.Guid TemplateId { get; set; } = default!;

    /// <summary>
    /// Optional custom actor ID (auto-generated if not provided)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    public string? ActorId { get; set; } = default!;

    /// <summary>
    /// Override template defaults
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("configurationOverrides")]
    public object? ConfigurationOverrides { get; set; } = default!;

    /// <summary>
    /// Initial state passed to behavior
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("initialState")]
    public object? InitialState { get; set; } = default!;

    /// <summary>
    /// Optional character ID for NPC brain actors
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("characterId")]
    public System.Guid? CharacterId { get; set; } = default!;

}

/// <summary>
/// Request to get an actor instance by ID
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class GetActorRequest
{

    /// <summary>
    /// Actor ID to retrieve
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActorId { get; set; } = default!;

}

/// <summary>
/// Response containing actor instance details
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ActorInstanceResponse
{

    /// <summary>
    /// Unique actor identifier
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActorId { get; set; } = default!;

    /// <summary>
    /// Template this actor was instantiated from
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("templateId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public System.Guid TemplateId { get; set; } = default!;

    /// <summary>
    /// Actor category from template
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("category")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string Category { get; set; } = default!;

    /// <summary>
    /// Pool node running this actor (null in bannou mode)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("nodeId")]
    public string? NodeId { get; set; } = default!;

    /// <summary>
    /// Pool node's app-id for direct messaging
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("nodeAppId")]
    public string? NodeAppId { get; set; } = default!;

    /// <summary>
    /// Current actor lifecycle state
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("status")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
    public ActorStatus Status { get; set; } = default!;

    /// <summary>
    /// Associated character ID (for NPC brains)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("characterId")]
    public System.Guid? CharacterId { get; set; } = default!;

    /// <summary>
    /// When the actor started running
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("startedAt")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public System.DateTimeOffset StartedAt { get; set; } = default!;

    /// <summary>
    /// Last heartbeat timestamp from the actor
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("lastHeartbeat")]
    public System.DateTimeOffset? LastHeartbeat { get; set; } = default!;

    /// <summary>
    /// Number of behavior loop iterations executed
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("loopIterations")]
    public long LoopIterations { get; set; } = default!;

}

/// <summary>
/// Current actor lifecycle state
/// </summary>
#pragma warning disable CS1591 // Enum members cannot have XML documentation
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public enum ActorStatus
{

    [System.Runtime.Serialization.EnumMember(Value = @"pending")]
    Pending = 0,

    [System.Runtime.Serialization.EnumMember(Value = @"starting")]
    Starting = 1,

    [System.Runtime.Serialization.EnumMember(Value = @"running")]
    Running = 2,

    [System.Runtime.Serialization.EnumMember(Value = @"paused")]
    Paused = 3,

    [System.Runtime.Serialization.EnumMember(Value = @"stopping")]
    Stopping = 4,

    [System.Runtime.Serialization.EnumMember(Value = @"stopped")]
    Stopped = 5,

    [System.Runtime.Serialization.EnumMember(Value = @"error")]
    Error = 6,

}
#pragma warning restore CS1591

/// <summary>
/// Request to stop a running actor
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class StopActorRequest
{

    /// <summary>
    /// ID of the actor to stop
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActorId { get; set; } = default!;

    /// <summary>
    /// If true, allows behavior to complete current iteration
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("graceful")]
    public bool Graceful { get; set; } = true;

}

/// <summary>
/// Response confirming actor stop operation
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class StopActorResponse
{

    /// <summary>
    /// Whether the actor was successfully stopped
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("stopped")]
    public bool Stopped { get; set; } = default!;

    /// <summary>
    /// Final status of the actor after stopping
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("finalStatus")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
    public ActorStatus FinalStatus { get; set; } = default!;

}

/// <summary>
/// Request to list actor instances with optional filters
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ListActorsRequest
{

    /// <summary>
    /// Filter by category
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("category")]
    public string? Category { get; set; } = default!;

    /// <summary>
    /// Filter by pool node
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("nodeId")]
    public string? NodeId { get; set; } = default!;

    /// <summary>
    /// Filter by actor status
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("status")]
    [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
    public ActorStatus Status { get; set; } = default!;

    /// <summary>
    /// Filter by associated character
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("characterId")]
    public System.Guid? CharacterId { get; set; } = default!;

    /// <summary>
    /// Maximum number of actors to return
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("limit")]
    public int Limit { get; set; } = 100;

    /// <summary>
    /// Number of actors to skip
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("offset")]
    public int Offset { get; set; } = 0;

}

/// <summary>
/// Response containing a list of actor instances
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ListActorsResponse
{

    /// <summary>
    /// List of actor instances
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actors")]
    [System.ComponentModel.DataAnnotations.Required]
    [System.Text.Json.Serialization.JsonRequired]
    public System.Collections.Generic.ICollection<ActorInstanceResponse> Actors { get; set; } = new System.Collections.ObjectModel.Collection<ActorInstanceResponse>();

    /// <summary>
    /// Total number of actors matching the filter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("total")]
    public int Total { get; set; } = default!;

}

/// <summary>
/// Request to inject a perception event into an actor's queue
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class InjectPerceptionRequest
{

    /// <summary>
    /// Target actor to inject perception into
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActorId { get; set; } = default!;

    /// <summary>
    /// Perception data to inject
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("perception")]
    [System.ComponentModel.DataAnnotations.Required]
    [System.Text.Json.Serialization.JsonRequired]
    public PerceptionData Perception { get; set; } = new PerceptionData();

}

/// <summary>
/// Data representing a perception event for an actor.
/// <br/>
/// <br/>Spatial context can be provided in two ways (hybrid approach):
/// <br/>1. Typed: Use the optional spatialContext field for structured spatial data
/// <br/>2. Schema-less: Use perceptionType="spatial" with data containing spatial info
/// <br/>
/// <br/>The typed approach is recommended when game server has structured spatial data.
/// <br/>The schema-less approach allows flexibility for game-specific spatial formats.
/// <br/>
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class PerceptionData
{

    /// <summary>
    /// Perception type. Common values: visual, auditory, tactile, olfactory,
    /// <br/>proprioceptive, spatial. Use "spatial" for schema-less spatial data in 'data' field.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("perceptionType")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string PerceptionType { get; set; } = default!;

    /// <summary>
    /// ID of the entity causing this perception
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("sourceId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string SourceId { get; set; } = default!;

    /// <summary>
    /// Type of source (character, npc, object, environment)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("sourceType")]
    public string? SourceType { get; set; } = default!;

    /// <summary>
    /// Perception-specific data. For perceptionType="spatial", this can contain
    /// <br/>game-specific spatial context in any format the game server defines.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("data")]
    public object? Data { get; set; } = default!;

    /// <summary>
    /// How urgent this perception is (0-1)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("urgency")]
    [System.ComponentModel.DataAnnotations.Range(0F, 1F)]
    public float Urgency { get; set; } = 0.5F;

    /// <summary>
    /// Optional typed spatial context from game server's local spatial state.
    /// <br/>Provides structured information about terrain, nearby objects, hazards, etc.
    /// <br/>Alternative to using perceptionType="spatial" with schema-less data.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("spatialContext")]
    public SpatialContext? SpatialContext { get; set; } = default!;

}

/// <summary>
/// Spatial context derived from game server's authoritative spatial state.
/// <br/>Included in perception events to give NPC actors awareness of their environment
/// <br/>without requiring direct map subscriptions.
/// <br/>
/// <br/>Note: additionalProperties=true allows game-specific extensions.
/// <br/>
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class SpatialContext
{

    /// <summary>
    /// Terrain type at character position (grass, stone, water, etc.)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("terrainType")]
    public string? TerrainType { get; set; } = default!;

    /// <summary>
    /// Elevation at character position
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("elevation")]
    public float? Elevation { get; set; } = default!;

    /// <summary>
    /// Objects within perception radius
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("nearbyObjects")]
    public System.Collections.Generic.ICollection<NearbyObject>? NearbyObjects { get; set; } = default!;

    /// <summary>
    /// Active hazards within detection range
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("hazardsInRange")]
    public System.Collections.Generic.ICollection<HazardInfo>? HazardsInRange { get; set; } = default!;

    /// <summary>
    /// Directions the character can move (for navigation awareness)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("pathableDirections")]
    public System.Collections.Generic.ICollection<string>? PathableDirections { get; set; } = default!;

    /// <summary>
    /// Whether cover is available within close range
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("coverNearby")]
    public bool? CoverNearby { get; set; } = default!;

    /// <summary>
    /// Whether character is currently indoors/under roof
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("indoors")]
    public bool? Indoors { get; set; } = default!;

    private System.Collections.Generic.IDictionary<string, object>? _additionalProperties;

    /// <summary>
    /// Gets or sets additional properties not defined in the schema.
    /// </summary>
    [System.Text.Json.Serialization.JsonExtensionData]
    public System.Collections.Generic.IDictionary<string, object>? AdditionalProperties
    {
        get => _additionalProperties;
        set { _additionalProperties = value; }
    }

}

/// <summary>
/// Information about a nearby object perceived by the character
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class NearbyObject
{

    /// <summary>
    /// Unique identifier of the object
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("objectId")]
    public System.Guid ObjectId { get; set; } = default!;

    /// <summary>
    /// Type of object (boulder_cluster, tree, building, etc.)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("objectType")]
    public string ObjectType { get; set; } = default!;

    /// <summary>
    /// Distance from character in game units
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("distance")]
    public float Distance { get; set; } = default!;

    /// <summary>
    /// Relative direction (north, south, east, west, above, below, etc.)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("direction")]
    public string Direction { get; set; } = default!;

    /// <summary>
    /// Optional absolute position
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("position")]
    public Position3D? Position { get; set; } = default!;

    private System.Collections.Generic.IDictionary<string, object>? _additionalProperties;

    /// <summary>
    /// Gets or sets additional properties not defined in the schema.
    /// </summary>
    [System.Text.Json.Serialization.JsonExtensionData]
    public System.Collections.Generic.IDictionary<string, object>? AdditionalProperties
    {
        get => _additionalProperties;
        set { _additionalProperties = value; }
    }

}

/// <summary>
/// Information about a hazard in range
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class HazardInfo
{

    /// <summary>
    /// Type of hazard (fire, poison, radiation, deep_water, etc.)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("hazardType")]
    public string HazardType { get; set; } = default!;

    /// <summary>
    /// Distance to hazard edge
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("distance")]
    public float Distance { get; set; } = default!;

    /// <summary>
    /// Hazard severity (0-1)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("severity")]
    [System.ComponentModel.DataAnnotations.Range(0F, 1F)]
    public float Severity { get; set; } = default!;

    /// <summary>
    /// Direction to hazard center
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("direction")]
    public string? Direction { get; set; } = default!;

    private System.Collections.Generic.IDictionary<string, object>? _additionalProperties;

    /// <summary>
    /// Gets or sets additional properties not defined in the schema.
    /// </summary>
    [System.Text.Json.Serialization.JsonExtensionData]
    public System.Collections.Generic.IDictionary<string, object>? AdditionalProperties
    {
        get => _additionalProperties;
        set { _additionalProperties = value; }
    }

}

/// <summary>
/// 3D position in world coordinates
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Position3D
{

    /// <summary>
    /// X coordinate
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("x")]
    public float X { get; set; } = default!;

    /// <summary>
    /// Y coordinate (typically vertical)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("y")]
    public float Y { get; set; } = default!;

    /// <summary>
    /// Z coordinate
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("z")]
    public float Z { get; set; } = default!;

}

/// <summary>
/// Response confirming perception injection
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class InjectPerceptionResponse
{

    /// <summary>
    /// Whether the perception was successfully queued
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("queued")]
    public bool Queued { get; set; } = default!;

    /// <summary>
    /// Current depth of the perception queue
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("queueDepth")]
    public int QueueDepth { get; set; } = default!;

}

/// <summary>
/// Query an actor for its available options. Options are maintained by the actor
/// <br/>in its state.memories.{queryType}_options and returned based on requested freshness.
/// <br/>
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class QueryOptionsRequest
{

    /// <summary>
    /// ID of the actor to query
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActorId { get; set; } = default!;

    /// <summary>
    /// Type of options to query
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("queryType")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
    public OptionsQueryType QueryType { get; set; } = default!;

    /// <summary>
    /// Requested freshness level. Defaults to 'cached'.
    /// <br/>- fresh: Inject context and wait for actor to recompute
    /// <br/>- cached: Return cached options if within maxAgeMs
    /// <br/>- stale_ok: Return whatever is cached, even if expired
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("freshness")]
    [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
    public OptionsFreshness Freshness { get; set; } = default!;

    /// <summary>
    /// Maximum age of cached options in milliseconds (for 'cached' freshness).
    /// <br/>Defaults to 5000ms. If cached options are older, behavior depends on
    /// <br/>freshness level.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("maxAgeMs")]
    [System.ComponentModel.DataAnnotations.Range(0, 60000)]
    public int? MaxAgeMs { get; set; } = default!;

    /// <summary>
    /// Optional context for the query. When provided with freshness='fresh',
    /// <br/>this context is injected as a perception to the actor, triggering
    /// <br/>context-sensitive option recomputation.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("context")]
    public OptionsQueryContext? Context { get; set; } = default!;

}

/// <summary>
/// Response containing the actor's available options
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class QueryOptionsResponse
{

    /// <summary>
    /// ID of the queried actor
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActorId { get; set; } = default!;

    /// <summary>
    /// Type of options returned
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("queryType")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
    public OptionsQueryType QueryType { get; set; } = default!;

    /// <summary>
    /// Available options for the queried type
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("options")]
    [System.ComponentModel.DataAnnotations.Required]
    [System.Text.Json.Serialization.JsonRequired]
    public System.Collections.Generic.ICollection<ActorOption> Options { get; set; } = new System.Collections.ObjectModel.Collection<ActorOption>();

    /// <summary>
    /// When these options were last computed by the actor
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("computedAt")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public System.DateTimeOffset ComputedAt { get; set; } = default!;

    /// <summary>
    /// Age of options in milliseconds (now - computedAt)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("ageMs")]
    public int AgeMs { get; set; } = default!;

    /// <summary>
    /// Character-specific context that influenced these options.
    /// <br/>Only present for character-based actors.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("characterContext")]
    public CharacterOptionContext? CharacterContext { get; set; } = default!;

}

/// <summary>
/// Type of options to query. Actors maintain options in state.memories.{type}_options.
/// <br/>Well-known types are defined; actors can also expose custom types.
/// <br/>
/// </summary>
#pragma warning disable CS1591 // Enum members cannot have XML documentation
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public enum OptionsQueryType
{

    [System.Runtime.Serialization.EnumMember(Value = @"combat")]
    Combat = 0,

    [System.Runtime.Serialization.EnumMember(Value = @"dialogue")]
    Dialogue = 1,

    [System.Runtime.Serialization.EnumMember(Value = @"exploration")]
    Exploration = 2,

    [System.Runtime.Serialization.EnumMember(Value = @"social")]
    Social = 3,

    [System.Runtime.Serialization.EnumMember(Value = @"custom")]
    Custom = 4,

}
#pragma warning restore CS1591

/// <summary>
/// Controls caching behavior for options queries
/// </summary>
#pragma warning disable CS1591 // Enum members cannot have XML documentation
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public enum OptionsFreshness
{

    [System.Runtime.Serialization.EnumMember(Value = @"fresh")]
    Fresh = 0,

    [System.Runtime.Serialization.EnumMember(Value = @"cached")]
    Cached = 1,

    [System.Runtime.Serialization.EnumMember(Value = @"stale_ok")]
    Stale_ok = 2,

}
#pragma warning restore CS1591

/// <summary>
/// A single option available to the actor. The standardized fields enable
/// <br/>Event Brain to reason about options; additional fields allow actor-specific data.
/// <br/>
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ActorOption
{

    /// <summary>
    /// Unique identifier for this action within the option type.
    /// <br/>Examples: "sword_slash", "greet_friendly", "climb_wall"
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actionId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActionId { get; set; } = default!;

    /// <summary>
    /// How much the actor prefers this option (0-1), based on personality,
    /// <br/>combat preferences, current state, etc. Higher = more preferred.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("preference")]
    [System.ComponentModel.DataAnnotations.Range(0F, 1F)]
    public float Preference { get; set; } = default!;

    /// <summary>
    /// Estimated risk of this action (0=safe, 1=very risky)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("risk")]
    [System.ComponentModel.DataAnnotations.Range(0F, 1F)]
    public float? Risk { get; set; } = default!;

    /// <summary>
    /// Whether this option is currently available (requirements met)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("available")]
    public bool Available { get; set; } = default!;

    /// <summary>
    /// Requirements that must be met for this option
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("requirements")]
    public System.Collections.Generic.ICollection<string>? Requirements { get; set; } = default!;

    /// <summary>
    /// Milliseconds until this option becomes available again (if on cooldown)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("cooldownMs")]
    public int? CooldownMs { get; set; } = default!;

    /// <summary>
    /// Tags for categorization (e.g., ["melee", "aggressive", "loud"])
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("tags")]
    public System.Collections.Generic.ICollection<string>? Tags { get; set; } = default!;

    private System.Collections.Generic.IDictionary<string, object>? _additionalProperties;

    /// <summary>
    /// Gets or sets additional properties not defined in the schema.
    /// </summary>
    [System.Text.Json.Serialization.JsonExtensionData]
    public System.Collections.Generic.IDictionary<string, object>? AdditionalProperties
    {
        get => _additionalProperties;
        set { _additionalProperties = value; }
    }

}

/// <summary>
/// Context provided with a fresh query. Injected as a perception to the actor
/// <br/>to trigger context-sensitive option recomputation.
/// <br/>
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class OptionsQueryContext
{

    /// <summary>
    /// Current combat state (approaching, engaged, retreating, etc.)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("combatState")]
    public string? CombatState { get; set; } = default!;

    /// <summary>
    /// IDs of opponents in the current encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("opponentIds")]
    public System.Collections.Generic.ICollection<string>? OpponentIds { get; set; } = default!;

    /// <summary>
    /// IDs of allies in the current encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("allyIds")]
    public System.Collections.Generic.ICollection<string>? AllyIds { get; set; } = default!;

    /// <summary>
    /// Environment tags (indoor, elevated, destructibles, narrow, etc.)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("environmentTags")]
    public System.Collections.Generic.ICollection<string>? EnvironmentTags { get; set; } = default!;

    /// <summary>
    /// How urgent is this query (affects option prioritization)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("urgency")]
    [System.ComponentModel.DataAnnotations.Range(0F, 1F)]
    public float? Urgency { get; set; } = default!;

    /// <summary>
    /// Actor-specific context data
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("customContext")]
    public object? CustomContext { get; set; } = default!;

    private System.Collections.Generic.IDictionary<string, object>? _additionalProperties;

    /// <summary>
    /// Gets or sets additional properties not defined in the schema.
    /// </summary>
    [System.Text.Json.Serialization.JsonExtensionData]
    public System.Collections.Generic.IDictionary<string, object>? AdditionalProperties
    {
        get => _additionalProperties;
        set { _additionalProperties = value; }
    }

}

/// <summary>
/// Character-specific context that influenced option computation
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class CharacterOptionContext
{

    /// <summary>
    /// Character's combat style (aggressive, defensive, balanced, etc.)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("combatStyle")]
    public string? CombatStyle { get; set; } = default!;

    /// <summary>
    /// Character's risk tolerance (0=cautious, 1=reckless)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("riskTolerance")]
    [System.ComponentModel.DataAnnotations.Range(0F, 1F)]
    public float? RiskTolerance { get; set; } = default!;

    /// <summary>
    /// Whether character prioritizes ally protection
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("protectAllies")]
    public bool? ProtectAllies { get; set; } = default!;

    /// <summary>
    /// Character's current primary goal
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("currentGoal")]
    public string? CurrentGoal { get; set; } = default!;

    /// <summary>
    /// Character's current dominant emotion
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("emotionalState")]
    public string? EmotionalState { get; set; } = default!;

}

/// <summary>
/// Instruction sent to a participant actor by Event Brain to execute a choreographed sequence.
/// <br/>Delivered via emit_perception with perception_type "choreography_instruction".
/// <br/>
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ChoreographyInstruction
{

    /// <summary>
    /// ID of the coordinated encounter this instruction belongs to
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("encounterId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string EncounterId { get; set; } = default!;

    /// <summary>
    /// Unique ID for this sequence within the choreography.
    /// <br/>Used for acknowledgment and sync point coordination.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("sequenceId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string SequenceId { get; set; } = default!;

    /// <summary>
    /// Ordered list of actions for the participant to execute.
    /// <br/>Multiple actions allow for combos or reaction sequences.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actions")]
    [System.ComponentModel.DataAnnotations.Required]
    [System.Text.Json.Serialization.JsonRequired]
    public System.Collections.Generic.ICollection<ChoreographyAction> Actions { get; set; } = new System.Collections.ObjectModel.Collection<ChoreographyAction>();

    /// <summary>
    /// When and how to start executing this sequence
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("timing")]
    [System.ComponentModel.DataAnnotations.Required]
    [System.Text.Json.Serialization.JsonRequired]
    public ChoreographyTiming Timing { get; set; } = new ChoreographyTiming();

    /// <summary>
    /// How strongly to prefer this choreography over actor's own choices.
    /// <br/>Higher priority may interrupt current actions.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("priority")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
    public ChoreographyPriority Priority { get; set; } = default!;

    /// <summary>
    /// Whether participant can interrupt the sequence if a better opportunity arises.
    /// <br/>If false, participant should complete the sequence unless impossible.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("canInterrupt")]
    public bool? CanInterrupt { get; set; } = default!;

    /// <summary>
    /// Expected outcome of this sequence (e.g., "hit", "miss", "block").
    /// <br/>Used for coordinating reactions with other participants.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("expectedOutcome")]
    public string? ExpectedOutcome { get; set; } = default!;

    /// <summary>
    /// Event to emit when sequence completes (e.g., "sync_point.attack_landed").
    /// <br/>Other participants may be waiting on this.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("onComplete")]
    public string? OnComplete { get; set; } = default!;

}

/// <summary>
/// A single action within a choreographed sequence.
/// <br/>ActionId should match one from the participant's options.
/// <br/>
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ChoreographyAction
{

    /// <summary>
    /// Action identifier matching one from the actor's options.
    /// <br/>Examples: "sword_slash", "dodge_roll", "taunt"
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actionId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActionId { get; set; } = default!;

    /// <summary>
    /// Target actor ID for the action, if applicable.
    /// <br/>Null for untargeted actions like movement or taunts.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("targetId")]
    public string? TargetId { get; set; } = default!;

    /// <summary>
    /// Target position for movement or placement actions
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("position")]
    public ChoreographyPosition? Position { get; set; } = default!;

    /// <summary>
    /// Expected duration in milliseconds.
    /// <br/>Used for timing subsequent actions and sync points.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("durationMs")]
    [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
    public int? DurationMs { get; set; } = default!;

    /// <summary>
    /// Stylistic modifier for the action (e.g., "dramatic", "desperate", "confident").
    /// <br/>Actors may adjust animation/presentation based on style.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("style")]
    public string? Style { get; set; } = default!;

    /// <summary>
    /// Delay before starting this action (relative to previous action completion).
    /// <br/>Allows precise timing within sequences.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("delayMs")]
    [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
    public int? DelayMs { get; set; } = default!;

    private System.Collections.Generic.IDictionary<string, object>? _additionalProperties;

    /// <summary>
    /// Gets or sets additional properties not defined in the schema.
    /// </summary>
    [System.Text.Json.Serialization.JsonExtensionData]
    public System.Collections.Generic.IDictionary<string, object>? AdditionalProperties
    {
        get => _additionalProperties;
        set { _additionalProperties = value; }
    }

}

/// <summary>
/// Controls when a choreographed sequence should begin execution
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ChoreographyTiming
{

    /// <summary>
    /// When to start executing the sequence.
    /// <br/>- immediate: Start as soon as instruction received
    /// <br/>- after_previous: Start after current action completes
    /// <br/>- sync_point: Wait for specified sync point event
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("startAt")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
    public ChoreographyStartCondition StartAt { get; set; } = default!;

    /// <summary>
    /// Sync point to wait for (required when startAt=sync_point).
    /// <br/>Examples: "attack_landed", "guard_raised", "combo_ready"
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("syncPointId")]
    public string? SyncPointId { get; set; } = default!;

    /// <summary>
    /// Maximum time to wait for sync point in milliseconds.
    /// <br/>If exceeded, sequence may start anyway or be cancelled.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("maxWaitMs")]
    [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
    public int? MaxWaitMs { get; set; } = default!;

    /// <summary>
    /// Time window during which the action can start.
    /// <br/>Allows for natural timing variation.
    /// <br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("windowMs")]
    [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
    public int? WindowMs { get; set; } = default!;

}

/// <summary>
/// How strongly the actor should prefer the choreographed action over their own choices.
/// <br/>- low: Suggestion; actor may ignore if they prefer something else
/// <br/>- normal: Standard choreography; follow unless clearly suboptimal
/// <br/>- high: Important sequence; should follow even if not preferred
/// <br/>- override: Critical moment; must follow unless physically impossible
/// <br/>
/// </summary>
#pragma warning disable CS1591 // Enum members cannot have XML documentation
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public enum ChoreographyPriority
{

    [System.Runtime.Serialization.EnumMember(Value = @"low")]
    Low = 0,

    [System.Runtime.Serialization.EnumMember(Value = @"normal")]
    Normal = 1,

    [System.Runtime.Serialization.EnumMember(Value = @"high")]
    High = 2,

    [System.Runtime.Serialization.EnumMember(Value = @"override")]
    Override = 3,

}
#pragma warning restore CS1591

/// <summary>
/// When to begin executing a choreographed sequence
/// </summary>
#pragma warning disable CS1591 // Enum members cannot have XML documentation
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public enum ChoreographyStartCondition
{

    [System.Runtime.Serialization.EnumMember(Value = @"immediate")]
    Immediate = 0,

    [System.Runtime.Serialization.EnumMember(Value = @"after_previous")]
    After_previous = 1,

    [System.Runtime.Serialization.EnumMember(Value = @"sync_point")]
    Sync_point = 2,

}
#pragma warning restore CS1591

/// <summary>
/// 3D position for choreography movement and placement actions
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ChoreographyPosition
{

    /// <summary>
    /// X coordinate
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("x")]
    public float X { get; set; } = default!;

    /// <summary>
    /// Y coordinate (vertical)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("y")]
    public float Y { get; set; } = default!;

    /// <summary>
    /// Z coordinate
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("z")]
    public float Z { get; set; } = default!;

}

/// <summary>
/// Request to start an encounter managed by an Event Brain actor
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class StartEncounterRequest
{

    /// <summary>
    /// ID of the Event Brain actor that will manage this encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActorId { get; set; } = default!;

    /// <summary>
    /// Unique identifier for this encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("encounterId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string EncounterId { get; set; } = default!;

    /// <summary>
    /// Type of encounter (e.g., "combat", "conversation", "choreography")
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("encounterType")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string EncounterType { get; set; } = default!;

    /// <summary>
    /// Character IDs of participants in the encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("participants")]
    [System.ComponentModel.DataAnnotations.Required]
    [System.Text.Json.Serialization.JsonRequired]
    public System.Collections.Generic.ICollection<System.Guid> Participants { get; set; } = new System.Collections.ObjectModel.Collection<System.Guid>();

    /// <summary>
    /// Optional initial data for the encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("initialData")]
    public object? InitialData { get; set; } = default!;

}

/// <summary>
/// Response after starting an encounter
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class StartEncounterResponse
{

    /// <summary>
    /// Whether the encounter was started successfully
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("success")]
    public bool Success { get; set; } = default!;

    /// <summary>
    /// ID of the actor managing the encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActorId { get; set; } = default!;

    /// <summary>
    /// ID of the started encounter (null if failed)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("encounterId")]
    public string? EncounterId { get; set; } = default!;

    /// <summary>
    /// Error message if the encounter could not be started
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("error")]
    public string? Error { get; set; } = default!;

}

/// <summary>
/// Request to update the phase of an active encounter
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class UpdateEncounterPhaseRequest
{

    /// <summary>
    /// ID of the Event Brain actor managing the encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActorId { get; set; } = default!;

    /// <summary>
    /// New phase name for the encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("phase")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string Phase { get; set; } = default!;

}

/// <summary>
/// Response after updating encounter phase
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class UpdateEncounterPhaseResponse
{

    /// <summary>
    /// Whether the phase was updated successfully
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("success")]
    public bool Success { get; set; } = default!;

    /// <summary>
    /// ID of the actor managing the encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActorId { get; set; } = default!;

    /// <summary>
    /// Previous phase name (null if no encounter was active)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("previousPhase")]
    public string? PreviousPhase { get; set; } = default!;

    /// <summary>
    /// Current phase name after update
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("currentPhase")]
    public string? CurrentPhase { get; set; } = default!;

}

/// <summary>
/// Request to end an active encounter
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class EndEncounterRequest
{

    /// <summary>
    /// ID of the Event Brain actor managing the encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActorId { get; set; } = default!;

}

/// <summary>
/// Response after ending an encounter
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class EndEncounterResponse
{

    /// <summary>
    /// Whether an encounter was ended
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("success")]
    public bool Success { get; set; } = default!;

    /// <summary>
    /// ID of the actor
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActorId { get; set; } = default!;

    /// <summary>
    /// ID of the ended encounter (null if no encounter was active)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("encounterId")]
    public string? EncounterId { get; set; } = default!;

    /// <summary>
    /// Duration of the encounter in milliseconds
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("durationMs")]
    public int? DurationMs { get; set; } = default!;

}

/// <summary>
/// Request to get the current encounter state for an actor
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class GetEncounterRequest
{

    /// <summary>
    /// ID of the Event Brain actor to query
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActorId { get; set; } = default!;

}

/// <summary>
/// Response containing the current encounter state
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class GetEncounterResponse
{

    /// <summary>
    /// ID of the queried actor
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("actorId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string ActorId { get; set; } = default!;

    /// <summary>
    /// Whether the actor is currently managing an encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("hasActiveEncounter")]
    public bool HasActiveEncounter { get; set; } = default!;

    /// <summary>
    /// Current encounter state (null if no active encounter)
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("encounter")]
    public EncounterState? Encounter { get; set; } = default!;

}

/// <summary>
/// State of an active encounter being managed by an Event Brain actor
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class EncounterState
{

    /// <summary>
    /// Unique identifier for this encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("encounterId")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string EncounterId { get; set; } = default!;

    /// <summary>
    /// Type of encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("encounterType")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string EncounterType { get; set; } = default!;

    /// <summary>
    /// Character IDs participating in the encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("participants")]
    [System.ComponentModel.DataAnnotations.Required]
    [System.Text.Json.Serialization.JsonRequired]
    public System.Collections.Generic.ICollection<System.Guid> Participants { get; set; } = new System.Collections.ObjectModel.Collection<System.Guid>();

    /// <summary>
    /// Current phase of the encounter
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("phase")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public string Phase { get; set; } = default!;

    /// <summary>
    /// When the encounter started
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("startedAt")]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    [System.Text.Json.Serialization.JsonRequired]
    public System.DateTimeOffset StartedAt { get; set; } = default!;

    /// <summary>
    /// Custom encounter-specific data
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName("data")]
    public object? Data { get; set; } = default!;

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
