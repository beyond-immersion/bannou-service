//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#nullable enable

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8600 // Disable "CS8600 Converting null literal or possible null value to non-nullable type"
#pragma warning disable 8602 // Disable "CS8602 Dereference of a possibly null reference"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace BeyondImmersion.BannouService.Connect;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IConnectController : BeyondImmersion.BannouService.Controllers.IDaprController
{

    /// <summary>
    /// Internal API proxy for stateless requests
    /// </summary>

    /// <remarks>
    /// Stateless HTTP proxy for internal requests that don't require persistent sessions.
    /// <br/>Applies permission validation and rate limiting based on agent role and context.
    /// <br/>Perfect for AI agents making one-off API calls or bulk operations.
    /// </remarks>

    /// <returns>Request proxied successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InternalProxyResponse>> ProxyInternalRequestAsync(InternalProxyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get client capability manifest (GUID → API mappings)
    /// </summary>

    /// <remarks>
    /// Returns the capability manifest for the authenticated client's session.
    /// <br/>Maps client-salted GUIDs to available API endpoints based on the client's
    /// <br/>current permissions and session state.
    /// <br/>
    /// <br/>**Security**: Each client receives unique GUIDs for the same API endpoints.
    /// <br/>This prevents cross-session exploitation and enables per-client rate limiting.
    /// <br/>
    /// <br/>**Dynamic Updates**: Capabilities may change during a session when:
    /// <br/>- Role changes occur (admin promotion, etc.)
    /// <br/>- Subscription status changes
    /// <br/>- Session state transitions
    /// <br/>
    /// <br/>Clients should listen for capability update events via WebSocket to stay current.
    /// </remarks>

    /// <returns>Client capabilities retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ClientCapabilitiesResponse>> GetClientCapabilitiesAsync(GetClientCapabilitiesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Establish WebSocket connection
    /// </summary>

    /// <remarks>
    /// Initiates a WebSocket connection for real-time communication.
    /// <br/>Requires JWT authentication via Authorization header.
    /// <br/>
    /// <br/>**Connection Flow:**
    /// <br/>1. Send HTTP GET request with `Connection: Upgrade` and `Upgrade: websocket` headers
    /// <br/>2. Include `Authorization: Bearer &lt;jwt_token&gt;` header for authentication
    /// <br/>3. Server validates JWT and extracts user claims (roles, scopes, services)
    /// <br/>4. Connection upgrades to WebSocket protocol
    /// <br/>5. Client can send binary messages using the custom protocol
    /// <br/>
    /// <br/>**Reconnection:**
    /// <br/>For existing sessions, use `Authorization: Reconnect &lt;reconnect_token&gt;` instead.
    /// </remarks>

    /// <param name="connection">Must be "Upgrade" to initiate WebSocket connection</param>

    /// <param name="upgrade">Must be "websocket" to specify protocol upgrade</param>

    /// <param name="authorization">JWT Bearer token for new connections: "Bearer &lt;jwt_token&gt;"
    /// <br/>Reconnect token for existing sessions: "Reconnect &lt;reconnect_token&gt;"</param>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> ConnectWebSocketAsync(Connection connection, Upgrade upgrade, string authorization, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Establish WebSocket connection (POST variant)
    /// </summary>

    /// <remarks>
    /// Alternative POST method for establishing WebSocket connections.
    /// <br/>Functionally identical to the GET method but supports clients that
    /// <br/>require POST for WebSocket upgrades.
    /// </remarks>



    /// <param name="body">Optional connection parameters</param>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> ConnectWebSocketPostAsync(Connection2 connection, Upgrade2 upgrade, string authorization, ConnectRequest? body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public abstract class ConnectControllerBase : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IConnectService _implementation;

    public ConnectControllerBase(IConnectService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.Created => Created("", result),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.Created => result != null ? Created("", result) : Created("", null),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Internal API proxy for stateless requests
    /// </summary>
    /// <remarks>
    /// Stateless HTTP proxy for internal requests that don't require persistent sessions.
    /// <br/>Applies permission validation and rate limiting based on agent role and context.
    /// <br/>Perfect for AI agents making one-off API calls or bulk operations.
    /// </remarks>
    /// <returns>Request proxied successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("internal/proxy")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InternalProxyResponse>> ProxyInternalRequest([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] InternalProxyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ProxyInternalRequestAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get client capability manifest (GUID → API mappings)
    /// </summary>
    /// <remarks>
    /// Returns the capability manifest for the authenticated client's session.
    /// <br/>Maps client-salted GUIDs to available API endpoints based on the client's
    /// <br/>current permissions and session state.
    /// <br/>
    /// <br/>**Security**: Each client receives unique GUIDs for the same API endpoints.
    /// <br/>This prevents cross-session exploitation and enables per-client rate limiting.
    /// <br/>
    /// <br/>**Dynamic Updates**: Capabilities may change during a session when:
    /// <br/>- Role changes occur (admin promotion, etc.)
    /// <br/>- Subscription status changes
    /// <br/>- Session state transitions
    /// <br/>
    /// <br/>Clients should listen for capability update events via WebSocket to stay current.
    /// </remarks>
    /// <returns>Client capabilities retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("client-capabilities")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ClientCapabilitiesResponse>> GetClientCapabilities([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetClientCapabilitiesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetClientCapabilitiesAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Establish WebSocket connection
    /// </summary>
    /// <remarks>
    /// Initiates a WebSocket connection for real-time communication.
    /// <br/>Requires JWT authentication via Authorization header.
    /// <br/>
    /// <br/>**Connection Flow:**
    /// <br/>1. Send HTTP GET request with `Connection: Upgrade` and `Upgrade: websocket` headers
    /// <br/>2. Include `Authorization: Bearer &lt;jwt_token&gt;` header for authentication
    /// <br/>3. Server validates JWT and extracts user claims (roles, scopes, services)
    /// <br/>4. Connection upgrades to WebSocket protocol
    /// <br/>5. Client can send binary messages using the custom protocol
    /// <br/>
    /// <br/>**Reconnection:**
    /// <br/>For existing sessions, use `Authorization: Reconnect &lt;reconnect_token&gt;` instead.
    /// </remarks>
    /// <param name="connection">Must be "Upgrade" to initiate WebSocket connection</param>
    /// <param name="upgrade">Must be "websocket" to specify protocol upgrade</param>
    /// <param name="authorization">JWT Bearer token for new connections: "Bearer &lt;jwt_token&gt;"
    /// <br/>Reconnect token for existing sessions: "Reconnect &lt;reconnect_token&gt;"</param>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("connect")]

    public abstract System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> ConnectWebSocket([Microsoft.AspNetCore.Mvc.FromHeader] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] Connection connection, [Microsoft.AspNetCore.Mvc.FromHeader] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] Upgrade upgrade, [Microsoft.AspNetCore.Mvc.FromHeader] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string authorization, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Establish WebSocket connection (POST variant)
    /// </summary>
    /// <remarks>
    /// Alternative POST method for establishing WebSocket connections.
    /// <br/>Functionally identical to the GET method but supports clients that
    /// <br/>require POST for WebSocket upgrades.
    /// </remarks>
    /// <param name="body">Optional connection parameters</param>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("connect")]

    public abstract System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> ConnectWebSocketPost([Microsoft.AspNetCore.Mvc.FromHeader] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] Connection2 connection, [Microsoft.AspNetCore.Mvc.FromHeader] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] Upgrade2 upgrade, [Microsoft.AspNetCore.Mvc.FromHeader] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string authorization, [Microsoft.AspNetCore.Mvc.FromBody] ConnectRequest? body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));


    #region Meta Endpoints for ProxyInternalRequest

    private static readonly string _ProxyInternalRequest_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/InternalProxyRequest",
  "$defs": {
    "InternalProxyRequest": {
      "type": "object",
      "required": [
        "sessionId",
        "targetService",
        "targetEndpoint",
        "method"
      ],
      "properties": {
        "sessionId": {
          "type": "string",
          "description": "WebSocket session ID making the request"
        },
        "targetService": {
          "type": "string",
          "description": "Target service name (e.g., \"accounts\", \"auth\", \"behavior\")"
        },
        "targetEndpoint": {
          "type": "string",
          "description": "Target API endpoint path (e.g., \"/accounts/{id}\")"
        },
        "method": {
          "type": "string",
          "enum": [
            "GET",
            "POST",
            "PUT",
            "DELETE",
            "PATCH"
          ],
          "description": "HTTP method for the target endpoint"
        },
        "headers": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional headers to forward to the service"
        },
        "body": {
          "type": "object",
          "additionalProperties": true,
          "description": "Request body to forward to target service"
        },
        "pathParameters": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Path parameters for the endpoint"
        },
        "queryParameters": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Query string parameters for the endpoint"
        }
      }
    }
  }
}
""";

    private static readonly string _ProxyInternalRequest_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/InternalProxyResponse",
  "$defs": {
    "InternalProxyResponse": {
      "type": "object",
      "required": [
        "success",
        "statusCode"
      ],
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Whether the proxy request was successful"
        },
        "statusCode": {
          "type": "integer",
          "description": "HTTP status code from the target service"
        },
        "response": {
          "type": "string",
          "description": "JSON response from the target service (as string)"
        },
        "headers": {
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "description": "Response headers from the target service"
        },
        "error": {
          "type": "string",
          "description": "Error message if the request failed"
        },
        "executionTime": {
          "type": "integer",
          "description": "Request execution time in milliseconds"
        }
      }
    }
  }
}
""";

    private static readonly string _ProxyInternalRequest_Info = """
{
  "summary": "Internal API proxy for stateless requests",
  "description": "Stateless HTTP proxy for internal requests that don't require persistent sessions.\nApplies permission validation and rate limiting based on agent role and context.\nPerfect for AI agents making one-off API calls or bulk operations.\n",
  "tags": [
    "Internal Proxy"
  ],
  "deprecated": false,
  "operationId": "proxyInternalRequest"
}
""";

    /// <summary>Returns endpoint information for ProxyInternalRequest</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("internal/proxy/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ProxyInternalRequest_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Connect",
            "Post",
            "internal/proxy",
            _ProxyInternalRequest_Info));

    /// <summary>Returns request schema for ProxyInternalRequest</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("internal/proxy/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ProxyInternalRequest_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Connect",
            "Post",
            "internal/proxy",
            "request-schema",
            _ProxyInternalRequest_RequestSchema));

    /// <summary>Returns response schema for ProxyInternalRequest</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("internal/proxy/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ProxyInternalRequest_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Connect",
            "Post",
            "internal/proxy",
            "response-schema",
            _ProxyInternalRequest_ResponseSchema));

    /// <summary>Returns full schema for ProxyInternalRequest</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("internal/proxy/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ProxyInternalRequest_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Connect",
            "Post",
            "internal/proxy",
            _ProxyInternalRequest_Info,
            _ProxyInternalRequest_RequestSchema,
            _ProxyInternalRequest_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetClientCapabilities

    private static readonly string _GetClientCapabilities_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetClientCapabilitiesRequest",
  "$defs": {
    "GetClientCapabilitiesRequest": {
      "type": "object",
      "description": "Request to get client capability manifest (empty body allowed)",
      "properties": {
        "serviceFilter": {
          "type": "string",
          "description": "Optional filter by service name prefix",
          "nullable": true
        },
        "includeMetadata": {
          "type": "boolean",
          "description": "Include additional metadata about each capability",
          "default": false
        }
      }
    }
  }
}
""";

    private static readonly string _GetClientCapabilities_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ClientCapabilitiesResponse",
  "$defs": {
    "ClientCapabilitiesResponse": {
      "type": "object",
      "required": [
        "sessionId",
        "capabilities",
        "version",
        "generatedAt"
      ],
      "properties": {
        "sessionId": {
          "type": "string",
          "description": "Session ID this capability manifest belongs to"
        },
        "capabilities": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ClientCapability"
          },
          "description": "Available API capabilities for this client"
        },
        "shortcuts": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ClientShortcut"
          },
          "description": "Pre-bound API calls available for this session.\nShortcuts are invoked like normal capabilities but Connect injects\ na pre-bound payload instead of using the client's payload.\n",
          "nullable": true
        },
        "version": {
          "type": "integer",
          "description": "Capability manifest version (increments on changes)"
        },
        "generatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "When this capability manifest was generated"
        },
        "expiresAt": {
          "type": "string",
          "format": "date-time",
          "description": "When these capabilities expire and need refresh",
          "nullable": true
        }
      }
    },
    "ClientCapability": {
      "type": "object",
      "required": [
        "guid",
        "service",
        "endpoint",
        "method"
      ],
      "properties": {
        "guid": {
          "type": "string",
          "format": "uuid",
          "description": "Client-salted GUID for this API endpoint (unique per session)"
        },
        "service": {
          "type": "string",
          "description": "Service name (e.g., \"accounts\", \"auth\")"
        },
        "endpoint": {
          "type": "string",
          "description": "API endpoint path (e.g., \"/accounts/create\")"
        },
        "method": {
          "type": "string",
          "enum": [
            "GET",
            "POST",
            "PUT",
            "DELETE",
            "PATCH"
          ],
          "description": "HTTP method for this endpoint"
        },
        "description": {
          "type": "string",
          "description": "Human-readable description of this capability",
          "nullable": true
        },
        "channel": {
          "type": "integer",
          "format": "uint16",
          "description": "Preferred WebSocket channel for this capability",
          "default": 0
        }
      }
    },
    "ClientShortcut": {
      "type": "object",
      "description": "Session shortcut information sent to clients in the capability manifest.\nShortcuts appear as invocable capabilities but Connect injects a pre-bound\npayload when the shortcut GUID is used, replacing any client-provided payload.\n",
      "required": [
        "guid",
        "targetService",
        "targetEndpoint",
        "name"
      ],
      "properties": {
        "guid": {
          "type": "string",
          "format": "uuid",
          "description": "GUID to use in WebSocket message header when invoking this shortcut.\nUses UUID version 7 bits to distinguish from regular service GUIDs (version 5).\n"
        },
        "targetService": {
          "type": "string",
          "description": "The service this shortcut invokes (for client display purposes)."
        },
        "targetEndpoint": {
          "type": "string",
          "description": "The endpoint this shortcut invokes (for client display purposes)."
        },
        "name": {
          "type": "string",
          "description": "Machine-readable shortcut identifier (e.g., \"get_my_stats\", \"join_game\")."
        },
        "description": {
          "type": "string",
          "description": "Human-readable description of what this shortcut does.",
          "nullable": true
        },
        "displayName": {
          "type": "string",
          "description": "User-friendly name for display in client UIs.",
          "nullable": true
        },
        "sourceService": {
          "type": "string",
          "description": "The service that created this shortcut.",
          "nullable": true
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Categorization tags for client-side organization.",
          "nullable": true
        },
        "expiresAt": {
          "type": "string",
          "format": "date-time",
          "description": "When this shortcut expires (if time-limited).",
          "nullable": true
        }
      }
    }
  }
}
""";

    private static readonly string _GetClientCapabilities_Info = """
{
  "summary": "Get client capability manifest (GUID \u2192 API mappings)",
  "description": "Returns the capability manifest for the authenticated client's session.\nMaps client-salted GUIDs to available API endpoints based on the client's\ncurrent permissions and session state.\n\n**Security**: Each client receives unique GUIDs for the same API endpoints.\nThis prevents cross-session exploitation and enables per-client rate limiting.\ n\n**Dynamic Updates**: Capabilities may change during a session when:\n- Role changes occur (admin promotion, etc.)\ n- Subscription status changes\n- Session state transitions\n\nClients should listen for capability update events via WebSocket to stay current.\n",
  "tags": [
    "Client Capabilities"
  ],
  "deprecated": false,
  "operationId": "getClientCapabilities"
}
""";

    /// <summary>Returns endpoint information for GetClientCapabilities</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("client-capabilities/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetClientCapabilities_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Connect",
            "Post",
            "client-capabilities",
            _GetClientCapabilities_Info));

    /// <summary>Returns request schema for GetClientCapabilities</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("client-capabilities/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetClientCapabilities_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Connect",
            "Post",
            "client-capabilities",
            "request-schema",
            _GetClientCapabilities_RequestSchema));

    /// <summary>Returns response schema for GetClientCapabilities</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("client-capabilities/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetClientCapabilities_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Connect",
            "Post",
            "client-capabilities",
            "response-schema",
            _GetClientCapabilities_ResponseSchema));

    /// <summary>Returns full schema for GetClientCapabilities</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("client-capabilities/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetClientCapabilities_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Connect",
            "Post",
            "client-capabilities",
            _GetClientCapabilities_Info,
            _GetClientCapabilities_RequestSchema,
            _GetClientCapabilities_ResponseSchema));

    #endregion

    #region Meta Endpoints for ConnectWebSocket

    private static readonly string _ConnectWebSocket_RequestSchema = """
{}
""";

    private static readonly string _ConnectWebSocket_ResponseSchema = """
{}
""";

    private static readonly string _ConnectWebSocket_Info = """
{
  "summary": "Establish WebSocket connection",
  "description": "Initiates a WebSocket connection for real-time communication.\nRequires JWT authentication via Authorization header.\n\n**Connection Flow:**\n1. Send HTTP GET request with `Connection: Upgrade` and `Upgrade: websocket` headers\n2. Include `Authorization: Bearer <jwt_token>` header for authentication\n3. Server validates JWT and extracts user claims (roles, scopes, services)\ n4. Connection upgrades to WebSocket protocol\n5. Client can send binary messages using the custom protocol\n\n**Reconnection:**\nFor existing sessions, use `Authorization: Reconnect <reconnect_token>` instead.\n",
  "tags": [
    "WebSocket Connection"
  ],
  "deprecated": false,
  "operationId": "ConnectWebSocket"
}
""";

    /// <summary>Returns endpoint information for ConnectWebSocket</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("connect/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ConnectWebSocket_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Connect",
            "Get",
            "connect",
            _ConnectWebSocket_Info));

    /// <summary>Returns request schema for ConnectWebSocket</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("connect/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ConnectWebSocket_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Connect",
            "Get",
            "connect",
            "request-schema",
            _ConnectWebSocket_RequestSchema));

    /// <summary>Returns response schema for ConnectWebSocket</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("connect/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ConnectWebSocket_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Connect",
            "Get",
            "connect",
            "response-schema",
            _ConnectWebSocket_ResponseSchema));

    /// <summary>Returns full schema for ConnectWebSocket</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("connect/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ConnectWebSocket_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Connect",
            "Get",
            "connect",
            _ConnectWebSocket_Info,
            _ConnectWebSocket_RequestSchema,
            _ConnectWebSocket_ResponseSchema));

    #endregion

    #region Meta Endpoints for ConnectWebSocketPost

    private static readonly string _ConnectWebSocketPost_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ConnectRequest",
  "$defs": {
    "ConnectRequest": {
      "type": "object",
      "description": "Request model for WebSocket connection establishment.\nCurrently contains no specific fields but extends the base ApiRequest.\n",
      "properties": {},
      "additionalProperties": false
    }
  }
}
""";

    private static readonly string _ConnectWebSocketPost_ResponseSchema = """
{}
""";

    private static readonly string _ConnectWebSocketPost_Info = """
{
  "summary": "Establish WebSocket connection (POST variant)",
  "description": "Alternative POST method for establishing WebSocket connections.\nFunctionally identical to the GET method but supports clients that\nrequire POST for WebSocket upgrades.\n",
  "tags": [
    "WebSocket Connection"
  ],
  "deprecated": false,
  "operationId": "ConnectWebSocketPost"
}
""";

    /// <summary>Returns endpoint information for ConnectWebSocketPost</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("connect/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ConnectWebSocketPost_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Connect",
            "Post",
            "connect",
            _ConnectWebSocketPost_Info));

    /// <summary>Returns request schema for ConnectWebSocketPost</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("connect/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ConnectWebSocketPost_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Connect",
            "Post",
            "connect",
            "request-schema",
            _ConnectWebSocketPost_RequestSchema));

    /// <summary>Returns response schema for ConnectWebSocketPost</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("connect/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ConnectWebSocketPost_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Connect",
            "Post",
            "connect",
            "response-schema",
            _ConnectWebSocketPost_ResponseSchema));

    /// <summary>Returns full schema for ConnectWebSocketPost</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("connect/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ConnectWebSocketPost_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Connect",
            "Post",
            "connect",
            _ConnectWebSocketPost_Info,
            _ConnectWebSocketPost_RequestSchema,
            _ConnectWebSocketPost_ResponseSchema));

    #endregion

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
