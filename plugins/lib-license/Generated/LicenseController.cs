//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     RELATED FILES:
//     - Request/Response models: bannou-service/Generated/Models/{Service}Models.cs
//     - Event models: bannou-service/Generated/Events/{Service}EventsModels.cs
//     - Lifecycle events: bannou-service/Generated/Events/{Service}LifecycleEvents.cs
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.License;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface ILicenseController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Create a new board template
    /// </summary>

    /// <remarks>
    /// Create a board template with grid dimensions, starting nodes, adjacency mode,
    /// <br/>and a reference to the contract template that controls unlock behavior.
    /// <br/>Board templates are scoped to a game service.
    /// </remarks>

    /// <returns>Board template created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardTemplateResponse>> CreateBoardTemplateAsync(CreateBoardTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get a board template by ID
    /// </summary>

    /// <remarks>
    /// Retrieves a board template by its unique identifier.
    /// </remarks>

    /// <returns>Board template retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardTemplateResponse>> GetBoardTemplateAsync(GetBoardTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List board templates for a game service
    /// </summary>

    /// <remarks>
    /// Paginated list of board templates filtered by game service ID.
    /// </remarks>

    /// <returns>Board templates retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListBoardTemplatesResponse>> ListBoardTemplatesAsync(ListBoardTemplatesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update a board template
    /// </summary>

    /// <remarks>
    /// Update mutable fields of a board template. Grid dimensions, starting nodes,
    /// <br/>and contract template are immutable after creation.
    /// </remarks>

    /// <returns>Board template updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardTemplateResponse>> UpdateBoardTemplateAsync(UpdateBoardTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete a board template
    /// </summary>

    /// <remarks>
    /// Delete a board template. Blocked if active board instances exist
    /// <br/>that reference this template.
    /// </remarks>

    /// <returns>Board template deleted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardTemplateResponse>> DeleteBoardTemplateAsync(DeleteBoardTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Add a license definition to a board template
    /// </summary>

    /// <remarks>
    /// Add a license definition (node) to a board template at a specific grid position.
    /// <br/>Each definition has a unique code within the template, a grid position, an LP cost,
    /// <br/>and a reference to the item template that is created when the license is unlocked.
    /// <br/>Optional non-adjacent prerequisites can reference other license codes on the board.
    /// </remarks>

    /// <returns>License definition added successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LicenseDefinitionResponse>> AddLicenseDefinitionAsync(AddLicenseDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get a license definition
    /// </summary>

    /// <remarks>
    /// Get a license definition by board template ID and license code.
    /// </remarks>

    /// <returns>License definition retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LicenseDefinitionResponse>> GetLicenseDefinitionAsync(GetLicenseDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all license definitions for a board template
    /// </summary>

    /// <remarks>
    /// Returns the full grid layout of all license definitions for a board template.
    /// </remarks>

    /// <returns>License definitions retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListLicenseDefinitionsResponse>> ListLicenseDefinitionsAsync(ListLicenseDefinitionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update a license definition
    /// </summary>

    /// <remarks>
    /// Update mutable fields of a license definition. Position and code are immutable
    /// <br/>after creation.
    /// </remarks>

    /// <returns>License definition updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LicenseDefinitionResponse>> UpdateLicenseDefinitionAsync(UpdateLicenseDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Remove a license definition from a board template
    /// </summary>

    /// <remarks>
    /// Remove a license definition from a board template. Blocked if any board
    /// <br/>instances have this license unlocked.
    /// </remarks>

    /// <returns>License definition removed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LicenseDefinitionResponse>> RemoveLicenseDefinitionAsync(RemoveLicenseDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create a board instance for an owner
    /// </summary>

    /// <remarks>
    /// Create a board instance for an owner from a board template. Validates the owner type
    /// <br/>is in the template's allowedOwnerTypes, game service matches, and no duplicate board
    /// <br/>exists (one board per template per owner). For character owners, validates the character
    /// <br/>exists and resolves realm context. Creates an inventory container (slot_only,
    /// <br/>maxSlots = gridWidth * gridHeight) to hold unlocked license items.
    /// </remarks>

    /// <returns>Board created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardResponse>> CreateBoardAsync(CreateBoardRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get a board instance by ID
    /// </summary>

    /// <remarks>
    /// Retrieves a board instance by its unique identifier.
    /// </remarks>

    /// <returns>Board retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardResponse>> GetBoardAsync(GetBoardRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List boards for an owner
    /// </summary>

    /// <remarks>
    /// List all board instances for an owner (by ownerType + ownerId), with optional game service filter.
    /// </remarks>

    /// <returns>Boards retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListBoardsByOwnerResponse>> ListBoardsByOwnerAsync(ListBoardsByOwnerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete a board instance
    /// </summary>

    /// <remarks>
    /// Delete a board instance. Destroys the inventory container and all license
    /// <br/>items within it.
    /// </remarks>

    /// <returns>Board deleted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardResponse>> DeleteBoardAsync(DeleteBoardRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Unlock a license on a board
    /// </summary>

    /// <remarks>
    /// The core operation. Validates adjacency and prerequisites, creates a contract
    /// <br/>instance from the board template's contract template, executes the unlock
    /// <br/>milestone (LP deduction, ability grants via prebound APIs), then creates an
    /// <br/>item instance and places it in the board container. Atomic: if contract
    /// <br/>execution fails, no license is placed.
    /// </remarks>

    /// <returns>License unlocked successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UnlockLicenseResponse>> UnlockLicenseAsync(UnlockLicenseRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Check if a license can be unlocked
    /// </summary>

    /// <remarks>
    /// Check if a license can be unlocked without performing the unlock. Returns
    /// <br/>adjacency status, prerequisite status, and whether the character has
    /// <br/>sufficient LP.
    /// </remarks>

    /// <returns>Unlockability check completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CheckUnlockableResponse>> CheckUnlockableAsync(CheckUnlockableRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get full board state
    /// </summary>

    /// <remarks>
    /// Get the full board state: all defined license positions with unlock status
    /// <br/>(unlocked, locked, unlockable) and adjacency info. Primary endpoint for
    /// <br/>client UI rendering.
    /// </remarks>

    /// <returns>Board state retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardStateResponse>> GetBoardStateAsync(BoardStateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Bulk seed a board template with license definitions
    /// </summary>

    /// <remarks>
    /// Bulk seed a board template with license definitions from a JSON payload.
    /// <br/>Two-pass: creates definitions, then resolves prerequisite references.
    /// </remarks>

    /// <returns>Board template seeded successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SeedBoardTemplateResponse>> SeedBoardTemplateAsync(SeedBoardTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Clone a board's unlock state to a new owner
    /// </summary>

    /// <remarks>
    /// Developer-only endpoint for cloning NPC progression. Reads unlock state
    /// <br/>from a source board, creates a new board for the target owner, and bulk-creates
    /// <br/>item instances for all unlocked licenses. Skips contracts entirely (admin tooling,
    /// <br/>not gameplay). Publishes a single license.board.cloned event.
    /// <br/>Does not publish individual license.unlocked events.
    /// </remarks>

    /// <returns>Board cloned successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CloneBoardResponse>> CloneBoardAsync(CloneBoardRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Cleanup boards referencing a deleted owner
    /// </summary>

    /// <remarks>
    /// Called by lib-resource cleanup coordination when an owner entity is deleted.
    /// <br/>Deletes all board instances for the specified owner (ownerType + ownerId),
    /// <br/>destroying their inventory containers and all contained license items.
    /// <br/>This endpoint is designed for internal service-to-service calls during
    /// <br/>cascading resource cleanup.
    /// </remarks>

    /// <returns>Cleanup completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupByOwnerResponse>> CleanupByOwnerAsync(CleanupByOwnerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class LicenseController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private ILicenseService _implementation;

    public LicenseController(ILicenseService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Create a new board template
    /// </summary>
    /// <remarks>
    /// Create a board template with grid dimensions, starting nodes, adjacency mode,
    /// <br/>and a reference to the contract template that controls unlock behavior.
    /// <br/>Board templates are scoped to a game service.
    /// </remarks>
    /// <returns>Board template created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/board-template/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardTemplateResponse>> CreateBoardTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateBoardTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.CreateBoardTemplateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/board-template/create");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/board-template/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "CreateBoardTemplate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/board-template/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get a board template by ID
    /// </summary>
    /// <remarks>
    /// Retrieves a board template by its unique identifier.
    /// </remarks>
    /// <returns>Board template retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/board-template/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardTemplateResponse>> GetBoardTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetBoardTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetBoardTemplateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/board-template/get");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/board-template/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "GetBoardTemplate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/board-template/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List board templates for a game service
    /// </summary>
    /// <remarks>
    /// Paginated list of board templates filtered by game service ID.
    /// </remarks>
    /// <returns>Board templates retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/board-template/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListBoardTemplatesResponse>> ListBoardTemplates([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListBoardTemplatesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ListBoardTemplatesAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/board-template/list");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/board-template/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "ListBoardTemplates",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/board-template/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update a board template
    /// </summary>
    /// <remarks>
    /// Update mutable fields of a board template. Grid dimensions, starting nodes,
    /// <br/>and contract template are immutable after creation.
    /// </remarks>
    /// <returns>Board template updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/board-template/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardTemplateResponse>> UpdateBoardTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateBoardTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.UpdateBoardTemplateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/board-template/update");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/board-template/update");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "UpdateBoardTemplate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/board-template/update",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Delete a board template
    /// </summary>
    /// <remarks>
    /// Delete a board template. Blocked if active board instances exist
    /// <br/>that reference this template.
    /// </remarks>
    /// <returns>Board template deleted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/board-template/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardTemplateResponse>> DeleteBoardTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteBoardTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.DeleteBoardTemplateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/board-template/delete");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/board-template/delete");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "DeleteBoardTemplate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/board-template/delete",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Add a license definition to a board template
    /// </summary>
    /// <remarks>
    /// Add a license definition (node) to a board template at a specific grid position.
    /// <br/>Each definition has a unique code within the template, a grid position, an LP cost,
    /// <br/>and a reference to the item template that is created when the license is unlocked.
    /// <br/>Optional non-adjacent prerequisites can reference other license codes on the board.
    /// </remarks>
    /// <returns>License definition added successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/definition/add")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LicenseDefinitionResponse>> AddLicenseDefinition([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AddLicenseDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.AddLicenseDefinitionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/definition/add");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/definition/add");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "AddLicenseDefinition",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/definition/add",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get a license definition
    /// </summary>
    /// <remarks>
    /// Get a license definition by board template ID and license code.
    /// </remarks>
    /// <returns>License definition retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/definition/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LicenseDefinitionResponse>> GetLicenseDefinition([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetLicenseDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetLicenseDefinitionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/definition/get");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/definition/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "GetLicenseDefinition",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/definition/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List all license definitions for a board template
    /// </summary>
    /// <remarks>
    /// Returns the full grid layout of all license definitions for a board template.
    /// </remarks>
    /// <returns>License definitions retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/definition/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListLicenseDefinitionsResponse>> ListLicenseDefinitions([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListLicenseDefinitionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ListLicenseDefinitionsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/definition/list");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/definition/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "ListLicenseDefinitions",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/definition/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update a license definition
    /// </summary>
    /// <remarks>
    /// Update mutable fields of a license definition. Position and code are immutable
    /// <br/>after creation.
    /// </remarks>
    /// <returns>License definition updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/definition/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LicenseDefinitionResponse>> UpdateLicenseDefinition([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateLicenseDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.UpdateLicenseDefinitionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/definition/update");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/definition/update");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "UpdateLicenseDefinition",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/definition/update",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Remove a license definition from a board template
    /// </summary>
    /// <remarks>
    /// Remove a license definition from a board template. Blocked if any board
    /// <br/>instances have this license unlocked.
    /// </remarks>
    /// <returns>License definition removed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/definition/remove")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LicenseDefinitionResponse>> RemoveLicenseDefinition([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RemoveLicenseDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.RemoveLicenseDefinitionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/definition/remove");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/definition/remove");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "RemoveLicenseDefinition",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/definition/remove",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Create a board instance for an owner
    /// </summary>
    /// <remarks>
    /// Create a board instance for an owner from a board template. Validates the owner type
    /// <br/>is in the template's allowedOwnerTypes, game service matches, and no duplicate board
    /// <br/>exists (one board per template per owner). For character owners, validates the character
    /// <br/>exists and resolves realm context. Creates an inventory container (slot_only,
    /// <br/>maxSlots = gridWidth * gridHeight) to hold unlocked license items.
    /// </remarks>
    /// <returns>Board created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/board/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardResponse>> CreateBoard([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateBoardRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.CreateBoardAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/board/create");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/board/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "CreateBoard",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/board/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get a board instance by ID
    /// </summary>
    /// <remarks>
    /// Retrieves a board instance by its unique identifier.
    /// </remarks>
    /// <returns>Board retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/board/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardResponse>> GetBoard([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetBoardRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetBoardAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/board/get");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/board/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "GetBoard",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/board/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List boards for an owner
    /// </summary>
    /// <remarks>
    /// List all board instances for an owner (by ownerType + ownerId), with optional game service filter.
    /// </remarks>
    /// <returns>Boards retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/board/list-by-owner")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListBoardsByOwnerResponse>> ListBoardsByOwner([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListBoardsByOwnerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ListBoardsByOwnerAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/board/list-by-owner");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/board/list-by-owner");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "ListBoardsByOwner",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/board/list-by-owner",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Delete a board instance
    /// </summary>
    /// <remarks>
    /// Delete a board instance. Destroys the inventory container and all license
    /// <br/>items within it.
    /// </remarks>
    /// <returns>Board deleted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/board/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardResponse>> DeleteBoard([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteBoardRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.DeleteBoardAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/board/delete");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/board/delete");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "DeleteBoard",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/board/delete",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Unlock a license on a board
    /// </summary>
    /// <remarks>
    /// The core operation. Validates adjacency and prerequisites, creates a contract
    /// <br/>instance from the board template's contract template, executes the unlock
    /// <br/>milestone (LP deduction, ability grants via prebound APIs), then creates an
    /// <br/>item instance and places it in the board container. Atomic: if contract
    /// <br/>execution fails, no license is placed.
    /// </remarks>
    /// <returns>License unlocked successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/unlock")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UnlockLicenseResponse>> UnlockLicense([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UnlockLicenseRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.UnlockLicenseAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/unlock");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/unlock");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "UnlockLicense",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/unlock",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Check if a license can be unlocked
    /// </summary>
    /// <remarks>
    /// Check if a license can be unlocked without performing the unlock. Returns
    /// <br/>adjacency status, prerequisite status, and whether the character has
    /// <br/>sufficient LP.
    /// </remarks>
    /// <returns>Unlockability check completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/check-unlockable")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CheckUnlockableResponse>> CheckUnlockable([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CheckUnlockableRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.CheckUnlockableAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/check-unlockable");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/check-unlockable");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "CheckUnlockable",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/check-unlockable",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get full board state
    /// </summary>
    /// <remarks>
    /// Get the full board state: all defined license positions with unlock status
    /// <br/>(unlocked, locked, unlockable) and adjacency info. Primary endpoint for
    /// <br/>client UI rendering.
    /// </remarks>
    /// <returns>Board state retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/board-state")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BoardStateResponse>> GetBoardState([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BoardStateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetBoardStateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/board-state");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/board-state");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "GetBoardState",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/board-state",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Bulk seed a board template with license definitions
    /// </summary>
    /// <remarks>
    /// Bulk seed a board template with license definitions from a JSON payload.
    /// <br/>Two-pass: creates definitions, then resolves prerequisite references.
    /// </remarks>
    /// <returns>Board template seeded successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/board-template/seed")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SeedBoardTemplateResponse>> SeedBoardTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SeedBoardTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.SeedBoardTemplateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/board-template/seed");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/board-template/seed");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "SeedBoardTemplate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/board-template/seed",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Clone a board's unlock state to a new owner
    /// </summary>
    /// <remarks>
    /// Developer-only endpoint for cloning NPC progression. Reads unlock state
    /// <br/>from a source board, creates a new board for the target owner, and bulk-creates
    /// <br/>item instances for all unlocked licenses. Skips contracts entirely (admin tooling,
    /// <br/>not gameplay). Publishes a single license.board.cloned event.
    /// <br/>Does not publish individual license.unlocked events.
    /// </remarks>
    /// <returns>Board cloned successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/board/clone")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CloneBoardResponse>> CloneBoard([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CloneBoardRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.CloneBoardAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/board/clone");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/board/clone");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "CloneBoard",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/board/clone",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Cleanup boards referencing a deleted owner
    /// </summary>
    /// <remarks>
    /// Called by lib-resource cleanup coordination when an owner entity is deleted.
    /// <br/>Deletes all board instances for the specified owner (ownerType + ownerId),
    /// <br/>destroying their inventory containers and all contained license items.
    /// <br/>This endpoint is designed for internal service-to-service calls during
    /// <br/>cascading resource cleanup.
    /// </remarks>
    /// <returns>Cleanup completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("license/cleanup-by-owner")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupByOwnerResponse>> CleanupByOwner([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CleanupByOwnerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.CleanupByOwnerAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:license/cleanup-by-owner");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<LicenseController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:license/cleanup-by-owner");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "license",
                "CleanupByOwner",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:license/cleanup-by-owner",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
