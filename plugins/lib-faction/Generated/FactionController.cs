//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     RELATED FILES:
//     - Request/Response models: bannou-service/Generated/Models/{Service}Models.cs
//     - Event models: bannou-service/Generated/Events/{Service}EventsModels.cs
//     - Lifecycle events: bannou-service/Generated/Events/{Service}LifecycleEvents.cs
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Faction;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IFactionController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Create a new faction
    /// </summary>

    /// <remarks>
    /// Creates a new faction entity and automatically creates a seed via lib-seed
    /// <br/>with ownerType "faction" and the configured seed type code. The seed starts
    /// <br/>in the "nascent" phase with no capabilities unlocked.
    /// <br/>
    /// <br/>The faction code must be unique within the game service scope.
    /// <br/>
    /// <br/>If parentFactionId is provided, validates that the parent exists, belongs
    /// <br/>to the same game service and realm, and that the resulting hierarchy depth
    /// <br/>does not exceed the configured maximum.
    /// </remarks>

    /// <returns>Faction created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> CreateFactionAsync(CreateFactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get a faction by ID
    /// </summary>

    /// <remarks>
    /// Retrieves a faction by its unique identifier. Includes the current seed
    /// <br/>growth phase (denormalized from lib-seed for convenience) and member count.
    /// </remarks>

    /// <returns>Faction retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> GetFactionAsync(GetFactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get a faction by code
    /// </summary>

    /// <remarks>
    /// Retrieves a faction by its unique code within a game service scope.
    /// <br/>Codes are human-readable identifiers like "thieves_guild" or "royal_guard".
    /// </remarks>

    /// <returns>Faction retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> GetFactionByCodeAsync(GetFactionByCodeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List factions with filters
    /// </summary>

    /// <remarks>
    /// Returns a paginated list of factions with optional filters by realm,
    /// <br/>game service, status, and parent faction. Supports cursor-based pagination.
    /// </remarks>

    /// <returns>Factions retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListFactionsResponse>> ListFactionsAsync(ListFactionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update a faction
    /// </summary>

    /// <remarks>
    /// Updates mutable faction properties (name, description, code). The faction
    /// <br/>code must remain unique within its game service scope. Cannot change
    /// <br/>gameServiceId or realmId after creation.
    /// </remarks>

    /// <returns>Faction updated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> UpdateFactionAsync(UpdateFactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Deprecate a faction
    /// </summary>

    /// <remarks>
    /// Marks a faction as deprecated. Deprecated factions cannot accept new members
    /// <br/>or define new norms, but existing memberships and norms remain active.
    /// <br/>Existing norm enforcement continues until the faction is dissolved.
    /// </remarks>

    /// <returns>Faction deprecated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> DeprecateFactionAsync(DeprecateFactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Reactivate a deprecated faction
    /// </summary>

    /// <remarks>
    /// Restores a deprecated faction to active status.
    /// </remarks>

    /// <returns>Faction reactivated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> UndeprecateFactionAsync(UndeprecateFactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete a faction
    /// </summary>

    /// <remarks>
    /// Permanently deletes a faction. Checks resource references via lib-resource
    /// <br/>before deletion. If references exist, executes cleanup callbacks (CASCADE
    /// <br/>policy). Removes all memberships, territory claims, norm definitions, and
    /// <br/>the associated seed.
    /// </remarks>

    /// <returns>Faction deleted</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> DeleteFactionAsync(DeleteFactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Bulk seed factions from configuration
    /// </summary>

    /// <remarks>
    /// Creates multiple factions from a configuration payload. Uses two-pass
    /// <br/>parent resolution: first pass creates all factions without parent links,
    /// <br/>second pass sets parentFactionId by matching parent codes.
    /// <br/>
    /// <br/>Each faction in the payload gets a seed created via lib-seed. Existing
    /// <br/>factions (matched by code within game service) are skipped.
    /// </remarks>

    /// <returns>Seeding completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SeedFactionsResponse>> SeedFactionsAsync(SeedFactionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Designate a faction as realm baseline
    /// </summary>

    /// <remarks>
    /// Sets a faction as the realm's baseline cultural faction. The baseline
    /// <br/>faction provides realm-wide default norms (honor codes, cultural taboos,
    /// <br/>species instincts) that apply to all characters in the realm unless
    /// <br/>overridden by more specific faction norms.
    /// <br/>
    /// <br/>Only one faction per realm can be the baseline. Setting a new baseline
    /// <br/>clears the previous one. The faction must belong to the specified realm.
    /// </remarks>

    /// <returns>Faction designated as realm baseline</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> DesignateRealmBaselineAsync(DesignateRealmBaselineRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get the realm baseline faction
    /// </summary>

    /// <remarks>
    /// Returns the faction designated as the baseline cultural faction for a realm.
    /// <br/>Returns 404 if no baseline has been designated.
    /// </remarks>

    /// <returns>Realm baseline faction retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> GetRealmBaselineAsync(GetRealmBaselineRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Add a character to a faction
    /// </summary>

    /// <remarks>
    /// Adds a character as a member of a faction. The faction must be active
    /// <br/>(not deprecated or dissolved). If no role is specified, the configured
    /// <br/>default member role is used.
    /// <br/>
    /// <br/>A character can be a member of multiple factions simultaneously. Duplicate
    /// <br/>membership (same character + same faction) returns Conflict.
    /// <br/>
    /// <br/>Publishes a faction.member.added event for downstream consumers.
    /// </remarks>

    /// <returns>Member added</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionMemberResponse>> AddMemberAsync(AddMemberRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Remove a character from a faction
    /// </summary>

    /// <remarks>
    /// Removes a character's membership in a faction. Publishes a
    /// <br/>faction.member.removed event for downstream consumers.
    /// </remarks>

    /// <returns>Member removed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> RemoveMemberAsync(RemoveMemberRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List members of a faction
    /// </summary>

    /// <remarks>
    /// Returns a paginated list of members for a faction. Supports filtering
    /// <br/>by role and cursor-based pagination. Ordered by join date descending.
    /// </remarks>

    /// <returns>Members retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListMembersResponse>> ListMembersAsync(ListMembersRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List a character's faction memberships
    /// </summary>

    /// <remarks>
    /// Returns all faction memberships for a character. Used by lib-obligation
    /// <br/>to determine which guild faction norms apply to a character, and by the
    /// <br/>${faction.*} variable provider for ABML behavior expressions.
    /// </remarks>

    /// <returns>Memberships retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListMembershipsByCharacterResponse>> ListMembershipsByCharacterAsync(ListMembershipsByCharacterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update a member's role
    /// </summary>

    /// <remarks>
    /// Changes a member's role within a faction. Publishes a
    /// <br/>faction.member.role-changed event for downstream consumers.
    /// </remarks>

    /// <returns>Role updated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionMemberResponse>> UpdateMemberRoleAsync(UpdateMemberRoleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Check if a character is a member of a faction
    /// </summary>

    /// <remarks>
    /// Returns whether a character is currently a member of the specified faction,
    /// <br/>and if so, their role. Lightweight lookup for permission/capability checks.
    /// </remarks>

    /// <returns>Membership check result</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CheckMembershipResponse>> CheckMembershipAsync(CheckMembershipRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Claim a location for a faction
    /// </summary>

    /// <remarks>
    /// Claims a location as faction territory. Requires the faction's seed to
    /// <br/>have unlocked the "territory.claim" capability. A location can only have
    /// <br/>one controlling faction at a time (exclusive claim). If the location is
    /// <br/>already claimed by another faction, the claim is rejected with Conflict.
    /// <br/>
    /// <br/>The faction must belong to the same realm as the location.
    /// </remarks>

    /// <returns>Territory claimed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TerritoryClaimResponse>> ClaimTerritoryAsync(ClaimTerritoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Release a territory claim
    /// </summary>

    /// <remarks>
    /// Releases a faction's claim on a location. The territory becomes unclaimed
    /// <br/>and available for other factions. Publishes a faction.territory.released event.
    /// </remarks>

    /// <returns>Territory released</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> ReleaseTerritoryAsync(ReleaseTerritoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List territory claims for a faction
    /// </summary>

    /// <remarks>
    /// Returns all territory claims for a faction with optional status filtering
    /// <br/>and cursor-based pagination.
    /// </remarks>

    /// <returns>Territory claims retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListTerritoryClaimsResponse>> ListTerritoryClaimsAsync(ListTerritoryClaimsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get the controlling faction for a location
    /// </summary>

    /// <remarks>
    /// Returns the faction that currently controls a location. Used by
    /// <br/>lib-obligation and the norm resolution hierarchy to determine which
    /// <br/>location faction norms apply at a character's current position.
    /// <br/>
    /// <br/>Returns 404 if the location has no controlling faction.
    /// </remarks>

    /// <returns>Controlling faction retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ControllingFactionResponse>> GetControllingFactionAsync(GetControllingFactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Define a behavioral norm for a faction
    /// </summary>

    /// <remarks>
    /// Creates a new behavioral norm definition for a faction. Requires the
    /// <br/>faction's seed to have unlocked the "norm.define" capability (growth
    /// <br/>threshold must be reached). Higher-severity norms may require additional
    /// <br/>capabilities (norm.enforce.basic for Standard, norm.enforce.sanctions
    /// <br/>for Strict).
    /// <br/>
    /// <br/>Norms are stored as faction configuration and queried by lib-obligation
    /// <br/>for NPC cognition cost modifiers. They are NOT contract instances --
    /// <br/>this avoids the scaling problem of 100K NPCs each needing individual
    /// <br/>contract instances for ambient social rules.
    /// <br/>
    /// <br/>The violationType is an opaque string that maps to lib-obligation's
    /// <br/>violation type vocabulary (e.g., "theft", "deception", "violence",
    /// <br/>"honor_combat"). No separate taxonomy is maintained -- the vocabulary
    /// <br/>is defined by contract templates and action tag mappings.
    /// </remarks>

    /// <returns>Norm defined</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<NormDefinitionResponse>> DefineNormAsync(DefineNormRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update an existing norm
    /// </summary>

    /// <remarks>
    /// Updates properties of an existing norm definition. The violationType
    /// <br/>cannot be changed (delete and recreate if needed). Severity changes
    /// <br/>are subject to capability checks.
    /// </remarks>

    /// <returns>Norm updated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<NormDefinitionResponse>> UpdateNormAsync(UpdateNormRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete a norm definition
    /// </summary>

    /// <remarks>
    /// Removes a behavioral norm definition from a faction.
    /// </remarks>

    /// <returns>Norm deleted</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> DeleteNormAsync(DeleteNormRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List norms defined by a faction
    /// </summary>

    /// <remarks>
    /// Returns all norm definitions for a faction with optional filtering
    /// <br/>by severity and scope.
    /// </remarks>

    /// <returns>Norms retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListNormsResponse>> ListNormsAsync(ListNormsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Query all norms applicable to a character
    /// </summary>

    /// <remarks>
    /// Critical integration endpoint for lib-obligation. Aggregates norms from
    /// <br/>three resolution layers and returns a merged norm set with most-specific-wins
    /// <br/>resolution applied:
    /// <br/>
    /// <br/>1. Membership norms: from the character's faction memberships (guild norms)
    /// <br/>2. Territory norms: from the controlling faction at the character's location
    /// <br/>3. Realm baseline norms: from the realm's baseline cultural faction
    /// <br/>
    /// <br/>The mergedNormMap provides the winning norm for each violation type after
    /// <br/>resolution. When multiple layers define the same violation type, the
    /// <br/>most specific layer wins (membership &gt; territory &gt; realm baseline).
    /// <br/>
    /// <br/>Results are cached per character+location combination with configurable TTL.
    /// <br/>lib-obligation can use forceRefresh to bypass the cache after faction
    /// <br/>membership or location changes.
    /// </remarks>

    /// <returns>Applicable norms resolved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryApplicableNormsResponse>> QueryApplicableNormsAsync(QueryApplicableNormsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Cleanup faction data for a deleted character
    /// </summary>

    /// <remarks>
    /// Called by lib-resource cleanup coordination when a character is deleted.
    /// <br/>Removes all faction memberships for the character. Territory claims and
    /// <br/>norm definitions are faction-owned, not character-owned, so they remain.
    /// </remarks>

    /// <returns>Cleanup completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupByCharacterResponse>> CleanupByCharacterAsync(CleanupByCharacterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Cleanup faction data for a deleted realm
    /// </summary>

    /// <remarks>
    /// Called by lib-resource cleanup coordination when a realm is deleted.
    /// <br/>Removes all factions belonging to the realm, including their memberships,
    /// <br/>territory claims, norm definitions, and associated seeds.
    /// </remarks>

    /// <returns>Cleanup completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupByRealmResponse>> CleanupByRealmAsync(CleanupByRealmRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Cleanup territory claims for a deleted location
    /// </summary>

    /// <remarks>
    /// Called by lib-resource cleanup coordination when a location is deleted.
    /// <br/>Removes all territory claims referencing the location. The faction itself
    /// <br/>remains intact.
    /// </remarks>

    /// <returns>Cleanup completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupByLocationResponse>> CleanupByLocationAsync(CleanupByLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get faction data for character archival compression
    /// </summary>

    /// <remarks>
    /// Called by Resource service during character compression. Returns faction
    /// <br/>memberships and roles for the character for archival. Norm definitions
    /// <br/>are faction-owned data and not included in character archives.
    /// </remarks>

    /// <returns>Compressed data returned</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionArchive>> GetCompressDataAsync(GetCompressDataRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Restore faction data from archive
    /// </summary>

    /// <remarks>
    /// Called by Resource service during character decompression. Restores
    /// <br/>faction memberships from archive data. Only restores memberships for
    /// <br/>factions that still exist.
    /// </remarks>

    /// <returns>Restoration result</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RestoreFromArchiveResponse>> RestoreFromArchiveAsync(RestoreFromArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class FactionController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IFactionService _implementation;
    private BeyondImmersion.BannouService.Services.ITelemetryProvider _telemetryProvider;

    public FactionController(IFactionService implementation, BeyondImmersion.BannouService.Services.ITelemetryProvider telemetryProvider)
    {
        _implementation = implementation;
        _telemetryProvider = telemetryProvider;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Create a new faction
    /// </summary>
    /// <remarks>
    /// Creates a new faction entity and automatically creates a seed via lib-seed
    /// <br/>with ownerType "faction" and the configured seed type code. The seed starts
    /// <br/>in the "nascent" phase with no capabilities unlocked.
    /// <br/>
    /// <br/>The faction code must be unique within the game service scope.
    /// <br/>
    /// <br/>If parentFactionId is provided, validates that the parent exists, belongs
    /// <br/>to the same game service and realm, and that the resulting hierarchy depth
    /// <br/>does not exceed the configured maximum.
    /// </remarks>
    /// <returns>Faction created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> CreateFaction([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateFactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.CreateFaction",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/create");
        try
        {

            var (statusCode, result) = await _implementation.CreateFactionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/create");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "CreateFaction",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get a faction by ID
    /// </summary>
    /// <remarks>
    /// Retrieves a faction by its unique identifier. Includes the current seed
    /// <br/>growth phase (denormalized from lib-seed for convenience) and member count.
    /// </remarks>
    /// <returns>Faction retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> GetFaction([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetFactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.GetFaction",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/get");
        try
        {

            var (statusCode, result) = await _implementation.GetFactionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/get");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "GetFaction",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get a faction by code
    /// </summary>
    /// <remarks>
    /// Retrieves a faction by its unique code within a game service scope.
    /// <br/>Codes are human-readable identifiers like "thieves_guild" or "royal_guard".
    /// </remarks>
    /// <returns>Faction retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/get-by-code")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> GetFactionByCode([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetFactionByCodeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.GetFactionByCode",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/get-by-code");
        try
        {

            var (statusCode, result) = await _implementation.GetFactionByCodeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/get-by-code");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/get-by-code");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "GetFactionByCode",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/get-by-code",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List factions with filters
    /// </summary>
    /// <remarks>
    /// Returns a paginated list of factions with optional filters by realm,
    /// <br/>game service, status, and parent faction. Supports cursor-based pagination.
    /// </remarks>
    /// <returns>Factions retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListFactionsResponse>> ListFactions([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListFactionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.ListFactions",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/list");
        try
        {

            var (statusCode, result) = await _implementation.ListFactionsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/list");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "ListFactions",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update a faction
    /// </summary>
    /// <remarks>
    /// Updates mutable faction properties (name, description, code). The faction
    /// <br/>code must remain unique within its game service scope. Cannot change
    /// <br/>gameServiceId or realmId after creation.
    /// </remarks>
    /// <returns>Faction updated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> UpdateFaction([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateFactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.UpdateFaction",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/update");
        try
        {

            var (statusCode, result) = await _implementation.UpdateFactionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/update");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/update");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "UpdateFaction",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/update",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Deprecate a faction
    /// </summary>
    /// <remarks>
    /// Marks a faction as deprecated. Deprecated factions cannot accept new members
    /// <br/>or define new norms, but existing memberships and norms remain active.
    /// <br/>Existing norm enforcement continues until the faction is dissolved.
    /// </remarks>
    /// <returns>Faction deprecated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/deprecate")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> DeprecateFaction([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeprecateFactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.DeprecateFaction",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/deprecate");
        try
        {

            var (statusCode, result) = await _implementation.DeprecateFactionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/deprecate");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/deprecate");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "DeprecateFaction",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/deprecate",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Reactivate a deprecated faction
    /// </summary>
    /// <remarks>
    /// Restores a deprecated faction to active status.
    /// </remarks>
    /// <returns>Faction reactivated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/undeprecate")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> UndeprecateFaction([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UndeprecateFactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.UndeprecateFaction",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/undeprecate");
        try
        {

            var (statusCode, result) = await _implementation.UndeprecateFactionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/undeprecate");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/undeprecate");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "UndeprecateFaction",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/undeprecate",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Delete a faction
    /// </summary>
    /// <remarks>
    /// Permanently deletes a faction. Checks resource references via lib-resource
    /// <br/>before deletion. If references exist, executes cleanup callbacks (CASCADE
    /// <br/>policy). Removes all memberships, territory claims, norm definitions, and
    /// <br/>the associated seed.
    /// </remarks>
    /// <returns>Faction deleted</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> DeleteFaction([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteFactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.DeleteFaction",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/delete");
        try
        {

            var statusCode = await _implementation.DeleteFactionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/delete");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/delete");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "DeleteFaction",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/delete",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Bulk seed factions from configuration
    /// </summary>
    /// <remarks>
    /// Creates multiple factions from a configuration payload. Uses two-pass
    /// <br/>parent resolution: first pass creates all factions without parent links,
    /// <br/>second pass sets parentFactionId by matching parent codes.
    /// <br/>
    /// <br/>Each faction in the payload gets a seed created via lib-seed. Existing
    /// <br/>factions (matched by code within game service) are skipped.
    /// </remarks>
    /// <returns>Seeding completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/seed")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SeedFactionsResponse>> SeedFactions([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SeedFactionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.SeedFactions",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/seed");
        try
        {

            var (statusCode, result) = await _implementation.SeedFactionsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/seed");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/seed");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "SeedFactions",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/seed",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Designate a faction as realm baseline
    /// </summary>
    /// <remarks>
    /// Sets a faction as the realm's baseline cultural faction. The baseline
    /// <br/>faction provides realm-wide default norms (honor codes, cultural taboos,
    /// <br/>species instincts) that apply to all characters in the realm unless
    /// <br/>overridden by more specific faction norms.
    /// <br/>
    /// <br/>Only one faction per realm can be the baseline. Setting a new baseline
    /// <br/>clears the previous one. The faction must belong to the specified realm.
    /// </remarks>
    /// <returns>Faction designated as realm baseline</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/designate-realm-baseline")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> DesignateRealmBaseline([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DesignateRealmBaselineRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.DesignateRealmBaseline",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/designate-realm-baseline");
        try
        {

            var (statusCode, result) = await _implementation.DesignateRealmBaselineAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/designate-realm-baseline");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/designate-realm-baseline");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "DesignateRealmBaseline",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/designate-realm-baseline",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get the realm baseline faction
    /// </summary>
    /// <remarks>
    /// Returns the faction designated as the baseline cultural faction for a realm.
    /// <br/>Returns 404 if no baseline has been designated.
    /// </remarks>
    /// <returns>Realm baseline faction retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/get-realm-baseline")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionResponse>> GetRealmBaseline([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetRealmBaselineRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.GetRealmBaseline",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/get-realm-baseline");
        try
        {

            var (statusCode, result) = await _implementation.GetRealmBaselineAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/get-realm-baseline");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/get-realm-baseline");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "GetRealmBaseline",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/get-realm-baseline",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Add a character to a faction
    /// </summary>
    /// <remarks>
    /// Adds a character as a member of a faction. The faction must be active
    /// <br/>(not deprecated or dissolved). If no role is specified, the configured
    /// <br/>default member role is used.
    /// <br/>
    /// <br/>A character can be a member of multiple factions simultaneously. Duplicate
    /// <br/>membership (same character + same faction) returns Conflict.
    /// <br/>
    /// <br/>Publishes a faction.member.added event for downstream consumers.
    /// </remarks>
    /// <returns>Member added</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/member/add")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionMemberResponse>> AddMember([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AddMemberRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.AddMember",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/member/add");
        try
        {

            var (statusCode, result) = await _implementation.AddMemberAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/member/add");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/member/add");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "AddMember",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/member/add",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Remove a character from a faction
    /// </summary>
    /// <remarks>
    /// Removes a character's membership in a faction. Publishes a
    /// <br/>faction.member.removed event for downstream consumers.
    /// </remarks>
    /// <returns>Member removed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/member/remove")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> RemoveMember([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RemoveMemberRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.RemoveMember",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/member/remove");
        try
        {

            var statusCode = await _implementation.RemoveMemberAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/member/remove");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/member/remove");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "RemoveMember",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/member/remove",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List members of a faction
    /// </summary>
    /// <remarks>
    /// Returns a paginated list of members for a faction. Supports filtering
    /// <br/>by role and cursor-based pagination. Ordered by join date descending.
    /// </remarks>
    /// <returns>Members retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/member/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListMembersResponse>> ListMembers([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListMembersRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.ListMembers",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/member/list");
        try
        {

            var (statusCode, result) = await _implementation.ListMembersAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/member/list");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/member/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "ListMembers",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/member/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List a character's faction memberships
    /// </summary>
    /// <remarks>
    /// Returns all faction memberships for a character. Used by lib-obligation
    /// <br/>to determine which guild faction norms apply to a character, and by the
    /// <br/>${faction.*} variable provider for ABML behavior expressions.
    /// </remarks>
    /// <returns>Memberships retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/member/list-by-character")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListMembershipsByCharacterResponse>> ListMembershipsByCharacter([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListMembershipsByCharacterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.ListMembershipsByCharacter",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/member/list-by-character");
        try
        {

            var (statusCode, result) = await _implementation.ListMembershipsByCharacterAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/member/list-by-character");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/member/list-by-character");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "ListMembershipsByCharacter",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/member/list-by-character",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update a member's role
    /// </summary>
    /// <remarks>
    /// Changes a member's role within a faction. Publishes a
    /// <br/>faction.member.role-changed event for downstream consumers.
    /// </remarks>
    /// <returns>Role updated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/member/update-role")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionMemberResponse>> UpdateMemberRole([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateMemberRoleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.UpdateMemberRole",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/member/update-role");
        try
        {

            var (statusCode, result) = await _implementation.UpdateMemberRoleAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/member/update-role");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/member/update-role");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "UpdateMemberRole",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/member/update-role",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Check if a character is a member of a faction
    /// </summary>
    /// <remarks>
    /// Returns whether a character is currently a member of the specified faction,
    /// <br/>and if so, their role. Lightweight lookup for permission/capability checks.
    /// </remarks>
    /// <returns>Membership check result</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/member/check")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CheckMembershipResponse>> CheckMembership([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CheckMembershipRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.CheckMembership",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/member/check");
        try
        {

            var (statusCode, result) = await _implementation.CheckMembershipAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/member/check");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/member/check");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "CheckMembership",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/member/check",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Claim a location for a faction
    /// </summary>
    /// <remarks>
    /// Claims a location as faction territory. Requires the faction's seed to
    /// <br/>have unlocked the "territory.claim" capability. A location can only have
    /// <br/>one controlling faction at a time (exclusive claim). If the location is
    /// <br/>already claimed by another faction, the claim is rejected with Conflict.
    /// <br/>
    /// <br/>The faction must belong to the same realm as the location.
    /// </remarks>
    /// <returns>Territory claimed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/territory/claim")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TerritoryClaimResponse>> ClaimTerritory([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ClaimTerritoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.ClaimTerritory",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/territory/claim");
        try
        {

            var (statusCode, result) = await _implementation.ClaimTerritoryAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/territory/claim");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/territory/claim");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "ClaimTerritory",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/territory/claim",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Release a territory claim
    /// </summary>
    /// <remarks>
    /// Releases a faction's claim on a location. The territory becomes unclaimed
    /// <br/>and available for other factions. Publishes a faction.territory.released event.
    /// </remarks>
    /// <returns>Territory released</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/territory/release")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> ReleaseTerritory([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ReleaseTerritoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.ReleaseTerritory",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/territory/release");
        try
        {

            var statusCode = await _implementation.ReleaseTerritoryAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/territory/release");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/territory/release");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "ReleaseTerritory",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/territory/release",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List territory claims for a faction
    /// </summary>
    /// <remarks>
    /// Returns all territory claims for a faction with optional status filtering
    /// <br/>and cursor-based pagination.
    /// </remarks>
    /// <returns>Territory claims retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/territory/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListTerritoryClaimsResponse>> ListTerritoryClaims([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListTerritoryClaimsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.ListTerritoryClaims",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/territory/list");
        try
        {

            var (statusCode, result) = await _implementation.ListTerritoryClaimsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/territory/list");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/territory/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "ListTerritoryClaims",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/territory/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get the controlling faction for a location
    /// </summary>
    /// <remarks>
    /// Returns the faction that currently controls a location. Used by
    /// <br/>lib-obligation and the norm resolution hierarchy to determine which
    /// <br/>location faction norms apply at a character's current position.
    /// <br/>
    /// <br/>Returns 404 if the location has no controlling faction.
    /// </remarks>
    /// <returns>Controlling faction retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/territory/get-controlling")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ControllingFactionResponse>> GetControllingFaction([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetControllingFactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.GetControllingFaction",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/territory/get-controlling");
        try
        {

            var (statusCode, result) = await _implementation.GetControllingFactionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/territory/get-controlling");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/territory/get-controlling");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "GetControllingFaction",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/territory/get-controlling",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Define a behavioral norm for a faction
    /// </summary>
    /// <remarks>
    /// Creates a new behavioral norm definition for a faction. Requires the
    /// <br/>faction's seed to have unlocked the "norm.define" capability (growth
    /// <br/>threshold must be reached). Higher-severity norms may require additional
    /// <br/>capabilities (norm.enforce.basic for Standard, norm.enforce.sanctions
    /// <br/>for Strict).
    /// <br/>
    /// <br/>Norms are stored as faction configuration and queried by lib-obligation
    /// <br/>for NPC cognition cost modifiers. They are NOT contract instances --
    /// <br/>this avoids the scaling problem of 100K NPCs each needing individual
    /// <br/>contract instances for ambient social rules.
    /// <br/>
    /// <br/>The violationType is an opaque string that maps to lib-obligation's
    /// <br/>violation type vocabulary (e.g., "theft", "deception", "violence",
    /// <br/>"honor_combat"). No separate taxonomy is maintained -- the vocabulary
    /// <br/>is defined by contract templates and action tag mappings.
    /// </remarks>
    /// <returns>Norm defined</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/norm/define")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<NormDefinitionResponse>> DefineNorm([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DefineNormRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.DefineNorm",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/norm/define");
        try
        {

            var (statusCode, result) = await _implementation.DefineNormAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/norm/define");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/norm/define");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "DefineNorm",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/norm/define",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update an existing norm
    /// </summary>
    /// <remarks>
    /// Updates properties of an existing norm definition. The violationType
    /// <br/>cannot be changed (delete and recreate if needed). Severity changes
    /// <br/>are subject to capability checks.
    /// </remarks>
    /// <returns>Norm updated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/norm/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<NormDefinitionResponse>> UpdateNorm([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateNormRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.UpdateNorm",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/norm/update");
        try
        {

            var (statusCode, result) = await _implementation.UpdateNormAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/norm/update");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/norm/update");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "UpdateNorm",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/norm/update",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Delete a norm definition
    /// </summary>
    /// <remarks>
    /// Removes a behavioral norm definition from a faction.
    /// </remarks>
    /// <returns>Norm deleted</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/norm/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> DeleteNorm([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteNormRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.DeleteNorm",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/norm/delete");
        try
        {

            var statusCode = await _implementation.DeleteNormAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/norm/delete");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/norm/delete");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "DeleteNorm",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/norm/delete",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List norms defined by a faction
    /// </summary>
    /// <remarks>
    /// Returns all norm definitions for a faction with optional filtering
    /// <br/>by severity and scope.
    /// </remarks>
    /// <returns>Norms retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/norm/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListNormsResponse>> ListNorms([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListNormsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.ListNorms",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/norm/list");
        try
        {

            var (statusCode, result) = await _implementation.ListNormsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/norm/list");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/norm/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "ListNorms",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/norm/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Query all norms applicable to a character
    /// </summary>
    /// <remarks>
    /// Critical integration endpoint for lib-obligation. Aggregates norms from
    /// <br/>three resolution layers and returns a merged norm set with most-specific-wins
    /// <br/>resolution applied:
    /// <br/>
    /// <br/>1. Membership norms: from the character's faction memberships (guild norms)
    /// <br/>2. Territory norms: from the controlling faction at the character's location
    /// <br/>3. Realm baseline norms: from the realm's baseline cultural faction
    /// <br/>
    /// <br/>The mergedNormMap provides the winning norm for each violation type after
    /// <br/>resolution. When multiple layers define the same violation type, the
    /// <br/>most specific layer wins (membership &gt; territory &gt; realm baseline).
    /// <br/>
    /// <br/>Results are cached per character+location combination with configurable TTL.
    /// <br/>lib-obligation can use forceRefresh to bypass the cache after faction
    /// <br/>membership or location changes.
    /// </remarks>
    /// <returns>Applicable norms resolved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/norm/query-applicable")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryApplicableNormsResponse>> QueryApplicableNorms([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryApplicableNormsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.QueryApplicableNorms",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/norm/query-applicable");
        try
        {

            var (statusCode, result) = await _implementation.QueryApplicableNormsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/norm/query-applicable");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/norm/query-applicable");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "QueryApplicableNorms",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/norm/query-applicable",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Cleanup faction data for a deleted character
    /// </summary>
    /// <remarks>
    /// Called by lib-resource cleanup coordination when a character is deleted.
    /// <br/>Removes all faction memberships for the character. Territory claims and
    /// <br/>norm definitions are faction-owned, not character-owned, so they remain.
    /// </remarks>
    /// <returns>Cleanup completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/cleanup-by-character")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupByCharacterResponse>> CleanupByCharacter([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CleanupByCharacterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.CleanupByCharacter",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/cleanup-by-character");
        try
        {

            var (statusCode, result) = await _implementation.CleanupByCharacterAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/cleanup-by-character");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/cleanup-by-character");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "CleanupByCharacter",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/cleanup-by-character",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Cleanup faction data for a deleted realm
    /// </summary>
    /// <remarks>
    /// Called by lib-resource cleanup coordination when a realm is deleted.
    /// <br/>Removes all factions belonging to the realm, including their memberships,
    /// <br/>territory claims, norm definitions, and associated seeds.
    /// </remarks>
    /// <returns>Cleanup completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/cleanup-by-realm")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupByRealmResponse>> CleanupByRealm([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CleanupByRealmRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.CleanupByRealm",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/cleanup-by-realm");
        try
        {

            var (statusCode, result) = await _implementation.CleanupByRealmAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/cleanup-by-realm");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/cleanup-by-realm");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "CleanupByRealm",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/cleanup-by-realm",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Cleanup territory claims for a deleted location
    /// </summary>
    /// <remarks>
    /// Called by lib-resource cleanup coordination when a location is deleted.
    /// <br/>Removes all territory claims referencing the location. The faction itself
    /// <br/>remains intact.
    /// </remarks>
    /// <returns>Cleanup completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/cleanup-by-location")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupByLocationResponse>> CleanupByLocation([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CleanupByLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.CleanupByLocation",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/cleanup-by-location");
        try
        {

            var (statusCode, result) = await _implementation.CleanupByLocationAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/cleanup-by-location");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/cleanup-by-location");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "CleanupByLocation",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/cleanup-by-location",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get faction data for character archival compression
    /// </summary>
    /// <remarks>
    /// Called by Resource service during character compression. Returns faction
    /// <br/>memberships and roles for the character for archival. Norm definitions
    /// <br/>are faction-owned data and not included in character archives.
    /// </remarks>
    /// <returns>Compressed data returned</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/get-compress-data")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FactionArchive>> GetCompressData([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetCompressDataRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.GetCompressData",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/get-compress-data");
        try
        {

            var (statusCode, result) = await _implementation.GetCompressDataAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/get-compress-data");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/get-compress-data");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "GetCompressData",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/get-compress-data",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Restore faction data from archive
    /// </summary>
    /// <remarks>
    /// Called by Resource service during character decompression. Restores
    /// <br/>faction memberships from archive data. Only restores memberships for
    /// <br/>factions that still exist.
    /// </remarks>
    /// <returns>Restoration result</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("faction/restore-from-archive")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RestoreFromArchiveResponse>> RestoreFromArchive([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RestoreFromArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.faction",
            "FactionController.RestoreFromArchive",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "faction/restore-from-archive");
        try
        {

            var (statusCode, result) = await _implementation.RestoreFromArchiveAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:faction/restore-from-archive");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<FactionController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:faction/restore-from-archive");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "faction",
                "RestoreFromArchive",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:faction/restore-from-archive",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765