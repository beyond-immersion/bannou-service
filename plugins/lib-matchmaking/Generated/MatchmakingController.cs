//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Matchmaking;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IMatchmakingController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// List available matchmaking queues
    /// </summary>

    /// <remarks>
    /// List all available matchmaking queues that players can join.
    /// <br/>Returns queue configuration details including skill settings.
    /// </remarks>

    /// <returns>Queues retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListQueuesResponse>> ListQueuesAsync(ListQueuesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get queue details
    /// </summary>

    /// <remarks>
    /// Get detailed configuration for a specific matchmaking queue.
    /// </remarks>

    /// <returns>Queue details retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueueResponse>> GetQueueAsync(GetQueueRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create a new matchmaking queue
    /// </summary>

    /// <remarks>
    /// Create a new matchmaking queue with specified configuration.
    /// <br/>Admin only. Queue configuration includes skill settings, party limits,
    /// <br/>and exclusive group membership.
    /// </remarks>

    /// <returns>Queue created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueueResponse>> CreateQueueAsync(CreateQueueRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update a matchmaking queue
    /// </summary>

    /// <remarks>
    /// Update configuration of an existing matchmaking queue.
    /// <br/>Admin only. Changes take effect for new tickets only.
    /// </remarks>

    /// <returns>Queue updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueueResponse>> UpdateQueueAsync(UpdateQueueRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete a matchmaking queue
    /// </summary>

    /// <remarks>
    /// Delete a matchmaking queue. Admin only.
    /// <br/>Existing tickets in the queue will be cancelled with reason 'queue_disabled'.
    /// </remarks>

    /// <returns>Queue deleted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> DeleteQueueAsync(DeleteQueueRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Join matchmaking queue
    /// </summary>

    /// <remarks>
    /// Join a matchmaking queue with specified properties and query.
    /// <br/>Creates a matchmaking ticket and begins searching for compatible players.
    /// <br/>Returns immediately after ticket creation. Match results are delivered
    /// <br/>via WebSocket push events.
    /// </remarks>

    /// <returns>Successfully joined matchmaking queue</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JoinMatchmakingResponse>> JoinMatchmakingAsync(JoinMatchmakingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Leave matchmaking queue
    /// </summary>

    /// <remarks>
    /// Leave a matchmaking queue and cancel the ticket.
    /// <br/>Only available when actively in a queue (shortcut/prebound).
    /// </remarks>

    /// <returns>Successfully left matchmaking queue</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> LeaveMatchmakingAsync(LeaveMatchmakingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get matchmaking status
    /// </summary>

    /// <remarks>
    /// Get current matchmaking status for the player's active ticket.
    /// <br/>Only available when actively in a queue (shortcut/prebound).
    /// </remarks>

    /// <returns>Status retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MatchmakingStatusResponse>> GetMatchmakingStatusAsync(GetMatchmakingStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Accept a formed match
    /// </summary>

    /// <remarks>
    /// Accept a match that has been formed. Only available when a match
    /// <br/>is pending acceptance (shortcut/prebound after match formation).
    /// <br/>All players must accept within the timeout for the match to start.
    /// </remarks>

    /// <returns>Match acceptance recorded</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AcceptMatchResponse>> AcceptMatchAsync(AcceptMatchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Decline a formed match
    /// </summary>

    /// <remarks>
    /// Decline a match that has been formed. Only available when a match
    /// <br/>is pending acceptance (shortcut/prebound after match formation).
    /// <br/>Declining cancels the match for all participants.
    /// </remarks>

    /// <returns>Match declined</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> DeclineMatchAsync(DeclineMatchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get queue statistics
    /// </summary>

    /// <remarks>
    /// Get operational statistics for matchmaking queues.
    /// <br/>Includes queue depths, average wait times, and match rates.
    /// </remarks>

    /// <returns>Statistics retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MatchmakingStatsResponse>> GetMatchmakingStatsAsync(GetMatchmakingStatsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class MatchmakingController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IMatchmakingService _implementation;

    public MatchmakingController(IMatchmakingService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// List available matchmaking queues
    /// </summary>
    /// <remarks>
    /// List all available matchmaking queues that players can join.
    /// <br/>Returns queue configuration details including skill settings.
    /// </remarks>
    /// <returns>Queues retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListQueuesResponse>> ListQueues([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListQueuesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListQueuesAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get queue details
    /// </summary>
    /// <remarks>
    /// Get detailed configuration for a specific matchmaking queue.
    /// </remarks>
    /// <returns>Queue details retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueueResponse>> GetQueue([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetQueueRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetQueueAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Create a new matchmaking queue
    /// </summary>
    /// <remarks>
    /// Create a new matchmaking queue with specified configuration.
    /// <br/>Admin only. Queue configuration includes skill settings, party limits,
    /// <br/>and exclusive group membership.
    /// </remarks>
    /// <returns>Queue created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueueResponse>> CreateQueue([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateQueueRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateQueueAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Update a matchmaking queue
    /// </summary>
    /// <remarks>
    /// Update configuration of an existing matchmaking queue.
    /// <br/>Admin only. Changes take effect for new tickets only.
    /// </remarks>
    /// <returns>Queue updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueueResponse>> UpdateQueue([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateQueueRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateQueueAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Delete a matchmaking queue
    /// </summary>
    /// <remarks>
    /// Delete a matchmaking queue. Admin only.
    /// <br/>Existing tickets in the queue will be cancelled with reason 'queue_disabled'.
    /// </remarks>
    /// <returns>Queue deleted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> DeleteQueue([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteQueueRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var statusCode = await _implementation.DeleteQueueAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode);
    }

    /// <summary>
    /// Join matchmaking queue
    /// </summary>
    /// <remarks>
    /// Join a matchmaking queue with specified properties and query.
    /// <br/>Creates a matchmaking ticket and begins searching for compatible players.
    /// <br/>Returns immediately after ticket creation. Match results are delivered
    /// <br/>via WebSocket push events.
    /// </remarks>
    /// <returns>Successfully joined matchmaking queue</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("matchmaking/join")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JoinMatchmakingResponse>> JoinMatchmaking([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] JoinMatchmakingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.JoinMatchmakingAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Leave matchmaking queue
    /// </summary>
    /// <remarks>
    /// Leave a matchmaking queue and cancel the ticket.
    /// <br/>Only available when actively in a queue (shortcut/prebound).
    /// </remarks>
    /// <returns>Successfully left matchmaking queue</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("matchmaking/leave")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> LeaveMatchmaking([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] LeaveMatchmakingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var statusCode = await _implementation.LeaveMatchmakingAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode);
    }

    /// <summary>
    /// Get matchmaking status
    /// </summary>
    /// <remarks>
    /// Get current matchmaking status for the player's active ticket.
    /// <br/>Only available when actively in a queue (shortcut/prebound).
    /// </remarks>
    /// <returns>Status retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("matchmaking/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MatchmakingStatusResponse>> GetMatchmakingStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetMatchmakingStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetMatchmakingStatusAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Accept a formed match
    /// </summary>
    /// <remarks>
    /// Accept a match that has been formed. Only available when a match
    /// <br/>is pending acceptance (shortcut/prebound after match formation).
    /// <br/>All players must accept within the timeout for the match to start.
    /// </remarks>
    /// <returns>Match acceptance recorded</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("matchmaking/accept")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AcceptMatchResponse>> AcceptMatch([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AcceptMatchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.AcceptMatchAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Decline a formed match
    /// </summary>
    /// <remarks>
    /// Decline a match that has been formed. Only available when a match
    /// <br/>is pending acceptance (shortcut/prebound after match formation).
    /// <br/>Declining cancels the match for all participants.
    /// </remarks>
    /// <returns>Match declined</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("matchmaking/decline")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> DeclineMatch([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeclineMatchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var statusCode = await _implementation.DeclineMatchAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode);
    }

    /// <summary>
    /// Get queue statistics
    /// </summary>
    /// <remarks>
    /// Get operational statistics for matchmaking queues.
    /// <br/>Includes queue depths, average wait times, and match rates.
    /// </remarks>
    /// <returns>Statistics retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("matchmaking/stats")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MatchmakingStatsResponse>> GetMatchmakingStats([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetMatchmakingStatsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetMatchmakingStatsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }



    #region Meta Endpoints for ListQueues

    private static readonly string _ListQueues_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListQueuesRequest",
    "$defs": {
        "ListQueuesRequest": {
            "type": "object",
            "description": "Request to list available matchmaking queues",
            "additionalProperties": false,
            "properties": {
                "gameId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by game ID (null for all games)"
                },
                "includeDisabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "Include disabled queues in the list (admin only)"
                }
            }
        }
    }
}
""";

    private static readonly string _ListQueues_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListQueuesResponse",
    "$defs": {
        "ListQueuesResponse": {
            "type": "object",
            "description": "Response containing available matchmaking queues",
            "additionalProperties": false,
            "required": [
                "queues"
            ],
            "properties": {
                "queues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/QueueSummary"
                    },
                    "description": "List of available queues"
                }
            }
        },
        "QueueSummary": {
            "type": "object",
            "description": "Summary information about a matchmaking queue",
            "additionalProperties": false,
            "required": [
                "queueId",
                "gameId",
                "displayName",
                "enabled",
                "minCount",
                "maxCount"
            ],
            "properties": {
                "queueId": {
                    "type": "string",
                    "description": "Unique identifier for the queue"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game this queue is for"
                },
                "displayName": {
                    "type": "string",
                    "description": "Human-readable queue name"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the queue is currently accepting tickets"
                },
                "minCount": {
                    "type": "integer",
                    "description": "Minimum players required for a match"
                },
                "maxCount": {
                    "type": "integer",
                    "description": "Maximum players in a match"
                },
                "currentTickets": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Current number of tickets in queue (if available)"
                },
                "averageWaitSeconds": {
                    "type": "number",
                    "nullable": true,
                    "description": "Average wait time in seconds (if available)"
                }
            }
        }
    }
}
""";

    private static readonly string _ListQueues_Info = """
{
    "summary": "List available matchmaking queues",
    "description": "List all available matchmaking queues that players can join.\nReturns queue configuration details including skill settings.\n",
    "tags": [
        "Queues"
    ],
    "deprecated": false,
    "operationId": "listQueues"
}
""";

    /// <summary>Returns endpoint information for ListQueues</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListQueues_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/list",
            _ListQueues_Info));

    /// <summary>Returns request schema for ListQueues</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListQueues_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/list",
            "request-schema",
            _ListQueues_RequestSchema));

    /// <summary>Returns response schema for ListQueues</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListQueues_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/list",
            "response-schema",
            _ListQueues_ResponseSchema));

    /// <summary>Returns full schema for ListQueues</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListQueues_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/list",
            _ListQueues_Info,
            _ListQueues_RequestSchema,
            _ListQueues_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetQueue

    private static readonly string _GetQueue_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetQueueRequest",
    "$defs": {
        "GetQueueRequest": {
            "type": "object",
            "description": "Request to get details of a specific queue",
            "additionalProperties": false,
            "required": [
                "queueId"
            ],
            "properties": {
                "queueId": {
                    "type": "string",
                    "description": "ID of the queue to retrieve"
                }
            }
        }
    }
}
""";

    private static readonly string _GetQueue_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueueResponse",
    "$defs": {
        "QueueResponse": {
            "type": "object",
            "description": "Full configuration details of a matchmaking queue",
            "additionalProperties": false,
            "required": [
                "queueId",
                "gameId",
                "displayName",
                "enabled",
                "minCount",
                "maxCount",
                "countMultiple",
                "intervalSeconds",
                "maxIntervals",
                "createdAt"
            ],
            "properties": {
                "queueId": {
                    "type": "string",
                    "description": "Unique identifier for the queue"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game this queue is for"
                },
                "displayName": {
                    "type": "string",
                    "description": "Human-readable queue name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Detailed description of the queue"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the queue is currently accepting tickets"
                },
                "minCount": {
                    "type": "integer",
                    "minimum": 2,
                    "description": "Minimum players required for a match"
                },
                "maxCount": {
                    "type": "integer",
                    "maximum": 200,
                    "description": "Maximum players in a match"
                },
                "countMultiple": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Player count must be divisible by this (e.g., 2 for pairs)"
                },
                "intervalSeconds": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Seconds between match processing intervals"
                },
                "maxIntervals": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Maximum intervals before relaxing to minCount"
                },
                "skillExpansion": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SkillExpansionStep"
                    },
                    "nullable": true,
                    "description": "Skill window expansion steps"
                },
                "partySkillAggregation": {
                    "$ref": "#/$defs/PartySkillAggregation",
                    "description": "How to calculate party skill rating"
                },
                "partySkillWeights": {
                    "type": "array",
                    "items": {
                        "type": "number"
                    },
                    "nullable": true,
                    "description": "Weights for weighted party skill aggregation"
                },
                "partyMaxSize": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum party size for this queue"
                },
                "allowConcurrent": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether players can be in multiple queues"
                },
                "exclusiveGroup": {
                    "type": "string",
                    "nullable": true,
                    "description": "Exclusive group name (player can only be in one queue of the group)"
                },
                "useSkillRating": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether to use lib-analytics skill rating for matching"
                },
                "ratingCategory": {
                    "type": "string",
                    "nullable": true,
                    "description": "lib-analytics rating category to use"
                },
                "startWhenMinimumReached": {
                    "type": "boolean",
                    "default": false,
                    "description": "Start match with minCount after maxIntervals (for large lobbies)"
                },
                "requiresRegistration": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether players must be registered for a tournament"
                },
                "tournamentIdRequired": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether a tournament ID is required to join"
                },
                "matchAcceptTimeoutSeconds": {
                    "type": "integer",
                    "default": 30,
                    "description": "Seconds players have to accept/decline a formed match"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the queue was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the queue was last updated"
                }
            }
        },
        "SkillExpansionStep": {
            "type": "object",
            "description": "A step in the skill window expansion curve",
            "additionalProperties": false,
            "required": [
                "intervals"
            ],
            "properties": {
                "intervals": {
                    "type": "integer",
                    "minimum": 0,
                    "description": "Number of intervals after which this step applies"
                },
                "range": {
                    "type": "integer",
                    "nullable": true,
                    "minimum": 0,
                    "description": "Skill range (null means any skill level)"
                }
            }
        },
        "PartySkillAggregation": {
            "type": "string",
            "description": "Method for aggregating party member skills",
            "enum": [
                "highest",
                "average",
                "weighted"
            ]
        }
    }
}
""";

    private static readonly string _GetQueue_Info = """
{
    "summary": "Get queue details",
    "description": "Get detailed configuration for a specific matchmaking queue.\n",
    "tags": [
        "Queues"
    ],
    "deprecated": false,
    "operationId": "getQueue"
}
""";

    /// <summary>Returns endpoint information for GetQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetQueue_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/get",
            _GetQueue_Info));

    /// <summary>Returns request schema for GetQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetQueue_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/get",
            "request-schema",
            _GetQueue_RequestSchema));

    /// <summary>Returns response schema for GetQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetQueue_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/get",
            "response-schema",
            _GetQueue_ResponseSchema));

    /// <summary>Returns full schema for GetQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetQueue_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/get",
            _GetQueue_Info,
            _GetQueue_RequestSchema,
            _GetQueue_ResponseSchema));

    #endregion

    #region Meta Endpoints for CreateQueue

    private static readonly string _CreateQueue_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateQueueRequest",
    "$defs": {
        "CreateQueueRequest": {
            "type": "object",
            "description": "Request to create a new matchmaking queue",
            "additionalProperties": false,
            "required": [
                "queueId",
                "gameId",
                "displayName",
                "minCount",
                "maxCount"
            ],
            "properties": {
                "queueId": {
                    "type": "string",
                    "minLength": 1,
                    "maxLength": 64,
                    "pattern": "^[a-z0-9-]+$",
                    "description": "Unique identifier for the queue (lowercase alphanumeric with hyphens)"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game this queue is for"
                },
                "displayName": {
                    "type": "string",
                    "maxLength": 100,
                    "description": "Human-readable queue name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "maxLength": 500,
                    "description": "Detailed description of the queue"
                },
                "minCount": {
                    "type": "integer",
                    "minimum": 2,
                    "maximum": 200,
                    "description": "Minimum players required for a match"
                },
                "maxCount": {
                    "type": "integer",
                    "minimum": 2,
                    "maximum": 200,
                    "description": "Maximum players in a match"
                },
                "countMultiple": {
                    "type": "integer",
                    "minimum": 1,
                    "default": 1,
                    "description": "Player count must be divisible by this"
                },
                "intervalSeconds": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 300,
                    "default": 15,
                    "description": "Seconds between match processing intervals"
                },
                "maxIntervals": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 100,
                    "default": 6,
                    "description": "Maximum intervals before relaxing to minCount"
                },
                "skillExpansion": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SkillExpansionStep"
                    },
                    "nullable": true,
                    "description": "Skill window expansion steps"
                },
                "partySkillAggregation": {
                    "$ref": "#/$defs/PartySkillAggregation",
                    "description": "How to calculate party skill rating"
                },
                "partySkillWeights": {
                    "type": "array",
                    "items": {
                        "type": "number"
                    },
                    "nullable": true,
                    "description": "Weights for weighted party skill aggregation"
                },
                "partyMaxSize": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "Maximum party size for this queue"
                },
                "allowConcurrent": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether players can be in multiple queues"
                },
                "exclusiveGroup": {
                    "type": "string",
                    "nullable": true,
                    "maxLength": 64,
                    "description": "Exclusive group name"
                },
                "useSkillRating": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether to use lib-analytics skill rating"
                },
                "ratingCategory": {
                    "type": "string",
                    "nullable": true,
                    "description": "lib-analytics rating category to use"
                },
                "startWhenMinimumReached": {
                    "type": "boolean",
                    "default": false,
                    "description": "Start match with minCount after maxIntervals"
                },
                "requiresRegistration": {
                    "type": "boolean",
                    "default": false,
                    "description": "Require tournament registration"
                },
                "tournamentIdRequired": {
                    "type": "boolean",
                    "default": false,
                    "description": "Require tournament ID to join"
                },
                "matchAcceptTimeoutSeconds": {
                    "type": "integer",
                    "minimum": 10,
                    "maximum": 120,
                    "default": 30,
                    "description": "Seconds to accept/decline a match"
                }
            }
        },
        "SkillExpansionStep": {
            "type": "object",
            "description": "A step in the skill window expansion curve",
            "additionalProperties": false,
            "required": [
                "intervals"
            ],
            "properties": {
                "intervals": {
                    "type": "integer",
                    "minimum": 0,
                    "description": "Number of intervals after which this step applies"
                },
                "range": {
                    "type": "integer",
                    "nullable": true,
                    "minimum": 0,
                    "description": "Skill range (null means any skill level)"
                }
            }
        },
        "PartySkillAggregation": {
            "type": "string",
            "description": "Method for aggregating party member skills",
            "enum": [
                "highest",
                "average",
                "weighted"
            ]
        }
    }
}
""";

    private static readonly string _CreateQueue_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueueResponse",
    "$defs": {
        "QueueResponse": {
            "type": "object",
            "description": "Full configuration details of a matchmaking queue",
            "additionalProperties": false,
            "required": [
                "queueId",
                "gameId",
                "displayName",
                "enabled",
                "minCount",
                "maxCount",
                "countMultiple",
                "intervalSeconds",
                "maxIntervals",
                "createdAt"
            ],
            "properties": {
                "queueId": {
                    "type": "string",
                    "description": "Unique identifier for the queue"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game this queue is for"
                },
                "displayName": {
                    "type": "string",
                    "description": "Human-readable queue name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Detailed description of the queue"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the queue is currently accepting tickets"
                },
                "minCount": {
                    "type": "integer",
                    "minimum": 2,
                    "description": "Minimum players required for a match"
                },
                "maxCount": {
                    "type": "integer",
                    "maximum": 200,
                    "description": "Maximum players in a match"
                },
                "countMultiple": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Player count must be divisible by this (e.g., 2 for pairs)"
                },
                "intervalSeconds": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Seconds between match processing intervals"
                },
                "maxIntervals": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Maximum intervals before relaxing to minCount"
                },
                "skillExpansion": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SkillExpansionStep"
                    },
                    "nullable": true,
                    "description": "Skill window expansion steps"
                },
                "partySkillAggregation": {
                    "$ref": "#/$defs/PartySkillAggregation",
                    "description": "How to calculate party skill rating"
                },
                "partySkillWeights": {
                    "type": "array",
                    "items": {
                        "type": "number"
                    },
                    "nullable": true,
                    "description": "Weights for weighted party skill aggregation"
                },
                "partyMaxSize": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum party size for this queue"
                },
                "allowConcurrent": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether players can be in multiple queues"
                },
                "exclusiveGroup": {
                    "type": "string",
                    "nullable": true,
                    "description": "Exclusive group name (player can only be in one queue of the group)"
                },
                "useSkillRating": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether to use lib-analytics skill rating for matching"
                },
                "ratingCategory": {
                    "type": "string",
                    "nullable": true,
                    "description": "lib-analytics rating category to use"
                },
                "startWhenMinimumReached": {
                    "type": "boolean",
                    "default": false,
                    "description": "Start match with minCount after maxIntervals (for large lobbies)"
                },
                "requiresRegistration": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether players must be registered for a tournament"
                },
                "tournamentIdRequired": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether a tournament ID is required to join"
                },
                "matchAcceptTimeoutSeconds": {
                    "type": "integer",
                    "default": 30,
                    "description": "Seconds players have to accept/decline a formed match"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the queue was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the queue was last updated"
                }
            }
        },
        "SkillExpansionStep": {
            "type": "object",
            "description": "A step in the skill window expansion curve",
            "additionalProperties": false,
            "required": [
                "intervals"
            ],
            "properties": {
                "intervals": {
                    "type": "integer",
                    "minimum": 0,
                    "description": "Number of intervals after which this step applies"
                },
                "range": {
                    "type": "integer",
                    "nullable": true,
                    "minimum": 0,
                    "description": "Skill range (null means any skill level)"
                }
            }
        },
        "PartySkillAggregation": {
            "type": "string",
            "description": "Method for aggregating party member skills",
            "enum": [
                "highest",
                "average",
                "weighted"
            ]
        }
    }
}
""";

    private static readonly string _CreateQueue_Info = """
{
    "summary": "Create a new matchmaking queue",
    "description": "Create a new matchmaking queue with specified configuration.\nAdmin only. Queue configuration includes skill settings, party limits,\ nand exclusive group membership.\n",
    "tags": [
        "Queue Administration"
    ],
    "deprecated": false,
    "operationId": "createQueue"
}
""";

    /// <summary>Returns endpoint information for CreateQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateQueue_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/create",
            _CreateQueue_Info));

    /// <summary>Returns request schema for CreateQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateQueue_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/create",
            "request-schema",
            _CreateQueue_RequestSchema));

    /// <summary>Returns response schema for CreateQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateQueue_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/create",
            "response-schema",
            _CreateQueue_ResponseSchema));

    /// <summary>Returns full schema for CreateQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateQueue_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/create",
            _CreateQueue_Info,
            _CreateQueue_RequestSchema,
            _CreateQueue_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateQueue

    private static readonly string _UpdateQueue_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateQueueRequest",
    "$defs": {
        "UpdateQueueRequest": {
            "type": "object",
            "description": "Request to update a matchmaking queue",
            "additionalProperties": false,
            "required": [
                "queueId"
            ],
            "properties": {
                "queueId": {
                    "type": "string",
                    "description": "ID of the queue to update"
                },
                "displayName": {
                    "type": "string",
                    "nullable": true,
                    "maxLength": 100,
                    "description": "New display name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "maxLength": 500,
                    "description": "New description"
                },
                "enabled": {
                    "type": "boolean",
                    "nullable": true,
                    "description": "Enable or disable the queue"
                },
                "minCount": {
                    "type": "integer",
                    "minimum": 2,
                    "nullable": true,
                    "description": "New minimum count"
                },
                "maxCount": {
                    "type": "integer",
                    "maximum": 200,
                    "nullable": true,
                    "description": "New maximum count"
                },
                "countMultiple": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "New count multiple"
                },
                "intervalSeconds": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 300,
                    "nullable": true,
                    "description": "New interval seconds"
                },
                "maxIntervals": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 100,
                    "nullable": true,
                    "description": "New max intervals"
                },
                "skillExpansion": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SkillExpansionStep"
                    },
                    "nullable": true,
                    "description": "New skill expansion steps"
                },
                "partySkillAggregation": {
                    "$ref": "#/$defs/PartySkillAggregation",
                    "nullable": true,
                    "description": "New party skill aggregation method"
                },
                "partyMaxSize": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "New party max size"
                },
                "matchAcceptTimeoutSeconds": {
                    "type": "integer",
                    "minimum": 10,
                    "maximum": 120,
                    "nullable": true,
                    "description": "New match accept timeout"
                }
            }
        },
        "SkillExpansionStep": {
            "type": "object",
            "description": "A step in the skill window expansion curve",
            "additionalProperties": false,
            "required": [
                "intervals"
            ],
            "properties": {
                "intervals": {
                    "type": "integer",
                    "minimum": 0,
                    "description": "Number of intervals after which this step applies"
                },
                "range": {
                    "type": "integer",
                    "nullable": true,
                    "minimum": 0,
                    "description": "Skill range (null means any skill level)"
                }
            }
        },
        "PartySkillAggregation": {
            "type": "string",
            "description": "Method for aggregating party member skills",
            "enum": [
                "highest",
                "average",
                "weighted"
            ]
        }
    }
}
""";

    private static readonly string _UpdateQueue_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueueResponse",
    "$defs": {
        "QueueResponse": {
            "type": "object",
            "description": "Full configuration details of a matchmaking queue",
            "additionalProperties": false,
            "required": [
                "queueId",
                "gameId",
                "displayName",
                "enabled",
                "minCount",
                "maxCount",
                "countMultiple",
                "intervalSeconds",
                "maxIntervals",
                "createdAt"
            ],
            "properties": {
                "queueId": {
                    "type": "string",
                    "description": "Unique identifier for the queue"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game this queue is for"
                },
                "displayName": {
                    "type": "string",
                    "description": "Human-readable queue name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Detailed description of the queue"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the queue is currently accepting tickets"
                },
                "minCount": {
                    "type": "integer",
                    "minimum": 2,
                    "description": "Minimum players required for a match"
                },
                "maxCount": {
                    "type": "integer",
                    "maximum": 200,
                    "description": "Maximum players in a match"
                },
                "countMultiple": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Player count must be divisible by this (e.g., 2 for pairs)"
                },
                "intervalSeconds": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Seconds between match processing intervals"
                },
                "maxIntervals": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Maximum intervals before relaxing to minCount"
                },
                "skillExpansion": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SkillExpansionStep"
                    },
                    "nullable": true,
                    "description": "Skill window expansion steps"
                },
                "partySkillAggregation": {
                    "$ref": "#/$defs/PartySkillAggregation",
                    "description": "How to calculate party skill rating"
                },
                "partySkillWeights": {
                    "type": "array",
                    "items": {
                        "type": "number"
                    },
                    "nullable": true,
                    "description": "Weights for weighted party skill aggregation"
                },
                "partyMaxSize": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum party size for this queue"
                },
                "allowConcurrent": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether players can be in multiple queues"
                },
                "exclusiveGroup": {
                    "type": "string",
                    "nullable": true,
                    "description": "Exclusive group name (player can only be in one queue of the group)"
                },
                "useSkillRating": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether to use lib-analytics skill rating for matching"
                },
                "ratingCategory": {
                    "type": "string",
                    "nullable": true,
                    "description": "lib-analytics rating category to use"
                },
                "startWhenMinimumReached": {
                    "type": "boolean",
                    "default": false,
                    "description": "Start match with minCount after maxIntervals (for large lobbies)"
                },
                "requiresRegistration": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether players must be registered for a tournament"
                },
                "tournamentIdRequired": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether a tournament ID is required to join"
                },
                "matchAcceptTimeoutSeconds": {
                    "type": "integer",
                    "default": 30,
                    "description": "Seconds players have to accept/decline a formed match"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the queue was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the queue was last updated"
                }
            }
        },
        "SkillExpansionStep": {
            "type": "object",
            "description": "A step in the skill window expansion curve",
            "additionalProperties": false,
            "required": [
                "intervals"
            ],
            "properties": {
                "intervals": {
                    "type": "integer",
                    "minimum": 0,
                    "description": "Number of intervals after which this step applies"
                },
                "range": {
                    "type": "integer",
                    "nullable": true,
                    "minimum": 0,
                    "description": "Skill range (null means any skill level)"
                }
            }
        },
        "PartySkillAggregation": {
            "type": "string",
            "description": "Method for aggregating party member skills",
            "enum": [
                "highest",
                "average",
                "weighted"
            ]
        }
    }
}
""";

    private static readonly string _UpdateQueue_Info = """
{
    "summary": "Update a matchmaking queue",
    "description": "Update configuration of an existing matchmaking queue.\nAdmin only. Changes take effect for new tickets only.\n",
    "tags": [
        "Queue Administration"
    ],
    "deprecated": false,
    "operationId": "updateQueue"
}
""";

    /// <summary>Returns endpoint information for UpdateQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateQueue_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/update",
            _UpdateQueue_Info));

    /// <summary>Returns request schema for UpdateQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateQueue_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/update",
            "request-schema",
            _UpdateQueue_RequestSchema));

    /// <summary>Returns response schema for UpdateQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateQueue_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/update",
            "response-schema",
            _UpdateQueue_ResponseSchema));

    /// <summary>Returns full schema for UpdateQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateQueue_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/update",
            _UpdateQueue_Info,
            _UpdateQueue_RequestSchema,
            _UpdateQueue_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeleteQueue

    private static readonly string _DeleteQueue_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteQueueRequest",
    "$defs": {
        "DeleteQueueRequest": {
            "type": "object",
            "description": "Request to delete a matchmaking queue",
            "additionalProperties": false,
            "required": [
                "queueId"
            ],
            "properties": {
                "queueId": {
                    "type": "string",
                    "description": "ID of the queue to delete"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteQueue_ResponseSchema = """
{}
""";

    private static readonly string _DeleteQueue_Info = """
{
    "summary": "Delete a matchmaking queue",
    "description": "Delete a matchmaking queue. Admin only.\nExisting tickets in the queue will be cancelled with reason 'queue_disabled'.\n",
    "tags": [
        "Queue Administration"
    ],
    "deprecated": false,
    "operationId": "deleteQueue"
}
""";

    /// <summary>Returns endpoint information for DeleteQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteQueue_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/delete",
            _DeleteQueue_Info));

    /// <summary>Returns request schema for DeleteQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteQueue_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/delete",
            "request-schema",
            _DeleteQueue_RequestSchema));

    /// <summary>Returns response schema for DeleteQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteQueue_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/delete",
            "response-schema",
            _DeleteQueue_ResponseSchema));

    /// <summary>Returns full schema for DeleteQueue</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/queue/delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteQueue_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/queue/delete",
            _DeleteQueue_Info,
            _DeleteQueue_RequestSchema,
            _DeleteQueue_ResponseSchema));

    #endregion

    #region Meta Endpoints for JoinMatchmaking

    private static readonly string _JoinMatchmaking_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/JoinMatchmakingRequest",
    "$defs": {
        "JoinMatchmakingRequest": {
            "type": "object",
            "description": "Request to join a matchmaking queue",
            "additionalProperties": false,
            "required": [
                "webSocketSessionId",
                "accountId",
                "queueId"
            ],
            "properties": {
                "webSocketSessionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "WebSocket session ID for event delivery"
                },
                "accountId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Account ID of the player joining"
                },
                "queueId": {
                    "type": "string",
                    "description": "ID of the queue to join"
                },
                "partyId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Party ID if joining as part of a party"
                },
                "partyMembers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/PartyMemberInfo"
                    },
                    "nullable": true,
                    "description": "Party member information (required if partyId provided)"
                },
                "stringProperties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "String properties for query matching"
                },
                "numericProperties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "number"
                    },
                    "nullable": true,
                    "description": "Numeric properties for query matching"
                },
                "query": {
                    "type": "string",
                    "nullable": true,
                    "maxLength": 1000,
                    "description": "Lucene-like query for opponent matching"
                },
                "tournamentId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Tournament ID if joining tournament queue"
                }
            }
        },
        "PartyMemberInfo": {
            "type": "object",
            "description": "Information about a party member for matchmaking",
            "additionalProperties": false,
            "required": [
                "accountId",
                "webSocketSessionId"
            ],
            "properties": {
                "accountId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Account ID of the party member"
                },
                "webSocketSessionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "WebSocket session ID for event delivery"
                },
                "skillRating": {
                    "type": "number",
                    "nullable": true,
                    "description": "Pre-fetched skill rating (optional, will be looked up if not provided)"
                }
            }
        }
    }
}
""";

    private static readonly string _JoinMatchmaking_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/JoinMatchmakingResponse",
    "$defs": {
        "JoinMatchmakingResponse": {
            "type": "object",
            "description": "Response after joining a matchmaking queue",
            "additionalProperties": false,
            "required": [
                "ticketId",
                "queueId",
                "estimatedWaitSeconds"
            ],
            "properties": {
                "ticketId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this matchmaking ticket"
                },
                "queueId": {
                    "type": "string",
                    "description": "Queue that was joined"
                },
                "estimatedWaitSeconds": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Estimated wait time based on current queue (null if unknown)"
                },
                "position": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Approximate position in queue (null if not tracked)"
                }
            }
        }
    }
}
""";

    private static readonly string _JoinMatchmaking_Info = """
{
    "summary": "Join matchmaking queue",
    "description": "Join a matchmaking queue with specified properties and query.\nCreates a matchmaking ticket and begins searching for compatible players.\ nReturns immediately after ticket creation. Match results are delivered\nvia WebSocket push events.\n",
    "tags": [
        "Matchmaking"
    ],
    "deprecated": false,
    "operationId": "joinMatchmaking"
}
""";

    /// <summary>Returns endpoint information for JoinMatchmaking</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/join/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> JoinMatchmaking_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Matchmaking",
            "Post",
            "matchmaking/join",
            _JoinMatchmaking_Info));

    /// <summary>Returns request schema for JoinMatchmaking</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/join/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> JoinMatchmaking_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/join",
            "request-schema",
            _JoinMatchmaking_RequestSchema));

    /// <summary>Returns response schema for JoinMatchmaking</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/join/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> JoinMatchmaking_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/join",
            "response-schema",
            _JoinMatchmaking_ResponseSchema));

    /// <summary>Returns full schema for JoinMatchmaking</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/join/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> JoinMatchmaking_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/join",
            _JoinMatchmaking_Info,
            _JoinMatchmaking_RequestSchema,
            _JoinMatchmaking_ResponseSchema));

    #endregion

    #region Meta Endpoints for LeaveMatchmaking

    private static readonly string _LeaveMatchmaking_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/LeaveMatchmakingRequest",
    "$defs": {
        "LeaveMatchmakingRequest": {
            "type": "object",
            "description": "Request to leave a matchmaking queue",
            "additionalProperties": false,
            "required": [
                "webSocketSessionId",
                "accountId",
                "ticketId"
            ],
            "properties": {
                "webSocketSessionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "WebSocket session ID"
                },
                "accountId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Account ID of the player"
                },
                "ticketId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the ticket to cancel"
                }
            }
        }
    }
}
""";

    private static readonly string _LeaveMatchmaking_ResponseSchema = """
{}
""";

    private static readonly string _LeaveMatchmaking_Info = """
{
    "summary": "Leave matchmaking queue",
    "description": "Leave a matchmaking queue and cancel the ticket.\nOnly available when actively in a queue (shortcut/prebound).\n",
    "tags": [
        "Matchmaking"
    ],
    "deprecated": false,
    "operationId": "leaveMatchmaking"
}
""";

    /// <summary>Returns endpoint information for LeaveMatchmaking</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/leave/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> LeaveMatchmaking_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Matchmaking",
            "Post",
            "matchmaking/leave",
            _LeaveMatchmaking_Info));

    /// <summary>Returns request schema for LeaveMatchmaking</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/leave/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> LeaveMatchmaking_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/leave",
            "request-schema",
            _LeaveMatchmaking_RequestSchema));

    /// <summary>Returns response schema for LeaveMatchmaking</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/leave/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> LeaveMatchmaking_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/leave",
            "response-schema",
            _LeaveMatchmaking_ResponseSchema));

    /// <summary>Returns full schema for LeaveMatchmaking</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/leave/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> LeaveMatchmaking_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/leave",
            _LeaveMatchmaking_Info,
            _LeaveMatchmaking_RequestSchema,
            _LeaveMatchmaking_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetMatchmakingStatus

    private static readonly string _GetMatchmakingStatus_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetMatchmakingStatusRequest",
    "$defs": {
        "GetMatchmakingStatusRequest": {
            "type": "object",
            "description": "Request to get matchmaking status",
            "additionalProperties": false,
            "required": [
                "webSocketSessionId",
                "accountId",
                "ticketId"
            ],
            "properties": {
                "webSocketSessionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "WebSocket session ID"
                },
                "accountId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Account ID of the player"
                },
                "ticketId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the ticket to query"
                }
            }
        }
    }
}
""";

    private static readonly string _GetMatchmakingStatus_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/MatchmakingStatusResponse",
    "$defs": {
        "MatchmakingStatusResponse": {
            "type": "object",
            "description": "Current matchmaking status for a ticket",
            "additionalProperties": false,
            "required": [
                "ticketId",
                "queueId",
                "status",
                "intervalsElapsed",
                "createdAt"
            ],
            "properties": {
                "ticketId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Ticket identifier"
                },
                "queueId": {
                    "type": "string",
                    "description": "Queue the ticket is in"
                },
                "status": {
                    "$ref": "#/$defs/TicketStatus",
                    "description": "Current ticket status"
                },
                "intervalsElapsed": {
                    "type": "integer",
                    "description": "Number of processing intervals elapsed"
                },
                "currentSkillRange": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Current skill matching range (null if skill not used)"
                },
                "estimatedWaitSeconds": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Updated estimated wait time"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the ticket was created"
                },
                "matchId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Match ID if a match has been found"
                }
            }
        },
        "TicketStatus": {
            "type": "string",
            "description": "Current status of a matchmaking ticket",
            "enum": [
                "searching",
                "match_found",
                "match_accepted",
                "cancelled",
                "expired"
            ]
        }
    }
}
""";

    private static readonly string _GetMatchmakingStatus_Info = """
{
    "summary": "Get matchmaking status",
    "description": "Get current matchmaking status for the player's active ticket.\nOnly available when actively in a queue (shortcut/prebound).\n",
    "tags": [
        "Matchmaking"
    ],
    "deprecated": false,
    "operationId": "getMatchmakingStatus"
}
""";

    /// <summary>Returns endpoint information for GetMatchmakingStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/status/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetMatchmakingStatus_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Matchmaking",
            "Post",
            "matchmaking/status",
            _GetMatchmakingStatus_Info));

    /// <summary>Returns request schema for GetMatchmakingStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/status/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetMatchmakingStatus_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/status",
            "request-schema",
            _GetMatchmakingStatus_RequestSchema));

    /// <summary>Returns response schema for GetMatchmakingStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/status/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetMatchmakingStatus_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/status",
            "response-schema",
            _GetMatchmakingStatus_ResponseSchema));

    /// <summary>Returns full schema for GetMatchmakingStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/status/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetMatchmakingStatus_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/status",
            _GetMatchmakingStatus_Info,
            _GetMatchmakingStatus_RequestSchema,
            _GetMatchmakingStatus_ResponseSchema));

    #endregion

    #region Meta Endpoints for AcceptMatch

    private static readonly string _AcceptMatch_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AcceptMatchRequest",
    "$defs": {
        "AcceptMatchRequest": {
            "type": "object",
            "description": "Request to accept a formed match",
            "additionalProperties": false,
            "required": [
                "webSocketSessionId",
                "accountId",
                "matchId"
            ],
            "properties": {
                "webSocketSessionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "WebSocket session ID"
                },
                "accountId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Account ID of the player"
                },
                "matchId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the match to accept"
                }
            }
        }
    }
}
""";

    private static readonly string _AcceptMatch_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AcceptMatchResponse",
    "$defs": {
        "AcceptMatchResponse": {
            "type": "object",
            "description": "Response after accepting a match",
            "additionalProperties": false,
            "required": [
                "matchId",
                "allAccepted"
            ],
            "properties": {
                "matchId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Match identifier"
                },
                "allAccepted": {
                    "type": "boolean",
                    "description": "Whether all players have accepted"
                },
                "acceptedCount": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Number of players who have accepted"
                },
                "totalCount": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Total players who need to accept"
                },
                "gameSessionId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Game session ID (set when all players accept)"
                }
            }
        }
    }
}
""";

    private static readonly string _AcceptMatch_Info = """
{
    "summary": "Accept a formed match",
    "description": "Accept a match that has been formed. Only available when a match\nis pending acceptance (shortcut/prebound after match formation).\nAll players must accept within the timeout for the match to start.\n",
    "tags": [
        "Matchmaking"
    ],
    "deprecated": false,
    "operationId": "acceptMatch"
}
""";

    /// <summary>Returns endpoint information for AcceptMatch</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/accept/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AcceptMatch_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Matchmaking",
            "Post",
            "matchmaking/accept",
            _AcceptMatch_Info));

    /// <summary>Returns request schema for AcceptMatch</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/accept/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AcceptMatch_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/accept",
            "request-schema",
            _AcceptMatch_RequestSchema));

    /// <summary>Returns response schema for AcceptMatch</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/accept/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AcceptMatch_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/accept",
            "response-schema",
            _AcceptMatch_ResponseSchema));

    /// <summary>Returns full schema for AcceptMatch</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/accept/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AcceptMatch_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/accept",
            _AcceptMatch_Info,
            _AcceptMatch_RequestSchema,
            _AcceptMatch_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeclineMatch

    private static readonly string _DeclineMatch_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeclineMatchRequest",
    "$defs": {
        "DeclineMatchRequest": {
            "type": "object",
            "description": "Request to decline a formed match",
            "additionalProperties": false,
            "required": [
                "webSocketSessionId",
                "accountId",
                "matchId"
            ],
            "properties": {
                "webSocketSessionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "WebSocket session ID"
                },
                "accountId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Account ID of the player"
                },
                "matchId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the match to decline"
                }
            }
        }
    }
}
""";

    private static readonly string _DeclineMatch_ResponseSchema = """
{}
""";

    private static readonly string _DeclineMatch_Info = """
{
    "summary": "Decline a formed match",
    "description": "Decline a match that has been formed. Only available when a match\nis pending acceptance (shortcut/prebound after match formation).\nDeclining cancels the match for all participants.\n",
    "tags": [
        "Matchmaking"
    ],
    "deprecated": false,
    "operationId": "declineMatch"
}
""";

    /// <summary>Returns endpoint information for DeclineMatch</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/decline/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeclineMatch_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Matchmaking",
            "Post",
            "matchmaking/decline",
            _DeclineMatch_Info));

    /// <summary>Returns request schema for DeclineMatch</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/decline/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeclineMatch_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/decline",
            "request-schema",
            _DeclineMatch_RequestSchema));

    /// <summary>Returns response schema for DeclineMatch</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/decline/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeclineMatch_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/decline",
            "response-schema",
            _DeclineMatch_ResponseSchema));

    /// <summary>Returns full schema for DeclineMatch</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/decline/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeclineMatch_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/decline",
            _DeclineMatch_Info,
            _DeclineMatch_RequestSchema,
            _DeclineMatch_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetMatchmakingStats

    private static readonly string _GetMatchmakingStats_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetMatchmakingStatsRequest",
    "$defs": {
        "GetMatchmakingStatsRequest": {
            "type": "object",
            "description": "Request to get matchmaking statistics",
            "additionalProperties": false,
            "properties": {
                "queueId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by specific queue (null for all queues)"
                },
                "gameId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by game ID"
                }
            }
        }
    }
}
""";

    private static readonly string _GetMatchmakingStats_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/MatchmakingStatsResponse",
    "$defs": {
        "MatchmakingStatsResponse": {
            "type": "object",
            "description": "Matchmaking operational statistics",
            "additionalProperties": false,
            "required": [
                "timestamp",
                "queueStats"
            ],
            "properties": {
                "timestamp": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When these stats were collected"
                },
                "queueStats": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/QueueStats"
                    },
                    "description": "Statistics per queue"
                }
            }
        },
        "QueueStats": {
            "type": "object",
            "description": "Statistics for a single matchmaking queue",
            "additionalProperties": false,
            "required": [
                "queueId",
                "currentTickets",
                "matchesFormedLastHour",
                "averageWaitSeconds"
            ],
            "properties": {
                "queueId": {
                    "type": "string",
                    "description": "Queue identifier"
                },
                "currentTickets": {
                    "type": "integer",
                    "description": "Number of active tickets"
                },
                "matchesFormedLastHour": {
                    "type": "integer",
                    "description": "Matches formed in the last hour"
                },
                "averageWaitSeconds": {
                    "type": "number",
                    "description": "Average wait time in seconds"
                },
                "medianWaitSeconds": {
                    "type": "number",
                    "nullable": true,
                    "description": "Median wait time in seconds"
                },
                "timeoutRatePercent": {
                    "type": "number",
                    "nullable": true,
                    "description": "Percentage of tickets that timed out"
                },
                "cancelRatePercent": {
                    "type": "number",
                    "nullable": true,
                    "description": "Percentage of tickets cancelled by user"
                }
            }
        }
    }
}
""";

    private static readonly string _GetMatchmakingStats_Info = """
{
    "summary": "Get queue statistics",
    "description": "Get operational statistics for matchmaking queues.\nIncludes queue depths, average wait times, and match rates.\n",
    "tags": [
        "Statistics"
    ],
    "deprecated": false,
    "operationId": "getMatchmakingStats"
}
""";

    /// <summary>Returns endpoint information for GetMatchmakingStats</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/stats/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetMatchmakingStats_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Matchmaking",
            "Post",
            "matchmaking/stats",
            _GetMatchmakingStats_Info));

    /// <summary>Returns request schema for GetMatchmakingStats</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/stats/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetMatchmakingStats_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/stats",
            "request-schema",
            _GetMatchmakingStats_RequestSchema));

    /// <summary>Returns response schema for GetMatchmakingStats</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/stats/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetMatchmakingStats_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/stats",
            "response-schema",
            _GetMatchmakingStats_ResponseSchema));

    /// <summary>Returns full schema for GetMatchmakingStats</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("matchmaking/stats/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetMatchmakingStats_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Matchmaking",
            "Post",
            "matchmaking/stats",
            _GetMatchmakingStats_Info,
            _GetMatchmakingStats_RequestSchema,
            _GetMatchmakingStats_ResponseSchema));

    #endregion

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
