//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     RELATED FILES:
//     - Request/Response models: bannou-service/Generated/Models/{Service}Models.cs
//     - Event models: bannou-service/Generated/Events/{Service}EventsModels.cs
//     - Lifecycle events: bannou-service/Generated/Events/{Service}LifecycleEvents.cs
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Item;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IItemController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Create a new item template
    /// </summary>

    /// <remarks>
    /// Creates a new item definition for a game. Code, gameId, quantityModel, and scope
    /// <br/>are immutable after creation.
    /// </remarks>

    /// <returns>Item template created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> CreateItemTemplateAsync(CreateItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get item template by ID or code
    /// </summary>

    /// <remarks>
    /// Retrieves an item template by its unique ID or by code+gameId combination.
    /// <br/>At least one of templateId or (code + gameId) must be provided.
    /// </remarks>

    /// <returns>Item template retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> GetItemTemplateAsync(GetItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List item templates with filters
    /// </summary>

    /// <remarks>
    /// Lists item templates with optional filtering by gameId, category, tags,
    /// <br/>rarity, scope, and active status.
    /// </remarks>

    /// <returns>Item templates retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListItemTemplatesResponse>> ListItemTemplatesAsync(ListItemTemplatesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update mutable fields of an item template
    /// </summary>

    /// <remarks>
    /// Updates mutable fields of an item template. Code, gameId, quantityModel, and scope
    /// <br/>are immutable after creation and cannot be changed.
    /// </remarks>

    /// <returns>Item template updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> UpdateItemTemplateAsync(UpdateItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Deprecate an item template
    /// </summary>

    /// <remarks>
    /// Marks an item template as deprecated. Deprecated templates cannot be used
    /// <br/>to create new instances but existing instances remain valid. Optionally
    /// <br/>specify a migration target template.
    /// </remarks>

    /// <returns>Item template deprecated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> DeprecateItemTemplateAsync(DeprecateItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create a new item instance
    /// </summary>

    /// <remarks>
    /// Creates a new item instance from a template. The instance must be placed
    /// <br/>in a container (containerId required). Use lib-inventory's /inventory/add
    /// <br/>for most use cases - this endpoint is for low-level instance creation.
    /// </remarks>

    /// <returns>Item instance created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> CreateItemInstanceAsync(CreateItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get item instance by ID
    /// </summary>

    /// <remarks>
    /// Retrieves an item instance by its unique ID.
    /// </remarks>

    /// <returns>Item instance retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> GetItemInstanceAsync(GetItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Modify item instance state
    /// </summary>

    /// <remarks>
    /// Modifies an item instance's mutable state: durability, custom stats,
    /// <br/>custom name, and metadata. Cannot modify bound items unless admin.
    /// </remarks>

    /// <returns>Item instance modified successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> ModifyItemInstanceAsync(ModifyItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Bind item to character
    /// </summary>

    /// <remarks>
    /// Binds an item instance to a character. The bind type must be allowed by
    /// <br/>the template's soulboundType. Once bound, the item cannot be traded.
    /// </remarks>

    /// <returns>Item instance bound successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> BindItemInstanceAsync(BindItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Unbind item from character
    /// </summary>

    /// <remarks>
    /// Removes the binding from a soulbound item. This is an admin-only operation
    /// <br/>for returning bound items to tradeable state. Requires a reason for audit trail.
    /// </remarks>

    /// <returns>Item instance unbound successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> UnbindItemInstanceAsync(UnbindItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Destroy item instance
    /// </summary>

    /// <remarks>
    /// Permanently destroys an item instance. The reason is recorded for audit.
    /// <br/>Cannot destroy bound items unless admin or reason is 'admin'.
    /// </remarks>

    /// <returns>Item instance destroyed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DestroyItemInstanceResponse>> DestroyItemInstanceAsync(DestroyItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Use an item (execute its behavior contract)
    /// </summary>

    /// <remarks>
    /// Uses an item by executing its behavior contract. The item's template must have
    /// <br/>a useBehaviorContractTemplateId defined. Creates a transient contract instance,
    /// <br/>completes the "use" milestone (triggering prebound APIs), and consumes the item
    /// <br/>on success if the template defines it as consumable. Returns failure if the
    /// <br/>contract's prebound APIs fail.
    /// </remarks>

    /// <returns>Item used successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UseItemResponse>> UseItemAsync(UseItemRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Complete a specific step of a multi-step item use
    /// </summary>

    /// <remarks>
    /// For items with multi-milestone use behaviors, completes a specific milestone.
    /// <br/>The first call (without an existing contractInstanceId on the item) creates
    /// <br/>the contract instance and stores it on the item; subsequent calls progress
    /// <br/>the existing contract. Item is consumed only when all required milestones
    /// <br/>are complete (per itemUseBehavior).
    /// </remarks>

    /// <returns>Step completed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UseItemStepResponse>> UseItemStepAsync(UseItemStepRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List items in a container
    /// </summary>

    /// <remarks>
    /// Returns all item instances in the specified container.
    /// </remarks>

    /// <returns>Items retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListItemsResponse>> ListItemsByContainerAsync(ListItemsByContainerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List instances of a template
    /// </summary>

    /// <remarks>
    /// Returns item instances of the specified template, optionally filtered by realm.
    /// <br/>Useful for admin queries and analytics.
    /// </remarks>

    /// <returns>Items retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListItemsResponse>> ListItemsByTemplateAsync(ListItemsByTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get multiple item instances by ID
    /// </summary>

    /// <remarks>
    /// Retrieves multiple item instances in a single request.
    /// </remarks>

    /// <returns>Items retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BatchGetItemInstancesResponse>> BatchGetItemInstancesAsync(BatchGetItemInstancesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class ItemController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IItemService _implementation;
    private BeyondImmersion.BannouService.Services.ITelemetryProvider _telemetryProvider;

    public ItemController(IItemService implementation, BeyondImmersion.BannouService.Services.ITelemetryProvider telemetryProvider)
    {
        _implementation = implementation;
        _telemetryProvider = telemetryProvider;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Create a new item template
    /// </summary>
    /// <remarks>
    /// Creates a new item definition for a game. Code, gameId, quantityModel, and scope
    /// <br/>are immutable after creation.
    /// </remarks>
    /// <returns>Item template created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/template/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> CreateItemTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.CreateItemTemplate",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/template/create");
        try
        {

            var (statusCode, result) = await _implementation.CreateItemTemplateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/template/create");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/template/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "CreateItemTemplate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/template/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get item template by ID or code
    /// </summary>
    /// <remarks>
    /// Retrieves an item template by its unique ID or by code+gameId combination.
    /// <br/>At least one of templateId or (code + gameId) must be provided.
    /// </remarks>
    /// <returns>Item template retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/template/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> GetItemTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.GetItemTemplate",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/template/get");
        try
        {

            var (statusCode, result) = await _implementation.GetItemTemplateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/template/get");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/template/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "GetItemTemplate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/template/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List item templates with filters
    /// </summary>
    /// <remarks>
    /// Lists item templates with optional filtering by gameId, category, tags,
    /// <br/>rarity, scope, and active status.
    /// </remarks>
    /// <returns>Item templates retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/template/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListItemTemplatesResponse>> ListItemTemplates([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListItemTemplatesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.ListItemTemplates",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/template/list");
        try
        {

            var (statusCode, result) = await _implementation.ListItemTemplatesAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/template/list");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/template/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "ListItemTemplates",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/template/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update mutable fields of an item template
    /// </summary>
    /// <remarks>
    /// Updates mutable fields of an item template. Code, gameId, quantityModel, and scope
    /// <br/>are immutable after creation and cannot be changed.
    /// </remarks>
    /// <returns>Item template updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/template/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> UpdateItemTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.UpdateItemTemplate",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/template/update");
        try
        {

            var (statusCode, result) = await _implementation.UpdateItemTemplateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/template/update");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/template/update");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "UpdateItemTemplate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/template/update",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Deprecate an item template
    /// </summary>
    /// <remarks>
    /// Marks an item template as deprecated. Deprecated templates cannot be used
    /// <br/>to create new instances but existing instances remain valid. Optionally
    /// <br/>specify a migration target template.
    /// </remarks>
    /// <returns>Item template deprecated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/template/deprecate")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> DeprecateItemTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeprecateItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.DeprecateItemTemplate",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/template/deprecate");
        try
        {

            var (statusCode, result) = await _implementation.DeprecateItemTemplateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/template/deprecate");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/template/deprecate");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "DeprecateItemTemplate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/template/deprecate",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Create a new item instance
    /// </summary>
    /// <remarks>
    /// Creates a new item instance from a template. The instance must be placed
    /// <br/>in a container (containerId required). Use lib-inventory's /inventory/add
    /// <br/>for most use cases - this endpoint is for low-level instance creation.
    /// </remarks>
    /// <returns>Item instance created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> CreateItemInstance([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.CreateItemInstance",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/instance/create");
        try
        {

            var (statusCode, result) = await _implementation.CreateItemInstanceAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/instance/create");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/instance/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "CreateItemInstance",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/instance/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get item instance by ID
    /// </summary>
    /// <remarks>
    /// Retrieves an item instance by its unique ID.
    /// </remarks>
    /// <returns>Item instance retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> GetItemInstance([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.GetItemInstance",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/instance/get");
        try
        {

            var (statusCode, result) = await _implementation.GetItemInstanceAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/instance/get");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/instance/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "GetItemInstance",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/instance/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Modify item instance state
    /// </summary>
    /// <remarks>
    /// Modifies an item instance's mutable state: durability, custom stats,
    /// <br/>custom name, and metadata. Cannot modify bound items unless admin.
    /// </remarks>
    /// <returns>Item instance modified successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/modify")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> ModifyItemInstance([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ModifyItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.ModifyItemInstance",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/instance/modify");
        try
        {

            var (statusCode, result) = await _implementation.ModifyItemInstanceAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/instance/modify");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/instance/modify");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "ModifyItemInstance",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/instance/modify",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Bind item to character
    /// </summary>
    /// <remarks>
    /// Binds an item instance to a character. The bind type must be allowed by
    /// <br/>the template's soulboundType. Once bound, the item cannot be traded.
    /// </remarks>
    /// <returns>Item instance bound successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/bind")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> BindItemInstance([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BindItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.BindItemInstance",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/instance/bind");
        try
        {

            var (statusCode, result) = await _implementation.BindItemInstanceAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/instance/bind");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/instance/bind");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "BindItemInstance",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/instance/bind",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Unbind item from character
    /// </summary>
    /// <remarks>
    /// Removes the binding from a soulbound item. This is an admin-only operation
    /// <br/>for returning bound items to tradeable state. Requires a reason for audit trail.
    /// </remarks>
    /// <returns>Item instance unbound successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/unbind")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> UnbindItemInstance([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UnbindItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.UnbindItemInstance",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/instance/unbind");
        try
        {

            var (statusCode, result) = await _implementation.UnbindItemInstanceAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/instance/unbind");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/instance/unbind");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "UnbindItemInstance",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/instance/unbind",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Destroy item instance
    /// </summary>
    /// <remarks>
    /// Permanently destroys an item instance. The reason is recorded for audit.
    /// <br/>Cannot destroy bound items unless admin or reason is 'admin'.
    /// </remarks>
    /// <returns>Item instance destroyed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/destroy")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DestroyItemInstanceResponse>> DestroyItemInstance([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DestroyItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.DestroyItemInstance",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/instance/destroy");
        try
        {

            var (statusCode, result) = await _implementation.DestroyItemInstanceAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/instance/destroy");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/instance/destroy");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "DestroyItemInstance",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/instance/destroy",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Use an item (execute its behavior contract)
    /// </summary>
    /// <remarks>
    /// Uses an item by executing its behavior contract. The item's template must have
    /// <br/>a useBehaviorContractTemplateId defined. Creates a transient contract instance,
    /// <br/>completes the "use" milestone (triggering prebound APIs), and consumes the item
    /// <br/>on success if the template defines it as consumable. Returns failure if the
    /// <br/>contract's prebound APIs fail.
    /// </remarks>
    /// <returns>Item used successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/use")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UseItemResponse>> UseItem([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UseItemRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.UseItem",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/use");
        try
        {

            var (statusCode, result) = await _implementation.UseItemAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/use");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/use");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "UseItem",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/use",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Complete a specific step of a multi-step item use
    /// </summary>
    /// <remarks>
    /// For items with multi-milestone use behaviors, completes a specific milestone.
    /// <br/>The first call (without an existing contractInstanceId on the item) creates
    /// <br/>the contract instance and stores it on the item; subsequent calls progress
    /// <br/>the existing contract. Item is consumed only when all required milestones
    /// <br/>are complete (per itemUseBehavior).
    /// </remarks>
    /// <returns>Step completed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/use-step")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UseItemStepResponse>> UseItemStep([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UseItemStepRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.UseItemStep",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/use-step");
        try
        {

            var (statusCode, result) = await _implementation.UseItemStepAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/use-step");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/use-step");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "UseItemStep",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/use-step",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List items in a container
    /// </summary>
    /// <remarks>
    /// Returns all item instances in the specified container.
    /// </remarks>
    /// <returns>Items retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/list-by-container")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListItemsResponse>> ListItemsByContainer([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListItemsByContainerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.ListItemsByContainer",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/instance/list-by-container");
        try
        {

            var (statusCode, result) = await _implementation.ListItemsByContainerAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/instance/list-by-container");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/instance/list-by-container");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "ListItemsByContainer",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/instance/list-by-container",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List instances of a template
    /// </summary>
    /// <remarks>
    /// Returns item instances of the specified template, optionally filtered by realm.
    /// <br/>Useful for admin queries and analytics.
    /// </remarks>
    /// <returns>Items retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/list-by-template")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListItemsResponse>> ListItemsByTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListItemsByTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.ListItemsByTemplate",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/instance/list-by-template");
        try
        {

            var (statusCode, result) = await _implementation.ListItemsByTemplateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/instance/list-by-template");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/instance/list-by-template");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "ListItemsByTemplate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/instance/list-by-template",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get multiple item instances by ID
    /// </summary>
    /// <remarks>
    /// Retrieves multiple item instances in a single request.
    /// </remarks>
    /// <returns>Items retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/batch-get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BatchGetItemInstancesResponse>> BatchGetItemInstances([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BatchGetItemInstancesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.item",
            "ItemController.BatchGetItemInstances",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "item/instance/batch-get");
        try
        {

            var (statusCode, result) = await _implementation.BatchGetItemInstancesAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:item/instance/batch-get");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ItemController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:item/instance/batch-get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "item",
                "BatchGetItemInstances",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:item/instance/batch-get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
