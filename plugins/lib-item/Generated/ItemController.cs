//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     RELATED FILES:
//     - Request/Response models: bannou-service/Generated/Models/{Service}Models.cs
//     - Event models: bannou-service/Generated/Events/{Service}EventsModels.cs
//     - Lifecycle events: bannou-service/Generated/Events/{Service}LifecycleEvents.cs
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Item;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IItemController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Create a new item template
    /// </summary>

    /// <remarks>
    /// Creates a new item definition for a game. Code, gameId, quantityModel, and scope
    /// <br/>are immutable after creation.
    /// </remarks>

    /// <returns>Item template created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> CreateItemTemplateAsync(CreateItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get item template by ID or code
    /// </summary>

    /// <remarks>
    /// Retrieves an item template by its unique ID or by code+gameId combination.
    /// <br/>At least one of templateId or (code + gameId) must be provided.
    /// </remarks>

    /// <returns>Item template retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> GetItemTemplateAsync(GetItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List item templates with filters
    /// </summary>

    /// <remarks>
    /// Lists item templates with optional filtering by gameId, category, tags,
    /// <br/>rarity, scope, and active status.
    /// </remarks>

    /// <returns>Item templates retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListItemTemplatesResponse>> ListItemTemplatesAsync(ListItemTemplatesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update mutable fields of an item template
    /// </summary>

    /// <remarks>
    /// Updates mutable fields of an item template. Code, gameId, quantityModel, and scope
    /// <br/>are immutable after creation and cannot be changed.
    /// </remarks>

    /// <returns>Item template updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> UpdateItemTemplateAsync(UpdateItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Deprecate an item template
    /// </summary>

    /// <remarks>
    /// Marks an item template as deprecated. Deprecated templates cannot be used
    /// <br/>to create new instances but existing instances remain valid. Optionally
    /// <br/>specify a migration target template.
    /// </remarks>

    /// <returns>Item template deprecated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> DeprecateItemTemplateAsync(DeprecateItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create a new item instance
    /// </summary>

    /// <remarks>
    /// Creates a new item instance from a template. The instance must be placed
    /// <br/>in a container (containerId required). Use lib-inventory's /inventory/add
    /// <br/>for most use cases - this endpoint is for low-level instance creation.
    /// </remarks>

    /// <returns>Item instance created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> CreateItemInstanceAsync(CreateItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get item instance by ID
    /// </summary>

    /// <remarks>
    /// Retrieves an item instance by its unique ID.
    /// </remarks>

    /// <returns>Item instance retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> GetItemInstanceAsync(GetItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Modify item instance state
    /// </summary>

    /// <remarks>
    /// Modifies an item instance's mutable state: durability, custom stats,
    /// <br/>custom name, and metadata. Cannot modify bound items unless admin.
    /// </remarks>

    /// <returns>Item instance modified successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> ModifyItemInstanceAsync(ModifyItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Bind item to character
    /// </summary>

    /// <remarks>
    /// Binds an item instance to a character. The bind type must be allowed by
    /// <br/>the template's soulboundType. Once bound, the item cannot be traded.
    /// </remarks>

    /// <returns>Item instance bound successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> BindItemInstanceAsync(BindItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Unbind item from character
    /// </summary>

    /// <remarks>
    /// Removes the binding from a soulbound item. This is an admin-only operation
    /// <br/>for returning bound items to tradeable state. Requires a reason for audit trail.
    /// </remarks>

    /// <returns>Item instance unbound successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> UnbindItemInstanceAsync(UnbindItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Destroy item instance
    /// </summary>

    /// <remarks>
    /// Permanently destroys an item instance. The reason is recorded for audit.
    /// <br/>Cannot destroy bound items unless admin or reason is 'admin'.
    /// </remarks>

    /// <returns>Item instance destroyed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DestroyItemInstanceResponse>> DestroyItemInstanceAsync(DestroyItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Use an item (execute its behavior contract)
    /// </summary>

    /// <remarks>
    /// Uses an item by executing its behavior contract. The item's template must have
    /// <br/>a useBehaviorContractTemplateId defined. Creates a transient contract instance,
    /// <br/>completes the "use" milestone (triggering prebound APIs), and consumes the item
    /// <br/>on success if the template defines it as consumable. Returns failure if the
    /// <br/>contract's prebound APIs fail.
    /// </remarks>

    /// <returns>Item used successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UseItemResponse>> UseItemAsync(UseItemRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Complete a specific step of a multi-step item use
    /// </summary>

    /// <remarks>
    /// For items with multi-milestone use behaviors, completes a specific milestone.
    /// <br/>The first call (without an existing contractInstanceId on the item) creates
    /// <br/>the contract instance and stores it on the item; subsequent calls progress
    /// <br/>the existing contract. Item is consumed only when all required milestones
    /// <br/>are complete (per itemUseBehavior).
    /// </remarks>

    /// <returns>Step completed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UseItemStepResponse>> UseItemStepAsync(UseItemStepRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List items in a container
    /// </summary>

    /// <remarks>
    /// Returns all item instances in the specified container.
    /// </remarks>

    /// <returns>Items retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListItemsResponse>> ListItemsByContainerAsync(ListItemsByContainerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List instances of a template
    /// </summary>

    /// <remarks>
    /// Returns item instances of the specified template, optionally filtered by realm.
    /// <br/>Useful for admin queries and analytics.
    /// </remarks>

    /// <returns>Items retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListItemsResponse>> ListItemsByTemplateAsync(ListItemsByTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get multiple item instances by ID
    /// </summary>

    /// <remarks>
    /// Retrieves multiple item instances in a single request.
    /// </remarks>

    /// <returns>Items retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BatchGetItemInstancesResponse>> BatchGetItemInstancesAsync(BatchGetItemInstancesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class ItemController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IItemService _implementation;

    public ItemController(IItemService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Create a new item template
    /// </summary>
    /// <remarks>
    /// Creates a new item definition for a game. Code, gameId, quantityModel, and scope
    /// <br/>are immutable after creation.
    /// </remarks>
    /// <returns>Item template created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/template/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> CreateItemTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateItemTemplateAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get item template by ID or code
    /// </summary>
    /// <remarks>
    /// Retrieves an item template by its unique ID or by code+gameId combination.
    /// <br/>At least one of templateId or (code + gameId) must be provided.
    /// </remarks>
    /// <returns>Item template retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/template/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> GetItemTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetItemTemplateAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List item templates with filters
    /// </summary>
    /// <remarks>
    /// Lists item templates with optional filtering by gameId, category, tags,
    /// <br/>rarity, scope, and active status.
    /// </remarks>
    /// <returns>Item templates retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/template/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListItemTemplatesResponse>> ListItemTemplates([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListItemTemplatesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListItemTemplatesAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Update mutable fields of an item template
    /// </summary>
    /// <remarks>
    /// Updates mutable fields of an item template. Code, gameId, quantityModel, and scope
    /// <br/>are immutable after creation and cannot be changed.
    /// </remarks>
    /// <returns>Item template updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/template/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> UpdateItemTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateItemTemplateAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Deprecate an item template
    /// </summary>
    /// <remarks>
    /// Marks an item template as deprecated. Deprecated templates cannot be used
    /// <br/>to create new instances but existing instances remain valid. Optionally
    /// <br/>specify a migration target template.
    /// </remarks>
    /// <returns>Item template deprecated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/template/deprecate")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemTemplateResponse>> DeprecateItemTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeprecateItemTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DeprecateItemTemplateAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Create a new item instance
    /// </summary>
    /// <remarks>
    /// Creates a new item instance from a template. The instance must be placed
    /// <br/>in a container (containerId required). Use lib-inventory's /inventory/add
    /// <br/>for most use cases - this endpoint is for low-level instance creation.
    /// </remarks>
    /// <returns>Item instance created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> CreateItemInstance([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateItemInstanceAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get item instance by ID
    /// </summary>
    /// <remarks>
    /// Retrieves an item instance by its unique ID.
    /// </remarks>
    /// <returns>Item instance retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> GetItemInstance([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetItemInstanceAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Modify item instance state
    /// </summary>
    /// <remarks>
    /// Modifies an item instance's mutable state: durability, custom stats,
    /// <br/>custom name, and metadata. Cannot modify bound items unless admin.
    /// </remarks>
    /// <returns>Item instance modified successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/modify")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> ModifyItemInstance([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ModifyItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ModifyItemInstanceAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Bind item to character
    /// </summary>
    /// <remarks>
    /// Binds an item instance to a character. The bind type must be allowed by
    /// <br/>the template's soulboundType. Once bound, the item cannot be traded.
    /// </remarks>
    /// <returns>Item instance bound successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/bind")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> BindItemInstance([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BindItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.BindItemInstanceAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Unbind item from character
    /// </summary>
    /// <remarks>
    /// Removes the binding from a soulbound item. This is an admin-only operation
    /// <br/>for returning bound items to tradeable state. Requires a reason for audit trail.
    /// </remarks>
    /// <returns>Item instance unbound successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/unbind")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ItemInstanceResponse>> UnbindItemInstance([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UnbindItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UnbindItemInstanceAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Destroy item instance
    /// </summary>
    /// <remarks>
    /// Permanently destroys an item instance. The reason is recorded for audit.
    /// <br/>Cannot destroy bound items unless admin or reason is 'admin'.
    /// </remarks>
    /// <returns>Item instance destroyed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/destroy")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DestroyItemInstanceResponse>> DestroyItemInstance([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DestroyItemInstanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DestroyItemInstanceAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Use an item (execute its behavior contract)
    /// </summary>
    /// <remarks>
    /// Uses an item by executing its behavior contract. The item's template must have
    /// <br/>a useBehaviorContractTemplateId defined. Creates a transient contract instance,
    /// <br/>completes the "use" milestone (triggering prebound APIs), and consumes the item
    /// <br/>on success if the template defines it as consumable. Returns failure if the
    /// <br/>contract's prebound APIs fail.
    /// </remarks>
    /// <returns>Item used successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/use")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UseItemResponse>> UseItem([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UseItemRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UseItemAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Complete a specific step of a multi-step item use
    /// </summary>
    /// <remarks>
    /// For items with multi-milestone use behaviors, completes a specific milestone.
    /// <br/>The first call (without an existing contractInstanceId on the item) creates
    /// <br/>the contract instance and stores it on the item; subsequent calls progress
    /// <br/>the existing contract. Item is consumed only when all required milestones
    /// <br/>are complete (per itemUseBehavior).
    /// </remarks>
    /// <returns>Step completed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/use-step")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UseItemStepResponse>> UseItemStep([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UseItemStepRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UseItemStepAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List items in a container
    /// </summary>
    /// <remarks>
    /// Returns all item instances in the specified container.
    /// </remarks>
    /// <returns>Items retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/list-by-container")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListItemsResponse>> ListItemsByContainer([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListItemsByContainerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListItemsByContainerAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List instances of a template
    /// </summary>
    /// <remarks>
    /// Returns item instances of the specified template, optionally filtered by realm.
    /// <br/>Useful for admin queries and analytics.
    /// </remarks>
    /// <returns>Items retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/list-by-template")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListItemsResponse>> ListItemsByTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListItemsByTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListItemsByTemplateAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get multiple item instances by ID
    /// </summary>
    /// <remarks>
    /// Retrieves multiple item instances in a single request.
    /// </remarks>
    /// <returns>Items retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("item/instance/batch-get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BatchGetItemInstancesResponse>> BatchGetItemInstances([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BatchGetItemInstancesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.BatchGetItemInstancesAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
