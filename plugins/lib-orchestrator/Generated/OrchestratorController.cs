//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     RELATED FILES:
//     - Request/Response models: bannou-service/Generated/Models/{Service}Models.cs
//     - Event models: bannou-service/Generated/Events/{Service}EventsModels.cs
//     - Lifecycle events: bannou-service/Generated/Events/{Service}LifecycleEvents.cs
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Orchestrator;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IOrchestratorController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Check infrastructure component health
    /// </summary>

    /// <remarks>
    /// Validates connectivity and health of core infrastructure components:
    /// <br/>- Redis (direct connection via StackExchange.Redis)
    /// <br/>- RabbitMQ (direct connection via RabbitMQ.Client)
    /// <br/>-
    /// </remarks>

    /// <returns>Infrastructure health status (check response body for component health)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InfrastructureHealthResponse>> GetInfrastructureHealthAsync(InfrastructureHealthRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get health status of all services
    /// </summary>

    /// <remarks>
    /// Retrieves health information from all services via Redis heartbeat monitoring.
    /// <br/>Uses existing ServiceHeartbeatEvent schema from common-events.yaml.
    /// </remarks>

    /// <returns>Service health report</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceHealthReport>> GetServicesHealthAsync(ServiceHealthRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Restart service with optional configuration
    /// </summary>

    /// <remarks>
    /// Performs intelligent service restart based on health metrics.
    /// <br/>Only restarts if truly necessary (e.g., 5+ minute degradation).
    /// <br/>
    /// <br/>Supports optional environment variable updates during restart.
    /// </remarks>

    /// <returns>Service restarted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceRestartResult>> RestartServiceAsync(ServiceRestartRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Check if service needs restart
    /// </summary>

    /// <remarks>
    /// Evaluates service health and determines if restart is necessary.
    /// <br/>
    /// <br/>Restart logic:
    /// <br/>- Healthy: No restart needed
    /// <br/>- Degraded &lt; 5 min: No restart needed
    /// <br/>- Degraded &gt; 5 min: Restart recommended
    /// <br/>- Unavailable: Restart needed
    /// </remarks>

    /// <returns>Restart recommendation</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RestartRecommendation>> ShouldRestartServiceAsync(ShouldRestartServiceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Detect available container orchestration backends
    /// </summary>

    /// <remarks>
    /// Detects which container orchestration backends are available on this system.
    /// <br/>Returns availability status and capabilities for each backend.
    /// <br/>
    /// <br/>**Priority Order** (for automatic selection):
    /// <br/>1. Kubernetes - Full cluster orchestration with operators
    /// <br/>2. Portainer - API abstraction over Compose/Swarm with web UI
    /// <br/>3. Docker Swarm - Native Docker cluster orchestration
    /// <br/>4. Docker Compose - Single-host container management
    /// <br/>
    /// <br/>Detection methods:
    /// <br/>- Kubernetes: Check for kubectl and cluster connectivity
    /// <br/>- Portainer: Check for Portainer API endpoint
    /// <br/>- Swarm: Check `docker info` for swarm mode
    /// <br/>- Compose: Check for docker compose v2 availability
    /// </remarks>

    /// <returns>Available backends with capabilities</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BackendsResponse>> GetBackendsAsync(ListBackendsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List available deployment presets
    /// </summary>

    /// <remarks>
    /// Returns all available deployment presets from the orchestrator's preset directory.
    /// <br/>Presets define service combinations and configuration for specific use cases.
    /// <br/>
    /// <br/>Built-in presets:
    /// <br/>- `local-development`: All services in single container with mesh infrastructure
    /// <br/>- `local-testing`: Test environment with infrastructure services
    /// <br/>- `integration-http`: HTTP integration testing preset
    /// <br/>- `integration-edge`: WebSocket/edge testing preset
    /// <br/>- `split-auth-account`: Auth and Account in separate containers
    /// <br/>- `distributed-npc`: NPC processing distributed across nodes
    /// </remarks>

    /// <returns>Available deployment presets</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PresetsResponse>> GetPresetsAsync(ListPresetsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Deploy or update an environment
    /// </summary>

    /// <remarks>
    /// Deploys a complete environment using a preset or custom configuration.
    /// <br/>Supports graceful transitions, forced deployments, and clean rebuilds.
    /// <br/>
    /// <br/>**Deployment Modes**:
    /// <br/>- `graceful`: Wait for existing connections to drain before changing topology
    /// <br/>- `force`: Immediately apply changes (may interrupt active connections)
    /// <br/>- `clean`: Tear down completely and rebuild from scratch
    /// <br/>
    /// <br/>**Backend Selection**:
    /// <br/>- If `backend` not specified, uses highest-priority available backend
    /// <br/>- If `backend` specified but unavailable, returns error (no fallback)
    /// <br/>
    /// <br/>**Live Topology Changes**:
    /// <br/>Supports changing service distribution without full restart:
    /// <br/>- Move auth/account to separate container while keeping other services together
    /// <br/>- Scale specific services to additional nodes
    /// <br/>- Update environment variables without restart (where supported)
    /// </remarks>

    /// <returns>Deployment initiated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeployResponse>> DeployAsync(DeployRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get current service-to-app-id routing mappings
    /// </summary>

    /// <remarks>
    /// Returns the current service-to-app-id routing mappings used for mesh service invocation through lib-mesh.
    /// <br/>This is the authoritative source of truth for how services are routed in the current deployment.
    /// <br/>
    /// <br/>In development, all services route to "bannou" by default. In production, services may be
    /// <br/>distributed across multiple app-ids based on deployment topology.
    /// <br/>
    /// <br/>**Use Cases**:
    /// <br/>- Services querying routing on startup
    /// <br/>- Debugging service communication issues
    /// <br/>- Monitoring deployment topology
    /// </remarks>

    /// <returns>Service routing mappings</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceRoutingResponse>> GetServiceRoutingAsync(GetServiceRoutingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get current environment status
    /// </summary>

    /// <remarks>
    /// Returns comprehensive status of the current deployment including:
    /// <br/>- Active backend and deployment configuration
    /// <br/>- Service topology (which services on which containers)
    /// <br/>- Container health and resource usage
    /// <br/>- Infrastructure component status
    /// <br/>- Active preset and any customizations
    /// </remarks>

    /// <returns>Current environment status</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EnvironmentStatus>> GetStatusAsync(GetStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Tear down the current environment
    /// </summary>

    /// <remarks>
    /// Tears down all containers and services in the current deployment.
    /// <br/>Optionally preserves volumes and networks for faster redeployment.
    /// <br/>
    /// <br/>**Teardown Modes**:
    /// <br/>- `graceful`: Signal shutdown and wait for clean exit
    /// <br/>- `force`: Immediately stop all containers (SIGKILL)
    /// <br/>- `preserve-data`: Keep volumes and networks, only remove containers
    /// </remarks>

    /// <returns>Teardown completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TeardownResponse>> TeardownAsync(TeardownRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Clean up unused resources
    /// </summary>

    /// <remarks>
    /// Prunes unused Docker resources to reclaim disk space and clean up
    /// <br/>orphaned containers, networks, volumes, and images.
    /// <br/>
    /// <br/>Equivalent to running various `docker system prune` commands.
    /// <br/>
    /// <br/>**Clean Targets**:
    /// <br/>- `containers`: Remove stopped containers
    /// <br/>- `networks`: Remove unused networks
    /// <br/>- `volumes`: Remove unused volumes (CAUTION: data loss)
    /// <br/>- `images`: Remove dangling images
    /// <br/>- `all`: All of the above
    /// </remarks>

    /// <returns>Cleanup completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanResponse>> CleanAsync(CleanRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get service/container logs
    /// </summary>

    /// <remarks>
    /// Retrieves logs from services or containers with filtering options.
    /// <br/>Supports real-time streaming via WebSocket upgrade.
    /// </remarks>

    /// <returns>Log output</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LogsResponse>> GetLogsAsync(GetLogsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update service topology without full redeploy
    /// </summary>

    /// <remarks>
    /// Changes which services run on which containers without tearing down
    /// <br/>the entire environment. Enables live topology changes.
    /// <br/>
    /// <br/>**Use Cases**:
    /// <br/>- Move auth service to dedicated container for scaling
    /// <br/>- Consolidate services during low-traffic periods
    /// <br/>- Split services for debugging/isolation
    /// <br/>- Add new service nodes to running environment
    /// </remarks>

    /// <returns>Topology update applied</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TopologyUpdateResponse>> UpdateTopologyAsync(TopologyUpdateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Request container restart (self-service pattern)
    /// </summary>

    /// <remarks>
    /// Plugins call this endpoint to request restart of their own container.
    /// <br/>This is part of the self-service configuration update pattern where
    /// <br/>plugins decide if they care about config changes and request restarts.
    /// <br/>
    /// <br/>**Flow**:
    /// <br/>1. Orchestrator publishes ConfigurationChangedEvent with changed keys
    /// <br/>2. Plugins check if any changed keys match their dependencies
    /// <br/>3. Plugins that care call this endpoint to request restart
    /// <br/>4. Orchestrator performs rolling restart of requested containers
    /// <br/>
    /// <br/>**Priority Levels**:
    /// <br/>- `graceful`: Rolling update, wait for healthy before cycling next instance
    /// <br/>- `immediate`: Rolling update but don't wait for connection drain
    /// <br/>- `force`: Kill all instances simultaneously (causes downtime)
    /// </remarks>

    /// <returns>Restart request accepted</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerRestartResponse>> RequestContainerRestartAsync(ContainerRestartRequestBody body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get container health and restart history
    /// </summary>

    /// <remarks>
    /// Returns detailed status of a container including health, restart history,
    /// <br/>running plugins, and current configuration.
    /// </remarks>

    /// <returns>Container status</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerStatus>> GetContainerStatusAsync(GetContainerStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Rollback to previous configuration
    /// </summary>

    /// <remarks>
    /// Quickly rollback to the previous configuration without waiting for CI.
    /// <br/>Swaps currentConfig with previousConfig and publishes ConfigurationChangedEvent
    /// <br/>with the reverted keys so services can request restart.
    /// <br/>
    /// <br/>**Note**: This is a quick fix. GitHub secrets should still be corrected
    /// <br/>to prevent re-breaking on next orchestrator deploy.
    /// </remarks>

    /// <returns>Rollback completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfigRollbackResponse>> RollbackConfigurationAsync(ConfigRollbackRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get current configuration version and metadata
    /// </summary>

    /// <remarks>
    /// Returns the current configuration version, last update time,
    /// <br/>and summary of configuration state (not actual values for security).
    /// </remarks>

    /// <returns>Configuration version info</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfigVersionResponse>> GetConfigVersionAsync(GetConfigVersionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Acquire a processor from a pool
    /// </summary>

    /// <remarks>
    /// Requests an available processor instance from the specified pool type.
    /// <br/>Returns the app-id of an available processor or 429 if none available.
    /// <br/>The processor is marked as busy until explicitly released.
    /// </remarks>

    /// <returns>Processor acquired successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AcquireProcessorResponse>> AcquireProcessorAsync(AcquireProcessorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Release a processor back to the pool
    /// </summary>

    /// <remarks>
    /// Releases a previously acquired processor, making it available for other requests.
    /// <br/>Should be called when processing is complete or on error cleanup.
    /// </remarks>

    /// <returns>Processor released successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ReleaseProcessorResponse>> ReleaseProcessorAsync(ReleaseProcessorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get processing pool status
    /// </summary>

    /// <remarks>
    /// Returns current status of a processing pool including:
    /// <br/>- Total instances (running and available)
    /// <br/>- Current utilization
    /// <br/>- Queue depth (waiting requests)
    /// <br/>- Recent processing metrics
    /// </remarks>

    /// <returns>Pool status retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PoolStatusResponse>> GetPoolStatusAsync(GetPoolStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Scale a processing pool
    /// </summary>

    /// <remarks>
    /// Manually adjust the size of a processing pool.
    /// <br/>Can scale up (add instances) or scale down (remove idle instances).
    /// <br/>Respects min/max constraints from pool configuration.
    /// </remarks>

    /// <returns>Pool scaled successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ScalePoolResponse>> ScalePoolAsync(ScalePoolRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Cleanup idle processing pool instances
    /// </summary>

    /// <remarks>
    /// Scales pool back to minimum instances by removing idle processors.
    /// <br/>Used for resource reclamation during low-activity periods.
    /// </remarks>

    /// <returns>Cleanup completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupPoolResponse>> CleanupPoolAsync(CleanupPoolRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class OrchestratorController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IOrchestratorService _implementation;
    private BeyondImmersion.BannouService.Services.ITelemetryProvider _telemetryProvider;

    public OrchestratorController(IOrchestratorService implementation, BeyondImmersion.BannouService.Services.ITelemetryProvider telemetryProvider)
    {
        _implementation = implementation;
        _telemetryProvider = telemetryProvider;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Check infrastructure component health
    /// </summary>
    /// <remarks>
    /// Validates connectivity and health of core infrastructure components:
    /// <br/>- Redis (direct connection via StackExchange.Redis)
    /// <br/>- RabbitMQ (direct connection via RabbitMQ.Client)
    /// <br/>-
    /// </remarks>
    /// <returns>Infrastructure health status (check response body for component health)</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/health/infrastructure")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InfrastructureHealthResponse>> GetInfrastructureHealth([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] InfrastructureHealthRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.GetInfrastructureHealth",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/health/infrastructure");
        try
        {

            var (statusCode, result) = await _implementation.GetInfrastructureHealthAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/health/infrastructure");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/health/infrastructure");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "GetInfrastructureHealth",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/health/infrastructure",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get health status of all services
    /// </summary>
    /// <remarks>
    /// Retrieves health information from all services via Redis heartbeat monitoring.
    /// <br/>Uses existing ServiceHeartbeatEvent schema from common-events.yaml.
    /// </remarks>
    /// <returns>Service health report</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/health/services")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceHealthReport>> GetServicesHealth([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ServiceHealthRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.GetServicesHealth",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/health/services");
        try
        {

            var (statusCode, result) = await _implementation.GetServicesHealthAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/health/services");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/health/services");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "GetServicesHealth",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/health/services",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Restart service with optional configuration
    /// </summary>
    /// <remarks>
    /// Performs intelligent service restart based on health metrics.
    /// <br/>Only restarts if truly necessary (e.g., 5+ minute degradation).
    /// <br/>
    /// <br/>Supports optional environment variable updates during restart.
    /// </remarks>
    /// <returns>Service restarted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/services/restart")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceRestartResult>> RestartService([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ServiceRestartRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.RestartService",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/services/restart");
        try
        {

            var (statusCode, result) = await _implementation.RestartServiceAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/services/restart");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/services/restart");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "RestartService",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/services/restart",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Check if service needs restart
    /// </summary>
    /// <remarks>
    /// Evaluates service health and determines if restart is necessary.
    /// <br/>
    /// <br/>Restart logic:
    /// <br/>- Healthy: No restart needed
    /// <br/>- Degraded &lt; 5 min: No restart needed
    /// <br/>- Degraded &gt; 5 min: Restart recommended
    /// <br/>- Unavailable: Restart needed
    /// </remarks>
    /// <returns>Restart recommendation</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/services/should-restart")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RestartRecommendation>> ShouldRestartService([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ShouldRestartServiceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.ShouldRestartService",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/services/should-restart");
        try
        {

            var (statusCode, result) = await _implementation.ShouldRestartServiceAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/services/should-restart");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/services/should-restart");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "ShouldRestartService",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/services/should-restart",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Detect available container orchestration backends
    /// </summary>
    /// <remarks>
    /// Detects which container orchestration backends are available on this system.
    /// <br/>Returns availability status and capabilities for each backend.
    /// <br/>
    /// <br/>**Priority Order** (for automatic selection):
    /// <br/>1. Kubernetes - Full cluster orchestration with operators
    /// <br/>2. Portainer - API abstraction over Compose/Swarm with web UI
    /// <br/>3. Docker Swarm - Native Docker cluster orchestration
    /// <br/>4. Docker Compose - Single-host container management
    /// <br/>
    /// <br/>Detection methods:
    /// <br/>- Kubernetes: Check for kubectl and cluster connectivity
    /// <br/>- Portainer: Check for Portainer API endpoint
    /// <br/>- Swarm: Check `docker info` for swarm mode
    /// <br/>- Compose: Check for docker compose v2 availability
    /// </remarks>
    /// <returns>Available backends with capabilities</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/backends/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BackendsResponse>> GetBackends([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListBackendsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.GetBackends",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/backends/list");
        try
        {

            var (statusCode, result) = await _implementation.GetBackendsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/backends/list");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/backends/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "GetBackends",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/backends/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List available deployment presets
    /// </summary>
    /// <remarks>
    /// Returns all available deployment presets from the orchestrator's preset directory.
    /// <br/>Presets define service combinations and configuration for specific use cases.
    /// <br/>
    /// <br/>Built-in presets:
    /// <br/>- `local-development`: All services in single container with mesh infrastructure
    /// <br/>- `local-testing`: Test environment with infrastructure services
    /// <br/>- `integration-http`: HTTP integration testing preset
    /// <br/>- `integration-edge`: WebSocket/edge testing preset
    /// <br/>- `split-auth-account`: Auth and Account in separate containers
    /// <br/>- `distributed-npc`: NPC processing distributed across nodes
    /// </remarks>
    /// <returns>Available deployment presets</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/presets/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PresetsResponse>> GetPresets([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListPresetsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.GetPresets",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/presets/list");
        try
        {

            var (statusCode, result) = await _implementation.GetPresetsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/presets/list");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/presets/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "GetPresets",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/presets/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Deploy or update an environment
    /// </summary>
    /// <remarks>
    /// Deploys a complete environment using a preset or custom configuration.
    /// <br/>Supports graceful transitions, forced deployments, and clean rebuilds.
    /// <br/>
    /// <br/>**Deployment Modes**:
    /// <br/>- `graceful`: Wait for existing connections to drain before changing topology
    /// <br/>- `force`: Immediately apply changes (may interrupt active connections)
    /// <br/>- `clean`: Tear down completely and rebuild from scratch
    /// <br/>
    /// <br/>**Backend Selection**:
    /// <br/>- If `backend` not specified, uses highest-priority available backend
    /// <br/>- If `backend` specified but unavailable, returns error (no fallback)
    /// <br/>
    /// <br/>**Live Topology Changes**:
    /// <br/>Supports changing service distribution without full restart:
    /// <br/>- Move auth/account to separate container while keeping other services together
    /// <br/>- Scale specific services to additional nodes
    /// <br/>- Update environment variables without restart (where supported)
    /// </remarks>
    /// <returns>Deployment initiated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/deploy")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeployResponse>> Deploy([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeployRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.Deploy",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/deploy");
        try
        {

            var (statusCode, result) = await _implementation.DeployAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/deploy");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/deploy");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "Deploy",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/deploy",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get current service-to-app-id routing mappings
    /// </summary>
    /// <remarks>
    /// Returns the current service-to-app-id routing mappings used for mesh service invocation through lib-mesh.
    /// <br/>This is the authoritative source of truth for how services are routed in the current deployment.
    /// <br/>
    /// <br/>In development, all services route to "bannou" by default. In production, services may be
    /// <br/>distributed across multiple app-ids based on deployment topology.
    /// <br/>
    /// <br/>**Use Cases**:
    /// <br/>- Services querying routing on startup
    /// <br/>- Debugging service communication issues
    /// <br/>- Monitoring deployment topology
    /// </remarks>
    /// <returns>Service routing mappings</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/service-routing")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceRoutingResponse>> GetServiceRouting([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetServiceRoutingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.GetServiceRouting",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/service-routing");
        try
        {

            var (statusCode, result) = await _implementation.GetServiceRoutingAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/service-routing");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/service-routing");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "GetServiceRouting",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/service-routing",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get current environment status
    /// </summary>
    /// <remarks>
    /// Returns comprehensive status of the current deployment including:
    /// <br/>- Active backend and deployment configuration
    /// <br/>- Service topology (which services on which containers)
    /// <br/>- Container health and resource usage
    /// <br/>- Infrastructure component status
    /// <br/>- Active preset and any customizations
    /// </remarks>
    /// <returns>Current environment status</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EnvironmentStatus>> GetStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.GetStatus",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/status");
        try
        {

            var (statusCode, result) = await _implementation.GetStatusAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/status");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/status");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "GetStatus",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/status",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Tear down the current environment
    /// </summary>
    /// <remarks>
    /// Tears down all containers and services in the current deployment.
    /// <br/>Optionally preserves volumes and networks for faster redeployment.
    /// <br/>
    /// <br/>**Teardown Modes**:
    /// <br/>- `graceful`: Signal shutdown and wait for clean exit
    /// <br/>- `force`: Immediately stop all containers (SIGKILL)
    /// <br/>- `preserve-data`: Keep volumes and networks, only remove containers
    /// </remarks>
    /// <returns>Teardown completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/teardown")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TeardownResponse>> Teardown([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] TeardownRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.Teardown",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/teardown");
        try
        {

            var (statusCode, result) = await _implementation.TeardownAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/teardown");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/teardown");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "Teardown",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/teardown",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Clean up unused resources
    /// </summary>
    /// <remarks>
    /// Prunes unused Docker resources to reclaim disk space and clean up
    /// <br/>orphaned containers, networks, volumes, and images.
    /// <br/>
    /// <br/>Equivalent to running various `docker system prune` commands.
    /// <br/>
    /// <br/>**Clean Targets**:
    /// <br/>- `containers`: Remove stopped containers
    /// <br/>- `networks`: Remove unused networks
    /// <br/>- `volumes`: Remove unused volumes (CAUTION: data loss)
    /// <br/>- `images`: Remove dangling images
    /// <br/>- `all`: All of the above
    /// </remarks>
    /// <returns>Cleanup completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/clean")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanResponse>> Clean([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CleanRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.Clean",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/clean");
        try
        {

            var (statusCode, result) = await _implementation.CleanAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/clean");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/clean");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "Clean",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/clean",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get service/container logs
    /// </summary>
    /// <remarks>
    /// Retrieves logs from services or containers with filtering options.
    /// <br/>Supports real-time streaming via WebSocket upgrade.
    /// </remarks>
    /// <returns>Log output</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/logs")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LogsResponse>> GetLogs([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetLogsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.GetLogs",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/logs");
        try
        {

            var (statusCode, result) = await _implementation.GetLogsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/logs");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/logs");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "GetLogs",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/logs",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update service topology without full redeploy
    /// </summary>
    /// <remarks>
    /// Changes which services run on which containers without tearing down
    /// <br/>the entire environment. Enables live topology changes.
    /// <br/>
    /// <br/>**Use Cases**:
    /// <br/>- Move auth service to dedicated container for scaling
    /// <br/>- Consolidate services during low-traffic periods
    /// <br/>- Split services for debugging/isolation
    /// <br/>- Add new service nodes to running environment
    /// </remarks>
    /// <returns>Topology update applied</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/topology")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TopologyUpdateResponse>> UpdateTopology([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] TopologyUpdateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.UpdateTopology",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/topology");
        try
        {

            var (statusCode, result) = await _implementation.UpdateTopologyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/topology");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/topology");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "UpdateTopology",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/topology",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Request container restart (self-service pattern)
    /// </summary>
    /// <remarks>
    /// Plugins call this endpoint to request restart of their own container.
    /// <br/>This is part of the self-service configuration update pattern where
    /// <br/>plugins decide if they care about config changes and request restarts.
    /// <br/>
    /// <br/>**Flow**:
    /// <br/>1. Orchestrator publishes ConfigurationChangedEvent with changed keys
    /// <br/>2. Plugins check if any changed keys match their dependencies
    /// <br/>3. Plugins that care call this endpoint to request restart
    /// <br/>4. Orchestrator performs rolling restart of requested containers
    /// <br/>
    /// <br/>**Priority Levels**:
    /// <br/>- `graceful`: Rolling update, wait for healthy before cycling next instance
    /// <br/>- `immediate`: Rolling update but don't wait for connection drain
    /// <br/>- `force`: Kill all instances simultaneously (causes downtime)
    /// </remarks>
    /// <returns>Restart request accepted</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/containers/request-restart")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerRestartResponse>> RequestContainerRestart([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ContainerRestartRequestBody body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.RequestContainerRestart",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/containers/request-restart");
        try
        {

            var (statusCode, result) = await _implementation.RequestContainerRestartAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/containers/request-restart");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/containers/request-restart");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "RequestContainerRestart",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/containers/request-restart",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get container health and restart history
    /// </summary>
    /// <remarks>
    /// Returns detailed status of a container including health, restart history,
    /// <br/>running plugins, and current configuration.
    /// </remarks>
    /// <returns>Container status</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/containers/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerStatus>> GetContainerStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetContainerStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.GetContainerStatus",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/containers/status");
        try
        {

            var (statusCode, result) = await _implementation.GetContainerStatusAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/containers/status");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/containers/status");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "GetContainerStatus",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/containers/status",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Rollback to previous configuration
    /// </summary>
    /// <remarks>
    /// Quickly rollback to the previous configuration without waiting for CI.
    /// <br/>Swaps currentConfig with previousConfig and publishes ConfigurationChangedEvent
    /// <br/>with the reverted keys so services can request restart.
    /// <br/>
    /// <br/>**Note**: This is a quick fix. GitHub secrets should still be corrected
    /// <br/>to prevent re-breaking on next orchestrator deploy.
    /// </remarks>
    /// <returns>Rollback completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/config/rollback")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfigRollbackResponse>> RollbackConfiguration([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ConfigRollbackRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.RollbackConfiguration",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/config/rollback");
        try
        {

            var (statusCode, result) = await _implementation.RollbackConfigurationAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/config/rollback");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/config/rollback");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "RollbackConfiguration",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/config/rollback",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get current configuration version and metadata
    /// </summary>
    /// <remarks>
    /// Returns the current configuration version, last update time,
    /// <br/>and summary of configuration state (not actual values for security).
    /// </remarks>
    /// <returns>Configuration version info</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/config/version")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfigVersionResponse>> GetConfigVersion([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetConfigVersionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.GetConfigVersion",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/config/version");
        try
        {

            var (statusCode, result) = await _implementation.GetConfigVersionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/config/version");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/config/version");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "GetConfigVersion",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/config/version",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Acquire a processor from a pool
    /// </summary>
    /// <remarks>
    /// Requests an available processor instance from the specified pool type.
    /// <br/>Returns the app-id of an available processor or 429 if none available.
    /// <br/>The processor is marked as busy until explicitly released.
    /// </remarks>
    /// <returns>Processor acquired successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/acquire")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AcquireProcessorResponse>> AcquireProcessor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AcquireProcessorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.AcquireProcessor",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/processing-pool/acquire");
        try
        {

            var (statusCode, result) = await _implementation.AcquireProcessorAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/processing-pool/acquire");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/processing-pool/acquire");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "AcquireProcessor",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/processing-pool/acquire",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Release a processor back to the pool
    /// </summary>
    /// <remarks>
    /// Releases a previously acquired processor, making it available for other requests.
    /// <br/>Should be called when processing is complete or on error cleanup.
    /// </remarks>
    /// <returns>Processor released successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/release")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ReleaseProcessorResponse>> ReleaseProcessor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ReleaseProcessorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.ReleaseProcessor",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/processing-pool/release");
        try
        {

            var (statusCode, result) = await _implementation.ReleaseProcessorAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/processing-pool/release");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/processing-pool/release");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "ReleaseProcessor",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/processing-pool/release",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get processing pool status
    /// </summary>
    /// <remarks>
    /// Returns current status of a processing pool including:
    /// <br/>- Total instances (running and available)
    /// <br/>- Current utilization
    /// <br/>- Queue depth (waiting requests)
    /// <br/>- Recent processing metrics
    /// </remarks>
    /// <returns>Pool status retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PoolStatusResponse>> GetPoolStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetPoolStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.GetPoolStatus",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/processing-pool/status");
        try
        {

            var (statusCode, result) = await _implementation.GetPoolStatusAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/processing-pool/status");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/processing-pool/status");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "GetPoolStatus",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/processing-pool/status",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Scale a processing pool
    /// </summary>
    /// <remarks>
    /// Manually adjust the size of a processing pool.
    /// <br/>Can scale up (add instances) or scale down (remove idle instances).
    /// <br/>Respects min/max constraints from pool configuration.
    /// </remarks>
    /// <returns>Pool scaled successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/scale")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ScalePoolResponse>> ScalePool([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ScalePoolRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.ScalePool",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/processing-pool/scale");
        try
        {

            var (statusCode, result) = await _implementation.ScalePoolAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/processing-pool/scale");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/processing-pool/scale");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "ScalePool",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/processing-pool/scale",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Cleanup idle processing pool instances
    /// </summary>
    /// <remarks>
    /// Scales pool back to minimum instances by removing idle processors.
    /// <br/>Used for resource reclamation during low-activity periods.
    /// </remarks>
    /// <returns>Cleanup completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/cleanup")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupPoolResponse>> CleanupPool([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CleanupPoolRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.orchestrator",
            "OrchestratorController.CleanupPool",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "orchestrator/processing-pool/cleanup");
        try
        {

            var (statusCode, result) = await _implementation.CleanupPoolAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:orchestrator/processing-pool/cleanup");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<OrchestratorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:orchestrator/processing-pool/cleanup");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "orchestrator",
                "CleanupPool",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:orchestrator/processing-pool/cleanup",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
