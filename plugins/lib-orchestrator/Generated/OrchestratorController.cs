//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Orchestrator;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IOrchestratorController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Check infrastructure component health
    /// </summary>

    /// <remarks>
    /// Validates connectivity and health of core infrastructure components:
    /// <br/>- Redis (direct connection via StackExchange.Redis)
    /// <br/>- RabbitMQ (direct connection via RabbitMQ.Client)
    /// <br/>-
    /// </remarks>

    /// <returns>Infrastructure health status (check response body for component health)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InfrastructureHealthResponse>> GetInfrastructureHealthAsync(InfrastructureHealthRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get health status of all services
    /// </summary>

    /// <remarks>
    /// Retrieves health information from all services via Redis heartbeat monitoring.
    /// <br/>Uses existing ServiceHeartbeatEvent schema from common-events.yaml.
    /// </remarks>

    /// <returns>Service health report</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceHealthReport>> GetServicesHealthAsync(ServiceHealthRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Restart service with optional configuration
    /// </summary>

    /// <remarks>
    /// Performs intelligent service restart based on health metrics.
    /// <br/>Only restarts if truly necessary (e.g., 5+ minute degradation).
    /// <br/>
    /// <br/>Supports optional environment variable updates during restart.
    /// </remarks>

    /// <returns>Service restarted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceRestartResult>> RestartServiceAsync(ServiceRestartRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Check if service needs restart
    /// </summary>

    /// <remarks>
    /// Evaluates service health and determines if restart is necessary.
    /// <br/>
    /// <br/>Restart logic:
    /// <br/>- Healthy: No restart needed
    /// <br/>- Degraded &lt; 5 min: No restart needed
    /// <br/>- Degraded &gt; 5 min: Restart recommended
    /// <br/>- Unavailable: Restart needed
    /// </remarks>

    /// <returns>Restart recommendation</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RestartRecommendation>> ShouldRestartServiceAsync(ShouldRestartServiceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Detect available container orchestration backends
    /// </summary>

    /// <remarks>
    /// Detects which container orchestration backends are available on this system.
    /// <br/>Returns availability status and capabilities for each backend.
    /// <br/>
    /// <br/>**Priority Order** (for automatic selection):
    /// <br/>1. Kubernetes - Full cluster orchestration with operators
    /// <br/>2. Portainer - API abstraction over Compose/Swarm with web UI
    /// <br/>3. Docker Swarm - Native Docker cluster orchestration
    /// <br/>4. Docker Compose - Single-host container management
    /// <br/>
    /// <br/>Detection methods:
    /// <br/>- Kubernetes: Check for kubectl and cluster connectivity
    /// <br/>- Portainer: Check for Portainer API endpoint
    /// <br/>- Swarm: Check `docker info` for swarm mode
    /// <br/>- Compose: Check for docker compose v2 availability
    /// </remarks>

    /// <returns>Available backends with capabilities</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BackendsResponse>> GetBackendsAsync(ListBackendsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List available deployment presets
    /// </summary>

    /// <remarks>
    /// Returns all available deployment presets from the orchestrator's preset directory.
    /// <br/>Presets define service combinations and configuration for specific use cases.
    /// <br/>
    /// <br/>Built-in presets:
    /// <br/>- `local-development`: All services in single container with mesh infrastructure
    /// <br/>- `local-testing`: Test environment with infrastructure services
    /// <br/>- `integration-http`: HTTP integration testing preset
    /// <br/>- `integration-edge`: WebSocket/edge testing preset
    /// <br/>- `split-auth-account`: Auth and Account in separate containers
    /// <br/>- `distributed-npc`: NPC processing distributed across nodes
    /// </remarks>

    /// <returns>Available deployment presets</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PresetsResponse>> GetPresetsAsync(ListPresetsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Deploy or update an environment
    /// </summary>

    /// <remarks>
    /// Deploys a complete environment using a preset or custom configuration.
    /// <br/>Supports graceful transitions, forced deployments, and clean rebuilds.
    /// <br/>
    /// <br/>**Deployment Modes**:
    /// <br/>- `graceful`: Wait for existing connections to drain before changing topology
    /// <br/>- `force`: Immediately apply changes (may interrupt active connections)
    /// <br/>- `clean`: Tear down completely and rebuild from scratch
    /// <br/>
    /// <br/>**Backend Selection**:
    /// <br/>- If `backend` not specified, uses highest-priority available backend
    /// <br/>- If `backend` specified but unavailable, returns error (no fallback)
    /// <br/>
    /// <br/>**Live Topology Changes**:
    /// <br/>Supports changing service distribution without full restart:
    /// <br/>- Move auth/account to separate container while keeping other services together
    /// <br/>- Scale specific services to additional nodes
    /// <br/>- Update environment variables without restart (where supported)
    /// </remarks>

    /// <returns>Deployment initiated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeployResponse>> DeployAsync(DeployRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get current service-to-app-id routing mappings
    /// </summary>

    /// <remarks>
    /// Returns the current service-to-app-id routing mappings used for mesh service invocation through lib-mesh.
    /// <br/>This is the authoritative source of truth for how services are routed in the current deployment.
    /// <br/>
    /// <br/>In development, all services route to "bannou" by default. In production, services may be
    /// <br/>distributed across multiple app-ids based on deployment topology.
    /// <br/>
    /// <br/>**Use Cases**:
    /// <br/>- Services querying routing on startup
    /// <br/>- Debugging service communication issues
    /// <br/>- Monitoring deployment topology
    /// </remarks>

    /// <returns>Service routing mappings</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceRoutingResponse>> GetServiceRoutingAsync(GetServiceRoutingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get current environment status
    /// </summary>

    /// <remarks>
    /// Returns comprehensive status of the current deployment including:
    /// <br/>- Active backend and deployment configuration
    /// <br/>- Service topology (which services on which containers)
    /// <br/>- Container health and resource usage
    /// <br/>- Infrastructure component status
    /// <br/>- Active preset and any customizations
    /// </remarks>

    /// <returns>Current environment status</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EnvironmentStatus>> GetStatusAsync(GetStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Tear down the current environment
    /// </summary>

    /// <remarks>
    /// Tears down all containers and services in the current deployment.
    /// <br/>Optionally preserves volumes and networks for faster redeployment.
    /// <br/>
    /// <br/>**Teardown Modes**:
    /// <br/>- `graceful`: Signal shutdown and wait for clean exit
    /// <br/>- `force`: Immediately stop all containers (SIGKILL)
    /// <br/>- `preserve-data`: Keep volumes and networks, only remove containers
    /// </remarks>

    /// <returns>Teardown completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TeardownResponse>> TeardownAsync(TeardownRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Clean up unused resources
    /// </summary>

    /// <remarks>
    /// Prunes unused Docker resources to reclaim disk space and clean up
    /// <br/>orphaned containers, networks, volumes, and images.
    /// <br/>
    /// <br/>Equivalent to running various `docker system prune` commands.
    /// <br/>
    /// <br/>**Clean Targets**:
    /// <br/>- `containers`: Remove stopped containers
    /// <br/>- `networks`: Remove unused networks
    /// <br/>- `volumes`: Remove unused volumes (CAUTION: data loss)
    /// <br/>- `images`: Remove dangling images
    /// <br/>- `all`: All of the above
    /// </remarks>

    /// <returns>Cleanup completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanResponse>> CleanAsync(CleanRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get service/container logs
    /// </summary>

    /// <remarks>
    /// Retrieves logs from services or containers with filtering options.
    /// <br/>Supports real-time streaming via WebSocket upgrade.
    /// </remarks>

    /// <returns>Log output</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LogsResponse>> GetLogsAsync(GetLogsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update service topology without full redeploy
    /// </summary>

    /// <remarks>
    /// Changes which services run on which containers without tearing down
    /// <br/>the entire environment. Enables live topology changes.
    /// <br/>
    /// <br/>**Use Cases**:
    /// <br/>- Move auth service to dedicated container for scaling
    /// <br/>- Consolidate services during low-traffic periods
    /// <br/>- Split services for debugging/isolation
    /// <br/>- Add new service nodes to running environment
    /// </remarks>

    /// <returns>Topology update applied</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TopologyUpdateResponse>> UpdateTopologyAsync(TopologyUpdateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Request container restart (self-service pattern)
    /// </summary>

    /// <remarks>
    /// Plugins call this endpoint to request restart of their own container.
    /// <br/>This is part of the self-service configuration update pattern where
    /// <br/>plugins decide if they care about config changes and request restarts.
    /// <br/>
    /// <br/>**Flow**:
    /// <br/>1. Orchestrator publishes ConfigurationChangedEvent with changed keys
    /// <br/>2. Plugins check if any changed keys match their dependencies
    /// <br/>3. Plugins that care call this endpoint to request restart
    /// <br/>4. Orchestrator performs rolling restart of requested containers
    /// <br/>
    /// <br/>**Priority Levels**:
    /// <br/>- `graceful`: Rolling update, wait for healthy before cycling next instance
    /// <br/>- `immediate`: Rolling update but don't wait for connection drain
    /// <br/>- `force`: Kill all instances simultaneously (causes downtime)
    /// </remarks>

    /// <returns>Restart request accepted</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerRestartResponse>> RequestContainerRestartAsync(ContainerRestartRequestBody body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get container health and restart history
    /// </summary>

    /// <remarks>
    /// Returns detailed status of a container including health, restart history,
    /// <br/>running plugins, and current configuration.
    /// </remarks>

    /// <returns>Container status</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerStatus>> GetContainerStatusAsync(GetContainerStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Rollback to previous configuration
    /// </summary>

    /// <remarks>
    /// Quickly rollback to the previous configuration without waiting for CI.
    /// <br/>Swaps currentConfig with previousConfig and publishes ConfigurationChangedEvent
    /// <br/>with the reverted keys so services can request restart.
    /// <br/>
    /// <br/>**Note**: This is a quick fix. GitHub secrets should still be corrected
    /// <br/>to prevent re-breaking on next orchestrator deploy.
    /// </remarks>

    /// <returns>Rollback completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfigRollbackResponse>> RollbackConfigurationAsync(ConfigRollbackRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get current configuration version and metadata
    /// </summary>

    /// <remarks>
    /// Returns the current configuration version, last update time,
    /// <br/>and summary of configuration state (not actual values for security).
    /// </remarks>

    /// <returns>Configuration version info</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfigVersionResponse>> GetConfigVersionAsync(GetConfigVersionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Acquire a processor from a pool
    /// </summary>

    /// <remarks>
    /// Requests an available processor instance from the specified pool type.
    /// <br/>Returns the app-id of an available processor or 429 if none available.
    /// <br/>The processor is marked as busy until explicitly released.
    /// </remarks>

    /// <returns>Processor acquired successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AcquireProcessorResponse>> AcquireProcessorAsync(AcquireProcessorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Release a processor back to the pool
    /// </summary>

    /// <remarks>
    /// Releases a previously acquired processor, making it available for other requests.
    /// <br/>Should be called when processing is complete or on error cleanup.
    /// </remarks>

    /// <returns>Processor released successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ReleaseProcessorResponse>> ReleaseProcessorAsync(ReleaseProcessorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get processing pool status
    /// </summary>

    /// <remarks>
    /// Returns current status of a processing pool including:
    /// <br/>- Total instances (running and available)
    /// <br/>- Current utilization
    /// <br/>- Queue depth (waiting requests)
    /// <br/>- Recent processing metrics
    /// </remarks>

    /// <returns>Pool status retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PoolStatusResponse>> GetPoolStatusAsync(GetPoolStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Scale a processing pool
    /// </summary>

    /// <remarks>
    /// Manually adjust the size of a processing pool.
    /// <br/>Can scale up (add instances) or scale down (remove idle instances).
    /// <br/>Respects min/max constraints from pool configuration.
    /// </remarks>

    /// <returns>Pool scaled successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ScalePoolResponse>> ScalePoolAsync(ScalePoolRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Cleanup idle processing pool instances
    /// </summary>

    /// <remarks>
    /// Scales pool back to minimum instances by removing idle processors.
    /// <br/>Used for resource reclamation during low-activity periods.
    /// </remarks>

    /// <returns>Cleanup completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupPoolResponse>> CleanupPoolAsync(CleanupPoolRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class OrchestratorController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IOrchestratorService _implementation;

    public OrchestratorController(IOrchestratorService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Check infrastructure component health
    /// </summary>
    /// <remarks>
    /// Validates connectivity and health of core infrastructure components:
    /// <br/>- Redis (direct connection via StackExchange.Redis)
    /// <br/>- RabbitMQ (direct connection via RabbitMQ.Client)
    /// <br/>-
    /// </remarks>
    /// <returns>Infrastructure health status (check response body for component health)</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/health/infrastructure")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InfrastructureHealthResponse>> GetInfrastructureHealth([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] InfrastructureHealthRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetInfrastructureHealthAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get health status of all services
    /// </summary>
    /// <remarks>
    /// Retrieves health information from all services via Redis heartbeat monitoring.
    /// <br/>Uses existing ServiceHeartbeatEvent schema from common-events.yaml.
    /// </remarks>
    /// <returns>Service health report</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/health/services")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceHealthReport>> GetServicesHealth([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ServiceHealthRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetServicesHealthAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Restart service with optional configuration
    /// </summary>
    /// <remarks>
    /// Performs intelligent service restart based on health metrics.
    /// <br/>Only restarts if truly necessary (e.g., 5+ minute degradation).
    /// <br/>
    /// <br/>Supports optional environment variable updates during restart.
    /// </remarks>
    /// <returns>Service restarted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/services/restart")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceRestartResult>> RestartService([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ServiceRestartRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RestartServiceAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Check if service needs restart
    /// </summary>
    /// <remarks>
    /// Evaluates service health and determines if restart is necessary.
    /// <br/>
    /// <br/>Restart logic:
    /// <br/>- Healthy: No restart needed
    /// <br/>- Degraded &lt; 5 min: No restart needed
    /// <br/>- Degraded &gt; 5 min: Restart recommended
    /// <br/>- Unavailable: Restart needed
    /// </remarks>
    /// <returns>Restart recommendation</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/services/should-restart")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RestartRecommendation>> ShouldRestartService([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ShouldRestartServiceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ShouldRestartServiceAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Detect available container orchestration backends
    /// </summary>
    /// <remarks>
    /// Detects which container orchestration backends are available on this system.
    /// <br/>Returns availability status and capabilities for each backend.
    /// <br/>
    /// <br/>**Priority Order** (for automatic selection):
    /// <br/>1. Kubernetes - Full cluster orchestration with operators
    /// <br/>2. Portainer - API abstraction over Compose/Swarm with web UI
    /// <br/>3. Docker Swarm - Native Docker cluster orchestration
    /// <br/>4. Docker Compose - Single-host container management
    /// <br/>
    /// <br/>Detection methods:
    /// <br/>- Kubernetes: Check for kubectl and cluster connectivity
    /// <br/>- Portainer: Check for Portainer API endpoint
    /// <br/>- Swarm: Check `docker info` for swarm mode
    /// <br/>- Compose: Check for docker compose v2 availability
    /// </remarks>
    /// <returns>Available backends with capabilities</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/backends/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BackendsResponse>> GetBackends([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListBackendsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetBackendsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List available deployment presets
    /// </summary>
    /// <remarks>
    /// Returns all available deployment presets from the orchestrator's preset directory.
    /// <br/>Presets define service combinations and configuration for specific use cases.
    /// <br/>
    /// <br/>Built-in presets:
    /// <br/>- `local-development`: All services in single container with mesh infrastructure
    /// <br/>- `local-testing`: Test environment with infrastructure services
    /// <br/>- `integration-http`: HTTP integration testing preset
    /// <br/>- `integration-edge`: WebSocket/edge testing preset
    /// <br/>- `split-auth-account`: Auth and Account in separate containers
    /// <br/>- `distributed-npc`: NPC processing distributed across nodes
    /// </remarks>
    /// <returns>Available deployment presets</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/presets/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PresetsResponse>> GetPresets([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListPresetsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetPresetsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Deploy or update an environment
    /// </summary>
    /// <remarks>
    /// Deploys a complete environment using a preset or custom configuration.
    /// <br/>Supports graceful transitions, forced deployments, and clean rebuilds.
    /// <br/>
    /// <br/>**Deployment Modes**:
    /// <br/>- `graceful`: Wait for existing connections to drain before changing topology
    /// <br/>- `force`: Immediately apply changes (may interrupt active connections)
    /// <br/>- `clean`: Tear down completely and rebuild from scratch
    /// <br/>
    /// <br/>**Backend Selection**:
    /// <br/>- If `backend` not specified, uses highest-priority available backend
    /// <br/>- If `backend` specified but unavailable, returns error (no fallback)
    /// <br/>
    /// <br/>**Live Topology Changes**:
    /// <br/>Supports changing service distribution without full restart:
    /// <br/>- Move auth/account to separate container while keeping other services together
    /// <br/>- Scale specific services to additional nodes
    /// <br/>- Update environment variables without restart (where supported)
    /// </remarks>
    /// <returns>Deployment initiated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/deploy")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeployResponse>> Deploy([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeployRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DeployAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get current service-to-app-id routing mappings
    /// </summary>
    /// <remarks>
    /// Returns the current service-to-app-id routing mappings used for mesh service invocation through lib-mesh.
    /// <br/>This is the authoritative source of truth for how services are routed in the current deployment.
    /// <br/>
    /// <br/>In development, all services route to "bannou" by default. In production, services may be
    /// <br/>distributed across multiple app-ids based on deployment topology.
    /// <br/>
    /// <br/>**Use Cases**:
    /// <br/>- Services querying routing on startup
    /// <br/>- Debugging service communication issues
    /// <br/>- Monitoring deployment topology
    /// </remarks>
    /// <returns>Service routing mappings</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/service-routing")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceRoutingResponse>> GetServiceRouting([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetServiceRoutingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetServiceRoutingAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get current environment status
    /// </summary>
    /// <remarks>
    /// Returns comprehensive status of the current deployment including:
    /// <br/>- Active backend and deployment configuration
    /// <br/>- Service topology (which services on which containers)
    /// <br/>- Container health and resource usage
    /// <br/>- Infrastructure component status
    /// <br/>- Active preset and any customizations
    /// </remarks>
    /// <returns>Current environment status</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EnvironmentStatus>> GetStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetStatusAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Tear down the current environment
    /// </summary>
    /// <remarks>
    /// Tears down all containers and services in the current deployment.
    /// <br/>Optionally preserves volumes and networks for faster redeployment.
    /// <br/>
    /// <br/>**Teardown Modes**:
    /// <br/>- `graceful`: Signal shutdown and wait for clean exit
    /// <br/>- `force`: Immediately stop all containers (SIGKILL)
    /// <br/>- `preserve-data`: Keep volumes and networks, only remove containers
    /// </remarks>
    /// <returns>Teardown completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/teardown")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TeardownResponse>> Teardown([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] TeardownRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.TeardownAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Clean up unused resources
    /// </summary>
    /// <remarks>
    /// Prunes unused Docker resources to reclaim disk space and clean up
    /// <br/>orphaned containers, networks, volumes, and images.
    /// <br/>
    /// <br/>Equivalent to running various `docker system prune` commands.
    /// <br/>
    /// <br/>**Clean Targets**:
    /// <br/>- `containers`: Remove stopped containers
    /// <br/>- `networks`: Remove unused networks
    /// <br/>- `volumes`: Remove unused volumes (CAUTION: data loss)
    /// <br/>- `images`: Remove dangling images
    /// <br/>- `all`: All of the above
    /// </remarks>
    /// <returns>Cleanup completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/clean")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanResponse>> Clean([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CleanRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CleanAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get service/container logs
    /// </summary>
    /// <remarks>
    /// Retrieves logs from services or containers with filtering options.
    /// <br/>Supports real-time streaming via WebSocket upgrade.
    /// </remarks>
    /// <returns>Log output</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/logs")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LogsResponse>> GetLogs([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetLogsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetLogsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Update service topology without full redeploy
    /// </summary>
    /// <remarks>
    /// Changes which services run on which containers without tearing down
    /// <br/>the entire environment. Enables live topology changes.
    /// <br/>
    /// <br/>**Use Cases**:
    /// <br/>- Move auth service to dedicated container for scaling
    /// <br/>- Consolidate services during low-traffic periods
    /// <br/>- Split services for debugging/isolation
    /// <br/>- Add new service nodes to running environment
    /// </remarks>
    /// <returns>Topology update applied</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/topology")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TopologyUpdateResponse>> UpdateTopology([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] TopologyUpdateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateTopologyAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Request container restart (self-service pattern)
    /// </summary>
    /// <remarks>
    /// Plugins call this endpoint to request restart of their own container.
    /// <br/>This is part of the self-service configuration update pattern where
    /// <br/>plugins decide if they care about config changes and request restarts.
    /// <br/>
    /// <br/>**Flow**:
    /// <br/>1. Orchestrator publishes ConfigurationChangedEvent with changed keys
    /// <br/>2. Plugins check if any changed keys match their dependencies
    /// <br/>3. Plugins that care call this endpoint to request restart
    /// <br/>4. Orchestrator performs rolling restart of requested containers
    /// <br/>
    /// <br/>**Priority Levels**:
    /// <br/>- `graceful`: Rolling update, wait for healthy before cycling next instance
    /// <br/>- `immediate`: Rolling update but don't wait for connection drain
    /// <br/>- `force`: Kill all instances simultaneously (causes downtime)
    /// </remarks>
    /// <returns>Restart request accepted</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/containers/request-restart")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerRestartResponse>> RequestContainerRestart([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ContainerRestartRequestBody body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RequestContainerRestartAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get container health and restart history
    /// </summary>
    /// <remarks>
    /// Returns detailed status of a container including health, restart history,
    /// <br/>running plugins, and current configuration.
    /// </remarks>
    /// <returns>Container status</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/containers/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerStatus>> GetContainerStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetContainerStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetContainerStatusAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Rollback to previous configuration
    /// </summary>
    /// <remarks>
    /// Quickly rollback to the previous configuration without waiting for CI.
    /// <br/>Swaps currentConfig with previousConfig and publishes ConfigurationChangedEvent
    /// <br/>with the reverted keys so services can request restart.
    /// <br/>
    /// <br/>**Note**: This is a quick fix. GitHub secrets should still be corrected
    /// <br/>to prevent re-breaking on next orchestrator deploy.
    /// </remarks>
    /// <returns>Rollback completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/config/rollback")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfigRollbackResponse>> RollbackConfiguration([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ConfigRollbackRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RollbackConfigurationAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get current configuration version and metadata
    /// </summary>
    /// <remarks>
    /// Returns the current configuration version, last update time,
    /// <br/>and summary of configuration state (not actual values for security).
    /// </remarks>
    /// <returns>Configuration version info</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/config/version")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfigVersionResponse>> GetConfigVersion([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetConfigVersionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetConfigVersionAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Acquire a processor from a pool
    /// </summary>
    /// <remarks>
    /// Requests an available processor instance from the specified pool type.
    /// <br/>Returns the app-id of an available processor or 429 if none available.
    /// <br/>The processor is marked as busy until explicitly released.
    /// </remarks>
    /// <returns>Processor acquired successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/acquire")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AcquireProcessorResponse>> AcquireProcessor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AcquireProcessorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.AcquireProcessorAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Release a processor back to the pool
    /// </summary>
    /// <remarks>
    /// Releases a previously acquired processor, making it available for other requests.
    /// <br/>Should be called when processing is complete or on error cleanup.
    /// </remarks>
    /// <returns>Processor released successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/release")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ReleaseProcessorResponse>> ReleaseProcessor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ReleaseProcessorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ReleaseProcessorAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get processing pool status
    /// </summary>
    /// <remarks>
    /// Returns current status of a processing pool including:
    /// <br/>- Total instances (running and available)
    /// <br/>- Current utilization
    /// <br/>- Queue depth (waiting requests)
    /// <br/>- Recent processing metrics
    /// </remarks>
    /// <returns>Pool status retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PoolStatusResponse>> GetPoolStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetPoolStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetPoolStatusAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Scale a processing pool
    /// </summary>
    /// <remarks>
    /// Manually adjust the size of a processing pool.
    /// <br/>Can scale up (add instances) or scale down (remove idle instances).
    /// <br/>Respects min/max constraints from pool configuration.
    /// </remarks>
    /// <returns>Pool scaled successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/scale")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ScalePoolResponse>> ScalePool([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ScalePoolRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ScalePoolAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Cleanup idle processing pool instances
    /// </summary>
    /// <remarks>
    /// Scales pool back to minimum instances by removing idle processors.
    /// <br/>Used for resource reclamation during low-activity periods.
    /// </remarks>
    /// <returns>Cleanup completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/cleanup")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupPoolResponse>> CleanupPool([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CleanupPoolRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CleanupPoolAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765