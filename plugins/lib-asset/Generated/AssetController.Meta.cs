//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace BeyondImmersion.BannouService.Asset;

/// <summary>
/// Meta/introspection endpoints for runtime schema access.
/// Generated from schemas/Generated/asset-api-meta.yaml
/// </summary>
public partial class AssetController
{
    #region Meta Endpoints for RequestUpload

    private static readonly string _RequestUpload_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UploadRequest",
    "$defs": {
        "UploadRequest": {
            "description": "Request to initiate an asset upload and receive a pre-signed URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "filename",
                "size",
                "contentType",
                "owner"
            ],
            "properties": {
                "owner": {
                    "type": "string",
                    "description": "Owner of this asset operation. NOT a session ID.\nFor user-initiated uploads: the accountId (UUID format).\nFor service-initiated uploads: the service name (e.g., \"behavior\", \"orchestrator\").\n"
                },
                "filename": {
                    "type": "string",
                    "description": "Original filename with extension"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type (e.g., image/png, model/gltf-binary)"
                },
                "metadata": {
                    "$ref": "#/$defs/AssetMetadataInput",
                    "description": "Optional metadata for asset categorization"
                }
            }
        },
        "AssetMetadataInput": {
            "type": "object",
            "additionalProperties": false,
            "description": "User-provided metadata for asset categorization",
            "properties": {
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Type classification for the asset"
                },
                "realm": {
                    "$ref": "#/$defs/GameRealm",
                    "description": "Game realm the asset belongs to"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for the asset"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "GameRealm": {
            "type": "string",
            "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\ nUse \"shared\" for assets that are available across all realms.\n"
        }
    }
}
""";

    private static readonly string _RequestUpload_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UploadResponse",
    "$defs": {
        "UploadResponse": {
            "description": "Response containing pre-signed URL and configuration for uploading an asset",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "uploadId",
                "uploadUrl",
                "expiresAt"
            ],
            "properties": {
                "uploadId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique upload session identifier"
                },
                "uploadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for uploading the file"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the upload URL expires"
                },
                "multipart": {
                    "$ref": "#/$defs/MultipartConfig",
                    "description": "Configuration for multipart uploads if file size requires it"
                },
                "requiredHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Headers the client must include when uploading to the pre-signed URL"
                }
            }
        },
        "MultipartConfig": {
            "description": "Configuration for multipart uploads of large files",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "required": {
                    "type": "boolean",
                    "description": "Whether multipart upload is required for this file size"
                },
                "partSize": {
                    "type": "integer",
                    "description": "Size of each part in bytes"
                },
                "maxParts": {
                    "type": "integer",
                    "description": "Maximum number of parts"
                },
                "uploadUrls": {
                    "type": "array",
                    "nullable": true,
                    "description": "Pre-signed URLs for each part of the multipart upload",
                    "items": {
                        "$ref": "#/$defs/PartUploadInfo"
                    }
                }
            }
        },
        "PartUploadInfo": {
            "description": "Upload information for a single part in a multipart upload",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "partNumber",
                "uploadUrl"
            ],
            "properties": {
                "partNumber": {
                    "type": "integer",
                    "description": "Part number (1-based)"
                },
                "uploadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for uploading this part"
                },
                "minSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Minimum size for this part"
                },
                "maxSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Maximum size for this part"
                }
            }
        }
    }
}
""";

    private static readonly string _RequestUpload_Info = """
{
    "summary": "Request upload URL for a new asset",
    "description": "Generate a pre-signed URL for uploading a new asset directly to storage.\nFor large files (>50MB), returns multipart upload configuration.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "requestUpload"
}
""";

    /// <summary>Returns endpoint information for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/upload/request/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/assets/upload/request",
            _RequestUpload_Info));

    /// <summary>Returns request schema for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/upload/request/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/assets/upload/request",
            "request-schema",
            _RequestUpload_RequestSchema));

    /// <summary>Returns response schema for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/upload/request/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/assets/upload/request",
            "response-schema",
            _RequestUpload_ResponseSchema));

    /// <summary>Returns full schema for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/upload/request/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/assets/upload/request",
            _RequestUpload_Info,
            _RequestUpload_RequestSchema,
            _RequestUpload_ResponseSchema));

    #endregion

    #region Meta Endpoints for CompleteUpload

    private static readonly string _CompleteUpload_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CompleteUploadRequest",
    "$defs": {
        "CompleteUploadRequest": {
            "description": "Request to finalize an upload and trigger asset processing",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "uploadId"
            ],
            "properties": {
                "uploadId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Upload session ID from requestUpload"
                },
                "parts": {
                    "type": "array",
                    "nullable": true,
                    "description": "For multipart uploads - ETags of completed parts (null for single-file uploads)",
                    "items": {
                        "$ref": "#/$defs/CompletedPart"
                    }
                }
            }
        },
        "CompletedPart": {
            "description": "Information about a completed part in a multipart upload",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "partNumber",
                "etag"
            ],
            "properties": {
                "partNumber": {
                    "type": "integer",
                    "description": "Part number (1-based)"
                },
                "etag": {
                    "type": "string",
                    "description": "ETag returned from part upload"
                }
            }
        }
    }
}
""";

    private static readonly string _CompleteUpload_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetMetadata",
    "$defs": {
        "AssetMetadata": {
            "type": "object",
            "additionalProperties": false,
            "description": "Complete asset metadata including system-generated fields",
            "required": [
                "assetId",
                "contentHash",
                "filename",
                "contentType",
                "size",
                "assetType",
                "realm",
                "tags",
                "processingStatus",
                "isArchived",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "filename": {
                    "type": "string",
                    "description": "Original filename"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Type classification for the asset"
                },
                "realm": {
                    "$ref": "#/$defs/GameRealm",
                    "description": "Game realm the asset belongs to"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for the asset"
                },
                "processingStatus": {
                    "$ref": "#/$defs/ProcessingStatus",
                    "description": "Current status of asset processing pipeline"
                },
                "isArchived": {
                    "type": "boolean",
                    "description": "Whether the asset is in cold/archival storage",
                    "default": false
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was last updated"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "GameRealm": {
            "type": "string",
            "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\nUse \"shared\" for assets that are available across all realms.\n"
        },
        "ProcessingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "processing",
                "complete",
                "failed"
            ],
            "description": "Asset processing pipeline status"
        }
    }
}
""";

    private static readonly string _CompleteUpload_Info = """
{
    "summary": "Mark upload as complete, trigger processing",
    "description": "Called after the client has uploaded the file to the pre-signed URL.\nTriggers the asset processing pipeline (texture conversion, model validation, etc.)\nand emits completion events via WebSocket.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "completeUpload"
}
""";

    /// <summary>Returns endpoint information for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/upload/complete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/assets/upload/complete",
            _CompleteUpload_Info));

    /// <summary>Returns request schema for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/upload/complete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/assets/upload/complete",
            "request-schema",
            _CompleteUpload_RequestSchema));

    /// <summary>Returns response schema for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/upload/complete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/assets/upload/complete",
            "response-schema",
            _CompleteUpload_ResponseSchema));

    /// <summary>Returns full schema for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/upload/complete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/assets/upload/complete",
            _CompleteUpload_Info,
            _CompleteUpload_RequestSchema,
            _CompleteUpload_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetAsset

    private static readonly string _GetAsset_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetAssetRequest",
    "$defs": {
        "GetAssetRequest": {
            "description": "Request to retrieve asset metadata and download URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Asset identifier"
                },
                "version": {
                    "type": "string",
                    "default": "latest",
                    "description": "Version ID or 'latest'"
                }
            }
        }
    }
}
""";

    private static readonly string _GetAsset_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetWithDownloadUrl",
    "$defs": {
        "AssetWithDownloadUrl": {
            "description": "Asset metadata with optional pre-signed download URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId",
                "versionId",
                "size",
                "contentHash",
                "contentType",
                "metadata"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "versionId": {
                    "type": "string",
                    "description": "Version identifier for this specific asset version"
                },
                "downloadUrl": {
                    "type": "string",
                    "format": "uri",
                    "nullable": true,
                    "description": "Pre-signed download URL (only populated when requested)"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the download URL expires (only populated when requested)"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "metadata": {
                    "$ref": "#/$defs/AssetMetadata",
                    "description": "Complete asset metadata"
                }
            }
        },
        "AssetMetadata": {
            "type": "object",
            "additionalProperties": false,
            "description": "Complete asset metadata including system-generated fields",
            "required": [
                "assetId",
                "contentHash",
                "filename",
                "contentType",
                "size",
                "assetType",
                "realm",
                "tags",
                "processingStatus",
                "isArchived",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "filename": {
                    "type": "string",
                    "description": "Original filename"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Type classification for the asset"
                },
                "realm": {
                    "$ref": "#/$defs/GameRealm",
                    "description": "Game realm the asset belongs to"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for the asset"
                },
                "processingStatus": {
                    "$ref": "#/$defs/ProcessingStatus",
                    "description": "Current status of asset processing pipeline"
                },
                "isArchived": {
                    "type": "boolean",
                    "description": "Whether the asset is in cold/archival storage",
                    "default": false
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was last updated"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "GameRealm": {
            "type": "string",
            "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\ nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\nUse \"shared\" for assets that are available across all realms.\n"
        },
        "ProcessingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "processing",
                "complete",
                "failed"
            ],
            "description": "Asset processing pipeline status"
        }
    }
}
""";

    private static readonly string _GetAsset_Info = """
{
    "summary": "Get asset metadata and download URL",
    "description": "Retrieve asset metadata and generate a pre-signed download URL.\nSpecify version to download a specific version, or omit for latest.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "getAsset"
}
""";

    /// <summary>Returns endpoint information for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/assets/get",
            _GetAsset_Info));

    /// <summary>Returns request schema for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/assets/get",
            "request-schema",
            _GetAsset_RequestSchema));

    /// <summary>Returns response schema for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/assets/get",
            "response-schema",
            _GetAsset_ResponseSchema));

    /// <summary>Returns full schema for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/assets/get",
            _GetAsset_Info,
            _GetAsset_RequestSchema,
            _GetAsset_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeleteAsset

    private static readonly string _DeleteAsset_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteAssetRequest",
    "$defs": {
        "DeleteAssetRequest": {
            "description": "Request to delete an asset from storage",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Asset identifier to delete"
                },
                "versionId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Specific version to delete. If omitted, all versions are deleted.\n"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteAsset_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteAssetResponse",
    "$defs": {
        "DeleteAssetResponse": {
            "description": "Response confirming asset deletion",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId",
                "versionsDeleted"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Deleted asset identifier"
                },
                "versionsDeleted": {
                    "type": "integer",
                    "description": "Number of versions deleted"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteAsset_Info = """
{
    "summary": "Delete an asset",
    "description": "Delete an asset from storage. If versionId is specified, only that version is deleted.\nIf versionId is omitted, all versions are deleted.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "deleteAsset"
}
""";

    /// <summary>Returns endpoint information for DeleteAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteAsset_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/assets/delete",
            _DeleteAsset_Info));

    /// <summary>Returns request schema for DeleteAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteAsset_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/assets/delete",
            "request-schema",
            _DeleteAsset_RequestSchema));

    /// <summary>Returns response schema for DeleteAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteAsset_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/assets/delete",
            "response-schema",
            _DeleteAsset_ResponseSchema));

    /// <summary>Returns full schema for DeleteAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteAsset_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/assets/delete",
            _DeleteAsset_Info,
            _DeleteAsset_RequestSchema,
            _DeleteAsset_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListAssetVersions

    private static readonly string _ListAssetVersions_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListVersionsRequest",
    "$defs": {
        "ListVersionsRequest": {
            "description": "Request to list all versions of an asset with pagination",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Asset identifier to list versions for"
                },
                "limit": {
                    "type": "integer",
                    "default": 50,
                    "description": "Maximum number of versions to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Number of versions to skip for pagination"
                }
            }
        }
    }
}
""";

    private static readonly string _ListAssetVersions_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetVersionList",
    "$defs": {
        "AssetVersionList": {
            "description": "Paginated list of asset versions",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId",
                "versions",
                "total",
                "limit",
                "offset"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Asset identifier"
                },
                "versions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetVersion"
                    },
                    "description": "List of asset versions"
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of versions available"
                },
                "limit": {
                    "type": "integer",
                    "description": "Maximum number of versions returned per page"
                },
                "offset": {
                    "type": "integer",
                    "description": "Number of versions skipped"
                }
            }
        },
        "AssetVersion": {
            "description": "Metadata for a specific version of an asset",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "versionId",
                "createdAt",
                "size",
                "isArchived"
            ],
            "properties": {
                "versionId": {
                    "type": "string",
                    "description": "Unique version identifier"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when this version was created"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes for this version"
                },
                "isArchived": {
                    "type": "boolean",
                    "description": "Whether this version is in cold storage"
                }
            }
        }
    }
}
""";

    private static readonly string _ListAssetVersions_Info = """
{
    "summary": "List all versions of an asset",
    "description": "Retrieve version history for an asset with pagination.\nIncludes version IDs, creation timestamps, and archive status.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "listAssetVersions"
}
""";

    /// <summary>Returns endpoint information for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/list-versions/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/assets/list-versions",
            _ListAssetVersions_Info));

    /// <summary>Returns request schema for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/list-versions/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/assets/list-versions",
            "request-schema",
            _ListAssetVersions_RequestSchema));

    /// <summary>Returns response schema for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/list-versions/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/assets/list-versions",
            "response-schema",
            _ListAssetVersions_ResponseSchema));

    /// <summary>Returns full schema for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/list-versions/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/assets/list-versions",
            _ListAssetVersions_Info,
            _ListAssetVersions_RequestSchema,
            _ListAssetVersions_ResponseSchema));

    #endregion

    #region Meta Endpoints for SearchAssets

    private static readonly string _SearchAssets_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetSearchRequest",
    "$defs": {
        "AssetSearchRequest": {
            "description": "Search criteria for filtering assets with pagination",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetType",
                "realm"
            ],
            "properties": {
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Filter by tags (assets must have all specified tags) (null to skip tag filtering)"
                },
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Filter by asset type"
                },
                "realm": {
                    "$ref": "#/$defs/GameRealm",
                    "description": "Filter by game realm"
                },
                "contentType": {
                    "type": "string",
                    "nullable": true,
                    "description": "MIME content type filter (null to skip content type filtering)"
                },
                "limit": {
                    "type": "integer",
                    "default": 50,
                    "description": "Maximum number of results to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Number of results to skip for pagination"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "GameRealm": {
            "type": "string",
            "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\ nUse \"shared\" for assets that are available across all realms.\n"
        }
    }
}
""";

    private static readonly string _SearchAssets_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetSearchResult",
    "$defs": {
        "AssetSearchResult": {
            "description": "Paginated results from an asset search query",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assets",
                "total",
                "limit",
                "offset"
            ],
            "properties": {
                "assets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetMetadata"
                    },
                    "description": "List of matching assets"
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of matching assets"
                },
                "limit": {
                    "type": "integer",
                    "description": "Maximum number of results returned per page"
                },
                "offset": {
                    "type": "integer",
                    "description": "Number of results skipped"
                }
            }
        },
        "AssetMetadata": {
            "type": "object",
            "additionalProperties": false,
            "description": "Complete asset metadata including system-generated fields",
            "required": [
                "assetId",
                "contentHash",
                "filename",
                "contentType",
                "size",
                "assetType",
                "realm",
                "tags",
                "processingStatus",
                "isArchived",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "filename": {
                    "type": "string",
                    "description": "Original filename"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Type classification for the asset"
                },
                "realm": {
                    "$ref": "#/$defs/GameRealm",
                    "description": "Game realm the asset belongs to"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for the asset"
                },
                "processingStatus": {
                    "$ref": "#/$defs/ProcessingStatus",
                    "description": "Current status of asset processing pipeline"
                },
                "isArchived": {
                    "type": "boolean",
                    "description": "Whether the asset is in cold/archival storage",
                    "default": false
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was last updated"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "GameRealm": {
            "type": "string",
            "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\ nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\nUse \"shared\" for assets that are available across all realms.\n"
        },
        "ProcessingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "processing",
                "complete",
                "failed"
            ],
            "description": "Asset processing pipeline status"
        }
    }
}
""";

    private static readonly string _SearchAssets_Info = """
{
    "summary": "Search assets by tags, type, or realm",
    "description": "Search assets using various filters with pagination.\nAll filters are optional and combine with AND logic.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "searchAssets"
}
""";

    /// <summary>Returns endpoint information for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/search/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/assets/search",
            _SearchAssets_Info));

    /// <summary>Returns request schema for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/search/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/assets/search",
            "request-schema",
            _SearchAssets_RequestSchema));

    /// <summary>Returns response schema for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/search/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/assets/search",
            "response-schema",
            _SearchAssets_ResponseSchema));

    /// <summary>Returns full schema for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/search/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/assets/search",
            _SearchAssets_Info,
            _SearchAssets_RequestSchema,
            _SearchAssets_ResponseSchema));

    #endregion

    #region Meta Endpoints for CreateBundle

    private static readonly string _CreateBundle_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateBundleRequest",
    "$defs": {
        "CreateBundleRequest": {
            "description": "Request to create a new asset bundle from multiple assets",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bundleId",
                "assetIds",
                "owner"
            ],
            "properties": {
                "owner": {
                    "type": "string",
                    "description": "Owner of this bundle. NOT a session ID.\nFor user-initiated bundles: the accountId (UUID format).\nFor service-initiated bundles: the service name (e.g., \"orchestrator\").\n"
                },
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier (e.g., \"synty/polygon-adventure\", \"my-bundle-v1\")"
                },
                "version": {
                    "type": "string",
                    "default": "1.0.0",
                    "description": "Bundle version string"
                },
                "realm": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/GameRealm"
                        }
                    ],
                    "nullable": true,
                    "description": "Game realm this bundle belongs to.\nDefaults to 'shared' if not specified.\n"
                },
                "assetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of asset IDs to include in the bundle"
                },
                "compression": {
                    "$ref": "#/$defs/CompressionType",
                    "description": "Compression algorithm to use for the bundle"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Custom metadata for the bundle (null if none). No Bannou plugin reads specific keys from this field by convention."
                }
            }
        },
        "GameRealm": {
            "type": "string",
            "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\nUse \"shared\" for assets that are available across all realms.\n"
        },
        "CompressionType": {
            "type": "string",
            "enum": [
                "lz4",
                "lzma",
                "none"
            ],
            "description": "Compression algorithm for bundles"
        }
    }
}
""";

    private static readonly string _CreateBundle_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateBundleResponse",
    "$defs": {
        "CreateBundleResponse": {
            "description": "Response with bundle creation status and estimated size",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bundleId",
                "status",
                "estimatedSize"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier (e.g., \"synty/polygon-adventure\", \"my-bundle-v1\")"
                },
                "status": {
                    "type": "string",
                    "enum": [
                        "queued",
                        "processing",
                        "ready",
                        "failed"
                    ],
                    "description": "Bundle creation status"
                },
                "estimatedSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Estimated bundle size in bytes"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateBundle_Info = """
{
    "summary": "Create asset bundle from multiple assets",
    "description": "Create a .bannou bundle containing multiple assets.\nFor large bundles, processing is delegated to the processing pool.\ nCompletion notification sent via WebSocket event.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "createBundle"
}
""";

    /// <summary>Returns endpoint information for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/bundles/create",
            _CreateBundle_Info));

    /// <summary>Returns request schema for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/create",
            "request-schema",
            _CreateBundle_RequestSchema));

    /// <summary>Returns response schema for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/create",
            "response-schema",
            _CreateBundle_ResponseSchema));

    /// <summary>Returns full schema for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/bundles/create",
            _CreateBundle_Info,
            _CreateBundle_RequestSchema,
            _CreateBundle_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetBundle

    private static readonly string _GetBundle_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetBundleRequest",
    "$defs": {
        "GetBundleRequest": {
            "description": "Request to retrieve bundle metadata and download URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bundleId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier to retrieve"
                },
                "format": {
                    "$ref": "#/$defs/BundleFormat",
                    "description": "Desired download format (bannou or zip)"
                }
            }
        },
        "BundleFormat": {
            "type": "string",
            "enum": [
                "bannou",
                "zip"
            ],
            "description": "Bundle file format"
        }
    }
}
""";

    private static readonly string _GetBundle_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BundleWithDownloadUrl",
    "$defs": {
        "BundleWithDownloadUrl": {
            "description": "Bundle metadata combined with a pre-signed download URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bundleId",
                "version",
                "downloadUrl",
                "format",
                "expiresAt",
                "size",
                "assetCount",
                "fromCache"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier (e.g., \"synty/polygon-adventure\", \"my-bundle-v1\")"
                },
                "version": {
                    "type": "string",
                    "description": "Bundle version string"
                },
                "downloadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for downloading the bundle"
                },
                "format": {
                    "$ref": "#/$defs/BundleFormat",
                    "description": "Format of the downloadable bundle"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the download URL expires"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Bundle file size in bytes"
                },
                "assetCount": {
                    "type": "integer",
                    "description": "Number of assets contained in the bundle"
                },
                "fromCache": {
                    "type": "boolean",
                    "description": "True if ZIP format was served from conversion cache"
                }
            }
        },
        "BundleFormat": {
            "type": "string",
            "enum": [
                "bannou",
                "zip"
            ],
            "description": "Bundle file format"
        }
    }
}
""";

    private static readonly string _GetBundle_Info = """
{
    "summary": "Get bundle manifest and download URL",
    "description": "Retrieve bundle metadata and generate a pre-signed download URL.\nSupports both native .bannou format and ZIP conversion (cached).\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "getBundle"
}
""";

    /// <summary>Returns endpoint information for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/bundles/get",
            _GetBundle_Info));

    /// <summary>Returns request schema for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/get",
            "request-schema",
            _GetBundle_RequestSchema));

    /// <summary>Returns response schema for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/get",
            "response-schema",
            _GetBundle_ResponseSchema));

    /// <summary>Returns full schema for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/bundles/get",
            _GetBundle_Info,
            _GetBundle_RequestSchema,
            _GetBundle_ResponseSchema));

    #endregion

    #region Meta Endpoints for RequestBundleUpload

    private static readonly string _RequestBundleUpload_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BundleUploadRequest",
    "$defs": {
        "BundleUploadRequest": {
            "description": "Request to upload a pre-built asset bundle file",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "filename",
                "size",
                "owner"
            ],
            "properties": {
                "owner": {
                    "type": "string",
                    "description": "Owner of this bundle upload. NOT a session ID.\nFor user-initiated uploads: the accountId (UUID format).\nFor service-initiated uploads: the service name (e.g., \"orchestrator\").\n"
                },
                "filename": {
                    "type": "string",
                    "description": "Must end with .bannou or .zip"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Bundle file size in bytes"
                },
                "manifestPreview": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/BundleManifestPreview"
                        }
                    ],
                    "nullable": true,
                    "description": "Optional preview of bundle manifest for validation"
                }
            }
        },
        "BundleManifestPreview": {
            "type": "object",
            "additionalProperties": false,
            "description": "Preview of bundle manifest for validation",
            "required": [
                "bundleId",
                "version",
                "assetCount"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier from the manifest"
                },
                "version": {
                    "type": "string",
                    "description": "Bundle version from the manifest"
                },
                "assetCount": {
                    "type": "integer",
                    "description": "Number of assets declared in the manifest"
                }
            }
        }
    }
}
""";

    private static readonly string _RequestBundleUpload_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UploadResponse",
    "$defs": {
        "UploadResponse": {
            "description": "Response containing pre-signed URL and configuration for uploading an asset",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "uploadId",
                "uploadUrl",
                "expiresAt"
            ],
            "properties": {
                "uploadId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique upload session identifier"
                },
                "uploadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for uploading the file"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the upload URL expires"
                },
                "multipart": {
                    "$ref": "#/$defs/MultipartConfig",
                    "description": "Configuration for multipart uploads if file size requires it"
                },
                "requiredHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Headers the client must include when uploading to the pre-signed URL"
                }
            }
        },
        "MultipartConfig": {
            "description": "Configuration for multipart uploads of large files",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "required": {
                    "type": "boolean",
                    "description": "Whether multipart upload is required for this file size"
                },
                "partSize": {
                    "type": "integer",
                    "description": "Size of each part in bytes"
                },
                "maxParts": {
                    "type": "integer",
                    "description": "Maximum number of parts"
                },
                "uploadUrls": {
                    "type": "array",
                    "nullable": true,
                    "description": "Pre-signed URLs for each part of the multipart upload",
                    "items": {
                        "$ref": "#/$defs/PartUploadInfo"
                    }
                }
            }
        },
        "PartUploadInfo": {
            "description": "Upload information for a single part in a multipart upload",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "partNumber",
                "uploadUrl"
            ],
            "properties": {
                "partNumber": {
                    "type": "integer",
                    "description": "Part number (1-based)"
                },
                "uploadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for uploading this part"
                },
                "minSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Minimum size for this part"
                },
                "maxSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Maximum size for this part"
                }
            }
        }
    }
}
""";

    private static readonly string _RequestBundleUpload_Info = """
{
    "summary": "Request upload URL for a pre-made bundle",
    "description": "Upload a pre-built bundle (.bannou or .zip format).\nAfter upload, the bundle undergoes validation before registration.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "requestBundleUpload"
}
""";

    /// <summary>Returns endpoint information for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/upload/request/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/bundles/upload/request",
            _RequestBundleUpload_Info));

    /// <summary>Returns request schema for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/upload/request/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/upload/request",
            "request-schema",
            _RequestBundleUpload_RequestSchema));

    /// <summary>Returns response schema for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/upload/request/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/upload/request",
            "response-schema",
            _RequestBundleUpload_ResponseSchema));

    /// <summary>Returns full schema for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/upload/request/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/bundles/upload/request",
            _RequestBundleUpload_Info,
            _RequestBundleUpload_RequestSchema,
            _RequestBundleUpload_ResponseSchema));

    #endregion

    #region Meta Endpoints for CreateMetabundle

    private static readonly string _CreateMetabundle_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateMetabundleRequest",
    "$defs": {
        "CreateMetabundleRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to create a metabundle from source bundles and/or standalone assets.\ nAt least one of sourceBundleIds or standaloneAssetIds must be provided.\nThis enables packaging behaviors/scripts with 3D assets as a complete unit.\n",
            "required": [
                "metabundleId",
                "owner",
                "realm"
            ],
            "properties": {
                "metabundleId": {
                    "type": "string",
                    "description": "Human-readable identifier for the new metabundle (e.g., \"game-assets-v1\")"
                },
                "sourceBundleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Human-readable source bundle IDs (e.g., \"synty/polygon-adventure\") to pull assets from.\nCan cherry-pick specific assets using assetFilter, or include all if assetFilter is null.\n"
                },
                "standaloneAssetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Individual asset IDs (not in bundles) to include directly.\nUseful for including behaviors, scripts, or metadata files\nalongside bundled 3D assets.\n"
                },
                "version": {
                    "type": "string",
                    "default": "1.0.0",
                    "description": "Metabundle version string"
                },
                "owner": {
                    "type": "string",
                    "description": "Owner of this metabundle. NOT a session ID.\nFor user-initiated: the accountId (UUID format).\nFor service-initiated: the service name.\n"
                },
                "realm": {
                    "$ref": "#/$defs/GameRealm",
                    "description": "Game realm for this metabundle"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Human-readable description"
                },
                "assetFilter": {
                    "type": "array",
                    "nullable": true,
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional subset of asset IDs to include FROM SOURCE BUNDLES.\nIf null, all assets from source bundles are included.\nStandalone assets are always included regardless of this filter.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Custom metadata for the metabundle. No Bannou plugin reads specific keys from this field by convention."
                }
            }
        },
        "GameRealm": {
            "type": "string",
            "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\ nUse \"shared\" for assets that are available across all realms.\n"
        }
    }
}
""";

    private static readonly string _CreateMetabundle_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateMetabundleResponse",
    "$defs": {
        "CreateMetabundleResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response from metabundle creation.\nFor synchronous creation (small jobs): status=ready with downloadUrl.\nFor async creation (large jobs): status=queued with jobId for polling.\n",
            "required": [
                "metabundleId",
                "status",
                "assetCount",
                "sizeBytes"
            ],
            "properties": {
                "metabundleId": {
                    "type": "string",
                    "description": "Human-readable metabundle identifier"
                },
                "jobId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Job ID for async processing. Only present when status is 'queued' or 'processing'.\nUse /bundles/job/status to poll for completion, or wait for\nMetabundleCreationCompleteEvent via WebSocket.\n"
                },
                "status": {
                    "type": "string",
                    "enum": [
                        "queued",
                        "processing",
                        "ready",
                        "failed"
                    ],
                    "description": "Creation status.\n- queued: Job accepted for async processing (poll with jobId)\n- processing: Job is actively running\n- ready: Metabundle created and available for download\n- failed: Creation failed (see conflicts for details)\n"
                },
                "downloadUrl": {
                    "type": "string",
                    "format": "uri",
                    "nullable": true,
                    "description": "Pre-signed download URL (only present when status is 'ready')"
                },
                "assetCount": {
                    "type": "integer",
                    "description": "Number of assets in the metabundle"
                },
                "standaloneAssetCount": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Number of standalone assets included directly (not from bundles)"
                },
                "sizeBytes": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Total size in bytes"
                },
                "sourceBundles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SourceBundleReference"
                    },
                    "description": "Provenance data for the metabundle"
                },
                "conflicts": {
                    "type": "array",
                    "nullable": true,
                    "items": {
                        "$ref": "#/$defs/AssetConflict"
                    },
                    "description": "Present if creation failed due to asset conflicts"
                }
            }
        },
        "SourceBundleReference": {
            "type": "object",
            "additionalProperties": false,
            "description": "Provenance reference to a source bundle used in metabundle creation",
            "required": [
                "bundleId",
                "version",
                "assetIds",
                "contentHash"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Source bundle identifier"
                },
                "version": {
                    "type": "string",
                    "description": "Version of source bundle at composition time"
                },
                "assetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Asset IDs contributed from this source bundle"
                },
                "contentHash": {
                    "type": "string",
                    "description": "Hash of source bundle at composition time (for integrity verification)"
                }
            }
        },
        "AssetConflict": {
            "type": "object",
            "additionalProperties": false,
            "description": "Describes a conflict when the same asset ID has different content hashes",
            "required": [
                "assetId",
                "conflictingBundles"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "The conflicting asset identifier"
                },
                "conflictingBundles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ConflictingBundleEntry"
                    },
                    "description": "Bundles with conflicting versions of this asset"
                }
            }
        },
        "ConflictingBundleEntry": {
            "type": "object",
            "additionalProperties": false,
            "description": "A bundle entry in an asset conflict",
            "required": [
                "bundleId",
                "contentHash"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Bundle containing this version"
                },
                "contentHash": {
                    "type": "string",
                    "description": "Content hash of asset in this bundle"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateMetabundle_Info = """
{
    "summary": "Create metabundle from source bundles",
    "description": "Compose a metabundle by extracting and repackaging assets from multiple\nsource bundles. The resulting metabundle is a complete physical copy with\nprovenance metadata tracking the source bundles.\n\nAssets are deduplicated by content hash. If the same asset ID exists in\nmultiple source bundles with different content hashes, the request fails\nwith conflict details.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "createMetabundle"
}
""";

    /// <summary>Returns endpoint information for CreateMetabundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/metabundle/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateMetabundle_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/bundles/metabundle/create",
            _CreateMetabundle_Info));

    /// <summary>Returns request schema for CreateMetabundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/metabundle/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateMetabundle_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/metabundle/create",
            "request-schema",
            _CreateMetabundle_RequestSchema));

    /// <summary>Returns response schema for CreateMetabundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/metabundle/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateMetabundle_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/metabundle/create",
            "response-schema",
            _CreateMetabundle_ResponseSchema));

    /// <summary>Returns full schema for CreateMetabundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/metabundle/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateMetabundle_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/bundles/metabundle/create",
            _CreateMetabundle_Info,
            _CreateMetabundle_RequestSchema,
            _CreateMetabundle_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetJobStatus

    private static readonly string _GetJobStatus_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetJobStatusRequest",
    "$defs": {
        "GetJobStatusRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to get the status of an async metabundle creation job",
            "required": [
                "jobId"
            ],
            "properties": {
                "jobId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Job ID from the createMetabundle response"
                }
            }
        }
    }
}
""";

    private static readonly string _GetJobStatus_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetJobStatusResponse",
    "$defs": {
        "GetJobStatusResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Status of an async metabundle creation job.\nWhen status is 'ready', the response includes the full metabundle details.\n",
            "required": [
                "jobId",
                "metabundleId",
                "status"
            ],
            "properties": {
                "jobId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Job identifier"
                },
                "metabundleId": {
                    "type": "string",
                    "description": "Human-readable metabundle identifier being created"
                },
                "status": {
                    "type": "string",
                    "enum": [
                        "queued",
                        "processing",
                        "ready",
                        "failed",
                        "cancelled"
                    ],
                    "description": "Current job status.\n- queued: Waiting for processing resources\n- processing: Actively being processed\n- ready: Completed successfully\n- failed: Creation failed\ n- cancelled: Job was cancelled\n"
                },
                "progress": {
                    "type": "integer",
                    "minimum": 0,
                    "maximum": 100,
                    "nullable": true,
                    "description": "Progress percentage (0-100) when status is 'processing'"
                },
                "downloadUrl": {
                    "type": "string",
                    "format": "uri",
                    "nullable": true,
                    "description": "Pre-signed download URL (only when status is 'ready')"
                },
                "assetCount": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Number of assets in metabundle (when ready)"
                },
                "standaloneAssetCount": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Number of standalone assets included (when ready)"
                },
                "sizeBytes": {
                    "type": "integer",
                    "format": "int64",
                    "nullable": true,
                    "description": "Total size in bytes (when ready)"
                },
                "sourceBundles": {
                    "type": "array",
                    "nullable": true,
                    "items": {
                        "$ref": "#/$defs/SourceBundleReference"
                    },
                    "description": "Provenance data (when ready)"
                },
                "errorCode": {
                    "type": "string",
                    "nullable": true,
                    "description": "Error code (when status is 'failed')"
                },
                "errorMessage": {
                    "type": "string",
                    "nullable": true,
                    "description": "Human-readable error description (when status is 'failed')"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the job was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the job was last updated"
                },
                "processingTimeMs": {
                    "type": "integer",
                    "format": "int64",
                    "nullable": true,
                    "description": "Total processing time in milliseconds (when complete)"
                }
            }
        },
        "SourceBundleReference": {
            "type": "object",
            "additionalProperties": false,
            "description": "Provenance reference to a source bundle used in metabundle creation",
            "required": [
                "bundleId",
                "version",
                "assetIds",
                "contentHash"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Source bundle identifier"
                },
                "version": {
                    "type": "string",
                    "description": "Version of source bundle at composition time"
                },
                "assetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Asset IDs contributed from this source bundle"
                },
                "contentHash": {
                    "type": "string",
                    "description": "Hash of source bundle at composition time (for integrity verification)"
                }
            }
        }
    }
}
""";

    private static readonly string _GetJobStatus_Info = """
{
    "summary": "Get async metabundle job status",
    "description": "Poll the status of an async metabundle creation job.\nUse the jobId returned from createMetabundle when status was 'queued'.\n\ nClients can either poll this endpoint or wait for the\nMetabundleCreationCompleteEvent via WebSocket for completion notification.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "getJobStatus"
}
""";

    /// <summary>Returns endpoint information for GetJobStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/job/status/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetJobStatus_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/bundles/job/status",
            _GetJobStatus_Info));

    /// <summary>Returns request schema for GetJobStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/job/status/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetJobStatus_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/job/status",
            "request-schema",
            _GetJobStatus_RequestSchema));

    /// <summary>Returns response schema for GetJobStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/job/status/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetJobStatus_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/job/status",
            "response-schema",
            _GetJobStatus_ResponseSchema));

    /// <summary>Returns full schema for GetJobStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/job/status/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetJobStatus_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/bundles/job/status",
            _GetJobStatus_Info,
            _GetJobStatus_RequestSchema,
            _GetJobStatus_ResponseSchema));

    #endregion

    #region Meta Endpoints for CancelJob

    private static readonly string _CancelJob_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CancelJobRequest",
    "$defs": {
        "CancelJobRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to cancel an async metabundle creation job",
            "required": [
                "jobId"
            ],
            "properties": {
                "jobId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Job ID from the createMetabundle response"
                }
            }
        }
    }
}
""";

    private static readonly string _CancelJob_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CancelJobResponse",
    "$defs": {
        "CancelJobResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Result of job cancellation attempt",
            "required": [
                "jobId",
                "cancelled",
                "status"
            ],
            "properties": {
                "jobId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Job identifier"
                },
                "cancelled": {
                    "type": "boolean",
                    "description": "Whether the job was successfully cancelled"
                },
                "status": {
                    "type": "string",
                    "enum": [
                        "queued",
                        "processing",
                        "ready",
                        "failed",
                        "cancelled"
                    ],
                    "description": "Current job status after cancellation attempt"
                },
                "message": {
                    "type": "string",
                    "nullable": true,
                    "description": "Additional context about the cancellation result"
                }
            }
        }
    }
}
""";

    private static readonly string _CancelJob_Info = """
{
    "summary": "Cancel an async metabundle job",
    "description": "Cancel a pending or processing metabundle creation job.\nJobs that are already completed (ready or failed) cannot be cancelled.\n\nSuccessfully cancelled jobs will emit a MetabundleCreationCompleteEvent\nwith status 'cancelled' via WebSocket.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "cancelJob"
}
""";

    /// <summary>Returns endpoint information for CancelJob</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/job/cancel/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CancelJob_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/bundles/job/cancel",
            _CancelJob_Info));

    /// <summary>Returns request schema for CancelJob</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/job/cancel/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CancelJob_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/job/cancel",
            "request-schema",
            _CancelJob_RequestSchema));

    /// <summary>Returns response schema for CancelJob</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/job/cancel/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CancelJob_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/job/cancel",
            "response-schema",
            _CancelJob_ResponseSchema));

    /// <summary>Returns full schema for CancelJob</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/job/cancel/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CancelJob_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/bundles/job/cancel",
            _CancelJob_Info,
            _CancelJob_RequestSchema,
            _CancelJob_ResponseSchema));

    #endregion

    #region Meta Endpoints for ResolveBundles

    private static readonly string _ResolveBundles_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ResolveBundlesRequest",
    "$defs": {
        "ResolveBundlesRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to resolve optimal bundle downloads for requested assets",
            "required": [
                "assetIds",
                "realm"
            ],
            "properties": {
                "assetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Platform asset IDs to resolve"
                },
                "realm": {
                    "$ref": "#/$defs/GameRealm",
                    "description": "Game realm to search within"
                },
                "preferMetabundles": {
                    "type": "boolean",
                    "default": true,
                    "description": "Prefer metabundles when coverage is equal"
                },
                "includeStandalone": {
                    "type": "boolean",
                    "default": true,
                    "description": "Include standalone assets not in any bundle"
                },
                "maxBundles": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum number of bundles to return (optimization limit)"
                }
            }
        },
        "GameRealm": {
            "type": "string",
            "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\nUse \"shared\" for assets that are available across all realms.\n"
        }
    }
}
""";

    private static readonly string _ResolveBundles_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ResolveBundlesResponse",
    "$defs": {
        "ResolveBundlesResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Optimal bundle set for requested assets",
            "required": [
                "bundles",
                "standaloneAssets",
                "coverage"
            ],
            "properties": {
                "bundles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ResolvedBundle"
                    },
                    "description": "Bundles to download"
                },
                "standaloneAssets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ResolvedAsset"
                    },
                    "description": "Individual assets to download"
                },
                "coverage": {
                    "$ref": "#/$defs/CoverageAnalysis",
                    "description": "Coverage statistics"
                },
                "unresolved": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Asset IDs that couldn't be found (null if all resolved)"
                }
            }
        },
        "ResolvedBundle": {
            "type": "object",
            "additionalProperties": false,
            "description": "A bundle selected for download in resolution",
            "required": [
                "bundleId",
                "bundleType",
                "downloadUrl",
                "expiresAt",
                "size",
                "assetsProvided"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier"
                },
                "bundleType": {
                    "$ref": "#/$defs/BundleType",
                    "description": "Whether source or metabundle"
                },
                "version": {
                    "type": "string",
                    "nullable": true,
                    "description": "Bundle version"
                },
                "downloadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed download URL"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the download URL expires"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Bundle file size in bytes"
                },
                "assetsProvided": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Which of the requested assets this bundle provides"
                }
            }
        },
        "BundleType": {
            "type": "string",
            "enum": [
                "source",
                "metabundle"
            ],
            "description": "Bundle category:\n- source: Original bundle (uploaded or server-created from assets)\n- metabundle: Composed from other bundles server-side\n"
        },
        "ResolvedAsset": {
            "type": "object",
            "additionalProperties": false,
            "description": "A standalone asset selected for download",
            "required": [
                "assetId",
                "downloadUrl",
                "expiresAt",
                "size"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Asset identifier"
                },
                "downloadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed download URL"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the download URL expires"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Asset file size in bytes"
                },
                "contentHash": {
                    "type": "string",
                    "nullable": true,
                    "description": "SHA256 hash of asset content"
                }
            }
        },
        "CoverageAnalysis": {
            "type": "object",
            "additionalProperties": false,
            "description": "Statistics about asset resolution coverage",
            "required": [
                "totalRequested",
                "resolvedViaBundles",
                "resolvedStandalone",
                "unresolvedCount"
            ],
            "properties": {
                "totalRequested": {
                    "type": "integer",
                    "description": "Total number of assets requested"
                },
                "resolvedViaBundles": {
                    "type": "integer",
                    "description": "Assets resolved through bundle downloads"
                },
                "resolvedStandalone": {
                    "type": "integer",
                    "description": "Assets resolved as standalone downloads"
                },
                "unresolvedCount": {
                    "type": "integer",
                    "description": "Assets that could not be found"
                },
                "bundleEfficiency": {
                    "type": "number",
                    "format": "float",
                    "nullable": true,
                    "description": "Ratio of assets provided to bundle downloads (higher is better)"
                }
            }
        }
    }
}
""";

    private static readonly string _ResolveBundles_Info = """
{
    "summary": "Compute optimal bundles for requested assets",
    "description": "Given a list of asset IDs, compute the optimal set of bundles to download\nto obtain all requested assets with minimal transfers.\n\nThe algorithm uses greedy set-cover optimization:\n1. Find all bundles containing requested assets\ n2. Select bundles that cover the most uncovered assets\n3. Prefer metabundles when coverage is equal (tie-breaker)\ n4. Include standalone assets for any remaining unresolved IDs\n\nReturns pre-signed download URLs for all selected bundles and assets.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "resolveBundles"
}
""";

    /// <summary>Returns endpoint information for ResolveBundles</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/resolve/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ResolveBundles_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/bundles/resolve",
            _ResolveBundles_Info));

    /// <summary>Returns request schema for ResolveBundles</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/resolve/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ResolveBundles_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/resolve",
            "request-schema",
            _ResolveBundles_RequestSchema));

    /// <summary>Returns response schema for ResolveBundles</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/resolve/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ResolveBundles_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/resolve",
            "response-schema",
            _ResolveBundles_ResponseSchema));

    /// <summary>Returns full schema for ResolveBundles</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/resolve/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ResolveBundles_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/bundles/resolve",
            _ResolveBundles_Info,
            _ResolveBundles_RequestSchema,
            _ResolveBundles_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryBundlesByAsset

    private static readonly string _QueryBundlesByAsset_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryBundlesByAssetRequest",
    "$defs": {
        "QueryBundlesByAssetRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to find bundles containing a specific asset",
            "required": [
                "assetId",
                "realm"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Platform asset ID to search for"
                },
                "realm": {
                    "$ref": "#/$defs/GameRealm",
                    "description": "Game realm to search within"
                },
                "bundleType": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/BundleType"
                        }
                    ],
                    "nullable": true,
                    "description": "Filter by bundle type (optional, null for all types)"
                },
                "limit": {
                    "type": "integer",
                    "default": 50,
                    "description": "Maximum results to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Pagination offset"
                }
            }
        },
        "GameRealm": {
            "type": "string",
            "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\nUse \"shared\" for assets that are available across all realms.\n"
        },
        "BundleType": {
            "type": "string",
            "enum": [
                "source",
                "metabundle"
            ],
            "description": "Bundle category:\ n- source: Original bundle (uploaded or server-created from assets)\n- metabundle: Composed from other bundles server-side\n"
        }
    }
}
""";

    private static readonly string _QueryBundlesByAsset_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryBundlesByAssetResponse",
    "$defs": {
        "QueryBundlesByAssetResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Bundles containing the requested asset",
            "required": [
                "assetId",
                "bundles",
                "total",
                "limit",
                "offset"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "The queried asset ID"
                },
                "bundles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/BundleSummary"
                    },
                    "description": "Bundles containing this asset"
                },
                "total": {
                    "type": "integer",
                    "description": "Total matching bundles"
                },
                "limit": {
                    "type": "integer",
                    "description": "Page size"
                },
                "offset": {
                    "type": "integer",
                    "description": "Page offset"
                }
            }
        },
        "BundleSummary": {
            "type": "object",
            "additionalProperties": false,
            "description": "Summary information about a bundle",
            "required": [
                "bundleId",
                "bundleType",
                "version",
                "assetCount",
                "realm"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier"
                },
                "bundleType": {
                    "$ref": "#/$defs/BundleType",
                    "description": "Source or metabundle"
                },
                "version": {
                    "type": "string",
                    "description": "Bundle version"
                },
                "assetCount": {
                    "type": "integer",
                    "description": "Number of assets in bundle"
                },
                "sizeBytes": {
                    "type": "integer",
                    "format": "int64",
                    "nullable": true,
                    "description": "Bundle file size"
                },
                "realm": {
                    "$ref": "#/$defs/GameRealm",
                    "description": "Game realm"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the bundle was created"
                }
            }
        },
        "BundleType": {
            "type": "string",
            "enum": [
                "source",
                "metabundle"
            ],
            "description": "Bundle category:\n- source: Original bundle (uploaded or server-created from assets)\n- metabundle: Composed from other bundles server-side\n"
        },
        "GameRealm": {
            "type": "string",
            "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\nUse \"shared\" for assets that are available across all realms.\n"
        }
    }
}
""";

    private static readonly string _QueryBundlesByAsset_Info = """
{
    "summary": "Find all bundles containing a specific asset",
    "description": "Query the reverse index to find all bundles (source and metabundle)\nthat contain a specific asset ID. Useful for understanding asset\ndistribution and debugging resolution issues.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "queryBundlesByAsset"
}
""";

    /// <summary>Returns endpoint information for QueryBundlesByAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/query/by-asset/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBundlesByAsset_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/bundles/query/by-asset",
            _QueryBundlesByAsset_Info));

    /// <summary>Returns request schema for QueryBundlesByAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/query/by-asset/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBundlesByAsset_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/query/by-asset",
            "request-schema",
            _QueryBundlesByAsset_RequestSchema));

    /// <summary>Returns response schema for QueryBundlesByAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/query/by-asset/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBundlesByAsset_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/query/by-asset",
            "response-schema",
            _QueryBundlesByAsset_ResponseSchema));

    /// <summary>Returns full schema for QueryBundlesByAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/query/by-asset/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBundlesByAsset_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/bundles/query/by-asset",
            _QueryBundlesByAsset_Info,
            _QueryBundlesByAsset_RequestSchema,
            _QueryBundlesByAsset_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateBundle

    private static readonly string _UpdateBundle_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateBundleRequest",
    "$defs": {
        "UpdateBundleRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to update bundle metadata",
            "required": [
                "bundleId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier to update"
                },
                "name": {
                    "type": "string",
                    "nullable": true,
                    "description": "New bundle name (null to leave unchanged)"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "New bundle description (null to leave unchanged)"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Replace all tags with these (null to leave unchanged)"
                },
                "addTags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Tags to add (merged with existing)"
                },
                "removeTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Tag keys to remove"
                },
                "reason": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional reason for the update (recorded in version history)"
                }
            }
        }
    }
}
""";

    private static readonly string _UpdateBundle_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateBundleResponse",
    "$defs": {
        "UpdateBundleResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Result of bundle update operation",
            "required": [
                "bundleId",
                "version",
                "previousVersion",
                "changes"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier that was updated"
                },
                "version": {
                    "type": "integer",
                    "description": "New version number after update"
                },
                "previousVersion": {
                    "type": "integer",
                    "description": "Version number before update"
                },
                "changes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of changes made (e.g., \"name changed\", \"tag 'env' added\")"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the update occurred"
                }
            }
        }
    }
}
""";

    private static readonly string _UpdateBundle_Info = """
{
    "summary": "Update bundle metadata",
    "description": "Update metadata for an existing bundle (name, description, tags).\nDoes not modify bundle contents - for that, create a new bundle.\n\ nIncrements the bundle version and records the change in version history.\nOnly the bundle owner or admin can update.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "updateBundle"
}
""";

    /// <summary>Returns endpoint information for UpdateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateBundle_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/bundles/update",
            _UpdateBundle_Info));

    /// <summary>Returns request schema for UpdateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateBundle_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/update",
            "request-schema",
            _UpdateBundle_RequestSchema));

    /// <summary>Returns response schema for UpdateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateBundle_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/update",
            "response-schema",
            _UpdateBundle_ResponseSchema));

    /// <summary>Returns full schema for UpdateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateBundle_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/bundles/update",
            _UpdateBundle_Info,
            _UpdateBundle_RequestSchema,
            _UpdateBundle_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeleteBundle

    private static readonly string _DeleteBundle_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteBundleRequest",
    "$defs": {
        "DeleteBundleRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to delete a bundle",
            "required": [
                "bundleId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier to delete"
                },
                "permanent": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, permanently delete (admin only). If false, soft-delete."
                },
                "reason": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional reason for deletion (recorded in version history)"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteBundle_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteBundleResponse",
    "$defs": {
        "DeleteBundleResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Result of bundle deletion",
            "required": [
                "bundleId",
                "status",
                "deletedAt"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier that was deleted"
                },
                "status": {
                    "type": "string",
                    "enum": [
                        "deleted",
                        "permanently_deleted"
                    ],
                    "description": "Deletion status"
                },
                "deletedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the bundle was deleted"
                },
                "retentionUntil": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When soft-deleted bundle will be permanently removed (null for permanent deletes)"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteBundle_Info = """
{
    "summary": "Soft-delete a bundle",
    "description": "Soft-delete a bundle, marking it as deleted but retaining data\nfor the configured retention period (default 30 days).\n\nDeleted bundles are excluded from resolution and queries by default.\nUse permanent=true for immediate, unrecoverable deletion (admin only).\n\nOnly the bundle owner or admin can delete.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "deleteBundle"
}
""";

    /// <summary>Returns endpoint information for DeleteBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteBundle_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/bundles/delete",
            _DeleteBundle_Info));

    /// <summary>Returns request schema for DeleteBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteBundle_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/delete",
            "request-schema",
            _DeleteBundle_RequestSchema));

    /// <summary>Returns response schema for DeleteBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteBundle_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/delete",
            "response-schema",
            _DeleteBundle_ResponseSchema));

    /// <summary>Returns full schema for DeleteBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteBundle_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/bundles/delete",
            _DeleteBundle_Info,
            _DeleteBundle_RequestSchema,
            _DeleteBundle_ResponseSchema));

    #endregion

    #region Meta Endpoints for RestoreBundle

    private static readonly string _RestoreBundle_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RestoreBundleRequest",
    "$defs": {
        "RestoreBundleRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to restore a soft-deleted bundle",
            "required": [
                "bundleId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier to restore"
                },
                "reason": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional reason for restoration (recorded in version history)"
                }
            }
        }
    }
}
""";

    private static readonly string _RestoreBundle_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RestoreBundleResponse",
    "$defs": {
        "RestoreBundleResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Result of bundle restoration",
            "required": [
                "bundleId",
                "status",
                "restoredAt",
                "restoredFromVersion"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier that was restored"
                },
                "status": {
                    "type": "string",
                    "description": "Current bundle status (should be \"active\")"
                },
                "restoredAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the bundle was restored"
                },
                "restoredFromVersion": {
                    "type": "integer",
                    "description": "Version number the bundle was restored from"
                }
            }
        }
    }
}
""";

    private static readonly string _RestoreBundle_Info = """
{
    "summary": "Restore a soft-deleted bundle",
    "description": "Restore a bundle that was soft-deleted, making it active again.\nCan only restore bundles within their retention period.\n\nOnly the bundle owner or admin can restore.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "restoreBundle"
}
""";

    /// <summary>Returns endpoint information for RestoreBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/restore/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestoreBundle_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/bundles/restore",
            _RestoreBundle_Info));

    /// <summary>Returns request schema for RestoreBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/restore/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestoreBundle_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/restore",
            "request-schema",
            _RestoreBundle_RequestSchema));

    /// <summary>Returns response schema for RestoreBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/restore/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestoreBundle_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/restore",
            "response-schema",
            _RestoreBundle_ResponseSchema));

    /// <summary>Returns full schema for RestoreBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/restore/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestoreBundle_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/bundles/restore",
            _RestoreBundle_Info,
            _RestoreBundle_RequestSchema,
            _RestoreBundle_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryBundles

    private static readonly string _QueryBundles_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryBundlesRequest",
    "$defs": {
        "QueryBundlesRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Advanced bundle query with filters",
            "properties": {
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Filter by exact tag key-value matches"
                },
                "tagExists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Filter bundles that have these tag keys (any value)"
                },
                "tagNotExists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Filter bundles that do NOT have these tag keys"
                },
                "status": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/BundleLifecycle"
                        }
                    ],
                    "nullable": true,
                    "description": "Filter by lifecycle status (null for active only by default)"
                },
                "createdAfter": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "Filter bundles created after this time"
                },
                "createdBefore": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "Filter bundles created before this time"
                },
                "nameContains": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter bundles with name containing this string (case-insensitive)"
                },
                "owner": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by bundle owner account ID"
                },
                "realm": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/GameRealm"
                        }
                    ],
                    "nullable": true,
                    "description": "Filter by realm"
                },
                "bundleType": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/BundleType"
                        }
                    ],
                    "nullable": true,
                    "description": "Filter by bundle type (source or metabundle)"
                },
                "sortField": {
                    "type": "string",
                    "enum": [
                        "created_at",
                        "updated_at",
                        "name",
                        "size"
                    ],
                    "nullable": true,
                    "description": "Field to sort by (default created_at)"
                },
                "sortOrder": {
                    "type": "string",
                    "enum": [
                        "asc",
                        "desc"
                    ],
                    "nullable": true,
                    "description": "Sort order (default desc)"
                },
                "limit": {
                    "type": "integer",
                    "default": 100,
                    "description": "Maximum results to return (max 1000)"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Pagination offset"
                },
                "includeDeleted": {
                    "type": "boolean",
                    "default": false,
                    "description": "Include soft-deleted bundles in results"
                }
            }
        },
        "BundleLifecycle": {
            "type": "string",
            "enum": [
                "active",
                "deleted",
                "processing"
            ],
            "description": "Bundle lifecycle status:\n- active: Bundle is available for use\n- deleted: Bundle has been soft-deleted (within retention period)\n- processing: Bundle is being processed (metabundle creation)\n"
        },
        "GameRealm": {
            "type": "string",
            "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\nUse \"shared\" for assets that are available across all realms.\n"
        },
        "BundleType": {
            "type": "string",
            "enum": [
                "source",
                "metabundle"
            ],
            "description": "Bundle category:\n- source: Original bundle (uploaded or server-created from assets)\ n- metabundle: Composed from other bundles server-side\n"
        }
    }
}
""";

    private static readonly string _QueryBundles_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryBundlesResponse",
    "$defs": {
        "QueryBundlesResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Bundle query results",
            "required": [
                "bundles",
                "totalCount",
                "limit",
                "offset"
            ],
            "properties": {
                "bundles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/BundleInfo"
                    },
                    "description": "Matching bundles"
                },
                "totalCount": {
                    "type": "integer",
                    "description": "Total number of matching bundles (for pagination)"
                },
                "limit": {
                    "type": "integer",
                    "description": "Page size used"
                },
                "offset": {
                    "type": "integer",
                    "description": "Page offset used"
                }
            }
        },
        "BundleInfo": {
            "type": "object",
            "additionalProperties": false,
            "description": "Complete metadata for an asset bundle (API response model)",
            "required": [
                "bundleId",
                "bundleType",
                "version",
                "metadataVersion",
                "realm",
                "status",
                "assetCount",
                "createdAt"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier (e.g., \"synty/polygon-adventure\", \"my-bundle-v1\")"
                },
                "bundleType": {
                    "$ref": "#/$defs/BundleType",
                    "description": "Whether source or metabundle"
                },
                "version": {
                    "type": "string",
                    "description": "Bundle content version string"
                },
                "metadataVersion": {
                    "type": "integer",
                    "description": "Metadata version number (increments on metadata changes)"
                },
                "name": {
                    "type": "string",
                    "nullable": true,
                    "description": "Human-readable bundle name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Bundle description"
                },
                "owner": {
                    "type": "string",
                    "nullable": true,
                    "description": "Owner account ID or service name (null for system-owned bundles)"
                },
                "realm": {
                    "$ref": "#/$defs/GameRealm",
                    "description": "Game realm this bundle belongs to"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Key-value tags for categorization and filtering"
                },
                "status": {
                    "$ref": "#/$defs/BundleLifecycle",
                    "description": "Bundle lifecycle status"
                },
                "assetCount": {
                    "type": "integer",
                    "description": "Number of assets in the bundle"
                },
                "sizeBytes": {
                    "type": "integer",
                    "format": "int64",
                    "nullable": true,
                    "description": "Bundle file size in bytes (null if not yet calculated)"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the bundle was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the bundle metadata was last updated"
                },
                "deletedAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the bundle was soft-deleted (null if active)"
                }
            }
        },
        "BundleType": {
            "type": "string",
            "enum": [
                "source",
                "metabundle"
            ],
            "description": "Bundle category:\ n- source: Original bundle (uploaded or server-created from assets)\n- metabundle: Composed from other bundles server-side\n"
        },
        "GameRealm": {
            "type": "string",
            "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\nUse \"shared\" for assets that are available across all realms.\n"
        },
        "BundleLifecycle": {
            "type": "string",
            "enum": [
                "active",
                "deleted",
                "processing"
            ],
            "description": "Bundle lifecycle status:\n- active: Bundle is available for use\n- deleted: Bundle has been soft-deleted (within retention period)\n- processing: Bundle is being processed (metabundle creation)\n"
        }
    }
}
""";

    private static readonly string _QueryBundles_Info = """
{
    "summary": "Query bundles with advanced filters",
    "description": "Query bundles with flexible filtering options including:\n- Tag matching (exact, exists, not exists)\n- Status filtering (active, deleted)\n- Date range filtering\n- Name search (contains)\n- Owner filtering\n- Realm and bundle type filtering\ n\nSupports pagination and sorting.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "queryBundles"
}
""";

    /// <summary>Returns endpoint information for QueryBundles</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/query/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBundles_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/bundles/query",
            _QueryBundles_Info));

    /// <summary>Returns request schema for QueryBundles</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/query/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBundles_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/query",
            "request-schema",
            _QueryBundles_RequestSchema));

    /// <summary>Returns response schema for QueryBundles</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/query/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBundles_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/query",
            "response-schema",
            _QueryBundles_ResponseSchema));

    /// <summary>Returns full schema for QueryBundles</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/query/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBundles_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/bundles/query",
            _QueryBundles_Info,
            _QueryBundles_RequestSchema,
            _QueryBundles_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListBundleVersions

    private static readonly string _ListBundleVersions_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListBundleVersionsRequest",
    "$defs": {
        "ListBundleVersionsRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to list bundle version history",
            "required": [
                "bundleId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier to get history for"
                },
                "limit": {
                    "type": "integer",
                    "default": 50,
                    "description": "Maximum versions to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Pagination offset"
                }
            }
        }
    }
}
""";

    private static readonly string _ListBundleVersions_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListBundleVersionsResponse",
    "$defs": {
        "ListBundleVersionsResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Bundle version history",
            "required": [
                "bundleId",
                "currentVersion",
                "versions",
                "totalCount"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier"
                },
                "currentVersion": {
                    "type": "integer",
                    "description": "Current version number"
                },
                "versions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/BundleVersionRecord"
                    },
                    "description": "Version history records (newest first)"
                },
                "totalCount": {
                    "type": "integer",
                    "description": "Total number of versions"
                }
            }
        },
        "BundleVersionRecord": {
            "type": "object",
            "additionalProperties": false,
            "description": "A single version record in bundle history",
            "required": [
                "version",
                "createdAt",
                "createdBy",
                "changes"
            ],
            "properties": {
                "version": {
                    "type": "integer",
                    "description": "Version number"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When this version was created"
                },
                "createdBy": {
                    "type": "string",
                    "description": "Account ID that made the change"
                },
                "changes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of changes in this version"
                },
                "reason": {
                    "type": "string",
                    "nullable": true,
                    "description": "Reason provided for the change"
                },
                "snapshot": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/BundleInfo"
                        }
                    ],
                    "nullable": true,
                    "description": "Full metadata snapshot at this version (only for current version)"
                }
            }
        },
        "BundleInfo": {
            "type": "object",
            "additionalProperties": false,
            "description": "Complete metadata for an asset bundle (API response model)",
            "required": [
                "bundleId",
                "bundleType",
                "version",
                "metadataVersion",
                "realm",
                "status",
                "assetCount",
                "createdAt"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Human-readable bundle identifier (e.g., \"synty/polygon-adventure\", \"my-bundle-v1\")"
                },
                "bundleType": {
                    "$ref": "#/$defs/BundleType",
                    "description": "Whether source or metabundle"
                },
                "version": {
                    "type": "string",
                    "description": "Bundle content version string"
                },
                "metadataVersion": {
                    "type": "integer",
                    "description": "Metadata version number (increments on metadata changes)"
                },
                "name": {
                    "type": "string",
                    "nullable": true,
                    "description": "Human-readable bundle name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Bundle description"
                },
                "owner": {
                    "type": "string",
                    "nullable": true,
                    "description": "Owner account ID or service name (null for system-owned bundles)"
                },
                "realm": {
                    "$ref": "#/$defs/GameRealm",
                    "description": "Game realm this bundle belongs to"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Key-value tags for categorization and filtering"
                },
                "status": {
                    "$ref": "#/$defs/BundleLifecycle",
                    "description": "Bundle lifecycle status"
                },
                "assetCount": {
                    "type": "integer",
                    "description": "Number of assets in the bundle"
                },
                "sizeBytes": {
                    "type": "integer",
                    "format": "int64",
                    "nullable": true,
                    "description": "Bundle file size in bytes (null if not yet calculated)"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the bundle was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the bundle metadata was last updated"
                },
                "deletedAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the bundle was soft-deleted (null if active)"
                }
            }
        },
        "BundleType": {
            "type": "string",
            "enum": [
                "source",
                "metabundle"
            ],
            "description": "Bundle category:\n- source: Original bundle (uploaded or server-created from assets)\n- metabundle: Composed from other bundles server-side\n"
        },
        "GameRealm": {
            "type": "string",
            "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\nUse \"shared\" for assets that are available across all realms.\n"
        },
        "BundleLifecycle": {
            "type": "string",
            "enum": [
                "active",
                "deleted",
                "processing"
            ],
            "description": "Bundle lifecycle status:\n- active: Bundle is available for use\ n- deleted: Bundle has been soft-deleted (within retention period)\n- processing: Bundle is being processed (metabundle creation)\n"
        }
    }
}
""";

    private static readonly string _ListBundleVersions_Info = """
{
    "summary": "List version history for a bundle",
    "description": "Get the version history for a bundle, showing all metadata changes\nover time. Each version record includes:\n- Version number\ n- When the change was made\n- Who made the change\n- What changed\n- Optional reason for the change\n\nThe current version's full metadata snapshot is always included.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "listBundleVersions"
}
""";

    /// <summary>Returns endpoint information for ListBundleVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/list-versions/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListBundleVersions_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/bundles/list-versions",
            _ListBundleVersions_Info));

    /// <summary>Returns request schema for ListBundleVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/list-versions/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListBundleVersions_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/list-versions",
            "request-schema",
            _ListBundleVersions_RequestSchema));

    /// <summary>Returns response schema for ListBundleVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/list-versions/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListBundleVersions_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/bundles/list-versions",
            "response-schema",
            _ListBundleVersions_ResponseSchema));

    /// <summary>Returns full schema for ListBundleVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/bundles/list-versions/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListBundleVersions_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/bundles/list-versions",
            _ListBundleVersions_Info,
            _ListBundleVersions_RequestSchema,
            _ListBundleVersions_ResponseSchema));

    #endregion

    #region Meta Endpoints for BulkGetAssets

    private static readonly string _BulkGetAssets_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BulkGetAssetsRequest",
    "$defs": {
        "BulkGetAssetsRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to retrieve metadata for multiple assets",
            "required": [
                "assetIds"
            ],
            "properties": {
                "assetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Asset IDs to retrieve (max 100)"
                },
                "includeDownloadUrls": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether to generate pre-signed download URLs"
                }
            }
        }
    }
}
""";

    private static readonly string _BulkGetAssets_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BulkGetAssetsResponse",
    "$defs": {
        "BulkGetAssetsResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Batch asset metadata response",
            "required": [
                "assets",
                "notFound"
            ],
            "properties": {
                "assets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetWithDownloadUrl"
                    },
                    "description": "Found assets with metadata"
                },
                "notFound": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Asset IDs that weren't found"
                }
            }
        },
        "AssetWithDownloadUrl": {
            "description": "Asset metadata with optional pre-signed download URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId",
                "versionId",
                "size",
                "contentHash",
                "contentType",
                "metadata"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "versionId": {
                    "type": "string",
                    "description": "Version identifier for this specific asset version"
                },
                "downloadUrl": {
                    "type": "string",
                    "format": "uri",
                    "nullable": true,
                    "description": "Pre-signed download URL (only populated when requested)"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the download URL expires (only populated when requested)"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "metadata": {
                    "$ref": "#/$defs/AssetMetadata",
                    "description": "Complete asset metadata"
                }
            }
        },
        "AssetMetadata": {
            "type": "object",
            "additionalProperties": false,
            "description": "Complete asset metadata including system-generated fields",
            "required": [
                "assetId",
                "contentHash",
                "filename",
                "contentType",
                "size",
                "assetType",
                "realm",
                "tags",
                "processingStatus",
                "isArchived",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "filename": {
                    "type": "string",
                    "description": "Original filename"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Type classification for the asset"
                },
                "realm": {
                    "$ref": "#/$defs/GameRealm",
                    "description": "Game realm the asset belongs to"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for the asset"
                },
                "processingStatus": {
                    "$ref": "#/$defs/ProcessingStatus",
                    "description": "Current status of asset processing pipeline"
                },
                "isArchived": {
                    "type": "boolean",
                    "description": "Whether the asset is in cold/archival storage",
                    "default": false
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was last updated"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "GameRealm": {
            "type": "string",
            "description": "Realm stub name (lowercase string identifier) that this asset belongs to.\nUse the realm's stub_name property (e.g., \"realm-1\", \"realm-2\") from the Realm service.\nUse \"shared\" for assets that are available across all realms.\n"
        },
        "ProcessingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "processing",
                "complete",
                "failed"
            ],
            "description": "Asset processing pipeline status"
        }
    }
}
""";

    private static readonly string _BulkGetAssets_Info = """
{
    "summary": "Batch asset metadata lookup",
    "description": "Retrieve metadata for multiple assets in a single request.\nOptionally includes pre-signed download URLs.\nMaximum 100 asset IDs per request.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "bulkGetAssets"
}
""";

    /// <summary>Returns endpoint information for BulkGetAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/bulk-get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkGetAssets_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "POST",
            "/assets/bulk-get",
            _BulkGetAssets_Info));

    /// <summary>Returns request schema for BulkGetAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/bulk-get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkGetAssets_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/assets/bulk-get",
            "request-schema",
            _BulkGetAssets_RequestSchema));

    /// <summary>Returns response schema for BulkGetAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/bulk-get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkGetAssets_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "POST",
            "/assets/bulk-get",
            "response-schema",
            _BulkGetAssets_ResponseSchema));

    /// <summary>Returns full schema for BulkGetAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/assets/bulk-get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkGetAssets_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "POST",
            "/assets/bulk-get",
            _BulkGetAssets_Info,
            _BulkGetAssets_RequestSchema,
            _BulkGetAssets_ResponseSchema));

    #endregion
}
