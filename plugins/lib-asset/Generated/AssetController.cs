//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Asset;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IAssetController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Request upload URL for a new asset
    /// </summary>

    /// <remarks>
    /// Generate a pre-signed URL for uploading a new asset directly to storage.
    /// <br/>For large files (&gt;50MB), returns multipart upload configuration.
    /// </remarks>

    /// <returns>Upload URL generated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestUploadAsync(UploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Mark upload as complete, trigger processing
    /// </summary>

    /// <remarks>
    /// Called after the client has uploaded the file to the pre-signed URL.
    /// <br/>Triggers the asset processing pipeline (texture conversion, model validation, etc.)
    /// <br/>and emits completion events via WebSocket.
    /// </remarks>

    /// <returns>Asset created, processing started</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetMetadata>> CompleteUploadAsync(CompleteUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get asset metadata and download URL
    /// </summary>

    /// <remarks>
    /// Retrieve asset metadata and generate a pre-signed download URL.
    /// <br/>Specify version to download a specific version, or omit for latest.
    /// </remarks>

    /// <returns>Asset metadata with download URL</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetWithDownloadUrl>> GetAssetAsync(GetAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete an asset
    /// </summary>

    /// <remarks>
    /// Delete an asset from storage. If versionId is specified, only that version is deleted.
    /// <br/>If versionId is omitted, all versions are deleted.
    /// </remarks>

    /// <returns>Asset deleted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteAssetResponse>> DeleteAssetAsync(DeleteAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all versions of an asset
    /// </summary>

    /// <remarks>
    /// Retrieve version history for an asset with pagination.
    /// <br/>Includes version IDs, creation timestamps, and archive status.
    /// </remarks>

    /// <returns>List of asset versions</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetVersionList>> ListAssetVersionsAsync(ListVersionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Search assets by tags, type, or realm
    /// </summary>

    /// <remarks>
    /// Search assets using various filters with pagination.
    /// <br/>All filters are optional and combine with AND logic.
    /// </remarks>

    /// <returns>Matching assets</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetSearchResult>> SearchAssetsAsync(AssetSearchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create asset bundle from multiple assets
    /// </summary>

    /// <remarks>
    /// Create a .bannou bundle containing multiple assets.
    /// <br/>For large bundles, processing is delegated to the processing pool.
    /// <br/>Completion notification sent via WebSocket event.
    /// </remarks>

    /// <returns>Bundle created immediately (small bundles)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateBundleResponse>> CreateBundleAsync(CreateBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get bundle manifest and download URL
    /// </summary>

    /// <remarks>
    /// Retrieve bundle metadata and generate a pre-signed download URL.
    /// <br/>Supports both native .bannou format and ZIP conversion (cached).
    /// </remarks>

    /// <returns>Bundle manifest with download URL</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BundleWithDownloadUrl>> GetBundleAsync(GetBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Request upload URL for a pre-made bundle
    /// </summary>

    /// <remarks>
    /// Upload a pre-built bundle (.bannou or .zip format).
    /// <br/>After upload, the bundle undergoes validation before registration.
    /// </remarks>

    /// <returns>Upload URL generated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestBundleUploadAsync(BundleUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create metabundle from source bundles
    /// </summary>

    /// <remarks>
    /// Compose a metabundle by extracting and repackaging assets from multiple
    /// <br/>source bundles. The resulting metabundle is a complete physical copy with
    /// <br/>provenance metadata tracking the source bundles.
    /// <br/>
    /// <br/>Assets are deduplicated by content hash. If the same asset ID exists in
    /// <br/>multiple source bundles with different content hashes, the request fails
    /// <br/>with conflict details.
    /// </remarks>

    /// <returns>Metabundle created or queued for creation</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateMetabundleResponse>> CreateMetabundleAsync(CreateMetabundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get async metabundle job status
    /// </summary>

    /// <remarks>
    /// Poll the status of an async metabundle creation job.
    /// <br/>Use the jobId returned from createMetabundle when status was 'queued'.
    /// <br/>
    /// <br/>Clients can either poll this endpoint or wait for the
    /// <br/>MetabundleCreationCompleteEvent via WebSocket for completion notification.
    /// </remarks>

    /// <returns>Job status retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetJobStatusResponse>> GetJobStatusAsync(GetJobStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Cancel an async metabundle job
    /// </summary>

    /// <remarks>
    /// Cancel a pending or processing metabundle creation job.
    /// <br/>Jobs that are already completed (ready or failed) cannot be cancelled.
    /// <br/>
    /// <br/>Successfully cancelled jobs will emit a MetabundleCreationCompleteEvent
    /// <br/>with status 'cancelled' via WebSocket.
    /// </remarks>

    /// <returns>Job cancellation result</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CancelJobResponse>> CancelJobAsync(CancelJobRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Compute optimal bundles for requested assets
    /// </summary>

    /// <remarks>
    /// Given a list of asset IDs, compute the optimal set of bundles to download
    /// <br/>to obtain all requested assets with minimal transfers.
    /// <br/>
    /// <br/>The algorithm uses greedy set-cover optimization:
    /// <br/>1. Find all bundles containing requested assets
    /// <br/>2. Select bundles that cover the most uncovered assets
    /// <br/>3. Prefer metabundles when coverage is equal (tie-breaker)
    /// <br/>4. Include standalone assets for any remaining unresolved IDs
    /// <br/>
    /// <br/>Returns pre-signed download URLs for all selected bundles and assets.
    /// </remarks>

    /// <returns>Resolution complete with download URLs</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ResolveBundlesResponse>> ResolveBundlesAsync(ResolveBundlesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Find all bundles containing a specific asset
    /// </summary>

    /// <remarks>
    /// Query the reverse index to find all bundles (source and metabundle)
    /// <br/>that contain a specific asset ID. Useful for understanding asset
    /// <br/>distribution and debugging resolution issues.
    /// </remarks>

    /// <returns>Bundles containing the asset</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryBundlesByAssetResponse>> QueryBundlesByAssetAsync(QueryBundlesByAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update bundle metadata
    /// </summary>

    /// <remarks>
    /// Update metadata for an existing bundle (name, description, tags).
    /// <br/>Does not modify bundle contents - for that, create a new bundle.
    /// <br/>
    /// <br/>Increments the bundle version and records the change in version history.
    /// <br/>Only the bundle owner or admin can update.
    /// </remarks>

    /// <returns>Bundle updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateBundleResponse>> UpdateBundleAsync(UpdateBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Soft-delete a bundle
    /// </summary>

    /// <remarks>
    /// Soft-delete a bundle, marking it as deleted but retaining data
    /// <br/>for the configured retention period (default 30 days).
    /// <br/>
    /// <br/>Deleted bundles are excluded from resolution and queries by default.
    /// <br/>Use permanent=true for immediate, unrecoverable deletion (admin only).
    /// <br/>
    /// <br/>Only the bundle owner or admin can delete.
    /// </remarks>

    /// <returns>Bundle deleted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteBundleResponse>> DeleteBundleAsync(DeleteBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Restore a soft-deleted bundle
    /// </summary>

    /// <remarks>
    /// Restore a bundle that was soft-deleted, making it active again.
    /// <br/>Can only restore bundles within their retention period.
    /// <br/>
    /// <br/>Only the bundle owner or admin can restore.
    /// </remarks>

    /// <returns>Bundle restored successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RestoreBundleResponse>> RestoreBundleAsync(RestoreBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Query bundles with advanced filters
    /// </summary>

    /// <remarks>
    /// Query bundles with flexible filtering options including:
    /// <br/>- Tag matching (exact, exists, not exists)
    /// <br/>- Status filtering (active, deleted)
    /// <br/>- Date range filtering
    /// <br/>- Name search (contains)
    /// <br/>- Owner filtering
    /// <br/>- Realm and bundle type filtering
    /// <br/>
    /// <br/>Supports pagination and sorting.
    /// </remarks>

    /// <returns>Query results</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryBundlesResponse>> QueryBundlesAsync(QueryBundlesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List version history for a bundle
    /// </summary>

    /// <remarks>
    /// Get the version history for a bundle, showing all metadata changes
    /// <br/>over time. Each version record includes:
    /// <br/>- Version number
    /// <br/>- When the change was made
    /// <br/>- Who made the change
    /// <br/>- What changed
    /// <br/>- Optional reason for the change
    /// <br/>
    /// <br/>The current version's full metadata snapshot is always included.
    /// </remarks>

    /// <returns>Version history</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListBundleVersionsResponse>> ListBundleVersionsAsync(ListBundleVersionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Batch asset metadata lookup
    /// </summary>

    /// <remarks>
    /// Retrieve metadata for multiple assets in a single request.
    /// <br/>Optionally includes pre-signed download URLs.
    /// <br/>Maximum 100 asset IDs per request.
    /// </remarks>

    /// <returns>Asset metadata retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BulkGetAssetsResponse>> BulkGetAssetsAsync(BulkGetAssetsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class AssetController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IAssetService _implementation;

    public AssetController(IAssetService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Request upload URL for a new asset
    /// </summary>
    /// <remarks>
    /// Generate a pre-signed URL for uploading a new asset directly to storage.
    /// <br/>For large files (&gt;50MB), returns multipart upload configuration.
    /// </remarks>
    /// <returns>Upload URL generated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/upload/request")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestUpload([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RequestUploadAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Mark upload as complete, trigger processing
    /// </summary>
    /// <remarks>
    /// Called after the client has uploaded the file to the pre-signed URL.
    /// <br/>Triggers the asset processing pipeline (texture conversion, model validation, etc.)
    /// <br/>and emits completion events via WebSocket.
    /// </remarks>
    /// <returns>Asset created, processing started</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetMetadata>> CompleteUpload([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CompleteUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CompleteUploadAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get asset metadata and download URL
    /// </summary>
    /// <remarks>
    /// Retrieve asset metadata and generate a pre-signed download URL.
    /// <br/>Specify version to download a specific version, or omit for latest.
    /// </remarks>
    /// <returns>Asset metadata with download URL</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetWithDownloadUrl>> GetAsset([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetAssetAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Delete an asset
    /// </summary>
    /// <remarks>
    /// Delete an asset from storage. If versionId is specified, only that version is deleted.
    /// <br/>If versionId is omitted, all versions are deleted.
    /// </remarks>
    /// <returns>Asset deleted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteAssetResponse>> DeleteAsset([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DeleteAssetAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List all versions of an asset
    /// </summary>
    /// <remarks>
    /// Retrieve version history for an asset with pagination.
    /// <br/>Includes version IDs, creation timestamps, and archive status.
    /// </remarks>
    /// <returns>List of asset versions</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/list-versions")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetVersionList>> ListAssetVersions([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListVersionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListAssetVersionsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Search assets by tags, type, or realm
    /// </summary>
    /// <remarks>
    /// Search assets using various filters with pagination.
    /// <br/>All filters are optional and combine with AND logic.
    /// </remarks>
    /// <returns>Matching assets</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/search")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetSearchResult>> SearchAssets([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AssetSearchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.SearchAssetsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Create asset bundle from multiple assets
    /// </summary>
    /// <remarks>
    /// Create a .bannou bundle containing multiple assets.
    /// <br/>For large bundles, processing is delegated to the processing pool.
    /// <br/>Completion notification sent via WebSocket event.
    /// </remarks>
    /// <returns>Bundle created immediately (small bundles)</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateBundleResponse>> CreateBundle([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateBundleAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get bundle manifest and download URL
    /// </summary>
    /// <remarks>
    /// Retrieve bundle metadata and generate a pre-signed download URL.
    /// <br/>Supports both native .bannou format and ZIP conversion (cached).
    /// </remarks>
    /// <returns>Bundle manifest with download URL</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BundleWithDownloadUrl>> GetBundle([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetBundleAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Request upload URL for a pre-made bundle
    /// </summary>
    /// <remarks>
    /// Upload a pre-built bundle (.bannou or .zip format).
    /// <br/>After upload, the bundle undergoes validation before registration.
    /// </remarks>
    /// <returns>Upload URL generated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestBundleUpload([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BundleUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RequestBundleUploadAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Create metabundle from source bundles
    /// </summary>
    /// <remarks>
    /// Compose a metabundle by extracting and repackaging assets from multiple
    /// <br/>source bundles. The resulting metabundle is a complete physical copy with
    /// <br/>provenance metadata tracking the source bundles.
    /// <br/>
    /// <br/>Assets are deduplicated by content hash. If the same asset ID exists in
    /// <br/>multiple source bundles with different content hashes, the request fails
    /// <br/>with conflict details.
    /// </remarks>
    /// <returns>Metabundle created or queued for creation</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/metabundle/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateMetabundleResponse>> CreateMetabundle([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateMetabundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateMetabundleAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get async metabundle job status
    /// </summary>
    /// <remarks>
    /// Poll the status of an async metabundle creation job.
    /// <br/>Use the jobId returned from createMetabundle when status was 'queued'.
    /// <br/>
    /// <br/>Clients can either poll this endpoint or wait for the
    /// <br/>MetabundleCreationCompleteEvent via WebSocket for completion notification.
    /// </remarks>
    /// <returns>Job status retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/job/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetJobStatusResponse>> GetJobStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetJobStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetJobStatusAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Cancel an async metabundle job
    /// </summary>
    /// <remarks>
    /// Cancel a pending or processing metabundle creation job.
    /// <br/>Jobs that are already completed (ready or failed) cannot be cancelled.
    /// <br/>
    /// <br/>Successfully cancelled jobs will emit a MetabundleCreationCompleteEvent
    /// <br/>with status 'cancelled' via WebSocket.
    /// </remarks>
    /// <returns>Job cancellation result</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/job/cancel")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CancelJobResponse>> CancelJob([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CancelJobRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CancelJobAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Compute optimal bundles for requested assets
    /// </summary>
    /// <remarks>
    /// Given a list of asset IDs, compute the optimal set of bundles to download
    /// <br/>to obtain all requested assets with minimal transfers.
    /// <br/>
    /// <br/>The algorithm uses greedy set-cover optimization:
    /// <br/>1. Find all bundles containing requested assets
    /// <br/>2. Select bundles that cover the most uncovered assets
    /// <br/>3. Prefer metabundles when coverage is equal (tie-breaker)
    /// <br/>4. Include standalone assets for any remaining unresolved IDs
    /// <br/>
    /// <br/>Returns pre-signed download URLs for all selected bundles and assets.
    /// </remarks>
    /// <returns>Resolution complete with download URLs</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/resolve")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ResolveBundlesResponse>> ResolveBundles([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ResolveBundlesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ResolveBundlesAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Find all bundles containing a specific asset
    /// </summary>
    /// <remarks>
    /// Query the reverse index to find all bundles (source and metabundle)
    /// <br/>that contain a specific asset ID. Useful for understanding asset
    /// <br/>distribution and debugging resolution issues.
    /// </remarks>
    /// <returns>Bundles containing the asset</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/query/by-asset")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryBundlesByAssetResponse>> QueryBundlesByAsset([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryBundlesByAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.QueryBundlesByAssetAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Update bundle metadata
    /// </summary>
    /// <remarks>
    /// Update metadata for an existing bundle (name, description, tags).
    /// <br/>Does not modify bundle contents - for that, create a new bundle.
    /// <br/>
    /// <br/>Increments the bundle version and records the change in version history.
    /// <br/>Only the bundle owner or admin can update.
    /// </remarks>
    /// <returns>Bundle updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateBundleResponse>> UpdateBundle([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateBundleAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Soft-delete a bundle
    /// </summary>
    /// <remarks>
    /// Soft-delete a bundle, marking it as deleted but retaining data
    /// <br/>for the configured retention period (default 30 days).
    /// <br/>
    /// <br/>Deleted bundles are excluded from resolution and queries by default.
    /// <br/>Use permanent=true for immediate, unrecoverable deletion (admin only).
    /// <br/>
    /// <br/>Only the bundle owner or admin can delete.
    /// </remarks>
    /// <returns>Bundle deleted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteBundleResponse>> DeleteBundle([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DeleteBundleAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Restore a soft-deleted bundle
    /// </summary>
    /// <remarks>
    /// Restore a bundle that was soft-deleted, making it active again.
    /// <br/>Can only restore bundles within their retention period.
    /// <br/>
    /// <br/>Only the bundle owner or admin can restore.
    /// </remarks>
    /// <returns>Bundle restored successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/restore")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RestoreBundleResponse>> RestoreBundle([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RestoreBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RestoreBundleAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Query bundles with advanced filters
    /// </summary>
    /// <remarks>
    /// Query bundles with flexible filtering options including:
    /// <br/>- Tag matching (exact, exists, not exists)
    /// <br/>- Status filtering (active, deleted)
    /// <br/>- Date range filtering
    /// <br/>- Name search (contains)
    /// <br/>- Owner filtering
    /// <br/>- Realm and bundle type filtering
    /// <br/>
    /// <br/>Supports pagination and sorting.
    /// </remarks>
    /// <returns>Query results</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/query")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryBundlesResponse>> QueryBundles([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryBundlesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.QueryBundlesAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List version history for a bundle
    /// </summary>
    /// <remarks>
    /// Get the version history for a bundle, showing all metadata changes
    /// <br/>over time. Each version record includes:
    /// <br/>- Version number
    /// <br/>- When the change was made
    /// <br/>- Who made the change
    /// <br/>- What changed
    /// <br/>- Optional reason for the change
    /// <br/>
    /// <br/>The current version's full metadata snapshot is always included.
    /// </remarks>
    /// <returns>Version history</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/list-versions")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListBundleVersionsResponse>> ListBundleVersions([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListBundleVersionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListBundleVersionsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Batch asset metadata lookup
    /// </summary>
    /// <remarks>
    /// Retrieve metadata for multiple assets in a single request.
    /// <br/>Optionally includes pre-signed download URLs.
    /// <br/>Maximum 100 asset IDs per request.
    /// </remarks>
    /// <returns>Asset metadata retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/bulk-get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BulkGetAssetsResponse>> BulkGetAssets([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BulkGetAssetsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.BulkGetAssetsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
