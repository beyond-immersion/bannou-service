//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Asset;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IAssetController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Request upload URL for a new asset
    /// </summary>

    /// <remarks>
    /// Generate a pre-signed URL for uploading a new asset directly to storage.
    /// <br/>For large files (&gt;50MB), returns multipart upload configuration.
    /// </remarks>

    /// <returns>Upload URL generated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestUploadAsync(UploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Mark upload as complete, trigger processing
    /// </summary>

    /// <remarks>
    /// Called after the client has uploaded the file to the pre-signed URL.
    /// <br/>Triggers the asset processing pipeline (texture conversion, model validation, etc.)
    /// <br/>and emits completion events via WebSocket.
    /// </remarks>

    /// <returns>Asset created, processing started</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetMetadata>> CompleteUploadAsync(CompleteUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get asset metadata and download URL
    /// </summary>

    /// <remarks>
    /// Retrieve asset metadata and generate a pre-signed download URL.
    /// <br/>Specify version to download a specific version, or omit for latest.
    /// </remarks>

    /// <returns>Asset metadata with download URL</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetWithDownloadUrl>> GetAssetAsync(GetAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete an asset
    /// </summary>

    /// <remarks>
    /// Delete an asset from storage. If versionId is specified, only that version is deleted.
    /// <br/>If versionId is omitted, all versions are deleted.
    /// </remarks>

    /// <returns>Asset deleted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteAssetResponse>> DeleteAssetAsync(DeleteAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all versions of an asset
    /// </summary>

    /// <remarks>
    /// Retrieve version history for an asset with pagination.
    /// <br/>Includes version IDs, creation timestamps, and archive status.
    /// </remarks>

    /// <returns>List of asset versions</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetVersionList>> ListAssetVersionsAsync(ListVersionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Search assets by tags, type, or realm
    /// </summary>

    /// <remarks>
    /// Search assets using various filters with pagination.
    /// <br/>All filters are optional and combine with AND logic.
    /// </remarks>

    /// <returns>Matching assets</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetSearchResult>> SearchAssetsAsync(AssetSearchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create asset bundle from multiple assets
    /// </summary>

    /// <remarks>
    /// Create a .bannou bundle containing multiple assets.
    /// <br/>For large bundles, processing is delegated to the processing pool.
    /// <br/>Completion notification sent via WebSocket event.
    /// </remarks>

    /// <returns>Bundle created immediately (small bundles)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateBundleResponse>> CreateBundleAsync(CreateBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get bundle manifest and download URL
    /// </summary>

    /// <remarks>
    /// Retrieve bundle metadata and generate a pre-signed download URL.
    /// <br/>Supports both native .bannou format and ZIP conversion (cached).
    /// </remarks>

    /// <returns>Bundle manifest with download URL</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BundleWithDownloadUrl>> GetBundleAsync(GetBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Request upload URL for a pre-made bundle
    /// </summary>

    /// <remarks>
    /// Upload a pre-built bundle (.bannou or .zip format).
    /// <br/>After upload, the bundle undergoes validation before registration.
    /// </remarks>

    /// <returns>Upload URL generated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestBundleUploadAsync(BundleUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create metabundle from source bundles
    /// </summary>

    /// <remarks>
    /// Compose a metabundle by extracting and repackaging assets from multiple
    /// <br/>source bundles. The resulting metabundle is a complete physical copy with
    /// <br/>provenance metadata tracking the source bundles.
    /// <br/>
    /// <br/>Assets are deduplicated by content hash. If the same asset ID exists in
    /// <br/>multiple source bundles with different content hashes, the request fails
    /// <br/>with conflict details.
    /// </remarks>

    /// <returns>Metabundle created or queued for creation</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateMetabundleResponse>> CreateMetabundleAsync(CreateMetabundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Compute optimal bundles for requested assets
    /// </summary>

    /// <remarks>
    /// Given a list of asset IDs, compute the optimal set of bundles to download
    /// <br/>to obtain all requested assets with minimal transfers.
    /// <br/>
    /// <br/>The algorithm uses greedy set-cover optimization:
    /// <br/>1. Find all bundles containing requested assets
    /// <br/>2. Select bundles that cover the most uncovered assets
    /// <br/>3. Prefer metabundles when coverage is equal (tie-breaker)
    /// <br/>4. Include standalone assets for any remaining unresolved IDs
    /// <br/>
    /// <br/>Returns pre-signed download URLs for all selected bundles and assets.
    /// </remarks>

    /// <returns>Resolution complete with download URLs</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ResolveBundlesResponse>> ResolveBundlesAsync(ResolveBundlesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Find all bundles containing a specific asset
    /// </summary>

    /// <remarks>
    /// Query the reverse index to find all bundles (source and metabundle)
    /// <br/>that contain a specific asset ID. Useful for understanding asset
    /// <br/>distribution and debugging resolution issues.
    /// </remarks>

    /// <returns>Bundles containing the asset</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryBundlesByAssetResponse>> QueryBundlesByAssetAsync(QueryBundlesByAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Batch asset metadata lookup
    /// </summary>

    /// <remarks>
    /// Retrieve metadata for multiple assets in a single request.
    /// <br/>Optionally includes pre-signed download URLs.
    /// <br/>Maximum 100 asset IDs per request.
    /// </remarks>

    /// <returns>Asset metadata retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BulkGetAssetsResponse>> BulkGetAssetsAsync(BulkGetAssetsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class AssetController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IAssetService _implementation;

    public AssetController(IAssetService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Request upload URL for a new asset
    /// </summary>
    /// <remarks>
    /// Generate a pre-signed URL for uploading a new asset directly to storage.
    /// <br/>For large files (&gt;50MB), returns multipart upload configuration.
    /// </remarks>
    /// <returns>Upload URL generated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/upload/request")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestUpload([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RequestUploadAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Mark upload as complete, trigger processing
    /// </summary>
    /// <remarks>
    /// Called after the client has uploaded the file to the pre-signed URL.
    /// <br/>Triggers the asset processing pipeline (texture conversion, model validation, etc.)
    /// <br/>and emits completion events via WebSocket.
    /// </remarks>
    /// <returns>Asset created, processing started</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetMetadata>> CompleteUpload([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CompleteUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CompleteUploadAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get asset metadata and download URL
    /// </summary>
    /// <remarks>
    /// Retrieve asset metadata and generate a pre-signed download URL.
    /// <br/>Specify version to download a specific version, or omit for latest.
    /// </remarks>
    /// <returns>Asset metadata with download URL</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetWithDownloadUrl>> GetAsset([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetAssetAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Delete an asset
    /// </summary>
    /// <remarks>
    /// Delete an asset from storage. If versionId is specified, only that version is deleted.
    /// <br/>If versionId is omitted, all versions are deleted.
    /// </remarks>
    /// <returns>Asset deleted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteAssetResponse>> DeleteAsset([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DeleteAssetAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List all versions of an asset
    /// </summary>
    /// <remarks>
    /// Retrieve version history for an asset with pagination.
    /// <br/>Includes version IDs, creation timestamps, and archive status.
    /// </remarks>
    /// <returns>List of asset versions</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/list-versions")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetVersionList>> ListAssetVersions([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListVersionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListAssetVersionsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Search assets by tags, type, or realm
    /// </summary>
    /// <remarks>
    /// Search assets using various filters with pagination.
    /// <br/>All filters are optional and combine with AND logic.
    /// </remarks>
    /// <returns>Matching assets</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/search")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AssetSearchResult>> SearchAssets([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AssetSearchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.SearchAssetsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Create asset bundle from multiple assets
    /// </summary>
    /// <remarks>
    /// Create a .bannou bundle containing multiple assets.
    /// <br/>For large bundles, processing is delegated to the processing pool.
    /// <br/>Completion notification sent via WebSocket event.
    /// </remarks>
    /// <returns>Bundle created immediately (small bundles)</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateBundleResponse>> CreateBundle([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateBundleAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get bundle manifest and download URL
    /// </summary>
    /// <remarks>
    /// Retrieve bundle metadata and generate a pre-signed download URL.
    /// <br/>Supports both native .bannou format and ZIP conversion (cached).
    /// </remarks>
    /// <returns>Bundle manifest with download URL</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BundleWithDownloadUrl>> GetBundle([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetBundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetBundleAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Request upload URL for a pre-made bundle
    /// </summary>
    /// <remarks>
    /// Upload a pre-built bundle (.bannou or .zip format).
    /// <br/>After upload, the bundle undergoes validation before registration.
    /// </remarks>
    /// <returns>Upload URL generated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UploadResponse>> RequestBundleUpload([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BundleUploadRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RequestBundleUploadAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Create metabundle from source bundles
    /// </summary>
    /// <remarks>
    /// Compose a metabundle by extracting and repackaging assets from multiple
    /// <br/>source bundles. The resulting metabundle is a complete physical copy with
    /// <br/>provenance metadata tracking the source bundles.
    /// <br/>
    /// <br/>Assets are deduplicated by content hash. If the same asset ID exists in
    /// <br/>multiple source bundles with different content hashes, the request fails
    /// <br/>with conflict details.
    /// </remarks>
    /// <returns>Metabundle created or queued for creation</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/metabundle/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateMetabundleResponse>> CreateMetabundle([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateMetabundleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateMetabundleAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Compute optimal bundles for requested assets
    /// </summary>
    /// <remarks>
    /// Given a list of asset IDs, compute the optimal set of bundles to download
    /// <br/>to obtain all requested assets with minimal transfers.
    /// <br/>
    /// <br/>The algorithm uses greedy set-cover optimization:
    /// <br/>1. Find all bundles containing requested assets
    /// <br/>2. Select bundles that cover the most uncovered assets
    /// <br/>3. Prefer metabundles when coverage is equal (tie-breaker)
    /// <br/>4. Include standalone assets for any remaining unresolved IDs
    /// <br/>
    /// <br/>Returns pre-signed download URLs for all selected bundles and assets.
    /// </remarks>
    /// <returns>Resolution complete with download URLs</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/resolve")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ResolveBundlesResponse>> ResolveBundles([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ResolveBundlesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ResolveBundlesAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Find all bundles containing a specific asset
    /// </summary>
    /// <remarks>
    /// Query the reverse index to find all bundles (source and metabundle)
    /// <br/>that contain a specific asset ID. Useful for understanding asset
    /// <br/>distribution and debugging resolution issues.
    /// </remarks>
    /// <returns>Bundles containing the asset</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("bundles/query/by-asset")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryBundlesByAssetResponse>> QueryBundlesByAsset([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryBundlesByAssetRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.QueryBundlesByAssetAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Batch asset metadata lookup
    /// </summary>
    /// <remarks>
    /// Retrieve metadata for multiple assets in a single request.
    /// <br/>Optionally includes pre-signed download URLs.
    /// <br/>Maximum 100 asset IDs per request.
    /// </remarks>
    /// <returns>Asset metadata retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("assets/bulk-get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BulkGetAssetsResponse>> BulkGetAssets([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BulkGetAssetsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.BulkGetAssetsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }



    #region Meta Endpoints for RequestUpload

    private static readonly string _RequestUpload_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UploadRequest",
    "$defs": {
        "UploadRequest": {
            "description": "Request to initiate an asset upload and receive a pre-signed URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "filename",
                "size",
                "contentType",
                "owner"
            ],
            "properties": {
                "owner": {
                    "type": "string",
                    "description": "Owner of this asset operation. NOT a session ID.\nFor user-initiated uploads: the accountId (UUID format).\nFor service-initiated uploads: the service name (e.g., \"behavior\", \"orchestrator\").\n"
                },
                "filename": {
                    "type": "string",
                    "description": "Original filename with extension"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type (e.g., image/png, model/gltf-binary)"
                },
                "metadata": {
                    "$ref": "#/$defs/AssetMetadataInput",
                    "description": "Optional metadata for asset categorization"
                }
            }
        },
        "AssetMetadataInput": {
            "type": "object",
            "additionalProperties": false,
            "description": "User-provided metadata for asset categorization",
            "properties": {
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Type classification for the asset"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Game realm the asset belongs to"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for the asset"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        }
    }
}
""";

    private static readonly string _RequestUpload_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UploadResponse",
    "$defs": {
        "UploadResponse": {
            "description": "Response containing pre-signed URL and configuration for uploading an asset",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "uploadId",
                "uploadUrl",
                "expiresAt"
            ],
            "properties": {
                "uploadId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique upload session identifier"
                },
                "uploadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for uploading the file"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the upload URL expires"
                },
                "multipart": {
                    "$ref": "#/$defs/MultipartConfig",
                    "description": "Configuration for multipart uploads if file size requires it"
                },
                "requiredHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Headers the client must include when uploading to the pre-signed URL"
                }
            }
        },
        "MultipartConfig": {
            "description": "Configuration for multipart uploads of large files",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "required": {
                    "type": "boolean",
                    "description": "Whether multipart upload is required for this file size"
                },
                "partSize": {
                    "type": "integer",
                    "description": "Size of each part in bytes"
                },
                "maxParts": {
                    "type": "integer",
                    "description": "Maximum number of parts"
                },
                "uploadUrls": {
                    "type": "array",
                    "nullable": true,
                    "description": "Pre-signed URLs for each part of the multipart upload",
                    "items": {
                        "$ref": "#/$defs/PartUploadInfo"
                    }
                }
            }
        },
        "PartUploadInfo": {
            "description": "Upload information for a single part in a multipart upload",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "partNumber",
                "uploadUrl"
            ],
            "properties": {
                "partNumber": {
                    "type": "integer",
                    "description": "Part number (1-based)"
                },
                "uploadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for uploading this part"
                },
                "minSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Minimum size for this part"
                },
                "maxSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Maximum size for this part"
                }
            }
        }
    }
}
""";

    private static readonly string _RequestUpload_Info = """
{
    "summary": "Request upload URL for a new asset",
    "description": "Generate a pre-signed URL for uploading a new asset directly to storage.\nFor large files (>50MB), returns multipart upload configuration.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "requestUpload"
}
""";

    /// <summary>Returns endpoint information for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/request/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/upload/request",
            _RequestUpload_Info));

    /// <summary>Returns request schema for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/request/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/request",
            "request-schema",
            _RequestUpload_RequestSchema));

    /// <summary>Returns response schema for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/request/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/request",
            "response-schema",
            _RequestUpload_ResponseSchema));

    /// <summary>Returns full schema for RequestUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/request/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestUpload_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/request",
            _RequestUpload_Info,
            _RequestUpload_RequestSchema,
            _RequestUpload_ResponseSchema));

    #endregion

    #region Meta Endpoints for CompleteUpload

    private static readonly string _CompleteUpload_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CompleteUploadRequest",
    "$defs": {
        "CompleteUploadRequest": {
            "description": "Request to finalize an upload and trigger asset processing",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "uploadId"
            ],
            "properties": {
                "uploadId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Upload session ID from requestUpload"
                },
                "parts": {
                    "type": "array",
                    "nullable": true,
                    "description": "For multipart uploads - ETags of completed parts (null for single-file uploads)",
                    "items": {
                        "$ref": "#/$defs/CompletedPart"
                    }
                }
            }
        },
        "CompletedPart": {
            "description": "Information about a completed part in a multipart upload",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "partNumber",
                "etag"
            ],
            "properties": {
                "partNumber": {
                    "type": "integer",
                    "description": "Part number (1-based)"
                },
                "etag": {
                    "type": "string",
                    "description": "ETag returned from part upload"
                }
            }
        }
    }
}
""";

    private static readonly string _CompleteUpload_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetMetadata",
    "$defs": {
        "AssetMetadata": {
            "type": "object",
            "additionalProperties": false,
            "description": "Complete asset metadata including system-generated fields",
            "required": [
                "assetId",
                "contentHash",
                "filename",
                "contentType",
                "size",
                "assetType",
                "realm",
                "tags",
                "processingStatus",
                "isArchived",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "filename": {
                    "type": "string",
                    "description": "Original filename"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Type classification for the asset"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Game realm the asset belongs to"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for the asset"
                },
                "processingStatus": {
                    "$ref": "#/$defs/ProcessingStatus",
                    "description": "Current status of asset processing pipeline"
                },
                "isArchived": {
                    "type": "boolean",
                    "description": "Whether the asset is in cold/archival storage",
                    "default": false
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was last updated"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        },
        "ProcessingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "processing",
                "complete",
                "failed"
            ],
            "description": "Asset processing pipeline status"
        }
    }
}
""";

    private static readonly string _CompleteUpload_Info = """
{
    "summary": "Mark upload as complete, trigger processing",
    "description": "Called after the client has uploaded the file to the pre-signed URL.\nTriggers the asset processing pipeline (texture conversion, model validation, etc.)\nand emits completion events via WebSocket.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "completeUpload"
}
""";

    /// <summary>Returns endpoint information for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/upload/complete",
            _CompleteUpload_Info));

    /// <summary>Returns request schema for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/complete",
            "request-schema",
            _CompleteUpload_RequestSchema));

    /// <summary>Returns response schema for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/complete",
            "response-schema",
            _CompleteUpload_ResponseSchema));

    /// <summary>Returns full schema for CompleteUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/upload/complete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CompleteUpload_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/upload/complete",
            _CompleteUpload_Info,
            _CompleteUpload_RequestSchema,
            _CompleteUpload_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetAsset

    private static readonly string _GetAsset_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetAssetRequest",
    "$defs": {
        "GetAssetRequest": {
            "description": "Request to retrieve asset metadata and download URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Asset identifier"
                },
                "version": {
                    "type": "string",
                    "default": "latest",
                    "description": "Version ID or 'latest'"
                }
            }
        }
    }
}
""";

    private static readonly string _GetAsset_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetWithDownloadUrl",
    "$defs": {
        "AssetWithDownloadUrl": {
            "description": "Asset metadata with optional pre-signed download URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId",
                "versionId",
                "size",
                "contentHash",
                "contentType",
                "metadata"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "versionId": {
                    "type": "string",
                    "description": "Version identifier for this specific asset version"
                },
                "downloadUrl": {
                    "type": "string",
                    "format": "uri",
                    "nullable": true,
                    "description": "Pre-signed download URL (only populated when requested)"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the download URL expires (only populated when requested)"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "metadata": {
                    "$ref": "#/$defs/AssetMetadata",
                    "description": "Complete asset metadata"
                }
            }
        },
        "AssetMetadata": {
            "type": "object",
            "additionalProperties": false,
            "description": "Complete asset metadata including system-generated fields",
            "required": [
                "assetId",
                "contentHash",
                "filename",
                "contentType",
                "size",
                "assetType",
                "realm",
                "tags",
                "processingStatus",
                "isArchived",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "filename": {
                    "type": "string",
                    "description": "Original filename"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Type classification for the asset"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Game realm the asset belongs to"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for the asset"
                },
                "processingStatus": {
                    "$ref": "#/$defs/ProcessingStatus",
                    "description": "Current status of asset processing pipeline"
                },
                "isArchived": {
                    "type": "boolean",
                    "description": "Whether the asset is in cold/archival storage",
                    "default": false
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was last updated"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        },
        "ProcessingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "processing",
                "complete",
                "failed"
            ],
            "description": "Asset processing pipeline status"
        }
    }
}
""";

    private static readonly string _GetAsset_Info = """
{
    "summary": "Get asset metadata and download URL",
    "description": "Retrieve asset metadata and generate a pre-signed download URL.\nSpecify version to download a specific version, or omit for latest.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "getAsset"
}
""";

    /// <summary>Returns endpoint information for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/get",
            _GetAsset_Info));

    /// <summary>Returns request schema for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/get",
            "request-schema",
            _GetAsset_RequestSchema));

    /// <summary>Returns response schema for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/get",
            "response-schema",
            _GetAsset_ResponseSchema));

    /// <summary>Returns full schema for GetAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetAsset_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/get",
            _GetAsset_Info,
            _GetAsset_RequestSchema,
            _GetAsset_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeleteAsset

    private static readonly string _DeleteAsset_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteAssetRequest",
    "$defs": {
        "DeleteAssetRequest": {
            "description": "Request to delete an asset from storage",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Asset identifier to delete"
                },
                "versionId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Specific version to delete. If omitted, all versions are deleted.\n"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteAsset_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteAssetResponse",
    "$defs": {
        "DeleteAssetResponse": {
            "description": "Response confirming asset deletion",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId",
                "versionsDeleted"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Deleted asset identifier"
                },
                "versionsDeleted": {
                    "type": "integer",
                    "description": "Number of versions deleted"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteAsset_Info = """
{
    "summary": "Delete an asset",
    "description": "Delete an asset from storage. If versionId is specified, only that version is deleted.\nIf versionId is omitted, all versions are deleted.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "deleteAsset"
}
""";

    /// <summary>Returns endpoint information for DeleteAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteAsset_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/delete",
            _DeleteAsset_Info));

    /// <summary>Returns request schema for DeleteAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteAsset_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/delete",
            "request-schema",
            _DeleteAsset_RequestSchema));

    /// <summary>Returns response schema for DeleteAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteAsset_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/delete",
            "response-schema",
            _DeleteAsset_ResponseSchema));

    /// <summary>Returns full schema for DeleteAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteAsset_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/delete",
            _DeleteAsset_Info,
            _DeleteAsset_RequestSchema,
            _DeleteAsset_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListAssetVersions

    private static readonly string _ListAssetVersions_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListVersionsRequest",
    "$defs": {
        "ListVersionsRequest": {
            "description": "Request to list all versions of an asset with pagination",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Asset identifier to list versions for"
                },
                "limit": {
                    "type": "integer",
                    "default": 50,
                    "description": "Maximum number of versions to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Number of versions to skip for pagination"
                }
            }
        }
    }
}
""";

    private static readonly string _ListAssetVersions_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetVersionList",
    "$defs": {
        "AssetVersionList": {
            "description": "Paginated list of asset versions",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId",
                "versions",
                "total",
                "limit",
                "offset"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Asset identifier"
                },
                "versions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetVersion"
                    },
                    "description": "List of asset versions"
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of versions available"
                },
                "limit": {
                    "type": "integer",
                    "description": "Maximum number of versions returned per page"
                },
                "offset": {
                    "type": "integer",
                    "description": "Number of versions skipped"
                }
            }
        },
        "AssetVersion": {
            "description": "Metadata for a specific version of an asset",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "versionId",
                "createdAt",
                "size",
                "isArchived"
            ],
            "properties": {
                "versionId": {
                    "type": "string",
                    "description": "Unique version identifier"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when this version was created"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes for this version"
                },
                "isArchived": {
                    "type": "boolean",
                    "description": "Whether this version is in cold storage"
                }
            }
        }
    }
}
""";

    private static readonly string _ListAssetVersions_Info = """
{
    "summary": "List all versions of an asset",
    "description": "Retrieve version history for an asset with pagination.\nIncludes version IDs, creation timestamps, and archive status.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "listAssetVersions"
}
""";

    /// <summary>Returns endpoint information for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/list-versions/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/list-versions",
            _ListAssetVersions_Info));

    /// <summary>Returns request schema for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/list-versions/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/list-versions",
            "request-schema",
            _ListAssetVersions_RequestSchema));

    /// <summary>Returns response schema for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/list-versions/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/list-versions",
            "response-schema",
            _ListAssetVersions_ResponseSchema));

    /// <summary>Returns full schema for ListAssetVersions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/list-versions/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListAssetVersions_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/list-versions",
            _ListAssetVersions_Info,
            _ListAssetVersions_RequestSchema,
            _ListAssetVersions_ResponseSchema));

    #endregion

    #region Meta Endpoints for SearchAssets

    private static readonly string _SearchAssets_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetSearchRequest",
    "$defs": {
        "AssetSearchRequest": {
            "description": "Search criteria for filtering assets with pagination",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetType",
                "realm"
            ],
            "properties": {
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Filter by tags (assets must have all specified tags) (null to skip tag filtering)"
                },
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Filter by asset type"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Filter by game realm"
                },
                "contentType": {
                    "type": "string",
                    "nullable": true,
                    "description": "MIME content type filter (null to skip content type filtering)"
                },
                "limit": {
                    "type": "integer",
                    "default": 50,
                    "description": "Maximum number of results to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Number of results to skip for pagination"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        }
    }
}
""";

    private static readonly string _SearchAssets_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AssetSearchResult",
    "$defs": {
        "AssetSearchResult": {
            "description": "Paginated results from an asset search query",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assets",
                "total",
                "limit",
                "offset"
            ],
            "properties": {
                "assets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetMetadata"
                    },
                    "description": "List of matching assets"
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of matching assets"
                },
                "limit": {
                    "type": "integer",
                    "description": "Maximum number of results returned per page"
                },
                "offset": {
                    "type": "integer",
                    "description": "Number of results skipped"
                }
            }
        },
        "AssetMetadata": {
            "type": "object",
            "additionalProperties": false,
            "description": "Complete asset metadata including system-generated fields",
            "required": [
                "assetId",
                "contentHash",
                "filename",
                "contentType",
                "size",
                "assetType",
                "realm",
                "tags",
                "processingStatus",
                "isArchived",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "filename": {
                    "type": "string",
                    "description": "Original filename"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Type classification for the asset"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Game realm the asset belongs to"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for the asset"
                },
                "processingStatus": {
                    "$ref": "#/$defs/ProcessingStatus",
                    "description": "Current status of asset processing pipeline"
                },
                "isArchived": {
                    "type": "boolean",
                    "description": "Whether the asset is in cold/archival storage",
                    "default": false
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was last updated"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        },
        "ProcessingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "processing",
                "complete",
                "failed"
            ],
            "description": "Asset processing pipeline status"
        }
    }
}
""";

    private static readonly string _SearchAssets_Info = """
{
    "summary": "Search assets by tags, type, or realm",
    "description": "Search assets using various filters with pagination.\nAll filters are optional and combine with AND logic.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "searchAssets"
}
""";

    /// <summary>Returns endpoint information for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/search/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/search",
            _SearchAssets_Info));

    /// <summary>Returns request schema for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/search/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/search",
            "request-schema",
            _SearchAssets_RequestSchema));

    /// <summary>Returns response schema for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/search/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/search",
            "response-schema",
            _SearchAssets_ResponseSchema));

    /// <summary>Returns full schema for SearchAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/search/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchAssets_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/search",
            _SearchAssets_Info,
            _SearchAssets_RequestSchema,
            _SearchAssets_ResponseSchema));

    #endregion

    #region Meta Endpoints for CreateBundle

    private static readonly string _CreateBundle_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateBundleRequest",
    "$defs": {
        "CreateBundleRequest": {
            "description": "Request to create a new asset bundle from multiple assets",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bundleId",
                "assetIds",
                "owner"
            ],
            "properties": {
                "owner": {
                    "type": "string",
                    "description": "Owner of this bundle. NOT a session ID.\nFor user-initiated bundles: the accountId (UUID format).\nFor service-initiated bundles: the service name (e.g., \"orchestrator\").\n"
                },
                "bundleId": {
                    "type": "string",
                    "description": "Unique bundle identifier"
                },
                "version": {
                    "type": "string",
                    "default": "1.0.0",
                    "description": "Bundle version string"
                },
                "realm": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/Realm"
                        }
                    ],
                    "nullable": true,
                    "description": "Game realm this bundle belongs to.\nDefaults to 'shared' if not specified.\n"
                },
                "assetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of asset IDs to include in the bundle"
                },
                "compression": {
                    "$ref": "#/$defs/CompressionType",
                    "description": "Compression algorithm to use for the bundle"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Custom metadata for the bundle (null if none)"
                }
            }
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        },
        "CompressionType": {
            "type": "string",
            "enum": [
                "lz4",
                "lzma",
                "none"
            ],
            "description": "Compression algorithm for bundles"
        }
    }
}
""";

    private static readonly string _CreateBundle_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateBundleResponse",
    "$defs": {
        "CreateBundleResponse": {
            "description": "Response with bundle creation status and estimated size",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bundleId",
                "status",
                "estimatedSize"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Unique bundle identifier"
                },
                "status": {
                    "type": "string",
                    "enum": [
                        "queued",
                        "processing",
                        "ready",
                        "failed"
                    ],
                    "description": "Bundle creation status"
                },
                "estimatedSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Estimated bundle size in bytes"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateBundle_Info = """
{
    "summary": "Create asset bundle from multiple assets",
    "description": "Create a .bannou bundle containing multiple assets.\nFor large bundles, processing is delegated to the processing pool.\ nCompletion notification sent via WebSocket event.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "createBundle"
}
""";

    /// <summary>Returns endpoint information for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "bundles/create",
            _CreateBundle_Info));

    /// <summary>Returns request schema for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/create",
            "request-schema",
            _CreateBundle_RequestSchema));

    /// <summary>Returns response schema for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/create",
            "response-schema",
            _CreateBundle_ResponseSchema));

    /// <summary>Returns full schema for CreateBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateBundle_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "bundles/create",
            _CreateBundle_Info,
            _CreateBundle_RequestSchema,
            _CreateBundle_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetBundle

    private static readonly string _GetBundle_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetBundleRequest",
    "$defs": {
        "GetBundleRequest": {
            "description": "Request to retrieve bundle metadata and download URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bundleId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Bundle identifier to retrieve"
                },
                "format": {
                    "$ref": "#/$defs/BundleFormat",
                    "description": "Desired download format (bannou or zip)"
                }
            }
        },
        "BundleFormat": {
            "type": "string",
            "enum": [
                "bannou",
                "zip"
            ],
            "description": "Bundle file format"
        }
    }
}
""";

    private static readonly string _GetBundle_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BundleWithDownloadUrl",
    "$defs": {
        "BundleWithDownloadUrl": {
            "description": "Bundle metadata combined with a pre-signed download URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bundleId",
                "version",
                "downloadUrl",
                "format",
                "expiresAt",
                "size",
                "assetCount",
                "fromCache"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Unique bundle identifier"
                },
                "version": {
                    "type": "string",
                    "description": "Bundle version string"
                },
                "downloadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for downloading the bundle"
                },
                "format": {
                    "$ref": "#/$defs/BundleFormat",
                    "description": "Format of the downloadable bundle"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the download URL expires"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Bundle file size in bytes"
                },
                "assetCount": {
                    "type": "integer",
                    "description": "Number of assets contained in the bundle"
                },
                "fromCache": {
                    "type": "boolean",
                    "description": "True if ZIP format was served from conversion cache"
                }
            }
        },
        "BundleFormat": {
            "type": "string",
            "enum": [
                "bannou",
                "zip"
            ],
            "description": "Bundle file format"
        }
    }
}
""";

    private static readonly string _GetBundle_Info = """
{
    "summary": "Get bundle manifest and download URL",
    "description": "Retrieve bundle metadata and generate a pre-signed download URL.\nSupports both native .bannou format and ZIP conversion (cached).\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "getBundle"
}
""";

    /// <summary>Returns endpoint information for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "bundles/get",
            _GetBundle_Info));

    /// <summary>Returns request schema for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/get",
            "request-schema",
            _GetBundle_RequestSchema));

    /// <summary>Returns response schema for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/get",
            "response-schema",
            _GetBundle_ResponseSchema));

    /// <summary>Returns full schema for GetBundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBundle_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "bundles/get",
            _GetBundle_Info,
            _GetBundle_RequestSchema,
            _GetBundle_ResponseSchema));

    #endregion

    #region Meta Endpoints for RequestBundleUpload

    private static readonly string _RequestBundleUpload_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BundleUploadRequest",
    "$defs": {
        "BundleUploadRequest": {
            "description": "Request to upload a pre-built asset bundle file",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "filename",
                "size",
                "owner"
            ],
            "properties": {
                "owner": {
                    "type": "string",
                    "description": "Owner of this bundle upload. NOT a session ID.\nFor user-initiated uploads: the accountId (UUID format).\nFor service-initiated uploads: the service name (e.g., \"orchestrator\").\n"
                },
                "filename": {
                    "type": "string",
                    "description": "Must end with .bannou or .zip"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Bundle file size in bytes"
                },
                "manifestPreview": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/BundleManifestPreview"
                        }
                    ],
                    "nullable": true,
                    "description": "Optional preview of bundle manifest for validation"
                }
            }
        },
        "BundleManifestPreview": {
            "type": "object",
            "additionalProperties": false,
            "description": "Preview of bundle manifest for validation",
            "required": [
                "bundleId",
                "version",
                "assetCount"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Bundle identifier from the manifest"
                },
                "version": {
                    "type": "string",
                    "description": "Bundle version from the manifest"
                },
                "assetCount": {
                    "type": "integer",
                    "description": "Number of assets declared in the manifest"
                }
            }
        }
    }
}
""";

    private static readonly string _RequestBundleUpload_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UploadResponse",
    "$defs": {
        "UploadResponse": {
            "description": "Response containing pre-signed URL and configuration for uploading an asset",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "uploadId",
                "uploadUrl",
                "expiresAt"
            ],
            "properties": {
                "uploadId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique upload session identifier"
                },
                "uploadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for uploading the file"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the upload URL expires"
                },
                "multipart": {
                    "$ref": "#/$defs/MultipartConfig",
                    "description": "Configuration for multipart uploads if file size requires it"
                },
                "requiredHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Headers the client must include when uploading to the pre-signed URL"
                }
            }
        },
        "MultipartConfig": {
            "description": "Configuration for multipart uploads of large files",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "required": {
                    "type": "boolean",
                    "description": "Whether multipart upload is required for this file size"
                },
                "partSize": {
                    "type": "integer",
                    "description": "Size of each part in bytes"
                },
                "maxParts": {
                    "type": "integer",
                    "description": "Maximum number of parts"
                },
                "uploadUrls": {
                    "type": "array",
                    "nullable": true,
                    "description": "Pre-signed URLs for each part of the multipart upload",
                    "items": {
                        "$ref": "#/$defs/PartUploadInfo"
                    }
                }
            }
        },
        "PartUploadInfo": {
            "description": "Upload information for a single part in a multipart upload",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "partNumber",
                "uploadUrl"
            ],
            "properties": {
                "partNumber": {
                    "type": "integer",
                    "description": "Part number (1-based)"
                },
                "uploadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed URL for uploading this part"
                },
                "minSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Minimum size for this part"
                },
                "maxSize": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Maximum size for this part"
                }
            }
        }
    }
}
""";

    private static readonly string _RequestBundleUpload_Info = """
{
    "summary": "Request upload URL for a pre-made bundle",
    "description": "Upload a pre-built bundle (.bannou or .zip format).\nAfter upload, the bundle undergoes validation before registration.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "requestBundleUpload"
}
""";

    /// <summary>Returns endpoint information for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "bundles/upload/request",
            _RequestBundleUpload_Info));

    /// <summary>Returns request schema for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/upload/request",
            "request-schema",
            _RequestBundleUpload_RequestSchema));

    /// <summary>Returns response schema for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/upload/request",
            "response-schema",
            _RequestBundleUpload_ResponseSchema));

    /// <summary>Returns full schema for RequestBundleUpload</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/upload/request/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestBundleUpload_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "bundles/upload/request",
            _RequestBundleUpload_Info,
            _RequestBundleUpload_RequestSchema,
            _RequestBundleUpload_ResponseSchema));

    #endregion

    #region Meta Endpoints for CreateMetabundle

    private static readonly string _CreateMetabundle_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateMetabundleRequest",
    "$defs": {
        "CreateMetabundleRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to create a metabundle from source bundles and/or standalone assets.\ nAt least one of sourceBundleIds or standaloneAssetIds must be provided.\nThis enables packaging behaviors/scripts with 3D assets as a complete unit.\n",
            "required": [
                "metabundleId",
                "owner",
                "realm"
            ],
            "properties": {
                "metabundleId": {
                    "type": "string",
                    "description": "Unique identifier for the new metabundle"
                },
                "sourceBundleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Source bundle IDs to pull assets from. Can cherry-pick specific\nassets using assetFilter, or include all if assetFilter is null.\n"
                },
                "standaloneAssetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Individual asset IDs (not in bundles) to include directly.\nUseful for including behaviors, scripts, or metadata files\nalongside bundled 3D assets.\n"
                },
                "version": {
                    "type": "string",
                    "default": "1.0.0",
                    "description": "Metabundle version string"
                },
                "owner": {
                    "type": "string",
                    "description": "Owner of this metabundle. NOT a session ID.\nFor user-initiated: the accountId (UUID format).\nFor service-initiated: the service name.\n"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Game realm for this metabundle"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Human-readable description"
                },
                "assetFilter": {
                    "type": "array",
                    "nullable": true,
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional subset of asset IDs to include FROM SOURCE BUNDLES.\nIf null, all assets from source bundles are included.\nStandalone assets are always included regardless of this filter.\n"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Custom metadata for the metabundle"
                }
            }
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        }
    }
}
""";

    private static readonly string _CreateMetabundle_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateMetabundleResponse",
    "$defs": {
        "CreateMetabundleResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response from metabundle creation",
            "required": [
                "metabundleId",
                "status",
                "assetCount",
                "sizeBytes"
            ],
            "properties": {
                "metabundleId": {
                    "type": "string",
                    "description": "Metabundle identifier"
                },
                "status": {
                    "type": "string",
                    "enum": [
                        "queued",
                        "processing",
                        "ready",
                        "failed"
                    ],
                    "description": "Creation status"
                },
                "assetCount": {
                    "type": "integer",
                    "description": "Number of assets in the metabundle"
                },
                "standaloneAssetCount": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Number of standalone assets included directly (not from bundles)"
                },
                "sizeBytes": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Total size in bytes"
                },
                "sourceBundles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SourceBundleReference"
                    },
                    "description": "Provenance data for the metabundle"
                },
                "conflicts": {
                    "type": "array",
                    "nullable": true,
                    "items": {
                        "$ref": "#/$defs/AssetConflict"
                    },
                    "description": "Present if creation failed due to asset conflicts"
                }
            }
        },
        "SourceBundleReference": {
            "type": "object",
            "additionalProperties": false,
            "description": "Provenance reference to a source bundle used in metabundle creation",
            "required": [
                "bundleId",
                "version",
                "assetIds",
                "contentHash"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Source bundle identifier"
                },
                "version": {
                    "type": "string",
                    "description": "Version of source bundle at composition time"
                },
                "assetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Asset IDs contributed from this source bundle"
                },
                "contentHash": {
                    "type": "string",
                    "description": "Hash of source bundle at composition time (for integrity verification)"
                }
            }
        },
        "AssetConflict": {
            "type": "object",
            "additionalProperties": false,
            "description": "Describes a conflict when the same asset ID has different content hashes",
            "required": [
                "assetId",
                "conflictingBundles"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "The conflicting asset identifier"
                },
                "conflictingBundles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ConflictingBundleEntry"
                    },
                    "description": "Bundles with conflicting versions of this asset"
                }
            }
        },
        "ConflictingBundleEntry": {
            "type": "object",
            "additionalProperties": false,
            "description": "A bundle entry in an asset conflict",
            "required": [
                "bundleId",
                "contentHash"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Bundle containing this version"
                },
                "contentHash": {
                    "type": "string",
                    "description": "Content hash of asset in this bundle"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateMetabundle_Info = """
{
    "summary": "Create metabundle from source bundles",
    "description": "Compose a metabundle by extracting and repackaging assets from multiple\nsource bundles. The resulting metabundle is a complete physical copy with\nprovenance metadata tracking the source bundles.\n\nAssets are deduplicated by content hash. If the same asset ID exists in\nmultiple source bundles with different content hashes, the request fails\nwith conflict details.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "createMetabundle"
}
""";

    /// <summary>Returns endpoint information for CreateMetabundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/metabundle/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateMetabundle_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "bundles/metabundle/create",
            _CreateMetabundle_Info));

    /// <summary>Returns request schema for CreateMetabundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/metabundle/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateMetabundle_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/metabundle/create",
            "request-schema",
            _CreateMetabundle_RequestSchema));

    /// <summary>Returns response schema for CreateMetabundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/metabundle/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateMetabundle_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/metabundle/create",
            "response-schema",
            _CreateMetabundle_ResponseSchema));

    /// <summary>Returns full schema for CreateMetabundle</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/metabundle/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateMetabundle_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "bundles/metabundle/create",
            _CreateMetabundle_Info,
            _CreateMetabundle_RequestSchema,
            _CreateMetabundle_ResponseSchema));

    #endregion

    #region Meta Endpoints for ResolveBundles

    private static readonly string _ResolveBundles_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ResolveBundlesRequest",
    "$defs": {
        "ResolveBundlesRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to resolve optimal bundle downloads for requested assets",
            "required": [
                "assetIds",
                "realm"
            ],
            "properties": {
                "assetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Platform asset IDs to resolve"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Game realm to search within"
                },
                "preferMetabundles": {
                    "type": "boolean",
                    "default": true,
                    "description": "Prefer metabundles when coverage is equal"
                },
                "includeStandalone": {
                    "type": "boolean",
                    "default": true,
                    "description": "Include standalone assets not in any bundle"
                },
                "maxBundles": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum number of bundles to return (optimization limit)"
                }
            }
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        }
    }
}
""";

    private static readonly string _ResolveBundles_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ResolveBundlesResponse",
    "$defs": {
        "ResolveBundlesResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Optimal bundle set for requested assets",
            "required": [
                "bundles",
                "standaloneAssets",
                "coverage"
            ],
            "properties": {
                "bundles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ResolvedBundle"
                    },
                    "description": "Bundles to download"
                },
                "standaloneAssets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ResolvedAsset"
                    },
                    "description": "Individual assets to download"
                },
                "coverage": {
                    "$ref": "#/$defs/CoverageAnalysis",
                    "description": "Coverage statistics"
                },
                "unresolved": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Asset IDs that couldn't be found (null if all resolved)"
                }
            }
        },
        "ResolvedBundle": {
            "type": "object",
            "additionalProperties": false,
            "description": "A bundle selected for download in resolution",
            "required": [
                "bundleId",
                "bundleType",
                "downloadUrl",
                "expiresAt",
                "size",
                "assetsProvided"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Bundle identifier"
                },
                "bundleType": {
                    "$ref": "#/$defs/BundleType",
                    "description": "Whether source or metabundle"
                },
                "version": {
                    "type": "string",
                    "nullable": true,
                    "description": "Bundle version"
                },
                "downloadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed download URL"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the download URL expires"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Bundle file size in bytes"
                },
                "assetsProvided": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Which of the requested assets this bundle provides"
                }
            }
        },
        "BundleType": {
            "type": "string",
            "enum": [
                "source",
                "metabundle"
            ],
            "description": "Bundle category:\n- source: Original bundle (uploaded or server-created from assets)\n- metabundle: Composed from other bundles server-side\n"
        },
        "ResolvedAsset": {
            "type": "object",
            "additionalProperties": false,
            "description": "A standalone asset selected for download",
            "required": [
                "assetId",
                "downloadUrl",
                "expiresAt",
                "size"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Asset identifier"
                },
                "downloadUrl": {
                    "type": "string",
                    "format": "uri",
                    "description": "Pre-signed download URL"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the download URL expires"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Asset file size in bytes"
                },
                "contentHash": {
                    "type": "string",
                    "nullable": true,
                    "description": "SHA256 hash of asset content"
                }
            }
        },
        "CoverageAnalysis": {
            "type": "object",
            "additionalProperties": false,
            "description": "Statistics about asset resolution coverage",
            "required": [
                "totalRequested",
                "resolvedViaBundles",
                "resolvedStandalone",
                "unresolvedCount"
            ],
            "properties": {
                "totalRequested": {
                    "type": "integer",
                    "description": "Total number of assets requested"
                },
                "resolvedViaBundles": {
                    "type": "integer",
                    "description": "Assets resolved through bundle downloads"
                },
                "resolvedStandalone": {
                    "type": "integer",
                    "description": "Assets resolved as standalone downloads"
                },
                "unresolvedCount": {
                    "type": "integer",
                    "description": "Assets that could not be found"
                },
                "bundleEfficiency": {
                    "type": "number",
                    "format": "float",
                    "nullable": true,
                    "description": "Ratio of assets provided to bundle downloads (higher is better)"
                }
            }
        }
    }
}
""";

    private static readonly string _ResolveBundles_Info = """
{
    "summary": "Compute optimal bundles for requested assets",
    "description": "Given a list of asset IDs, compute the optimal set of bundles to download\nto obtain all requested assets with minimal transfers.\n\nThe algorithm uses greedy set-cover optimization:\n1. Find all bundles containing requested assets\ n2. Select bundles that cover the most uncovered assets\n3. Prefer metabundles when coverage is equal (tie-breaker)\ n4. Include standalone assets for any remaining unresolved IDs\n\nReturns pre-signed download URLs for all selected bundles and assets.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "resolveBundles"
}
""";

    /// <summary>Returns endpoint information for ResolveBundles</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/resolve/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ResolveBundles_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "bundles/resolve",
            _ResolveBundles_Info));

    /// <summary>Returns request schema for ResolveBundles</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/resolve/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ResolveBundles_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/resolve",
            "request-schema",
            _ResolveBundles_RequestSchema));

    /// <summary>Returns response schema for ResolveBundles</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/resolve/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ResolveBundles_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/resolve",
            "response-schema",
            _ResolveBundles_ResponseSchema));

    /// <summary>Returns full schema for ResolveBundles</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/resolve/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ResolveBundles_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "bundles/resolve",
            _ResolveBundles_Info,
            _ResolveBundles_RequestSchema,
            _ResolveBundles_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryBundlesByAsset

    private static readonly string _QueryBundlesByAsset_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryBundlesByAssetRequest",
    "$defs": {
        "QueryBundlesByAssetRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to find bundles containing a specific asset",
            "required": [
                "assetId",
                "realm"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Platform asset ID to search for"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Game realm to search within"
                },
                "bundleType": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/BundleType"
                        }
                    ],
                    "nullable": true,
                    "description": "Filter by bundle type (optional, null for all types)"
                },
                "limit": {
                    "type": "integer",
                    "default": 50,
                    "description": "Maximum results to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Pagination offset"
                }
            }
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        },
        "BundleType": {
            "type": "string",
            "enum": [
                "source",
                "metabundle"
            ],
            "description": "Bundle category:\n- source: Original bundle (uploaded or server-created from assets)\n- metabundle: Composed from other bundles server-side\n"
        }
    }
}
""";

    private static readonly string _QueryBundlesByAsset_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryBundlesByAssetResponse",
    "$defs": {
        "QueryBundlesByAssetResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Bundles containing the requested asset",
            "required": [
                "assetId",
                "bundles",
                "total",
                "limit",
                "offset"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "The queried asset ID"
                },
                "bundles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/BundleSummary"
                    },
                    "description": "Bundles containing this asset"
                },
                "total": {
                    "type": "integer",
                    "description": "Total matching bundles"
                },
                "limit": {
                    "type": "integer",
                    "description": "Page size"
                },
                "offset": {
                    "type": "integer",
                    "description": "Page offset"
                }
            }
        },
        "BundleSummary": {
            "type": "object",
            "additionalProperties": false,
            "description": "Summary information about a bundle",
            "required": [
                "bundleId",
                "bundleType",
                "version",
                "assetCount",
                "realm"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "description": "Bundle identifier"
                },
                "bundleType": {
                    "$ref": "#/$defs/BundleType",
                    "description": "Source or metabundle"
                },
                "version": {
                    "type": "string",
                    "description": "Bundle version"
                },
                "assetCount": {
                    "type": "integer",
                    "description": "Number of assets in bundle"
                },
                "sizeBytes": {
                    "type": "integer",
                    "format": "int64",
                    "nullable": true,
                    "description": "Bundle file size"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Game realm"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the bundle was created"
                }
            }
        },
        "BundleType": {
            "type": "string",
            "enum": [
                "source",
                "metabundle"
            ],
            "description": "Bundle category:\n- source: Original bundle (uploaded or server-created from assets)\n- metabundle: Composed from other bundles server-side\n"
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        }
    }
}
""";

    private static readonly string _QueryBundlesByAsset_Info = """
{
    "summary": "Find all bundles containing a specific asset",
    "description": "Query the reverse index to find all bundles (source and metabundle)\nthat contain a specific asset ID. Useful for understanding asset\ndistribution and debugging resolution issues.\n",
    "tags": [
        "Bundles"
    ],
    "deprecated": false,
    "operationId": "queryBundlesByAsset"
}
""";

    /// <summary>Returns endpoint information for QueryBundlesByAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/query/by-asset/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBundlesByAsset_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "bundles/query/by-asset",
            _QueryBundlesByAsset_Info));

    /// <summary>Returns request schema for QueryBundlesByAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/query/by-asset/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBundlesByAsset_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/query/by-asset",
            "request-schema",
            _QueryBundlesByAsset_RequestSchema));

    /// <summary>Returns response schema for QueryBundlesByAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/query/by-asset/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBundlesByAsset_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "bundles/query/by-asset",
            "response-schema",
            _QueryBundlesByAsset_ResponseSchema));

    /// <summary>Returns full schema for QueryBundlesByAsset</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("bundles/query/by-asset/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBundlesByAsset_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "bundles/query/by-asset",
            _QueryBundlesByAsset_Info,
            _QueryBundlesByAsset_RequestSchema,
            _QueryBundlesByAsset_ResponseSchema));

    #endregion

    #region Meta Endpoints for BulkGetAssets

    private static readonly string _BulkGetAssets_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BulkGetAssetsRequest",
    "$defs": {
        "BulkGetAssetsRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to retrieve metadata for multiple assets",
            "required": [
                "assetIds"
            ],
            "properties": {
                "assetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Asset IDs to retrieve (max 100)"
                },
                "includeDownloadUrls": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether to generate pre-signed download URLs"
                }
            }
        }
    }
}
""";

    private static readonly string _BulkGetAssets_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BulkGetAssetsResponse",
    "$defs": {
        "BulkGetAssetsResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Batch asset metadata response",
            "required": [
                "assets",
                "notFound"
            ],
            "properties": {
                "assets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetWithDownloadUrl"
                    },
                    "description": "Found assets with metadata"
                },
                "notFound": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Asset IDs that weren't found"
                }
            }
        },
        "AssetWithDownloadUrl": {
            "description": "Asset metadata with optional pre-signed download URL",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "assetId",
                "versionId",
                "size",
                "contentHash",
                "contentType",
                "metadata"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "versionId": {
                    "type": "string",
                    "description": "Version identifier for this specific asset version"
                },
                "downloadUrl": {
                    "type": "string",
                    "format": "uri",
                    "nullable": true,
                    "description": "Pre-signed download URL (only populated when requested)"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When the download URL expires (only populated when requested)"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "metadata": {
                    "$ref": "#/$defs/AssetMetadata",
                    "description": "Complete asset metadata"
                }
            }
        },
        "AssetMetadata": {
            "type": "object",
            "additionalProperties": false,
            "description": "Complete asset metadata including system-generated fields",
            "required": [
                "assetId",
                "contentHash",
                "filename",
                "contentType",
                "size",
                "assetType",
                "realm",
                "tags",
                "processingStatus",
                "isArchived",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "description": "Unique asset identifier"
                },
                "contentHash": {
                    "type": "string",
                    "description": "SHA256 hash of file contents"
                },
                "filename": {
                    "type": "string",
                    "description": "Original filename"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME content type"
                },
                "size": {
                    "type": "integer",
                    "format": "int64",
                    "description": "File size in bytes"
                },
                "assetType": {
                    "$ref": "#/$defs/AssetType",
                    "description": "Type classification for the asset"
                },
                "realm": {
                    "$ref": "#/$defs/Realm",
                    "description": "Game realm the asset belongs to"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for the asset"
                },
                "processingStatus": {
                    "$ref": "#/$defs/ProcessingStatus",
                    "description": "Current status of asset processing pipeline"
                },
                "isArchived": {
                    "type": "boolean",
                    "description": "Whether the asset is in cold/archival storage",
                    "default": false
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the asset was last updated"
                }
            }
        },
        "AssetType": {
            "type": "string",
            "enum": [
                "texture",
                "model",
                "audio",
                "behavior",
                "bundle",
                "prefab",
                "other"
            ],
            "description": "Type classification for assets"
        },
        "Realm": {
            "type": "string",
            "enum": [
                "omega",
                "arcadia",
                "fantasia",
                "shared"
            ],
            "description": "Game realm the asset belongs to"
        },
        "ProcessingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "processing",
                "complete",
                "failed"
            ],
            "description": "Asset processing pipeline status"
        }
    }
}
""";

    private static readonly string _BulkGetAssets_Info = """
{
    "summary": "Batch asset metadata lookup",
    "description": "Retrieve metadata for multiple assets in a single request.\nOptionally includes pre-signed download URLs.\nMaximum 100 asset IDs per request.\n",
    "tags": [
        "Assets"
    ],
    "deprecated": false,
    "operationId": "bulkGetAssets"
}
""";

    /// <summary>Returns endpoint information for BulkGetAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/bulk-get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkGetAssets_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Asset",
            "Post",
            "assets/bulk-get",
            _BulkGetAssets_Info));

    /// <summary>Returns request schema for BulkGetAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/bulk-get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkGetAssets_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/bulk-get",
            "request-schema",
            _BulkGetAssets_RequestSchema));

    /// <summary>Returns response schema for BulkGetAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/bulk-get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkGetAssets_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Asset",
            "Post",
            "assets/bulk-get",
            "response-schema",
            _BulkGetAssets_ResponseSchema));

    /// <summary>Returns full schema for BulkGetAssets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("assets/bulk-get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkGetAssets_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Asset",
            "Post",
            "assets/bulk-get",
            _BulkGetAssets_Info,
            _BulkGetAssets_RequestSchema,
            _BulkGetAssets_ResponseSchema));

    #endregion

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
