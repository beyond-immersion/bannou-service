//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     RELATED FILES:
//     - Request/Response models: bannou-service/Generated/Models/{Service}Models.cs
//     - Event models: bannou-service/Generated/Events/{Service}EventsModels.cs
//     - Lifecycle events: bannou-service/Generated/Events/{Service}LifecycleEvents.cs
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Actor;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IActorController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Create an actor template (category definition)
    /// </summary>


    /// <returns>Template created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> CreateActorTemplateAsync(CreateActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get an actor template by ID or category
    /// </summary>


    /// <returns>Template retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> GetActorTemplateAsync(GetActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all actor templates
    /// </summary>


    /// <returns>Templates listed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListActorTemplatesResponse>> ListActorTemplatesAsync(ListActorTemplatesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update an actor template
    /// </summary>


    /// <returns>Template updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> UpdateActorTemplateAsync(UpdateActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete an actor template
    /// </summary>


    /// <returns>Template deleted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteActorTemplateResponse>> DeleteActorTemplateAsync(DeleteActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Spawn a new actor from a template
    /// </summary>


    /// <returns>Actor spawned successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorInstanceResponse>> SpawnActorAsync(SpawnActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get actor instance (instantiate-on-access if template allows)
    /// </summary>

    /// <remarks>
    /// If the actor exists, returns its current state.
    /// <br/>If the actor doesn't exist but a matching template has auto-spawn enabled,
    /// <br/>instantiates the actor and returns it.
    /// </remarks>

    /// <returns>Actor retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorInstanceResponse>> GetActorAsync(GetActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Stop a running actor
    /// </summary>


    /// <returns>Actor stopped successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<StopActorResponse>> StopActorAsync(StopActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Bind an unbound actor to a character
    /// </summary>

    /// <remarks>
    /// Transitions an unbound (event-mode) actor to a bound (character-mode) actor.
    /// <br/>After binding, the actor receives character perception events and variable
    /// <br/>providers begin loading character-specific data on subsequent ticks.
    /// <br/>Fails if the actor is already bound to a character.
    /// </remarks>

    /// <returns>Actor bound to character successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorInstanceResponse>> BindActorCharacterAsync(BindActorCharacterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Cleanup actors referencing a deleted character
    /// </summary>

    /// <remarks>
    /// Called by lib-resource cleanup coordination when a character is deleted.
    /// <br/>Stops and removes all actors that reference the specified characterId.
    /// <br/>This endpoint is designed for internal service-to-service calls during
    /// <br/>cascading resource cleanup.
    /// </remarks>

    /// <returns>Cleanup completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupByCharacterResponse>> CleanupByCharacterAsync(CleanupByCharacterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List actors with optional filters
    /// </summary>


    /// <returns>Actors listed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListActorsResponse>> ListActorsAsync(ListActorsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Inject a perception event into an actor's queue (testing)
    /// </summary>

    /// <remarks>
    /// Injects a perception event directly into the actor's perception queue
    /// <br/>for testing purposes. Useful for testing actor behavior without a
    /// <br/>full game server setup.
    /// </remarks>

    /// <returns>Perception injected successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InjectPerceptionResponse>> InjectPerceptionAsync(InjectPerceptionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Query an actor for its available options
    /// </summary>

    /// <remarks>
    /// Query an actor for its available options (combat, dialogue, exploration, etc.).
    /// <br/>Options are maintained by the actor in its state and returned based on requested
    /// <br/>freshness level. This enables Event Brain actors to ask participants "what can
    /// <br/>you do?" for choreography and coordination.
    /// <br/>
    /// <br/>Freshness levels:
    /// <br/>- fresh: Inject context and wait for actor to recompute options
    /// <br/>- cached: Return cached options if within maxAgeMs, else recompute
    /// <br/>- stale_ok: Return cached options regardless of age
    /// </remarks>

    /// <returns>Options retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryOptionsResponse>> QueryOptionsAsync(QueryOptionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Start an encounter managed by an Event Brain actor
    /// </summary>

    /// <remarks>
    /// Initializes an encounter with the specified participants. The Event Brain actor
    /// <br/>will coordinate the encounter, sending instructions to participant NPC Brain actors
    /// <br/>via their character perception channels.
    /// </remarks>

    /// <returns>Encounter started successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> StartEncounterAsync(StartEncounterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update the phase of an active encounter
    /// </summary>

    /// <remarks>
    /// Updates the phase of an encounter being managed by an Event Brain actor.
    /// <br/>Phase changes are logged and can trigger behavior changes in participant actors.
    /// </remarks>

    /// <returns>Encounter phase updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateEncounterPhaseResponse>> UpdateEncounterPhaseAsync(UpdateEncounterPhaseRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// End an active encounter
    /// </summary>

    /// <remarks>
    /// Ends an encounter being managed by an Event Brain actor. This clears the
    /// <br/>encounter state and allows the actor to manage a new encounter.
    /// </remarks>

    /// <returns>Encounter ended successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EndEncounterResponse>> EndEncounterAsync(EndEncounterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get the current encounter state for an actor
    /// </summary>

    /// <remarks>
    /// Retrieves the current encounter state for an Event Brain actor. Returns
    /// <br/>null encounter data if the actor is not managing an encounter.
    /// </remarks>

    /// <returns>Encounter state retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetEncounterResponse>> GetEncounterAsync(GetEncounterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class ActorController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IActorService _implementation;
    private BeyondImmersion.BannouService.Services.ITelemetryProvider _telemetryProvider;

    public ActorController(IActorService implementation, BeyondImmersion.BannouService.Services.ITelemetryProvider telemetryProvider)
    {
        _implementation = implementation;
        _telemetryProvider = telemetryProvider;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Create an actor template (category definition)
    /// </summary>
    /// <returns>Template created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> CreateActorTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.CreateActorTemplate",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/template/create");
        try
        {

            var (statusCode, result) = await _implementation.CreateActorTemplateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/template/create");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/template/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "CreateActorTemplate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/template/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get an actor template by ID or category
    /// </summary>
    /// <returns>Template retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> GetActorTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.GetActorTemplate",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/template/get");
        try
        {

            var (statusCode, result) = await _implementation.GetActorTemplateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/template/get");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/template/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "GetActorTemplate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/template/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List all actor templates
    /// </summary>
    /// <returns>Templates listed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListActorTemplatesResponse>> ListActorTemplates([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListActorTemplatesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.ListActorTemplates",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/template/list");
        try
        {

            var (statusCode, result) = await _implementation.ListActorTemplatesAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/template/list");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/template/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "ListActorTemplates",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/template/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update an actor template
    /// </summary>
    /// <returns>Template updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> UpdateActorTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.UpdateActorTemplate",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/template/update");
        try
        {

            var (statusCode, result) = await _implementation.UpdateActorTemplateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/template/update");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/template/update");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "UpdateActorTemplate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/template/update",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Delete an actor template
    /// </summary>
    /// <returns>Template deleted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteActorTemplateResponse>> DeleteActorTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.DeleteActorTemplate",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/template/delete");
        try
        {

            var (statusCode, result) = await _implementation.DeleteActorTemplateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/template/delete");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/template/delete");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "DeleteActorTemplate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/template/delete",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Spawn a new actor from a template
    /// </summary>
    /// <returns>Actor spawned successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/spawn")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorInstanceResponse>> SpawnActor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SpawnActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.SpawnActor",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/spawn");
        try
        {

            var (statusCode, result) = await _implementation.SpawnActorAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/spawn");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/spawn");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "SpawnActor",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/spawn",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get actor instance (instantiate-on-access if template allows)
    /// </summary>
    /// <remarks>
    /// If the actor exists, returns its current state.
    /// <br/>If the actor doesn't exist but a matching template has auto-spawn enabled,
    /// <br/>instantiates the actor and returns it.
    /// </remarks>
    /// <returns>Actor retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorInstanceResponse>> GetActor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.GetActor",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/get");
        try
        {

            var (statusCode, result) = await _implementation.GetActorAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/get");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "GetActor",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Stop a running actor
    /// </summary>
    /// <returns>Actor stopped successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/stop")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<StopActorResponse>> StopActor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] StopActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.StopActor",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/stop");
        try
        {

            var (statusCode, result) = await _implementation.StopActorAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/stop");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/stop");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "StopActor",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/stop",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Bind an unbound actor to a character
    /// </summary>
    /// <remarks>
    /// Transitions an unbound (event-mode) actor to a bound (character-mode) actor.
    /// <br/>After binding, the actor receives character perception events and variable
    /// <br/>providers begin loading character-specific data on subsequent ticks.
    /// <br/>Fails if the actor is already bound to a character.
    /// </remarks>
    /// <returns>Actor bound to character successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/bind-character")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorInstanceResponse>> BindActorCharacter([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BindActorCharacterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.BindActorCharacter",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/bind-character");
        try
        {

            var (statusCode, result) = await _implementation.BindActorCharacterAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/bind-character");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/bind-character");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "BindActorCharacter",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/bind-character",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Cleanup actors referencing a deleted character
    /// </summary>
    /// <remarks>
    /// Called by lib-resource cleanup coordination when a character is deleted.
    /// <br/>Stops and removes all actors that reference the specified characterId.
    /// <br/>This endpoint is designed for internal service-to-service calls during
    /// <br/>cascading resource cleanup.
    /// </remarks>
    /// <returns>Cleanup completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/cleanup-by-character")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupByCharacterResponse>> CleanupByCharacter([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CleanupByCharacterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.CleanupByCharacter",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/cleanup-by-character");
        try
        {

            var (statusCode, result) = await _implementation.CleanupByCharacterAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/cleanup-by-character");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/cleanup-by-character");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "CleanupByCharacter",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/cleanup-by-character",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List actors with optional filters
    /// </summary>
    /// <returns>Actors listed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListActorsResponse>> ListActors([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListActorsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.ListActors",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/list");
        try
        {

            var (statusCode, result) = await _implementation.ListActorsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/list");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "ListActors",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Inject a perception event into an actor's queue (testing)
    /// </summary>
    /// <remarks>
    /// Injects a perception event directly into the actor's perception queue
    /// <br/>for testing purposes. Useful for testing actor behavior without a
    /// <br/>full game server setup.
    /// </remarks>
    /// <returns>Perception injected successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/inject-perception")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InjectPerceptionResponse>> InjectPerception([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] InjectPerceptionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.InjectPerception",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/inject-perception");
        try
        {

            var (statusCode, result) = await _implementation.InjectPerceptionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/inject-perception");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/inject-perception");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "InjectPerception",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/inject-perception",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Query an actor for its available options
    /// </summary>
    /// <remarks>
    /// Query an actor for its available options (combat, dialogue, exploration, etc.).
    /// <br/>Options are maintained by the actor in its state and returned based on requested
    /// <br/>freshness level. This enables Event Brain actors to ask participants "what can
    /// <br/>you do?" for choreography and coordination.
    /// <br/>
    /// <br/>Freshness levels:
    /// <br/>- fresh: Inject context and wait for actor to recompute options
    /// <br/>- cached: Return cached options if within maxAgeMs, else recompute
    /// <br/>- stale_ok: Return cached options regardless of age
    /// </remarks>
    /// <returns>Options retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/query-options")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryOptionsResponse>> QueryOptions([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryOptionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.QueryOptions",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/query-options");
        try
        {

            var (statusCode, result) = await _implementation.QueryOptionsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/query-options");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/query-options");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "QueryOptions",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/query-options",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Start an encounter managed by an Event Brain actor
    /// </summary>
    /// <remarks>
    /// Initializes an encounter with the specified participants. The Event Brain actor
    /// <br/>will coordinate the encounter, sending instructions to participant NPC Brain actors
    /// <br/>via their character perception channels.
    /// </remarks>
    /// <returns>Encounter started successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/encounter/start")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> StartEncounter([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] StartEncounterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.StartEncounter",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/encounter/start");
        try
        {

            var statusCode = await _implementation.StartEncounterAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/encounter/start");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/encounter/start");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "StartEncounter",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/encounter/start",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update the phase of an active encounter
    /// </summary>
    /// <remarks>
    /// Updates the phase of an encounter being managed by an Event Brain actor.
    /// <br/>Phase changes are logged and can trigger behavior changes in participant actors.
    /// </remarks>
    /// <returns>Encounter phase updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/encounter/update-phase")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateEncounterPhaseResponse>> UpdateEncounterPhase([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateEncounterPhaseRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.UpdateEncounterPhase",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/encounter/update-phase");
        try
        {

            var (statusCode, result) = await _implementation.UpdateEncounterPhaseAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/encounter/update-phase");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/encounter/update-phase");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "UpdateEncounterPhase",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/encounter/update-phase",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// End an active encounter
    /// </summary>
    /// <remarks>
    /// Ends an encounter being managed by an Event Brain actor. This clears the
    /// <br/>encounter state and allows the actor to manage a new encounter.
    /// </remarks>
    /// <returns>Encounter ended successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/encounter/end")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EndEncounterResponse>> EndEncounter([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] EndEncounterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.EndEncounter",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/encounter/end");
        try
        {

            var (statusCode, result) = await _implementation.EndEncounterAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/encounter/end");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/encounter/end");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "EndEncounter",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/encounter/end",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get the current encounter state for an actor
    /// </summary>
    /// <remarks>
    /// Retrieves the current encounter state for an Event Brain actor. Returns
    /// <br/>null encounter data if the actor is not managing an encounter.
    /// </remarks>
    /// <returns>Encounter state retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/encounter/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetEncounterResponse>> GetEncounter([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetEncounterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.actor",
            "ActorController.GetEncounter",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "actor/encounter/get");
        try
        {

            var (statusCode, result) = await _implementation.GetEncounterAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:actor/encounter/get");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<ActorController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:actor/encounter/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "actor",
                "GetEncounter",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:actor/encounter/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765