//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Actor;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IActorController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Create an actor template (category definition)
    /// </summary>


    /// <returns>Template created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> CreateActorTemplateAsync(CreateActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get an actor template by ID or category
    /// </summary>


    /// <returns>Template retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> GetActorTemplateAsync(GetActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all actor templates
    /// </summary>


    /// <returns>Templates listed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListActorTemplatesResponse>> ListActorTemplatesAsync(ListActorTemplatesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update an actor template
    /// </summary>


    /// <returns>Template updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> UpdateActorTemplateAsync(UpdateActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete an actor template
    /// </summary>


    /// <returns>Template deleted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteActorTemplateResponse>> DeleteActorTemplateAsync(DeleteActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Spawn a new actor from a template
    /// </summary>


    /// <returns>Actor spawned successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorInstanceResponse>> SpawnActorAsync(SpawnActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get actor instance (instantiate-on-access if template allows)
    /// </summary>

    /// <remarks>
    /// If the actor exists, returns its current state.
    /// <br/>If the actor doesn't exist but a matching template has auto-spawn enabled,
    /// <br/>instantiates the actor and returns it.
    /// </remarks>

    /// <returns>Actor retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorInstanceResponse>> GetActorAsync(GetActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Stop a running actor
    /// </summary>


    /// <returns>Actor stopped successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<StopActorResponse>> StopActorAsync(StopActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List actors with optional filters
    /// </summary>


    /// <returns>Actors listed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListActorsResponse>> ListActorsAsync(ListActorsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Inject a perception event into an actor's queue (testing)
    /// </summary>

    /// <remarks>
    /// Injects a perception event directly into the actor's perception queue
    /// <br/>for testing purposes. Useful for testing actor behavior without a
    /// <br/>full game server setup.
    /// </remarks>

    /// <returns>Perception injected successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InjectPerceptionResponse>> InjectPerceptionAsync(InjectPerceptionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Query an actor for its available options
    /// </summary>

    /// <remarks>
    /// Query an actor for its available options (combat, dialogue, exploration, etc.).
    /// <br/>Options are maintained by the actor in its state and returned based on requested
    /// <br/>freshness level. This enables Event Brain actors to ask participants "what can
    /// <br/>you do?" for choreography and coordination.
    /// <br/>
    /// <br/>Freshness levels:
    /// <br/>- fresh: Inject context and wait for actor to recompute options
    /// <br/>- cached: Return cached options if within maxAgeMs, else recompute
    /// <br/>- stale_ok: Return cached options regardless of age
    /// </remarks>

    /// <returns>Options retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryOptionsResponse>> QueryOptionsAsync(QueryOptionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class ActorController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IActorService _implementation;

    public ActorController(IActorService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Create an actor template (category definition)
    /// </summary>
    /// <returns>Template created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> CreateActorTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateActorTemplateAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get an actor template by ID or category
    /// </summary>
    /// <returns>Template retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> GetActorTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetActorTemplateAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List all actor templates
    /// </summary>
    /// <returns>Templates listed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListActorTemplatesResponse>> ListActorTemplates([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListActorTemplatesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListActorTemplatesAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Update an actor template
    /// </summary>
    /// <returns>Template updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> UpdateActorTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateActorTemplateAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Delete an actor template
    /// </summary>
    /// <returns>Template deleted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteActorTemplateResponse>> DeleteActorTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DeleteActorTemplateAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Spawn a new actor from a template
    /// </summary>
    /// <returns>Actor spawned successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/spawn")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorInstanceResponse>> SpawnActor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SpawnActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.SpawnActorAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get actor instance (instantiate-on-access if template allows)
    /// </summary>
    /// <remarks>
    /// If the actor exists, returns its current state.
    /// <br/>If the actor doesn't exist but a matching template has auto-spawn enabled,
    /// <br/>instantiates the actor and returns it.
    /// </remarks>
    /// <returns>Actor retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorInstanceResponse>> GetActor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetActorAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Stop a running actor
    /// </summary>
    /// <returns>Actor stopped successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/stop")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<StopActorResponse>> StopActor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] StopActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.StopActorAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List actors with optional filters
    /// </summary>
    /// <returns>Actors listed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListActorsResponse>> ListActors([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListActorsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListActorsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Inject a perception event into an actor's queue (testing)
    /// </summary>
    /// <remarks>
    /// Injects a perception event directly into the actor's perception queue
    /// <br/>for testing purposes. Useful for testing actor behavior without a
    /// <br/>full game server setup.
    /// </remarks>
    /// <returns>Perception injected successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/inject-perception")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InjectPerceptionResponse>> InjectPerception([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] InjectPerceptionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.InjectPerceptionAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Query an actor for its available options
    /// </summary>
    /// <remarks>
    /// Query an actor for its available options (combat, dialogue, exploration, etc.).
    /// <br/>Options are maintained by the actor in its state and returned based on requested
    /// <br/>freshness level. This enables Event Brain actors to ask participants "what can
    /// <br/>you do?" for choreography and coordination.
    /// <br/>
    /// <br/>Freshness levels:
    /// <br/>- fresh: Inject context and wait for actor to recompute options
    /// <br/>- cached: Return cached options if within maxAgeMs, else recompute
    /// <br/>- stale_ok: Return cached options regardless of age
    /// </remarks>
    /// <returns>Options retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/query-options")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryOptionsResponse>> QueryOptions([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryOptionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.QueryOptionsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }



    #region Meta Endpoints for CreateActorTemplate

    private static readonly string _CreateActorTemplate_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateActorTemplateRequest",
    "$defs": {
        "CreateActorTemplateRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to create a new actor template definition",
            "required": [
                "category",
                "behaviorRef"
            ],
            "properties": {
                "category": {
                    "type": "string",
                    "description": "Category identifier (e.g., \"npc-brain\", \"world-admin\", \"cron-cleanup\")"
                },
                "behaviorRef": {
                    "type": "string",
                    "description": "Reference to behavior in lib-assets (e.g., \"asset://behaviors/npc-brain-v1\")"
                },
                "configuration": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Default configuration passed to behavior execution"
                },
                "autoSpawn": {
                    "description": "Auto-spawn configuration for instantiate-on-access",
                    "nullable": true,
                    "$ref": "#/$defs/AutoSpawnConfig"
                },
                "tickIntervalMs": {
                    "type": "integer",
                    "default": 1000,
                    "description": "Milliseconds between behavior loop iterations"
                },
                "autoSaveIntervalSeconds": {
                    "type": "integer",
                    "default": 60,
                    "description": "Seconds between automatic state saves (0 to disable)"
                },
                "maxInstancesPerNode": {
                    "type": "integer",
                    "default": 100,
                    "description": "Maximum actors of this category per pool node"
                }
            }
        },
        "AutoSpawnConfig": {
            "type": "object",
            "additionalProperties": false,
            "description": "Configuration for instantiate-on-access behavior",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, accessing a non-existent actor creates it"
                },
                "idPattern": {
                    "type": "string",
                    "nullable": true,
                    "description": "Regex pattern for actor IDs that trigger auto-spawn.\nExamples: \"npc-.*\" matches \"npc-grok\", \"npc-merchant-123\"\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum auto-spawned instances (0 = unlimited)"
                },
                "characterIdCaptureGroup": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "1-based regex capture group index for extracting CharacterId from actor ID.\nExample: With idPattern \"npc-brain-([a-f0-9-]+)\" and characterIdCaptureGroup: 1,\nactor ID \"npc-brain-abc-123-def\" extracts \"abc-123-def\" as CharacterId (parsed as GUID).\n"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateActorTemplate_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ActorTemplateResponse",
    "$defs": {
        "ActorTemplateResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing actor template details",
            "required": [
                "templateId",
                "category",
                "behaviorRef",
                "tickIntervalMs",
                "autoSaveIntervalSeconds",
                "maxInstancesPerNode",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique template identifier"
                },
                "category": {
                    "type": "string",
                    "description": "Category identifier"
                },
                "behaviorRef": {
                    "type": "string",
                    "description": "Reference to behavior in lib-assets"
                },
                "configuration": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Default configuration passed to behavior execution"
                },
                "autoSpawn": {
                    "description": "Auto-spawn configuration for instantiate-on-access",
                    "nullable": true,
                    "$ref": "#/$defs/AutoSpawnConfig"
                },
                "tickIntervalMs": {
                    "type": "integer",
                    "description": "Milliseconds between behavior loop iterations"
                },
                "autoSaveIntervalSeconds": {
                    "type": "integer",
                    "description": "Seconds between automatic state saves"
                },
                "maxInstancesPerNode": {
                    "type": "integer",
                    "description": "Maximum actors of this category per pool node"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was last updated"
                }
            }
        },
        "AutoSpawnConfig": {
            "type": "object",
            "additionalProperties": false,
            "description": "Configuration for instantiate-on-access behavior",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, accessing a non-existent actor creates it"
                },
                "idPattern": {
                    "type": "string",
                    "nullable": true,
                    "description": "Regex pattern for actor IDs that trigger auto-spawn.\nExamples: \"npc-.*\" matches \"npc-grok\", \"npc-merchant-123\"\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum auto-spawned instances (0 = unlimited)"
                },
                "characterIdCaptureGroup": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "1-based regex capture group index for extracting CharacterId from actor ID.\nExample: With idPattern \"npc-brain-([a-f0-9-]+)\" and characterIdCaptureGroup: 1,\nactor ID \"npc-brain-abc-123-def\" extracts \"abc-123-def\" as CharacterId (parsed as GUID).\n"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateActorTemplate_Info = """
{
    "summary": "Create an actor template (category definition)",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "CreateActorTemplate"
}
""";

    /// <summary>Returns endpoint information for CreateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateActorTemplate_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "Post",
            "actor/template/create",
            _CreateActorTemplate_Info));

    /// <summary>Returns request schema for CreateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateActorTemplate_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/template/create",
            "request-schema",
            _CreateActorTemplate_RequestSchema));

    /// <summary>Returns response schema for CreateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateActorTemplate_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/template/create",
            "response-schema",
            _CreateActorTemplate_ResponseSchema));

    /// <summary>Returns full schema for CreateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateActorTemplate_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "Post",
            "actor/template/create",
            _CreateActorTemplate_Info,
            _CreateActorTemplate_RequestSchema,
            _CreateActorTemplate_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetActorTemplate

    private static readonly string _GetActorTemplate_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetActorTemplateRequest",
    "$defs": {
        "GetActorTemplateRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to get an actor template by ID or category",
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Template ID to retrieve"
                },
                "category": {
                    "type": "string",
                    "nullable": true,
                    "description": "Or retrieve by category name"
                }
            }
        }
    }
}
""";

    private static readonly string _GetActorTemplate_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ActorTemplateResponse",
    "$defs": {
        "ActorTemplateResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing actor template details",
            "required": [
                "templateId",
                "category",
                "behaviorRef",
                "tickIntervalMs",
                "autoSaveIntervalSeconds",
                "maxInstancesPerNode",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique template identifier"
                },
                "category": {
                    "type": "string",
                    "description": "Category identifier"
                },
                "behaviorRef": {
                    "type": "string",
                    "description": "Reference to behavior in lib-assets"
                },
                "configuration": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Default configuration passed to behavior execution"
                },
                "autoSpawn": {
                    "description": "Auto-spawn configuration for instantiate-on-access",
                    "nullable": true,
                    "$ref": "#/$defs/AutoSpawnConfig"
                },
                "tickIntervalMs": {
                    "type": "integer",
                    "description": "Milliseconds between behavior loop iterations"
                },
                "autoSaveIntervalSeconds": {
                    "type": "integer",
                    "description": "Seconds between automatic state saves"
                },
                "maxInstancesPerNode": {
                    "type": "integer",
                    "description": "Maximum actors of this category per pool node"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was last updated"
                }
            }
        },
        "AutoSpawnConfig": {
            "type": "object",
            "additionalProperties": false,
            "description": "Configuration for instantiate-on-access behavior",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, accessing a non-existent actor creates it"
                },
                "idPattern": {
                    "type": "string",
                    "nullable": true,
                    "description": "Regex pattern for actor IDs that trigger auto-spawn.\nExamples: \"npc-.*\" matches \"npc-grok\", \"npc-merchant-123\"\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum auto-spawned instances (0 = unlimited)"
                },
                "characterIdCaptureGroup": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "1-based regex capture group index for extracting CharacterId from actor ID.\nExample: With idPattern \"npc-brain-([a-f0-9-]+)\" and characterIdCaptureGroup: 1,\nactor ID \"npc-brain-abc-123-def\" extracts \"abc-123-def\" as CharacterId (parsed as GUID).\n"
                }
            }
        }
    }
}
""";

    private static readonly string _GetActorTemplate_Info = """
{
    "summary": "Get an actor template by ID or category",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "GetActorTemplate"
}
""";

    /// <summary>Returns endpoint information for GetActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActorTemplate_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "Post",
            "actor/template/get",
            _GetActorTemplate_Info));

    /// <summary>Returns request schema for GetActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActorTemplate_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/template/get",
            "request-schema",
            _GetActorTemplate_RequestSchema));

    /// <summary>Returns response schema for GetActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActorTemplate_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/template/get",
            "response-schema",
            _GetActorTemplate_ResponseSchema));

    /// <summary>Returns full schema for GetActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActorTemplate_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "Post",
            "actor/template/get",
            _GetActorTemplate_Info,
            _GetActorTemplate_RequestSchema,
            _GetActorTemplate_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListActorTemplates

    private static readonly string _ListActorTemplates_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListActorTemplatesRequest",
    "$defs": {
        "ListActorTemplatesRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to list actor templates with pagination",
            "properties": {
                "limit": {
                    "type": "integer",
                    "default": 100,
                    "description": "Maximum number of templates to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Number of templates to skip"
                }
            }
        }
    }
}
""";

    private static readonly string _ListActorTemplates_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListActorTemplatesResponse",
    "$defs": {
        "ListActorTemplatesResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing a list of actor templates",
            "required": [
                "templates",
                "total"
            ],
            "properties": {
                "templates": {
                    "type": "array",
                    "description": "List of actor templates",
                    "items": {
                        "$ref": "#/$defs/ActorTemplateResponse"
                    }
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of templates available"
                }
            }
        },
        "ActorTemplateResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing actor template details",
            "required": [
                "templateId",
                "category",
                "behaviorRef",
                "tickIntervalMs",
                "autoSaveIntervalSeconds",
                "maxInstancesPerNode",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique template identifier"
                },
                "category": {
                    "type": "string",
                    "description": "Category identifier"
                },
                "behaviorRef": {
                    "type": "string",
                    "description": "Reference to behavior in lib-assets"
                },
                "configuration": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Default configuration passed to behavior execution"
                },
                "autoSpawn": {
                    "description": "Auto-spawn configuration for instantiate-on-access",
                    "nullable": true,
                    "$ref": "#/$defs/AutoSpawnConfig"
                },
                "tickIntervalMs": {
                    "type": "integer",
                    "description": "Milliseconds between behavior loop iterations"
                },
                "autoSaveIntervalSeconds": {
                    "type": "integer",
                    "description": "Seconds between automatic state saves"
                },
                "maxInstancesPerNode": {
                    "type": "integer",
                    "description": "Maximum actors of this category per pool node"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was last updated"
                }
            }
        },
        "AutoSpawnConfig": {
            "type": "object",
            "additionalProperties": false,
            "description": "Configuration for instantiate-on-access behavior",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, accessing a non-existent actor creates it"
                },
                "idPattern": {
                    "type": "string",
                    "nullable": true,
                    "description": "Regex pattern for actor IDs that trigger auto-spawn.\nExamples: \"npc-.*\" matches \"npc-grok\", \"npc-merchant-123\"\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum auto-spawned instances (0 = unlimited)"
                },
                "characterIdCaptureGroup": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "1-based regex capture group index for extracting CharacterId from actor ID.\nExample: With idPattern \"npc-brain-([a-f0-9-]+)\" and characterIdCaptureGroup: 1,\nactor ID \"npc-brain-abc-123-def\" extracts \"abc-123-def\" as CharacterId (parsed as GUID).\n"
                }
            }
        }
    }
}
""";

    private static readonly string _ListActorTemplates_Info = """
{
    "summary": "List all actor templates",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "ListActorTemplates"
}
""";

    /// <summary>Returns endpoint information for ListActorTemplates</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActorTemplates_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "Post",
            "actor/template/list",
            _ListActorTemplates_Info));

    /// <summary>Returns request schema for ListActorTemplates</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActorTemplates_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/template/list",
            "request-schema",
            _ListActorTemplates_RequestSchema));

    /// <summary>Returns response schema for ListActorTemplates</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActorTemplates_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/template/list",
            "response-schema",
            _ListActorTemplates_ResponseSchema));

    /// <summary>Returns full schema for ListActorTemplates</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActorTemplates_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "Post",
            "actor/template/list",
            _ListActorTemplates_Info,
            _ListActorTemplates_RequestSchema,
            _ListActorTemplates_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateActorTemplate

    private static readonly string _UpdateActorTemplate_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateActorTemplateRequest",
    "$defs": {
        "UpdateActorTemplateRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to update an existing actor template",
            "required": [
                "templateId"
            ],
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the template to update"
                },
                "behaviorRef": {
                    "type": "string",
                    "nullable": true,
                    "description": "New behavior reference (triggers behavior.updated subscription)"
                },
                "configuration": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Updated configuration settings"
                },
                "autoSpawn": {
                    "description": "Updated auto-spawn configuration",
                    "nullable": true,
                    "$ref": "#/$defs/AutoSpawnConfig"
                },
                "tickIntervalMs": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Updated tick interval in milliseconds"
                },
                "autoSaveIntervalSeconds": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Updated auto-save interval in seconds"
                }
            }
        },
        "AutoSpawnConfig": {
            "type": "object",
            "additionalProperties": false,
            "description": "Configuration for instantiate-on-access behavior",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, accessing a non-existent actor creates it"
                },
                "idPattern": {
                    "type": "string",
                    "nullable": true,
                    "description": "Regex pattern for actor IDs that trigger auto-spawn.\nExamples: \"npc-.*\" matches \"npc-grok\", \"npc-merchant-123\"\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum auto-spawned instances (0 = unlimited)"
                },
                "characterIdCaptureGroup": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "1-based regex capture group index for extracting CharacterId from actor ID.\nExample: With idPattern \"npc-brain-([a-f0-9-]+)\" and characterIdCaptureGroup: 1,\nactor ID \"npc-brain-abc-123-def\" extracts \"abc-123-def\" as CharacterId (parsed as GUID).\n"
                }
            }
        }
    }
}
""";

    private static readonly string _UpdateActorTemplate_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ActorTemplateResponse",
    "$defs": {
        "ActorTemplateResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing actor template details",
            "required": [
                "templateId",
                "category",
                "behaviorRef",
                "tickIntervalMs",
                "autoSaveIntervalSeconds",
                "maxInstancesPerNode",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique template identifier"
                },
                "category": {
                    "type": "string",
                    "description": "Category identifier"
                },
                "behaviorRef": {
                    "type": "string",
                    "description": "Reference to behavior in lib-assets"
                },
                "configuration": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Default configuration passed to behavior execution"
                },
                "autoSpawn": {
                    "description": "Auto-spawn configuration for instantiate-on-access",
                    "nullable": true,
                    "$ref": "#/$defs/AutoSpawnConfig"
                },
                "tickIntervalMs": {
                    "type": "integer",
                    "description": "Milliseconds between behavior loop iterations"
                },
                "autoSaveIntervalSeconds": {
                    "type": "integer",
                    "description": "Seconds between automatic state saves"
                },
                "maxInstancesPerNode": {
                    "type": "integer",
                    "description": "Maximum actors of this category per pool node"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was last updated"
                }
            }
        },
        "AutoSpawnConfig": {
            "type": "object",
            "additionalProperties": false,
            "description": "Configuration for instantiate-on-access behavior",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, accessing a non-existent actor creates it"
                },
                "idPattern": {
                    "type": "string",
                    "nullable": true,
                    "description": "Regex pattern for actor IDs that trigger auto-spawn.\nExamples: \"npc-.*\" matches \"npc-grok\", \"npc-merchant-123\"\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum auto-spawned instances (0 = unlimited)"
                },
                "characterIdCaptureGroup": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "1-based regex capture group index for extracting CharacterId from actor ID.\nExample: With idPattern \"npc-brain-([a-f0-9-]+)\" and characterIdCaptureGroup: 1,\nactor ID \"npc-brain-abc-123-def\" extracts \"abc-123-def\" as CharacterId (parsed as GUID).\n"
                }
            }
        }
    }
}
""";

    private static readonly string _UpdateActorTemplate_Info = """
{
    "summary": "Update an actor template",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "UpdateActorTemplate"
}
""";

    /// <summary>Returns endpoint information for UpdateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateActorTemplate_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "Post",
            "actor/template/update",
            _UpdateActorTemplate_Info));

    /// <summary>Returns request schema for UpdateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateActorTemplate_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/template/update",
            "request-schema",
            _UpdateActorTemplate_RequestSchema));

    /// <summary>Returns response schema for UpdateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateActorTemplate_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/template/update",
            "response-schema",
            _UpdateActorTemplate_ResponseSchema));

    /// <summary>Returns full schema for UpdateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateActorTemplate_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "Post",
            "actor/template/update",
            _UpdateActorTemplate_Info,
            _UpdateActorTemplate_RequestSchema,
            _UpdateActorTemplate_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeleteActorTemplate

    private static readonly string _DeleteActorTemplate_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteActorTemplateRequest",
    "$defs": {
        "DeleteActorTemplateRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to delete an actor template",
            "required": [
                "templateId"
            ],
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the template to delete"
                },
                "forceStopActors": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, stops all running actors using this template"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteActorTemplate_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteActorTemplateResponse",
    "$defs": {
        "DeleteActorTemplateResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response confirming template deletion",
            "required": [
                "deleted",
                "stoppedActorCount"
            ],
            "properties": {
                "deleted": {
                    "type": "boolean",
                    "description": "Whether the template was successfully deleted"
                },
                "stoppedActorCount": {
                    "type": "integer",
                    "description": "Number of running actors that were stopped"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteActorTemplate_Info = """
{
    "summary": "Delete an actor template",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "DeleteActorTemplate"
}
""";

    /// <summary>Returns endpoint information for DeleteActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteActorTemplate_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "Post",
            "actor/template/delete",
            _DeleteActorTemplate_Info));

    /// <summary>Returns request schema for DeleteActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteActorTemplate_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/template/delete",
            "request-schema",
            _DeleteActorTemplate_RequestSchema));

    /// <summary>Returns response schema for DeleteActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteActorTemplate_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/template/delete",
            "response-schema",
            _DeleteActorTemplate_ResponseSchema));

    /// <summary>Returns full schema for DeleteActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/template/delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteActorTemplate_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "Post",
            "actor/template/delete",
            _DeleteActorTemplate_Info,
            _DeleteActorTemplate_RequestSchema,
            _DeleteActorTemplate_ResponseSchema));

    #endregion

    #region Meta Endpoints for SpawnActor

    private static readonly string _SpawnActor_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/SpawnActorRequest",
    "$defs": {
        "SpawnActorRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to spawn a new actor from a template",
            "required": [
                "templateId"
            ],
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Template to instantiate from"
                },
                "actorId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional custom actor ID (auto-generated if not provided)"
                },
                "configurationOverrides": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Override template defaults"
                },
                "initialState": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Initial state passed to behavior"
                },
                "characterId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Optional character ID for NPC brain actors"
                }
            }
        }
    }
}
""";

    private static readonly string _SpawnActor_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ActorInstanceResponse",
    "$defs": {
        "ActorInstanceResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing actor instance details",
            "required": [
                "actorId",
                "templateId",
                "category",
                "status",
                "startedAt",
                "loopIterations"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "Unique actor identifier"
                },
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Template this actor was instantiated from"
                },
                "category": {
                    "type": "string",
                    "description": "Actor category from template"
                },
                "nodeId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Pool node running this actor (null in bannou mode)"
                },
                "nodeAppId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Pool node's app-id for direct messaging"
                },
                "status": {
                    "description": "Current actor lifecycle state",
                    "$ref": "#/$defs/ActorStatus"
                },
                "characterId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Associated character ID (for NPC brains)"
                },
                "startedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the actor started running"
                },
                "lastHeartbeat": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "Last heartbeat timestamp from the actor"
                },
                "loopIterations": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Number of behavior loop iterations executed"
                }
            }
        },
        "ActorStatus": {
            "type": "string",
            "enum": [
                "pending",
                "starting",
                "running",
                "paused",
                "stopping",
                "stopped",
                "error"
            ],
            "description": "Current actor lifecycle state"
        }
    }
}
""";

    private static readonly string _SpawnActor_Info = """
{
    "summary": "Spawn a new actor from a template",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "SpawnActor"
}
""";

    /// <summary>Returns endpoint information for SpawnActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/spawn/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SpawnActor_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "Post",
            "actor/spawn",
            _SpawnActor_Info));

    /// <summary>Returns request schema for SpawnActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/spawn/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SpawnActor_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/spawn",
            "request-schema",
            _SpawnActor_RequestSchema));

    /// <summary>Returns response schema for SpawnActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/spawn/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SpawnActor_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/spawn",
            "response-schema",
            _SpawnActor_ResponseSchema));

    /// <summary>Returns full schema for SpawnActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/spawn/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SpawnActor_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "Post",
            "actor/spawn",
            _SpawnActor_Info,
            _SpawnActor_RequestSchema,
            _SpawnActor_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetActor

    private static readonly string _GetActor_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetActorRequest",
    "$defs": {
        "GetActorRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to get an actor instance by ID",
            "required": [
                "actorId"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "Actor ID to retrieve"
                }
            }
        }
    }
}
""";

    private static readonly string _GetActor_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ActorInstanceResponse",
    "$defs": {
        "ActorInstanceResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing actor instance details",
            "required": [
                "actorId",
                "templateId",
                "category",
                "status",
                "startedAt",
                "loopIterations"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "Unique actor identifier"
                },
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Template this actor was instantiated from"
                },
                "category": {
                    "type": "string",
                    "description": "Actor category from template"
                },
                "nodeId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Pool node running this actor (null in bannou mode)"
                },
                "nodeAppId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Pool node's app-id for direct messaging"
                },
                "status": {
                    "description": "Current actor lifecycle state",
                    "$ref": "#/$defs/ActorStatus"
                },
                "characterId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Associated character ID (for NPC brains)"
                },
                "startedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the actor started running"
                },
                "lastHeartbeat": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "Last heartbeat timestamp from the actor"
                },
                "loopIterations": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Number of behavior loop iterations executed"
                }
            }
        },
        "ActorStatus": {
            "type": "string",
            "enum": [
                "pending",
                "starting",
                "running",
                "paused",
                "stopping",
                "stopped",
                "error"
            ],
            "description": "Current actor lifecycle state"
        }
    }
}
""";

    private static readonly string _GetActor_Info = """
{
    "summary": "Get actor instance (instantiate-on-access if template allows)",
    "description": "If the actor exists, returns its current state.\nIf the actor doesn't exist but a matching template has auto-spawn enabled,\ninstantiates the actor and returns it.\n",
    "tags": [],
    "deprecated": false,
    "operationId": "GetActor"
}
""";

    /// <summary>Returns endpoint information for GetActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActor_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "Post",
            "actor/get",
            _GetActor_Info));

    /// <summary>Returns request schema for GetActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActor_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/get",
            "request-schema",
            _GetActor_RequestSchema));

    /// <summary>Returns response schema for GetActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActor_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/get",
            "response-schema",
            _GetActor_ResponseSchema));

    /// <summary>Returns full schema for GetActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActor_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "Post",
            "actor/get",
            _GetActor_Info,
            _GetActor_RequestSchema,
            _GetActor_ResponseSchema));

    #endregion

    #region Meta Endpoints for StopActor

    private static readonly string _StopActor_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/StopActorRequest",
    "$defs": {
        "StopActorRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to stop a running actor",
            "required": [
                "actorId"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "ID of the actor to stop"
                },
                "graceful": {
                    "type": "boolean",
                    "default": true,
                    "description": "If true, allows behavior to complete current iteration"
                }
            }
        }
    }
}
""";

    private static readonly string _StopActor_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/StopActorResponse",
    "$defs": {
        "StopActorResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response confirming actor stop operation",
            "required": [
                "stopped",
                "finalStatus"
            ],
            "properties": {
                "stopped": {
                    "type": "boolean",
                    "description": "Whether the actor was successfully stopped"
                },
                "finalStatus": {
                    "description": "Final status of the actor after stopping",
                    "$ref": "#/$defs/ActorStatus"
                }
            }
        },
        "ActorStatus": {
            "type": "string",
            "enum": [
                "pending",
                "starting",
                "running",
                "paused",
                "stopping",
                "stopped",
                "error"
            ],
            "description": "Current actor lifecycle state"
        }
    }
}
""";

    private static readonly string _StopActor_Info = """
{
    "summary": "Stop a running actor",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "StopActor"
}
""";

    /// <summary>Returns endpoint information for StopActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/stop/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> StopActor_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "Post",
            "actor/stop",
            _StopActor_Info));

    /// <summary>Returns request schema for StopActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/stop/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> StopActor_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/stop",
            "request-schema",
            _StopActor_RequestSchema));

    /// <summary>Returns response schema for StopActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/stop/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> StopActor_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/stop",
            "response-schema",
            _StopActor_ResponseSchema));

    /// <summary>Returns full schema for StopActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/stop/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> StopActor_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "Post",
            "actor/stop",
            _StopActor_Info,
            _StopActor_RequestSchema,
            _StopActor_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListActors

    private static readonly string _ListActors_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListActorsRequest",
    "$defs": {
        "ListActorsRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to list actor instances with optional filters",
            "properties": {
                "category": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by category"
                },
                "nodeId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by pool node"
                },
                "status": {
                    "description": "Filter by actor status",
                    "$ref": "#/$defs/ActorStatus"
                },
                "characterId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Filter by associated character"
                },
                "limit": {
                    "type": "integer",
                    "default": 100,
                    "description": "Maximum number of actors to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Number of actors to skip"
                }
            }
        },
        "ActorStatus": {
            "type": "string",
            "enum": [
                "pending",
                "starting",
                "running",
                "paused",
                "stopping",
                "stopped",
                "error"
            ],
            "description": "Current actor lifecycle state"
        }
    }
}
""";

    private static readonly string _ListActors_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListActorsResponse",
    "$defs": {
        "ListActorsResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing a list of actor instances",
            "required": [
                "actors",
                "total"
            ],
            "properties": {
                "actors": {
                    "type": "array",
                    "description": "List of actor instances",
                    "items": {
                        "$ref": "#/$defs/ActorInstanceResponse"
                    }
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of actors matching the filter"
                }
            }
        },
        "ActorInstanceResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing actor instance details",
            "required": [
                "actorId",
                "templateId",
                "category",
                "status",
                "startedAt",
                "loopIterations"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "Unique actor identifier"
                },
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Template this actor was instantiated from"
                },
                "category": {
                    "type": "string",
                    "description": "Actor category from template"
                },
                "nodeId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Pool node running this actor (null in bannou mode)"
                },
                "nodeAppId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Pool node's app-id for direct messaging"
                },
                "status": {
                    "description": "Current actor lifecycle state",
                    "$ref": "#/$defs/ActorStatus"
                },
                "characterId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Associated character ID (for NPC brains)"
                },
                "startedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the actor started running"
                },
                "lastHeartbeat": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "Last heartbeat timestamp from the actor"
                },
                "loopIterations": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Number of behavior loop iterations executed"
                }
            }
        },
        "ActorStatus": {
            "type": "string",
            "enum": [
                "pending",
                "starting",
                "running",
                "paused",
                "stopping",
                "stopped",
                "error"
            ],
            "description": "Current actor lifecycle state"
        }
    }
}
""";

    private static readonly string _ListActors_Info = """
{
    "summary": "List actors with optional filters",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "ListActors"
}
""";

    /// <summary>Returns endpoint information for ListActors</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActors_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "Post",
            "actor/list",
            _ListActors_Info));

    /// <summary>Returns request schema for ListActors</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActors_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/list",
            "request-schema",
            _ListActors_RequestSchema));

    /// <summary>Returns response schema for ListActors</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActors_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/list",
            "response-schema",
            _ListActors_ResponseSchema));

    /// <summary>Returns full schema for ListActors</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActors_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "Post",
            "actor/list",
            _ListActors_Info,
            _ListActors_RequestSchema,
            _ListActors_ResponseSchema));

    #endregion

    #region Meta Endpoints for InjectPerception

    private static readonly string _InjectPerception_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/InjectPerceptionRequest",
    "$defs": {
        "InjectPerceptionRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to inject a perception event into an actor's queue",
            "required": [
                "actorId",
                "perception"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "Target actor to inject perception into"
                },
                "perception": {
                    "description": "Perception data to inject",
                    "$ref": "#/$defs/PerceptionData"
                }
            }
        },
        "PerceptionData": {
            "type": "object",
            "additionalProperties": false,
            "description": "Data representing a perception event for an actor.\n\nSpatial context can be provided in two ways (hybrid approach):\n1. Typed: Use the optional spatialContext field for structured spatial data\n2. Schema-less: Use perceptionType=\"spatial\" with data containing spatial info\n\nThe typed approach is recommended when game server has structured spatial data.\nThe schema-less approach allows flexibility for game-specific spatial formats.\n",
            "required": [
                "perceptionType",
                "sourceId"
            ],
            "properties": {
                "perceptionType": {
                    "type": "string",
                    "description": "Perception type. Common values: visual, auditory, tactile, olfactory,\nproprioceptive, spatial. Use \"spatial\" for schema-less spatial data in 'data' field.\n"
                },
                "sourceId": {
                    "type": "string",
                    "description": "ID of the entity causing this perception"
                },
                "sourceType": {
                    "type": "string",
                    "nullable": true,
                    "description": "Type of source (character, npc, object, environment)"
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Perception-specific data. For perceptionType=\"spatial\", this can contain\ngame-specific spatial context in any format the game server defines.\n"
                },
                "urgency": {
                    "type": "number",
                    "format": "float",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 0.5,
                    "description": "How urgent this perception is (0-1)"
                },
                "spatialContext": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/SpatialContext"
                        }
                    ],
                    "nullable": true,
                    "description": "Optional typed spatial context from game server's local spatial state.\nProvides structured information about terrain, nearby objects, hazards, etc.\nAlternative to using perceptionType=\"spatial\" with schema-less data.\n"
                }
            }
        },
        "SpatialContext": {
            "type": "object",
            "additionalProperties": true,
            "description": "Spatial context derived from game server's authoritative spatial state.\nIncluded in perception events to give NPC actors awareness of their environment\nwithout requiring direct map subscriptions.\ n\nNote: additionalProperties=true allows game-specific extensions.\n",
            "properties": {
                "terrainType": {
                    "type": "string",
                    "nullable": true,
                    "description": "Terrain type at character position (grass, stone, water, etc.)"
                },
                "elevation": {
                    "type": "number",
                    "format": "float",
                    "nullable": true,
                    "description": "Elevation at character position"
                },
                "nearbyObjects": {
                    "type": "array",
                    "nullable": true,
                    "description": "Objects within perception radius",
                    "items": {
                        "$ref": "#/$defs/NearbyObject"
                    }
                },
                "hazardsInRange": {
                    "type": "array",
                    "nullable": true,
                    "description": "Active hazards within detection range",
                    "items": {
                        "$ref": "#/$defs/HazardInfo"
                    }
                },
                "pathableDirections": {
                    "type": "array",
                    "nullable": true,
                    "description": "Directions the character can move (for navigation awareness)",
                    "items": {
                        "type": "string",
                        "description": "Cardinal or relative direction (north, south, east, west, forward, etc.)"
                    }
                },
                "coverNearby": {
                    "type": "boolean",
                    "nullable": true,
                    "description": "Whether cover is available within close range"
                },
                "indoors": {
                    "type": "boolean",
                    "nullable": true,
                    "description": "Whether character is currently indoors/under roof"
                }
            }
        },
        "NearbyObject": {
            "type": "object",
            "additionalProperties": true,
            "description": "Information about a nearby object perceived by the character",
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the object"
                },
                "objectType": {
                    "type": "string",
                    "description": "Type of object (boulder_cluster, tree, building, etc.)"
                },
                "distance": {
                    "type": "number",
                    "format": "float",
                    "description": "Distance from character in game units"
                },
                "direction": {
                    "type": "string",
                    "description": "Relative direction (north, south, east, west, above, below, etc.)"
                },
                "position": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/Position3D"
                        }
                    ],
                    "nullable": true,
                    "description": "Optional absolute position"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "additionalProperties": false,
            "description": "3D position in world coordinates",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "float",
                    "description": "X coordinate"
                },
                "y": {
                    "type": "number",
                    "format": "float",
                    "description": "Y coordinate (typically vertical)"
                },
                "z": {
                    "type": "number",
                    "format": "float",
                    "description": "Z coordinate"
                }
            }
        },
        "HazardInfo": {
            "type": "object",
            "additionalProperties": true,
            "description": "Information about a hazard in range",
            "properties": {
                "hazardType": {
                    "type": "string",
                    "description": "Type of hazard (fire, poison, radiation, deep_water, etc.)"
                },
                "distance": {
                    "type": "number",
                    "format": "float",
                    "description": "Distance to hazard edge"
                },
                "severity": {
                    "type": "number",
                    "format": "float",
                    "minimum": 0,
                    "maximum": 1,
                    "description": "Hazard severity (0-1)"
                },
                "direction": {
                    "type": "string",
                    "nullable": true,
                    "description": "Direction to hazard center"
                }
            }
        }
    }
}
""";

    private static readonly string _InjectPerception_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/InjectPerceptionResponse",
    "$defs": {
        "InjectPerceptionResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response confirming perception injection",
            "required": [
                "queued",
                "queueDepth"
            ],
            "properties": {
                "queued": {
                    "type": "boolean",
                    "description": "Whether the perception was successfully queued"
                },
                "queueDepth": {
                    "type": "integer",
                    "description": "Current depth of the perception queue"
                }
            }
        }
    }
}
""";

    private static readonly string _InjectPerception_Info = """
{
    "summary": "Inject a perception event into an actor's queue (testing)",
    "description": "Injects a perception event directly into the actor's perception queue\nfor testing purposes. Useful for testing actor behavior without a\nfull game server setup.\n",
    "tags": [],
    "deprecated": false,
    "operationId": "InjectPerception"
}
""";

    /// <summary>Returns endpoint information for InjectPerception</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/inject-perception/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> InjectPerception_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "Post",
            "actor/inject-perception",
            _InjectPerception_Info));

    /// <summary>Returns request schema for InjectPerception</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/inject-perception/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> InjectPerception_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/inject-perception",
            "request-schema",
            _InjectPerception_RequestSchema));

    /// <summary>Returns response schema for InjectPerception</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/inject-perception/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> InjectPerception_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/inject-perception",
            "response-schema",
            _InjectPerception_ResponseSchema));

    /// <summary>Returns full schema for InjectPerception</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/inject-perception/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> InjectPerception_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "Post",
            "actor/inject-perception",
            _InjectPerception_Info,
            _InjectPerception_RequestSchema,
            _InjectPerception_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryOptions

    private static readonly string _QueryOptions_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryOptionsRequest",
    "$defs": {
        "QueryOptionsRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Query an actor for its available options. Options are maintained by the actor\ nin its state.memories.{queryType}_options and returned based on requested freshness.\n",
            "required": [
                "actorId",
                "queryType"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "ID of the actor to query"
                },
                "queryType": {
                    "$ref": "#/$defs/OptionsQueryType",
                    "description": "Type of options to query"
                },
                "freshness": {
                    "$ref": "#/$defs/OptionsFreshness",
                    "description": "Requested freshness level. Defaults to 'cached'.\n- fresh: Inject context and wait for actor to recompute\n- cached: Return cached options if within maxAgeMs\n- stale_ok: Return whatever is cached, even if expired\n"
                },
                "maxAgeMs": {
                    "type": "integer",
                    "minimum": 0,
                    "maximum": 60000,
                    "nullable": true,
                    "description": "Maximum age of cached options in milliseconds (for 'cached' freshness).\nDefaults to 5000ms. If cached options are older, behavior depends on\nfreshness level.\n"
                },
                "context": {
                    "$ref": "#/$defs/OptionsQueryContext",
                    "nullable": true,
                    "description": "Optional context for the query. When provided with freshness='fresh',\nthis context is injected as a perception to the actor, triggering\ncontext-sensitive option recomputation.\n"
                }
            }
        },
        "OptionsQueryType": {
            "type": "string",
            "description": "Type of options to query. Actors maintain options in state.memories.{type}_options.\ nWell-known types are defined; actors can also expose custom types.\n",
            "enum": [
                "combat",
                "dialogue",
                "exploration",
                "social",
                "custom"
            ]
        },
        "OptionsFreshness": {
            "type": "string",
            "description": "Controls caching behavior for options queries",
            "enum": [
                "fresh",
                "cached",
                "stale_ok"
            ],
            "default": "cached"
        },
        "OptionsQueryContext": {
            "type": "object",
            "additionalProperties": true,
            "description": "Context provided with a fresh query. Injected as a perception to the actor\nto trigger context-sensitive option recomputation.\n",
            "properties": {
                "combatState": {
                    "type": "string",
                    "nullable": true,
                    "description": "Current combat state (approaching, engaged, retreating, etc.)"
                },
                "opponentIds": {
                    "type": "array",
                    "nullable": true,
                    "description": "IDs of opponents in the current encounter",
                    "items": {
                        "type": "string"
                    }
                },
                "allyIds": {
                    "type": "array",
                    "nullable": true,
                    "description": "IDs of allies in the current encounter",
                    "items": {
                        "type": "string"
                    }
                },
                "environmentTags": {
                    "type": "array",
                    "nullable": true,
                    "description": "Environment tags (indoor, elevated, destructibles, narrow, etc.)",
                    "items": {
                        "type": "string"
                    }
                },
                "urgency": {
                    "type": "number",
                    "format": "float",
                    "minimum": 0,
                    "maximum": 1,
                    "nullable": true,
                    "description": "How urgent is this query (affects option prioritization)"
                },
                "customContext": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Actor-specific context data"
                }
            }
        }
    }
}
""";

    private static readonly string _QueryOptions_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryOptionsResponse",
    "$defs": {
        "QueryOptionsResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing the actor's available options",
            "required": [
                "actorId",
                "queryType",
                "options",
                "computedAt",
                "ageMs"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "ID of the queried actor"
                },
                "queryType": {
                    "$ref": "#/$defs/OptionsQueryType",
                    "description": "Type of options returned"
                },
                "options": {
                    "type": "array",
                    "description": "Available options for the queried type",
                    "items": {
                        "$ref": "#/$defs/ActorOption"
                    }
                },
                "computedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When these options were last computed by the actor"
                },
                "ageMs": {
                    "type": "integer",
                    "description": "Age of options in milliseconds (now - computedAt)"
                },
                "characterContext": {
                    "$ref": "#/$defs/CharacterOptionContext",
                    "nullable": true,
                    "description": "Character-specific context that influenced these options.\nOnly present for character-based actors.\n"
                }
            }
        },
        "OptionsQueryType": {
            "type": "string",
            "description": "Type of options to query. Actors maintain options in state.memories.{type}_options.\nWell-known types are defined; actors can also expose custom types.\n",
            "enum": [
                "combat",
                "dialogue",
                "exploration",
                "social",
                "custom"
            ]
        },
        "ActorOption": {
            "type": "object",
            "additionalProperties": true,
            "description": "A single option available to the actor. The standardized fields enable\nEvent Brain to reason about options; additional fields allow actor-specific data.\n",
            "required": [
                "actionId",
                "preference",
                "available"
            ],
            "properties": {
                "actionId": {
                    "type": "string",
                    "description": "Unique identifier for this action within the option type.\nExamples: \"sword_slash\", \"greet_friendly\", \"climb_wall\"\n"
                },
                "preference": {
                    "type": "number",
                    "format": "float",
                    "minimum": 0,
                    "maximum": 1,
                    "description": "How much the actor prefers this option (0-1), based on personality,\ncombat preferences, current state, etc. Higher = more preferred.\n"
                },
                "risk": {
                    "type": "number",
                    "format": "float",
                    "minimum": 0,
                    "maximum": 1,
                    "nullable": true,
                    "description": "Estimated risk of this action (0=safe, 1=very risky)"
                },
                "available": {
                    "type": "boolean",
                    "description": "Whether this option is currently available (requirements met)"
                },
                "requirements": {
                    "type": "array",
                    "nullable": true,
                    "description": "Requirements that must be met for this option",
                    "items": {
                        "type": "string"
                    }
                },
                "cooldownMs": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Milliseconds until this option becomes available again (if on cooldown)"
                },
                "tags": {
                    "type": "array",
                    "nullable": true,
                    "description": "Tags for categorization (e.g., [\"melee\", \"aggressive\", \"loud\"])",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "CharacterOptionContext": {
            "type": "object",
            "additionalProperties": false,
            "description": "Character-specific context that influenced option computation",
            "properties": {
                "combatStyle": {
                    "type": "string",
                    "nullable": true,
                    "description": "Character's combat style (aggressive, defensive, balanced, etc.)"
                },
                "riskTolerance": {
                    "type": "number",
                    "format": "float",
                    "minimum": 0,
                    "maximum": 1,
                    "nullable": true,
                    "description": "Character's risk tolerance (0=cautious, 1=reckless)"
                },
                "protectAllies": {
                    "type": "boolean",
                    "nullable": true,
                    "description": "Whether character prioritizes ally protection"
                },
                "currentGoal": {
                    "type": "string",
                    "nullable": true,
                    "description": "Character's current primary goal"
                },
                "emotionalState": {
                    "type": "string",
                    "nullable": true,
                    "description": "Character's current dominant emotion"
                }
            }
        }
    }
}
""";

    private static readonly string _QueryOptions_Info = """
{
    "summary": "Query an actor for its available options",
    "description": "Query an actor for its available options (combat, dialogue, exploration, etc.).\nOptions are maintained by the actor in its state and returned based on requested\nfreshness level. This enables Event Brain actors to ask participants \"what can\nyou do?\" for choreography and coordination.\n\nFreshness levels:\n- fresh: Inject context and wait for actor to recompute options\n- cached: Return cached options if within maxAgeMs, else recompute\n- stale_ok: Return cached options regardless of age\n",
    "tags": [],
    "deprecated": false,
    "operationId": "QueryOptions"
}
""";

    /// <summary>Returns endpoint information for QueryOptions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/query-options/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryOptions_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "Post",
            "actor/query-options",
            _QueryOptions_Info));

    /// <summary>Returns request schema for QueryOptions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/query-options/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryOptions_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/query-options",
            "request-schema",
            _QueryOptions_RequestSchema));

    /// <summary>Returns response schema for QueryOptions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/query-options/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryOptions_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "Post",
            "actor/query-options",
            "response-schema",
            _QueryOptions_ResponseSchema));

    /// <summary>Returns full schema for QueryOptions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("actor/query-options/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryOptions_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "Post",
            "actor/query-options",
            _QueryOptions_Info,
            _QueryOptions_RequestSchema,
            _QueryOptions_ResponseSchema));

    #endregion

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
