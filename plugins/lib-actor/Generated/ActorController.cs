//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     RELATED FILES:
//     - Request/Response models: bannou-service/Generated/Models/{Service}Models.cs
//     - Event models: bannou-service/Generated/Events/{Service}EventsModels.cs
//     - Lifecycle events: bannou-service/Generated/Events/{Service}LifecycleEvents.cs
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Actor;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IActorController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Create an actor template (category definition)
    /// </summary>


    /// <returns>Template created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> CreateActorTemplateAsync(CreateActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get an actor template by ID or category
    /// </summary>


    /// <returns>Template retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> GetActorTemplateAsync(GetActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all actor templates
    /// </summary>


    /// <returns>Templates listed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListActorTemplatesResponse>> ListActorTemplatesAsync(ListActorTemplatesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update an actor template
    /// </summary>


    /// <returns>Template updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> UpdateActorTemplateAsync(UpdateActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete an actor template
    /// </summary>


    /// <returns>Template deleted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteActorTemplateResponse>> DeleteActorTemplateAsync(DeleteActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Spawn a new actor from a template
    /// </summary>


    /// <returns>Actor spawned successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorInstanceResponse>> SpawnActorAsync(SpawnActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get actor instance (instantiate-on-access if template allows)
    /// </summary>

    /// <remarks>
    /// If the actor exists, returns its current state.
    /// <br/>If the actor doesn't exist but a matching template has auto-spawn enabled,
    /// <br/>instantiates the actor and returns it.
    /// </remarks>

    /// <returns>Actor retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorInstanceResponse>> GetActorAsync(GetActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Stop a running actor
    /// </summary>


    /// <returns>Actor stopped successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<StopActorResponse>> StopActorAsync(StopActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List actors with optional filters
    /// </summary>


    /// <returns>Actors listed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListActorsResponse>> ListActorsAsync(ListActorsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Inject a perception event into an actor's queue (testing)
    /// </summary>

    /// <remarks>
    /// Injects a perception event directly into the actor's perception queue
    /// <br/>for testing purposes. Useful for testing actor behavior without a
    /// <br/>full game server setup.
    /// </remarks>

    /// <returns>Perception injected successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InjectPerceptionResponse>> InjectPerceptionAsync(InjectPerceptionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Query an actor for its available options
    /// </summary>

    /// <remarks>
    /// Query an actor for its available options (combat, dialogue, exploration, etc.).
    /// <br/>Options are maintained by the actor in its state and returned based on requested
    /// <br/>freshness level. This enables Event Brain actors to ask participants "what can
    /// <br/>you do?" for choreography and coordination.
    /// <br/>
    /// <br/>Freshness levels:
    /// <br/>- fresh: Inject context and wait for actor to recompute options
    /// <br/>- cached: Return cached options if within maxAgeMs, else recompute
    /// <br/>- stale_ok: Return cached options regardless of age
    /// </remarks>

    /// <returns>Options retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryOptionsResponse>> QueryOptionsAsync(QueryOptionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Start an encounter managed by an Event Brain actor
    /// </summary>

    /// <remarks>
    /// Initializes an encounter with the specified participants. The Event Brain actor
    /// <br/>will coordinate the encounter, sending instructions to participant NPC Brain actors
    /// <br/>via their character perception channels.
    /// </remarks>

    /// <returns>Encounter started successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> StartEncounterAsync(StartEncounterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update the phase of an active encounter
    /// </summary>

    /// <remarks>
    /// Updates the phase of an encounter being managed by an Event Brain actor.
    /// <br/>Phase changes are logged and can trigger behavior changes in participant actors.
    /// </remarks>

    /// <returns>Encounter phase updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateEncounterPhaseResponse>> UpdateEncounterPhaseAsync(UpdateEncounterPhaseRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// End an active encounter
    /// </summary>

    /// <remarks>
    /// Ends an encounter being managed by an Event Brain actor. This clears the
    /// <br/>encounter state and allows the actor to manage a new encounter.
    /// </remarks>

    /// <returns>Encounter ended successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EndEncounterResponse>> EndEncounterAsync(EndEncounterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get the current encounter state for an actor
    /// </summary>

    /// <remarks>
    /// Retrieves the current encounter state for an Event Brain actor. Returns
    /// <br/>null encounter data if the actor is not managing an encounter.
    /// </remarks>

    /// <returns>Encounter state retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetEncounterResponse>> GetEncounterAsync(GetEncounterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class ActorController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IActorService _implementation;

    public ActorController(IActorService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Create an actor template (category definition)
    /// </summary>
    /// <returns>Template created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> CreateActorTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateActorTemplateAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get an actor template by ID or category
    /// </summary>
    /// <returns>Template retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> GetActorTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetActorTemplateAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List all actor templates
    /// </summary>
    /// <returns>Templates listed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListActorTemplatesResponse>> ListActorTemplates([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListActorTemplatesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListActorTemplatesAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Update an actor template
    /// </summary>
    /// <returns>Template updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorTemplateResponse>> UpdateActorTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateActorTemplateAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Delete an actor template
    /// </summary>
    /// <returns>Template deleted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/template/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteActorTemplateResponse>> DeleteActorTemplate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteActorTemplateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DeleteActorTemplateAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Spawn a new actor from a template
    /// </summary>
    /// <returns>Actor spawned successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/spawn")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorInstanceResponse>> SpawnActor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SpawnActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.SpawnActorAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get actor instance (instantiate-on-access if template allows)
    /// </summary>
    /// <remarks>
    /// If the actor exists, returns its current state.
    /// <br/>If the actor doesn't exist but a matching template has auto-spawn enabled,
    /// <br/>instantiates the actor and returns it.
    /// </remarks>
    /// <returns>Actor retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ActorInstanceResponse>> GetActor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetActorAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Stop a running actor
    /// </summary>
    /// <returns>Actor stopped successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/stop")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<StopActorResponse>> StopActor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] StopActorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.StopActorAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List actors with optional filters
    /// </summary>
    /// <returns>Actors listed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListActorsResponse>> ListActors([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListActorsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListActorsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Inject a perception event into an actor's queue (testing)
    /// </summary>
    /// <remarks>
    /// Injects a perception event directly into the actor's perception queue
    /// <br/>for testing purposes. Useful for testing actor behavior without a
    /// <br/>full game server setup.
    /// </remarks>
    /// <returns>Perception injected successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/inject-perception")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InjectPerceptionResponse>> InjectPerception([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] InjectPerceptionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.InjectPerceptionAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Query an actor for its available options
    /// </summary>
    /// <remarks>
    /// Query an actor for its available options (combat, dialogue, exploration, etc.).
    /// <br/>Options are maintained by the actor in its state and returned based on requested
    /// <br/>freshness level. This enables Event Brain actors to ask participants "what can
    /// <br/>you do?" for choreography and coordination.
    /// <br/>
    /// <br/>Freshness levels:
    /// <br/>- fresh: Inject context and wait for actor to recompute options
    /// <br/>- cached: Return cached options if within maxAgeMs, else recompute
    /// <br/>- stale_ok: Return cached options regardless of age
    /// </remarks>
    /// <returns>Options retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/query-options")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryOptionsResponse>> QueryOptions([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryOptionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.QueryOptionsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Start an encounter managed by an Event Brain actor
    /// </summary>
    /// <remarks>
    /// Initializes an encounter with the specified participants. The Event Brain actor
    /// <br/>will coordinate the encounter, sending instructions to participant NPC Brain actors
    /// <br/>via their character perception channels.
    /// </remarks>
    /// <returns>Encounter started successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/encounter/start")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> StartEncounter([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] StartEncounterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var statusCode = await _implementation.StartEncounterAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode);
    }

    /// <summary>
    /// Update the phase of an active encounter
    /// </summary>
    /// <remarks>
    /// Updates the phase of an encounter being managed by an Event Brain actor.
    /// <br/>Phase changes are logged and can trigger behavior changes in participant actors.
    /// </remarks>
    /// <returns>Encounter phase updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/encounter/update-phase")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateEncounterPhaseResponse>> UpdateEncounterPhase([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateEncounterPhaseRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateEncounterPhaseAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// End an active encounter
    /// </summary>
    /// <remarks>
    /// Ends an encounter being managed by an Event Brain actor. This clears the
    /// <br/>encounter state and allows the actor to manage a new encounter.
    /// </remarks>
    /// <returns>Encounter ended successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/encounter/end")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EndEncounterResponse>> EndEncounter([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] EndEncounterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.EndEncounterAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get the current encounter state for an actor
    /// </summary>
    /// <remarks>
    /// Retrieves the current encounter state for an Event Brain actor. Returns
    /// <br/>null encounter data if the actor is not managing an encounter.
    /// </remarks>
    /// <returns>Encounter state retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("actor/encounter/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetEncounterResponse>> GetEncounter([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetEncounterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetEncounterAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
