//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace BeyondImmersion.BannouService.Actor;

/// <summary>
/// Meta/introspection endpoints for runtime schema access.
/// Generated from schemas/Generated/actor-api-meta.yaml
/// </summary>
public partial class ActorController
{
    #region Meta Endpoints for CreateActorTemplate

    private static readonly string _CreateActorTemplate_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateActorTemplateRequest",
    "$defs": {
        "CreateActorTemplateRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to create a new actor template definition",
            "required": [
                "category",
                "behaviorRef"
            ],
            "properties": {
                "category": {
                    "type": "string",
                    "description": "Category identifier (e.g., \"npc-brain\", \"world-admin\", \"cron-cleanup\")"
                },
                "behaviorRef": {
                    "type": "string",
                    "description": "Reference to behavior in lib-assets (e.g., \"asset://behaviors/npc-brain-v1\")"
                },
                "configuration": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Default configuration passed to behavior execution"
                },
                "autoSpawn": {
                    "description": "Auto-spawn configuration for instantiate-on-access",
                    "nullable": true,
                    "$ref": "#/$defs/AutoSpawnConfig"
                },
                "tickIntervalMs": {
                    "type": "integer",
                    "default": 1000,
                    "description": "Milliseconds between behavior loop iterations"
                },
                "autoSaveIntervalSeconds": {
                    "type": "integer",
                    "default": 60,
                    "description": "Seconds between automatic state saves (0 to disable)"
                },
                "maxInstancesPerNode": {
                    "type": "integer",
                    "default": 100,
                    "description": "Maximum actors of this category per pool node"
                }
            }
        },
        "AutoSpawnConfig": {
            "type": "object",
            "additionalProperties": false,
            "description": "Configuration for instantiate-on-access behavior",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, accessing a non-existent actor creates it"
                },
                "idPattern": {
                    "type": "string",
                    "nullable": true,
                    "description": "Regex pattern for actor IDs that trigger auto-spawn.\nExamples: \"npc-.*\" matches \"npc-grok\", \"npc-merchant-123\"\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum auto-spawned instances (0 = unlimited)"
                },
                "characterIdCaptureGroup": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "1-based regex capture group index for extracting CharacterId from actor ID.\nExample: With idPattern \"npc-brain-([a-f0-9-]+)\" and characterIdCaptureGroup: 1,\nactor ID \"npc-brain-abc-123-def\" extracts \"abc-123-def\" as CharacterId (parsed as GUID).\n"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateActorTemplate_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ActorTemplateResponse",
    "$defs": {
        "ActorTemplateResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing actor template details",
            "required": [
                "templateId",
                "category",
                "behaviorRef",
                "tickIntervalMs",
                "autoSaveIntervalSeconds",
                "maxInstancesPerNode",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique template identifier"
                },
                "category": {
                    "type": "string",
                    "description": "Category identifier"
                },
                "behaviorRef": {
                    "type": "string",
                    "description": "Reference to behavior in lib-assets"
                },
                "configuration": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Default configuration passed to behavior execution"
                },
                "autoSpawn": {
                    "description": "Auto-spawn configuration for instantiate-on-access",
                    "nullable": true,
                    "$ref": "#/$defs/AutoSpawnConfig"
                },
                "tickIntervalMs": {
                    "type": "integer",
                    "description": "Milliseconds between behavior loop iterations"
                },
                "autoSaveIntervalSeconds": {
                    "type": "integer",
                    "description": "Seconds between automatic state saves"
                },
                "maxInstancesPerNode": {
                    "type": "integer",
                    "description": "Maximum actors of this category per pool node"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was last updated"
                }
            }
        },
        "AutoSpawnConfig": {
            "type": "object",
            "additionalProperties": false,
            "description": "Configuration for instantiate-on-access behavior",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, accessing a non-existent actor creates it"
                },
                "idPattern": {
                    "type": "string",
                    "nullable": true,
                    "description": "Regex pattern for actor IDs that trigger auto-spawn.\nExamples: \"npc-.*\" matches \"npc-grok\", \"npc-merchant-123\"\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum auto-spawned instances (0 = unlimited)"
                },
                "characterIdCaptureGroup": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "1-based regex capture group index for extracting CharacterId from actor ID.\nExample: With idPattern \"npc-brain-([a-f0-9-]+)\" and characterIdCaptureGroup: 1,\nactor ID \"npc-brain-abc-123-def\" extracts \"abc-123-def\" as CharacterId (parsed as GUID).\n"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateActorTemplate_Info = """
{
    "summary": "Create an actor template (category definition)",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "CreateActorTemplate"
}
""";

    /// <summary>Returns endpoint information for CreateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateActorTemplate_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/template/create",
            _CreateActorTemplate_Info));

    /// <summary>Returns request schema for CreateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateActorTemplate_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/create",
            "request-schema",
            _CreateActorTemplate_RequestSchema));

    /// <summary>Returns response schema for CreateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateActorTemplate_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/create",
            "response-schema",
            _CreateActorTemplate_ResponseSchema));

    /// <summary>Returns full schema for CreateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateActorTemplate_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/create",
            _CreateActorTemplate_Info,
            _CreateActorTemplate_RequestSchema,
            _CreateActorTemplate_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetActorTemplate

    private static readonly string _GetActorTemplate_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetActorTemplateRequest",
    "$defs": {
        "GetActorTemplateRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to get an actor template by ID or category",
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Template ID to retrieve"
                },
                "category": {
                    "type": "string",
                    "nullable": true,
                    "description": "Or retrieve by category name"
                }
            }
        }
    }
}
""";

    private static readonly string _GetActorTemplate_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ActorTemplateResponse",
    "$defs": {
        "ActorTemplateResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing actor template details",
            "required": [
                "templateId",
                "category",
                "behaviorRef",
                "tickIntervalMs",
                "autoSaveIntervalSeconds",
                "maxInstancesPerNode",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique template identifier"
                },
                "category": {
                    "type": "string",
                    "description": "Category identifier"
                },
                "behaviorRef": {
                    "type": "string",
                    "description": "Reference to behavior in lib-assets"
                },
                "configuration": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Default configuration passed to behavior execution"
                },
                "autoSpawn": {
                    "description": "Auto-spawn configuration for instantiate-on-access",
                    "nullable": true,
                    "$ref": "#/$defs/AutoSpawnConfig"
                },
                "tickIntervalMs": {
                    "type": "integer",
                    "description": "Milliseconds between behavior loop iterations"
                },
                "autoSaveIntervalSeconds": {
                    "type": "integer",
                    "description": "Seconds between automatic state saves"
                },
                "maxInstancesPerNode": {
                    "type": "integer",
                    "description": "Maximum actors of this category per pool node"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was last updated"
                }
            }
        },
        "AutoSpawnConfig": {
            "type": "object",
            "additionalProperties": false,
            "description": "Configuration for instantiate-on-access behavior",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, accessing a non-existent actor creates it"
                },
                "idPattern": {
                    "type": "string",
                    "nullable": true,
                    "description": "Regex pattern for actor IDs that trigger auto-spawn.\nExamples: \"npc-.*\" matches \"npc-grok\", \"npc-merchant-123\"\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum auto-spawned instances (0 = unlimited)"
                },
                "characterIdCaptureGroup": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "1-based regex capture group index for extracting CharacterId from actor ID.\nExample: With idPattern \"npc-brain-([a-f0-9-]+)\" and characterIdCaptureGroup: 1,\nactor ID \"npc-brain-abc-123-def\" extracts \"abc-123-def\" as CharacterId (parsed as GUID).\n"
                }
            }
        }
    }
}
""";

    private static readonly string _GetActorTemplate_Info = """
{
    "summary": "Get an actor template by ID or category",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "GetActorTemplate"
}
""";

    /// <summary>Returns endpoint information for GetActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActorTemplate_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/template/get",
            _GetActorTemplate_Info));

    /// <summary>Returns request schema for GetActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActorTemplate_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/get",
            "request-schema",
            _GetActorTemplate_RequestSchema));

    /// <summary>Returns response schema for GetActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActorTemplate_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/get",
            "response-schema",
            _GetActorTemplate_ResponseSchema));

    /// <summary>Returns full schema for GetActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActorTemplate_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/get",
            _GetActorTemplate_Info,
            _GetActorTemplate_RequestSchema,
            _GetActorTemplate_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListActorTemplates

    private static readonly string _ListActorTemplates_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListActorTemplatesRequest",
    "$defs": {
        "ListActorTemplatesRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to list actor templates with pagination",
            "properties": {
                "limit": {
                    "type": "integer",
                    "default": 100,
                    "description": "Maximum number of templates to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Number of templates to skip"
                }
            }
        }
    }
}
""";

    private static readonly string _ListActorTemplates_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListActorTemplatesResponse",
    "$defs": {
        "ListActorTemplatesResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing a list of actor templates",
            "required": [
                "templates",
                "total"
            ],
            "properties": {
                "templates": {
                    "type": "array",
                    "description": "List of actor templates",
                    "items": {
                        "$ref": "#/$defs/ActorTemplateResponse"
                    }
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of templates available"
                }
            }
        },
        "ActorTemplateResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing actor template details",
            "required": [
                "templateId",
                "category",
                "behaviorRef",
                "tickIntervalMs",
                "autoSaveIntervalSeconds",
                "maxInstancesPerNode",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique template identifier"
                },
                "category": {
                    "type": "string",
                    "description": "Category identifier"
                },
                "behaviorRef": {
                    "type": "string",
                    "description": "Reference to behavior in lib-assets"
                },
                "configuration": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Default configuration passed to behavior execution"
                },
                "autoSpawn": {
                    "description": "Auto-spawn configuration for instantiate-on-access",
                    "nullable": true,
                    "$ref": "#/$defs/AutoSpawnConfig"
                },
                "tickIntervalMs": {
                    "type": "integer",
                    "description": "Milliseconds between behavior loop iterations"
                },
                "autoSaveIntervalSeconds": {
                    "type": "integer",
                    "description": "Seconds between automatic state saves"
                },
                "maxInstancesPerNode": {
                    "type": "integer",
                    "description": "Maximum actors of this category per pool node"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was last updated"
                }
            }
        },
        "AutoSpawnConfig": {
            "type": "object",
            "additionalProperties": false,
            "description": "Configuration for instantiate-on-access behavior",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, accessing a non-existent actor creates it"
                },
                "idPattern": {
                    "type": "string",
                    "nullable": true,
                    "description": "Regex pattern for actor IDs that trigger auto-spawn.\nExamples: \"npc-.*\" matches \"npc-grok\", \"npc-merchant-123\"\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum auto-spawned instances (0 = unlimited)"
                },
                "characterIdCaptureGroup": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "1-based regex capture group index for extracting CharacterId from actor ID.\nExample: With idPattern \"npc-brain-([a-f0-9-]+)\" and characterIdCaptureGroup: 1,\nactor ID \"npc-brain-abc-123-def\" extracts \"abc-123-def\" as CharacterId (parsed as GUID).\n"
                }
            }
        }
    }
}
""";

    private static readonly string _ListActorTemplates_Info = """
{
    "summary": "List all actor templates",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "ListActorTemplates"
}
""";

    /// <summary>Returns endpoint information for ListActorTemplates</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActorTemplates_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/template/list",
            _ListActorTemplates_Info));

    /// <summary>Returns request schema for ListActorTemplates</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActorTemplates_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/list",
            "request-schema",
            _ListActorTemplates_RequestSchema));

    /// <summary>Returns response schema for ListActorTemplates</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActorTemplates_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/list",
            "response-schema",
            _ListActorTemplates_ResponseSchema));

    /// <summary>Returns full schema for ListActorTemplates</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActorTemplates_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/list",
            _ListActorTemplates_Info,
            _ListActorTemplates_RequestSchema,
            _ListActorTemplates_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateActorTemplate

    private static readonly string _UpdateActorTemplate_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateActorTemplateRequest",
    "$defs": {
        "UpdateActorTemplateRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to update an existing actor template",
            "required": [
                "templateId"
            ],
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the template to update"
                },
                "behaviorRef": {
                    "type": "string",
                    "nullable": true,
                    "description": "New behavior reference (triggers behavior.updated subscription)"
                },
                "configuration": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Updated configuration settings"
                },
                "autoSpawn": {
                    "description": "Updated auto-spawn configuration",
                    "nullable": true,
                    "$ref": "#/$defs/AutoSpawnConfig"
                },
                "tickIntervalMs": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Updated tick interval in milliseconds"
                },
                "autoSaveIntervalSeconds": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Updated auto-save interval in seconds"
                }
            }
        },
        "AutoSpawnConfig": {
            "type": "object",
            "additionalProperties": false,
            "description": "Configuration for instantiate-on-access behavior",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, accessing a non-existent actor creates it"
                },
                "idPattern": {
                    "type": "string",
                    "nullable": true,
                    "description": "Regex pattern for actor IDs that trigger auto-spawn.\nExamples: \"npc-.*\" matches \"npc-grok\", \"npc-merchant-123\"\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum auto-spawned instances (0 = unlimited)"
                },
                "characterIdCaptureGroup": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "1-based regex capture group index for extracting CharacterId from actor ID.\nExample: With idPattern \"npc-brain-([a-f0-9-]+)\" and characterIdCaptureGroup: 1,\nactor ID \"npc-brain-abc-123-def\" extracts \"abc-123-def\" as CharacterId (parsed as GUID).\n"
                }
            }
        }
    }
}
""";

    private static readonly string _UpdateActorTemplate_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ActorTemplateResponse",
    "$defs": {
        "ActorTemplateResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing actor template details",
            "required": [
                "templateId",
                "category",
                "behaviorRef",
                "tickIntervalMs",
                "autoSaveIntervalSeconds",
                "maxInstancesPerNode",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique template identifier"
                },
                "category": {
                    "type": "string",
                    "description": "Category identifier"
                },
                "behaviorRef": {
                    "type": "string",
                    "description": "Reference to behavior in lib-assets"
                },
                "configuration": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Default configuration passed to behavior execution"
                },
                "autoSpawn": {
                    "description": "Auto-spawn configuration for instantiate-on-access",
                    "nullable": true,
                    "$ref": "#/$defs/AutoSpawnConfig"
                },
                "tickIntervalMs": {
                    "type": "integer",
                    "description": "Milliseconds between behavior loop iterations"
                },
                "autoSaveIntervalSeconds": {
                    "type": "integer",
                    "description": "Seconds between automatic state saves"
                },
                "maxInstancesPerNode": {
                    "type": "integer",
                    "description": "Maximum actors of this category per pool node"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the template was last updated"
                }
            }
        },
        "AutoSpawnConfig": {
            "type": "object",
            "additionalProperties": false,
            "description": "Configuration for instantiate-on-access behavior",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, accessing a non-existent actor creates it"
                },
                "idPattern": {
                    "type": "string",
                    "nullable": true,
                    "description": "Regex pattern for actor IDs that trigger auto-spawn.\nExamples: \"npc-.*\" matches \"npc-grok\", \"npc-merchant-123\"\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum auto-spawned instances (0 = unlimited)"
                },
                "characterIdCaptureGroup": {
                    "type": "integer",
                    "minimum": 1,
                    "nullable": true,
                    "description": "1-based regex capture group index for extracting CharacterId from actor ID.\nExample: With idPattern \"npc-brain-([a-f0-9-]+)\" and characterIdCaptureGroup: 1,\nactor ID \"npc-brain-abc-123-def\" extracts \"abc-123-def\" as CharacterId (parsed as GUID).\n"
                }
            }
        }
    }
}
""";

    private static readonly string _UpdateActorTemplate_Info = """
{
    "summary": "Update an actor template",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "UpdateActorTemplate"
}
""";

    /// <summary>Returns endpoint information for UpdateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateActorTemplate_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/template/update",
            _UpdateActorTemplate_Info));

    /// <summary>Returns request schema for UpdateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateActorTemplate_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/update",
            "request-schema",
            _UpdateActorTemplate_RequestSchema));

    /// <summary>Returns response schema for UpdateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateActorTemplate_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/update",
            "response-schema",
            _UpdateActorTemplate_ResponseSchema));

    /// <summary>Returns full schema for UpdateActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateActorTemplate_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/update",
            _UpdateActorTemplate_Info,
            _UpdateActorTemplate_RequestSchema,
            _UpdateActorTemplate_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeleteActorTemplate

    private static readonly string _DeleteActorTemplate_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteActorTemplateRequest",
    "$defs": {
        "DeleteActorTemplateRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to delete an actor template",
            "required": [
                "templateId"
            ],
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the template to delete"
                },
                "forceStopActors": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, stops all running actors using this template"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteActorTemplate_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteActorTemplateResponse",
    "$defs": {
        "DeleteActorTemplateResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response confirming template deletion",
            "required": [
                "deleted",
                "stoppedActorCount"
            ],
            "properties": {
                "deleted": {
                    "type": "boolean",
                    "description": "Whether the template was successfully deleted"
                },
                "stoppedActorCount": {
                    "type": "integer",
                    "description": "Number of running actors that were stopped"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteActorTemplate_Info = """
{
    "summary": "Delete an actor template",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "DeleteActorTemplate"
}
""";

    /// <summary>Returns endpoint information for DeleteActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteActorTemplate_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/template/delete",
            _DeleteActorTemplate_Info));

    /// <summary>Returns request schema for DeleteActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteActorTemplate_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/delete",
            "request-schema",
            _DeleteActorTemplate_RequestSchema));

    /// <summary>Returns response schema for DeleteActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteActorTemplate_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/delete",
            "response-schema",
            _DeleteActorTemplate_ResponseSchema));

    /// <summary>Returns full schema for DeleteActorTemplate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/template/delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteActorTemplate_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/template/delete",
            _DeleteActorTemplate_Info,
            _DeleteActorTemplate_RequestSchema,
            _DeleteActorTemplate_ResponseSchema));

    #endregion

    #region Meta Endpoints for SpawnActor

    private static readonly string _SpawnActor_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/SpawnActorRequest",
    "$defs": {
        "SpawnActorRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to spawn a new actor from a template",
            "required": [
                "templateId"
            ],
            "properties": {
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Template to instantiate from"
                },
                "actorId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional custom actor ID (auto-generated if not provided)"
                },
                "configurationOverrides": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Override template defaults"
                },
                "initialState": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Initial state passed to behavior"
                },
                "characterId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Optional character ID for NPC brain actors"
                }
            }
        }
    }
}
""";

    private static readonly string _SpawnActor_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ActorInstanceResponse",
    "$defs": {
        "ActorInstanceResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing actor instance details",
            "required": [
                "actorId",
                "templateId",
                "category",
                "status",
                "startedAt",
                "loopIterations"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "Unique actor identifier"
                },
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Template this actor was instantiated from"
                },
                "category": {
                    "type": "string",
                    "description": "Actor category from template"
                },
                "nodeId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Pool node running this actor (null in bannou mode)"
                },
                "nodeAppId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Pool node's app-id for direct messaging"
                },
                "status": {
                    "description": "Current actor lifecycle state",
                    "$ref": "#/$defs/ActorStatus"
                },
                "characterId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Associated character ID (for NPC brains)"
                },
                "startedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the actor started running"
                },
                "lastHeartbeat": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "Last heartbeat timestamp from the actor"
                },
                "loopIterations": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Number of behavior loop iterations executed"
                }
            }
        },
        "ActorStatus": {
            "type": "string",
            "enum": [
                "pending",
                "starting",
                "running",
                "paused",
                "stopping",
                "stopped",
                "error"
            ],
            "description": "Current actor lifecycle state"
        }
    }
}
""";

    private static readonly string _SpawnActor_Info = """
{
    "summary": "Spawn a new actor from a template",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "SpawnActor"
}
""";

    /// <summary>Returns endpoint information for SpawnActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/spawn/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SpawnActor_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/spawn",
            _SpawnActor_Info));

    /// <summary>Returns request schema for SpawnActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/spawn/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SpawnActor_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/spawn",
            "request-schema",
            _SpawnActor_RequestSchema));

    /// <summary>Returns response schema for SpawnActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/spawn/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SpawnActor_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/spawn",
            "response-schema",
            _SpawnActor_ResponseSchema));

    /// <summary>Returns full schema for SpawnActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/spawn/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SpawnActor_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/spawn",
            _SpawnActor_Info,
            _SpawnActor_RequestSchema,
            _SpawnActor_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetActor

    private static readonly string _GetActor_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetActorRequest",
    "$defs": {
        "GetActorRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to get an actor instance by ID",
            "required": [
                "actorId"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "Actor ID to retrieve"
                }
            }
        }
    }
}
""";

    private static readonly string _GetActor_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ActorInstanceResponse",
    "$defs": {
        "ActorInstanceResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing actor instance details",
            "required": [
                "actorId",
                "templateId",
                "category",
                "status",
                "startedAt",
                "loopIterations"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "Unique actor identifier"
                },
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Template this actor was instantiated from"
                },
                "category": {
                    "type": "string",
                    "description": "Actor category from template"
                },
                "nodeId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Pool node running this actor (null in bannou mode)"
                },
                "nodeAppId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Pool node's app-id for direct messaging"
                },
                "status": {
                    "description": "Current actor lifecycle state",
                    "$ref": "#/$defs/ActorStatus"
                },
                "characterId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Associated character ID (for NPC brains)"
                },
                "startedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the actor started running"
                },
                "lastHeartbeat": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "Last heartbeat timestamp from the actor"
                },
                "loopIterations": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Number of behavior loop iterations executed"
                }
            }
        },
        "ActorStatus": {
            "type": "string",
            "enum": [
                "pending",
                "starting",
                "running",
                "paused",
                "stopping",
                "stopped",
                "error"
            ],
            "description": "Current actor lifecycle state"
        }
    }
}
""";

    private static readonly string _GetActor_Info = """
{
    "summary": "Get actor instance (instantiate-on-access if template allows)",
    "description": "If the actor exists, returns its current state.\nIf the actor doesn't exist but a matching template has auto-spawn enabled,\ninstantiates the actor and returns it.\n",
    "tags": [],
    "deprecated": false,
    "operationId": "GetActor"
}
""";

    /// <summary>Returns endpoint information for GetActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActor_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/get",
            _GetActor_Info));

    /// <summary>Returns request schema for GetActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActor_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/get",
            "request-schema",
            _GetActor_RequestSchema));

    /// <summary>Returns response schema for GetActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActor_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/get",
            "response-schema",
            _GetActor_ResponseSchema));

    /// <summary>Returns full schema for GetActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetActor_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/get",
            _GetActor_Info,
            _GetActor_RequestSchema,
            _GetActor_ResponseSchema));

    #endregion

    #region Meta Endpoints for StopActor

    private static readonly string _StopActor_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/StopActorRequest",
    "$defs": {
        "StopActorRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to stop a running actor",
            "required": [
                "actorId"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "ID of the actor to stop"
                },
                "graceful": {
                    "type": "boolean",
                    "default": true,
                    "description": "If true, allows behavior to complete current iteration"
                }
            }
        }
    }
}
""";

    private static readonly string _StopActor_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/StopActorResponse",
    "$defs": {
        "StopActorResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response confirming actor stop operation",
            "required": [
                "stopped",
                "finalStatus"
            ],
            "properties": {
                "stopped": {
                    "type": "boolean",
                    "description": "Whether the actor was successfully stopped"
                },
                "finalStatus": {
                    "description": "Final status of the actor after stopping",
                    "$ref": "#/$defs/ActorStatus"
                }
            }
        },
        "ActorStatus": {
            "type": "string",
            "enum": [
                "pending",
                "starting",
                "running",
                "paused",
                "stopping",
                "stopped",
                "error"
            ],
            "description": "Current actor lifecycle state"
        }
    }
}
""";

    private static readonly string _StopActor_Info = """
{
    "summary": "Stop a running actor",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "StopActor"
}
""";

    /// <summary>Returns endpoint information for StopActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/stop/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> StopActor_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/stop",
            _StopActor_Info));

    /// <summary>Returns request schema for StopActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/stop/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> StopActor_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/stop",
            "request-schema",
            _StopActor_RequestSchema));

    /// <summary>Returns response schema for StopActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/stop/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> StopActor_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/stop",
            "response-schema",
            _StopActor_ResponseSchema));

    /// <summary>Returns full schema for StopActor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/stop/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> StopActor_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/stop",
            _StopActor_Info,
            _StopActor_RequestSchema,
            _StopActor_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListActors

    private static readonly string _ListActors_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListActorsRequest",
    "$defs": {
        "ListActorsRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to list actor instances with optional filters",
            "properties": {
                "category": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by category"
                },
                "nodeId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by pool node"
                },
                "status": {
                    "description": "Filter by actor status",
                    "$ref": "#/$defs/ActorStatus"
                },
                "characterId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Filter by associated character"
                },
                "limit": {
                    "type": "integer",
                    "default": 100,
                    "description": "Maximum number of actors to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Number of actors to skip"
                }
            }
        },
        "ActorStatus": {
            "type": "string",
            "enum": [
                "pending",
                "starting",
                "running",
                "paused",
                "stopping",
                "stopped",
                "error"
            ],
            "description": "Current actor lifecycle state"
        }
    }
}
""";

    private static readonly string _ListActors_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListActorsResponse",
    "$defs": {
        "ListActorsResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing a list of actor instances",
            "required": [
                "actors",
                "total"
            ],
            "properties": {
                "actors": {
                    "type": "array",
                    "description": "List of actor instances",
                    "items": {
                        "$ref": "#/$defs/ActorInstanceResponse"
                    }
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of actors matching the filter"
                }
            }
        },
        "ActorInstanceResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing actor instance details",
            "required": [
                "actorId",
                "templateId",
                "category",
                "status",
                "startedAt",
                "loopIterations"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "Unique actor identifier"
                },
                "templateId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Template this actor was instantiated from"
                },
                "category": {
                    "type": "string",
                    "description": "Actor category from template"
                },
                "nodeId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Pool node running this actor (null in bannou mode)"
                },
                "nodeAppId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Pool node's app-id for direct messaging"
                },
                "status": {
                    "description": "Current actor lifecycle state",
                    "$ref": "#/$defs/ActorStatus"
                },
                "characterId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Associated character ID (for NPC brains)"
                },
                "startedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the actor started running"
                },
                "lastHeartbeat": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "Last heartbeat timestamp from the actor"
                },
                "loopIterations": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Number of behavior loop iterations executed"
                }
            }
        },
        "ActorStatus": {
            "type": "string",
            "enum": [
                "pending",
                "starting",
                "running",
                "paused",
                "stopping",
                "stopped",
                "error"
            ],
            "description": "Current actor lifecycle state"
        }
    }
}
""";

    private static readonly string _ListActors_Info = """
{
    "summary": "List actors with optional filters",
    "description": "",
    "tags": [],
    "deprecated": false,
    "operationId": "ListActors"
}
""";

    /// <summary>Returns endpoint information for ListActors</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActors_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/list",
            _ListActors_Info));

    /// <summary>Returns request schema for ListActors</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActors_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/list",
            "request-schema",
            _ListActors_RequestSchema));

    /// <summary>Returns response schema for ListActors</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActors_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/list",
            "response-schema",
            _ListActors_ResponseSchema));

    /// <summary>Returns full schema for ListActors</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListActors_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/list",
            _ListActors_Info,
            _ListActors_RequestSchema,
            _ListActors_ResponseSchema));

    #endregion

    #region Meta Endpoints for InjectPerception

    private static readonly string _InjectPerception_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/InjectPerceptionRequest",
    "$defs": {
        "InjectPerceptionRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to inject a perception event into an actor's queue",
            "required": [
                "actorId",
                "perception"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "Target actor to inject perception into"
                },
                "perception": {
                    "description": "Perception data to inject",
                    "$ref": "#/$defs/PerceptionData"
                }
            }
        },
        "PerceptionData": {
            "type": "object",
            "additionalProperties": false,
            "description": "Data representing a perception event for an actor.\n\nSpatial context can be provided in two ways (hybrid approach):\n1. Typed: Use the optional spatialContext field for structured spatial data\n2. Schema-less: Use perceptionType=\"spatial\" with data containing spatial info\n\nThe typed approach is recommended when game server has structured spatial data.\nThe schema-less approach allows flexibility for game-specific spatial formats.\n",
            "required": [
                "perceptionType",
                "sourceId"
            ],
            "properties": {
                "perceptionType": {
                    "type": "string",
                    "description": "Perception type. Common values: visual, auditory, tactile, olfactory,\nproprioceptive, spatial. Use \"spatial\" for schema-less spatial data in 'data' field.\n"
                },
                "sourceId": {
                    "type": "string",
                    "description": "ID of the entity causing this perception"
                },
                "sourceType": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/PerceptionSourceType"
                        }
                    ],
                    "nullable": true,
                    "description": "Type of source (character, npc, object, environment, coordinator, scheduled, message)"
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Perception-specific data. For perceptionType=\"spatial\", this can contain\ ngame-specific spatial context in any format the game server defines.\n"
                },
                "urgency": {
                    "type": "number",
                    "format": "float",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 0.5,
                    "description": "How urgent this perception is (0-1)"
                },
                "spatialContext": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/SpatialContext"
                        }
                    ],
                    "nullable": true,
                    "description": "Optional typed spatial context from game server's local spatial state.\nProvides structured information about terrain, nearby objects, hazards, etc.\nAlternative to using perceptionType=\"spatial\" with schema-less data.\n"
                }
            }
        },
        "PerceptionSourceType": {
            "type": "string",
            "description": "Type of source generating a perception event",
            "enum": [
                "character",
                "npc",
                "object",
                "environment",
                "coordinator",
                "scheduled",
                "message",
                "service",
                "system"
            ]
        },
        "SpatialContext": {
            "type": "object",
            "additionalProperties": true,
            "description": "Spatial context derived from game server's authoritative spatial state.\nIncluded in perception events to give NPC actors awareness of their environment\nwithout requiring direct map subscriptions.\n\nNote: additionalProperties=true allows game-specific extensions.\n",
            "properties": {
                "terrainType": {
                    "type": "string",
                    "nullable": true,
                    "description": "Terrain type at character position (grass, stone, water, etc.)"
                },
                "elevation": {
                    "type": "number",
                    "format": "float",
                    "nullable": true,
                    "description": "Elevation at character position"
                },
                "nearbyObjects": {
                    "type": "array",
                    "nullable": true,
                    "description": "Objects within perception radius",
                    "items": {
                        "$ref": "#/$defs/NearbyObject"
                    }
                },
                "hazardsInRange": {
                    "type": "array",
                    "nullable": true,
                    "description": "Active hazards within detection range",
                    "items": {
                        "$ref": "#/$defs/HazardInfo"
                    }
                },
                "pathableDirections": {
                    "type": "array",
                    "nullable": true,
                    "description": "Directions the character can move (for navigation awareness)",
                    "items": {
                        "type": "string",
                        "description": "Cardinal or relative direction (north, south, east, west, forward, etc.)"
                    }
                },
                "coverNearby": {
                    "type": "boolean",
                    "nullable": true,
                    "description": "Whether cover is available within close range"
                },
                "indoors": {
                    "type": "boolean",
                    "nullable": true,
                    "description": "Whether character is currently indoors/under roof"
                }
            }
        },
        "NearbyObject": {
            "type": "object",
            "additionalProperties": true,
            "description": "Information about a nearby object perceived by the character",
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the object"
                },
                "objectType": {
                    "type": "string",
                    "description": "Type of object (boulder_cluster, tree, building, etc.)"
                },
                "distance": {
                    "type": "number",
                    "format": "float",
                    "description": "Distance from character in game units"
                },
                "direction": {
                    "type": "string",
                    "description": "Relative direction (north, south, east, west, above, below, etc.)"
                },
                "position": {
                    "allOf": [
                        {
                            "$ref": "#/$defs/Position3D"
                        }
                    ],
                    "nullable": true,
                    "description": "Optional absolute position"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "additionalProperties": false,
            "description": "3D position in world coordinates",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "float",
                    "description": "X coordinate"
                },
                "y": {
                    "type": "number",
                    "format": "float",
                    "description": "Y coordinate (typically vertical)"
                },
                "z": {
                    "type": "number",
                    "format": "float",
                    "description": "Z coordinate"
                }
            }
        },
        "HazardInfo": {
            "type": "object",
            "additionalProperties": true,
            "description": "Information about a hazard in range",
            "properties": {
                "hazardType": {
                    "type": "string",
                    "description": "Type of hazard (fire, poison, radiation, deep_water, etc.)"
                },
                "distance": {
                    "type": "number",
                    "format": "float",
                    "description": "Distance to hazard edge"
                },
                "severity": {
                    "type": "number",
                    "format": "float",
                    "minimum": 0,
                    "maximum": 1,
                    "description": "Hazard severity (0-1)"
                },
                "direction": {
                    "type": "string",
                    "nullable": true,
                    "description": "Direction to hazard center"
                }
            }
        }
    }
}
""";

    private static readonly string _InjectPerception_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/InjectPerceptionResponse",
    "$defs": {
        "InjectPerceptionResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response confirming perception injection",
            "required": [
                "queued",
                "queueDepth"
            ],
            "properties": {
                "queued": {
                    "type": "boolean",
                    "description": "Whether the perception was successfully queued"
                },
                "queueDepth": {
                    "type": "integer",
                    "description": "Current depth of the perception queue"
                }
            }
        }
    }
}
""";

    private static readonly string _InjectPerception_Info = """
{
    "summary": "Inject a perception event into an actor's queue (testing)",
    "description": "Injects a perception event directly into the actor's perception queue\nfor testing purposes. Useful for testing actor behavior without a\nfull game server setup.\n",
    "tags": [],
    "deprecated": false,
    "operationId": "InjectPerception"
}
""";

    /// <summary>Returns endpoint information for InjectPerception</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/inject-perception/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> InjectPerception_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/inject-perception",
            _InjectPerception_Info));

    /// <summary>Returns request schema for InjectPerception</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/inject-perception/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> InjectPerception_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/inject-perception",
            "request-schema",
            _InjectPerception_RequestSchema));

    /// <summary>Returns response schema for InjectPerception</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/inject-perception/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> InjectPerception_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/inject-perception",
            "response-schema",
            _InjectPerception_ResponseSchema));

    /// <summary>Returns full schema for InjectPerception</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/inject-perception/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> InjectPerception_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/inject-perception",
            _InjectPerception_Info,
            _InjectPerception_RequestSchema,
            _InjectPerception_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryOptions

    private static readonly string _QueryOptions_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryOptionsRequest",
    "$defs": {
        "QueryOptionsRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Query an actor for its available options. Options are maintained by the actor\ nin its state.memories.{queryType}_options and returned based on requested freshness.\n",
            "required": [
                "actorId",
                "queryType"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "ID of the actor to query"
                },
                "queryType": {
                    "$ref": "#/$defs/OptionsQueryType",
                    "description": "Type of options to query"
                },
                "freshness": {
                    "$ref": "#/$defs/OptionsFreshness",
                    "description": "Requested freshness level. Defaults to 'cached'.\n- fresh: Inject context and wait for actor to recompute\n- cached: Return cached options if within maxAgeMs\n- stale_ok: Return whatever is cached, even if expired\n"
                },
                "maxAgeMs": {
                    "type": "integer",
                    "minimum": 0,
                    "maximum": 60000,
                    "nullable": true,
                    "description": "Maximum age of cached options in milliseconds (for 'cached' freshness).\nDefaults to 5000ms. If cached options are older, behavior depends on\nfreshness level.\n"
                },
                "context": {
                    "$ref": "#/$defs/OptionsQueryContext",
                    "nullable": true,
                    "description": "Optional context for the query. When provided with freshness='fresh',\nthis context is injected as a perception to the actor, triggering\ncontext-sensitive option recomputation.\n"
                }
            }
        },
        "OptionsQueryType": {
            "type": "string",
            "description": "Type of options to query. Actors maintain options in state.memories.{type}_options.\ nWell-known types are defined; actors can also expose custom types.\n",
            "enum": [
                "combat",
                "dialogue",
                "exploration",
                "social",
                "custom"
            ]
        },
        "OptionsFreshness": {
            "type": "string",
            "description": "Controls caching behavior for options queries",
            "enum": [
                "fresh",
                "cached",
                "stale_ok"
            ],
            "default": "cached"
        },
        "OptionsQueryContext": {
            "type": "object",
            "additionalProperties": true,
            "description": "Context provided with a fresh query. Injected as a perception to the actor\nto trigger context-sensitive option recomputation.\n",
            "properties": {
                "combatState": {
                    "type": "string",
                    "nullable": true,
                    "description": "Current combat state (approaching, engaged, retreating, etc.)"
                },
                "opponentIds": {
                    "type": "array",
                    "nullable": true,
                    "description": "IDs of opponents in the current encounter",
                    "items": {
                        "type": "string"
                    }
                },
                "allyIds": {
                    "type": "array",
                    "nullable": true,
                    "description": "IDs of allies in the current encounter",
                    "items": {
                        "type": "string"
                    }
                },
                "environmentTags": {
                    "type": "array",
                    "nullable": true,
                    "description": "Environment tags (indoor, elevated, destructibles, narrow, etc.)",
                    "items": {
                        "type": "string"
                    }
                },
                "urgency": {
                    "type": "number",
                    "format": "float",
                    "minimum": 0,
                    "maximum": 1,
                    "nullable": true,
                    "description": "How urgent is this query (affects option prioritization)"
                },
                "customContext": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Actor-specific context data"
                }
            }
        }
    }
}
""";

    private static readonly string _QueryOptions_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryOptionsResponse",
    "$defs": {
        "QueryOptionsResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing the actor's available options",
            "required": [
                "actorId",
                "queryType",
                "options",
                "computedAt",
                "ageMs"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "ID of the queried actor"
                },
                "queryType": {
                    "$ref": "#/$defs/OptionsQueryType",
                    "description": "Type of options returned"
                },
                "options": {
                    "type": "array",
                    "description": "Available options for the queried type",
                    "items": {
                        "$ref": "#/$defs/ActorOption"
                    }
                },
                "computedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When these options were last computed by the actor"
                },
                "ageMs": {
                    "type": "integer",
                    "description": "Age of options in milliseconds (now - computedAt)"
                },
                "characterContext": {
                    "$ref": "#/$defs/CharacterOptionContext",
                    "nullable": true,
                    "description": "Character-specific context that influenced these options.\nOnly present for character-based actors.\n"
                }
            }
        },
        "OptionsQueryType": {
            "type": "string",
            "description": "Type of options to query. Actors maintain options in state.memories.{type}_options.\nWell-known types are defined; actors can also expose custom types.\n",
            "enum": [
                "combat",
                "dialogue",
                "exploration",
                "social",
                "custom"
            ]
        },
        "ActorOption": {
            "type": "object",
            "additionalProperties": true,
            "description": "A single option available to the actor. The standardized fields enable\nEvent Brain to reason about options; additional fields allow actor-specific data.\n",
            "required": [
                "actionId",
                "preference",
                "available"
            ],
            "properties": {
                "actionId": {
                    "type": "string",
                    "description": "Unique identifier for this action within the option type.\nExamples: \"sword_slash\", \"greet_friendly\", \"climb_wall\"\n"
                },
                "preference": {
                    "type": "number",
                    "format": "float",
                    "minimum": 0,
                    "maximum": 1,
                    "description": "How much the actor prefers this option (0-1), based on personality,\ncombat preferences, current state, etc. Higher = more preferred.\n"
                },
                "risk": {
                    "type": "number",
                    "format": "float",
                    "minimum": 0,
                    "maximum": 1,
                    "nullable": true,
                    "description": "Estimated risk of this action (0=safe, 1=very risky)"
                },
                "available": {
                    "type": "boolean",
                    "description": "Whether this option is currently available (requirements met)"
                },
                "requirements": {
                    "type": "array",
                    "nullable": true,
                    "description": "Requirements that must be met for this option",
                    "items": {
                        "type": "string"
                    }
                },
                "cooldownMs": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Milliseconds until this option becomes available again (if on cooldown)"
                },
                "tags": {
                    "type": "array",
                    "nullable": true,
                    "description": "Tags for categorization (e.g., [\"melee\", \"aggressive\", \"loud\"])",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "CharacterOptionContext": {
            "type": "object",
            "additionalProperties": false,
            "description": "Character-specific context that influenced option computation",
            "properties": {
                "combatStyle": {
                    "type": "string",
                    "nullable": true,
                    "description": "Character's combat style (aggressive, defensive, balanced, etc.)"
                },
                "riskTolerance": {
                    "type": "number",
                    "format": "float",
                    "minimum": 0,
                    "maximum": 1,
                    "nullable": true,
                    "description": "Character's risk tolerance (0=cautious, 1=reckless)"
                },
                "protectAllies": {
                    "type": "boolean",
                    "nullable": true,
                    "description": "Whether character prioritizes ally protection"
                },
                "currentGoal": {
                    "type": "string",
                    "nullable": true,
                    "description": "Character's current primary goal"
                },
                "emotionalState": {
                    "type": "string",
                    "nullable": true,
                    "description": "Character's current dominant emotion"
                }
            }
        }
    }
}
""";

    private static readonly string _QueryOptions_Info = """
{
    "summary": "Query an actor for its available options",
    "description": "Query an actor for its available options (combat, dialogue, exploration, etc.).\nOptions are maintained by the actor in its state and returned based on requested\nfreshness level. This enables Event Brain actors to ask participants \"what can\nyou do?\" for choreography and coordination.\n\nFreshness levels:\n- fresh: Inject context and wait for actor to recompute options\n- cached: Return cached options if within maxAgeMs, else recompute\n- stale_ok: Return cached options regardless of age\n",
    "tags": [],
    "deprecated": false,
    "operationId": "QueryOptions"
}
""";

    /// <summary>Returns endpoint information for QueryOptions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/query-options/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryOptions_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/query-options",
            _QueryOptions_Info));

    /// <summary>Returns request schema for QueryOptions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/query-options/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryOptions_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/query-options",
            "request-schema",
            _QueryOptions_RequestSchema));

    /// <summary>Returns response schema for QueryOptions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/query-options/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryOptions_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/query-options",
            "response-schema",
            _QueryOptions_ResponseSchema));

    /// <summary>Returns full schema for QueryOptions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/query-options/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryOptions_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/query-options",
            _QueryOptions_Info,
            _QueryOptions_RequestSchema,
            _QueryOptions_ResponseSchema));

    #endregion

    #region Meta Endpoints for StartEncounter

    private static readonly string _StartEncounter_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/StartEncounterRequest",
    "$defs": {
        "StartEncounterRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to start an encounter managed by an Event Brain actor",
            "required": [
                "actorId",
                "encounterId",
                "encounterType",
                "participants"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "ID of the Event Brain actor that will manage this encounter"
                },
                "encounterId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this encounter"
                },
                "encounterType": {
                    "type": "string",
                    "description": "Type of encounter (e.g., \"combat\", \"conversation\", \"choreography\")"
                },
                "participants": {
                    "type": "array",
                    "description": "Character IDs of participants in the encounter",
                    "items": {
                        "type": "string",
                        "format": "uuid"
                    }
                },
                "initialData": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Optional initial data for the encounter"
                }
            }
        }
    }
}
""";

    private static readonly string _StartEncounter_ResponseSchema = """
{}
""";

    private static readonly string _StartEncounter_Info = """
{
    "summary": "Start an encounter managed by an Event Brain actor",
    "description": "Initializes an encounter with the specified participants. The Event Brain actor\nwill coordinate the encounter, sending instructions to participant NPC Brain actors\nvia their character perception channels.\n",
    "tags": [],
    "deprecated": false,
    "operationId": "StartEncounter"
}
""";

    /// <summary>Returns endpoint information for StartEncounter</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/start/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> StartEncounter_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/encounter/start",
            _StartEncounter_Info));

    /// <summary>Returns request schema for StartEncounter</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/start/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> StartEncounter_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/encounter/start",
            "request-schema",
            _StartEncounter_RequestSchema));

    /// <summary>Returns response schema for StartEncounter</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/start/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> StartEncounter_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/encounter/start",
            "response-schema",
            _StartEncounter_ResponseSchema));

    /// <summary>Returns full schema for StartEncounter</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/start/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> StartEncounter_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/encounter/start",
            _StartEncounter_Info,
            _StartEncounter_RequestSchema,
            _StartEncounter_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateEncounterPhase

    private static readonly string _UpdateEncounterPhase_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateEncounterPhaseRequest",
    "$defs": {
        "UpdateEncounterPhaseRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to update the phase of an active encounter",
            "required": [
                "actorId",
                "phase"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "ID of the Event Brain actor managing the encounter"
                },
                "phase": {
                    "type": "string",
                    "description": "New phase name for the encounter"
                }
            }
        }
    }
}
""";

    private static readonly string _UpdateEncounterPhase_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateEncounterPhaseResponse",
    "$defs": {
        "UpdateEncounterPhaseResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response after updating encounter phase",
            "required": [
                "actorId",
                "currentPhase"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "ID of the actor managing the encounter"
                },
                "previousPhase": {
                    "type": "string",
                    "nullable": true,
                    "description": "Previous phase name"
                },
                "currentPhase": {
                    "type": "string",
                    "description": "Current phase name after update"
                }
            }
        }
    }
}
""";

    private static readonly string _UpdateEncounterPhase_Info = """
{
    "summary": "Update the phase of an active encounter",
    "description": "Updates the phase of an encounter being managed by an Event Brain actor.\nPhase changes are logged and can trigger behavior changes in participant actors.\n",
    "tags": [],
    "deprecated": false,
    "operationId": "UpdateEncounterPhase"
}
""";

    /// <summary>Returns endpoint information for UpdateEncounterPhase</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/update-phase/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateEncounterPhase_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/encounter/update-phase",
            _UpdateEncounterPhase_Info));

    /// <summary>Returns request schema for UpdateEncounterPhase</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/update-phase/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateEncounterPhase_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/encounter/update-phase",
            "request-schema",
            _UpdateEncounterPhase_RequestSchema));

    /// <summary>Returns response schema for UpdateEncounterPhase</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/update-phase/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateEncounterPhase_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/encounter/update-phase",
            "response-schema",
            _UpdateEncounterPhase_ResponseSchema));

    /// <summary>Returns full schema for UpdateEncounterPhase</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/update-phase/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateEncounterPhase_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/encounter/update-phase",
            _UpdateEncounterPhase_Info,
            _UpdateEncounterPhase_RequestSchema,
            _UpdateEncounterPhase_ResponseSchema));

    #endregion

    #region Meta Endpoints for EndEncounter

    private static readonly string _EndEncounter_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/EndEncounterRequest",
    "$defs": {
        "EndEncounterRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to end an active encounter",
            "required": [
                "actorId"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "ID of the Event Brain actor managing the encounter"
                }
            }
        }
    }
}
""";

    private static readonly string _EndEncounter_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/EndEncounterResponse",
    "$defs": {
        "EndEncounterResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response after ending an encounter",
            "required": [
                "actorId",
                "encounterId"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "ID of the actor"
                },
                "encounterId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the ended encounter"
                },
                "durationMs": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Duration of the encounter in milliseconds"
                }
            }
        }
    }
}
""";

    private static readonly string _EndEncounter_Info = """
{
    "summary": "End an active encounter",
    "description": "Ends an encounter being managed by an Event Brain actor. This clears the\nencounter state and allows the actor to manage a new encounter.\n",
    "tags": [],
    "deprecated": false,
    "operationId": "EndEncounter"
}
""";

    /// <summary>Returns endpoint information for EndEncounter</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/end/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> EndEncounter_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/encounter/end",
            _EndEncounter_Info));

    /// <summary>Returns request schema for EndEncounter</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/end/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> EndEncounter_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/encounter/end",
            "request-schema",
            _EndEncounter_RequestSchema));

    /// <summary>Returns response schema for EndEncounter</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/end/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> EndEncounter_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/encounter/end",
            "response-schema",
            _EndEncounter_ResponseSchema));

    /// <summary>Returns full schema for EndEncounter</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/end/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> EndEncounter_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/encounter/end",
            _EndEncounter_Info,
            _EndEncounter_RequestSchema,
            _EndEncounter_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetEncounter

    private static readonly string _GetEncounter_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetEncounterRequest",
    "$defs": {
        "GetEncounterRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to get the current encounter state for an actor",
            "required": [
                "actorId"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "ID of the Event Brain actor to query"
                }
            }
        }
    }
}
""";

    private static readonly string _GetEncounter_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetEncounterResponse",
    "$defs": {
        "GetEncounterResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing the current encounter state",
            "required": [
                "actorId",
                "hasActiveEncounter"
            ],
            "properties": {
                "actorId": {
                    "type": "string",
                    "description": "ID of the queried actor"
                },
                "hasActiveEncounter": {
                    "type": "boolean",
                    "description": "Whether the actor is currently managing an encounter"
                },
                "encounter": {
                    "nullable": true,
                    "description": "Current encounter state (null if no active encounter)",
                    "$ref": "#/$defs/EncounterState"
                }
            }
        },
        "EncounterState": {
            "type": "object",
            "additionalProperties": false,
            "description": "State of an active encounter being managed by an Event Brain actor",
            "required": [
                "encounterId",
                "encounterType",
                "participants",
                "phase",
                "startedAt"
            ],
            "properties": {
                "encounterId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this encounter"
                },
                "encounterType": {
                    "type": "string",
                    "description": "Type of encounter"
                },
                "participants": {
                    "type": "array",
                    "description": "Character IDs participating in the encounter",
                    "items": {
                        "type": "string",
                        "format": "uuid"
                    }
                },
                "phase": {
                    "type": "string",
                    "description": "Current phase of the encounter"
                },
                "startedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the encounter started"
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Custom encounter-specific data"
                }
            }
        }
    }
}
""";

    private static readonly string _GetEncounter_Info = """
{
    "summary": "Get the current encounter state for an actor",
    "description": "Retrieves the current encounter state for an Event Brain actor. Returns\nnull encounter data if the actor is not managing an encounter.\n",
    "tags": [],
    "deprecated": false,
    "operationId": "GetEncounter"
}
""";

    /// <summary>Returns endpoint information for GetEncounter</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetEncounter_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Actor",
            "POST",
            "/actor/encounter/get",
            _GetEncounter_Info));

    /// <summary>Returns request schema for GetEncounter</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetEncounter_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/encounter/get",
            "request-schema",
            _GetEncounter_RequestSchema));

    /// <summary>Returns response schema for GetEncounter</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetEncounter_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Actor",
            "POST",
            "/actor/encounter/get",
            "response-schema",
            _GetEncounter_ResponseSchema));

    /// <summary>Returns full schema for GetEncounter</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/actor/encounter/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetEncounter_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Actor",
            "POST",
            "/actor/encounter/get",
            _GetEncounter_Info,
            _GetEncounter_RequestSchema,
            _GetEncounter_ResponseSchema));

    #endregion
}
