//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace BeyondImmersion.BannouService.Mapping;

/// <summary>
/// Meta/introspection endpoints for runtime schema access.
/// Generated from schemas/Generated/mapping-api-meta.yaml
/// </summary>
public partial class MappingController
{
    #region Meta Endpoints for CreateChannel

    private static readonly string _CreateChannel_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateChannelRequest",
    "$defs": {
        "CreateChannelRequest": {
            "type": "object",
            "description": "Request to create a new map channel",
            "required": [
                "regionId",
                "kind",
                "sourceAppId"
            ],
            "properties": {
                "sourceAppId": {
                    "type": "string",
                    "description": "App-id of the caller taking authority (used for event metadata)"
                },
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region for this channel"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind for this channel"
                },
                "nonAuthorityHandling": {
                    "$ref": "#/$defs/NonAuthorityHandlingMode",
                    "description": "How to handle non-authority publishes"
                },
                "takeoverMode": {
                    "$ref": "#/$defs/AuthorityTakeoverMode",
                    "description": "Policy for authority takeover when channel exists with expired authority.\npreserve_and_diff (default): Keep existing data, new authority sends updates.\nreset: Clear all channel data before new authority takes over.\nrequire_consume: New authority must call RequestSnapshot before publishing.\n"
                },
                "alertConfig": {
                    "$ref": "#/$defs/NonAuthorityAlertConfig",
                    "description": "Configuration for non-authority publish alerts",
                    "nullable": true
                },
                "initialSnapshot": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapPayload"
                    },
                    "description": "Optional initial data to populate channel",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "NonAuthorityHandlingMode": {
            "type": "string",
            "description": "How to handle publish attempts from non-authority sources",
            "enum": [
                "reject_and_alert",
                "accept_and_alert",
                "reject_silent"
            ],
            "default": "reject_and_alert"
        },
        "AuthorityTakeoverMode": {
            "type": "string",
            "description": "Policy for handling authority takeover when creating a channel that\nalready has expired authority. Controls what happens to existing data.\n",
            "enum": [
                "preserve_and_diff",
                "reset",
                "require_consume"
            ],
            "default": "preserve_and_diff"
        },
        "NonAuthorityAlertConfig": {
            "type": "object",
            "description": "Configuration for non-authority publish alerts",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether to emit warning events"
                },
                "alertTopic": {
                    "type": "string",
                    "description": "Custom topic for warnings (default map.warnings.unauthorized-publish)",
                    "nullable": true
                },
                "includePayloadSummary": {
                    "type": "boolean",
                    "default": false,
                    "description": "Include truncated payload in warning for debugging"
                }
            }
        },
        "MapPayload": {
            "type": "object",
            "description": "Schema-less payload. Only envelope fields are validated.\nThe 'data' field can contain ANYTHING the publisher wants.\nlib-mapping does not validate contents - only publisher and consumer care.\n",
            "required": [
                "objectType"
            ],
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique ID for this object (generated if not provided)"
                },
                "objectType": {
                    "type": "string",
                    "description": "Publisher-defined type (used for indexing and filtering)"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Position for point objects",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Bounds for area objects",
                    "nullable": true
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Game-specific spatial object data. lib-mapping stores and returns this as-is. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateChannel_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthorityGrant",
    "$defs": {
        "AuthorityGrant": {
            "type": "object",
            "description": "Granted authority over a map channel",
            "required": [
                "channelId",
                "authorityToken",
                "ingestTopic",
                "expiresAt",
                "regionId",
                "kind"
            ],
            "properties": {
                "channelId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "The channel (region+kind) you have authority over"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Opaque token proving your authority (include in publishes)"
                },
                "ingestTopic": {
                    "type": "string",
                    "description": "Topic for direct lib-messaging publishes (map.ingest.{channelId})"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When authority expires (must heartbeat to extend)"
                },
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region ID for this channel"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind for this channel"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\ nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        }
    }
}
""";

    private static readonly string _CreateChannel_Info = """
{
    "summary": "Create a new map channel and become its authority",
    "description": "Creates a new region+kind channel and grants authority to caller.\nReturns ingestTopic for high-throughput event publishing.\nIf channel already exists with active authority, returns Conflict.\n",
    "tags": [
        "Authority"
    ],
    "deprecated": false,
    "operationId": "createChannel"
}
""";

    /// <summary>Returns endpoint information for CreateChannel</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/create-channel/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateChannel_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/create-channel",
            _CreateChannel_Info));

    /// <summary>Returns request schema for CreateChannel</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/create-channel/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateChannel_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/create-channel",
            "request-schema",
            _CreateChannel_RequestSchema));

    /// <summary>Returns response schema for CreateChannel</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/create-channel/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateChannel_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/create-channel",
            "response-schema",
            _CreateChannel_ResponseSchema));

    /// <summary>Returns full schema for CreateChannel</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/create-channel/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateChannel_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/create-channel",
            _CreateChannel_Info,
            _CreateChannel_RequestSchema,
            _CreateChannel_ResponseSchema));

    #endregion

    #region Meta Endpoints for ReleaseAuthority

    private static readonly string _ReleaseAuthority_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ReleaseAuthorityRequest",
    "$defs": {
        "ReleaseAuthorityRequest": {
            "type": "object",
            "description": "Request to release authority over a channel",
            "required": [
                "channelId",
                "authorityToken"
            ],
            "properties": {
                "channelId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Channel to release"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Current authority token"
                }
            }
        }
    }
}
""";

    private static readonly string _ReleaseAuthority_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ReleaseAuthorityResponse",
    "$defs": {
        "ReleaseAuthorityResponse": {
            "type": "object",
            "description": "Response to authority release",
            "properties": {
                "released": {
                    "type": "boolean",
                    "description": "Whether authority was successfully released"
                }
            }
        }
    }
}
""";

    private static readonly string _ReleaseAuthority_Info = """
{
    "summary": "Release authority over a channel",
    "description": "Voluntarily releases authority. Channel becomes unassigned.\nOnly the current authority can release.\n",
    "tags": [
        "Authority"
    ],
    "deprecated": false,
    "operationId": "releaseAuthority"
}
""";

    /// <summary>Returns endpoint information for ReleaseAuthority</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/release-authority/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthority_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/release-authority",
            _ReleaseAuthority_Info));

    /// <summary>Returns request schema for ReleaseAuthority</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/release-authority/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthority_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/release-authority",
            "request-schema",
            _ReleaseAuthority_RequestSchema));

    /// <summary>Returns response schema for ReleaseAuthority</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/release-authority/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthority_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/release-authority",
            "response-schema",
            _ReleaseAuthority_ResponseSchema));

    /// <summary>Returns full schema for ReleaseAuthority</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/release-authority/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthority_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/release-authority",
            _ReleaseAuthority_Info,
            _ReleaseAuthority_RequestSchema,
            _ReleaseAuthority_ResponseSchema));

    #endregion

    #region Meta Endpoints for AuthorityHeartbeat

    private static readonly string _AuthorityHeartbeat_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthorityHeartbeatRequest",
    "$defs": {
        "AuthorityHeartbeatRequest": {
            "type": "object",
            "description": "Request to maintain authority",
            "required": [
                "channelId",
                "authorityToken"
            ],
            "properties": {
                "channelId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Channel to heartbeat"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Current authority token"
                }
            }
        }
    }
}
""";

    private static readonly string _AuthorityHeartbeat_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthorityHeartbeatResponse",
    "$defs": {
        "AuthorityHeartbeatResponse": {
            "type": "object",
            "description": "Response to authority heartbeat",
            "properties": {
                "valid": {
                    "type": "boolean",
                    "description": "Whether your authority is still valid"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Updated expiration time"
                },
                "warning": {
                    "type": "string",
                    "description": "Optional warning (e.g., \"authority expiring soon\")",
                    "nullable": true
                }
            }
        }
    }
}
""";

    private static readonly string _AuthorityHeartbeat_Info = """
{
    "summary": "Maintain authority over channel",
    "description": "Keep-alive for authority. Must be called periodically (default every 30s).\nFailure to heartbeat results in authority expiration.\n",
    "tags": [
        "Authority"
    ],
    "deprecated": false,
    "operationId": "authorityHeartbeat"
}
""";

    /// <summary>Returns endpoint information for AuthorityHeartbeat</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authority-heartbeat/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AuthorityHeartbeat_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/authority-heartbeat",
            _AuthorityHeartbeat_Info));

    /// <summary>Returns request schema for AuthorityHeartbeat</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authority-heartbeat/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AuthorityHeartbeat_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/authority-heartbeat",
            "request-schema",
            _AuthorityHeartbeat_RequestSchema));

    /// <summary>Returns response schema for AuthorityHeartbeat</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authority-heartbeat/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AuthorityHeartbeat_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/authority-heartbeat",
            "response-schema",
            _AuthorityHeartbeat_ResponseSchema));

    /// <summary>Returns full schema for AuthorityHeartbeat</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authority-heartbeat/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AuthorityHeartbeat_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/authority-heartbeat",
            _AuthorityHeartbeat_Info,
            _AuthorityHeartbeat_RequestSchema,
            _AuthorityHeartbeat_ResponseSchema));

    #endregion

    #region Meta Endpoints for PublishMapUpdate

    private static readonly string _PublishMapUpdate_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/PublishMapUpdateRequest",
    "$defs": {
        "PublishMapUpdateRequest": {
            "type": "object",
            "description": "Request to publish map data update",
            "required": [
                "channelId",
                "authorityToken",
                "payload"
            ],
            "properties": {
                "channelId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Channel to publish to"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Authority token for validation"
                },
                "sourceAppId": {
                    "type": "string",
                    "description": "App-id of caller (for warnings on non-authority attempts)",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Affected area (null means entire region)",
                    "nullable": true
                },
                "deltaType": {
                    "$ref": "#/$defs/DeltaType",
                    "description": "Whether this is incremental or full"
                },
                "payload": {
                    "$ref": "#/$defs/MapPayload",
                    "description": "The payload to publish"
                },
                "payloadAssetRef": {
                    "type": "string",
                    "description": "For large payloads, lib-asset reference instead of inline",
                    "nullable": true
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "DeltaType": {
            "type": "string",
            "description": "Whether an update is incremental or a full snapshot",
            "enum": [
                "delta",
                "snapshot"
            ],
            "default": "delta"
        },
        "MapPayload": {
            "type": "object",
            "description": "Schema-less payload. Only envelope fields are validated.\nThe 'data' field can contain ANYTHING the publisher wants.\nlib-mapping does not validate contents - only publisher and consumer care.\n",
            "required": [
                "objectType"
            ],
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique ID for this object (generated if not provided)"
                },
                "objectType": {
                    "type": "string",
                    "description": "Publisher-defined type (used for indexing and filtering)"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Position for point objects",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Bounds for area objects",
                    "nullable": true
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Game-specific spatial object data. lib-mapping stores and returns this as-is. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                }
            }
        }
    }
}
""";

    private static readonly string _PublishMapUpdate_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/PublishMapUpdateResponse",
    "$defs": {
        "PublishMapUpdateResponse": {
            "type": "object",
            "description": "Response to publish request",
            "properties": {
                "accepted": {
                    "type": "boolean",
                    "description": "Whether the update was accepted"
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Assigned version number"
                },
                "warning": {
                    "type": "string",
                    "description": "Optional warning message",
                    "nullable": true
                }
            }
        }
    }
}
""";

    private static readonly string _PublishMapUpdate_Info = """
{
    "summary": "Publish map data update (RPC path)",
    "description": "Game servers use this to push authoritative spatial updates.\nValidates authority token, stores update, and broadcasts to consumers.\ nFor high-throughput scenarios, use event publishing via ingestTopic instead.\n",
    "tags": [
        "Runtime"
    ],
    "deprecated": false,
    "operationId": "publishMapUpdate"
}
""";

    /// <summary>Returns endpoint information for PublishMapUpdate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/publish/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishMapUpdate_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/publish",
            _PublishMapUpdate_Info));

    /// <summary>Returns request schema for PublishMapUpdate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/publish/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishMapUpdate_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/publish",
            "request-schema",
            _PublishMapUpdate_RequestSchema));

    /// <summary>Returns response schema for PublishMapUpdate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/publish/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishMapUpdate_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/publish",
            "response-schema",
            _PublishMapUpdate_ResponseSchema));

    /// <summary>Returns full schema for PublishMapUpdate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/publish/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishMapUpdate_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/publish",
            _PublishMapUpdate_Info,
            _PublishMapUpdate_RequestSchema,
            _PublishMapUpdate_ResponseSchema));

    #endregion

    #region Meta Endpoints for PublishObjectChanges

    private static readonly string _PublishObjectChanges_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/PublishObjectChangesRequest",
    "$defs": {
        "PublishObjectChangesRequest": {
            "type": "object",
            "description": "Request to publish object changes (batch)",
            "required": [
                "channelId",
                "authorityToken",
                "changes"
            ],
            "properties": {
                "channelId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Channel to publish to"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Authority token for validation"
                },
                "sourceAppId": {
                    "type": "string",
                    "description": "App-id of caller (for warnings on non-authority attempts)",
                    "nullable": true
                },
                "changes": {
                    "type": "array",
                    "maxItems": 100,
                    "items": {
                        "$ref": "#/$defs/ObjectChange"
                    },
                    "description": "Object changes to publish"
                }
            }
        },
        "ObjectChange": {
            "type": "object",
            "description": "A single change to a map object",
            "required": [
                "objectId",
                "action"
            ],
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the object being changed"
                },
                "action": {
                    "$ref": "#/$defs/ObjectAction",
                    "description": "Type of change"
                },
                "objectType": {
                    "type": "string",
                    "description": "Object type (required for created)",
                    "nullable": true
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Object position (for create/update)",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Object bounds (for create/update)",
                    "nullable": true
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Game-specific object state data. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                }
            }
        },
        "ObjectAction": {
            "type": "string",
            "description": "Type of change to a map object",
            "enum": [
                "created",
                "updated",
                "deleted"
            ]
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        }
    }
}
""";

    private static readonly string _PublishObjectChanges_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/PublishObjectChangesResponse",
    "$defs": {
        "PublishObjectChangesResponse": {
            "type": "object",
            "description": "Response to object changes publish",
            "properties": {
                "accepted": {
                    "type": "boolean",
                    "description": "Whether the changes were accepted"
                },
                "acceptedCount": {
                    "type": "integer",
                    "description": "Number of changes accepted"
                },
                "rejectedCount": {
                    "type": "integer",
                    "description": "Number of changes rejected"
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Assigned version number"
                },
                "warning": {
                    "type": "string",
                    "description": "Optional warning message",
                    "nullable": true
                }
            }
        }
    }
}
""";

    private static readonly string _PublishObjectChanges_Info = """
{
    "summary": "Publish metadata object changes (batch)",
    "description": "Game servers use this to push object state changes.\nEfficiently batches multiple object changes into one event.\nMax 100 changes per request.\n",
    "tags": [
        "Runtime"
    ],
    "deprecated": false,
    "operationId": "publishObjectChanges"
}
""";

    /// <summary>Returns endpoint information for PublishObjectChanges</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/publish-objects/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishObjectChanges_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/publish-objects",
            _PublishObjectChanges_Info));

    /// <summary>Returns request schema for PublishObjectChanges</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/publish-objects/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishObjectChanges_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/publish-objects",
            "request-schema",
            _PublishObjectChanges_RequestSchema));

    /// <summary>Returns response schema for PublishObjectChanges</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/publish-objects/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishObjectChanges_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/publish-objects",
            "response-schema",
            _PublishObjectChanges_ResponseSchema));

    /// <summary>Returns full schema for PublishObjectChanges</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/publish-objects/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishObjectChanges_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/publish-objects",
            _PublishObjectChanges_Info,
            _PublishObjectChanges_RequestSchema,
            _PublishObjectChanges_ResponseSchema));

    #endregion

    #region Meta Endpoints for RequestSnapshot

    private static readonly string _RequestSnapshot_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RequestSnapshotRequest",
    "$defs": {
        "RequestSnapshotRequest": {
            "type": "object",
            "description": "Request for full snapshot",
            "required": [
                "regionId"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region to snapshot"
                },
                "kinds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapKind"
                    },
                    "description": "Which kinds to include (default all)",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Optional bounds filter",
                    "nullable": true
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Optional authority token. If provided and valid, clears the\nRequiresConsumeBeforePublish flag for require_consume takeover mode.\n",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _RequestSnapshot_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RequestSnapshotResponse",
    "$defs": {
        "RequestSnapshotResponse": {
            "type": "object",
            "description": "Snapshot response",
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region ID"
                },
                "objects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapObject"
                    },
                    "description": "All objects in snapshot"
                },
                "payloadRef": {
                    "type": "string",
                    "description": "For large snapshots, lib-asset reference",
                    "nullable": true
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Snapshot version"
                }
            }
        },
        "MapObject": {
            "type": "object",
            "description": "A stored map object with full metadata",
            "required": [
                "objectId",
                "regionId",
                "kind",
                "objectType",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this object"
                },
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region this object belongs to"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind this object is stored under"
                },
                "objectType": {
                    "type": "string",
                    "description": "Publisher-defined type"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Position for point objects",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Bounding box for area objects",
                    "nullable": true
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Game-specific spatial object data. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Monotonic version for ordering"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was last updated"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        }
    }
}
""";

    private static readonly string _RequestSnapshot_Info = """
{
    "summary": "Request full snapshot for cold start",
    "description": "Consumers use this when starting up to get initial state.\nReturns current snapshot of requested region/kinds.\nFor very large maps, payloadRef points to lib-asset storage.\n",
    "tags": [
        "Runtime"
    ],
    "deprecated": false,
    "operationId": "requestSnapshot"
}
""";

    /// <summary>Returns endpoint information for RequestSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/request-snapshot/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestSnapshot_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/request-snapshot",
            _RequestSnapshot_Info));

    /// <summary>Returns request schema for RequestSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/request-snapshot/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestSnapshot_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/request-snapshot",
            "request-schema",
            _RequestSnapshot_RequestSchema));

    /// <summary>Returns response schema for RequestSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/request-snapshot/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestSnapshot_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/request-snapshot",
            "response-schema",
            _RequestSnapshot_ResponseSchema));

    /// <summary>Returns full schema for RequestSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/request-snapshot/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestSnapshot_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/request-snapshot",
            _RequestSnapshot_Info,
            _RequestSnapshot_RequestSchema,
            _RequestSnapshot_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryPoint

    private static readonly string _QueryPoint_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryPointRequest",
    "$defs": {
        "QueryPointRequest": {
            "type": "object",
            "description": "Query map data at a point",
            "required": [
                "regionId",
                "position"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region to query"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Point to query at"
                },
                "kinds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapKind"
                    },
                    "description": "Kinds to query (default all)",
                    "nullable": true
                },
                "radius": {
                    "type": "number",
                    "description": "Include objects within this radius",
                    "nullable": true
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        }
    }
}
""";

    private static readonly string _QueryPoint_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryPointResponse",
    "$defs": {
        "QueryPointResponse": {
            "type": "object",
            "description": "Point query results",
            "properties": {
                "objects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapObject"
                    },
                    "description": "Objects at/near the point"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Queried position"
                },
                "radius": {
                    "type": "number",
                    "description": "Applied radius filter",
                    "nullable": true
                }
            }
        },
        "MapObject": {
            "type": "object",
            "description": "A stored map object with full metadata",
            "required": [
                "objectId",
                "regionId",
                "kind",
                "objectType",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this object"
                },
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region this object belongs to"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind this object is stored under"
                },
                "objectType": {
                    "type": "string",
                    "description": "Publisher-defined type"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Position for point objects",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Bounding box for area objects",
                    "nullable": true
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Game-specific spatial object data. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Monotonic version for ordering"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was last updated"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\ nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        }
    }
}
""";

    private static readonly string _QueryPoint_Info = """
{
    "summary": "Query map data at a specific point",
    "description": "Returns all map data at a point across requested kinds.\nUsed by behavior stacks for contextual decisions.\nOptionally includes objects within radius.\n",
    "tags": [
        "Query"
    ],
    "deprecated": false,
    "operationId": "queryPoint"
}
""";

    /// <summary>Returns endpoint information for QueryPoint</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/point/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryPoint_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/query/point",
            _QueryPoint_Info));

    /// <summary>Returns request schema for QueryPoint</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/point/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryPoint_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/query/point",
            "request-schema",
            _QueryPoint_RequestSchema));

    /// <summary>Returns response schema for QueryPoint</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/point/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryPoint_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/query/point",
            "response-schema",
            _QueryPoint_ResponseSchema));

    /// <summary>Returns full schema for QueryPoint</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/point/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryPoint_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/query/point",
            _QueryPoint_Info,
            _QueryPoint_RequestSchema,
            _QueryPoint_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryBounds

    private static readonly string _QueryBounds_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryBoundsRequest",
    "$defs": {
        "QueryBoundsRequest": {
            "type": "object",
            "description": "Query map data within bounds",
            "required": [
                "regionId",
                "bounds"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region to query"
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Bounding box to query"
                },
                "kinds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapKind"
                    },
                    "description": "Kinds to query (default all)",
                    "nullable": true
                },
                "maxObjects": {
                    "type": "integer",
                    "default": 500,
                    "maximum": 5000,
                    "description": "Maximum objects to return"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        }
    }
}
""";

    private static readonly string _QueryBounds_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryBoundsResponse",
    "$defs": {
        "QueryBoundsResponse": {
            "type": "object",
            "description": "Bounds query results",
            "properties": {
                "objects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapObject"
                    },
                    "description": "Objects within bounds"
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Queried bounds"
                },
                "truncated": {
                    "type": "boolean",
                    "description": "Whether results were truncated"
                }
            }
        },
        "MapObject": {
            "type": "object",
            "description": "A stored map object with full metadata",
            "required": [
                "objectId",
                "regionId",
                "kind",
                "objectType",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this object"
                },
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region this object belongs to"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind this object is stored under"
                },
                "objectType": {
                    "type": "string",
                    "description": "Publisher-defined type"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Position for point objects",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Bounding box for area objects",
                    "nullable": true
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Game-specific spatial object data. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Monotonic version for ordering"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was last updated"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\ nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        }
    }
}
""";

    private static readonly string _QueryBounds_Info = """
{
    "summary": "Query map data within bounds",
    "description": "Returns map data within a bounding box.\nFor event actors needing region overview.\nLimited to maxObjects per kind.\n",
    "tags": [
        "Query"
    ],
    "deprecated": false,
    "operationId": "queryBounds"
}
""";

    /// <summary>Returns endpoint information for QueryBounds</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/bounds/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBounds_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/query/bounds",
            _QueryBounds_Info));

    /// <summary>Returns request schema for QueryBounds</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/bounds/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBounds_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/query/bounds",
            "request-schema",
            _QueryBounds_RequestSchema));

    /// <summary>Returns response schema for QueryBounds</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/bounds/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBounds_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/query/bounds",
            "response-schema",
            _QueryBounds_ResponseSchema));

    /// <summary>Returns full schema for QueryBounds</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/bounds/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBounds_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/query/bounds",
            _QueryBounds_Info,
            _QueryBounds_RequestSchema,
            _QueryBounds_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryObjectsByType

    private static readonly string _QueryObjectsByType_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryObjectsByTypeRequest",
    "$defs": {
        "QueryObjectsByTypeRequest": {
            "type": "object",
            "description": "Query objects by type",
            "required": [
                "regionId",
                "objectType"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region to query"
                },
                "objectType": {
                    "type": "string",
                    "description": "Object type to filter by"
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Optional bounds filter",
                    "nullable": true
                },
                "maxObjects": {
                    "type": "integer",
                    "default": 500,
                    "maximum": 5000,
                    "description": "Maximum objects to return"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _QueryObjectsByType_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryObjectsByTypeResponse",
    "$defs": {
        "QueryObjectsByTypeResponse": {
            "type": "object",
            "description": "Object type query results",
            "properties": {
                "objects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapObject"
                    },
                    "description": "Matching objects"
                },
                "objectType": {
                    "type": "string",
                    "description": "Queried object type"
                },
                "truncated": {
                    "type": "boolean",
                    "description": "Whether results were truncated"
                }
            }
        },
        "MapObject": {
            "type": "object",
            "description": "A stored map object with full metadata",
            "required": [
                "objectId",
                "regionId",
                "kind",
                "objectType",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this object"
                },
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region this object belongs to"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind this object is stored under"
                },
                "objectType": {
                    "type": "string",
                    "description": "Publisher-defined type"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Position for point objects",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Bounding box for area objects",
                    "nullable": true
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Game-specific spatial object data. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Monotonic version for ordering"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was last updated"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\ nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        }
    }
}
""";

    private static readonly string _QueryObjectsByType_Info = """
{
    "summary": "Find all objects of a type in region",
    "description": "Returns all objects matching an objectType filter.\nFor event actors asking \"where are all the boulder clusters?\"\n",
    "tags": [
        "Query"
    ],
    "deprecated": false,
    "operationId": "queryObjectsByType"
}
""";

    /// <summary>Returns endpoint information for QueryObjectsByType</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/objects-by-type/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryObjectsByType_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/query/objects-by-type",
            _QueryObjectsByType_Info));

    /// <summary>Returns request schema for QueryObjectsByType</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/objects-by-type/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryObjectsByType_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/query/objects-by-type",
            "request-schema",
            _QueryObjectsByType_RequestSchema));

    /// <summary>Returns response schema for QueryObjectsByType</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/objects-by-type/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryObjectsByType_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/query/objects-by-type",
            "response-schema",
            _QueryObjectsByType_ResponseSchema));

    /// <summary>Returns full schema for QueryObjectsByType</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/objects-by-type/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryObjectsByType_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/query/objects-by-type",
            _QueryObjectsByType_Info,
            _QueryObjectsByType_RequestSchema,
            _QueryObjectsByType_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryAffordance

    private static readonly string _QueryAffordance_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AffordanceQueryRequest",
    "$defs": {
        "AffordanceQueryRequest": {
            "type": "object",
            "description": "Query for locations that afford a specific action",
            "required": [
                "regionId",
                "affordanceType"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region to search"
                },
                "affordanceType": {
                    "$ref": "#/$defs/AffordanceType",
                    "description": "Type of affordance to search for"
                },
                "customAffordance": {
                    "$ref": "#/$defs/CustomAffordance",
                    "description": "Custom affordance definition (when affordanceType=custom)",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Optional bounds to search within",
                    "nullable": true
                },
                "maxResults": {
                    "type": "integer",
                    "default": 10,
                    "maximum": 100,
                    "description": "Maximum locations to return"
                },
                "minScore": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 0.5,
                    "description": "Minimum affordance score to include"
                },
                "participantCount": {
                    "type": "integer",
                    "description": "Expected participants (affects space requirements)",
                    "nullable": true
                },
                "excludePositions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/Position3D"
                    },
                    "description": "Positions to exclude (e.g., player's current location)",
                    "nullable": true
                },
                "actorCapabilities": {
                    "$ref": "#/$defs/ActorCapabilities",
                    "description": "Actor capabilities affecting evaluation",
                    "nullable": true
                },
                "freshness": {
                    "$ref": "#/$defs/AffordanceFreshness",
                    "description": "Cache freshness level"
                },
                "maxAgeSeconds": {
                    "type": "integer",
                    "minimum": 0,
                    "maximum": 3600,
                    "description": "Max age of cached results (for cached/aggressive_cache)",
                    "nullable": true
                }
            }
        },
        "AffordanceType": {
            "type": "string",
            "description": "Well-known affordance types with predefined scoring logic.\nUse 'custom' for novel affordance definitions.\n",
            "enum": [
                "ambush",
                "shelter",
                "vista",
                "choke_point",
                "gathering_spot",
                "dramatic_reveal",
                "hidden_path",
                "defensible_position",
                "custom"
            ]
        },
        "CustomAffordance": {
            "type": "object",
            "description": "Custom affordance definition for novel scenarios",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Human-readable description of this affordance",
                    "nullable": true
                },
                "requires": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Game-specific required criteria for affordance matching. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                },
                "prefers": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Game-specific preferred criteria (boost score but not required). No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                },
                "excludes": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Game-specific exclusion criteria for affordance matching. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "ActorCapabilities": {
            "type": "object",
            "description": "Actor-specific capabilities that affect affordance evaluation.\nSame location may afford different actions to different actor types.\n",
            "properties": {
                "size": {
                    "$ref": "#/$defs/ActorSize",
                    "description": "Affects cover requirements and passage width"
                },
                "height": {
                    "type": "number",
                    "description": "Actor height in meters (affects cover, sightlines)",
                    "nullable": true
                },
                "canClimb": {
                    "type": "boolean",
                    "default": false,
                    "description": "Can reach elevated positions"
                },
                "canSwim": {
                    "type": "boolean",
                    "default": false,
                    "description": "Includes water-based positions"
                },
                "canFly": {
                    "type": "boolean",
                    "default": false,
                    "description": "Includes aerial positions"
                },
                "perceptionRange": {
                    "type": "number",
                    "description": "Affects sightline distance requirements",
                    "nullable": true
                },
                "movementSpeed": {
                    "type": "number",
                    "description": "Affects escape route viability calculations",
                    "nullable": true
                },
                "stealthRating": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "description": "Affects ambush/hidden_path affordance scoring",
                    "nullable": true
                }
            }
        },
        "ActorSize": {
            "type": "string",
            "description": "Size classification affecting cover requirements and passage width",
            "enum": [
                "tiny",
                "small",
                "medium",
                "large",
                "huge"
            ],
            "default": "medium"
        },
        "AffordanceFreshness": {
            "type": "string",
            "description": "Controls caching behavior for affordance queries",
            "enum": [
                "fresh",
                "cached",
                "aggressive_cache"
            ],
            "default": "cached"
        }
    }
}
""";

    private static readonly string _QueryAffordance_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AffordanceQueryResponse",
    "$defs": {
        "AffordanceQueryResponse": {
            "type": "object",
            "description": "Affordance query results",
            "properties": {
                "locations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AffordanceLocation"
                    },
                    "description": "Scored locations (highest score first)"
                },
                "queryMetadata": {
                    "$ref": "#/$defs/AffordanceQueryMetadata",
                    "description": "Metadata about query execution (optional)",
                    "nullable": true
                }
            }
        },
        "AffordanceLocation": {
            "type": "object",
            "description": "A location that affords the requested action",
            "properties": {
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Location position"
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Area bounds if affordance spans an area",
                    "nullable": true
                },
                "score": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "description": "How well this location affords the action (0-1)"
                },
                "features": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Game-specific features of this affordance result. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                },
                "objectIds": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "uuid"
                    },
                    "description": "Map objects contributing to this affordance",
                    "nullable": true
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "AffordanceQueryMetadata": {
            "type": "object",
            "description": "Metadata about the affordance query execution",
            "properties": {
                "kindsSearched": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Map kinds that were queried",
                    "nullable": true
                },
                "objectsEvaluated": {
                    "type": "integer",
                    "description": "Number of candidate objects evaluated"
                },
                "candidatesGenerated": {
                    "type": "integer",
                    "description": "Number of candidate positions generated"
                },
                "searchDurationMs": {
                    "type": "integer",
                    "description": "Query execution time in milliseconds"
                },
                "cacheHit": {
                    "type": "boolean",
                    "description": "Whether results came from cache"
                }
            }
        }
    }
}
""";

    private static readonly string _QueryAffordance_Info = """
{
    "summary": "Find locations that afford a specific action or scene type",
    "description": "Affordance queries answer \"where can I do X?\" by combining\nmultiple map kinds and applying game-specific scoring logic.\n\nUsed by Event Brain for procedural scene orchestration:\n- \"Find ambush locations\"\n- \"Find dramatic reveal spots\"\n- \"Find sheltered rest areas\"\n\nWell-known types have predefined scoring; use affordanceType=custom\nwith customAffordance for novel scenarios.\n",
    "tags": [
        "Query"
    ],
    "deprecated": false,
    "operationId": "queryAffordance"
}
""";

    /// <summary>Returns endpoint information for QueryAffordance</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/affordance/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryAffordance_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/query/affordance",
            _QueryAffordance_Info));

    /// <summary>Returns request schema for QueryAffordance</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/affordance/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryAffordance_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/query/affordance",
            "request-schema",
            _QueryAffordance_RequestSchema));

    /// <summary>Returns response schema for QueryAffordance</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/affordance/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryAffordance_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/query/affordance",
            "response-schema",
            _QueryAffordance_ResponseSchema));

    /// <summary>Returns full schema for QueryAffordance</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/query/affordance/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryAffordance_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/query/affordance",
            _QueryAffordance_Info,
            _QueryAffordance_RequestSchema,
            _QueryAffordance_ResponseSchema));

    #endregion

    #region Meta Endpoints for CheckoutForAuthoring

    private static readonly string _CheckoutForAuthoring_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthoringCheckoutRequest",
    "$defs": {
        "AuthoringCheckoutRequest": {
            "type": "object",
            "description": "Request to checkout for authoring",
            "required": [
                "regionId",
                "kind",
                "editorId"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region to checkout"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind to checkout"
                },
                "editorId": {
                    "type": "string",
                    "description": "Identifier for the editor/user"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        }
    }
}
""";

    private static readonly string _CheckoutForAuthoring_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthoringCheckoutResponse",
    "$defs": {
        "AuthoringCheckoutResponse": {
            "type": "object",
            "description": "Checkout response",
            "properties": {
                "authorityToken": {
                    "type": "string",
                    "description": "Token for publishing changes (if successful)",
                    "nullable": true
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the checkout expires",
                    "nullable": true
                },
                "lockedBy": {
                    "type": "string",
                    "description": "Who has the lock (if checkout failed)",
                    "nullable": true
                },
                "lockedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the lock was acquired (if checkout failed)",
                    "nullable": true
                }
            }
        }
    }
}
""";

    private static readonly string _CheckoutForAuthoring_Info = """
{
    "summary": "Acquire exclusive edit lock for design-time editing",
    "description": "For level editors and design tools only.\nGame servers do NOT use this - they use create-channel for implicit authority.\nReturns authority token for publishing edits.\n",
    "tags": [
        "Authoring"
    ],
    "deprecated": false,
    "operationId": "checkoutForAuthoring"
}
""";

    /// <summary>Returns endpoint information for CheckoutForAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authoring/checkout/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckoutForAuthoring_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/authoring/checkout",
            _CheckoutForAuthoring_Info));

    /// <summary>Returns request schema for CheckoutForAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authoring/checkout/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckoutForAuthoring_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/authoring/checkout",
            "request-schema",
            _CheckoutForAuthoring_RequestSchema));

    /// <summary>Returns response schema for CheckoutForAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authoring/checkout/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckoutForAuthoring_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/authoring/checkout",
            "response-schema",
            _CheckoutForAuthoring_ResponseSchema));

    /// <summary>Returns full schema for CheckoutForAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authoring/checkout/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckoutForAuthoring_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/authoring/checkout",
            _CheckoutForAuthoring_Info,
            _CheckoutForAuthoring_RequestSchema,
            _CheckoutForAuthoring_ResponseSchema));

    #endregion

    #region Meta Endpoints for CommitAuthoring

    private static readonly string _CommitAuthoring_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthoringCommitRequest",
    "$defs": {
        "AuthoringCommitRequest": {
            "type": "object",
            "description": "Request to commit authoring changes",
            "required": [
                "regionId",
                "kind",
                "authorityToken"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region being edited"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind being edited"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Checkout authority token"
                },
                "commitMessage": {
                    "type": "string",
                    "description": "Optional commit message for history",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\ nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        }
    }
}
""";

    private static readonly string _CommitAuthoring_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthoringCommitResponse",
    "$defs": {
        "AuthoringCommitResponse": {
            "type": "object",
            "description": "Commit response",
            "properties": {
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Committed version number",
                    "nullable": true
                }
            }
        }
    }
}
""";

    private static readonly string _CommitAuthoring_Info = """
{
    "summary": "Commit design-time changes",
    "description": "Commits pending changes and releases the checkout lock.\nOptionally includes a commit message for history.\n",
    "tags": [
        "Authoring"
    ],
    "deprecated": false,
    "operationId": "commitAuthoring"
}
""";

    /// <summary>Returns endpoint information for CommitAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authoring/commit/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CommitAuthoring_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/authoring/commit",
            _CommitAuthoring_Info));

    /// <summary>Returns request schema for CommitAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authoring/commit/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CommitAuthoring_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/authoring/commit",
            "request-schema",
            _CommitAuthoring_RequestSchema));

    /// <summary>Returns response schema for CommitAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authoring/commit/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CommitAuthoring_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/authoring/commit",
            "response-schema",
            _CommitAuthoring_ResponseSchema));

    /// <summary>Returns full schema for CommitAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authoring/commit/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CommitAuthoring_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/authoring/commit",
            _CommitAuthoring_Info,
            _CommitAuthoring_RequestSchema,
            _CommitAuthoring_ResponseSchema));

    #endregion

    #region Meta Endpoints for ReleaseAuthoring

    private static readonly string _ReleaseAuthoring_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthoringReleaseRequest",
    "$defs": {
        "AuthoringReleaseRequest": {
            "type": "object",
            "description": "Request to release authoring checkout",
            "required": [
                "regionId",
                "kind",
                "authorityToken"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region being edited"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind being edited"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Checkout authority token"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        }
    }
}
""";

    private static readonly string _ReleaseAuthoring_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthoringReleaseResponse",
    "$defs": {
        "AuthoringReleaseResponse": {
            "type": "object",
            "description": "Release response",
            "properties": {
                "released": {
                    "type": "boolean",
                    "description": "Whether checkout was released"
                }
            }
        }
    }
}
""";

    private static readonly string _ReleaseAuthoring_Info = """
{
    "summary": "Release authoring checkout without committing",
    "description": "Discards pending changes and releases the checkout lock.\nUse when abandoning edits.\n",
    "tags": [
        "Authoring"
    ],
    "deprecated": false,
    "operationId": "releaseAuthoring"
}
""";

    /// <summary>Returns endpoint information for ReleaseAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authoring/release/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthoring_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/authoring/release",
            _ReleaseAuthoring_Info));

    /// <summary>Returns request schema for ReleaseAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authoring/release/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthoring_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/authoring/release",
            "request-schema",
            _ReleaseAuthoring_RequestSchema));

    /// <summary>Returns response schema for ReleaseAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authoring/release/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthoring_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/authoring/release",
            "response-schema",
            _ReleaseAuthoring_ResponseSchema));

    /// <summary>Returns full schema for ReleaseAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/authoring/release/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthoring_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/authoring/release",
            _ReleaseAuthoring_Info,
            _ReleaseAuthoring_RequestSchema,
            _ReleaseAuthoring_ResponseSchema));

    #endregion

    #region Meta Endpoints for CreateDefinition

    private static readonly string _CreateDefinition_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateDefinitionRequest",
    "$defs": {
        "CreateDefinitionRequest": {
            "type": "object",
            "description": "Request to create a map definition",
            "required": [
                "name"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Human-readable name"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the map template",
                    "nullable": true
                },
                "layers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/LayerDefinition"
                    },
                    "description": "Layer configurations",
                    "nullable": true
                },
                "defaultBounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Default bounds for regions using this definition",
                    "nullable": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Client-provided definition metadata. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                }
            }
        },
        "LayerDefinition": {
            "type": "object",
            "description": "Configuration for a specific layer within a map definition",
            "required": [
                "kind"
            ],
            "properties": {
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "The layer kind"
                },
                "storageMode": {
                    "type": "string",
                    "enum": [
                        "durable",
                        "cached",
                        "ephemeral"
                    ],
                    "default": "cached",
                    "description": "How this layer's data should be stored"
                },
                "ttlSeconds": {
                    "type": "integer",
                    "description": "TTL for cached/ephemeral data (0 = no TTL)",
                    "nullable": true
                },
                "defaultNonAuthorityHandling": {
                    "$ref": "#/$defs/NonAuthorityHandlingMode",
                    "description": "Default non-authority handling for channels using this layer"
                },
                "cellSize": {
                    "type": "number",
                    "format": "double",
                    "description": "Spatial cell size for indexing (default from config if not set)",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "NonAuthorityHandlingMode": {
            "type": "string",
            "description": "How to handle publish attempts from non-authority sources",
            "enum": [
                "reject_and_alert",
                "accept_and_alert",
                "reject_silent"
            ],
            "default": "reject_and_alert"
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateDefinition_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/MapDefinition",
    "$defs": {
        "MapDefinition": {
            "type": "object",
            "description": "A map definition template that describes the structure of a region",
            "required": [
                "definitionId",
                "name",
                "createdAt"
            ],
            "properties": {
                "definitionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this definition"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable name"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the map template",
                    "nullable": true
                },
                "layers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/LayerDefinition"
                    },
                    "description": "Layer configurations for this map",
                    "nullable": true
                },
                "defaultBounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Default bounds for regions using this definition",
                    "nullable": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Client-provided definition metadata. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was last updated",
                    "nullable": true
                }
            }
        },
        "LayerDefinition": {
            "type": "object",
            "description": "Configuration for a specific layer within a map definition",
            "required": [
                "kind"
            ],
            "properties": {
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "The layer kind"
                },
                "storageMode": {
                    "type": "string",
                    "enum": [
                        "durable",
                        "cached",
                        "ephemeral"
                    ],
                    "default": "cached",
                    "description": "How this layer's data should be stored"
                },
                "ttlSeconds": {
                    "type": "integer",
                    "description": "TTL for cached/ephemeral data (0 = no TTL)",
                    "nullable": true
                },
                "defaultNonAuthorityHandling": {
                    "$ref": "#/$defs/NonAuthorityHandlingMode",
                    "description": "Default non-authority handling for channels using this layer"
                },
                "cellSize": {
                    "type": "number",
                    "format": "double",
                    "description": "Spatial cell size for indexing (default from config if not set)",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "NonAuthorityHandlingMode": {
            "type": "string",
            "description": "How to handle publish attempts from non-authority sources",
            "enum": [
                "reject_and_alert",
                "accept_and_alert",
                "reject_silent"
            ],
            "default": "reject_and_alert"
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateDefinition_Info = """
{
    "summary": "Create a map definition template",
    "description": "Creates a new map definition (template) that describes the structure\nof a region. Definitions are templates that can be used to bootstrap\nchannels with predefined layer configurations.\n",
    "tags": [
        "Definition"
    ],
    "deprecated": false,
    "operationId": "createDefinition"
}
""";

    /// <summary>Returns endpoint information for CreateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDefinition_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/definition/create",
            _CreateDefinition_Info));

    /// <summary>Returns request schema for CreateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDefinition_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/create",
            "request-schema",
            _CreateDefinition_RequestSchema));

    /// <summary>Returns response schema for CreateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDefinition_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/create",
            "response-schema",
            _CreateDefinition_ResponseSchema));

    /// <summary>Returns full schema for CreateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDefinition_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/create",
            _CreateDefinition_Info,
            _CreateDefinition_RequestSchema,
            _CreateDefinition_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetDefinition

    private static readonly string _GetDefinition_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetDefinitionRequest",
    "$defs": {
        "GetDefinitionRequest": {
            "type": "object",
            "description": "Request to get a map definition",
            "required": [
                "definitionId"
            ],
            "properties": {
                "definitionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Definition ID to retrieve"
                }
            }
        }
    }
}
""";

    private static readonly string _GetDefinition_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/MapDefinition",
    "$defs": {
        "MapDefinition": {
            "type": "object",
            "description": "A map definition template that describes the structure of a region",
            "required": [
                "definitionId",
                "name",
                "createdAt"
            ],
            "properties": {
                "definitionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this definition"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable name"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the map template",
                    "nullable": true
                },
                "layers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/LayerDefinition"
                    },
                    "description": "Layer configurations for this map",
                    "nullable": true
                },
                "defaultBounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Default bounds for regions using this definition",
                    "nullable": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Client-provided definition metadata. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was last updated",
                    "nullable": true
                }
            }
        },
        "LayerDefinition": {
            "type": "object",
            "description": "Configuration for a specific layer within a map definition",
            "required": [
                "kind"
            ],
            "properties": {
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "The layer kind"
                },
                "storageMode": {
                    "type": "string",
                    "enum": [
                        "durable",
                        "cached",
                        "ephemeral"
                    ],
                    "default": "cached",
                    "description": "How this layer's data should be stored"
                },
                "ttlSeconds": {
                    "type": "integer",
                    "description": "TTL for cached/ephemeral data (0 = no TTL)",
                    "nullable": true
                },
                "defaultNonAuthorityHandling": {
                    "$ref": "#/$defs/NonAuthorityHandlingMode",
                    "description": "Default non-authority handling for channels using this layer"
                },
                "cellSize": {
                    "type": "number",
                    "format": "double",
                    "description": "Spatial cell size for indexing (default from config if not set)",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "NonAuthorityHandlingMode": {
            "type": "string",
            "description": "How to handle publish attempts from non-authority sources",
            "enum": [
                "reject_and_alert",
                "accept_and_alert",
                "reject_silent"
            ],
            "default": "reject_and_alert"
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _GetDefinition_Info = """
{
    "summary": "Get a map definition by ID",
    "description": "Returns the full map definition including all layer configurations.",
    "tags": [
        "Definition"
    ],
    "deprecated": false,
    "operationId": "getDefinition"
}
""";

    /// <summary>Returns endpoint information for GetDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDefinition_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/definition/get",
            _GetDefinition_Info));

    /// <summary>Returns request schema for GetDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDefinition_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/get",
            "request-schema",
            _GetDefinition_RequestSchema));

    /// <summary>Returns response schema for GetDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDefinition_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/get",
            "response-schema",
            _GetDefinition_ResponseSchema));

    /// <summary>Returns full schema for GetDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDefinition_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/get",
            _GetDefinition_Info,
            _GetDefinition_RequestSchema,
            _GetDefinition_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListDefinitions

    private static readonly string _ListDefinitions_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListDefinitionsRequest",
    "$defs": {
        "ListDefinitionsRequest": {
            "type": "object",
            "description": "Request to list map definitions",
            "properties": {
                "nameFilter": {
                    "type": "string",
                    "description": "Filter by name (partial match)",
                    "nullable": true
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Pagination offset"
                },
                "limit": {
                    "type": "integer",
                    "default": 50,
                    "description": "Max results to return"
                }
            }
        }
    }
}
""";

    private static readonly string _ListDefinitions_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListDefinitionsResponse",
    "$defs": {
        "ListDefinitionsResponse": {
            "type": "object",
            "description": "Response containing list of map definitions",
            "properties": {
                "definitions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapDefinition"
                    },
                    "description": "List of definitions"
                },
                "total": {
                    "type": "integer",
                    "description": "Total count matching filter"
                },
                "offset": {
                    "type": "integer",
                    "description": "Current offset"
                },
                "limit": {
                    "type": "integer",
                    "description": "Results limit used"
                }
            }
        },
        "MapDefinition": {
            "type": "object",
            "description": "A map definition template that describes the structure of a region",
            "required": [
                "definitionId",
                "name",
                "createdAt"
            ],
            "properties": {
                "definitionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this definition"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable name"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the map template",
                    "nullable": true
                },
                "layers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/LayerDefinition"
                    },
                    "description": "Layer configurations for this map",
                    "nullable": true
                },
                "defaultBounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Default bounds for regions using this definition",
                    "nullable": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Client-provided definition metadata. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was last updated",
                    "nullable": true
                }
            }
        },
        "LayerDefinition": {
            "type": "object",
            "description": "Configuration for a specific layer within a map definition",
            "required": [
                "kind"
            ],
            "properties": {
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "The layer kind"
                },
                "storageMode": {
                    "type": "string",
                    "enum": [
                        "durable",
                        "cached",
                        "ephemeral"
                    ],
                    "default": "cached",
                    "description": "How this layer's data should be stored"
                },
                "ttlSeconds": {
                    "type": "integer",
                    "description": "TTL for cached/ephemeral data (0 = no TTL)",
                    "nullable": true
                },
                "defaultNonAuthorityHandling": {
                    "$ref": "#/$defs/NonAuthorityHandlingMode",
                    "description": "Default non-authority handling for channels using this layer"
                },
                "cellSize": {
                    "type": "number",
                    "format": "double",
                    "description": "Spatial cell size for indexing (default from config if not set)",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\ nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "NonAuthorityHandlingMode": {
            "type": "string",
            "description": "How to handle publish attempts from non-authority sources",
            "enum": [
                "reject_and_alert",
                "accept_and_alert",
                "reject_silent"
            ],
            "default": "reject_and_alert"
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _ListDefinitions_Info = """
{
    "summary": "List map definitions with optional filters",
    "description": "Returns a paginated list of map definitions.",
    "tags": [
        "Definition"
    ],
    "deprecated": false,
    "operationId": "listDefinitions"
}
""";

    /// <summary>Returns endpoint information for ListDefinitions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDefinitions_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/definition/list",
            _ListDefinitions_Info));

    /// <summary>Returns request schema for ListDefinitions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDefinitions_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/list",
            "request-schema",
            _ListDefinitions_RequestSchema));

    /// <summary>Returns response schema for ListDefinitions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDefinitions_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/list",
            "response-schema",
            _ListDefinitions_ResponseSchema));

    /// <summary>Returns full schema for ListDefinitions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDefinitions_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/list",
            _ListDefinitions_Info,
            _ListDefinitions_RequestSchema,
            _ListDefinitions_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateDefinition

    private static readonly string _UpdateDefinition_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateDefinitionRequest",
    "$defs": {
        "UpdateDefinitionRequest": {
            "type": "object",
            "description": "Request to update a map definition",
            "required": [
                "definitionId"
            ],
            "properties": {
                "definitionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Definition ID to update"
                },
                "name": {
                    "type": "string",
                    "description": "New name (optional)",
                    "nullable": true
                },
                "description": {
                    "type": "string",
                    "description": "New description (optional)",
                    "nullable": true
                },
                "layers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/LayerDefinition"
                    },
                    "description": "New layer configurations (replaces existing)",
                    "nullable": true
                },
                "defaultBounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "New default bounds",
                    "nullable": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Updated client-provided definition metadata (replaces existing). No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                }
            }
        },
        "LayerDefinition": {
            "type": "object",
            "description": "Configuration for a specific layer within a map definition",
            "required": [
                "kind"
            ],
            "properties": {
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "The layer kind"
                },
                "storageMode": {
                    "type": "string",
                    "enum": [
                        "durable",
                        "cached",
                        "ephemeral"
                    ],
                    "default": "cached",
                    "description": "How this layer's data should be stored"
                },
                "ttlSeconds": {
                    "type": "integer",
                    "description": "TTL for cached/ephemeral data (0 = no TTL)",
                    "nullable": true
                },
                "defaultNonAuthorityHandling": {
                    "$ref": "#/$defs/NonAuthorityHandlingMode",
                    "description": "Default non-authority handling for channels using this layer"
                },
                "cellSize": {
                    "type": "number",
                    "format": "double",
                    "description": "Spatial cell size for indexing (default from config if not set)",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "NonAuthorityHandlingMode": {
            "type": "string",
            "description": "How to handle publish attempts from non-authority sources",
            "enum": [
                "reject_and_alert",
                "accept_and_alert",
                "reject_silent"
            ],
            "default": "reject_and_alert"
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _UpdateDefinition_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/MapDefinition",
    "$defs": {
        "MapDefinition": {
            "type": "object",
            "description": "A map definition template that describes the structure of a region",
            "required": [
                "definitionId",
                "name",
                "createdAt"
            ],
            "properties": {
                "definitionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this definition"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable name"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the map template",
                    "nullable": true
                },
                "layers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/LayerDefinition"
                    },
                    "description": "Layer configurations for this map",
                    "nullable": true
                },
                "defaultBounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Default bounds for regions using this definition",
                    "nullable": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Client-provided definition metadata. No Bannou plugin reads specific keys from this field by convention.",
                    "nullable": true
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was last updated",
                    "nullable": true
                }
            }
        },
        "LayerDefinition": {
            "type": "object",
            "description": "Configuration for a specific layer within a map definition",
            "required": [
                "kind"
            ],
            "properties": {
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "The layer kind"
                },
                "storageMode": {
                    "type": "string",
                    "enum": [
                        "durable",
                        "cached",
                        "ephemeral"
                    ],
                    "default": "cached",
                    "description": "How this layer's data should be stored"
                },
                "ttlSeconds": {
                    "type": "integer",
                    "description": "TTL for cached/ephemeral data (0 = no TTL)",
                    "nullable": true
                },
                "defaultNonAuthorityHandling": {
                    "$ref": "#/$defs/NonAuthorityHandlingMode",
                    "description": "Default non-authority handling for channels using this layer"
                },
                "cellSize": {
                    "type": "number",
                    "format": "double",
                    "description": "Spatial cell size for indexing (default from config if not set)",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "NonAuthorityHandlingMode": {
            "type": "string",
            "description": "How to handle publish attempts from non-authority sources",
            "enum": [
                "reject_and_alert",
                "accept_and_alert",
                "reject_silent"
            ],
            "default": "reject_and_alert"
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _UpdateDefinition_Info = """
{
    "summary": "Update a map definition",
    "description": "Updates an existing map definition. Cannot change the definition ID.\nLayer configurations can be modified.\n",
    "tags": [
        "Definition"
    ],
    "deprecated": false,
    "operationId": "updateDefinition"
}
""";

    /// <summary>Returns endpoint information for UpdateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDefinition_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/definition/update",
            _UpdateDefinition_Info));

    /// <summary>Returns request schema for UpdateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDefinition_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/update",
            "request-schema",
            _UpdateDefinition_RequestSchema));

    /// <summary>Returns response schema for UpdateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDefinition_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/update",
            "response-schema",
            _UpdateDefinition_ResponseSchema));

    /// <summary>Returns full schema for UpdateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDefinition_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/update",
            _UpdateDefinition_Info,
            _UpdateDefinition_RequestSchema,
            _UpdateDefinition_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeleteDefinition

    private static readonly string _DeleteDefinition_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteDefinitionRequest",
    "$defs": {
        "DeleteDefinitionRequest": {
            "type": "object",
            "description": "Request to delete a map definition",
            "required": [
                "definitionId"
            ],
            "properties": {
                "definitionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Definition ID to delete"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteDefinition_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteDefinitionResponse",
    "$defs": {
        "DeleteDefinitionResponse": {
            "type": "object",
            "description": "Response to delete request",
            "properties": {
                "deleted": {
                    "type": "boolean",
                    "description": "Whether the definition was deleted"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteDefinition_Info = """
{
    "summary": "Delete a map definition",
    "description": "Deletes a map definition. Cannot delete if active channels reference it.",
    "tags": [
        "Definition"
    ],
    "deprecated": false,
    "operationId": "deleteDefinition"
}
""";

    /// <summary>Returns endpoint information for DeleteDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDefinition_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "POST",
            "/mapping/definition/delete",
            _DeleteDefinition_Info));

    /// <summary>Returns request schema for DeleteDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDefinition_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/delete",
            "request-schema",
            _DeleteDefinition_RequestSchema));

    /// <summary>Returns response schema for DeleteDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDefinition_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/delete",
            "response-schema",
            _DeleteDefinition_ResponseSchema));

    /// <summary>Returns full schema for DeleteDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/mapping/definition/delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDefinition_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "POST",
            "/mapping/definition/delete",
            _DeleteDefinition_Info,
            _DeleteDefinition_RequestSchema,
            _DeleteDefinition_ResponseSchema));

    #endregion
}
