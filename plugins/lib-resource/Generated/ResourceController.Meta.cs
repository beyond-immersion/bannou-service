//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace BeyondImmersion.BannouService.Resource;

/// <summary>
/// Meta/introspection endpoints for runtime schema access.
/// Generated from schemas/Generated/resource-api-meta.yaml
/// </summary>
public partial class ResourceController
{
    #region Meta Endpoints for RegisterReference

    private static readonly string _RegisterReference_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RegisterReferenceRequest",
    "$defs": {
        "RegisterReferenceRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to register a reference to a resource",
            "required": [
                "resourceType",
                "resourceId",
                "sourceType",
                "sourceId"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource being referenced (opaque identifier, e.g., \"character\", \"realm\")"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource being referenced"
                },
                "sourceType": {
                    "type": "string",
                    "description": "Type of entity holding the reference (opaque identifier, e.g., \"actor\", \"scene\")"
                },
                "sourceId": {
                    "type": "string",
                    "description": "ID of the entity holding the reference (opaque string, supports non-Guid IDs)"
                }
            }
        }
    }
}
""";

    private static readonly string _RegisterReference_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RegisterReferenceResponse",
    "$defs": {
        "RegisterReferenceResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response after registering a reference",
            "required": [
                "resourceType",
                "resourceId",
                "newRefCount",
                "alreadyRegistered"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource referenced"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource referenced"
                },
                "newRefCount": {
                    "type": "integer",
                    "description": "Reference count after registration"
                },
                "alreadyRegistered": {
                    "type": "boolean",
                    "description": "True if this exact reference was already registered"
                }
            }
        }
    }
}
""";

    private static readonly string _RegisterReference_Info = """
{
    "summary": "Register a reference to a resource",
    "description": "Records that sourceType:sourceId references resourceType:resourceId.\nTypically called via event handlers, not directly.\n",
    "tags": [
        "Reference Management"
    ],
    "deprecated": false,
    "operationId": "registerReference"
}
""";

    /// <summary>Returns endpoint information for RegisterReference</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/register/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RegisterReference_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/register",
            _RegisterReference_Info));

    /// <summary>Returns request schema for RegisterReference</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/register/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RegisterReference_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/register",
            "request-schema",
            _RegisterReference_RequestSchema));

    /// <summary>Returns response schema for RegisterReference</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/register/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RegisterReference_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/register",
            "response-schema",
            _RegisterReference_ResponseSchema));

    /// <summary>Returns full schema for RegisterReference</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/register/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RegisterReference_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/register",
            _RegisterReference_Info,
            _RegisterReference_RequestSchema,
            _RegisterReference_ResponseSchema));

    #endregion

    #region Meta Endpoints for UnregisterReference

    private static readonly string _UnregisterReference_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UnregisterReferenceRequest",
    "$defs": {
        "UnregisterReferenceRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to unregister a reference to a resource",
            "required": [
                "resourceType",
                "resourceId",
                "sourceType",
                "sourceId"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource being dereferenced (opaque identifier)"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource being dereferenced"
                },
                "sourceType": {
                    "type": "string",
                    "description": "Type of entity releasing the reference (opaque identifier)"
                },
                "sourceId": {
                    "type": "string",
                    "description": "ID of the entity releasing the reference (opaque string, supports non-Guid IDs)"
                }
            }
        }
    }
}
""";

    private static readonly string _UnregisterReference_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UnregisterReferenceResponse",
    "$defs": {
        "UnregisterReferenceResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response after unregistering a reference",
            "required": [
                "resourceType",
                "resourceId",
                "newRefCount",
                "wasRegistered"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource dereferenced"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource dereferenced"
                },
                "newRefCount": {
                    "type": "integer",
                    "description": "Reference count after unregistration"
                },
                "wasRegistered": {
                    "type": "boolean",
                    "description": "True if this reference existed before unregistration"
                },
                "gracePeriodStartedAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When grace period started (null if refCount > 0)"
                }
            }
        }
    }
}
""";

    private static readonly string _UnregisterReference_Info = """
{
    "summary": "Remove a reference to a resource",
    "description": "Records that sourceType:sourceId no longer references resourceType:resourceId.\nTypically called via event handlers, not directly.\n",
    "tags": [
        "Reference Management"
    ],
    "deprecated": false,
    "operationId": "unregisterReference"
}
""";

    /// <summary>Returns endpoint information for UnregisterReference</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/unregister/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UnregisterReference_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/unregister",
            _UnregisterReference_Info));

    /// <summary>Returns request schema for UnregisterReference</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/unregister/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UnregisterReference_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/unregister",
            "request-schema",
            _UnregisterReference_RequestSchema));

    /// <summary>Returns response schema for UnregisterReference</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/unregister/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UnregisterReference_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/unregister",
            "response-schema",
            _UnregisterReference_ResponseSchema));

    /// <summary>Returns full schema for UnregisterReference</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/unregister/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UnregisterReference_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/unregister",
            _UnregisterReference_Info,
            _UnregisterReference_RequestSchema,
            _UnregisterReference_ResponseSchema));

    #endregion

    #region Meta Endpoints for CheckReferences

    private static readonly string _CheckReferences_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CheckReferencesRequest",
    "$defs": {
        "CheckReferencesRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to check reference status for a resource",
            "required": [
                "resourceType",
                "resourceId"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource to check (opaque identifier)"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource to check"
                }
            }
        }
    }
}
""";

    private static readonly string _CheckReferences_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CheckReferencesResponse",
    "$defs": {
        "CheckReferencesResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing reference status for a resource",
            "required": [
                "resourceType",
                "resourceId",
                "refCount",
                "isCleanupEligible"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource checked"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource checked"
                },
                "refCount": {
                    "type": "integer",
                    "description": "Current reference count"
                },
                "sources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ResourceReference"
                    },
                    "nullable": true,
                    "description": "List of entities referencing this resource (optional, for diagnostics)"
                },
                "isCleanupEligible": {
                    "type": "boolean",
                    "description": "True if refCount=0 and grace period has passed"
                },
                "gracePeriodEndsAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When grace period ends (null if refCount > 0 or already passed)"
                },
                "lastZeroTimestamp": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When refCount last became zero"
                }
            }
        },
        "ResourceReference": {
            "type": "object",
            "additionalProperties": false,
            "description": "A reference from a source entity to a resource",
            "required": [
                "sourceType",
                "sourceId",
                "registeredAt"
            ],
            "properties": {
                "sourceType": {
                    "type": "string",
                    "description": "Type of entity holding the reference (opaque identifier)"
                },
                "sourceId": {
                    "type": "string",
                    "description": "ID of the entity holding the reference (opaque string, supports non-Guid IDs)"
                },
                "registeredAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When this reference was registered"
                }
            }
        }
    }
}
""";

    private static readonly string _CheckReferences_Info = """
{
    "summary": "Check reference count and cleanup eligibility",
    "description": "Returns the current reference count for a resource and whether it is\neligible for cleanup (refcount=0 and grace period passed).\n",
    "tags": [
        "Reference Management"
    ],
    "deprecated": false,
    "operationId": "checkReferences"
}
""";

    /// <summary>Returns endpoint information for CheckReferences</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/check/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckReferences_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/check",
            _CheckReferences_Info));

    /// <summary>Returns request schema for CheckReferences</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/check/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckReferences_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/check",
            "request-schema",
            _CheckReferences_RequestSchema));

    /// <summary>Returns response schema for CheckReferences</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/check/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckReferences_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/check",
            "response-schema",
            _CheckReferences_ResponseSchema));

    /// <summary>Returns full schema for CheckReferences</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/check/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckReferences_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/check",
            _CheckReferences_Info,
            _CheckReferences_RequestSchema,
            _CheckReferences_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListReferences

    private static readonly string _ListReferences_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListReferencesRequest",
    "$defs": {
        "ListReferencesRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to list all references to a resource",
            "required": [
                "resourceType",
                "resourceId"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource to list references for (opaque identifier)"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource to list references for"
                },
                "filterSourceType": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional filter by source type (opaque identifier)"
                },
                "limit": {
                    "type": "integer",
                    "default": 100,
                    "description": "Maximum references to return"
                }
            }
        }
    }
}
""";

    private static readonly string _ListReferences_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListReferencesResponse",
    "$defs": {
        "ListReferencesResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing list of references to a resource",
            "required": [
                "resourceType",
                "resourceId",
                "references",
                "totalCount"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource listed"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource listed"
                },
                "references": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ResourceReference"
                    },
                    "description": "List of references"
                },
                "totalCount": {
                    "type": "integer",
                    "description": "Total reference count (may exceed returned list if limit applied)"
                }
            }
        },
        "ResourceReference": {
            "type": "object",
            "additionalProperties": false,
            "description": "A reference from a source entity to a resource",
            "required": [
                "sourceType",
                "sourceId",
                "registeredAt"
            ],
            "properties": {
                "sourceType": {
                    "type": "string",
                    "description": "Type of entity holding the reference (opaque identifier)"
                },
                "sourceId": {
                    "type": "string",
                    "description": "ID of the entity holding the reference (opaque string, supports non-Guid IDs)"
                },
                "registeredAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When this reference was registered"
                }
            }
        }
    }
}
""";

    private static readonly string _ListReferences_Info = """
{
    "summary": "List all references to a resource",
    "description": "Returns all entities currently referencing a resource.\nUseful for debugging and understanding reference chains.\n",
    "tags": [
        "Reference Management"
    ],
    "deprecated": false,
    "operationId": "listReferences"
}
""";

    /// <summary>Returns endpoint information for ListReferences</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListReferences_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/list",
            _ListReferences_Info));

    /// <summary>Returns request schema for ListReferences</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListReferences_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/list",
            "request-schema",
            _ListReferences_RequestSchema));

    /// <summary>Returns response schema for ListReferences</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListReferences_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/list",
            "response-schema",
            _ListReferences_ResponseSchema));

    /// <summary>Returns full schema for ListReferences</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListReferences_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/list",
            _ListReferences_Info,
            _ListReferences_RequestSchema,
            _ListReferences_ResponseSchema));

    #endregion

    #region Meta Endpoints for DefineCleanupCallback

    private static readonly string _DefineCleanupCallback_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DefineCleanupRequest",
    "$defs": {
        "DefineCleanupRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to define a cleanup callback for a resource type",
            "required": [
                "resourceType",
                "sourceType",
                "callbackEndpoint",
                "payloadTemplate"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource this cleanup handles (opaque identifier)"
                },
                "sourceType": {
                    "type": "string",
                    "description": "Type of entity that will be cleaned up (opaque identifier)"
                },
                "onDeleteAction": {
                    "$ref": "#/$defs/OnDeleteAction",
                    "nullable": true,
                    "description": "Action to take when resource is deleted (defaults to CASCADE if not specified)"
                },
                "serviceName": {
                    "type": "string",
                    "nullable": true,
                    "description": "Target service name for callback invocation via lib-mesh (defaults to sourceType if not specified)"
                },
                "callbackEndpoint": {
                    "type": "string",
                    "description": "Endpoint path (e.g., /actor/cleanup-by-character)"
                },
                "payloadTemplate": {
                    "type": "string",
                    "description": "JSON template with {{resourceId}} placeholder"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Human-readable description of cleanup action"
                }
            }
        },
        "OnDeleteAction": {
            "type": "string",
            "enum": [
                "CASCADE",
                "RESTRICT",
                "DETACH"
            ],
            "description": "Action to take when the referenced resource is deleted.\nCASCADE: Delete dependent entities when resource is deleted\nRESTRICT: Block resource deletion if references exist\nDETACH: Set reference to null when resource is deleted\n"
        }
    }
}
""";

    private static readonly string _DefineCleanupCallback_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DefineCleanupResponse",
    "$defs": {
        "DefineCleanupResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response after defining a cleanup callback",
            "required": [
                "resourceType",
                "sourceType",
                "registered"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Resource type for callback (opaque identifier)"
                },
                "sourceType": {
                    "type": "string",
                    "description": "Source type for callback (opaque identifier)"
                },
                "registered": {
                    "type": "boolean",
                    "description": "True if callback was registered (or updated)"
                },
                "previouslyDefined": {
                    "type": "boolean",
                    "description": "True if this callback was already defined (updated)"
                }
            }
        }
    }
}
""";

    private static readonly string _DefineCleanupCallback_Info = """
{
    "summary": "Define cleanup callbacks for a resource type",
    "description": "Services call this at startup to register their cleanup endpoints.\nWhen a resource is deleted, these callbacks are invoked to clean up\ndependent entities.\n",
    "tags": [
        "Cleanup Management"
    ],
    "deprecated": false,
    "operationId": "defineCleanupCallback"
}
""";

    /// <summary>Returns endpoint information for DefineCleanupCallback</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/define/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DefineCleanupCallback_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/cleanup/define",
            _DefineCleanupCallback_Info));

    /// <summary>Returns request schema for DefineCleanupCallback</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/define/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DefineCleanupCallback_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/cleanup/define",
            "request-schema",
            _DefineCleanupCallback_RequestSchema));

    /// <summary>Returns response schema for DefineCleanupCallback</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/define/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DefineCleanupCallback_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/cleanup/define",
            "response-schema",
            _DefineCleanupCallback_ResponseSchema));

    /// <summary>Returns full schema for DefineCleanupCallback</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/define/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DefineCleanupCallback_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/cleanup/define",
            _DefineCleanupCallback_Info,
            _DefineCleanupCallback_RequestSchema,
            _DefineCleanupCallback_ResponseSchema));

    #endregion

    #region Meta Endpoints for ExecuteCleanup

    private static readonly string _ExecuteCleanup_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ExecuteCleanupRequest",
    "$defs": {
        "ExecuteCleanupRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to execute cleanup for a resource",
            "required": [
                "resourceType",
                "resourceId"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource to clean up (opaque identifier)"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource to clean up"
                },
                "gracePeriodSeconds": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Override grace period in seconds (uses default if not specified, 0 to skip)"
                },
                "cleanupPolicy": {
                    "$ref": "#/$defs/CleanupPolicy",
                    "nullable": true,
                    "description": "Override cleanup policy (uses resource default if not specified)"
                },
                "dryRun": {
                    "type": "boolean",
                    "nullable": true,
                    "description": "If true, returns what callbacks WOULD execute without actually\nexecuting them. Useful for pre-deletion validation and debugging.\nDefaults to false.\n"
                }
            }
        },
        "CleanupPolicy": {
            "type": "string",
            "enum": [
                "BEST_EFFORT",
                "ALL_REQUIRED"
            ],
            "description": "Policy for cleanup callback execution.\nBEST_EFFORT: Proceed with deletion even if some callbacks fail\nALL_REQUIRED: Abort deletion if any callback fails\n"
        }
    }
}
""";

    private static readonly string _ExecuteCleanup_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ExecuteCleanupResponse",
    "$defs": {
        "ExecuteCleanupResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response after attempting to execute cleanup",
            "required": [
                "resourceType",
                "resourceId",
                "success",
                "dryRun",
                "callbackResults"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource cleaned up"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource cleaned up"
                },
                "success": {
                    "type": "boolean",
                    "description": "True if cleanup completed (per cleanup policy)"
                },
                "abortReason": {
                    "type": "string",
                    "nullable": true,
                    "description": "Why cleanup was aborted (refcount changed, callback failed with ALL_REQUIRED, etc.)"
                },
                "callbackResults": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/CleanupCallbackResult"
                    },
                    "description": "Results of each cleanup callback"
                },
                "cleanupDurationMs": {
                    "type": "integer",
                    "description": "Total cleanup execution time in milliseconds"
                },
                "dryRun": {
                    "type": "boolean",
                    "description": "True if this was a preview (no callbacks were actually executed)"
                }
            }
        },
        "CleanupCallbackResult": {
            "type": "object",
            "additionalProperties": false,
            "description": "Result of executing a single cleanup callback",
            "required": [
                "sourceType",
                "serviceName",
                "endpoint",
                "success"
            ],
            "properties": {
                "sourceType": {
                    "type": "string",
                    "description": "Source type that was cleaned up (opaque identifier)"
                },
                "serviceName": {
                    "type": "string",
                    "description": "Service that was called"
                },
                "endpoint": {
                    "type": "string",
                    "description": "Endpoint that was called"
                },
                "success": {
                    "type": "boolean",
                    "description": "Whether callback succeeded"
                },
                "statusCode": {
                    "type": "integer",
                    "nullable": true,
                    "description": "HTTP status code from callback"
                },
                "errorMessage": {
                    "type": "string",
                    "nullable": true,
                    "description": "Error message if callback failed"
                },
                "durationMs": {
                    "type": "integer",
                    "description": "Callback execution time in milliseconds"
                }
            }
        }
    }
}
""";

    private static readonly string _ExecuteCleanup_Info = """
{
    "summary": "Execute cleanup for a resource",
    "description": "Validates refcount=0, grace period passed, acquires distributed lock,\nre-validates under lock, then executes all cleanup callbacks.\nReturns Conflict if refcount changed during execution.\n",
    "tags": [
        "Cleanup Management"
    ],
    "deprecated": false,
    "operationId": "executeCleanup"
}
""";

    /// <summary>Returns endpoint information for ExecuteCleanup</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/execute/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteCleanup_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/cleanup/execute",
            _ExecuteCleanup_Info));

    /// <summary>Returns request schema for ExecuteCleanup</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/execute/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteCleanup_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/cleanup/execute",
            "request-schema",
            _ExecuteCleanup_RequestSchema));

    /// <summary>Returns response schema for ExecuteCleanup</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/execute/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteCleanup_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/cleanup/execute",
            "response-schema",
            _ExecuteCleanup_ResponseSchema));

    /// <summary>Returns full schema for ExecuteCleanup</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/execute/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteCleanup_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/cleanup/execute",
            _ExecuteCleanup_Info,
            _ExecuteCleanup_RequestSchema,
            _ExecuteCleanup_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListCleanupCallbacks

    private static readonly string _ListCleanupCallbacks_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListCleanupCallbacksRequest",
    "$defs": {
        "ListCleanupCallbacksRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to list registered cleanup callbacks",
            "properties": {
                "resourceType": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by resource type (list all if not specified)"
                },
                "sourceType": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by source type (requires resourceType)"
                }
            }
        }
    }
}
""";

    private static readonly string _ListCleanupCallbacks_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListCleanupCallbacksResponse",
    "$defs": {
        "ListCleanupCallbacksResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "List of registered cleanup callbacks",
            "required": [
                "callbacks",
                "totalCount"
            ],
            "properties": {
                "callbacks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/CleanupCallbackSummary"
                    },
                    "description": "Registered callbacks matching filter"
                },
                "totalCount": {
                    "type": "integer",
                    "description": "Total number of callbacks returned"
                }
            }
        },
        "CleanupCallbackSummary": {
            "type": "object",
            "additionalProperties": false,
            "description": "Summary of a registered cleanup callback",
            "required": [
                "resourceType",
                "sourceType",
                "onDeleteAction",
                "serviceName",
                "callbackEndpoint",
                "registeredAt"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource this callback handles"
                },
                "sourceType": {
                    "type": "string",
                    "description": "Type of entity that will be cleaned up"
                },
                "onDeleteAction": {
                    "$ref": "#/$defs/OnDeleteAction",
                    "description": "Action taken when resource is deleted"
                },
                "serviceName": {
                    "type": "string",
                    "description": "Target service for callback invocation"
                },
                "callbackEndpoint": {
                    "type": "string",
                    "description": "Endpoint path called during cleanup"
                },
                "registeredAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When this callback was registered"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Human-readable description"
                }
            }
        },
        "OnDeleteAction": {
            "type": "string",
            "enum": [
                "CASCADE",
                "RESTRICT",
                "DETACH"
            ],
            "description": "Action to take when the referenced resource is deleted.\nCASCADE: Delete dependent entities when resource is deleted\nRESTRICT: Block resource deletion if references exist\nDETACH: Set reference to null when resource is deleted\n"
        }
    }
}
""";

    private static readonly string _ListCleanupCallbacks_Info = """
{
    "summary": "List registered cleanup callbacks",
    "description": "Returns all cleanup callbacks registered for a resource type.\nUseful for debugging and admin inspection of cleanup chains.\n",
    "tags": [
        "Cleanup Management"
    ],
    "deprecated": false,
    "operationId": "listCleanupCallbacks"
}
""";

    /// <summary>Returns endpoint information for ListCleanupCallbacks</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListCleanupCallbacks_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/cleanup/list",
            _ListCleanupCallbacks_Info));

    /// <summary>Returns request schema for ListCleanupCallbacks</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListCleanupCallbacks_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/cleanup/list",
            "request-schema",
            _ListCleanupCallbacks_RequestSchema));

    /// <summary>Returns response schema for ListCleanupCallbacks</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListCleanupCallbacks_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/cleanup/list",
            "response-schema",
            _ListCleanupCallbacks_ResponseSchema));

    /// <summary>Returns full schema for ListCleanupCallbacks</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListCleanupCallbacks_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/cleanup/list",
            _ListCleanupCallbacks_Info,
            _ListCleanupCallbacks_RequestSchema,
            _ListCleanupCallbacks_ResponseSchema));

    #endregion

    #region Meta Endpoints for RemoveCleanupCallback

    private static readonly string _RemoveCleanupCallback_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RemoveCleanupCallbackRequest",
    "$defs": {
        "RemoveCleanupCallbackRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to remove a cleanup callback",
            "required": [
                "resourceType",
                "sourceType"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource the callback handles"
                },
                "sourceType": {
                    "type": "string",
                    "description": "Type of entity the callback cleans up"
                }
            }
        }
    }
}
""";

    private static readonly string _RemoveCleanupCallback_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RemoveCleanupCallbackResponse",
    "$defs": {
        "RemoveCleanupCallbackResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response after removing a cleanup callback",
            "required": [
                "resourceType",
                "sourceType",
                "wasRegistered"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Resource type of removed callback"
                },
                "sourceType": {
                    "type": "string",
                    "description": "Source type of removed callback"
                },
                "wasRegistered": {
                    "type": "boolean",
                    "description": "True if callback existed before removal"
                },
                "removedAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When callback was removed (null if wasn't registered)"
                }
            }
        }
    }
}
""";

    private static readonly string _RemoveCleanupCallback_Info = """
{
    "summary": "Remove a cleanup callback registration",
    "description": "Removes a cleanup callback that was previously registered via\n/resource/cleanup/define. Use when a consumer service is decommissioned\ nor a callback becomes orphaned. Idempotent - returns success even if\ncallback was not registered.\n",
    "tags": [
        "Cleanup Management"
    ],
    "deprecated": false,
    "operationId": "removeCleanupCallback"
}
""";

    /// <summary>Returns endpoint information for RemoveCleanupCallback</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/remove/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RemoveCleanupCallback_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/cleanup/remove",
            _RemoveCleanupCallback_Info));

    /// <summary>Returns request schema for RemoveCleanupCallback</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/remove/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RemoveCleanupCallback_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/cleanup/remove",
            "request-schema",
            _RemoveCleanupCallback_RequestSchema));

    /// <summary>Returns response schema for RemoveCleanupCallback</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/remove/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RemoveCleanupCallback_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/cleanup/remove",
            "response-schema",
            _RemoveCleanupCallback_ResponseSchema));

    /// <summary>Returns full schema for RemoveCleanupCallback</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/cleanup/remove/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RemoveCleanupCallback_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/cleanup/remove",
            _RemoveCleanupCallback_Info,
            _RemoveCleanupCallback_RequestSchema,
            _RemoveCleanupCallback_ResponseSchema));

    #endregion

    #region Meta Endpoints for DefineCompressCallback

    private static readonly string _DefineCompressCallback_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DefineCompressCallbackRequest",
    "$defs": {
        "DefineCompressCallbackRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to register a compression callback",
            "required": [
                "resourceType",
                "sourceType",
                "compressEndpoint",
                "compressPayloadTemplate"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource this compression handles (opaque identifier)"
                },
                "sourceType": {
                    "type": "string",
                    "description": "Type of data being compressed (opaque identifier, e.g., \"character-personality\")"
                },
                "serviceName": {
                    "type": "string",
                    "nullable": true,
                    "description": "Target service name (defaults to sourceType if not specified)"
                },
                "compressEndpoint": {
                    "type": "string",
                    "description": "Endpoint returning compressed data (e.g., /character-personality/get-compress-data)"
                },
                "compressPayloadTemplate": {
                    "type": "string",
                    "description": "JSON template with {{resourceId}} placeholder"
                },
                "decompressEndpoint": {
                    "type": "string",
                    "nullable": true,
                    "description": "Endpoint for restoring data (e.g., /character-personality/restore-from-archive)"
                },
                "decompressPayloadTemplate": {
                    "type": "string",
                    "nullable": true,
                    "description": "JSON template with {{resourceId}} and {{data}} placeholders"
                },
                "priority": {
                    "type": "integer",
                    "default": 100,
                    "description": "Execution order (lower = earlier). Use for dependency ordering."
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Human-readable description of what data this compresses"
                }
            }
        }
    }
}
""";

    private static readonly string _DefineCompressCallback_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DefineCompressCallbackResponse",
    "$defs": {
        "DefineCompressCallbackResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response after registering compression callback",
            "required": [
                "resourceType",
                "sourceType",
                "registered"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Resource type for callback"
                },
                "sourceType": {
                    "type": "string",
                    "description": "Source type for callback"
                },
                "registered": {
                    "type": "boolean",
                    "description": "True if callback was registered"
                },
                "previouslyDefined": {
                    "type": "boolean",
                    "description": "True if callback was already defined (updated)"
                }
            }
        }
    }
}
""";

    private static readonly string _DefineCompressCallback_Info = """
{
    "summary": "Register compression callback for a resource type",
    "description": "Services call this at startup (OnRunningAsync) to register compression endpoints.\nWhen a resource is compressed, these callbacks gather data for the archive bundle.\n\nMirrors the cleanup callback pattern - services register their data export\nendpoints, and compression orchestrates calling all registered callbacks to\nbuild a complete archive.\n",
    "tags": [
        "Compression Management"
    ],
    "deprecated": false,
    "operationId": "defineCompressCallback"
}
""";

    /// <summary>Returns endpoint information for DefineCompressCallback</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/compress/define/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DefineCompressCallback_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/compress/define",
            _DefineCompressCallback_Info));

    /// <summary>Returns request schema for DefineCompressCallback</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/compress/define/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DefineCompressCallback_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/compress/define",
            "request-schema",
            _DefineCompressCallback_RequestSchema));

    /// <summary>Returns response schema for DefineCompressCallback</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/compress/define/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DefineCompressCallback_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/compress/define",
            "response-schema",
            _DefineCompressCallback_ResponseSchema));

    /// <summary>Returns full schema for DefineCompressCallback</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/compress/define/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DefineCompressCallback_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/compress/define",
            _DefineCompressCallback_Info,
            _DefineCompressCallback_RequestSchema,
            _DefineCompressCallback_ResponseSchema));

    #endregion

    #region Meta Endpoints for ExecuteCompress

    private static readonly string _ExecuteCompress_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ExecuteCompressRequest",
    "$defs": {
        "ExecuteCompressRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to compress a resource",
            "required": [
                "resourceType",
                "resourceId"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource to compress"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource to compress"
                },
                "deleteSourceData": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, invoke cleanup callbacks after successful archival"
                },
                "deleteSourceDataPolicy": {
                    "$ref": "#/$defs/CleanupPolicy",
                    "nullable": true,
                    "description": "Cleanup policy for source data deletion after archival.\nOnly applies when deleteSourceData is true.\nIf not specified, uses the configured DefaultCleanupPolicy.\n"
                },
                "compressionPolicy": {
                    "$ref": "#/$defs/CompressionPolicy",
                    "nullable": true,
                    "description": "Override policy (uses default from config if not specified)"
                },
                "dryRun": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, return what would be compressed without executing"
                }
            }
        },
        "CleanupPolicy": {
            "type": "string",
            "enum": [
                "BEST_EFFORT",
                "ALL_REQUIRED"
            ],
            "description": "Policy for cleanup callback execution.\nBEST_EFFORT: Proceed with deletion even if some callbacks fail\nALL_REQUIRED: Abort deletion if any callback fails\n"
        },
        "CompressionPolicy": {
            "type": "string",
            "enum": [
                "BEST_EFFORT",
                "ALL_REQUIRED"
            ],
            "description": "Policy for compression callback execution.\nBEST_EFFORT: Create archive even if some callbacks fail (partial archive)\nALL_REQUIRED: Abort compression if any callback fails\n"
        }
    }
}
""";

    private static readonly string _ExecuteCompress_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ExecuteCompressResponse",
    "$defs": {
        "ExecuteCompressResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Compression execution result",
            "required": [
                "resourceType",
                "resourceId",
                "success",
                "dryRun",
                "callbackResults",
                "compressionDurationMs"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource compressed"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource compressed"
                },
                "success": {
                    "type": "boolean",
                    "description": "True if compression completed successfully"
                },
                "archiveId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "ID of created archive (null if failed or dryRun)"
                },
                "abortReason": {
                    "type": "string",
                    "nullable": true,
                    "description": "Why compression was aborted"
                },
                "callbackResults": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/CompressCallbackResult"
                    },
                    "description": "Results of each compression callback"
                },
                "sourceDataDeleted": {
                    "type": "boolean",
                    "description": "Whether cleanup callbacks were executed after archival"
                },
                "dryRun": {
                    "type": "boolean",
                    "description": "True if this was a preview (no callbacks actually executed)"
                },
                "compressionDurationMs": {
                    "type": "integer",
                    "description": "Total compression execution time in milliseconds"
                }
            }
        },
        "CompressCallbackResult": {
            "type": "object",
            "additionalProperties": false,
            "description": "Result of a single compression callback",
            "required": [
                "sourceType",
                "serviceName",
                "endpoint",
                "success",
                "durationMs"
            ],
            "properties": {
                "sourceType": {
                    "type": "string",
                    "description": "Source type that provided data"
                },
                "serviceName": {
                    "type": "string",
                    "description": "Service that was called"
                },
                "endpoint": {
                    "type": "string",
                    "description": "Endpoint that was called"
                },
                "success": {
                    "type": "boolean",
                    "description": "Whether callback succeeded"
                },
                "statusCode": {
                    "type": "integer",
                    "nullable": true,
                    "description": "HTTP status code from callback"
                },
                "errorMessage": {
                    "type": "string",
                    "nullable": true,
                    "description": "Error message if callback failed"
                },
                "dataSize": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Size of compressed data in bytes"
                },
                "durationMs": {
                    "type": "integer",
                    "description": "Callback execution time in milliseconds"
                }
            }
        }
    }
}
""";

    private static readonly string _ExecuteCompress_Info = """
{
    "summary": "Compress a resource and all dependents",
    "description": "Gathers data from all registered compression callbacks, bundles into\na unified archive, and stores in MySQL. Optionally deletes source data\nafter successful archival via existing cleanup callbacks.\n\nFlow:\n1. Get all compression callbacks for resourceType, sorted by priority\n2. If dryRun, return preview without executing\n3. Acquire distributed lock\n4. Execute each callback to gather data\n5. Bundle responses into archive (gzipped JSON per entry)\n6. Store archive in MySQL\n7. If deleteSourceData, invoke cleanup callbacks\n8. Publish resource.compressed event\n",
    "tags": [
        "Compression Management"
    ],
    "deprecated": false,
    "operationId": "executeCompress"
}
""";

    /// <summary>Returns endpoint information for ExecuteCompress</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/compress/execute/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteCompress_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/compress/execute",
            _ExecuteCompress_Info));

    /// <summary>Returns request schema for ExecuteCompress</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/compress/execute/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteCompress_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/compress/execute",
            "request-schema",
            _ExecuteCompress_RequestSchema));

    /// <summary>Returns response schema for ExecuteCompress</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/compress/execute/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteCompress_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/compress/execute",
            "response-schema",
            _ExecuteCompress_ResponseSchema));

    /// <summary>Returns full schema for ExecuteCompress</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/compress/execute/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteCompress_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/compress/execute",
            _ExecuteCompress_Info,
            _ExecuteCompress_RequestSchema,
            _ExecuteCompress_ResponseSchema));

    #endregion

    #region Meta Endpoints for ExecuteDecompress

    private static readonly string _ExecuteDecompress_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ExecuteDecompressRequest",
    "$defs": {
        "ExecuteDecompressRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to decompress and restore a resource",
            "required": [
                "resourceType",
                "resourceId"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource to decompress"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource to decompress"
                },
                "archiveId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Specific archive version (latest if not specified)"
                }
            }
        }
    }
}
""";

    private static readonly string _ExecuteDecompress_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ExecuteDecompressResponse",
    "$defs": {
        "ExecuteDecompressResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Decompression execution result",
            "required": [
                "resourceType",
                "resourceId",
                "success",
                "callbackResults",
                "decompressionDurationMs"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource decompressed"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource decompressed"
                },
                "success": {
                    "type": "boolean",
                    "description": "True if decompression completed successfully"
                },
                "archiveId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "ID of archive that was restored"
                },
                "abortReason": {
                    "type": "string",
                    "nullable": true,
                    "description": "Why decompression was aborted"
                },
                "callbackResults": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/DecompressCallbackResult"
                    },
                    "description": "Results of each decompression callback"
                },
                "decompressionDurationMs": {
                    "type": "integer",
                    "description": "Total decompression execution time in milliseconds"
                }
            }
        },
        "DecompressCallbackResult": {
            "type": "object",
            "additionalProperties": false,
            "description": "Result of a single decompression callback",
            "required": [
                "sourceType",
                "serviceName",
                "endpoint",
                "success",
                "durationMs"
            ],
            "properties": {
                "sourceType": {
                    "type": "string",
                    "description": "Source type that was restored"
                },
                "serviceName": {
                    "type": "string",
                    "description": "Service that was called"
                },
                "endpoint": {
                    "type": "string",
                    "description": "Endpoint that was called"
                },
                "success": {
                    "type": "boolean",
                    "description": "Whether callback succeeded"
                },
                "statusCode": {
                    "type": "integer",
                    "nullable": true,
                    "description": "HTTP status code from callback"
                },
                "errorMessage": {
                    "type": "string",
                    "nullable": true,
                    "description": "Error message if callback failed"
                },
                "durationMs": {
                    "type": "integer",
                    "description": "Callback execution time in milliseconds"
                }
            }
        }
    }
}
""";

    private static readonly string _ExecuteDecompress_Info = """
{
    "summary": "Restore data from archive",
    "description": "Retrieves the archive bundle and invokes decompression callbacks\nfor each service to restore their data.\n\nCallbacks are invoked in priority order (same as compression).\nEach callback receives the resource ID and its archived data blob.\n",
    "tags": [
        "Compression Management"
    ],
    "deprecated": false,
    "operationId": "executeDecompress"
}
""";

    /// <summary>Returns endpoint information for ExecuteDecompress</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/decompress/execute/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteDecompress_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/decompress/execute",
            _ExecuteDecompress_Info));

    /// <summary>Returns request schema for ExecuteDecompress</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/decompress/execute/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteDecompress_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/decompress/execute",
            "request-schema",
            _ExecuteDecompress_RequestSchema));

    /// <summary>Returns response schema for ExecuteDecompress</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/decompress/execute/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteDecompress_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/decompress/execute",
            "response-schema",
            _ExecuteDecompress_ResponseSchema));

    /// <summary>Returns full schema for ExecuteDecompress</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/decompress/execute/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteDecompress_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/decompress/execute",
            _ExecuteDecompress_Info,
            _ExecuteDecompress_RequestSchema,
            _ExecuteDecompress_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListCompressCallbacks

    private static readonly string _ListCompressCallbacks_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListCompressCallbacksRequest",
    "$defs": {
        "ListCompressCallbacksRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to list registered compression callbacks",
            "properties": {
                "resourceType": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by resource type (list all if not specified)"
                },
                "sourceType": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by source type (requires resourceType)"
                }
            }
        }
    }
}
""";

    private static readonly string _ListCompressCallbacks_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListCompressCallbacksResponse",
    "$defs": {
        "ListCompressCallbacksResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "List of registered compression callbacks",
            "required": [
                "callbacks",
                "totalCount"
            ],
            "properties": {
                "callbacks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/CompressCallbackSummary"
                    },
                    "description": "Registered callbacks matching filter"
                },
                "totalCount": {
                    "type": "integer",
                    "description": "Total number of callbacks returned"
                }
            }
        },
        "CompressCallbackSummary": {
            "type": "object",
            "additionalProperties": false,
            "description": "Summary of a registered compression callback",
            "required": [
                "resourceType",
                "sourceType",
                "serviceName",
                "compressEndpoint",
                "priority",
                "registeredAt"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource this callback handles"
                },
                "sourceType": {
                    "type": "string",
                    "description": "Type of data being compressed"
                },
                "serviceName": {
                    "type": "string",
                    "description": "Target service for callback invocation"
                },
                "compressEndpoint": {
                    "type": "string",
                    "description": "Endpoint called during compression"
                },
                "decompressEndpoint": {
                    "type": "string",
                    "nullable": true,
                    "description": "Endpoint called during decompression"
                },
                "priority": {
                    "type": "integer",
                    "description": "Execution order (lower = earlier)"
                },
                "registeredAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When this callback was registered"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Human-readable description"
                }
            }
        }
    }
}
""";

    private static readonly string _ListCompressCallbacks_Info = """
{
    "summary": "List registered compression callbacks",
    "description": "Returns all compression callbacks registered for a resource type.\nUseful for debugging and admin inspection of compression chains.\n",
    "tags": [
        "Compression Management"
    ],
    "deprecated": false,
    "operationId": "listCompressCallbacks"
}
""";

    /// <summary>Returns endpoint information for ListCompressCallbacks</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/compress/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListCompressCallbacks_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/compress/list",
            _ListCompressCallbacks_Info));

    /// <summary>Returns request schema for ListCompressCallbacks</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/compress/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListCompressCallbacks_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/compress/list",
            "request-schema",
            _ListCompressCallbacks_RequestSchema));

    /// <summary>Returns response schema for ListCompressCallbacks</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/compress/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListCompressCallbacks_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/compress/list",
            "response-schema",
            _ListCompressCallbacks_ResponseSchema));

    /// <summary>Returns full schema for ListCompressCallbacks</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/compress/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListCompressCallbacks_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/compress/list",
            _ListCompressCallbacks_Info,
            _ListCompressCallbacks_RequestSchema,
            _ListCompressCallbacks_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetArchive

    private static readonly string _GetArchive_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetArchiveRequest",
    "$defs": {
        "GetArchiveRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to retrieve a compressed archive",
            "required": [
                "resourceType",
                "resourceId"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource"
                },
                "archiveId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Specific version (latest if not specified)"
                }
            }
        }
    }
}
""";

    private static readonly string _GetArchive_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetArchiveResponse",
    "$defs": {
        "GetArchiveResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing archive data",
            "required": [
                "resourceType",
                "resourceId",
                "found"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource"
                },
                "found": {
                    "type": "boolean",
                    "description": "True if archive exists"
                },
                "archive": {
                    "$ref": "#/$defs/ResourceArchive",
                    "nullable": true,
                    "description": "The archive data (null if not found)"
                }
            }
        },
        "ResourceArchive": {
            "type": "object",
            "additionalProperties": false,
            "description": "Bundled compressed archive",
            "required": [
                "archiveId",
                "resourceType",
                "resourceId",
                "version",
                "entries",
                "createdAt",
                "sourceDataDeleted"
            ],
            "properties": {
                "archiveId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this archive"
                },
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource archived"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource archived"
                },
                "version": {
                    "type": "integer",
                    "description": "Archive version (increments on re-compression)"
                },
                "entries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ArchiveBundleEntry"
                    },
                    "description": "Data entries from each compression callback"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When this archive was created"
                },
                "sourceDataDeleted": {
                    "type": "boolean",
                    "description": "Whether original source data was deleted after archival"
                }
            }
        },
        "ArchiveBundleEntry": {
            "type": "object",
            "additionalProperties": false,
            "description": "Single entry in the archive bundle",
            "required": [
                "sourceType",
                "serviceName",
                "data",
                "compressedAt"
            ],
            "properties": {
                "sourceType": {
                    "type": "string",
                    "description": "Type of data (e.g., \"character-personality\")"
                },
                "serviceName": {
                    "type": "string",
                    "description": "Service that provided the data"
                },
                "data": {
                    "type": "string",
                    "description": "Base64-encoded gzipped JSON from the service callback"
                },
                "compressedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When this entry was compressed"
                },
                "dataChecksum": {
                    "type": "string",
                    "nullable": true,
                    "description": "SHA256 hash for integrity verification"
                },
                "originalSizeBytes": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Size before compression"
                }
            }
        }
    }
}
""";

    private static readonly string _GetArchive_Info = """
{
    "summary": "Retrieve compressed archive",
    "description": "Retrieves a compressed archive by resource type and ID.\nReturns the latest version unless a specific archiveId is provided.\n",
    "tags": [
        "Compression Management"
    ],
    "deprecated": false,
    "operationId": "getArchive"
}
""";

    /// <summary>Returns endpoint information for GetArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/archive/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetArchive_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/archive/get",
            _GetArchive_Info));

    /// <summary>Returns request schema for GetArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/archive/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetArchive_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/archive/get",
            "request-schema",
            _GetArchive_RequestSchema));

    /// <summary>Returns response schema for GetArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/archive/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetArchive_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/archive/get",
            "response-schema",
            _GetArchive_ResponseSchema));

    /// <summary>Returns full schema for GetArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/archive/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetArchive_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/archive/get",
            _GetArchive_Info,
            _GetArchive_RequestSchema,
            _GetArchive_ResponseSchema));

    #endregion

    #region Meta Endpoints for ExecuteSnapshot

    private static readonly string _ExecuteSnapshot_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ExecuteSnapshotRequest",
    "$defs": {
        "ExecuteSnapshotRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to create an ephemeral snapshot of a living resource",
            "required": [
                "resourceType",
                "resourceId"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource to snapshot (opaque identifier).\nMust match compression callback registrations.\n"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource to snapshot"
                },
                "snapshotType": {
                    "type": "string",
                    "description": "Optional label for the snapshot purpose (e.g., \"storyline_seed\", \"analytics\").\nStored in metadata for filtering/debugging.\n"
                },
                "ttlSeconds": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Time-to-live in seconds for the snapshot.\nIf not specified, uses the configured default (RESOURCE_SNAPSHOT_DEFAULT_TTL_SECONDS).\ nValue is clamped to configured min/max range.\nSnapshot is automatically deleted by Redis after TTL expires.\n"
                },
                "compressionPolicy": {
                    "$ref": "#/$defs/CompressionPolicy",
                    "nullable": true,
                    "description": "Policy for callback execution.\ nIf not specified, uses the configured default (RESOURCE_DEFAULT_COMPRESSION_POLICY).\n"
                },
                "dryRun": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, return what would be captured without storing"
                },
                "filterSourceTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Optional list of source types to include in the snapshot.\nOnly compression callbacks matching these source types will be executed.\nIf omitted or empty, all registered compression callbacks are executed.\nExample: [\"character-personality\", \"character-history\"]\n"
                }
            }
        },
        "CompressionPolicy": {
            "type": "string",
            "enum": [
                "BEST_EFFORT",
                "ALL_REQUIRED"
            ],
            "description": "Policy for compression callback execution.\nBEST_EFFORT: Create archive even if some callbacks fail (partial archive)\nALL_REQUIRED: Abort compression if any callback fails\n"
        }
    }
}
""";

    private static readonly string _ExecuteSnapshot_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ExecuteSnapshotResponse",
    "$defs": {
        "ExecuteSnapshotResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Result of snapshot execution",
            "required": [
                "resourceType",
                "resourceId",
                "success",
                "dryRun",
                "snapshotDurationMs"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource snapshotted"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource snapshotted"
                },
                "success": {
                    "type": "boolean",
                    "description": "True if snapshot completed successfully"
                },
                "dryRun": {
                    "type": "boolean",
                    "description": "True if this was a dry run"
                },
                "snapshotId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Unique ID for this snapshot (null on failure or dry run)"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "When this snapshot will expire (null on failure or dry run)"
                },
                "abortReason": {
                    "type": "string",
                    "nullable": true,
                    "description": "Why snapshot was aborted"
                },
                "callbackResults": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/CompressCallbackResult"
                    },
                    "description": "Results of each compression callback"
                },
                "snapshotDurationMs": {
                    "type": "integer",
                    "description": "Total snapshot execution time in milliseconds"
                }
            }
        },
        "CompressCallbackResult": {
            "type": "object",
            "additionalProperties": false,
            "description": "Result of a single compression callback",
            "required": [
                "sourceType",
                "serviceName",
                "endpoint",
                "success",
                "durationMs"
            ],
            "properties": {
                "sourceType": {
                    "type": "string",
                    "description": "Source type that provided data"
                },
                "serviceName": {
                    "type": "string",
                    "description": "Service that was called"
                },
                "endpoint": {
                    "type": "string",
                    "description": "Endpoint that was called"
                },
                "success": {
                    "type": "boolean",
                    "description": "Whether callback succeeded"
                },
                "statusCode": {
                    "type": "integer",
                    "nullable": true,
                    "description": "HTTP status code from callback"
                },
                "errorMessage": {
                    "type": "string",
                    "nullable": true,
                    "description": "Error message if callback failed"
                },
                "dataSize": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Size of compressed data in bytes"
                },
                "durationMs": {
                    "type": "integer",
                    "description": "Callback execution time in milliseconds"
                }
            }
        }
    }
}
""";

    private static readonly string _ExecuteSnapshot_Info = """
{
    "summary": "Create ephemeral snapshot of a living resource",
    "description": "Creates a non-destructive snapshot of a resource using the same compression\ncallbacks, but stores the result in Redis with a configurable TTL instead\nof permanent MySQL storage.\n\n**Use Case**: The Storyline Composer needs compressed data from living\nentities (not just dead/archived ones) to seed emergent narratives.\nThis endpoint provides that capability without affecting the source data.\n\n**Key Differences from compress/execute**:\n1. Stores in Redis (ephemeral) not MySQL (permanent)\n2. Never deletes source data\n3. Publishes `resource.snapshot.created` event (not `resource.compressed`)\n4. Snapshot expires after TTL (default 1 hour, max 24 hours)\n\n**Intended Consumers**:\ n- Actor behaviors (via ABML service_call)\n- Regional Watchers for storyline composition\n- Analytics for living entity state capture\n",
    "tags": [
        "Snapshot Management"
    ],
    "deprecated": false,
    "operationId": "executeSnapshot"
}
""";

    /// <summary>Returns endpoint information for ExecuteSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/snapshot/execute/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteSnapshot_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/snapshot/execute",
            _ExecuteSnapshot_Info));

    /// <summary>Returns request schema for ExecuteSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/snapshot/execute/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteSnapshot_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/snapshot/execute",
            "request-schema",
            _ExecuteSnapshot_RequestSchema));

    /// <summary>Returns response schema for ExecuteSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/snapshot/execute/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteSnapshot_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/snapshot/execute",
            "response-schema",
            _ExecuteSnapshot_ResponseSchema));

    /// <summary>Returns full schema for ExecuteSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/snapshot/execute/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ExecuteSnapshot_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/snapshot/execute",
            _ExecuteSnapshot_Info,
            _ExecuteSnapshot_RequestSchema,
            _ExecuteSnapshot_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetSnapshot

    private static readonly string _GetSnapshot_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetSnapshotRequest",
    "$defs": {
        "GetSnapshotRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to retrieve a snapshot",
            "required": [
                "snapshotId"
            ],
            "properties": {
                "snapshotId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the snapshot to retrieve"
                },
                "filterSourceTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Optional filter for which entries to return from the snapshot.\nOnly entries with matching source types are returned.\nIf omitted or empty, all entries are returned.\n"
                }
            }
        }
    }
}
""";

    private static readonly string _GetSnapshot_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetSnapshotResponse",
    "$defs": {
        "GetSnapshotResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing snapshot data",
            "required": [
                "snapshotId",
                "found"
            ],
            "properties": {
                "snapshotId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the snapshot"
                },
                "found": {
                    "type": "boolean",
                    "description": "True if snapshot exists (hasn't expired)"
                },
                "snapshot": {
                    "$ref": "#/$defs/ResourceSnapshot",
                    "nullable": true,
                    "description": "The snapshot data (null if not found/expired)"
                }
            }
        },
        "ResourceSnapshot": {
            "type": "object",
            "additionalProperties": false,
            "description": "Ephemeral snapshot of a living resource",
            "required": [
                "snapshotId",
                "resourceType",
                "resourceId",
                "snapshotType",
                "entries",
                "createdAt",
                "expiresAt"
            ],
            "properties": {
                "snapshotId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this snapshot"
                },
                "resourceType": {
                    "type": "string",
                    "description": "Type of resource snapshotted"
                },
                "resourceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the resource snapshotted"
                },
                "snapshotType": {
                    "type": "string",
                    "description": "Label for snapshot purpose (e.g., \"storyline_seed\")"
                },
                "entries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ArchiveBundleEntry"
                    },
                    "description": "Data entries from each compression callback (same format as archives)"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When this snapshot was created"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When this snapshot will expire"
                }
            }
        },
        "ArchiveBundleEntry": {
            "type": "object",
            "additionalProperties": false,
            "description": "Single entry in the archive bundle",
            "required": [
                "sourceType",
                "serviceName",
                "data",
                "compressedAt"
            ],
            "properties": {
                "sourceType": {
                    "type": "string",
                    "description": "Type of data (e.g., \"character-personality\")"
                },
                "serviceName": {
                    "type": "string",
                    "description": "Service that provided the data"
                },
                "data": {
                    "type": "string",
                    "description": "Base64-encoded gzipped JSON from the service callback"
                },
                "compressedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When this entry was compressed"
                },
                "dataChecksum": {
                    "type": "string",
                    "nullable": true,
                    "description": "SHA256 hash for integrity verification"
                },
                "originalSizeBytes": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Size before compression"
                }
            }
        }
    }
}
""";

    private static readonly string _GetSnapshot_Info = """
{
    "summary": "Retrieve an ephemeral snapshot",
    "description": "Retrieves a previously created snapshot by its ID.\nReturns 404 if the snapshot has expired or doesn't exist.\n\nSnapshots are stored with TTL - if the TTL has elapsed, the snapshot\nis automatically deleted by Redis.\n",
    "tags": [
        "Snapshot Management"
    ],
    "deprecated": false,
    "operationId": "getSnapshot"
}
""";

    /// <summary>Returns endpoint information for GetSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/snapshot/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSnapshot_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/snapshot/get",
            _GetSnapshot_Info));

    /// <summary>Returns request schema for GetSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/snapshot/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSnapshot_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/snapshot/get",
            "request-schema",
            _GetSnapshot_RequestSchema));

    /// <summary>Returns response schema for GetSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/snapshot/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSnapshot_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/snapshot/get",
            "response-schema",
            _GetSnapshot_ResponseSchema));

    /// <summary>Returns full schema for GetSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/snapshot/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSnapshot_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/snapshot/get",
            _GetSnapshot_Info,
            _GetSnapshot_RequestSchema,
            _GetSnapshot_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListSeededResources

    private static readonly string _ListSeededResources_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListSeededResourcesRequest",
    "$defs": {
        "ListSeededResourcesRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to list available seeded resources",
            "properties": {
                "resourceType": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by resource type (list all types if not specified)"
                }
            }
        }
    }
}
""";

    private static readonly string _ListSeededResources_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListSeededResourcesResponse",
    "$defs": {
        "ListSeededResourcesResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "List of available seeded resources",
            "required": [
                "resources",
                "totalCount"
            ],
            "properties": {
                "resources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SeededResourceSummary"
                    },
                    "description": "Available seeded resources"
                },
                "totalCount": {
                    "type": "integer",
                    "description": "Total number of resources returned"
                }
            }
        },
        "SeededResourceSummary": {
            "type": "object",
            "additionalProperties": false,
            "description": "Summary of an available seeded resource",
            "required": [
                "resourceType",
                "identifier",
                "contentType"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Resource type category (e.g., \"behavior\", \"species-definition\")"
                },
                "identifier": {
                    "type": "string",
                    "description": "Unique identifier within the resource type"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME type of the content (e.g., \"application/yaml\")"
                },
                "sizeBytes": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Content size in bytes (null in list responses for efficiency; use getSeededResource for size)"
                }
            }
        }
    }
}
""";

    private static readonly string _ListSeededResources_Info = """
{
    "summary": "List available seeded resources",
    "description": "Returns identifiers of all seeded resources available from registered providers.\nFilter by resourceType to get resources of a specific category.\n\nSeeded resources are read-only factory defaults provided by plugins via\nISeededResourceProvider implementations registered in DI.\n",
    "tags": [
        "Seeded Resources"
    ],
    "deprecated": false,
    "operationId": "listSeededResources"
}
""";

    /// <summary>Returns endpoint information for ListSeededResources</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/seeded/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListSeededResources_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/seeded/list",
            _ListSeededResources_Info));

    /// <summary>Returns request schema for ListSeededResources</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/seeded/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListSeededResources_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/seeded/list",
            "request-schema",
            _ListSeededResources_RequestSchema));

    /// <summary>Returns response schema for ListSeededResources</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/seeded/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListSeededResources_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/seeded/list",
            "response-schema",
            _ListSeededResources_ResponseSchema));

    /// <summary>Returns full schema for ListSeededResources</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/seeded/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListSeededResources_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/seeded/list",
            _ListSeededResources_Info,
            _ListSeededResources_RequestSchema,
            _ListSeededResources_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetSeededResource

    private static readonly string _GetSeededResource_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetSeededResourceRequest",
    "$defs": {
        "GetSeededResourceRequest": {
            "type": "object",
            "additionalProperties": false,
            "description": "Request to get a seeded resource",
            "required": [
                "resourceType",
                "identifier"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Resource type category"
                },
                "identifier": {
                    "type": "string",
                    "description": "Resource identifier"
                }
            }
        }
    }
}
""";

    private static readonly string _GetSeededResource_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetSeededResourceResponse",
    "$defs": {
        "GetSeededResourceResponse": {
            "type": "object",
            "additionalProperties": false,
            "description": "Response containing seeded resource content",
            "required": [
                "resourceType",
                "identifier",
                "found"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Resource type requested"
                },
                "identifier": {
                    "type": "string",
                    "description": "Resource identifier requested"
                },
                "found": {
                    "type": "boolean",
                    "description": "True if resource was found"
                },
                "resource": {
                    "$ref": "#/$defs/SeededResourceDetail",
                    "nullable": true,
                    "description": "The resource data (null if not found)"
                }
            }
        },
        "SeededResourceDetail": {
            "type": "object",
            "additionalProperties": false,
            "description": "Full seeded resource with content",
            "required": [
                "resourceType",
                "identifier",
                "contentType",
                "content"
            ],
            "properties": {
                "resourceType": {
                    "type": "string",
                    "description": "Resource type category"
                },
                "identifier": {
                    "type": "string",
                    "description": "Unique identifier"
                },
                "contentType": {
                    "type": "string",
                    "description": "MIME type of the content"
                },
                "content": {
                    "type": "string",
                    "description": "Base64-encoded resource content"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Client-only key-value metadata provided by the seeded resource provider.\nUsed for client display hints and debugging context (e.g., source assembly,\nfile origin). NOT a cross-service data contract per FOUNDATION TENETS \u2014\nplugins MUST NOT read metadata keys from other providers by convention.\n"
                }
            }
        }
    }
}
""";

    private static readonly string _GetSeededResource_Info = """
{
    "summary": "Get a seeded resource by type and identifier",
    "description": "Retrieves the content and metadata of a seeded resource.\nReturns found=false if the resource type or identifier is not found.\n\nContent is returned as base64-encoded bytes with contentType indicating\nthe MIME type for proper parsing.\n",
    "tags": [
        "Seeded Resources"
    ],
    "deprecated": false,
    "operationId": "getSeededResource"
}
""";

    /// <summary>Returns endpoint information for GetSeededResource</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/seeded/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSeededResource_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Resource",
            "POST",
            "/resource/seeded/get",
            _GetSeededResource_Info));

    /// <summary>Returns request schema for GetSeededResource</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/seeded/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSeededResource_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/seeded/get",
            "request-schema",
            _GetSeededResource_RequestSchema));

    /// <summary>Returns response schema for GetSeededResource</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/seeded/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSeededResource_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Resource",
            "POST",
            "/resource/seeded/get",
            "response-schema",
            _GetSeededResource_ResponseSchema));

    /// <summary>Returns full schema for GetSeededResource</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/resource/seeded/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSeededResource_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Resource",
            "POST",
            "/resource/seeded/get",
            _GetSeededResource_Info,
            _GetSeededResource_RequestSchema,
            _GetSeededResource_ResponseSchema));

    #endregion
}
