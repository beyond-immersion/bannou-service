//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     RELATED FILES:
//     - Request/Response models: bannou-service/Generated/Models/{Service}Models.cs
//     - Event models: bannou-service/Generated/Events/{Service}EventsModels.cs
//     - Lifecycle events: bannou-service/Generated/Events/{Service}LifecycleEvents.cs
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Relationship;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IRelationshipController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Create a new relationship between two entities
    /// </summary>

    /// <remarks>
    /// Creates a relationship between two entities.
    /// <br/>Duplicate relationships (same entities + same type) are prevented.
    /// <br/>Relationships can be re-created after being ended.
    /// </remarks>

    /// <returns>Relationship created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipResponse>> CreateRelationshipAsync(CreateRelationshipRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get a relationship by ID
    /// </summary>


    /// <returns>Relationship retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipResponse>> GetRelationshipAsync(GetRelationshipRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all relationships for an entity
    /// </summary>

    /// <remarks>
    /// Returns all relationships where the specified entity is either
    /// <br/>entity1 or entity2. Supports filtering by relationship type,
    /// <br/>other entity type, and whether to include ended relationships.
    /// </remarks>

    /// <returns>Relationships retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipListResponse>> ListRelationshipsByEntityAsync(ListRelationshipsByEntityRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get all relationships between two specific entities
    /// </summary>

    /// <remarks>
    /// Returns all relationships that exist between two specific entities,
    /// <br/>regardless of which is entity1 or entity2.
    /// </remarks>

    /// <returns>Relationships retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipListResponse>> GetRelationshipsBetweenAsync(GetRelationshipsBetweenRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all relationships of a specific type
    /// </summary>

    /// <remarks>
    /// Returns all relationships that use a specific relationship type.
    /// <br/>Useful for finding all "FRIEND" relationships, for example.
    /// </remarks>

    /// <returns>Relationships retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipListResponse>> ListRelationshipsByTypeAsync(ListRelationshipsByTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update relationship metadata
    /// </summary>

    /// <remarks>
    /// Only metadata can be updated. Entity IDs and types cannot be changed.
    /// </remarks>

    /// <returns>Relationship updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipResponse>> UpdateRelationshipAsync(UpdateRelationshipRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// End a relationship
    /// </summary>

    /// <remarks>
    /// Marks a relationship as ended with a timestamp.
    /// <br/>Ended relationships are preserved for history and can be re-created.
    /// <br/>The composite uniqueness key is cleared, allowing new relationships
    /// <br/>between the same entities with the same type.
    /// </remarks>

    /// <returns>Relationship ended successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> EndRelationshipAsync(EndRelationshipRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Cleanup relationships referencing a deleted entity
    /// </summary>

    /// <remarks>
    /// Called by lib-resource cleanup coordination when a foundational entity
    /// <br/>(character, realm) is deleted. Ends all active relationships where the
    /// <br/>specified entity is either entity1 or entity2. Ended relationships are
    /// <br/>preserved for history (soft-delete via endedAt). This endpoint is designed
    /// <br/>for internal service-to-service calls during cascading resource cleanup.
    /// </remarks>

    /// <returns>Cleanup completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupByEntityResponse>> CleanupByEntityAsync(CleanupByEntityRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get relationship type by ID
    /// </summary>


    /// <returns>Relationship type retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeResponse>> GetRelationshipTypeAsync(GetRelationshipTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get relationship type by code
    /// </summary>

    /// <remarks>
    /// Retrieve a relationship type using its unique code (e.g., "SON", "MOTHER", "FRIEND")
    /// </remarks>

    /// <returns>Relationship type retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeResponse>> GetRelationshipTypeByCodeAsync(GetRelationshipTypeByCodeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all relationship types
    /// </summary>

    /// <remarks>
    /// Retrieve all relationship types with optional hierarchy filtering
    /// </remarks>

    /// <returns>Relationship types retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeListResponse>> ListRelationshipTypesAsync(ListRelationshipTypesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get child types for a parent type
    /// </summary>

    /// <remarks>
    /// Retrieve all relationship types that have the specified type as their parent
    /// </remarks>

    /// <returns>Child relationship types retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeListResponse>> GetChildRelationshipTypesAsync(GetChildRelationshipTypesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Check if type matches ancestor in hierarchy
    /// </summary>

    /// <remarks>
    /// Checks if a relationship type matches or descends from an ancestor type.
    /// <br/>For example, "SON" matches "CHILD" because CHILD is an ancestor of SON.
    /// <br/>This enables queries like "find all CHILD relationships" to match SON, DAUGHTER, etc.
    /// </remarks>

    /// <returns>Hierarchy match result</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MatchesHierarchyResponse>> MatchesHierarchyAsync(MatchesHierarchyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get all ancestors of a relationship type
    /// </summary>

    /// <remarks>
    /// Returns the full ancestry chain from the specified type up to the root.
    /// <br/>For example, for "SON" might return ["CHILD", "FAMILY"].
    /// </remarks>

    /// <returns>Ancestors retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeListResponse>> GetAncestorsAsync(GetAncestorsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create new relationship type
    /// </summary>


    /// <returns>Relationship type created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeResponse>> CreateRelationshipTypeAsync(CreateRelationshipTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update relationship type
    /// </summary>


    /// <returns>Relationship type updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeResponse>> UpdateRelationshipTypeAsync(UpdateRelationshipTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete relationship type
    /// </summary>

    /// <remarks>
    /// Hard delete a relationship type. This will fail if the type is still in use.
    /// <br/>For safe removal, first deprecate the type, then merge it into another type
    /// <br/>(or VOID), then delete. Only deprecated types with zero references can be deleted.
    /// </remarks>

    /// <returns>Relationship type deleted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> DeleteRelationshipTypeAsync(DeleteRelationshipTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Deprecate a relationship type
    /// </summary>

    /// <remarks>
    /// Soft-delete a relationship type by marking it as deprecated.
    /// <br/>Deprecated types:
    /// <br/>- Remain queryable for historical data
    /// <br/>- Cannot be used for creating new relationships
    /// <br/>- Can be merged into other types using the merge endpoint
    /// <br/>- Can be hard-deleted after all references are removed
    /// </remarks>

    /// <returns>Relationship type deprecated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeResponse>> DeprecateRelationshipTypeAsync(DeprecateRelationshipTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Restore a deprecated relationship type
    /// </summary>

    /// <remarks>
    /// Remove the deprecated status from a relationship type, making it
    /// <br/>available for new relationships again.
    /// </remarks>

    /// <returns>Relationship type restored successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeResponse>> UndeprecateRelationshipTypeAsync(UndeprecateRelationshipTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Merge a deprecated type into another type
    /// </summary>

    /// <remarks>
    /// Migrate all relationships using a deprecated type to a target type.
    /// <br/>This is the recommended way to handle type removal:
    /// <br/>1. Deprecate the source type
    /// <br/>2. Merge into the target type (or VOID for effective deletion)
    /// <br/>3. Optionally hard-delete the now-empty deprecated type
    /// <br/>
    /// <br/>The merge operation:
    /// <br/>- Updates all relationships using sourceTypeId to use targetTypeId
    /// <br/>- Publishes events for each affected relationship
    /// <br/>- Returns count of migrated relationships
    /// <br/>- Fails if source is not deprecated (safety check)
    /// </remarks>

    /// <returns>Merge completed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MergeRelationshipTypeResponse>> MergeRelationshipTypeAsync(MergeRelationshipTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Seed relationship types from configuration
    /// </summary>

    /// <remarks>
    /// Idempotent operation to seed relationship types from provided data.
    /// <br/>Creates types that don't exist, optionally updates existing types.
    /// <br/>Typically called at service startup with YAML-defined types.
    /// </remarks>

    /// <returns>Seed operation completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SeedRelationshipTypesResponse>> SeedRelationshipTypesAsync(SeedRelationshipTypesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class RelationshipController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IRelationshipService _implementation;
    private BeyondImmersion.BannouService.Services.ITelemetryProvider _telemetryProvider;

    public RelationshipController(IRelationshipService implementation, BeyondImmersion.BannouService.Services.ITelemetryProvider telemetryProvider)
    {
        _implementation = implementation;
        _telemetryProvider = telemetryProvider;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Create a new relationship between two entities
    /// </summary>
    /// <remarks>
    /// Creates a relationship between two entities.
    /// <br/>Duplicate relationships (same entities + same type) are prevented.
    /// <br/>Relationships can be re-created after being ended.
    /// </remarks>
    /// <returns>Relationship created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipResponse>> CreateRelationship([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateRelationshipRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship",
            "RelationshipController.CreateRelationship",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship/create");
        try
        {

            var (statusCode, result) = await _implementation.CreateRelationshipAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship/create");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship",
                "CreateRelationship",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get a relationship by ID
    /// </summary>
    /// <returns>Relationship retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipResponse>> GetRelationship([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetRelationshipRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship",
            "RelationshipController.GetRelationship",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship/get");
        try
        {

            var (statusCode, result) = await _implementation.GetRelationshipAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship/get");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship",
                "GetRelationship",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List all relationships for an entity
    /// </summary>
    /// <remarks>
    /// Returns all relationships where the specified entity is either
    /// <br/>entity1 or entity2. Supports filtering by relationship type,
    /// <br/>other entity type, and whether to include ended relationships.
    /// </remarks>
    /// <returns>Relationships retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship/list-by-entity")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipListResponse>> ListRelationshipsByEntity([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListRelationshipsByEntityRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship",
            "RelationshipController.ListRelationshipsByEntity",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship/list-by-entity");
        try
        {

            var (statusCode, result) = await _implementation.ListRelationshipsByEntityAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship/list-by-entity");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship/list-by-entity");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship",
                "ListRelationshipsByEntity",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship/list-by-entity",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get all relationships between two specific entities
    /// </summary>
    /// <remarks>
    /// Returns all relationships that exist between two specific entities,
    /// <br/>regardless of which is entity1 or entity2.
    /// </remarks>
    /// <returns>Relationships retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship/get-between")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipListResponse>> GetRelationshipsBetween([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetRelationshipsBetweenRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship",
            "RelationshipController.GetRelationshipsBetween",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship/get-between");
        try
        {

            var (statusCode, result) = await _implementation.GetRelationshipsBetweenAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship/get-between");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship/get-between");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship",
                "GetRelationshipsBetween",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship/get-between",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List all relationships of a specific type
    /// </summary>
    /// <remarks>
    /// Returns all relationships that use a specific relationship type.
    /// <br/>Useful for finding all "FRIEND" relationships, for example.
    /// </remarks>
    /// <returns>Relationships retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship/list-by-type")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipListResponse>> ListRelationshipsByType([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListRelationshipsByTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship",
            "RelationshipController.ListRelationshipsByType",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship/list-by-type");
        try
        {

            var (statusCode, result) = await _implementation.ListRelationshipsByTypeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship/list-by-type");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship/list-by-type");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship",
                "ListRelationshipsByType",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship/list-by-type",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update relationship metadata
    /// </summary>
    /// <remarks>
    /// Only metadata can be updated. Entity IDs and types cannot be changed.
    /// </remarks>
    /// <returns>Relationship updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipResponse>> UpdateRelationship([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateRelationshipRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship",
            "RelationshipController.UpdateRelationship",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship/update");
        try
        {

            var (statusCode, result) = await _implementation.UpdateRelationshipAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship/update");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship/update");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship",
                "UpdateRelationship",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship/update",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// End a relationship
    /// </summary>
    /// <remarks>
    /// Marks a relationship as ended with a timestamp.
    /// <br/>Ended relationships are preserved for history and can be re-created.
    /// <br/>The composite uniqueness key is cleared, allowing new relationships
    /// <br/>between the same entities with the same type.
    /// </remarks>
    /// <returns>Relationship ended successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship/end")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> EndRelationship([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] EndRelationshipRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship",
            "RelationshipController.EndRelationship",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship/end");
        try
        {

            var statusCode = await _implementation.EndRelationshipAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship/end");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship/end");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship",
                "EndRelationship",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship/end",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Cleanup relationships referencing a deleted entity
    /// </summary>
    /// <remarks>
    /// Called by lib-resource cleanup coordination when a foundational entity
    /// <br/>(character, realm) is deleted. Ends all active relationships where the
    /// <br/>specified entity is either entity1 or entity2. Ended relationships are
    /// <br/>preserved for history (soft-delete via endedAt). This endpoint is designed
    /// <br/>for internal service-to-service calls during cascading resource cleanup.
    /// </remarks>
    /// <returns>Cleanup completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship/cleanup-by-entity")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupByEntityResponse>> CleanupByEntity([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CleanupByEntityRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship",
            "RelationshipController.CleanupByEntity",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship/cleanup-by-entity");
        try
        {

            var (statusCode, result) = await _implementation.CleanupByEntityAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship/cleanup-by-entity");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship/cleanup-by-entity");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship",
                "CleanupByEntity",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship/cleanup-by-entity",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get relationship type by ID
    /// </summary>
    /// <returns>Relationship type retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship-type/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeResponse>> GetRelationshipType([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetRelationshipTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship-type",
            "RelationshipController.GetRelationshipType",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship-type/get");
        try
        {

            var (statusCode, result) = await _implementation.GetRelationshipTypeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship-type/get");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship-type/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship-type",
                "GetRelationshipType",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship-type/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get relationship type by code
    /// </summary>
    /// <remarks>
    /// Retrieve a relationship type using its unique code (e.g., "SON", "MOTHER", "FRIEND")
    /// </remarks>
    /// <returns>Relationship type retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship-type/get-by-code")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeResponse>> GetRelationshipTypeByCode([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetRelationshipTypeByCodeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship-type",
            "RelationshipController.GetRelationshipTypeByCode",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship-type/get-by-code");
        try
        {

            var (statusCode, result) = await _implementation.GetRelationshipTypeByCodeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship-type/get-by-code");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship-type/get-by-code");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship-type",
                "GetRelationshipTypeByCode",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship-type/get-by-code",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List all relationship types
    /// </summary>
    /// <remarks>
    /// Retrieve all relationship types with optional hierarchy filtering
    /// </remarks>
    /// <returns>Relationship types retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship-type/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeListResponse>> ListRelationshipTypes([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListRelationshipTypesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship-type",
            "RelationshipController.ListRelationshipTypes",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship-type/list");
        try
        {

            var (statusCode, result) = await _implementation.ListRelationshipTypesAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship-type/list");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship-type/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship-type",
                "ListRelationshipTypes",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship-type/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get child types for a parent type
    /// </summary>
    /// <remarks>
    /// Retrieve all relationship types that have the specified type as their parent
    /// </remarks>
    /// <returns>Child relationship types retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship-type/get-children")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeListResponse>> GetChildRelationshipTypes([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetChildRelationshipTypesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship-type",
            "RelationshipController.GetChildRelationshipTypes",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship-type/get-children");
        try
        {

            var (statusCode, result) = await _implementation.GetChildRelationshipTypesAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship-type/get-children");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship-type/get-children");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship-type",
                "GetChildRelationshipTypes",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship-type/get-children",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Check if type matches ancestor in hierarchy
    /// </summary>
    /// <remarks>
    /// Checks if a relationship type matches or descends from an ancestor type.
    /// <br/>For example, "SON" matches "CHILD" because CHILD is an ancestor of SON.
    /// <br/>This enables queries like "find all CHILD relationships" to match SON, DAUGHTER, etc.
    /// </remarks>
    /// <returns>Hierarchy match result</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship-type/matches-hierarchy")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MatchesHierarchyResponse>> MatchesHierarchy([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] MatchesHierarchyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship-type",
            "RelationshipController.MatchesHierarchy",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship-type/matches-hierarchy");
        try
        {

            var (statusCode, result) = await _implementation.MatchesHierarchyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship-type/matches-hierarchy");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship-type/matches-hierarchy");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship-type",
                "MatchesHierarchy",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship-type/matches-hierarchy",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get all ancestors of a relationship type
    /// </summary>
    /// <remarks>
    /// Returns the full ancestry chain from the specified type up to the root.
    /// <br/>For example, for "SON" might return ["CHILD", "FAMILY"].
    /// </remarks>
    /// <returns>Ancestors retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship-type/get-ancestors")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeListResponse>> GetAncestors([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetAncestorsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship-type",
            "RelationshipController.GetAncestors",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship-type/get-ancestors");
        try
        {

            var (statusCode, result) = await _implementation.GetAncestorsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship-type/get-ancestors");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship-type/get-ancestors");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship-type",
                "GetAncestors",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship-type/get-ancestors",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Create new relationship type
    /// </summary>
    /// <returns>Relationship type created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship-type/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeResponse>> CreateRelationshipType([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateRelationshipTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship-type",
            "RelationshipController.CreateRelationshipType",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship-type/create");
        try
        {

            var (statusCode, result) = await _implementation.CreateRelationshipTypeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship-type/create");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship-type/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship-type",
                "CreateRelationshipType",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship-type/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update relationship type
    /// </summary>
    /// <returns>Relationship type updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship-type/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeResponse>> UpdateRelationshipType([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateRelationshipTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship-type",
            "RelationshipController.UpdateRelationshipType",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship-type/update");
        try
        {

            var (statusCode, result) = await _implementation.UpdateRelationshipTypeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship-type/update");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship-type/update");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship-type",
                "UpdateRelationshipType",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship-type/update",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Delete relationship type
    /// </summary>
    /// <remarks>
    /// Hard delete a relationship type. This will fail if the type is still in use.
    /// <br/>For safe removal, first deprecate the type, then merge it into another type
    /// <br/>(or VOID), then delete. Only deprecated types with zero references can be deleted.
    /// </remarks>
    /// <returns>Relationship type deleted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship-type/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> DeleteRelationshipType([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteRelationshipTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship-type",
            "RelationshipController.DeleteRelationshipType",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship-type/delete");
        try
        {

            var statusCode = await _implementation.DeleteRelationshipTypeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship-type/delete");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship-type/delete");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship-type",
                "DeleteRelationshipType",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship-type/delete",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Deprecate a relationship type
    /// </summary>
    /// <remarks>
    /// Soft-delete a relationship type by marking it as deprecated.
    /// <br/>Deprecated types:
    /// <br/>- Remain queryable for historical data
    /// <br/>- Cannot be used for creating new relationships
    /// <br/>- Can be merged into other types using the merge endpoint
    /// <br/>- Can be hard-deleted after all references are removed
    /// </remarks>
    /// <returns>Relationship type deprecated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship-type/deprecate")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeResponse>> DeprecateRelationshipType([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeprecateRelationshipTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship-type",
            "RelationshipController.DeprecateRelationshipType",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship-type/deprecate");
        try
        {

            var (statusCode, result) = await _implementation.DeprecateRelationshipTypeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship-type/deprecate");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship-type/deprecate");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship-type",
                "DeprecateRelationshipType",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship-type/deprecate",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Restore a deprecated relationship type
    /// </summary>
    /// <remarks>
    /// Remove the deprecated status from a relationship type, making it
    /// <br/>available for new relationships again.
    /// </remarks>
    /// <returns>Relationship type restored successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship-type/undeprecate")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RelationshipTypeResponse>> UndeprecateRelationshipType([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UndeprecateRelationshipTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship-type",
            "RelationshipController.UndeprecateRelationshipType",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship-type/undeprecate");
        try
        {

            var (statusCode, result) = await _implementation.UndeprecateRelationshipTypeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship-type/undeprecate");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship-type/undeprecate");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship-type",
                "UndeprecateRelationshipType",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship-type/undeprecate",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Merge a deprecated type into another type
    /// </summary>
    /// <remarks>
    /// Migrate all relationships using a deprecated type to a target type.
    /// <br/>This is the recommended way to handle type removal:
    /// <br/>1. Deprecate the source type
    /// <br/>2. Merge into the target type (or VOID for effective deletion)
    /// <br/>3. Optionally hard-delete the now-empty deprecated type
    /// <br/>
    /// <br/>The merge operation:
    /// <br/>- Updates all relationships using sourceTypeId to use targetTypeId
    /// <br/>- Publishes events for each affected relationship
    /// <br/>- Returns count of migrated relationships
    /// <br/>- Fails if source is not deprecated (safety check)
    /// </remarks>
    /// <returns>Merge completed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship-type/merge")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MergeRelationshipTypeResponse>> MergeRelationshipType([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] MergeRelationshipTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship-type",
            "RelationshipController.MergeRelationshipType",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship-type/merge");
        try
        {

            var (statusCode, result) = await _implementation.MergeRelationshipTypeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship-type/merge");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship-type/merge");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship-type",
                "MergeRelationshipType",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship-type/merge",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Seed relationship types from configuration
    /// </summary>
    /// <remarks>
    /// Idempotent operation to seed relationship types from provided data.
    /// <br/>Creates types that don't exist, optionally updates existing types.
    /// <br/>Typically called at service startup with YAML-defined types.
    /// </remarks>
    /// <returns>Seed operation completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("relationship-type/seed")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SeedRelationshipTypesResponse>> SeedRelationshipTypes([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SeedRelationshipTypesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.relationship-type",
            "RelationshipController.SeedRelationshipTypes",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "relationship-type/seed");
        try
        {

            var (statusCode, result) = await _implementation.SeedRelationshipTypesAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:relationship-type/seed");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<RelationshipController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:relationship-type/seed");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "relationship-type",
                "SeedRelationshipTypes",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:relationship-type/seed",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
