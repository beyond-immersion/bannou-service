//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Analytics;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IAnalyticsController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Ingest a single analytics event
    /// </summary>

    /// <remarks>
    /// High-throughput event ingestion endpoint for recording game events.
    /// <br/>Events are buffered in memory and periodically flushed to persistent storage.
    /// <br/>Service-only endpoint - not exposed to clients.
    /// </remarks>

    /// <returns>Event ingested successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<IngestEventResponse>> IngestEventAsync(IngestEventRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Ingest multiple analytics events
    /// </summary>

    /// <remarks>
    /// Batch event ingestion for high-volume scenarios. Accepts up to 1000 events per request.
    /// <br/>Service-only endpoint - not exposed to clients.
    /// </remarks>

    /// <returns>Events ingested successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<IngestEventBatchResponse>> IngestEventBatchAsync(IngestEventBatchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get entity statistics summary
    /// </summary>

    /// <remarks>
    /// Retrieve aggregated statistics for an entity. Summaries include total counts,
    /// <br/>averages, and derived metrics computed from ingested events.
    /// </remarks>

    /// <returns>Entity summary retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EntitySummaryResponse>> GetEntitySummaryAsync(GetEntitySummaryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Query entity summaries with filters
    /// </summary>

    /// <remarks>
    /// Query multiple entity summaries with filtering and sorting options.
    /// <br/>Useful for dashboards and reporting.
    /// </remarks>

    /// <returns>Query executed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryEntitySummariesResponse>> QueryEntitySummariesAsync(QueryEntitySummariesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get entity Glicko-2 skill rating
    /// </summary>

    /// <remarks>
    /// Retrieve the current Glicko-2 skill rating for an entity.
    /// <br/>Returns rating, rating deviation (RD), and volatility.
    /// </remarks>

    /// <returns>Skill rating retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SkillRatingResponse>> GetSkillRatingAsync(GetSkillRatingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update entity skill rating after match
    /// </summary>

    /// <remarks>
    /// Update skill ratings for entities after a match result.
    /// <br/>Uses Glicko-2 algorithm to compute new ratings based on outcomes.
    /// <br/>Service-only endpoint - typically called by game-session service.
    /// </remarks>

    /// <returns>Skill ratings updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateSkillRatingResponse>> UpdateSkillRatingAsync(UpdateSkillRatingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Record controller possession event
    /// </summary>

    /// <remarks>
    /// Record when an account takes or releases control of an entity.
    /// <br/>Used for tracking which player controlled which character/actor at what time.
    /// <br/>Service-only endpoint.
    /// </remarks>

    /// <returns>Controller event recorded successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> RecordControllerEventAsync(RecordControllerEventRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Query controller history
    /// </summary>

    /// <remarks>
    /// Query who controlled what entity during a time range.
    /// <br/>Useful for audit trails and replays.
    /// </remarks>

    /// <returns>Controller history retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryControllerHistoryResponse>> QueryControllerHistoryAsync(QueryControllerHistoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class AnalyticsController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IAnalyticsService _implementation;

    public AnalyticsController(IAnalyticsService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Ingest a single analytics event
    /// </summary>
    /// <remarks>
    /// High-throughput event ingestion endpoint for recording game events.
    /// <br/>Events are buffered in memory and periodically flushed to persistent storage.
    /// <br/>Service-only endpoint - not exposed to clients.
    /// </remarks>
    /// <returns>Event ingested successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("analytics/event/ingest")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<IngestEventResponse>> IngestEvent([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] IngestEventRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.IngestEventAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Ingest multiple analytics events
    /// </summary>
    /// <remarks>
    /// Batch event ingestion for high-volume scenarios. Accepts up to 1000 events per request.
    /// <br/>Service-only endpoint - not exposed to clients.
    /// </remarks>
    /// <returns>Events ingested successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("analytics/event/ingest-batch")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<IngestEventBatchResponse>> IngestEventBatch([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] IngestEventBatchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.IngestEventBatchAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get entity statistics summary
    /// </summary>
    /// <remarks>
    /// Retrieve aggregated statistics for an entity. Summaries include total counts,
    /// <br/>averages, and derived metrics computed from ingested events.
    /// </remarks>
    /// <returns>Entity summary retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("analytics/summary/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EntitySummaryResponse>> GetEntitySummary([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetEntitySummaryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetEntitySummaryAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Query entity summaries with filters
    /// </summary>
    /// <remarks>
    /// Query multiple entity summaries with filtering and sorting options.
    /// <br/>Useful for dashboards and reporting.
    /// </remarks>
    /// <returns>Query executed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("analytics/summary/query")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryEntitySummariesResponse>> QueryEntitySummaries([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryEntitySummariesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.QueryEntitySummariesAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get entity Glicko-2 skill rating
    /// </summary>
    /// <remarks>
    /// Retrieve the current Glicko-2 skill rating for an entity.
    /// <br/>Returns rating, rating deviation (RD), and volatility.
    /// </remarks>
    /// <returns>Skill rating retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("analytics/rating/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SkillRatingResponse>> GetSkillRating([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetSkillRatingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetSkillRatingAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Update entity skill rating after match
    /// </summary>
    /// <remarks>
    /// Update skill ratings for entities after a match result.
    /// <br/>Uses Glicko-2 algorithm to compute new ratings based on outcomes.
    /// <br/>Service-only endpoint - typically called by game-session service.
    /// </remarks>
    /// <returns>Skill ratings updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("analytics/rating/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateSkillRatingResponse>> UpdateSkillRating([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateSkillRatingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateSkillRatingAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Record controller possession event
    /// </summary>
    /// <remarks>
    /// Record when an account takes or releases control of an entity.
    /// <br/>Used for tracking which player controlled which character/actor at what time.
    /// <br/>Service-only endpoint.
    /// </remarks>
    /// <returns>Controller event recorded successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("analytics/controller-history/record")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> RecordControllerEvent([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RecordControllerEventRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var statusCode = await _implementation.RecordControllerEventAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode);
    }

    /// <summary>
    /// Query controller history
    /// </summary>
    /// <remarks>
    /// Query who controlled what entity during a time range.
    /// <br/>Useful for audit trails and replays.
    /// </remarks>
    /// <returns>Controller history retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("analytics/controller-history/query")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryControllerHistoryResponse>> QueryControllerHistory([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryControllerHistoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.QueryControllerHistoryAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }



    #region Meta Endpoints for IngestEvent

    private static readonly string _IngestEvent_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/IngestEventRequest",
    "$defs": {
        "IngestEventRequest": {
            "type": "object",
            "description": "Request to ingest a single analytics event",
            "additionalProperties": false,
            "required": [
                "gameServiceId",
                "eventType",
                "entityId",
                "entityType",
                "timestamp"
            ],
            "properties": {
                "gameServiceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the game service that generated this event"
                },
                "eventType": {
                    "type": "string",
                    "description": "Type of event (e.g., kill, death, score, action)"
                },
                "entityId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the entity this event relates to"
                },
                "entityType": {
                    "$ref": "#/$defs/EntityType",
                    "description": "Entity type the event is attributed to"
                },
                "timestamp": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the event occurred"
                },
                "value": {
                    "type": "number",
                    "format": "double",
                    "description": "Numeric value associated with the event (e.g., score amount)"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Additional event-specific data"
                }
            }
        },
        "EntityType": {
            "type": "string",
            "description": "Type of entity being tracked",
            "enum": [
                "account",
                "character",
                "guild",
                "actor",
                "custom"
            ]
        }
    }
}
""";

    private static readonly string _IngestEvent_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/IngestEventResponse",
    "$defs": {
        "IngestEventResponse": {
            "type": "object",
            "description": "Response after ingesting an event",
            "additionalProperties": false,
            "required": [
                "eventId",
                "accepted"
            ],
            "properties": {
                "eventId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier assigned to this event"
                },
                "accepted": {
                    "type": "boolean",
                    "description": "Whether the event was accepted for processing"
                }
            }
        }
    }
}
""";

    private static readonly string _IngestEvent_Info = """
{
    "summary": "Ingest a single analytics event",
    "description": "High-throughput event ingestion endpoint for recording game events.\nEvents are buffered in memory and periodically flushed to persistent storage.\nService-only endpoint - not exposed to clients.\n",
    "tags": [
        "Event Ingestion"
    ],
    "deprecated": false,
    "operationId": "ingestEvent"
}
""";

    /// <summary>Returns endpoint information for IngestEvent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/event/ingest/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> IngestEvent_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Analytics",
            "Post",
            "analytics/event/ingest",
            _IngestEvent_Info));

    /// <summary>Returns request schema for IngestEvent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/event/ingest/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> IngestEvent_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/event/ingest",
            "request-schema",
            _IngestEvent_RequestSchema));

    /// <summary>Returns response schema for IngestEvent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/event/ingest/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> IngestEvent_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/event/ingest",
            "response-schema",
            _IngestEvent_ResponseSchema));

    /// <summary>Returns full schema for IngestEvent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/event/ingest/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> IngestEvent_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Analytics",
            "Post",
            "analytics/event/ingest",
            _IngestEvent_Info,
            _IngestEvent_RequestSchema,
            _IngestEvent_ResponseSchema));

    #endregion

    #region Meta Endpoints for IngestEventBatch

    private static readonly string _IngestEventBatch_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/IngestEventBatchRequest",
    "$defs": {
        "IngestEventBatchRequest": {
            "type": "object",
            "description": "Request to ingest multiple analytics events",
            "additionalProperties": false,
            "required": [
                "events"
            ],
            "properties": {
                "events": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/IngestEventRequest"
                    },
                    "maxItems": 1000,
                    "description": "List of events to ingest (max 1000)"
                }
            }
        },
        "IngestEventRequest": {
            "type": "object",
            "description": "Request to ingest a single analytics event",
            "additionalProperties": false,
            "required": [
                "gameServiceId",
                "eventType",
                "entityId",
                "entityType",
                "timestamp"
            ],
            "properties": {
                "gameServiceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the game service that generated this event"
                },
                "eventType": {
                    "type": "string",
                    "description": "Type of event (e.g., kill, death, score, action)"
                },
                "entityId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the entity this event relates to"
                },
                "entityType": {
                    "$ref": "#/$defs/EntityType",
                    "description": "Entity type the event is attributed to"
                },
                "timestamp": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the event occurred"
                },
                "value": {
                    "type": "number",
                    "format": "double",
                    "description": "Numeric value associated with the event (e.g., score amount)"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Additional event-specific data"
                }
            }
        },
        "EntityType": {
            "type": "string",
            "description": "Type of entity being tracked",
            "enum": [
                "account",
                "character",
                "guild",
                "actor",
                "custom"
            ]
        }
    }
}
""";

    private static readonly string _IngestEventBatch_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/IngestEventBatchResponse",
    "$defs": {
        "IngestEventBatchResponse": {
            "type": "object",
            "description": "Response after batch event ingestion",
            "additionalProperties": false,
            "required": [
                "accepted",
                "rejected"
            ],
            "properties": {
                "accepted": {
                    "type": "integer",
                    "description": "Number of events accepted"
                },
                "rejected": {
                    "type": "integer",
                    "description": "Number of events rejected"
                },
                "errors": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Error messages for rejected events"
                }
            }
        }
    }
}
""";

    private static readonly string _IngestEventBatch_Info = """
{
    "summary": "Ingest multiple analytics events",
    "description": "Batch event ingestion for high-volume scenarios. Accepts up to 1000 events per request.\nService-only endpoint - not exposed to clients.\n",
    "tags": [
        "Event Ingestion"
    ],
    "deprecated": false,
    "operationId": "ingestEventBatch"
}
""";

    /// <summary>Returns endpoint information for IngestEventBatch</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/event/ingest-batch/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> IngestEventBatch_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Analytics",
            "Post",
            "analytics/event/ingest-batch",
            _IngestEventBatch_Info));

    /// <summary>Returns request schema for IngestEventBatch</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/event/ingest-batch/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> IngestEventBatch_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/event/ingest-batch",
            "request-schema",
            _IngestEventBatch_RequestSchema));

    /// <summary>Returns response schema for IngestEventBatch</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/event/ingest-batch/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> IngestEventBatch_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/event/ingest-batch",
            "response-schema",
            _IngestEventBatch_ResponseSchema));

    /// <summary>Returns full schema for IngestEventBatch</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/event/ingest-batch/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> IngestEventBatch_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Analytics",
            "Post",
            "analytics/event/ingest-batch",
            _IngestEventBatch_Info,
            _IngestEventBatch_RequestSchema,
            _IngestEventBatch_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetEntitySummary

    private static readonly string _GetEntitySummary_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetEntitySummaryRequest",
    "$defs": {
        "GetEntitySummaryRequest": {
            "type": "object",
            "description": "Request to get statistics for an entity",
            "additionalProperties": false,
            "required": [
                "gameServiceId",
                "entityId",
                "entityType"
            ],
            "properties": {
                "gameServiceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the game service"
                },
                "entityId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the entity"
                },
                "entityType": {
                    "$ref": "#/$defs/EntityType",
                    "description": "Entity type to summarize"
                }
            }
        },
        "EntityType": {
            "type": "string",
            "description": "Type of entity being tracked",
            "enum": [
                "account",
                "character",
                "guild",
                "actor",
                "custom"
            ]
        }
    }
}
""";

    private static readonly string _GetEntitySummary_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/EntitySummaryResponse",
    "$defs": {
        "EntitySummaryResponse": {
            "type": "object",
            "description": "Aggregated statistics for an entity",
            "additionalProperties": false,
            "required": [
                "entityId",
                "entityType",
                "totalEvents",
                "firstEventAt",
                "lastEventAt"
            ],
            "properties": {
                "entityId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the entity"
                },
                "entityType": {
                    "$ref": "#/$defs/EntityType",
                    "description": "Entity type for this summary"
                },
                "totalEvents": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Total number of events recorded"
                },
                "firstEventAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp of first recorded event"
                },
                "lastEventAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp of most recent event"
                },
                "eventCounts": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer",
                        "format": "int64"
                    },
                    "description": "Count of events by type"
                },
                "aggregates": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "number",
                        "format": "double"
                    },
                    "description": "Aggregated numeric values (sums, averages)"
                }
            }
        },
        "EntityType": {
            "type": "string",
            "description": "Type of entity being tracked",
            "enum": [
                "account",
                "character",
                "guild",
                "actor",
                "custom"
            ]
        }
    }
}
""";

    private static readonly string _GetEntitySummary_Info = """
{
    "summary": "Get entity statistics summary",
    "description": "Retrieve aggregated statistics for an entity. Summaries include total counts,\naverages, and derived metrics computed from ingested events.\n",
    "tags": [
        "Statistics"
    ],
    "deprecated": false,
    "operationId": "getEntitySummary"
}
""";

    /// <summary>Returns endpoint information for GetEntitySummary</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/summary/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetEntitySummary_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Analytics",
            "Post",
            "analytics/summary/get",
            _GetEntitySummary_Info));

    /// <summary>Returns request schema for GetEntitySummary</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/summary/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetEntitySummary_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/summary/get",
            "request-schema",
            _GetEntitySummary_RequestSchema));

    /// <summary>Returns response schema for GetEntitySummary</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/summary/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetEntitySummary_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/summary/get",
            "response-schema",
            _GetEntitySummary_ResponseSchema));

    /// <summary>Returns full schema for GetEntitySummary</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/summary/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetEntitySummary_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Analytics",
            "Post",
            "analytics/summary/get",
            _GetEntitySummary_Info,
            _GetEntitySummary_RequestSchema,
            _GetEntitySummary_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryEntitySummaries

    private static readonly string _QueryEntitySummaries_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryEntitySummariesRequest",
    "$defs": {
        "QueryEntitySummariesRequest": {
            "type": "object",
            "description": "Request to query multiple entity summaries",
            "additionalProperties": false,
            "required": [
                "gameServiceId"
            ],
            "properties": {
                "gameServiceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the game service"
                },
                "entityType": {
                    "$ref": "#/$defs/EntityType",
                    "nullable": true,
                    "description": "Optional filter by entity type"
                },
                "eventType": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by event type"
                },
                "minEvents": {
                    "type": "integer",
                    "description": "Minimum number of events"
                },
                "sortBy": {
                    "type": "string",
                    "nullable": true,
                    "description": "Field to sort by"
                },
                "sortDescending": {
                    "type": "boolean",
                    "default": true,
                    "description": "Sort in descending order"
                },
                "limit": {
                    "type": "integer",
                    "default": 100,
                    "maximum": 1000,
                    "description": "Maximum results to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Number of results to skip"
                }
            }
        },
        "EntityType": {
            "type": "string",
            "description": "Type of entity being tracked",
            "enum": [
                "account",
                "character",
                "guild",
                "actor",
                "custom"
            ]
        }
    }
}
""";

    private static readonly string _QueryEntitySummaries_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryEntitySummariesResponse",
    "$defs": {
        "QueryEntitySummariesResponse": {
            "type": "object",
            "description": "Response containing queried entity summaries",
            "additionalProperties": false,
            "required": [
                "summaries",
                "total"
            ],
            "properties": {
                "summaries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/EntitySummaryResponse"
                    },
                    "description": "List of matching entity summaries"
                },
                "total": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Total number of matching entities"
                }
            }
        },
        "EntitySummaryResponse": {
            "type": "object",
            "description": "Aggregated statistics for an entity",
            "additionalProperties": false,
            "required": [
                "entityId",
                "entityType",
                "totalEvents",
                "firstEventAt",
                "lastEventAt"
            ],
            "properties": {
                "entityId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the entity"
                },
                "entityType": {
                    "$ref": "#/$defs/EntityType",
                    "description": "Entity type for this summary"
                },
                "totalEvents": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Total number of events recorded"
                },
                "firstEventAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp of first recorded event"
                },
                "lastEventAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp of most recent event"
                },
                "eventCounts": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer",
                        "format": "int64"
                    },
                    "description": "Count of events by type"
                },
                "aggregates": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "number",
                        "format": "double"
                    },
                    "description": "Aggregated numeric values (sums, averages)"
                }
            }
        },
        "EntityType": {
            "type": "string",
            "description": "Type of entity being tracked",
            "enum": [
                "account",
                "character",
                "guild",
                "actor",
                "custom"
            ]
        }
    }
}
""";

    private static readonly string _QueryEntitySummaries_Info = """
{
    "summary": "Query entity summaries with filters",
    "description": "Query multiple entity summaries with filtering and sorting options.\nUseful for dashboards and reporting.\n",
    "tags": [
        "Statistics"
    ],
    "deprecated": false,
    "operationId": "queryEntitySummaries"
}
""";

    /// <summary>Returns endpoint information for QueryEntitySummaries</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/summary/query/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryEntitySummaries_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Analytics",
            "Post",
            "analytics/summary/query",
            _QueryEntitySummaries_Info));

    /// <summary>Returns request schema for QueryEntitySummaries</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/summary/query/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryEntitySummaries_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/summary/query",
            "request-schema",
            _QueryEntitySummaries_RequestSchema));

    /// <summary>Returns response schema for QueryEntitySummaries</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/summary/query/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryEntitySummaries_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/summary/query",
            "response-schema",
            _QueryEntitySummaries_ResponseSchema));

    /// <summary>Returns full schema for QueryEntitySummaries</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/summary/query/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryEntitySummaries_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Analytics",
            "Post",
            "analytics/summary/query",
            _QueryEntitySummaries_Info,
            _QueryEntitySummaries_RequestSchema,
            _QueryEntitySummaries_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetSkillRating

    private static readonly string _GetSkillRating_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetSkillRatingRequest",
    "$defs": {
        "GetSkillRatingRequest": {
            "type": "object",
            "description": "Request to get skill rating for an entity",
            "additionalProperties": false,
            "required": [
                "gameServiceId",
                "entityId",
                "entityType",
                "ratingType"
            ],
            "properties": {
                "gameServiceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the game service"
                },
                "entityId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the entity"
                },
                "entityType": {
                    "$ref": "#/$defs/EntityType",
                    "description": "Entity type whose rating is requested"
                },
                "ratingType": {
                    "type": "string",
                    "description": "Type of rating (e.g., overall, ranked, casual)"
                }
            }
        },
        "EntityType": {
            "type": "string",
            "description": "Type of entity being tracked",
            "enum": [
                "account",
                "character",
                "guild",
                "actor",
                "custom"
            ]
        }
    }
}
""";

    private static readonly string _GetSkillRating_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/SkillRatingResponse",
    "$defs": {
        "SkillRatingResponse": {
            "type": "object",
            "description": "Glicko-2 skill rating for an entity",
            "additionalProperties": false,
            "required": [
                "entityId",
                "entityType",
                "ratingType",
                "rating",
                "ratingDeviation",
                "volatility",
                "matchesPlayed"
            ],
            "properties": {
                "entityId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the entity"
                },
                "entityType": {
                    "$ref": "#/$defs/EntityType",
                    "description": "Entity type for this rating record"
                },
                "ratingType": {
                    "type": "string",
                    "description": "Type of rating"
                },
                "rating": {
                    "type": "number",
                    "format": "double",
                    "description": "Current Glicko-2 rating (typically 1500 start)"
                },
                "ratingDeviation": {
                    "type": "number",
                    "format": "double",
                    "description": "Rating deviation (uncertainty) - lower is more confident"
                },
                "volatility": {
                    "type": "number",
                    "format": "double",
                    "description": "Rating volatility (consistency of performance)"
                },
                "matchesPlayed": {
                    "type": "integer",
                    "description": "Number of rated matches played"
                },
                "lastMatchAt": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "Timestamp of last rated match"
                }
            }
        },
        "EntityType": {
            "type": "string",
            "description": "Type of entity being tracked",
            "enum": [
                "account",
                "character",
                "guild",
                "actor",
                "custom"
            ]
        }
    }
}
""";

    private static readonly string _GetSkillRating_Info = """
{
    "summary": "Get entity Glicko-2 skill rating",
    "description": "Retrieve the current Glicko-2 skill rating for an entity.\nReturns rating, rating deviation (RD), and volatility.\n",
    "tags": [
        "Skill Ratings"
    ],
    "deprecated": false,
    "operationId": "getSkillRating"
}
""";

    /// <summary>Returns endpoint information for GetSkillRating</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/rating/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSkillRating_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Analytics",
            "Post",
            "analytics/rating/get",
            _GetSkillRating_Info));

    /// <summary>Returns request schema for GetSkillRating</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/rating/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSkillRating_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/rating/get",
            "request-schema",
            _GetSkillRating_RequestSchema));

    /// <summary>Returns response schema for GetSkillRating</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/rating/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSkillRating_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/rating/get",
            "response-schema",
            _GetSkillRating_ResponseSchema));

    /// <summary>Returns full schema for GetSkillRating</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/rating/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSkillRating_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Analytics",
            "Post",
            "analytics/rating/get",
            _GetSkillRating_Info,
            _GetSkillRating_RequestSchema,
            _GetSkillRating_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateSkillRating

    private static readonly string _UpdateSkillRating_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateSkillRatingRequest",
    "$defs": {
        "UpdateSkillRatingRequest": {
            "type": "object",
            "description": "Request to update skill ratings after a match",
            "additionalProperties": false,
            "required": [
                "gameServiceId",
                "ratingType",
                "matchId",
                "results"
            ],
            "properties": {
                "gameServiceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the game service"
                },
                "ratingType": {
                    "type": "string",
                    "description": "Type of rating to update"
                },
                "matchId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this match"
                },
                "results": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MatchResult"
                    },
                    "minItems": 2,
                    "description": "Results for all participants (min 2)"
                }
            }
        },
        "MatchResult": {
            "type": "object",
            "description": "Individual result in a match",
            "additionalProperties": false,
            "required": [
                "entityId",
                "entityType",
                "outcome"
            ],
            "properties": {
                "entityId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the participating entity"
                },
                "entityType": {
                    "$ref": "#/$defs/EntityType",
                    "description": "Entity type for this match participant"
                },
                "outcome": {
                    "type": "number",
                    "format": "double",
                    "minimum": 0,
                    "maximum": 1,
                    "description": "Match outcome (1.0 = win, 0.5 = draw, 0.0 = loss)"
                },
                "score": {
                    "type": "number",
                    "format": "double",
                    "nullable": true,
                    "description": "Optional numeric score for the match"
                }
            }
        },
        "EntityType": {
            "type": "string",
            "description": "Type of entity being tracked",
            "enum": [
                "account",
                "character",
                "guild",
                "actor",
                "custom"
            ]
        }
    }
}
""";

    private static readonly string _UpdateSkillRating_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateSkillRatingResponse",
    "$defs": {
        "UpdateSkillRatingResponse": {
            "type": "object",
            "description": "Response after updating skill ratings",
            "additionalProperties": false,
            "required": [
                "matchId",
                "updatedRatings"
            ],
            "properties": {
                "matchId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the processed match"
                },
                "updatedRatings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SkillRatingChange"
                    },
                    "description": "Updated ratings for all participants"
                }
            }
        },
        "SkillRatingChange": {
            "type": "object",
            "description": "Rating change for a single entity",
            "additionalProperties": false,
            "required": [
                "entityId",
                "entityType",
                "previousRating",
                "newRating",
                "ratingChange"
            ],
            "properties": {
                "entityId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the entity"
                },
                "entityType": {
                    "$ref": "#/$defs/EntityType",
                    "description": "Entity type for this rating change"
                },
                "previousRating": {
                    "type": "number",
                    "format": "double",
                    "description": "Rating before this match"
                },
                "newRating": {
                    "type": "number",
                    "format": "double",
                    "description": "Rating after this match"
                },
                "ratingChange": {
                    "type": "number",
                    "format": "double",
                    "description": "Change in rating (can be negative)"
                }
            }
        },
        "EntityType": {
            "type": "string",
            "description": "Type of entity being tracked",
            "enum": [
                "account",
                "character",
                "guild",
                "actor",
                "custom"
            ]
        }
    }
}
""";

    private static readonly string _UpdateSkillRating_Info = """
{
    "summary": "Update entity skill rating after match",
    "description": "Update skill ratings for entities after a match result.\nUses Glicko-2 algorithm to compute new ratings based on outcomes.\ nService-only endpoint - typically called by game-session service.\n",
    "tags": [
        "Skill Ratings"
    ],
    "deprecated": false,
    "operationId": "updateSkillRating"
}
""";

    /// <summary>Returns endpoint information for UpdateSkillRating</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/rating/update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateSkillRating_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Analytics",
            "Post",
            "analytics/rating/update",
            _UpdateSkillRating_Info));

    /// <summary>Returns request schema for UpdateSkillRating</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/rating/update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateSkillRating_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/rating/update",
            "request-schema",
            _UpdateSkillRating_RequestSchema));

    /// <summary>Returns response schema for UpdateSkillRating</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/rating/update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateSkillRating_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/rating/update",
            "response-schema",
            _UpdateSkillRating_ResponseSchema));

    /// <summary>Returns full schema for UpdateSkillRating</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/rating/update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateSkillRating_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Analytics",
            "Post",
            "analytics/rating/update",
            _UpdateSkillRating_Info,
            _UpdateSkillRating_RequestSchema,
            _UpdateSkillRating_ResponseSchema));

    #endregion

    #region Meta Endpoints for RecordControllerEvent

    private static readonly string _RecordControllerEvent_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RecordControllerEventRequest",
    "$defs": {
        "RecordControllerEventRequest": {
            "type": "object",
            "description": "Request to record a controller possession/release event",
            "additionalProperties": false,
            "required": [
                "gameServiceId",
                "accountId",
                "targetEntityId",
                "targetEntityType",
                "action",
                "timestamp"
            ],
            "properties": {
                "gameServiceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the game service"
                },
                "accountId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the account taking/releasing control"
                },
                "targetEntityId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the entity being controlled"
                },
                "targetEntityType": {
                    "$ref": "#/$defs/EntityType",
                    "description": "Entity type being controlled"
                },
                "action": {
                    "$ref": "#/$defs/ControllerAction",
                    "description": "Whether control was possessed or released"
                },
                "timestamp": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the control event occurred"
                },
                "sessionId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Game session ID (if applicable)"
                }
            }
        },
        "EntityType": {
            "type": "string",
            "description": "Type of entity being tracked",
            "enum": [
                "account",
                "character",
                "guild",
                "actor",
                "custom"
            ]
        },
        "ControllerAction": {
            "type": "string",
            "description": "Type of controller action",
            "enum": [
                "possess",
                "release"
            ]
        }
    }
}
""";

    private static readonly string _RecordControllerEvent_ResponseSchema = """
{}
""";

    private static readonly string _RecordControllerEvent_Info = """
{
    "summary": "Record controller possession event",
    "description": "Record when an account takes or releases control of an entity.\nUsed for tracking which player controlled which character/actor at what time.\nService-only endpoint.\n",
    "tags": [
        "Controller History"
    ],
    "deprecated": false,
    "operationId": "recordControllerEvent"
}
""";

    /// <summary>Returns endpoint information for RecordControllerEvent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/controller-history/record/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RecordControllerEvent_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Analytics",
            "Post",
            "analytics/controller-history/record",
            _RecordControllerEvent_Info));

    /// <summary>Returns request schema for RecordControllerEvent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/controller-history/record/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RecordControllerEvent_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/controller-history/record",
            "request-schema",
            _RecordControllerEvent_RequestSchema));

    /// <summary>Returns response schema for RecordControllerEvent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/controller-history/record/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RecordControllerEvent_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/controller-history/record",
            "response-schema",
            _RecordControllerEvent_ResponseSchema));

    /// <summary>Returns full schema for RecordControllerEvent</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/controller-history/record/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RecordControllerEvent_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Analytics",
            "Post",
            "analytics/controller-history/record",
            _RecordControllerEvent_Info,
            _RecordControllerEvent_RequestSchema,
            _RecordControllerEvent_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryControllerHistory

    private static readonly string _QueryControllerHistory_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryControllerHistoryRequest",
    "$defs": {
        "QueryControllerHistoryRequest": {
            "type": "object",
            "description": "Request to query controller history",
            "additionalProperties": false,
            "required": [
                "gameServiceId"
            ],
            "properties": {
                "gameServiceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the game service"
                },
                "accountId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Filter by controlling account"
                },
                "targetEntityId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Filter by controlled entity"
                },
                "targetEntityType": {
                    "$ref": "#/$defs/EntityType",
                    "nullable": true,
                    "description": "Filter by entity type"
                },
                "startTime": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "Start of time range"
                },
                "endTime": {
                    "type": "string",
                    "format": "date-time",
                    "nullable": true,
                    "description": "End of time range"
                },
                "limit": {
                    "type": "integer",
                    "default": 100,
                    "maximum": 1000,
                    "description": "Maximum results to return"
                }
            }
        },
        "EntityType": {
            "type": "string",
            "description": "Type of entity being tracked",
            "enum": [
                "account",
                "character",
                "guild",
                "actor",
                "custom"
            ]
        }
    }
}
""";

    private static readonly string _QueryControllerHistory_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryControllerHistoryResponse",
    "$defs": {
        "QueryControllerHistoryResponse": {
            "type": "object",
            "description": "Response containing controller history",
            "additionalProperties": false,
            "required": [
                "events"
            ],
            "properties": {
                "events": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ControllerHistoryEvent"
                    },
                    "description": "Controller events matching the query"
                }
            }
        },
        "ControllerHistoryEvent": {
            "type": "object",
            "description": "A single controller possession/release event",
            "additionalProperties": false,
            "required": [
                "eventId",
                "accountId",
                "targetEntityId",
                "targetEntityType",
                "action",
                "timestamp"
            ],
            "properties": {
                "eventId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this event"
                },
                "accountId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the controlling account"
                },
                "targetEntityId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the controlled entity"
                },
                "targetEntityType": {
                    "$ref": "#/$defs/EntityType",
                    "description": "Entity type that was controlled"
                },
                "action": {
                    "$ref": "#/$defs/ControllerAction",
                    "description": "Control action that occurred (possess/release)"
                },
                "timestamp": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the event occurred"
                },
                "sessionId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Associated game session ID"
                }
            }
        },
        "EntityType": {
            "type": "string",
            "description": "Type of entity being tracked",
            "enum": [
                "account",
                "character",
                "guild",
                "actor",
                "custom"
            ]
        },
        "ControllerAction": {
            "type": "string",
            "description": "Type of controller action",
            "enum": [
                "possess",
                "release"
            ]
        }
    }
}
""";

    private static readonly string _QueryControllerHistory_Info = """
{
    "summary": "Query controller history",
    "description": "Query who controlled what entity during a time range.\nUseful for audit trails and replays.\n",
    "tags": [
        "Controller History"
    ],
    "deprecated": false,
    "operationId": "queryControllerHistory"
}
""";

    /// <summary>Returns endpoint information for QueryControllerHistory</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/controller-history/query/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryControllerHistory_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Analytics",
            "Post",
            "analytics/controller-history/query",
            _QueryControllerHistory_Info));

    /// <summary>Returns request schema for QueryControllerHistory</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/controller-history/query/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryControllerHistory_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/controller-history/query",
            "request-schema",
            _QueryControllerHistory_RequestSchema));

    /// <summary>Returns response schema for QueryControllerHistory</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/controller-history/query/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryControllerHistory_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Analytics",
            "Post",
            "analytics/controller-history/query",
            "response-schema",
            _QueryControllerHistory_ResponseSchema));

    /// <summary>Returns full schema for QueryControllerHistory</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("analytics/controller-history/query/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryControllerHistory_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Analytics",
            "Post",
            "analytics/controller-history/query",
            _QueryControllerHistory_Info,
            _QueryControllerHistory_RequestSchema,
            _QueryControllerHistory_ResponseSchema));

    #endregion

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
