//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     RELATED FILES:
//     - Request/Response models: bannou-service/Generated/Models/{Service}Models.cs
//     - Event models: bannou-service/Generated/Events/{Service}EventsModels.cs
//     - Lifecycle events: bannou-service/Generated/Events/{Service}LifecycleEvents.cs
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Escrow;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IEscrowController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Create a new escrow agreement
    /// </summary>

    /// <remarks>
    /// Create a new escrow agreement. For each party, creates a dedicated escrow wallet
    /// <br/>and container (owned by escrow entity). Issues deposit tokens and returns ALL
    /// <br/>tokens to the creating service, which is responsible for distributing them to
    /// <br/>parties through appropriate channels. Sets template values on bound contract.
    /// </remarks>

    /// <returns>Escrow created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateEscrowResponse>> CreateEscrowAsync(CreateEscrowRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get escrow details
    /// </summary>

    /// <remarks>
    /// Get escrow agreement details by ID.
    /// </remarks>

    /// <returns>Escrow details</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetEscrowResponse>> GetEscrowAsync(GetEscrowRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List escrows for a party
    /// </summary>

    /// <remarks>
    /// List escrow agreements with filtering options.
    /// </remarks>

    /// <returns>List of escrows</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListEscrowsResponse>> ListEscrowsAsync(ListEscrowsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get deposit or release token for a party
    /// </summary>

    /// <remarks>
    /// Get the deposit or release token for a specific party. Internal-only endpoint
    /// <br/>accessed via Shortcut APIs (prebound). Direct user access is prohibited to prevent
    /// <br/>token snooping. The party is identified by ownerId/ownerType (works for characters,
    /// <br/>NPCs, guilds, etc.).
    /// </remarks>

    /// <returns>Token information</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetMyTokenResponse>> GetMyTokenAsync(GetMyTokenRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Deposit assets into escrow
    /// </summary>

    /// <remarks>
    /// Deposit assets into escrow. Transfers currency from party's own wallet to that
    /// <br/>party's escrow wallet. Moves items from party's own container to that party's
    /// <br/>escrow container. Locks contracts with escrow as guardian.
    /// <br/>Rejects soulbound/non-tradeable items. After each deposit, queries bound contract
    /// <br/>to check if all asset requirements are satisfied.
    /// </remarks>

    /// <returns>Deposit successful</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DepositResponse>> DepositAsync(DepositRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Validate a deposit without executing
    /// </summary>

    /// <remarks>
    /// Validate a deposit without executing (dry run).
    /// </remarks>

    /// <returns>Validation result</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ValidateDepositResponse>> ValidateDepositAsync(ValidateDepositRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get deposit status for a party
    /// </summary>

    /// <remarks>
    /// Get deposit status for a party in an escrow.
    /// </remarks>

    /// <returns>Deposit status</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetDepositStatusResponse>> GetDepositStatusAsync(GetDepositStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Record party consent
    /// </summary>

    /// <remarks>
    /// Record party consent for release, refund, or re-affirmation.
    /// </remarks>

    /// <returns>Consent recorded</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConsentResponse>> RecordConsentAsync(ConsentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get consent status for escrow
    /// </summary>

    /// <remarks>
    /// Get consent status for all parties in an escrow.
    /// </remarks>

    /// <returns>Consent status</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetConsentStatusResponse>> GetConsentStatusAsync(GetConsentStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Trigger release
    /// </summary>

    /// <remarks>
    /// Trigger release (for trusted modes or after consent).
    /// <br/>If boundContractId is set, checks contract status first (must be fulfilled).
    /// <br/>Runs finalization flow before releasing remaining assets.
    /// </remarks>

    /// <returns>Release result</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ReleaseResponse>> ReleaseAsync(ReleaseRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Trigger refund
    /// </summary>

    /// <remarks>
    /// Trigger refund (for trusted modes or consent).
    /// </remarks>

    /// <returns>Refund result</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RefundResponse>> RefundAsync(RefundRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Cancel escrow before fully funded
    /// </summary>

    /// <remarks>
    /// Cancel escrow before fully funded, refunding any deposits.
    /// </remarks>

    /// <returns>Cancel result</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CancelResponse>> CancelAsync(CancelRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Raise a dispute on funded escrow
    /// </summary>

    /// <remarks>
    /// Raise a dispute on a funded escrow.
    /// </remarks>

    /// <returns>Dispute raised</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DisputeResponse>> DisputeAsync(DisputeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Confirm receipt of released assets
    /// </summary>

    /// <remarks>
    /// Called by parties to confirm they received their released assets.
    /// <br/>Required when ReleaseMode is party_required or service_and_party.
    /// </remarks>

    /// <returns>Confirmation recorded</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfirmReleaseResponse>> ConfirmReleaseAsync(ConfirmReleaseRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Confirm receipt of refunded assets
    /// </summary>

    /// <remarks>
    /// Called by parties to confirm they received their refunded deposits.
    /// <br/>Required when RefundMode is party_required.
    /// </remarks>

    /// <returns>Confirmation recorded</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfirmRefundResponse>> ConfirmRefundAsync(ConfirmRefundRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Arbiter resolves disputed escrow
    /// </summary>

    /// <remarks>
    /// Arbiter resolves a disputed escrow.
    /// </remarks>

    /// <returns>Resolution result</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ResolveResponse>> ResolveAsync(ResolveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Verify condition for conditional escrow
    /// </summary>

    /// <remarks>
    /// Verify condition for conditional escrow (non-contract path).
    /// <br/>For escrows with boundContractId, use contract milestones instead.
    /// </remarks>

    /// <returns>Verification result</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<VerifyConditionResponse>> VerifyConditionAsync(VerifyConditionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Manually trigger validation
    /// </summary>

    /// <remarks>
    /// Manually trigger validation on an active escrow.
    /// </remarks>

    /// <returns>Validation result</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ValidateEscrowResponse>> ValidateEscrowAsync(ValidateEscrowRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Re-affirm after validation failure
    /// </summary>

    /// <remarks>
    /// Re-affirm after validation failure (party accepts changed state).
    /// </remarks>

    /// <returns>Reaffirmation result</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ReaffirmResponse>> ReaffirmAsync(ReaffirmRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Register a custom asset type handler
    /// </summary>

    /// <remarks>
    /// Register a custom asset type handler for extensibility.
    /// </remarks>

    /// <returns>Handler registered</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RegisterHandlerResponse>> RegisterHandlerAsync(RegisterHandlerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List registered asset handlers
    /// </summary>

    /// <remarks>
    /// List registered asset handlers (includes built-in).
    /// </remarks>

    /// <returns>List of handlers</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListHandlersResponse>> ListHandlersAsync(ListHandlersRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Remove a custom asset handler registration
    /// </summary>

    /// <remarks>
    /// Remove a custom asset handler registration.
    /// </remarks>

    /// <returns>Handler deregistered</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeregisterHandlerResponse>> DeregisterHandlerAsync(DeregisterHandlerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class EscrowController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IEscrowService _implementation;

    public EscrowController(IEscrowService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Create a new escrow agreement
    /// </summary>
    /// <remarks>
    /// Create a new escrow agreement. For each party, creates a dedicated escrow wallet
    /// <br/>and container (owned by escrow entity). Issues deposit tokens and returns ALL
    /// <br/>tokens to the creating service, which is responsible for distributing them to
    /// <br/>parties through appropriate channels. Sets template values on bound contract.
    /// </remarks>
    /// <returns>Escrow created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateEscrowResponse>> CreateEscrow([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateEscrowRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.CreateEscrowAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/create");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "CreateEscrow",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get escrow details
    /// </summary>
    /// <remarks>
    /// Get escrow agreement details by ID.
    /// </remarks>
    /// <returns>Escrow details</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetEscrowResponse>> GetEscrow([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetEscrowRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetEscrowAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/get");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "GetEscrow",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List escrows for a party
    /// </summary>
    /// <remarks>
    /// List escrow agreements with filtering options.
    /// </remarks>
    /// <returns>List of escrows</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListEscrowsResponse>> ListEscrows([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListEscrowsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ListEscrowsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/list");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "ListEscrows",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get deposit or release token for a party
    /// </summary>
    /// <remarks>
    /// Get the deposit or release token for a specific party. Internal-only endpoint
    /// <br/>accessed via Shortcut APIs (prebound). Direct user access is prohibited to prevent
    /// <br/>token snooping. The party is identified by ownerId/ownerType (works for characters,
    /// <br/>NPCs, guilds, etc.).
    /// </remarks>
    /// <returns>Token information</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/get-my-token")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetMyTokenResponse>> GetMyToken([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetMyTokenRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetMyTokenAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/get-my-token");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/get-my-token");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "GetMyToken",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/get-my-token",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Deposit assets into escrow
    /// </summary>
    /// <remarks>
    /// Deposit assets into escrow. Transfers currency from party's own wallet to that
    /// <br/>party's escrow wallet. Moves items from party's own container to that party's
    /// <br/>escrow container. Locks contracts with escrow as guardian.
    /// <br/>Rejects soulbound/non-tradeable items. After each deposit, queries bound contract
    /// <br/>to check if all asset requirements are satisfied.
    /// </remarks>
    /// <returns>Deposit successful</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/deposit")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DepositResponse>> Deposit([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DepositRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.DepositAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/deposit");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/deposit");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "Deposit",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/deposit",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Validate a deposit without executing
    /// </summary>
    /// <remarks>
    /// Validate a deposit without executing (dry run).
    /// </remarks>
    /// <returns>Validation result</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/deposit/validate")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ValidateDepositResponse>> ValidateDeposit([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ValidateDepositRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ValidateDepositAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/deposit/validate");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/deposit/validate");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "ValidateDeposit",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/deposit/validate",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get deposit status for a party
    /// </summary>
    /// <remarks>
    /// Get deposit status for a party in an escrow.
    /// </remarks>
    /// <returns>Deposit status</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/deposit/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetDepositStatusResponse>> GetDepositStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetDepositStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetDepositStatusAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/deposit/status");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/deposit/status");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "GetDepositStatus",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/deposit/status",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Record party consent
    /// </summary>
    /// <remarks>
    /// Record party consent for release, refund, or re-affirmation.
    /// </remarks>
    /// <returns>Consent recorded</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/consent")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConsentResponse>> RecordConsent([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ConsentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.RecordConsentAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/consent");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/consent");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "RecordConsent",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/consent",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get consent status for escrow
    /// </summary>
    /// <remarks>
    /// Get consent status for all parties in an escrow.
    /// </remarks>
    /// <returns>Consent status</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/consent/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetConsentStatusResponse>> GetConsentStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetConsentStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetConsentStatusAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/consent/status");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/consent/status");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "GetConsentStatus",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/consent/status",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Trigger release
    /// </summary>
    /// <remarks>
    /// Trigger release (for trusted modes or after consent).
    /// <br/>If boundContractId is set, checks contract status first (must be fulfilled).
    /// <br/>Runs finalization flow before releasing remaining assets.
    /// </remarks>
    /// <returns>Release result</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/release")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ReleaseResponse>> Release([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ReleaseRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ReleaseAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/release");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/release");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "Release",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/release",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Trigger refund
    /// </summary>
    /// <remarks>
    /// Trigger refund (for trusted modes or consent).
    /// </remarks>
    /// <returns>Refund result</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/refund")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RefundResponse>> Refund([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RefundRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.RefundAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/refund");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/refund");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "Refund",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/refund",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Cancel escrow before fully funded
    /// </summary>
    /// <remarks>
    /// Cancel escrow before fully funded, refunding any deposits.
    /// </remarks>
    /// <returns>Cancel result</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/cancel")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CancelResponse>> Cancel([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CancelRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.CancelAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/cancel");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/cancel");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "Cancel",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/cancel",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Raise a dispute on funded escrow
    /// </summary>
    /// <remarks>
    /// Raise a dispute on a funded escrow.
    /// </remarks>
    /// <returns>Dispute raised</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/dispute")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DisputeResponse>> Dispute([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DisputeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.DisputeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/dispute");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/dispute");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "Dispute",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/dispute",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Confirm receipt of released assets
    /// </summary>
    /// <remarks>
    /// Called by parties to confirm they received their released assets.
    /// <br/>Required when ReleaseMode is party_required or service_and_party.
    /// </remarks>
    /// <returns>Confirmation recorded</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/confirm-release")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfirmReleaseResponse>> ConfirmRelease([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ConfirmReleaseRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ConfirmReleaseAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/confirm-release");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/confirm-release");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "ConfirmRelease",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/confirm-release",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Confirm receipt of refunded assets
    /// </summary>
    /// <remarks>
    /// Called by parties to confirm they received their refunded deposits.
    /// <br/>Required when RefundMode is party_required.
    /// </remarks>
    /// <returns>Confirmation recorded</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/confirm-refund")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfirmRefundResponse>> ConfirmRefund([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ConfirmRefundRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ConfirmRefundAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/confirm-refund");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/confirm-refund");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "ConfirmRefund",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/confirm-refund",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Arbiter resolves disputed escrow
    /// </summary>
    /// <remarks>
    /// Arbiter resolves a disputed escrow.
    /// </remarks>
    /// <returns>Resolution result</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/resolve")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ResolveResponse>> Resolve([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ResolveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ResolveAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/resolve");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/resolve");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "Resolve",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/resolve",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Verify condition for conditional escrow
    /// </summary>
    /// <remarks>
    /// Verify condition for conditional escrow (non-contract path).
    /// <br/>For escrows with boundContractId, use contract milestones instead.
    /// </remarks>
    /// <returns>Verification result</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/verify-condition")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<VerifyConditionResponse>> VerifyCondition([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] VerifyConditionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.VerifyConditionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/verify-condition");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/verify-condition");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "VerifyCondition",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/verify-condition",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Manually trigger validation
    /// </summary>
    /// <remarks>
    /// Manually trigger validation on an active escrow.
    /// </remarks>
    /// <returns>Validation result</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/validate")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ValidateEscrowResponse>> ValidateEscrow([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ValidateEscrowRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ValidateEscrowAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/validate");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/validate");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "ValidateEscrow",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/validate",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Re-affirm after validation failure
    /// </summary>
    /// <remarks>
    /// Re-affirm after validation failure (party accepts changed state).
    /// </remarks>
    /// <returns>Reaffirmation result</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/reaffirm")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ReaffirmResponse>> Reaffirm([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ReaffirmRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ReaffirmAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/reaffirm");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/reaffirm");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "Reaffirm",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/reaffirm",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Register a custom asset type handler
    /// </summary>
    /// <remarks>
    /// Register a custom asset type handler for extensibility.
    /// </remarks>
    /// <returns>Handler registered</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/handler/register")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RegisterHandlerResponse>> RegisterHandler([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RegisterHandlerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.RegisterHandlerAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/handler/register");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/handler/register");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "RegisterHandler",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/handler/register",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List registered asset handlers
    /// </summary>
    /// <remarks>
    /// List registered asset handlers (includes built-in).
    /// </remarks>
    /// <returns>List of handlers</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/handler/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListHandlersResponse>> ListHandlers([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListHandlersRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ListHandlersAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/handler/list");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/handler/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "ListHandlers",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/handler/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Remove a custom asset handler registration
    /// </summary>
    /// <remarks>
    /// Remove a custom asset handler registration.
    /// </remarks>
    /// <returns>Handler deregistered</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("escrow/handler/deregister")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeregisterHandlerResponse>> DeregisterHandler([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeregisterHandlerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.DeregisterHandlerAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:escrow/handler/deregister");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<EscrowController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:escrow/handler/deregister");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "escrow",
                "DeregisterHandler",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:escrow/handler/deregister",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765