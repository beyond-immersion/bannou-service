//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace BeyondImmersion.BannouService.Scene;

/// <summary>
/// Meta/introspection endpoints for runtime schema access.
/// Generated from schemas/Generated/scene-api-meta.yaml
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("generate-meta-controller.sh", "1.0")]
public partial class SceneController
{
    #region Meta Endpoints for CreateScene

    private static readonly string _CreateScene_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateSceneRequest",
    "$defs": {
        "CreateSceneRequest": {
            "type": "object",
            "description": "Request to create a new scene",
            "required": [
                "scene"
            ],
            "properties": {
                "scene": {
                    "$ref": "#/$defs/Scene",
                    "description": "The scene document to create"
                }
            }
        },
        "Scene": {
            "type": "object",
            "description": "A complete scene document with hierarchical node structure",
            "required": [
                "sceneId",
                "gameId",
                "sceneType",
                "name",
                "version",
                "root"
            ],
            "properties": {
                "schema": {
                    "type": "string",
                    "description": "Schema identifier for validation",
                    "default": "bannou://schemas/scene/v1"
                },
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique scene identifier"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game service identifier for partitioning. Treated as opaque string.\nDefault is the nil UUID for unpartitioned scenes.\n",
                    "default": "00000000-0000-0000-0000-000000000000"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene classification for querying and validation"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable scene name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional scene description"
                },
                "version": {
                    "type": "string",
                    "pattern": "^\\d+\\.\\d+\\.\\d+$",
                    "description": "Semantic version (MAJOR.MINOR.PATCH)"
                },
                "root": {
                    "$ref": "#/$defs/SceneNode",
                    "description": "Root node of the scene hierarchy"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for filtering scenes"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Scene-level metadata. Not interpreted by Scene service.\nExamples: author, thumbnail, editor preferences, generator config.\n"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was last modified"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        },
        "SceneNode": {
            "type": "object",
            "description": "A node in the scene hierarchy. Nodes can contain children to form\na tree structure. Each node has a local transform relative to its parent.\n",
            "required": [
                "nodeId",
                "refId",
                "name",
                "nodeType",
                "localTransform"
            ],
            "properties": {
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Globally unique node identifier"
                },
                "refId": {
                    "type": "string",
                    "pattern": "^[a-z][a-z0-9_]*$",
                    "description": "Scene-local reference identifier. Must be unique within the scene.\nUsed for scripting and cross-referencing. Examples: main_door, npc_spawn_1\n"
                },
                "parentNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Parent node ID. Null for the root node only."
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable display name for the node"
                },
                "nodeType": {
                    "$ref": "#/$defs/NodeType",
                    "description": "The structural type of this node"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Transform relative to parent node"
                },
                "asset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Optional asset binding (mesh, sound, particle effect)"
                },
                "children": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SceneNode"
                    },
                    "description": "Child nodes in the hierarchy"
                },
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether this node is active in the scene definition"
                },
                "sortOrder": {
                    "type": "integer",
                    "default": 0,
                    "description": "Ordering among siblings for deterministic iteration"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive)"
                },
                "annotations": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Consumer-specific data stored without interpretation.\nUse namespaced keys (e.g., render.castShadows, arcadia.interactionType).\n"
                },
                "attachmentPoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AttachmentPoint"
                    },
                    "description": "Predefined locations for attaching child objects.\ nUsed by Scene Composer for furniture decoration, wall accessories, etc.\n"
                },
                "affordances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/Affordance"
                    },
                    "description": "Interaction capabilities of this node.\nUsed by AI navigation and character controllers.\n"
                },
                "assetSlot": {
                    "$ref": "#/$defs/AssetSlot",
                    "nullable": true,
                    "description": "Procedural asset swapping configuration.\nDefines which assets can substitute for this node's asset.\n"
                },
                "markerType": {
                    "$ref": "#/$defs/MarkerType",
                    "nullable": true,
                    "description": "Type of marker for marker nodes.\nOnly relevant when nodeType is 'marker'.\n"
                },
                "volumeShape": {
                    "$ref": "#/$defs/VolumeShape",
                    "nullable": true,
                    "description": "Shape of volume for volume nodes.\nOnly relevant when nodeType is 'volume'.\n"
                },
                "volumeSize": {
                    "$ref": "#/$defs/Vector3",
                    "nullable": true,
                    "description": "Size/extents of the volume (interpretation depends on volumeShape).\nFor box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.\n"
                },
                "referenceSceneId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Scene ID to embed for reference nodes.\nOnly relevant when nodeType is 'reference'.\n"
                }
            }
        },
        "NodeType": {
            "type": "string",
            "description": "Structural node type. Indicates what kind of data the node contains,\nnot how it will be used at runtime. Consumers interpret nodes according\nto their own needs via tags and annotations.\n",
            "enum": [
                "group",
                "mesh",
                "marker",
                "volume",
                "emitter",
                "reference",
                "custom"
            ]
        },
        "Transform": {
            "type": "object",
            "description": "Position, rotation, and scale in 3D space",
            "required": [
                "position",
                "rotation",
                "scale"
            ],
            "properties": {
                "position": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Position relative to parent"
                },
                "rotation": {
                    "$ref": "#/$defs/Quaternion",
                    "description": "Rotation relative to parent"
                },
                "scale": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Scale relative to parent"
                }
            }
        },
        "Vector3": {
            "type": "object",
            "description": "A point or direction in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate"
                }
            }
        },
        "Quaternion": {
            "type": "object",
            "description": "Rotation represented as a quaternion",
            "required": [
                "x",
                "y",
                "z",
                "w"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X component"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y component"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z component"
                },
                "w": {
                    "type": "number",
                    "format": "double",
                    "description": "W component (scalar)"
                }
            }
        },
        "AssetReference": {
            "type": "object",
            "description": "Reference to an asset in lib-asset",
            "required": [
                "assetId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Optional bundle containing the asset"
                },
                "assetId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Asset identifier in lib-asset"
                },
                "variantId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Variant identifier (consumer interprets meaning)"
                }
            }
        },
        "AttachmentPoint": {
            "type": "object",
            "description": "A predefined location where child objects can be attached.\nUsed for decorating furniture, walls, and other objects with accessories.\nExample: A wall may have attachment points for paintings, shelves, or light fixtures.\n",
            "required": [
                "name",
                "localTransform"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Unique name for this attachment point within the node.\nExamples: wall_hook_left, shelf_1, lamp_socket\n"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Position and orientation relative to the owning node"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags of assets that can attach here.\nExamples: wall_decoration, picture_frame, plant\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset to display if no specific attachment is specified"
                },
                "attachedNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "ID of the node currently attached at this point (runtime state)"
                }
            }
        },
        "Affordance": {
            "type": "object",
            "description": "Describes a capability or interaction mode for a node.\nUsed by AI systems to understand what actions are possible and by\ncharacter controllers for contextual animations.\n",
            "required": [
                "type"
            ],
            "properties": {
                "type": {
                    "$ref": "#/$defs/AffordanceType",
                    "description": "The type of affordance"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Type-specific parameters. Examples:\n- sittable: { height: 0.5, facing: [0,0,1] }\n- door: { openAngle: 90, locked: false }\n- container: { capacity: 10, itemTypes: [\"weapon\", \"consumable\"] }\n"
                }
            }
        },
        "AffordanceType": {
            "type": "string",
            "description": "Types of affordances describing what an object can do or how it can be interacted with.\nUsed by AI navigation, character controllers, and procedural content systems.\n",
            "enum": [
                "walkable",
                "climbable",
                "sittable",
                "interactive",
                "collectible",
                "destructible",
                "container",
                "door",
                "teleport"
            ]
        },
        "AssetSlot": {
            "type": "object",
            "description": "Defines acceptable asset types for procedural swapping at this node.\nUsed by procedural generation systems to substitute assets while\nmaintaining scene coherence.\n",
            "required": [
                "slotType"
            ],
            "properties": {
                "slotType": {
                    "type": "string",
                    "description": "Category of acceptable assets.\nExamples: chair, table, wall_art, floor_lamp\n"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags that acceptable assets must have.\nUsed for filtering when selecting random variations.\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset if no specific asset is bound"
                },
                "variations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetReference"
                    },
                    "description": "Pre-approved asset variations for random selection.\nProcedural systems pick from this list rather than searching all assets.\n"
                }
            }
        },
        "MarkerType": {
            "type": "string",
            "description": "Types of marker nodes for spawn points, waypoints, and other positional markers.",
            "enum": [
                "generic",
                "spawn_point",
                "npc_spawn",
                "waypoint",
                "camera_point",
                "light_point",
                "audio_point",
                "trigger_point"
            ]
        },
        "VolumeShape": {
            "type": "string",
            "description": "Shape of a volume node for spatial bounds",
            "enum": [
                "box",
                "sphere",
                "capsule",
                "cylinder"
            ]
        }
    }
}
""";

    private static readonly string _CreateScene_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/SceneResponse",
    "$defs": {
        "SceneResponse": {
            "type": "object",
            "description": "Standard response containing a scene",
            "required": [
                "scene"
            ],
            "properties": {
                "scene": {
                    "$ref": "#/$defs/Scene",
                    "description": "The scene document"
                }
            }
        },
        "Scene": {
            "type": "object",
            "description": "A complete scene document with hierarchical node structure",
            "required": [
                "sceneId",
                "gameId",
                "sceneType",
                "name",
                "version",
                "root"
            ],
            "properties": {
                "schema": {
                    "type": "string",
                    "description": "Schema identifier for validation",
                    "default": "bannou://schemas/scene/v1"
                },
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique scene identifier"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game service identifier for partitioning. Treated as opaque string.\nDefault is the nil UUID for unpartitioned scenes.\n",
                    "default": "00000000-0000-0000-0000-000000000000"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene classification for querying and validation"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable scene name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional scene description"
                },
                "version": {
                    "type": "string",
                    "pattern": "^\\d+\\.\\d+\\.\\d+$",
                    "description": "Semantic version (MAJOR.MINOR.PATCH)"
                },
                "root": {
                    "$ref": "#/$defs/SceneNode",
                    "description": "Root node of the scene hierarchy"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for filtering scenes"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Scene-level metadata. Not interpreted by Scene service.\nExamples: author, thumbnail, editor preferences, generator config.\n"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was last modified"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        },
        "SceneNode": {
            "type": "object",
            "description": "A node in the scene hierarchy. Nodes can contain children to form\na tree structure. Each node has a local transform relative to its parent.\n",
            "required": [
                "nodeId",
                "refId",
                "name",
                "nodeType",
                "localTransform"
            ],
            "properties": {
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Globally unique node identifier"
                },
                "refId": {
                    "type": "string",
                    "pattern": "^[a-z][a-z0-9_]*$",
                    "description": "Scene-local reference identifier. Must be unique within the scene.\nUsed for scripting and cross-referencing. Examples: main_door, npc_spawn_1\n"
                },
                "parentNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Parent node ID. Null for the root node only."
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable display name for the node"
                },
                "nodeType": {
                    "$ref": "#/$defs/NodeType",
                    "description": "The structural type of this node"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Transform relative to parent node"
                },
                "asset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Optional asset binding (mesh, sound, particle effect)"
                },
                "children": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SceneNode"
                    },
                    "description": "Child nodes in the hierarchy"
                },
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether this node is active in the scene definition"
                },
                "sortOrder": {
                    "type": "integer",
                    "default": 0,
                    "description": "Ordering among siblings for deterministic iteration"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive)"
                },
                "annotations": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Consumer-specific data stored without interpretation.\nUse namespaced keys (e.g., render.castShadows, arcadia.interactionType).\n"
                },
                "attachmentPoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AttachmentPoint"
                    },
                    "description": "Predefined locations for attaching child objects.\ nUsed by Scene Composer for furniture decoration, wall accessories, etc.\n"
                },
                "affordances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/Affordance"
                    },
                    "description": "Interaction capabilities of this node.\nUsed by AI navigation and character controllers.\n"
                },
                "assetSlot": {
                    "$ref": "#/$defs/AssetSlot",
                    "nullable": true,
                    "description": "Procedural asset swapping configuration.\nDefines which assets can substitute for this node's asset.\n"
                },
                "markerType": {
                    "$ref": "#/$defs/MarkerType",
                    "nullable": true,
                    "description": "Type of marker for marker nodes.\nOnly relevant when nodeType is 'marker'.\n"
                },
                "volumeShape": {
                    "$ref": "#/$defs/VolumeShape",
                    "nullable": true,
                    "description": "Shape of volume for volume nodes.\nOnly relevant when nodeType is 'volume'.\n"
                },
                "volumeSize": {
                    "$ref": "#/$defs/Vector3",
                    "nullable": true,
                    "description": "Size/extents of the volume (interpretation depends on volumeShape).\nFor box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.\n"
                },
                "referenceSceneId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Scene ID to embed for reference nodes.\nOnly relevant when nodeType is 'reference'.\n"
                }
            }
        },
        "NodeType": {
            "type": "string",
            "description": "Structural node type. Indicates what kind of data the node contains,\nnot how it will be used at runtime. Consumers interpret nodes according\nto their own needs via tags and annotations.\n",
            "enum": [
                "group",
                "mesh",
                "marker",
                "volume",
                "emitter",
                "reference",
                "custom"
            ]
        },
        "Transform": {
            "type": "object",
            "description": "Position, rotation, and scale in 3D space",
            "required": [
                "position",
                "rotation",
                "scale"
            ],
            "properties": {
                "position": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Position relative to parent"
                },
                "rotation": {
                    "$ref": "#/$defs/Quaternion",
                    "description": "Rotation relative to parent"
                },
                "scale": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Scale relative to parent"
                }
            }
        },
        "Vector3": {
            "type": "object",
            "description": "A point or direction in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate"
                }
            }
        },
        "Quaternion": {
            "type": "object",
            "description": "Rotation represented as a quaternion",
            "required": [
                "x",
                "y",
                "z",
                "w"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X component"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y component"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z component"
                },
                "w": {
                    "type": "number",
                    "format": "double",
                    "description": "W component (scalar)"
                }
            }
        },
        "AssetReference": {
            "type": "object",
            "description": "Reference to an asset in lib-asset",
            "required": [
                "assetId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Optional bundle containing the asset"
                },
                "assetId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Asset identifier in lib-asset"
                },
                "variantId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Variant identifier (consumer interprets meaning)"
                }
            }
        },
        "AttachmentPoint": {
            "type": "object",
            "description": "A predefined location where child objects can be attached.\nUsed for decorating furniture, walls, and other objects with accessories.\nExample: A wall may have attachment points for paintings, shelves, or light fixtures.\n",
            "required": [
                "name",
                "localTransform"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Unique name for this attachment point within the node.\nExamples: wall_hook_left, shelf_1, lamp_socket\n"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Position and orientation relative to the owning node"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags of assets that can attach here.\nExamples: wall_decoration, picture_frame, plant\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset to display if no specific attachment is specified"
                },
                "attachedNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "ID of the node currently attached at this point (runtime state)"
                }
            }
        },
        "Affordance": {
            "type": "object",
            "description": "Describes a capability or interaction mode for a node.\nUsed by AI systems to understand what actions are possible and by\ncharacter controllers for contextual animations.\n",
            "required": [
                "type"
            ],
            "properties": {
                "type": {
                    "$ref": "#/$defs/AffordanceType",
                    "description": "The type of affordance"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Type-specific parameters. Examples:\n- sittable: { height: 0.5, facing: [0,0,1] }\n- door: { openAngle: 90, locked: false }\n- container: { capacity: 10, itemTypes: [\"weapon\", \"consumable\"] }\n"
                }
            }
        },
        "AffordanceType": {
            "type": "string",
            "description": "Types of affordances describing what an object can do or how it can be interacted with.\nUsed by AI navigation, character controllers, and procedural content systems.\n",
            "enum": [
                "walkable",
                "climbable",
                "sittable",
                "interactive",
                "collectible",
                "destructible",
                "container",
                "door",
                "teleport"
            ]
        },
        "AssetSlot": {
            "type": "object",
            "description": "Defines acceptable asset types for procedural swapping at this node.\nUsed by procedural generation systems to substitute assets while\nmaintaining scene coherence.\n",
            "required": [
                "slotType"
            ],
            "properties": {
                "slotType": {
                    "type": "string",
                    "description": "Category of acceptable assets.\nExamples: chair, table, wall_art, floor_lamp\n"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags that acceptable assets must have.\nUsed for filtering when selecting random variations.\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset if no specific asset is bound"
                },
                "variations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetReference"
                    },
                    "description": "Pre-approved asset variations for random selection.\nProcedural systems pick from this list rather than searching all assets.\n"
                }
            }
        },
        "MarkerType": {
            "type": "string",
            "description": "Types of marker nodes for spawn points, waypoints, and other positional markers.",
            "enum": [
                "generic",
                "spawn_point",
                "npc_spawn",
                "waypoint",
                "camera_point",
                "light_point",
                "audio_point",
                "trigger_point"
            ]
        },
        "VolumeShape": {
            "type": "string",
            "description": "Shape of a volume node for spatial bounds",
            "enum": [
                "box",
                "sphere",
                "capsule",
                "cylinder"
            ]
        }
    }
}
""";

    private static readonly string _CreateScene_Info = """
{
    "summary": "Create a new scene document",
    "description": "Creates a new scene document and stores it in lib-asset.\nPublishes scene.created event on success.\nReturns Conflict if a scene with the same sceneId already exists.\n",
    "tags": [
        "Scene"
    ],
    "deprecated": false,
    "operationId": "createScene"
}
""";

    /// <summary>Returns endpoint information for CreateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateScene_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/create",
            _CreateScene_Info));

    /// <summary>Returns request schema for CreateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateScene_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/create",
            "request-schema",
            _CreateScene_RequestSchema));

    /// <summary>Returns response schema for CreateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateScene_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/create",
            "response-schema",
            _CreateScene_ResponseSchema));

    /// <summary>Returns full schema for CreateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateScene_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/create",
            _CreateScene_Info,
            _CreateScene_RequestSchema,
            _CreateScene_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetScene

    private static readonly string _GetScene_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetSceneRequest",
    "$defs": {
        "GetSceneRequest": {
            "type": "object",
            "description": "Request to retrieve a scene",
            "required": [
                "sceneId"
            ],
            "properties": {
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the scene to retrieve"
                },
                "version": {
                    "type": "string",
                    "nullable": true,
                    "description": "Specific version to retrieve (null = latest)"
                },
                "resolveReferences": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether to resolve and embed referenced scenes"
                },
                "maxReferenceDepth": {
                    "type": "integer",
                    "default": 3,
                    "minimum": 1,
                    "maximum": 10,
                    "description": "Maximum depth for reference resolution (prevents infinite recursion)"
                }
            }
        }
    }
}
""";

    private static readonly string _GetScene_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetSceneResponse",
    "$defs": {
        "GetSceneResponse": {
            "type": "object",
            "description": "Response containing a scene and resolution metadata",
            "required": [
                "scene"
            ],
            "properties": {
                "scene": {
                    "$ref": "#/$defs/Scene",
                    "description": "The retrieved scene"
                },
                "resolvedReferences": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ResolvedReference"
                    },
                    "nullable": true,
                    "description": "List of resolved references (if resolveReferences was true)"
                },
                "unresolvedReferences": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/UnresolvedReference"
                    },
                    "nullable": true,
                    "description": "References that could not be resolved (circular, missing, depth exceeded)"
                },
                "resolutionErrors": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Error messages for reference resolution issues"
                }
            }
        },
        "Scene": {
            "type": "object",
            "description": "A complete scene document with hierarchical node structure",
            "required": [
                "sceneId",
                "gameId",
                "sceneType",
                "name",
                "version",
                "root"
            ],
            "properties": {
                "schema": {
                    "type": "string",
                    "description": "Schema identifier for validation",
                    "default": "bannou://schemas/scene/v1"
                },
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique scene identifier"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game service identifier for partitioning. Treated as opaque string.\nDefault is the nil UUID for unpartitioned scenes.\n",
                    "default": "00000000-0000-0000-0000-000000000000"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene classification for querying and validation"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable scene name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional scene description"
                },
                "version": {
                    "type": "string",
                    "pattern": "^\\d+\\.\\d+\\.\\d+$",
                    "description": "Semantic version (MAJOR.MINOR.PATCH)"
                },
                "root": {
                    "$ref": "#/$defs/SceneNode",
                    "description": "Root node of the scene hierarchy"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for filtering scenes"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Scene-level metadata. Not interpreted by Scene service.\nExamples: author, thumbnail, editor preferences, generator config.\n"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was last modified"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\ nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        },
        "SceneNode": {
            "type": "object",
            "description": "A node in the scene hierarchy. Nodes can contain children to form\na tree structure. Each node has a local transform relative to its parent.\n",
            "required": [
                "nodeId",
                "refId",
                "name",
                "nodeType",
                "localTransform"
            ],
            "properties": {
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Globally unique node identifier"
                },
                "refId": {
                    "type": "string",
                    "pattern": "^[a-z][a-z0-9_]*$",
                    "description": "Scene-local reference identifier. Must be unique within the scene.\nUsed for scripting and cross-referencing. Examples: main_door, npc_spawn_1\n"
                },
                "parentNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Parent node ID. Null for the root node only."
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable display name for the node"
                },
                "nodeType": {
                    "$ref": "#/$defs/NodeType",
                    "description": "The structural type of this node"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Transform relative to parent node"
                },
                "asset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Optional asset binding (mesh, sound, particle effect)"
                },
                "children": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SceneNode"
                    },
                    "description": "Child nodes in the hierarchy"
                },
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether this node is active in the scene definition"
                },
                "sortOrder": {
                    "type": "integer",
                    "default": 0,
                    "description": "Ordering among siblings for deterministic iteration"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive)"
                },
                "annotations": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Consumer-specific data stored without interpretation.\nUse namespaced keys (e.g., render.castShadows, arcadia.interactionType).\n"
                },
                "attachmentPoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AttachmentPoint"
                    },
                    "description": "Predefined locations for attaching child objects.\ nUsed by Scene Composer for furniture decoration, wall accessories, etc.\n"
                },
                "affordances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/Affordance"
                    },
                    "description": "Interaction capabilities of this node.\nUsed by AI navigation and character controllers.\n"
                },
                "assetSlot": {
                    "$ref": "#/$defs/AssetSlot",
                    "nullable": true,
                    "description": "Procedural asset swapping configuration.\nDefines which assets can substitute for this node's asset.\n"
                },
                "markerType": {
                    "$ref": "#/$defs/MarkerType",
                    "nullable": true,
                    "description": "Type of marker for marker nodes.\nOnly relevant when nodeType is 'marker'.\n"
                },
                "volumeShape": {
                    "$ref": "#/$defs/VolumeShape",
                    "nullable": true,
                    "description": "Shape of volume for volume nodes.\nOnly relevant when nodeType is 'volume'.\n"
                },
                "volumeSize": {
                    "$ref": "#/$defs/Vector3",
                    "nullable": true,
                    "description": "Size/extents of the volume (interpretation depends on volumeShape).\nFor box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.\n"
                },
                "referenceSceneId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Scene ID to embed for reference nodes.\nOnly relevant when nodeType is 'reference'.\n"
                }
            }
        },
        "NodeType": {
            "type": "string",
            "description": "Structural node type. Indicates what kind of data the node contains,\nnot how it will be used at runtime. Consumers interpret nodes according\nto their own needs via tags and annotations.\n",
            "enum": [
                "group",
                "mesh",
                "marker",
                "volume",
                "emitter",
                "reference",
                "custom"
            ]
        },
        "Transform": {
            "type": "object",
            "description": "Position, rotation, and scale in 3D space",
            "required": [
                "position",
                "rotation",
                "scale"
            ],
            "properties": {
                "position": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Position relative to parent"
                },
                "rotation": {
                    "$ref": "#/$defs/Quaternion",
                    "description": "Rotation relative to parent"
                },
                "scale": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Scale relative to parent"
                }
            }
        },
        "Vector3": {
            "type": "object",
            "description": "A point or direction in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate"
                }
            }
        },
        "Quaternion": {
            "type": "object",
            "description": "Rotation represented as a quaternion",
            "required": [
                "x",
                "y",
                "z",
                "w"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X component"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y component"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z component"
                },
                "w": {
                    "type": "number",
                    "format": "double",
                    "description": "W component (scalar)"
                }
            }
        },
        "AssetReference": {
            "type": "object",
            "description": "Reference to an asset in lib-asset",
            "required": [
                "assetId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Optional bundle containing the asset"
                },
                "assetId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Asset identifier in lib-asset"
                },
                "variantId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Variant identifier (consumer interprets meaning)"
                }
            }
        },
        "AttachmentPoint": {
            "type": "object",
            "description": "A predefined location where child objects can be attached.\nUsed for decorating furniture, walls, and other objects with accessories.\nExample: A wall may have attachment points for paintings, shelves, or light fixtures.\n",
            "required": [
                "name",
                "localTransform"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Unique name for this attachment point within the node.\nExamples: wall_hook_left, shelf_1, lamp_socket\n"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Position and orientation relative to the owning node"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags of assets that can attach here.\nExamples: wall_decoration, picture_frame, plant\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset to display if no specific attachment is specified"
                },
                "attachedNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "ID of the node currently attached at this point (runtime state)"
                }
            }
        },
        "Affordance": {
            "type": "object",
            "description": "Describes a capability or interaction mode for a node.\nUsed by AI systems to understand what actions are possible and by\ncharacter controllers for contextual animations.\n",
            "required": [
                "type"
            ],
            "properties": {
                "type": {
                    "$ref": "#/$defs/AffordanceType",
                    "description": "The type of affordance"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Type-specific parameters. Examples:\n- sittable: { height: 0.5, facing: [0,0,1] }\n- door: { openAngle: 90, locked: false }\n- container: { capacity: 10, itemTypes: [\"weapon\", \"consumable\"] }\n"
                }
            }
        },
        "AffordanceType": {
            "type": "string",
            "description": "Types of affordances describing what an object can do or how it can be interacted with.\nUsed by AI navigation, character controllers, and procedural content systems.\n",
            "enum": [
                "walkable",
                "climbable",
                "sittable",
                "interactive",
                "collectible",
                "destructible",
                "container",
                "door",
                "teleport"
            ]
        },
        "AssetSlot": {
            "type": "object",
            "description": "Defines acceptable asset types for procedural swapping at this node.\nUsed by procedural generation systems to substitute assets while\nmaintaining scene coherence.\n",
            "required": [
                "slotType"
            ],
            "properties": {
                "slotType": {
                    "type": "string",
                    "description": "Category of acceptable assets.\nExamples: chair, table, wall_art, floor_lamp\n"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags that acceptable assets must have.\nUsed for filtering when selecting random variations.\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset if no specific asset is bound"
                },
                "variations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetReference"
                    },
                    "description": "Pre-approved asset variations for random selection.\nProcedural systems pick from this list rather than searching all assets.\n"
                }
            }
        },
        "MarkerType": {
            "type": "string",
            "description": "Types of marker nodes for spawn points, waypoints, and other positional markers.",
            "enum": [
                "generic",
                "spawn_point",
                "npc_spawn",
                "waypoint",
                "camera_point",
                "light_point",
                "audio_point",
                "trigger_point"
            ]
        },
        "VolumeShape": {
            "type": "string",
            "description": "Shape of a volume node for spatial bounds",
            "enum": [
                "box",
                "sphere",
                "capsule",
                "cylinder"
            ]
        },
        "ResolvedReference": {
            "type": "object",
            "description": "A successfully resolved scene reference",
            "required": [
                "nodeId",
                "refId",
                "referencedSceneId",
                "scene"
            ],
            "properties": {
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Node ID containing the reference"
                },
                "refId": {
                    "type": "string",
                    "description": "refId of the referencing node"
                },
                "referencedSceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the referenced scene"
                },
                "referencedVersion": {
                    "type": "string",
                    "nullable": true,
                    "description": "Version that was resolved"
                },
                "scene": {
                    "$ref": "#/$defs/Scene",
                    "description": "The resolved scene content"
                },
                "depth": {
                    "type": "integer",
                    "description": "Depth level of this reference"
                }
            }
        },
        "UnresolvedReference": {
            "type": "object",
            "description": "A scene reference that could not be resolved",
            "required": [
                "nodeId",
                "refId",
                "referencedSceneId",
                "reason"
            ],
            "properties": {
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Node ID containing the reference"
                },
                "refId": {
                    "type": "string",
                    "description": "refId of the referencing node"
                },
                "referencedSceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the scene that could not be resolved"
                },
                "reason": {
                    "$ref": "#/$defs/UnresolvedReferenceReason",
                    "description": "Why the reference could not be resolved"
                },
                "cyclePath": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "uuid"
                    },
                    "nullable": true,
                    "description": "For circular references, the cycle path (sceneId chain)"
                }
            }
        },
        "UnresolvedReferenceReason": {
            "type": "string",
            "description": "Reason why a scene reference could not be resolved",
            "enum": [
                "not_found",
                "circular_reference",
                "depth_exceeded",
                "access_denied"
            ]
        }
    }
}
""";

    private static readonly string _GetScene_Info = """
{
    "summary": "Retrieve a scene by ID",
    "description": "Retrieves a scene document. Optionally resolves nested scene references\nup to a configurable depth.\n",
    "tags": [
        "Scene"
    ],
    "deprecated": false,
    "operationId": "getScene"
}
""";

    /// <summary>Returns endpoint information for GetScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetScene_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/get",
            _GetScene_Info));

    /// <summary>Returns request schema for GetScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetScene_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/get",
            "request-schema",
            _GetScene_RequestSchema));

    /// <summary>Returns response schema for GetScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetScene_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/get",
            "response-schema",
            _GetScene_ResponseSchema));

    /// <summary>Returns full schema for GetScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetScene_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/get",
            _GetScene_Info,
            _GetScene_RequestSchema,
            _GetScene_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListScenes

    private static readonly string _ListScenes_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListScenesRequest",
    "$defs": {
        "ListScenesRequest": {
            "type": "object",
            "description": "Request to list scenes with optional filters",
            "properties": {
                "gameId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by game ID"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "nullable": true,
                    "description": "Filter by single scene type"
                },
                "sceneTypes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SceneType"
                    },
                    "nullable": true,
                    "description": "Filter by multiple scene types (OR)"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Filter by tags (scenes must have ALL specified tags)"
                },
                "nameContains": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by name containing this substring (case-insensitive)"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "minimum": 0,
                    "description": "Pagination offset"
                },
                "limit": {
                    "type": "integer",
                    "default": 50,
                    "minimum": 1,
                    "maximum": 200,
                    "description": "Maximum results to return"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        }
    }
}
""";

    private static readonly string _ListScenes_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListScenesResponse",
    "$defs": {
        "ListScenesResponse": {
            "type": "object",
            "description": "Response containing scene list and pagination info",
            "required": [
                "scenes",
                "total"
            ],
            "properties": {
                "scenes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SceneSummary"
                    },
                    "description": "List of scene summaries (not full documents)"
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of matching scenes"
                },
                "offset": {
                    "type": "integer",
                    "description": "Current offset"
                },
                "limit": {
                    "type": "integer",
                    "description": "Applied limit"
                }
            }
        },
        "SceneSummary": {
            "type": "object",
            "description": "Summary of a scene for list results (excludes full node tree)",
            "required": [
                "sceneId",
                "gameId",
                "sceneType",
                "name",
                "version"
            ],
            "properties": {
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique scene identifier"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game service identifier"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene classification"
                },
                "name": {
                    "type": "string",
                    "description": "Scene name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Scene description"
                },
                "version": {
                    "type": "string",
                    "description": "Current version"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Scene tags"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Total number of nodes in scene"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Creation timestamp"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Last update timestamp"
                },
                "isCheckedOut": {
                    "type": "boolean",
                    "description": "Whether scene is currently checked out"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        }
    }
}
""";

    private static readonly string _ListScenes_Info = """
{
    "summary": "List scenes with filtering",
    "description": "Lists scenes matching the provided filters. Supports pagination.\nResults are ordered by updatedAt descending (most recent first).\n",
    "tags": [
        "Scene"
    ],
    "deprecated": false,
    "operationId": "listScenes"
}
""";

    /// <summary>Returns endpoint information for ListScenes</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListScenes_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/list",
            _ListScenes_Info));

    /// <summary>Returns request schema for ListScenes</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListScenes_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/list",
            "request-schema",
            _ListScenes_RequestSchema));

    /// <summary>Returns response schema for ListScenes</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListScenes_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/list",
            "response-schema",
            _ListScenes_ResponseSchema));

    /// <summary>Returns full schema for ListScenes</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListScenes_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/list",
            _ListScenes_Info,
            _ListScenes_RequestSchema,
            _ListScenes_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateScene

    private static readonly string _UpdateScene_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateSceneRequest",
    "$defs": {
        "UpdateSceneRequest": {
            "type": "object",
            "description": "Request to update an existing scene",
            "required": [
                "scene"
            ],
            "properties": {
                "scene": {
                    "$ref": "#/$defs/Scene",
                    "description": "The updated scene document (sceneId must match existing)"
                },
                "checkoutToken": {
                    "type": "string",
                    "nullable": true,
                    "description": "Checkout token if updating via checkout workflow"
                }
            }
        },
        "Scene": {
            "type": "object",
            "description": "A complete scene document with hierarchical node structure",
            "required": [
                "sceneId",
                "gameId",
                "sceneType",
                "name",
                "version",
                "root"
            ],
            "properties": {
                "schema": {
                    "type": "string",
                    "description": "Schema identifier for validation",
                    "default": "bannou://schemas/scene/v1"
                },
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique scene identifier"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game service identifier for partitioning. Treated as opaque string.\nDefault is the nil UUID for unpartitioned scenes.\n",
                    "default": "00000000-0000-0000-0000-000000000000"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene classification for querying and validation"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable scene name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional scene description"
                },
                "version": {
                    "type": "string",
                    "pattern": "^\\d+\\.\\d+\\.\\d+$",
                    "description": "Semantic version (MAJOR.MINOR.PATCH)"
                },
                "root": {
                    "$ref": "#/$defs/SceneNode",
                    "description": "Root node of the scene hierarchy"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for filtering scenes"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Scene-level metadata. Not interpreted by Scene service.\nExamples: author, thumbnail, editor preferences, generator config.\n"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was last modified"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        },
        "SceneNode": {
            "type": "object",
            "description": "A node in the scene hierarchy. Nodes can contain children to form\na tree structure. Each node has a local transform relative to its parent.\n",
            "required": [
                "nodeId",
                "refId",
                "name",
                "nodeType",
                "localTransform"
            ],
            "properties": {
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Globally unique node identifier"
                },
                "refId": {
                    "type": "string",
                    "pattern": "^[a-z][a-z0-9_]*$",
                    "description": "Scene-local reference identifier. Must be unique within the scene.\nUsed for scripting and cross-referencing. Examples: main_door, npc_spawn_1\n"
                },
                "parentNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Parent node ID. Null for the root node only."
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable display name for the node"
                },
                "nodeType": {
                    "$ref": "#/$defs/NodeType",
                    "description": "The structural type of this node"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Transform relative to parent node"
                },
                "asset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Optional asset binding (mesh, sound, particle effect)"
                },
                "children": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SceneNode"
                    },
                    "description": "Child nodes in the hierarchy"
                },
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether this node is active in the scene definition"
                },
                "sortOrder": {
                    "type": "integer",
                    "default": 0,
                    "description": "Ordering among siblings for deterministic iteration"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive)"
                },
                "annotations": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Consumer-specific data stored without interpretation.\nUse namespaced keys (e.g., render.castShadows, arcadia.interactionType).\n"
                },
                "attachmentPoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AttachmentPoint"
                    },
                    "description": "Predefined locations for attaching child objects.\ nUsed by Scene Composer for furniture decoration, wall accessories, etc.\n"
                },
                "affordances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/Affordance"
                    },
                    "description": "Interaction capabilities of this node.\nUsed by AI navigation and character controllers.\n"
                },
                "assetSlot": {
                    "$ref": "#/$defs/AssetSlot",
                    "nullable": true,
                    "description": "Procedural asset swapping configuration.\nDefines which assets can substitute for this node's asset.\n"
                },
                "markerType": {
                    "$ref": "#/$defs/MarkerType",
                    "nullable": true,
                    "description": "Type of marker for marker nodes.\nOnly relevant when nodeType is 'marker'.\n"
                },
                "volumeShape": {
                    "$ref": "#/$defs/VolumeShape",
                    "nullable": true,
                    "description": "Shape of volume for volume nodes.\nOnly relevant when nodeType is 'volume'.\n"
                },
                "volumeSize": {
                    "$ref": "#/$defs/Vector3",
                    "nullable": true,
                    "description": "Size/extents of the volume (interpretation depends on volumeShape).\nFor box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.\n"
                },
                "referenceSceneId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Scene ID to embed for reference nodes.\nOnly relevant when nodeType is 'reference'.\n"
                }
            }
        },
        "NodeType": {
            "type": "string",
            "description": "Structural node type. Indicates what kind of data the node contains,\nnot how it will be used at runtime. Consumers interpret nodes according\nto their own needs via tags and annotations.\n",
            "enum": [
                "group",
                "mesh",
                "marker",
                "volume",
                "emitter",
                "reference",
                "custom"
            ]
        },
        "Transform": {
            "type": "object",
            "description": "Position, rotation, and scale in 3D space",
            "required": [
                "position",
                "rotation",
                "scale"
            ],
            "properties": {
                "position": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Position relative to parent"
                },
                "rotation": {
                    "$ref": "#/$defs/Quaternion",
                    "description": "Rotation relative to parent"
                },
                "scale": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Scale relative to parent"
                }
            }
        },
        "Vector3": {
            "type": "object",
            "description": "A point or direction in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate"
                }
            }
        },
        "Quaternion": {
            "type": "object",
            "description": "Rotation represented as a quaternion",
            "required": [
                "x",
                "y",
                "z",
                "w"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X component"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y component"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z component"
                },
                "w": {
                    "type": "number",
                    "format": "double",
                    "description": "W component (scalar)"
                }
            }
        },
        "AssetReference": {
            "type": "object",
            "description": "Reference to an asset in lib-asset",
            "required": [
                "assetId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Optional bundle containing the asset"
                },
                "assetId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Asset identifier in lib-asset"
                },
                "variantId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Variant identifier (consumer interprets meaning)"
                }
            }
        },
        "AttachmentPoint": {
            "type": "object",
            "description": "A predefined location where child objects can be attached.\nUsed for decorating furniture, walls, and other objects with accessories.\nExample: A wall may have attachment points for paintings, shelves, or light fixtures.\n",
            "required": [
                "name",
                "localTransform"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Unique name for this attachment point within the node.\nExamples: wall_hook_left, shelf_1, lamp_socket\n"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Position and orientation relative to the owning node"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags of assets that can attach here.\nExamples: wall_decoration, picture_frame, plant\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset to display if no specific attachment is specified"
                },
                "attachedNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "ID of the node currently attached at this point (runtime state)"
                }
            }
        },
        "Affordance": {
            "type": "object",
            "description": "Describes a capability or interaction mode for a node.\nUsed by AI systems to understand what actions are possible and by\ncharacter controllers for contextual animations.\n",
            "required": [
                "type"
            ],
            "properties": {
                "type": {
                    "$ref": "#/$defs/AffordanceType",
                    "description": "The type of affordance"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Type-specific parameters. Examples:\n- sittable: { height: 0.5, facing: [0,0,1] }\n- door: { openAngle: 90, locked: false }\n- container: { capacity: 10, itemTypes: [\"weapon\", \"consumable\"] }\n"
                }
            }
        },
        "AffordanceType": {
            "type": "string",
            "description": "Types of affordances describing what an object can do or how it can be interacted with.\nUsed by AI navigation, character controllers, and procedural content systems.\n",
            "enum": [
                "walkable",
                "climbable",
                "sittable",
                "interactive",
                "collectible",
                "destructible",
                "container",
                "door",
                "teleport"
            ]
        },
        "AssetSlot": {
            "type": "object",
            "description": "Defines acceptable asset types for procedural swapping at this node.\nUsed by procedural generation systems to substitute assets while\nmaintaining scene coherence.\n",
            "required": [
                "slotType"
            ],
            "properties": {
                "slotType": {
                    "type": "string",
                    "description": "Category of acceptable assets.\nExamples: chair, table, wall_art, floor_lamp\n"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags that acceptable assets must have.\nUsed for filtering when selecting random variations.\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset if no specific asset is bound"
                },
                "variations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetReference"
                    },
                    "description": "Pre-approved asset variations for random selection.\nProcedural systems pick from this list rather than searching all assets.\n"
                }
            }
        },
        "MarkerType": {
            "type": "string",
            "description": "Types of marker nodes for spawn points, waypoints, and other positional markers.",
            "enum": [
                "generic",
                "spawn_point",
                "npc_spawn",
                "waypoint",
                "camera_point",
                "light_point",
                "audio_point",
                "trigger_point"
            ]
        },
        "VolumeShape": {
            "type": "string",
            "description": "Shape of a volume node for spatial bounds",
            "enum": [
                "box",
                "sphere",
                "capsule",
                "cylinder"
            ]
        }
    }
}
""";

    private static readonly string _UpdateScene_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/SceneResponse",
    "$defs": {
        "SceneResponse": {
            "type": "object",
            "description": "Standard response containing a scene",
            "required": [
                "scene"
            ],
            "properties": {
                "scene": {
                    "$ref": "#/$defs/Scene",
                    "description": "The scene document"
                }
            }
        },
        "Scene": {
            "type": "object",
            "description": "A complete scene document with hierarchical node structure",
            "required": [
                "sceneId",
                "gameId",
                "sceneType",
                "name",
                "version",
                "root"
            ],
            "properties": {
                "schema": {
                    "type": "string",
                    "description": "Schema identifier for validation",
                    "default": "bannou://schemas/scene/v1"
                },
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique scene identifier"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game service identifier for partitioning. Treated as opaque string.\nDefault is the nil UUID for unpartitioned scenes.\n",
                    "default": "00000000-0000-0000-0000-000000000000"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene classification for querying and validation"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable scene name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional scene description"
                },
                "version": {
                    "type": "string",
                    "pattern": "^\\d+\\.\\d+\\.\\d+$",
                    "description": "Semantic version (MAJOR.MINOR.PATCH)"
                },
                "root": {
                    "$ref": "#/$defs/SceneNode",
                    "description": "Root node of the scene hierarchy"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for filtering scenes"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Scene-level metadata. Not interpreted by Scene service.\nExamples: author, thumbnail, editor preferences, generator config.\n"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was last modified"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        },
        "SceneNode": {
            "type": "object",
            "description": "A node in the scene hierarchy. Nodes can contain children to form\na tree structure. Each node has a local transform relative to its parent.\n",
            "required": [
                "nodeId",
                "refId",
                "name",
                "nodeType",
                "localTransform"
            ],
            "properties": {
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Globally unique node identifier"
                },
                "refId": {
                    "type": "string",
                    "pattern": "^[a-z][a-z0-9_]*$",
                    "description": "Scene-local reference identifier. Must be unique within the scene.\nUsed for scripting and cross-referencing. Examples: main_door, npc_spawn_1\n"
                },
                "parentNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Parent node ID. Null for the root node only."
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable display name for the node"
                },
                "nodeType": {
                    "$ref": "#/$defs/NodeType",
                    "description": "The structural type of this node"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Transform relative to parent node"
                },
                "asset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Optional asset binding (mesh, sound, particle effect)"
                },
                "children": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SceneNode"
                    },
                    "description": "Child nodes in the hierarchy"
                },
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether this node is active in the scene definition"
                },
                "sortOrder": {
                    "type": "integer",
                    "default": 0,
                    "description": "Ordering among siblings for deterministic iteration"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive)"
                },
                "annotations": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Consumer-specific data stored without interpretation.\nUse namespaced keys (e.g., render.castShadows, arcadia.interactionType).\n"
                },
                "attachmentPoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AttachmentPoint"
                    },
                    "description": "Predefined locations for attaching child objects.\ nUsed by Scene Composer for furniture decoration, wall accessories, etc.\n"
                },
                "affordances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/Affordance"
                    },
                    "description": "Interaction capabilities of this node.\nUsed by AI navigation and character controllers.\n"
                },
                "assetSlot": {
                    "$ref": "#/$defs/AssetSlot",
                    "nullable": true,
                    "description": "Procedural asset swapping configuration.\nDefines which assets can substitute for this node's asset.\n"
                },
                "markerType": {
                    "$ref": "#/$defs/MarkerType",
                    "nullable": true,
                    "description": "Type of marker for marker nodes.\nOnly relevant when nodeType is 'marker'.\n"
                },
                "volumeShape": {
                    "$ref": "#/$defs/VolumeShape",
                    "nullable": true,
                    "description": "Shape of volume for volume nodes.\nOnly relevant when nodeType is 'volume'.\n"
                },
                "volumeSize": {
                    "$ref": "#/$defs/Vector3",
                    "nullable": true,
                    "description": "Size/extents of the volume (interpretation depends on volumeShape).\nFor box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.\n"
                },
                "referenceSceneId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Scene ID to embed for reference nodes.\nOnly relevant when nodeType is 'reference'.\n"
                }
            }
        },
        "NodeType": {
            "type": "string",
            "description": "Structural node type. Indicates what kind of data the node contains,\nnot how it will be used at runtime. Consumers interpret nodes according\nto their own needs via tags and annotations.\n",
            "enum": [
                "group",
                "mesh",
                "marker",
                "volume",
                "emitter",
                "reference",
                "custom"
            ]
        },
        "Transform": {
            "type": "object",
            "description": "Position, rotation, and scale in 3D space",
            "required": [
                "position",
                "rotation",
                "scale"
            ],
            "properties": {
                "position": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Position relative to parent"
                },
                "rotation": {
                    "$ref": "#/$defs/Quaternion",
                    "description": "Rotation relative to parent"
                },
                "scale": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Scale relative to parent"
                }
            }
        },
        "Vector3": {
            "type": "object",
            "description": "A point or direction in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate"
                }
            }
        },
        "Quaternion": {
            "type": "object",
            "description": "Rotation represented as a quaternion",
            "required": [
                "x",
                "y",
                "z",
                "w"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X component"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y component"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z component"
                },
                "w": {
                    "type": "number",
                    "format": "double",
                    "description": "W component (scalar)"
                }
            }
        },
        "AssetReference": {
            "type": "object",
            "description": "Reference to an asset in lib-asset",
            "required": [
                "assetId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Optional bundle containing the asset"
                },
                "assetId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Asset identifier in lib-asset"
                },
                "variantId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Variant identifier (consumer interprets meaning)"
                }
            }
        },
        "AttachmentPoint": {
            "type": "object",
            "description": "A predefined location where child objects can be attached.\nUsed for decorating furniture, walls, and other objects with accessories.\nExample: A wall may have attachment points for paintings, shelves, or light fixtures.\n",
            "required": [
                "name",
                "localTransform"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Unique name for this attachment point within the node.\nExamples: wall_hook_left, shelf_1, lamp_socket\n"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Position and orientation relative to the owning node"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags of assets that can attach here.\nExamples: wall_decoration, picture_frame, plant\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset to display if no specific attachment is specified"
                },
                "attachedNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "ID of the node currently attached at this point (runtime state)"
                }
            }
        },
        "Affordance": {
            "type": "object",
            "description": "Describes a capability or interaction mode for a node.\nUsed by AI systems to understand what actions are possible and by\ncharacter controllers for contextual animations.\n",
            "required": [
                "type"
            ],
            "properties": {
                "type": {
                    "$ref": "#/$defs/AffordanceType",
                    "description": "The type of affordance"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Type-specific parameters. Examples:\n- sittable: { height: 0.5, facing: [0,0,1] }\n- door: { openAngle: 90, locked: false }\n- container: { capacity: 10, itemTypes: [\"weapon\", \"consumable\"] }\n"
                }
            }
        },
        "AffordanceType": {
            "type": "string",
            "description": "Types of affordances describing what an object can do or how it can be interacted with.\nUsed by AI navigation, character controllers, and procedural content systems.\n",
            "enum": [
                "walkable",
                "climbable",
                "sittable",
                "interactive",
                "collectible",
                "destructible",
                "container",
                "door",
                "teleport"
            ]
        },
        "AssetSlot": {
            "type": "object",
            "description": "Defines acceptable asset types for procedural swapping at this node.\nUsed by procedural generation systems to substitute assets while\nmaintaining scene coherence.\n",
            "required": [
                "slotType"
            ],
            "properties": {
                "slotType": {
                    "type": "string",
                    "description": "Category of acceptable assets.\nExamples: chair, table, wall_art, floor_lamp\n"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags that acceptable assets must have.\nUsed for filtering when selecting random variations.\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset if no specific asset is bound"
                },
                "variations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetReference"
                    },
                    "description": "Pre-approved asset variations for random selection.\nProcedural systems pick from this list rather than searching all assets.\n"
                }
            }
        },
        "MarkerType": {
            "type": "string",
            "description": "Types of marker nodes for spawn points, waypoints, and other positional markers.",
            "enum": [
                "generic",
                "spawn_point",
                "npc_spawn",
                "waypoint",
                "camera_point",
                "light_point",
                "audio_point",
                "trigger_point"
            ]
        },
        "VolumeShape": {
            "type": "string",
            "description": "Shape of a volume node for spatial bounds",
            "enum": [
                "box",
                "sphere",
                "capsule",
                "cylinder"
            ]
        }
    }
}
""";

    private static readonly string _UpdateScene_Info = """
{
    "summary": "Update a scene document",
    "description": "Updates an existing scene document. Scene must not be checked out by\nanother user. Increments the PATCH version automatically.\nPublishes scene.updated event on success.\n",
    "tags": [
        "Scene"
    ],
    "deprecated": false,
    "operationId": "updateScene"
}
""";

    /// <summary>Returns endpoint information for UpdateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateScene_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/update",
            _UpdateScene_Info));

    /// <summary>Returns request schema for UpdateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateScene_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/update",
            "request-schema",
            _UpdateScene_RequestSchema));

    /// <summary>Returns response schema for UpdateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateScene_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/update",
            "response-schema",
            _UpdateScene_ResponseSchema));

    /// <summary>Returns full schema for UpdateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateScene_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/update",
            _UpdateScene_Info,
            _UpdateScene_RequestSchema,
            _UpdateScene_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeleteScene

    private static readonly string _DeleteScene_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteSceneRequest",
    "$defs": {
        "DeleteSceneRequest": {
            "type": "object",
            "description": "Request to delete a scene",
            "required": [
                "sceneId"
            ],
            "properties": {
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the scene to delete"
                },
                "reason": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional reason for deletion (included in event)"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteScene_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteSceneResponse",
    "$defs": {
        "DeleteSceneResponse": {
            "type": "object",
            "description": "Response confirming scene deletion",
            "required": [
                "deleted"
            ],
            "properties": {
                "deleted": {
                    "type": "boolean",
                    "description": "Whether the scene was successfully deleted"
                },
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the deleted scene"
                },
                "referencingScenes": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "uuid"
                    },
                    "nullable": true,
                    "description": "If deletion failed, IDs of scenes that reference this one"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteScene_Info = """
{
    "summary": "Delete a scene",
    "description": "Soft-deletes a scene. The scene data remains recoverable via lib-asset\nfor approximately 30 days. Cannot delete if other scenes reference this one.\ nPublishes scene.deleted event on success.\n",
    "tags": [
        "Scene"
    ],
    "deprecated": false,
    "operationId": "deleteScene"
}
""";

    /// <summary>Returns endpoint information for DeleteScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteScene_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/delete",
            _DeleteScene_Info));

    /// <summary>Returns request schema for DeleteScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteScene_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/delete",
            "request-schema",
            _DeleteScene_RequestSchema));

    /// <summary>Returns response schema for DeleteScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteScene_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/delete",
            "response-schema",
            _DeleteScene_ResponseSchema));

    /// <summary>Returns full schema for DeleteScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteScene_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/delete",
            _DeleteScene_Info,
            _DeleteScene_RequestSchema,
            _DeleteScene_ResponseSchema));

    #endregion

    #region Meta Endpoints for ValidateScene

    private static readonly string _ValidateScene_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ValidateSceneRequest",
    "$defs": {
        "ValidateSceneRequest": {
            "type": "object",
            "description": "Request to validate a scene structure",
            "required": [
                "scene"
            ],
            "properties": {
                "scene": {
                    "$ref": "#/$defs/Scene",
                    "description": "The scene to validate"
                },
                "applyGameRules": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether to apply registered game-specific validation rules"
                }
            }
        },
        "Scene": {
            "type": "object",
            "description": "A complete scene document with hierarchical node structure",
            "required": [
                "sceneId",
                "gameId",
                "sceneType",
                "name",
                "version",
                "root"
            ],
            "properties": {
                "schema": {
                    "type": "string",
                    "description": "Schema identifier for validation",
                    "default": "bannou://schemas/scene/v1"
                },
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique scene identifier"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game service identifier for partitioning. Treated as opaque string.\nDefault is the nil UUID for unpartitioned scenes.\n",
                    "default": "00000000-0000-0000-0000-000000000000"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene classification for querying and validation"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable scene name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional scene description"
                },
                "version": {
                    "type": "string",
                    "pattern": "^\\d+\\.\\d+\\.\\d+$",
                    "description": "Semantic version (MAJOR.MINOR.PATCH)"
                },
                "root": {
                    "$ref": "#/$defs/SceneNode",
                    "description": "Root node of the scene hierarchy"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for filtering scenes"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Scene-level metadata. Not interpreted by Scene service.\nExamples: author, thumbnail, editor preferences, generator config.\n"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was last modified"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        },
        "SceneNode": {
            "type": "object",
            "description": "A node in the scene hierarchy. Nodes can contain children to form\na tree structure. Each node has a local transform relative to its parent.\n",
            "required": [
                "nodeId",
                "refId",
                "name",
                "nodeType",
                "localTransform"
            ],
            "properties": {
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Globally unique node identifier"
                },
                "refId": {
                    "type": "string",
                    "pattern": "^[a-z][a-z0-9_]*$",
                    "description": "Scene-local reference identifier. Must be unique within the scene.\nUsed for scripting and cross-referencing. Examples: main_door, npc_spawn_1\n"
                },
                "parentNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Parent node ID. Null for the root node only."
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable display name for the node"
                },
                "nodeType": {
                    "$ref": "#/$defs/NodeType",
                    "description": "The structural type of this node"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Transform relative to parent node"
                },
                "asset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Optional asset binding (mesh, sound, particle effect)"
                },
                "children": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SceneNode"
                    },
                    "description": "Child nodes in the hierarchy"
                },
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether this node is active in the scene definition"
                },
                "sortOrder": {
                    "type": "integer",
                    "default": 0,
                    "description": "Ordering among siblings for deterministic iteration"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive)"
                },
                "annotations": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Consumer-specific data stored without interpretation.\nUse namespaced keys (e.g., render.castShadows, arcadia.interactionType).\n"
                },
                "attachmentPoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AttachmentPoint"
                    },
                    "description": "Predefined locations for attaching child objects.\ nUsed by Scene Composer for furniture decoration, wall accessories, etc.\n"
                },
                "affordances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/Affordance"
                    },
                    "description": "Interaction capabilities of this node.\nUsed by AI navigation and character controllers.\n"
                },
                "assetSlot": {
                    "$ref": "#/$defs/AssetSlot",
                    "nullable": true,
                    "description": "Procedural asset swapping configuration.\nDefines which assets can substitute for this node's asset.\n"
                },
                "markerType": {
                    "$ref": "#/$defs/MarkerType",
                    "nullable": true,
                    "description": "Type of marker for marker nodes.\nOnly relevant when nodeType is 'marker'.\n"
                },
                "volumeShape": {
                    "$ref": "#/$defs/VolumeShape",
                    "nullable": true,
                    "description": "Shape of volume for volume nodes.\nOnly relevant when nodeType is 'volume'.\n"
                },
                "volumeSize": {
                    "$ref": "#/$defs/Vector3",
                    "nullable": true,
                    "description": "Size/extents of the volume (interpretation depends on volumeShape).\nFor box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.\n"
                },
                "referenceSceneId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Scene ID to embed for reference nodes.\nOnly relevant when nodeType is 'reference'.\n"
                }
            }
        },
        "NodeType": {
            "type": "string",
            "description": "Structural node type. Indicates what kind of data the node contains,\nnot how it will be used at runtime. Consumers interpret nodes according\nto their own needs via tags and annotations.\n",
            "enum": [
                "group",
                "mesh",
                "marker",
                "volume",
                "emitter",
                "reference",
                "custom"
            ]
        },
        "Transform": {
            "type": "object",
            "description": "Position, rotation, and scale in 3D space",
            "required": [
                "position",
                "rotation",
                "scale"
            ],
            "properties": {
                "position": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Position relative to parent"
                },
                "rotation": {
                    "$ref": "#/$defs/Quaternion",
                    "description": "Rotation relative to parent"
                },
                "scale": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Scale relative to parent"
                }
            }
        },
        "Vector3": {
            "type": "object",
            "description": "A point or direction in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate"
                }
            }
        },
        "Quaternion": {
            "type": "object",
            "description": "Rotation represented as a quaternion",
            "required": [
                "x",
                "y",
                "z",
                "w"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X component"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y component"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z component"
                },
                "w": {
                    "type": "number",
                    "format": "double",
                    "description": "W component (scalar)"
                }
            }
        },
        "AssetReference": {
            "type": "object",
            "description": "Reference to an asset in lib-asset",
            "required": [
                "assetId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Optional bundle containing the asset"
                },
                "assetId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Asset identifier in lib-asset"
                },
                "variantId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Variant identifier (consumer interprets meaning)"
                }
            }
        },
        "AttachmentPoint": {
            "type": "object",
            "description": "A predefined location where child objects can be attached.\nUsed for decorating furniture, walls, and other objects with accessories.\nExample: A wall may have attachment points for paintings, shelves, or light fixtures.\n",
            "required": [
                "name",
                "localTransform"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Unique name for this attachment point within the node.\nExamples: wall_hook_left, shelf_1, lamp_socket\n"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Position and orientation relative to the owning node"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags of assets that can attach here.\nExamples: wall_decoration, picture_frame, plant\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset to display if no specific attachment is specified"
                },
                "attachedNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "ID of the node currently attached at this point (runtime state)"
                }
            }
        },
        "Affordance": {
            "type": "object",
            "description": "Describes a capability or interaction mode for a node.\nUsed by AI systems to understand what actions are possible and by\ncharacter controllers for contextual animations.\n",
            "required": [
                "type"
            ],
            "properties": {
                "type": {
                    "$ref": "#/$defs/AffordanceType",
                    "description": "The type of affordance"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Type-specific parameters. Examples:\n- sittable: { height: 0.5, facing: [0,0,1] }\n- door: { openAngle: 90, locked: false }\n- container: { capacity: 10, itemTypes: [\"weapon\", \"consumable\"] }\n"
                }
            }
        },
        "AffordanceType": {
            "type": "string",
            "description": "Types of affordances describing what an object can do or how it can be interacted with.\nUsed by AI navigation, character controllers, and procedural content systems.\n",
            "enum": [
                "walkable",
                "climbable",
                "sittable",
                "interactive",
                "collectible",
                "destructible",
                "container",
                "door",
                "teleport"
            ]
        },
        "AssetSlot": {
            "type": "object",
            "description": "Defines acceptable asset types for procedural swapping at this node.\nUsed by procedural generation systems to substitute assets while\nmaintaining scene coherence.\n",
            "required": [
                "slotType"
            ],
            "properties": {
                "slotType": {
                    "type": "string",
                    "description": "Category of acceptable assets.\nExamples: chair, table, wall_art, floor_lamp\n"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags that acceptable assets must have.\nUsed for filtering when selecting random variations.\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset if no specific asset is bound"
                },
                "variations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetReference"
                    },
                    "description": "Pre-approved asset variations for random selection.\nProcedural systems pick from this list rather than searching all assets.\n"
                }
            }
        },
        "MarkerType": {
            "type": "string",
            "description": "Types of marker nodes for spawn points, waypoints, and other positional markers.",
            "enum": [
                "generic",
                "spawn_point",
                "npc_spawn",
                "waypoint",
                "camera_point",
                "light_point",
                "audio_point",
                "trigger_point"
            ]
        },
        "VolumeShape": {
            "type": "string",
            "description": "Shape of a volume node for spatial bounds",
            "enum": [
                "box",
                "sphere",
                "capsule",
                "cylinder"
            ]
        }
    }
}
""";

    private static readonly string _ValidateScene_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ValidationResult",
    "$defs": {
        "ValidationResult": {
            "type": "object",
            "description": "Result of scene validation",
            "required": [
                "valid"
            ],
            "properties": {
                "valid": {
                    "type": "boolean",
                    "description": "Whether the scene passed all validation checks"
                },
                "errors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ValidationError"
                    },
                    "nullable": true,
                    "description": "Validation errors (severity = error)"
                },
                "warnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ValidationError"
                    },
                    "nullable": true,
                    "description": "Validation warnings (severity = warning)"
                }
            }
        },
        "ValidationError": {
            "type": "object",
            "description": "A single validation error or warning",
            "required": [
                "ruleId",
                "message",
                "severity"
            ],
            "properties": {
                "ruleId": {
                    "type": "string",
                    "description": "Identifier of the validation rule that triggered this"
                },
                "message": {
                    "type": "string",
                    "description": "Human-readable error message"
                },
                "severity": {
                    "$ref": "#/$defs/ValidationSeverity",
                    "description": "Severity level"
                },
                "nodePath": {
                    "type": "string",
                    "nullable": true,
                    "description": "Path to the problematic node (e.g., root.children[0].children[2])"
                },
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "ID of the problematic node"
                },
                "context": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Additional context for the error"
                }
            }
        },
        "ValidationSeverity": {
            "type": "string",
            "description": "Severity level of a validation issue",
            "enum": [
                "error",
                "warning"
            ]
        }
    }
}
""";

    private static readonly string _ValidateScene_Info = """
{
    "summary": "Validate a scene structure",
    "description": "Validates a scene document without saving it. Checks structural validity\nand optionally applies game-specific validation rules.\n",
    "tags": [
        "Scene"
    ],
    "deprecated": false,
    "operationId": "validateScene"
}
""";

    /// <summary>Returns endpoint information for ValidateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/validate/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ValidateScene_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/validate",
            _ValidateScene_Info));

    /// <summary>Returns request schema for ValidateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/validate/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ValidateScene_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/validate",
            "request-schema",
            _ValidateScene_RequestSchema));

    /// <summary>Returns response schema for ValidateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/validate/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ValidateScene_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/validate",
            "response-schema",
            _ValidateScene_ResponseSchema));

    /// <summary>Returns full schema for ValidateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/validate/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ValidateScene_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/validate",
            _ValidateScene_Info,
            _ValidateScene_RequestSchema,
            _ValidateScene_ResponseSchema));

    #endregion

    #region Meta Endpoints for InstantiateScene

    private static readonly string _InstantiateScene_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/InstantiateSceneRequest",
    "$defs": {
        "InstantiateSceneRequest": {
            "type": "object",
            "description": "Request to record a scene instantiation",
            "required": [
                "sceneAssetId",
                "instanceId",
                "regionId",
                "worldTransform"
            ],
            "properties": {
                "sceneAssetId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Scene asset ID that was instantiated"
                },
                "version": {
                    "type": "string",
                    "nullable": true,
                    "description": "Specific version (null = validates latest exists)"
                },
                "instanceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Caller-provided unique instance ID"
                },
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region where scene was placed"
                },
                "worldTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "World-space transform for scene origin"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Caller-provided metadata passed to event"
                }
            }
        },
        "Transform": {
            "type": "object",
            "description": "Position, rotation, and scale in 3D space",
            "required": [
                "position",
                "rotation",
                "scale"
            ],
            "properties": {
                "position": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Position relative to parent"
                },
                "rotation": {
                    "$ref": "#/$defs/Quaternion",
                    "description": "Rotation relative to parent"
                },
                "scale": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Scale relative to parent"
                }
            }
        },
        "Vector3": {
            "type": "object",
            "description": "A point or direction in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate"
                }
            }
        },
        "Quaternion": {
            "type": "object",
            "description": "Rotation represented as a quaternion",
            "required": [
                "x",
                "y",
                "z",
                "w"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X component"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y component"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z component"
                },
                "w": {
                    "type": "number",
                    "format": "double",
                    "description": "W component (scalar)"
                }
            }
        }
    }
}
""";

    private static readonly string _InstantiateScene_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/InstantiateSceneResponse",
    "$defs": {
        "InstantiateSceneResponse": {
            "type": "object",
            "description": "Response confirming instantiation",
            "required": [
                "instanceId",
                "sceneVersion"
            ],
            "properties": {
                "instanceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "The instance ID"
                },
                "sceneVersion": {
                    "type": "string",
                    "description": "Version that was instantiated"
                },
                "eventPublished": {
                    "type": "boolean",
                    "description": "Whether the event was successfully published"
                }
            }
        }
    }
}
""";

    private static readonly string _InstantiateScene_Info = """
{
    "summary": "Declare that a scene was instantiated in the game world",
    "description": "Records a scene instantiation and publishes an event. This is a\nNOTIFICATION endpoint - the caller has already instantiated the scene.\n\n1. Validates scene exists and is accessible\n2. Publishes scene.instantiated event\ n\nConsumers (Mapping, Actor, etc.) react to the event independently.\n",
    "tags": [
        "Instance"
    ],
    "deprecated": false,
    "operationId": "instantiateScene"
}
""";

    /// <summary>Returns endpoint information for InstantiateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/instantiate/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> InstantiateScene_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/instantiate",
            _InstantiateScene_Info));

    /// <summary>Returns request schema for InstantiateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/instantiate/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> InstantiateScene_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/instantiate",
            "request-schema",
            _InstantiateScene_RequestSchema));

    /// <summary>Returns response schema for InstantiateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/instantiate/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> InstantiateScene_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/instantiate",
            "response-schema",
            _InstantiateScene_ResponseSchema));

    /// <summary>Returns full schema for InstantiateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/instantiate/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> InstantiateScene_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/instantiate",
            _InstantiateScene_Info,
            _InstantiateScene_RequestSchema,
            _InstantiateScene_ResponseSchema));

    #endregion

    #region Meta Endpoints for DestroyInstance

    private static readonly string _DestroyInstance_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DestroyInstanceRequest",
    "$defs": {
        "DestroyInstanceRequest": {
            "type": "object",
            "description": "Request to record instance destruction",
            "required": [
                "instanceId"
            ],
            "properties": {
                "instanceId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Instance ID to destroy"
                },
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Region where instance was (for event metadata)"
                },
                "sceneAssetId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Scene asset ID (for event metadata)"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Caller-provided metadata"
                }
            }
        }
    }
}
""";

    private static readonly string _DestroyInstance_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DestroyInstanceResponse",
    "$defs": {
        "DestroyInstanceResponse": {
            "type": "object",
            "description": "Response confirming destruction",
            "required": [
                "destroyed"
            ],
            "properties": {
                "destroyed": {
                    "type": "boolean",
                    "description": "Whether destruction was recorded"
                },
                "eventPublished": {
                    "type": "boolean",
                    "description": "Whether the event was successfully published"
                }
            }
        }
    }
}
""";

    private static readonly string _DestroyInstance_Info = """
{
    "summary": "Declare that a scene instance was removed",
    "description": "Records instance destruction and publishes an event.\nConsumers react to clean up spatial data, despawn NPCs, etc.\n",
    "tags": [
        "Instance"
    ],
    "deprecated": false,
    "operationId": "destroyInstance"
}
""";

    /// <summary>Returns endpoint information for DestroyInstance</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/destroy-instance/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DestroyInstance_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/destroy-instance",
            _DestroyInstance_Info));

    /// <summary>Returns request schema for DestroyInstance</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/destroy-instance/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DestroyInstance_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/destroy-instance",
            "request-schema",
            _DestroyInstance_RequestSchema));

    /// <summary>Returns response schema for DestroyInstance</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/destroy-instance/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DestroyInstance_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/destroy-instance",
            "response-schema",
            _DestroyInstance_ResponseSchema));

    /// <summary>Returns full schema for DestroyInstance</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/destroy-instance/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DestroyInstance_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/destroy-instance",
            _DestroyInstance_Info,
            _DestroyInstance_RequestSchema,
            _DestroyInstance_ResponseSchema));

    #endregion

    #region Meta Endpoints for CheckoutScene

    private static readonly string _CheckoutScene_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CheckoutRequest",
    "$defs": {
        "CheckoutRequest": {
            "type": "object",
            "description": "Request to checkout a scene for editing",
            "required": [
                "sceneId"
            ],
            "properties": {
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Scene to checkout"
                },
                "editorId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional editor identifier (defaults to caller identity)"
                },
                "ttlMinutes": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Custom lock TTL (uses default if not specified)"
                }
            }
        }
    }
}
""";

    private static readonly string _CheckoutScene_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CheckoutResponse",
    "$defs": {
        "CheckoutResponse": {
            "type": "object",
            "description": "Response containing checkout token and scene",
            "required": [
                "checkoutToken",
                "scene",
                "expiresAt"
            ],
            "properties": {
                "checkoutToken": {
                    "type": "string",
                    "description": "Token required for commit/discard/heartbeat"
                },
                "scene": {
                    "$ref": "#/$defs/Scene",
                    "description": "Current scene document"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the checkout lock expires"
                }
            }
        },
        "Scene": {
            "type": "object",
            "description": "A complete scene document with hierarchical node structure",
            "required": [
                "sceneId",
                "gameId",
                "sceneType",
                "name",
                "version",
                "root"
            ],
            "properties": {
                "schema": {
                    "type": "string",
                    "description": "Schema identifier for validation",
                    "default": "bannou://schemas/scene/v1"
                },
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique scene identifier"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game service identifier for partitioning. Treated as opaque string.\ nDefault is the nil UUID for unpartitioned scenes.\n",
                    "default": "00000000-0000-0000-0000-000000000000"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene classification for querying and validation"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable scene name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional scene description"
                },
                "version": {
                    "type": "string",
                    "pattern": "^\\d+\\.\\d+\\.\\d+$",
                    "description": "Semantic version (MAJOR.MINOR.PATCH)"
                },
                "root": {
                    "$ref": "#/$defs/SceneNode",
                    "description": "Root node of the scene hierarchy"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for filtering scenes"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Scene-level metadata. Not interpreted by Scene service.\nExamples: author, thumbnail, editor preferences, generator config.\n"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was last modified"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        },
        "SceneNode": {
            "type": "object",
            "description": "A node in the scene hierarchy. Nodes can contain children to form\na tree structure. Each node has a local transform relative to its parent.\n",
            "required": [
                "nodeId",
                "refId",
                "name",
                "nodeType",
                "localTransform"
            ],
            "properties": {
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Globally unique node identifier"
                },
                "refId": {
                    "type": "string",
                    "pattern": "^[a-z][a-z0-9_]*$",
                    "description": "Scene-local reference identifier. Must be unique within the scene.\nUsed for scripting and cross-referencing. Examples: main_door, npc_spawn_1\n"
                },
                "parentNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Parent node ID. Null for the root node only."
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable display name for the node"
                },
                "nodeType": {
                    "$ref": "#/$defs/NodeType",
                    "description": "The structural type of this node"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Transform relative to parent node"
                },
                "asset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Optional asset binding (mesh, sound, particle effect)"
                },
                "children": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SceneNode"
                    },
                    "description": "Child nodes in the hierarchy"
                },
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether this node is active in the scene definition"
                },
                "sortOrder": {
                    "type": "integer",
                    "default": 0,
                    "description": "Ordering among siblings for deterministic iteration"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive)"
                },
                "annotations": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Consumer-specific data stored without interpretation.\nUse namespaced keys (e.g., render.castShadows, arcadia.interactionType).\n"
                },
                "attachmentPoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AttachmentPoint"
                    },
                    "description": "Predefined locations for attaching child objects.\ nUsed by Scene Composer for furniture decoration, wall accessories, etc.\n"
                },
                "affordances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/Affordance"
                    },
                    "description": "Interaction capabilities of this node.\nUsed by AI navigation and character controllers.\n"
                },
                "assetSlot": {
                    "$ref": "#/$defs/AssetSlot",
                    "nullable": true,
                    "description": "Procedural asset swapping configuration.\nDefines which assets can substitute for this node's asset.\n"
                },
                "markerType": {
                    "$ref": "#/$defs/MarkerType",
                    "nullable": true,
                    "description": "Type of marker for marker nodes.\nOnly relevant when nodeType is 'marker'.\n"
                },
                "volumeShape": {
                    "$ref": "#/$defs/VolumeShape",
                    "nullable": true,
                    "description": "Shape of volume for volume nodes.\nOnly relevant when nodeType is 'volume'.\n"
                },
                "volumeSize": {
                    "$ref": "#/$defs/Vector3",
                    "nullable": true,
                    "description": "Size/extents of the volume (interpretation depends on volumeShape).\nFor box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.\n"
                },
                "referenceSceneId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Scene ID to embed for reference nodes.\nOnly relevant when nodeType is 'reference'.\n"
                }
            }
        },
        "NodeType": {
            "type": "string",
            "description": "Structural node type. Indicates what kind of data the node contains,\nnot how it will be used at runtime. Consumers interpret nodes according\nto their own needs via tags and annotations.\n",
            "enum": [
                "group",
                "mesh",
                "marker",
                "volume",
                "emitter",
                "reference",
                "custom"
            ]
        },
        "Transform": {
            "type": "object",
            "description": "Position, rotation, and scale in 3D space",
            "required": [
                "position",
                "rotation",
                "scale"
            ],
            "properties": {
                "position": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Position relative to parent"
                },
                "rotation": {
                    "$ref": "#/$defs/Quaternion",
                    "description": "Rotation relative to parent"
                },
                "scale": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Scale relative to parent"
                }
            }
        },
        "Vector3": {
            "type": "object",
            "description": "A point or direction in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate"
                }
            }
        },
        "Quaternion": {
            "type": "object",
            "description": "Rotation represented as a quaternion",
            "required": [
                "x",
                "y",
                "z",
                "w"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X component"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y component"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z component"
                },
                "w": {
                    "type": "number",
                    "format": "double",
                    "description": "W component (scalar)"
                }
            }
        },
        "AssetReference": {
            "type": "object",
            "description": "Reference to an asset in lib-asset",
            "required": [
                "assetId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Optional bundle containing the asset"
                },
                "assetId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Asset identifier in lib-asset"
                },
                "variantId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Variant identifier (consumer interprets meaning)"
                }
            }
        },
        "AttachmentPoint": {
            "type": "object",
            "description": "A predefined location where child objects can be attached.\nUsed for decorating furniture, walls, and other objects with accessories.\nExample: A wall may have attachment points for paintings, shelves, or light fixtures.\n",
            "required": [
                "name",
                "localTransform"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Unique name for this attachment point within the node.\nExamples: wall_hook_left, shelf_1, lamp_socket\n"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Position and orientation relative to the owning node"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags of assets that can attach here.\nExamples: wall_decoration, picture_frame, plant\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset to display if no specific attachment is specified"
                },
                "attachedNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "ID of the node currently attached at this point (runtime state)"
                }
            }
        },
        "Affordance": {
            "type": "object",
            "description": "Describes a capability or interaction mode for a node.\nUsed by AI systems to understand what actions are possible and by\ncharacter controllers for contextual animations.\n",
            "required": [
                "type"
            ],
            "properties": {
                "type": {
                    "$ref": "#/$defs/AffordanceType",
                    "description": "The type of affordance"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Type-specific parameters. Examples:\n- sittable: { height: 0.5, facing: [0,0,1] }\n- door: { openAngle: 90, locked: false }\n- container: { capacity: 10, itemTypes: [\"weapon\", \"consumable\"] }\n"
                }
            }
        },
        "AffordanceType": {
            "type": "string",
            "description": "Types of affordances describing what an object can do or how it can be interacted with.\nUsed by AI navigation, character controllers, and procedural content systems.\n",
            "enum": [
                "walkable",
                "climbable",
                "sittable",
                "interactive",
                "collectible",
                "destructible",
                "container",
                "door",
                "teleport"
            ]
        },
        "AssetSlot": {
            "type": "object",
            "description": "Defines acceptable asset types for procedural swapping at this node.\nUsed by procedural generation systems to substitute assets while\nmaintaining scene coherence.\n",
            "required": [
                "slotType"
            ],
            "properties": {
                "slotType": {
                    "type": "string",
                    "description": "Category of acceptable assets.\nExamples: chair, table, wall_art, floor_lamp\n"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags that acceptable assets must have.\nUsed for filtering when selecting random variations.\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset if no specific asset is bound"
                },
                "variations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetReference"
                    },
                    "description": "Pre-approved asset variations for random selection.\nProcedural systems pick from this list rather than searching all assets.\n"
                }
            }
        },
        "MarkerType": {
            "type": "string",
            "description": "Types of marker nodes for spawn points, waypoints, and other positional markers.",
            "enum": [
                "generic",
                "spawn_point",
                "npc_spawn",
                "waypoint",
                "camera_point",
                "light_point",
                "audio_point",
                "trigger_point"
            ]
        },
        "VolumeShape": {
            "type": "string",
            "description": "Shape of a volume node for spatial bounds",
            "enum": [
                "box",
                "sphere",
                "capsule",
                "cylinder"
            ]
        }
    }
}
""";

    private static readonly string _CheckoutScene_Info = """
{
    "summary": "Lock a scene for editing",
    "description": "Acquires an exclusive lock on the scene for editing.\nReturns a checkout token required for commit.\nLock expires after TTL if not extended via heartbeat.\n",
    "tags": [
        "Versioning"
    ],
    "deprecated": false,
    "operationId": "checkoutScene"
}
""";

    /// <summary>Returns endpoint information for CheckoutScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/checkout/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckoutScene_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/checkout",
            _CheckoutScene_Info));

    /// <summary>Returns request schema for CheckoutScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/checkout/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckoutScene_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/checkout",
            "request-schema",
            _CheckoutScene_RequestSchema));

    /// <summary>Returns response schema for CheckoutScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/checkout/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckoutScene_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/checkout",
            "response-schema",
            _CheckoutScene_ResponseSchema));

    /// <summary>Returns full schema for CheckoutScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/checkout/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckoutScene_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/checkout",
            _CheckoutScene_Info,
            _CheckoutScene_RequestSchema,
            _CheckoutScene_ResponseSchema));

    #endregion

    #region Meta Endpoints for CommitScene

    private static readonly string _CommitScene_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CommitRequest",
    "$defs": {
        "CommitRequest": {
            "type": "object",
            "description": "Request to commit checkout changes",
            "required": [
                "sceneId",
                "checkoutToken",
                "scene"
            ],
            "properties": {
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Scene being committed"
                },
                "checkoutToken": {
                    "type": "string",
                    "description": "Checkout token from checkout response"
                },
                "scene": {
                    "$ref": "#/$defs/Scene",
                    "description": "Updated scene document"
                },
                "changesSummary": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional summary of changes for audit"
                }
            }
        },
        "Scene": {
            "type": "object",
            "description": "A complete scene document with hierarchical node structure",
            "required": [
                "sceneId",
                "gameId",
                "sceneType",
                "name",
                "version",
                "root"
            ],
            "properties": {
                "schema": {
                    "type": "string",
                    "description": "Schema identifier for validation",
                    "default": "bannou://schemas/scene/v1"
                },
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique scene identifier"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game service identifier for partitioning. Treated as opaque string.\nDefault is the nil UUID for unpartitioned scenes.\n",
                    "default": "00000000-0000-0000-0000-000000000000"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene classification for querying and validation"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable scene name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional scene description"
                },
                "version": {
                    "type": "string",
                    "pattern": "^\\d+\\.\\d+\\.\\d+$",
                    "description": "Semantic version (MAJOR.MINOR.PATCH)"
                },
                "root": {
                    "$ref": "#/$defs/SceneNode",
                    "description": "Root node of the scene hierarchy"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for filtering scenes"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Scene-level metadata. Not interpreted by Scene service.\nExamples: author, thumbnail, editor preferences, generator config.\n"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was last modified"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        },
        "SceneNode": {
            "type": "object",
            "description": "A node in the scene hierarchy. Nodes can contain children to form\na tree structure. Each node has a local transform relative to its parent.\n",
            "required": [
                "nodeId",
                "refId",
                "name",
                "nodeType",
                "localTransform"
            ],
            "properties": {
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Globally unique node identifier"
                },
                "refId": {
                    "type": "string",
                    "pattern": "^[a-z][a-z0-9_]*$",
                    "description": "Scene-local reference identifier. Must be unique within the scene.\nUsed for scripting and cross-referencing. Examples: main_door, npc_spawn_1\n"
                },
                "parentNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Parent node ID. Null for the root node only."
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable display name for the node"
                },
                "nodeType": {
                    "$ref": "#/$defs/NodeType",
                    "description": "The structural type of this node"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Transform relative to parent node"
                },
                "asset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Optional asset binding (mesh, sound, particle effect)"
                },
                "children": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SceneNode"
                    },
                    "description": "Child nodes in the hierarchy"
                },
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether this node is active in the scene definition"
                },
                "sortOrder": {
                    "type": "integer",
                    "default": 0,
                    "description": "Ordering among siblings for deterministic iteration"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive)"
                },
                "annotations": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Consumer-specific data stored without interpretation.\nUse namespaced keys (e.g., render.castShadows, arcadia.interactionType).\n"
                },
                "attachmentPoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AttachmentPoint"
                    },
                    "description": "Predefined locations for attaching child objects.\nUsed by Scene Composer for furniture decoration, wall accessories, etc.\n"
                },
                "affordances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/Affordance"
                    },
                    "description": "Interaction capabilities of this node.\nUsed by AI navigation and character controllers.\n"
                },
                "assetSlot": {
                    "$ref": "#/$defs/AssetSlot",
                    "nullable": true,
                    "description": "Procedural asset swapping configuration.\nDefines which assets can substitute for this node's asset.\n"
                },
                "markerType": {
                    "$ref": "#/$defs/MarkerType",
                    "nullable": true,
                    "description": "Type of marker for marker nodes.\nOnly relevant when nodeType is 'marker'.\n"
                },
                "volumeShape": {
                    "$ref": "#/$defs/VolumeShape",
                    "nullable": true,
                    "description": "Shape of volume for volume nodes.\nOnly relevant when nodeType is 'volume'.\n"
                },
                "volumeSize": {
                    "$ref": "#/$defs/Vector3",
                    "nullable": true,
                    "description": "Size/extents of the volume (interpretation depends on volumeShape).\ nFor box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.\n"
                },
                "referenceSceneId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Scene ID to embed for reference nodes.\nOnly relevant when nodeType is 'reference'.\n"
                }
            }
        },
        "NodeType": {
            "type": "string",
            "description": "Structural node type. Indicates what kind of data the node contains,\nnot how it will be used at runtime. Consumers interpret nodes according\nto their own needs via tags and annotations.\n",
            "enum": [
                "group",
                "mesh",
                "marker",
                "volume",
                "emitter",
                "reference",
                "custom"
            ]
        },
        "Transform": {
            "type": "object",
            "description": "Position, rotation, and scale in 3D space",
            "required": [
                "position",
                "rotation",
                "scale"
            ],
            "properties": {
                "position": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Position relative to parent"
                },
                "rotation": {
                    "$ref": "#/$defs/Quaternion",
                    "description": "Rotation relative to parent"
                },
                "scale": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Scale relative to parent"
                }
            }
        },
        "Vector3": {
            "type": "object",
            "description": "A point or direction in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate"
                }
            }
        },
        "Quaternion": {
            "type": "object",
            "description": "Rotation represented as a quaternion",
            "required": [
                "x",
                "y",
                "z",
                "w"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X component"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y component"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z component"
                },
                "w": {
                    "type": "number",
                    "format": "double",
                    "description": "W component (scalar)"
                }
            }
        },
        "AssetReference": {
            "type": "object",
            "description": "Reference to an asset in lib-asset",
            "required": [
                "assetId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Optional bundle containing the asset"
                },
                "assetId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Asset identifier in lib-asset"
                },
                "variantId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Variant identifier (consumer interprets meaning)"
                }
            }
        },
        "AttachmentPoint": {
            "type": "object",
            "description": "A predefined location where child objects can be attached.\nUsed for decorating furniture, walls, and other objects with accessories.\nExample: A wall may have attachment points for paintings, shelves, or light fixtures.\n",
            "required": [
                "name",
                "localTransform"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Unique name for this attachment point within the node.\nExamples: wall_hook_left, shelf_1, lamp_socket\n"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Position and orientation relative to the owning node"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags of assets that can attach here.\nExamples: wall_decoration, picture_frame, plant\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset to display if no specific attachment is specified"
                },
                "attachedNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "ID of the node currently attached at this point (runtime state)"
                }
            }
        },
        "Affordance": {
            "type": "object",
            "description": "Describes a capability or interaction mode for a node.\nUsed by AI systems to understand what actions are possible and by\ncharacter controllers for contextual animations.\n",
            "required": [
                "type"
            ],
            "properties": {
                "type": {
                    "$ref": "#/$defs/AffordanceType",
                    "description": "The type of affordance"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Type-specific parameters. Examples:\n- sittable: { height: 0.5, facing: [0,0,1] }\n- door: { openAngle: 90, locked: false }\n- container: { capacity: 10, itemTypes: [\"weapon\", \"consumable\"] }\n"
                }
            }
        },
        "AffordanceType": {
            "type": "string",
            "description": "Types of affordances describing what an object can do or how it can be interacted with.\nUsed by AI navigation, character controllers, and procedural content systems.\n",
            "enum": [
                "walkable",
                "climbable",
                "sittable",
                "interactive",
                "collectible",
                "destructible",
                "container",
                "door",
                "teleport"
            ]
        },
        "AssetSlot": {
            "type": "object",
            "description": "Defines acceptable asset types for procedural swapping at this node.\nUsed by procedural generation systems to substitute assets while\nmaintaining scene coherence.\n",
            "required": [
                "slotType"
            ],
            "properties": {
                "slotType": {
                    "type": "string",
                    "description": "Category of acceptable assets.\nExamples: chair, table, wall_art, floor_lamp\n"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags that acceptable assets must have.\nUsed for filtering when selecting random variations.\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset if no specific asset is bound"
                },
                "variations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetReference"
                    },
                    "description": "Pre-approved asset variations for random selection.\nProcedural systems pick from this list rather than searching all assets.\n"
                }
            }
        },
        "MarkerType": {
            "type": "string",
            "description": "Types of marker nodes for spawn points, waypoints, and other positional markers.",
            "enum": [
                "generic",
                "spawn_point",
                "npc_spawn",
                "waypoint",
                "camera_point",
                "light_point",
                "audio_point",
                "trigger_point"
            ]
        },
        "VolumeShape": {
            "type": "string",
            "description": "Shape of a volume node for spatial bounds",
            "enum": [
                "box",
                "sphere",
                "capsule",
                "cylinder"
            ]
        }
    }
}
""";

    private static readonly string _CommitScene_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CommitResponse",
    "$defs": {
        "CommitResponse": {
            "type": "object",
            "description": "Response confirming commit",
            "required": [
                "committed",
                "newVersion"
            ],
            "properties": {
                "committed": {
                    "type": "boolean",
                    "description": "Whether commit was successful"
                },
                "newVersion": {
                    "type": "string",
                    "description": "New version after commit"
                },
                "scene": {
                    "$ref": "#/$defs/Scene",
                    "nullable": true,
                    "description": "Committed scene with updated metadata"
                }
            }
        },
        "Scene": {
            "type": "object",
            "description": "A complete scene document with hierarchical node structure",
            "required": [
                "sceneId",
                "gameId",
                "sceneType",
                "name",
                "version",
                "root"
            ],
            "properties": {
                "schema": {
                    "type": "string",
                    "description": "Schema identifier for validation",
                    "default": "bannou://schemas/scene/v1"
                },
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique scene identifier"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game service identifier for partitioning. Treated as opaque string.\nDefault is the nil UUID for unpartitioned scenes.\n",
                    "default": "00000000-0000-0000-0000-000000000000"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene classification for querying and validation"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable scene name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional scene description"
                },
                "version": {
                    "type": "string",
                    "pattern": "^\\d+\\.\\d+\\.\\d+$",
                    "description": "Semantic version (MAJOR.MINOR.PATCH)"
                },
                "root": {
                    "$ref": "#/$defs/SceneNode",
                    "description": "Root node of the scene hierarchy"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for filtering scenes"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Scene-level metadata. Not interpreted by Scene service.\nExamples: author, thumbnail, editor preferences, generator config.\n"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was last modified"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        },
        "SceneNode": {
            "type": "object",
            "description": "A node in the scene hierarchy. Nodes can contain children to form\na tree structure. Each node has a local transform relative to its parent.\n",
            "required": [
                "nodeId",
                "refId",
                "name",
                "nodeType",
                "localTransform"
            ],
            "properties": {
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Globally unique node identifier"
                },
                "refId": {
                    "type": "string",
                    "pattern": "^[a-z][a-z0-9_]*$",
                    "description": "Scene-local reference identifier. Must be unique within the scene.\nUsed for scripting and cross-referencing. Examples: main_door, npc_spawn_1\n"
                },
                "parentNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Parent node ID. Null for the root node only."
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable display name for the node"
                },
                "nodeType": {
                    "$ref": "#/$defs/NodeType",
                    "description": "The structural type of this node"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Transform relative to parent node"
                },
                "asset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Optional asset binding (mesh, sound, particle effect)"
                },
                "children": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SceneNode"
                    },
                    "description": "Child nodes in the hierarchy"
                },
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether this node is active in the scene definition"
                },
                "sortOrder": {
                    "type": "integer",
                    "default": 0,
                    "description": "Ordering among siblings for deterministic iteration"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive)"
                },
                "annotations": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Consumer-specific data stored without interpretation.\nUse namespaced keys (e.g., render.castShadows, arcadia.interactionType).\n"
                },
                "attachmentPoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AttachmentPoint"
                    },
                    "description": "Predefined locations for attaching child objects.\nUsed by Scene Composer for furniture decoration, wall accessories, etc.\n"
                },
                "affordances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/Affordance"
                    },
                    "description": "Interaction capabilities of this node.\nUsed by AI navigation and character controllers.\n"
                },
                "assetSlot": {
                    "$ref": "#/$defs/AssetSlot",
                    "nullable": true,
                    "description": "Procedural asset swapping configuration.\nDefines which assets can substitute for this node's asset.\n"
                },
                "markerType": {
                    "$ref": "#/$defs/MarkerType",
                    "nullable": true,
                    "description": "Type of marker for marker nodes.\nOnly relevant when nodeType is 'marker'.\n"
                },
                "volumeShape": {
                    "$ref": "#/$defs/VolumeShape",
                    "nullable": true,
                    "description": "Shape of volume for volume nodes.\nOnly relevant when nodeType is 'volume'.\n"
                },
                "volumeSize": {
                    "$ref": "#/$defs/Vector3",
                    "nullable": true,
                    "description": "Size/extents of the volume (interpretation depends on volumeShape).\ nFor box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.\n"
                },
                "referenceSceneId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Scene ID to embed for reference nodes.\nOnly relevant when nodeType is 'reference'.\n"
                }
            }
        },
        "NodeType": {
            "type": "string",
            "description": "Structural node type. Indicates what kind of data the node contains,\nnot how it will be used at runtime. Consumers interpret nodes according\nto their own needs via tags and annotations.\n",
            "enum": [
                "group",
                "mesh",
                "marker",
                "volume",
                "emitter",
                "reference",
                "custom"
            ]
        },
        "Transform": {
            "type": "object",
            "description": "Position, rotation, and scale in 3D space",
            "required": [
                "position",
                "rotation",
                "scale"
            ],
            "properties": {
                "position": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Position relative to parent"
                },
                "rotation": {
                    "$ref": "#/$defs/Quaternion",
                    "description": "Rotation relative to parent"
                },
                "scale": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Scale relative to parent"
                }
            }
        },
        "Vector3": {
            "type": "object",
            "description": "A point or direction in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate"
                }
            }
        },
        "Quaternion": {
            "type": "object",
            "description": "Rotation represented as a quaternion",
            "required": [
                "x",
                "y",
                "z",
                "w"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X component"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y component"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z component"
                },
                "w": {
                    "type": "number",
                    "format": "double",
                    "description": "W component (scalar)"
                }
            }
        },
        "AssetReference": {
            "type": "object",
            "description": "Reference to an asset in lib-asset",
            "required": [
                "assetId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Optional bundle containing the asset"
                },
                "assetId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Asset identifier in lib-asset"
                },
                "variantId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Variant identifier (consumer interprets meaning)"
                }
            }
        },
        "AttachmentPoint": {
            "type": "object",
            "description": "A predefined location where child objects can be attached.\nUsed for decorating furniture, walls, and other objects with accessories.\nExample: A wall may have attachment points for paintings, shelves, or light fixtures.\n",
            "required": [
                "name",
                "localTransform"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Unique name for this attachment point within the node.\nExamples: wall_hook_left, shelf_1, lamp_socket\n"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Position and orientation relative to the owning node"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags of assets that can attach here.\nExamples: wall_decoration, picture_frame, plant\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset to display if no specific attachment is specified"
                },
                "attachedNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "ID of the node currently attached at this point (runtime state)"
                }
            }
        },
        "Affordance": {
            "type": "object",
            "description": "Describes a capability or interaction mode for a node.\nUsed by AI systems to understand what actions are possible and by\ncharacter controllers for contextual animations.\n",
            "required": [
                "type"
            ],
            "properties": {
                "type": {
                    "$ref": "#/$defs/AffordanceType",
                    "description": "The type of affordance"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Type-specific parameters. Examples:\n- sittable: { height: 0.5, facing: [0,0,1] }\n- door: { openAngle: 90, locked: false }\n- container: { capacity: 10, itemTypes: [\"weapon\", \"consumable\"] }\n"
                }
            }
        },
        "AffordanceType": {
            "type": "string",
            "description": "Types of affordances describing what an object can do or how it can be interacted with.\nUsed by AI navigation, character controllers, and procedural content systems.\n",
            "enum": [
                "walkable",
                "climbable",
                "sittable",
                "interactive",
                "collectible",
                "destructible",
                "container",
                "door",
                "teleport"
            ]
        },
        "AssetSlot": {
            "type": "object",
            "description": "Defines acceptable asset types for procedural swapping at this node.\nUsed by procedural generation systems to substitute assets while\nmaintaining scene coherence.\n",
            "required": [
                "slotType"
            ],
            "properties": {
                "slotType": {
                    "type": "string",
                    "description": "Category of acceptable assets.\nExamples: chair, table, wall_art, floor_lamp\n"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags that acceptable assets must have.\nUsed for filtering when selecting random variations.\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset if no specific asset is bound"
                },
                "variations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetReference"
                    },
                    "description": "Pre-approved asset variations for random selection.\nProcedural systems pick from this list rather than searching all assets.\n"
                }
            }
        },
        "MarkerType": {
            "type": "string",
            "description": "Types of marker nodes for spawn points, waypoints, and other positional markers.",
            "enum": [
                "generic",
                "spawn_point",
                "npc_spawn",
                "waypoint",
                "camera_point",
                "light_point",
                "audio_point",
                "trigger_point"
            ]
        },
        "VolumeShape": {
            "type": "string",
            "description": "Shape of a volume node for spatial bounds",
            "enum": [
                "box",
                "sphere",
                "capsule",
                "cylinder"
            ]
        }
    }
}
""";

    private static readonly string _CommitScene_Info = """
{
    "summary": "Save changes and release lock",
    "description": "Commits the changes made during checkout, increments version,\nand releases the lock. Publishes scene.committed event.\n",
    "tags": [
        "Versioning"
    ],
    "deprecated": false,
    "operationId": "commitScene"
}
""";

    /// <summary>Returns endpoint information for CommitScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/commit/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CommitScene_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/commit",
            _CommitScene_Info));

    /// <summary>Returns request schema for CommitScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/commit/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CommitScene_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/commit",
            "request-schema",
            _CommitScene_RequestSchema));

    /// <summary>Returns response schema for CommitScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/commit/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CommitScene_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/commit",
            "response-schema",
            _CommitScene_ResponseSchema));

    /// <summary>Returns full schema for CommitScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/commit/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CommitScene_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/commit",
            _CommitScene_Info,
            _CommitScene_RequestSchema,
            _CommitScene_ResponseSchema));

    #endregion

    #region Meta Endpoints for DiscardCheckout

    private static readonly string _DiscardCheckout_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DiscardRequest",
    "$defs": {
        "DiscardRequest": {
            "type": "object",
            "description": "Request to discard checkout",
            "required": [
                "sceneId",
                "checkoutToken"
            ],
            "properties": {
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Scene to discard changes for"
                },
                "checkoutToken": {
                    "type": "string",
                    "description": "Checkout token"
                }
            }
        }
    }
}
""";

    private static readonly string _DiscardCheckout_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DiscardResponse",
    "$defs": {
        "DiscardResponse": {
            "type": "object",
            "description": "Response confirming discard",
            "required": [
                "discarded"
            ],
            "properties": {
                "discarded": {
                    "type": "boolean",
                    "description": "Whether discard was successful"
                }
            }
        }
    }
}
""";

    private static readonly string _DiscardCheckout_Info = """
{
    "summary": "Release lock without saving changes",
    "description": "Discards any changes and releases the checkout lock.\nScene remains at its pre-checkout version.\n",
    "tags": [
        "Versioning"
    ],
    "deprecated": false,
    "operationId": "discardCheckout"
}
""";

    /// <summary>Returns endpoint information for DiscardCheckout</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/discard/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DiscardCheckout_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/discard",
            _DiscardCheckout_Info));

    /// <summary>Returns request schema for DiscardCheckout</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/discard/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DiscardCheckout_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/discard",
            "request-schema",
            _DiscardCheckout_RequestSchema));

    /// <summary>Returns response schema for DiscardCheckout</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/discard/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DiscardCheckout_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/discard",
            "response-schema",
            _DiscardCheckout_ResponseSchema));

    /// <summary>Returns full schema for DiscardCheckout</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/discard/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DiscardCheckout_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/discard",
            _DiscardCheckout_Info,
            _DiscardCheckout_RequestSchema,
            _DiscardCheckout_ResponseSchema));

    #endregion

    #region Meta Endpoints for HeartbeatCheckout

    private static readonly string _HeartbeatCheckout_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/HeartbeatRequest",
    "$defs": {
        "HeartbeatRequest": {
            "type": "object",
            "description": "Request to extend checkout lock",
            "required": [
                "sceneId",
                "checkoutToken"
            ],
            "properties": {
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Scene being edited"
                },
                "checkoutToken": {
                    "type": "string",
                    "description": "Checkout token"
                }
            }
        }
    }
}
""";

    private static readonly string _HeartbeatCheckout_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/HeartbeatResponse",
    "$defs": {
        "HeartbeatResponse": {
            "type": "object",
            "description": "Response confirming lock extension",
            "required": [
                "extended",
                "newExpiresAt"
            ],
            "properties": {
                "extended": {
                    "type": "boolean",
                    "description": "Whether extension was successful"
                },
                "newExpiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "New expiration time"
                },
                "extensionsRemaining": {
                    "type": "integer",
                    "description": "Number of extensions remaining"
                }
            }
        }
    }
}
""";

    private static readonly string _HeartbeatCheckout_Info = """
{
    "summary": "Extend checkout lock TTL",
    "description": "Extends the checkout lock TTL. Should be called periodically\nduring editing to prevent lock expiration.\n",
    "tags": [
        "Versioning"
    ],
    "deprecated": false,
    "operationId": "heartbeatCheckout"
}
""";

    /// <summary>Returns endpoint information for HeartbeatCheckout</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/heartbeat/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> HeartbeatCheckout_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/heartbeat",
            _HeartbeatCheckout_Info));

    /// <summary>Returns request schema for HeartbeatCheckout</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/heartbeat/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> HeartbeatCheckout_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/heartbeat",
            "request-schema",
            _HeartbeatCheckout_RequestSchema));

    /// <summary>Returns response schema for HeartbeatCheckout</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/heartbeat/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> HeartbeatCheckout_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/heartbeat",
            "response-schema",
            _HeartbeatCheckout_ResponseSchema));

    /// <summary>Returns full schema for HeartbeatCheckout</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/heartbeat/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> HeartbeatCheckout_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/heartbeat",
            _HeartbeatCheckout_Info,
            _HeartbeatCheckout_RequestSchema,
            _HeartbeatCheckout_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetSceneHistory

    private static readonly string _GetSceneHistory_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/HistoryRequest",
    "$defs": {
        "HistoryRequest": {
            "type": "object",
            "description": "Request for scene version history",
            "required": [
                "sceneId"
            ],
            "properties": {
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Scene to get history for"
                },
                "limit": {
                    "type": "integer",
                    "default": 10,
                    "description": "Maximum versions to return"
                }
            }
        }
    }
}
""";

    private static readonly string _GetSceneHistory_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/HistoryResponse",
    "$defs": {
        "HistoryResponse": {
            "type": "object",
            "description": "Scene version history",
            "required": [
                "sceneId",
                "versions"
            ],
            "properties": {
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Scene ID"
                },
                "currentVersion": {
                    "type": "string",
                    "description": "Current active version"
                },
                "versions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/VersionInfo"
                    },
                    "description": "Version history entries"
                }
            }
        },
        "VersionInfo": {
            "type": "object",
            "description": "Information about a specific version",
            "required": [
                "version",
                "createdAt"
            ],
            "properties": {
                "version": {
                    "type": "string",
                    "description": "Version string"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When this version was created"
                },
                "createdBy": {
                    "type": "string",
                    "nullable": true,
                    "description": "Who created this version"
                },
                "changesSummary": {
                    "type": "string",
                    "nullable": true,
                    "description": "Summary of changes"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Node count at this version"
                }
            }
        }
    }
}
""";

    private static readonly string _GetSceneHistory_Info = """
{
    "summary": "Get version history for a scene",
    "description": "Returns the version history for a scene, up to the configured\nretention limit per gameId.\n",
    "tags": [
        "Versioning"
    ],
    "deprecated": false,
    "operationId": "getSceneHistory"
}
""";

    /// <summary>Returns endpoint information for GetSceneHistory</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/history/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSceneHistory_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/history",
            _GetSceneHistory_Info));

    /// <summary>Returns request schema for GetSceneHistory</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/history/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSceneHistory_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/history",
            "request-schema",
            _GetSceneHistory_RequestSchema));

    /// <summary>Returns response schema for GetSceneHistory</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/history/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSceneHistory_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/history",
            "response-schema",
            _GetSceneHistory_ResponseSchema));

    /// <summary>Returns full schema for GetSceneHistory</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/history/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetSceneHistory_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/history",
            _GetSceneHistory_Info,
            _GetSceneHistory_RequestSchema,
            _GetSceneHistory_ResponseSchema));

    #endregion

    #region Meta Endpoints for RegisterValidationRules

    private static readonly string _RegisterValidationRules_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RegisterValidationRulesRequest",
    "$defs": {
        "RegisterValidationRulesRequest": {
            "type": "object",
            "description": "Request to register validation rules",
            "required": [
                "gameId",
                "sceneType",
                "rules"
            ],
            "properties": {
                "gameId": {
                    "type": "string",
                    "description": "Game ID for these rules"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene type for these rules"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ValidationRule"
                    },
                    "description": "Validation rules to register"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        },
        "ValidationRule": {
            "type": "object",
            "description": "A validation rule definition",
            "required": [
                "ruleId",
                "description",
                "severity",
                "ruleType"
            ],
            "properties": {
                "ruleId": {
                    "type": "string",
                    "description": "Unique rule identifier within the gameId+sceneType"
                },
                "description": {
                    "type": "string",
                    "description": "Human-readable description of the rule"
                },
                "severity": {
                    "$ref": "#/$defs/ValidationSeverity",
                    "description": "Whether violation is an error or warning"
                },
                "ruleType": {
                    "$ref": "#/$defs/ValidationRuleType",
                    "description": "Type of validation check"
                },
                "config": {
                    "$ref": "#/$defs/ValidationRuleConfig",
                    "nullable": true,
                    "description": "Rule-specific configuration"
                }
            }
        },
        "ValidationSeverity": {
            "type": "string",
            "description": "Severity level of a validation issue",
            "enum": [
                "error",
                "warning"
            ]
        },
        "ValidationRuleType": {
            "type": "string",
            "description": "Type of validation check to perform",
            "enum": [
                "require_tag",
                "require_node_type",
                "forbid_tag",
                "require_annotation",
                "custom_expression"
            ]
        },
        "ValidationRuleConfig": {
            "type": "object",
            "description": "Configuration for a validation rule",
            "properties": {
                "nodeType": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter to nodes of this type (for require_tag)"
                },
                "tag": {
                    "type": "string",
                    "nullable": true,
                    "description": "Tag to check for"
                },
                "minCount": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Minimum occurrences required"
                },
                "maxCount": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum occurrences allowed"
                },
                "annotationPath": {
                    "type": "string",
                    "nullable": true,
                    "description": "JSONPath to required annotation field (for require_annotation)"
                },
                "expression": {
                    "type": "string",
                    "nullable": true,
                    "description": "Custom validation expression (for custom_expression)"
                }
            }
        }
    }
}
""";

    private static readonly string _RegisterValidationRules_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RegisterValidationRulesResponse",
    "$defs": {
        "RegisterValidationRulesResponse": {
            "type": "object",
            "description": "Response confirming rule registration",
            "required": [
                "registered",
                "ruleCount"
            ],
            "properties": {
                "registered": {
                    "type": "boolean",
                    "description": "Whether registration was successful"
                },
                "ruleCount": {
                    "type": "integer",
                    "description": "Number of rules registered"
                }
            }
        }
    }
}
""";

    private static readonly string _RegisterValidationRules_Info = """
{
    "summary": "Register validation rules for a gameId+sceneType",
    "description": "Registers game-specific validation rules. Replaces any existing\nrules for the gameId+sceneType combination.\n",
    "tags": [
        "Validation"
    ],
    "deprecated": false,
    "operationId": "registerValidationRules"
}
""";

    /// <summary>Returns endpoint information for RegisterValidationRules</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/register-validation-rules/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RegisterValidationRules_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/register-validation-rules",
            _RegisterValidationRules_Info));

    /// <summary>Returns request schema for RegisterValidationRules</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/register-validation-rules/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RegisterValidationRules_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/register-validation-rules",
            "request-schema",
            _RegisterValidationRules_RequestSchema));

    /// <summary>Returns response schema for RegisterValidationRules</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/register-validation-rules/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RegisterValidationRules_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/register-validation-rules",
            "response-schema",
            _RegisterValidationRules_ResponseSchema));

    /// <summary>Returns full schema for RegisterValidationRules</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/register-validation-rules/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RegisterValidationRules_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/register-validation-rules",
            _RegisterValidationRules_Info,
            _RegisterValidationRules_RequestSchema,
            _RegisterValidationRules_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetValidationRules

    private static readonly string _GetValidationRules_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetValidationRulesRequest",
    "$defs": {
        "GetValidationRulesRequest": {
            "type": "object",
            "description": "Request to get validation rules",
            "required": [
                "gameId",
                "sceneType"
            ],
            "properties": {
                "gameId": {
                    "type": "string",
                    "description": "Game ID"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene type"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        }
    }
}
""";

    private static readonly string _GetValidationRules_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetValidationRulesResponse",
    "$defs": {
        "GetValidationRulesResponse": {
            "type": "object",
            "description": "Response containing validation rules",
            "required": [
                "gameId",
                "sceneType"
            ],
            "properties": {
                "gameId": {
                    "type": "string",
                    "description": "Game ID"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene type"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ValidationRule"
                    },
                    "description": "Registered rules (empty if none)"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        },
        "ValidationRule": {
            "type": "object",
            "description": "A validation rule definition",
            "required": [
                "ruleId",
                "description",
                "severity",
                "ruleType"
            ],
            "properties": {
                "ruleId": {
                    "type": "string",
                    "description": "Unique rule identifier within the gameId+sceneType"
                },
                "description": {
                    "type": "string",
                    "description": "Human-readable description of the rule"
                },
                "severity": {
                    "$ref": "#/$defs/ValidationSeverity",
                    "description": "Whether violation is an error or warning"
                },
                "ruleType": {
                    "$ref": "#/$defs/ValidationRuleType",
                    "description": "Type of validation check"
                },
                "config": {
                    "$ref": "#/$defs/ValidationRuleConfig",
                    "nullable": true,
                    "description": "Rule-specific configuration"
                }
            }
        },
        "ValidationSeverity": {
            "type": "string",
            "description": "Severity level of a validation issue",
            "enum": [
                "error",
                "warning"
            ]
        },
        "ValidationRuleType": {
            "type": "string",
            "description": "Type of validation check to perform",
            "enum": [
                "require_tag",
                "require_node_type",
                "forbid_tag",
                "require_annotation",
                "custom_expression"
            ]
        },
        "ValidationRuleConfig": {
            "type": "object",
            "description": "Configuration for a validation rule",
            "properties": {
                "nodeType": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter to nodes of this type (for require_tag)"
                },
                "tag": {
                    "type": "string",
                    "nullable": true,
                    "description": "Tag to check for"
                },
                "minCount": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Minimum occurrences required"
                },
                "maxCount": {
                    "type": "integer",
                    "nullable": true,
                    "description": "Maximum occurrences allowed"
                },
                "annotationPath": {
                    "type": "string",
                    "nullable": true,
                    "description": "JSONPath to required annotation field (for require_annotation)"
                },
                "expression": {
                    "type": "string",
                    "nullable": true,
                    "description": "Custom validation expression (for custom_expression)"
                }
            }
        }
    }
}
""";

    private static readonly string _GetValidationRules_Info = """
{
    "summary": "Get validation rules for a gameId+sceneType",
    "description": "Retrieves the registered validation rules for a specific\ngameId and sceneType combination.\n",
    "tags": [
        "Validation"
    ],
    "deprecated": false,
    "operationId": "getValidationRules"
}
""";

    /// <summary>Returns endpoint information for GetValidationRules</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/get-validation-rules/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetValidationRules_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/get-validation-rules",
            _GetValidationRules_Info));

    /// <summary>Returns request schema for GetValidationRules</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/get-validation-rules/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetValidationRules_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/get-validation-rules",
            "request-schema",
            _GetValidationRules_RequestSchema));

    /// <summary>Returns response schema for GetValidationRules</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/get-validation-rules/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetValidationRules_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/get-validation-rules",
            "response-schema",
            _GetValidationRules_ResponseSchema));

    /// <summary>Returns full schema for GetValidationRules</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/get-validation-rules/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetValidationRules_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/get-validation-rules",
            _GetValidationRules_Info,
            _GetValidationRules_RequestSchema,
            _GetValidationRules_ResponseSchema));

    #endregion

    #region Meta Endpoints for SearchScenes

    private static readonly string _SearchScenes_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/SearchScenesRequest",
    "$defs": {
        "SearchScenesRequest": {
            "type": "object",
            "description": "Request for full-text search",
            "required": [
                "query"
            ],
            "properties": {
                "query": {
                    "type": "string",
                    "description": "Search query text"
                },
                "gameId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Filter by game ID"
                },
                "sceneTypes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SceneType"
                    },
                    "nullable": true,
                    "description": "Filter by scene types"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Pagination offset"
                },
                "limit": {
                    "type": "integer",
                    "default": 50,
                    "description": "Maximum results"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        }
    }
}
""";

    private static readonly string _SearchScenes_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/SearchScenesResponse",
    "$defs": {
        "SearchScenesResponse": {
            "type": "object",
            "description": "Search results",
            "required": [
                "results",
                "total"
            ],
            "properties": {
                "results": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SearchResult"
                    },
                    "description": "Matching scenes"
                },
                "total": {
                    "type": "integer",
                    "description": "Total matches"
                }
            }
        },
        "SearchResult": {
            "type": "object",
            "description": "A single search result",
            "required": [
                "scene",
                "matchType"
            ],
            "properties": {
                "scene": {
                    "$ref": "#/$defs/SceneSummary",
                    "description": "Matching scene summary"
                },
                "matchType": {
                    "$ref": "#/$defs/SearchMatchType",
                    "description": "Where the match was found"
                },
                "matchContext": {
                    "type": "string",
                    "nullable": true,
                    "description": "Context around the match"
                }
            }
        },
        "SceneSummary": {
            "type": "object",
            "description": "Summary of a scene for list results (excludes full node tree)",
            "required": [
                "sceneId",
                "gameId",
                "sceneType",
                "name",
                "version"
            ],
            "properties": {
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique scene identifier"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game service identifier"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene classification"
                },
                "name": {
                    "type": "string",
                    "description": "Scene name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Scene description"
                },
                "version": {
                    "type": "string",
                    "description": "Current version"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Scene tags"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Total number of nodes in scene"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Creation timestamp"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Last update timestamp"
                },
                "isCheckedOut": {
                    "type": "boolean",
                    "description": "Whether scene is currently checked out"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        },
        "SearchMatchType": {
            "type": "string",
            "description": "Where the search match was found",
            "enum": [
                "name",
                "description",
                "tag",
                "node_name"
            ]
        }
    }
}
""";

    private static readonly string _SearchScenes_Info = """
{
    "summary": "Full-text search across scenes",
    "description": "Searches scene names, descriptions, tags, and node names\nfor matching content.\n",
    "tags": [
        "Query"
    ],
    "deprecated": false,
    "operationId": "searchScenes"
}
""";

    /// <summary>Returns endpoint information for SearchScenes</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/search/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchScenes_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/search",
            _SearchScenes_Info));

    /// <summary>Returns request schema for SearchScenes</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/search/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchScenes_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/search",
            "request-schema",
            _SearchScenes_RequestSchema));

    /// <summary>Returns response schema for SearchScenes</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/search/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchScenes_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/search",
            "response-schema",
            _SearchScenes_ResponseSchema));

    /// <summary>Returns full schema for SearchScenes</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/search/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchScenes_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/search",
            _SearchScenes_Info,
            _SearchScenes_RequestSchema,
            _SearchScenes_ResponseSchema));

    #endregion

    #region Meta Endpoints for FindReferences

    private static readonly string _FindReferences_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/FindReferencesRequest",
    "$defs": {
        "FindReferencesRequest": {
            "type": "object",
            "description": "Request to find referencing scenes",
            "required": [
                "sceneId"
            ],
            "properties": {
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Scene ID to find references to"
                }
            }
        }
    }
}
""";

    private static readonly string _FindReferences_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/FindReferencesResponse",
    "$defs": {
        "FindReferencesResponse": {
            "type": "object",
            "description": "Scenes that reference the target",
            "required": [
                "referencingScenes"
            ],
            "properties": {
                "referencingScenes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ReferenceInfo"
                    },
                    "description": "Scenes containing references"
                }
            }
        },
        "ReferenceInfo": {
            "type": "object",
            "description": "Information about a reference",
            "required": [
                "sceneId",
                "sceneName",
                "nodeId",
                "nodeRefId"
            ],
            "properties": {
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Scene containing the reference"
                },
                "sceneName": {
                    "type": "string",
                    "description": "Name of the referencing scene"
                },
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Node containing the reference"
                },
                "nodeRefId": {
                    "type": "string",
                    "description": "refId of the referencing node"
                },
                "nodeName": {
                    "type": "string",
                    "description": "Name of the referencing node"
                }
            }
        }
    }
}
""";

    private static readonly string _FindReferences_Info = """
{
    "summary": "Find scenes that reference a given scene",
    "description": "Returns all scenes that contain reference nodes pointing\nto the specified scene.\n",
    "tags": [
        "Query"
    ],
    "deprecated": false,
    "operationId": "findReferences"
}
""";

    /// <summary>Returns endpoint information for FindReferences</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/find-references/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> FindReferences_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/find-references",
            _FindReferences_Info));

    /// <summary>Returns request schema for FindReferences</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/find-references/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> FindReferences_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/find-references",
            "request-schema",
            _FindReferences_RequestSchema));

    /// <summary>Returns response schema for FindReferences</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/find-references/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> FindReferences_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/find-references",
            "response-schema",
            _FindReferences_ResponseSchema));

    /// <summary>Returns full schema for FindReferences</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/find-references/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> FindReferences_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/find-references",
            _FindReferences_Info,
            _FindReferences_RequestSchema,
            _FindReferences_ResponseSchema));

    #endregion

    #region Meta Endpoints for FindAssetUsage

    private static readonly string _FindAssetUsage_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/FindAssetUsageRequest",
    "$defs": {
        "FindAssetUsageRequest": {
            "type": "object",
            "description": "Request to find asset usage",
            "required": [
                "assetId"
            ],
            "properties": {
                "assetId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Asset ID to find usage of"
                },
                "gameId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional game filter"
                }
            }
        }
    }
}
""";

    private static readonly string _FindAssetUsage_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/FindAssetUsageResponse",
    "$defs": {
        "FindAssetUsageResponse": {
            "type": "object",
            "description": "Scenes using the asset",
            "required": [
                "usages"
            ],
            "properties": {
                "usages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetUsageInfo"
                    },
                    "description": "Asset usage instances"
                }
            }
        },
        "AssetUsageInfo": {
            "type": "object",
            "description": "Information about asset usage",
            "required": [
                "sceneId",
                "sceneName",
                "nodeId",
                "nodeRefId"
            ],
            "properties": {
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Scene using the asset"
                },
                "sceneName": {
                    "type": "string",
                    "description": "Scene name"
                },
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Node using the asset"
                },
                "nodeRefId": {
                    "type": "string",
                    "description": "refId of the node"
                },
                "nodeName": {
                    "type": "string",
                    "description": "Node name"
                },
                "nodeType": {
                    "$ref": "#/$defs/NodeType",
                    "description": "Type of the node"
                }
            }
        },
        "NodeType": {
            "type": "string",
            "description": "Structural node type. Indicates what kind of data the node contains,\nnot how it will be used at runtime. Consumers interpret nodes according\nto their own needs via tags and annotations.\n",
            "enum": [
                "group",
                "mesh",
                "marker",
                "volume",
                "emitter",
                "reference",
                "custom"
            ]
        }
    }
}
""";

    private static readonly string _FindAssetUsage_Info = """
{
    "summary": "Find scenes using a specific asset",
    "description": "Returns all scenes containing nodes that reference\na specific asset ID.\n",
    "tags": [
        "Query"
    ],
    "deprecated": false,
    "operationId": "findAssetUsage"
}
""";

    /// <summary>Returns endpoint information for FindAssetUsage</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/find-asset-usage/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> FindAssetUsage_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/find-asset-usage",
            _FindAssetUsage_Info));

    /// <summary>Returns request schema for FindAssetUsage</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/find-asset-usage/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> FindAssetUsage_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/find-asset-usage",
            "request-schema",
            _FindAssetUsage_RequestSchema));

    /// <summary>Returns response schema for FindAssetUsage</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/find-asset-usage/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> FindAssetUsage_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/find-asset-usage",
            "response-schema",
            _FindAssetUsage_ResponseSchema));

    /// <summary>Returns full schema for FindAssetUsage</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/find-asset-usage/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> FindAssetUsage_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/find-asset-usage",
            _FindAssetUsage_Info,
            _FindAssetUsage_RequestSchema,
            _FindAssetUsage_ResponseSchema));

    #endregion

    #region Meta Endpoints for DuplicateScene

    private static readonly string _DuplicateScene_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DuplicateSceneRequest",
    "$defs": {
        "DuplicateSceneRequest": {
            "type": "object",
            "description": "Request to duplicate a scene",
            "required": [
                "sourceSceneId",
                "newName"
            ],
            "properties": {
                "sourceSceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Scene to duplicate"
                },
                "newName": {
                    "type": "string",
                    "description": "Name for the duplicate"
                },
                "newGameId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional different game ID"
                },
                "newSceneType": {
                    "$ref": "#/$defs/SceneType",
                    "nullable": true,
                    "description": "Optional different scene type"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        }
    }
}
""";

    private static readonly string _DuplicateScene_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/SceneResponse",
    "$defs": {
        "SceneResponse": {
            "type": "object",
            "description": "Standard response containing a scene",
            "required": [
                "scene"
            ],
            "properties": {
                "scene": {
                    "$ref": "#/$defs/Scene",
                    "description": "The scene document"
                }
            }
        },
        "Scene": {
            "type": "object",
            "description": "A complete scene document with hierarchical node structure",
            "required": [
                "sceneId",
                "gameId",
                "sceneType",
                "name",
                "version",
                "root"
            ],
            "properties": {
                "schema": {
                    "type": "string",
                    "description": "Schema identifier for validation",
                    "default": "bannou://schemas/scene/v1"
                },
                "sceneId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique scene identifier"
                },
                "gameId": {
                    "type": "string",
                    "description": "Game service identifier for partitioning. Treated as opaque string.\nDefault is the nil UUID for unpartitioned scenes.\n",
                    "default": "00000000-0000-0000-0000-000000000000"
                },
                "sceneType": {
                    "$ref": "#/$defs/SceneType",
                    "description": "Scene classification for querying and validation"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable scene name"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Optional scene description"
                },
                "version": {
                    "type": "string",
                    "pattern": "^\\d+\\.\\d+\\.\\d+$",
                    "description": "Semantic version (MAJOR.MINOR.PATCH)"
                },
                "root": {
                    "$ref": "#/$defs/SceneNode",
                    "description": "Root node of the scene hierarchy"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Searchable tags for filtering scenes"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Scene-level metadata. Not interpreted by Scene service.\nExamples: author, thumbnail, editor preferences, generator config.\n"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the scene was last modified"
                }
            }
        },
        "SceneType": {
            "type": "string",
            "description": "Scene classification for querying and validation rule lookup.\nDifferent types may have different validation requirements per game.\n",
            "enum": [
                "unknown",
                "region",
                "city",
                "district",
                "lot",
                "building",
                "room",
                "dungeon",
                "arena",
                "vehicle",
                "prefab",
                "cutscene",
                "other"
            ]
        },
        "SceneNode": {
            "type": "object",
            "description": "A node in the scene hierarchy. Nodes can contain children to form\na tree structure. Each node has a local transform relative to its parent.\n",
            "required": [
                "nodeId",
                "refId",
                "name",
                "nodeType",
                "localTransform"
            ],
            "properties": {
                "nodeId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Globally unique node identifier"
                },
                "refId": {
                    "type": "string",
                    "pattern": "^[a-z][a-z0-9_]*$",
                    "description": "Scene-local reference identifier. Must be unique within the scene.\nUsed for scripting and cross-referencing. Examples: main_door, npc_spawn_1\n"
                },
                "parentNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Parent node ID. Null for the root node only."
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable display name for the node"
                },
                "nodeType": {
                    "$ref": "#/$defs/NodeType",
                    "description": "The structural type of this node"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Transform relative to parent node"
                },
                "asset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Optional asset binding (mesh, sound, particle effect)"
                },
                "children": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SceneNode"
                    },
                    "description": "Child nodes in the hierarchy"
                },
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether this node is active in the scene definition"
                },
                "sortOrder": {
                    "type": "integer",
                    "default": 0,
                    "description": "Ordering among siblings for deterministic iteration"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive)"
                },
                "annotations": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Consumer-specific data stored without interpretation.\nUse namespaced keys (e.g., render.castShadows, arcadia.interactionType).\n"
                },
                "attachmentPoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AttachmentPoint"
                    },
                    "description": "Predefined locations for attaching child objects.\ nUsed by Scene Composer for furniture decoration, wall accessories, etc.\n"
                },
                "affordances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/Affordance"
                    },
                    "description": "Interaction capabilities of this node.\nUsed by AI navigation and character controllers.\n"
                },
                "assetSlot": {
                    "$ref": "#/$defs/AssetSlot",
                    "nullable": true,
                    "description": "Procedural asset swapping configuration.\nDefines which assets can substitute for this node's asset.\n"
                },
                "markerType": {
                    "$ref": "#/$defs/MarkerType",
                    "nullable": true,
                    "description": "Type of marker for marker nodes.\nOnly relevant when nodeType is 'marker'.\n"
                },
                "volumeShape": {
                    "$ref": "#/$defs/VolumeShape",
                    "nullable": true,
                    "description": "Shape of volume for volume nodes.\nOnly relevant when nodeType is 'volume'.\n"
                },
                "volumeSize": {
                    "$ref": "#/$defs/Vector3",
                    "nullable": true,
                    "description": "Size/extents of the volume (interpretation depends on volumeShape).\nFor box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.\n"
                },
                "referenceSceneId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Scene ID to embed for reference nodes.\nOnly relevant when nodeType is 'reference'.\n"
                }
            }
        },
        "NodeType": {
            "type": "string",
            "description": "Structural node type. Indicates what kind of data the node contains,\nnot how it will be used at runtime. Consumers interpret nodes according\nto their own needs via tags and annotations.\n",
            "enum": [
                "group",
                "mesh",
                "marker",
                "volume",
                "emitter",
                "reference",
                "custom"
            ]
        },
        "Transform": {
            "type": "object",
            "description": "Position, rotation, and scale in 3D space",
            "required": [
                "position",
                "rotation",
                "scale"
            ],
            "properties": {
                "position": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Position relative to parent"
                },
                "rotation": {
                    "$ref": "#/$defs/Quaternion",
                    "description": "Rotation relative to parent"
                },
                "scale": {
                    "$ref": "#/$defs/Vector3",
                    "description": "Scale relative to parent"
                }
            }
        },
        "Vector3": {
            "type": "object",
            "description": "A point or direction in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate"
                }
            }
        },
        "Quaternion": {
            "type": "object",
            "description": "Rotation represented as a quaternion",
            "required": [
                "x",
                "y",
                "z",
                "w"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X component"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y component"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z component"
                },
                "w": {
                    "type": "number",
                    "format": "double",
                    "description": "W component (scalar)"
                }
            }
        },
        "AssetReference": {
            "type": "object",
            "description": "Reference to an asset in lib-asset",
            "required": [
                "assetId"
            ],
            "properties": {
                "bundleId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Optional bundle containing the asset"
                },
                "assetId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Asset identifier in lib-asset"
                },
                "variantId": {
                    "type": "string",
                    "nullable": true,
                    "description": "Variant identifier (consumer interprets meaning)"
                }
            }
        },
        "AttachmentPoint": {
            "type": "object",
            "description": "A predefined location where child objects can be attached.\nUsed for decorating furniture, walls, and other objects with accessories.\nExample: A wall may have attachment points for paintings, shelves, or light fixtures.\n",
            "required": [
                "name",
                "localTransform"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Unique name for this attachment point within the node.\nExamples: wall_hook_left, shelf_1, lamp_socket\n"
                },
                "localTransform": {
                    "$ref": "#/$defs/Transform",
                    "description": "Position and orientation relative to the owning node"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags of assets that can attach here.\nExamples: wall_decoration, picture_frame, plant\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset to display if no specific attachment is specified"
                },
                "attachedNodeId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "ID of the node currently attached at this point (runtime state)"
                }
            }
        },
        "Affordance": {
            "type": "object",
            "description": "Describes a capability or interaction mode for a node.\nUsed by AI systems to understand what actions are possible and by\ncharacter controllers for contextual animations.\n",
            "required": [
                "type"
            ],
            "properties": {
                "type": {
                    "$ref": "#/$defs/AffordanceType",
                    "description": "The type of affordance"
                },
                "parameters": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Type-specific parameters. Examples:\n- sittable: { height: 0.5, facing: [0,0,1] }\n- door: { openAngle: 90, locked: false }\n- container: { capacity: 10, itemTypes: [\"weapon\", \"consumable\"] }\n"
                }
            }
        },
        "AffordanceType": {
            "type": "string",
            "description": "Types of affordances describing what an object can do or how it can be interacted with.\nUsed by AI navigation, character controllers, and procedural content systems.\n",
            "enum": [
                "walkable",
                "climbable",
                "sittable",
                "interactive",
                "collectible",
                "destructible",
                "container",
                "door",
                "teleport"
            ]
        },
        "AssetSlot": {
            "type": "object",
            "description": "Defines acceptable asset types for procedural swapping at this node.\nUsed by procedural generation systems to substitute assets while\nmaintaining scene coherence.\n",
            "required": [
                "slotType"
            ],
            "properties": {
                "slotType": {
                    "type": "string",
                    "description": "Category of acceptable assets.\nExamples: chair, table, wall_art, floor_lamp\n"
                },
                "acceptsTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags that acceptable assets must have.\nUsed for filtering when selecting random variations.\n"
                },
                "defaultAsset": {
                    "$ref": "#/$defs/AssetReference",
                    "nullable": true,
                    "description": "Default asset if no specific asset is bound"
                },
                "variations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AssetReference"
                    },
                    "description": "Pre-approved asset variations for random selection.\nProcedural systems pick from this list rather than searching all assets.\n"
                }
            }
        },
        "MarkerType": {
            "type": "string",
            "description": "Types of marker nodes for spawn points, waypoints, and other positional markers.",
            "enum": [
                "generic",
                "spawn_point",
                "npc_spawn",
                "waypoint",
                "camera_point",
                "light_point",
                "audio_point",
                "trigger_point"
            ]
        },
        "VolumeShape": {
            "type": "string",
            "description": "Shape of a volume node for spatial bounds",
            "enum": [
                "box",
                "sphere",
                "capsule",
                "cylinder"
            ]
        }
    }
}
""";

    private static readonly string _DuplicateScene_Info = """
{
    "summary": "Duplicate a scene with a new ID",
    "description": "Creates a copy of a scene with a new sceneId and name.\nAll node IDs are regenerated. Version resets to 1.0.0.\n",
    "tags": [
        "Scene"
    ],
    "deprecated": false,
    "operationId": "duplicateScene"
}
""";

    /// <summary>Returns endpoint information for DuplicateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/duplicate/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DuplicateScene_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Scene",
            "POST",
            "/scene/duplicate",
            _DuplicateScene_Info));

    /// <summary>Returns request schema for DuplicateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/duplicate/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DuplicateScene_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/duplicate",
            "request-schema",
            _DuplicateScene_RequestSchema));

    /// <summary>Returns response schema for DuplicateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/duplicate/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DuplicateScene_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Scene",
            "POST",
            "/scene/duplicate",
            "response-schema",
            _DuplicateScene_ResponseSchema));

    /// <summary>Returns full schema for DuplicateScene</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("/scene/duplicate/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DuplicateScene_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Scene",
            "POST",
            "/scene/duplicate",
            _DuplicateScene_Info,
            _DuplicateScene_RequestSchema,
            _DuplicateScene_ResponseSchema));

    #endregion
}
