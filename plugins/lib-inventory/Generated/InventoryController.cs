//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     RELATED FILES:
//     - Request/Response models: bannou-service/Generated/Models/{Service}Models.cs
//     - Event models: bannou-service/Generated/Events/{Service}EventsModels.cs
//     - Lifecycle events: bannou-service/Generated/Events/{Service}LifecycleEvents.cs
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Inventory;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IInventoryController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Create a new container
    /// </summary>

    /// <remarks>
    /// Creates a new container with the specified constraint model and capacity.
    /// <br/>Container types are game-defined strings (e.g., "inventory", "bank", "equipment_slot").
    /// </remarks>

    /// <returns>Container created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerResponse>> CreateContainerAsync(CreateContainerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get container with contents
    /// </summary>

    /// <remarks>
    /// Retrieves a container by ID, optionally including its contents.
    /// </remarks>

    /// <returns>Container retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerWithContentsResponse>> GetContainerAsync(GetContainerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get container or create if not exists
    /// </summary>

    /// <remarks>
    /// Enables lazy container creation for character inventories.
    /// <br/>If a container doesn't exist for the owner/type combination, creates it
    /// <br/>with the specified defaults.
    /// </remarks>

    /// <returns>Container retrieved or created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerResponse>> GetOrCreateContainerAsync(GetOrCreateContainerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List containers for owner
    /// </summary>

    /// <remarks>
    /// Returns all containers owned by the specified entity.
    /// </remarks>

    /// <returns>Containers retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListContainersResponse>> ListContainersAsync(ListContainersRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update container properties
    /// </summary>

    /// <remarks>
    /// Updates mutable container properties like capacity limits and filtering.
    /// </remarks>

    /// <returns>Container updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerResponse>> UpdateContainerAsync(UpdateContainerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete container
    /// </summary>

    /// <remarks>
    /// Deletes a container. Must specify how to handle existing contents:
    /// <br/>destroy, transfer to another container, or error if not empty.
    /// </remarks>

    /// <returns>Container deleted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteContainerResponse>> DeleteContainerAsync(DeleteContainerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Add item to container
    /// </summary>

    /// <remarks>
    /// Adds an item instance to a container. Validates container constraints
    /// <br/>(slots, weight, grid, category filters). For stackable items, may
    /// <br/>merge with existing stacks.
    /// </remarks>

    /// <returns>Item added successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AddItemResponse>> AddItemToContainerAsync(AddItemRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Remove item from container
    /// </summary>

    /// <remarks>
    /// Removes an item from its container. The item still exists but has no
    /// <br/>container assignment. Use destroy via lib-item to permanently delete.
    /// </remarks>

    /// <returns>Item removed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RemoveItemResponse>> RemoveItemFromContainerAsync(RemoveItemRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Move item to different slot or container
    /// </summary>

    /// <remarks>
    /// Moves an item within the same container (slot change) or to a different
    /// <br/>container. Validates destination constraints. For equipment slots, this
    /// <br/>effectively equips/unequips items.
    /// </remarks>

    /// <returns>Item moved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MoveItemResponse>> MoveItemAsync(MoveItemRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Transfer item to different owner
    /// </summary>

    /// <remarks>
    /// Transfers an item to a container owned by a different entity.
    /// <br/>Used for trades, gifts, and loot distribution.
    /// </remarks>

    /// <returns>Item transferred successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TransferItemResponse>> TransferItemAsync(TransferItemRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Split stack into two
    /// </summary>

    /// <remarks>
    /// Splits a stack of items into two stacks. The original stack keeps the
    /// <br/>remainder, and a new stack is created with the split quantity.
    /// </remarks>

    /// <returns>Stack split successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SplitStackResponse>> SplitStackAsync(SplitStackRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Merge two stacks
    /// </summary>

    /// <remarks>
    /// Merges two stacks of the same item template. The source stack is
    /// <br/>destroyed and its quantity added to the target stack.
    /// </remarks>

    /// <returns>Stacks merged successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MergeStacksResponse>> MergeStacksAsync(MergeStacksRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Find items across containers
    /// </summary>

    /// <remarks>
    /// Searches for items across all containers owned by an entity.
    /// <br/>Can filter by template, category, tags, and other criteria.
    /// </remarks>

    /// <returns>Items found</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryItemsResponse>> QueryItemsAsync(QueryItemsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Count items of a template
    /// </summary>

    /// <remarks>
    /// Counts total quantity of a specific item template across containers.
    /// </remarks>

    /// <returns>Count completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CountItemsResponse>> CountItemsAsync(CountItemsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Check if entity has required items
    /// </summary>

    /// <remarks>
    /// Checks if an entity has the required quantities of specified items.
    /// <br/>Used for crafting and quest requirements validation.
    /// </remarks>

    /// <returns>Check completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<HasItemsResponse>> HasItemsAsync(HasItemsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Find where item would fit
    /// </summary>

    /// <remarks>
    /// Finds available space for an item in the owner's containers.
    /// <br/>Returns candidate containers and slots where the item could be placed.
    /// </remarks>

    /// <returns>Space search completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FindSpaceResponse>> FindSpaceAsync(FindSpaceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class InventoryController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IInventoryService _implementation;
    private BeyondImmersion.BannouService.Services.ITelemetryProvider _telemetryProvider;

    public InventoryController(IInventoryService implementation, BeyondImmersion.BannouService.Services.ITelemetryProvider telemetryProvider)
    {
        _implementation = implementation;
        _telemetryProvider = telemetryProvider;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Create a new container
    /// </summary>
    /// <remarks>
    /// Creates a new container with the specified constraint model and capacity.
    /// <br/>Container types are game-defined strings (e.g., "inventory", "bank", "equipment_slot").
    /// </remarks>
    /// <returns>Container created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/container/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerResponse>> CreateContainer([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateContainerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.CreateContainer",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/container/create");
        try
        {

            var (statusCode, result) = await _implementation.CreateContainerAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/container/create");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/container/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "CreateContainer",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/container/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get container with contents
    /// </summary>
    /// <remarks>
    /// Retrieves a container by ID, optionally including its contents.
    /// </remarks>
    /// <returns>Container retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/container/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerWithContentsResponse>> GetContainer([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetContainerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.GetContainer",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/container/get");
        try
        {

            var (statusCode, result) = await _implementation.GetContainerAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/container/get");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/container/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "GetContainer",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/container/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get container or create if not exists
    /// </summary>
    /// <remarks>
    /// Enables lazy container creation for character inventories.
    /// <br/>If a container doesn't exist for the owner/type combination, creates it
    /// <br/>with the specified defaults.
    /// </remarks>
    /// <returns>Container retrieved or created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/container/get-or-create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerResponse>> GetOrCreateContainer([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetOrCreateContainerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.GetOrCreateContainer",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/container/get-or-create");
        try
        {

            var (statusCode, result) = await _implementation.GetOrCreateContainerAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/container/get-or-create");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/container/get-or-create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "GetOrCreateContainer",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/container/get-or-create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List containers for owner
    /// </summary>
    /// <remarks>
    /// Returns all containers owned by the specified entity.
    /// </remarks>
    /// <returns>Containers retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/container/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListContainersResponse>> ListContainers([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListContainersRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.ListContainers",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/container/list");
        try
        {

            var (statusCode, result) = await _implementation.ListContainersAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/container/list");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/container/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "ListContainers",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/container/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update container properties
    /// </summary>
    /// <remarks>
    /// Updates mutable container properties like capacity limits and filtering.
    /// </remarks>
    /// <returns>Container updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/container/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerResponse>> UpdateContainer([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateContainerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.UpdateContainer",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/container/update");
        try
        {

            var (statusCode, result) = await _implementation.UpdateContainerAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/container/update");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/container/update");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "UpdateContainer",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/container/update",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Delete container
    /// </summary>
    /// <remarks>
    /// Deletes a container. Must specify how to handle existing contents:
    /// <br/>destroy, transfer to another container, or error if not empty.
    /// </remarks>
    /// <returns>Container deleted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/container/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteContainerResponse>> DeleteContainer([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteContainerRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.DeleteContainer",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/container/delete");
        try
        {

            var (statusCode, result) = await _implementation.DeleteContainerAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/container/delete");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/container/delete");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "DeleteContainer",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/container/delete",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Add item to container
    /// </summary>
    /// <remarks>
    /// Adds an item instance to a container. Validates container constraints
    /// <br/>(slots, weight, grid, category filters). For stackable items, may
    /// <br/>merge with existing stacks.
    /// </remarks>
    /// <returns>Item added successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/add")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AddItemResponse>> AddItemToContainer([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AddItemRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.AddItemToContainer",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/add");
        try
        {

            var (statusCode, result) = await _implementation.AddItemToContainerAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/add");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/add");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "AddItemToContainer",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/add",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Remove item from container
    /// </summary>
    /// <remarks>
    /// Removes an item from its container. The item still exists but has no
    /// <br/>container assignment. Use destroy via lib-item to permanently delete.
    /// </remarks>
    /// <returns>Item removed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/remove")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RemoveItemResponse>> RemoveItemFromContainer([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RemoveItemRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.RemoveItemFromContainer",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/remove");
        try
        {

            var (statusCode, result) = await _implementation.RemoveItemFromContainerAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/remove");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/remove");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "RemoveItemFromContainer",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/remove",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Move item to different slot or container
    /// </summary>
    /// <remarks>
    /// Moves an item within the same container (slot change) or to a different
    /// <br/>container. Validates destination constraints. For equipment slots, this
    /// <br/>effectively equips/unequips items.
    /// </remarks>
    /// <returns>Item moved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/move")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MoveItemResponse>> MoveItem([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] MoveItemRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.MoveItem",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/move");
        try
        {

            var (statusCode, result) = await _implementation.MoveItemAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/move");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/move");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "MoveItem",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/move",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Transfer item to different owner
    /// </summary>
    /// <remarks>
    /// Transfers an item to a container owned by a different entity.
    /// <br/>Used for trades, gifts, and loot distribution.
    /// </remarks>
    /// <returns>Item transferred successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/transfer")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TransferItemResponse>> TransferItem([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] TransferItemRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.TransferItem",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/transfer");
        try
        {

            var (statusCode, result) = await _implementation.TransferItemAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/transfer");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/transfer");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "TransferItem",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/transfer",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Split stack into two
    /// </summary>
    /// <remarks>
    /// Splits a stack of items into two stacks. The original stack keeps the
    /// <br/>remainder, and a new stack is created with the split quantity.
    /// </remarks>
    /// <returns>Stack split successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/split")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SplitStackResponse>> SplitStack([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SplitStackRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.SplitStack",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/split");
        try
        {

            var (statusCode, result) = await _implementation.SplitStackAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/split");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/split");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "SplitStack",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/split",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Merge two stacks
    /// </summary>
    /// <remarks>
    /// Merges two stacks of the same item template. The source stack is
    /// <br/>destroyed and its quantity added to the target stack.
    /// </remarks>
    /// <returns>Stacks merged successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/merge")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MergeStacksResponse>> MergeStacks([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] MergeStacksRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.MergeStacks",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/merge");
        try
        {

            var (statusCode, result) = await _implementation.MergeStacksAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/merge");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/merge");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "MergeStacks",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/merge",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Find items across containers
    /// </summary>
    /// <remarks>
    /// Searches for items across all containers owned by an entity.
    /// <br/>Can filter by template, category, tags, and other criteria.
    /// </remarks>
    /// <returns>Items found</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/query")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryItemsResponse>> QueryItems([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryItemsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.QueryItems",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/query");
        try
        {

            var (statusCode, result) = await _implementation.QueryItemsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/query");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/query");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "QueryItems",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/query",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Count items of a template
    /// </summary>
    /// <remarks>
    /// Counts total quantity of a specific item template across containers.
    /// </remarks>
    /// <returns>Count completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/count")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CountItemsResponse>> CountItems([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CountItemsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.CountItems",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/count");
        try
        {

            var (statusCode, result) = await _implementation.CountItemsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/count");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/count");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "CountItems",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/count",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Check if entity has required items
    /// </summary>
    /// <remarks>
    /// Checks if an entity has the required quantities of specified items.
    /// <br/>Used for crafting and quest requirements validation.
    /// </remarks>
    /// <returns>Check completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/has")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<HasItemsResponse>> HasItems([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] HasItemsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.HasItems",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/has");
        try
        {

            var (statusCode, result) = await _implementation.HasItemsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/has");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/has");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "HasItems",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/has",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Find where item would fit
    /// </summary>
    /// <remarks>
    /// Finds available space for an item in the owner's containers.
    /// <br/>Returns candidate containers and slots where the item could be placed.
    /// </remarks>
    /// <returns>Space search completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("inventory/find-space")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<FindSpaceResponse>> FindSpace([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] FindSpaceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.inventory",
            "InventoryController.FindSpace",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "inventory/find-space");
        try
        {

            var (statusCode, result) = await _implementation.FindSpaceAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:inventory/find-space");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<InventoryController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:inventory/find-space");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "inventory",
                "FindSpace",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:inventory/find-space",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
