// =============================================================================
// Bytecode Optimizer
// Performs peephole optimizations on generated bytecode.
// =============================================================================

using BeyondImmersion.BannouService.Behavior.Runtime;

namespace BeyondImmersion.Bannou.Behavior.Compiler.Codegen;

/// <summary>
/// Performs peephole optimizations on generated bytecode.
/// </summary>
public sealed class BytecodeOptimizer
{
    /// <summary>
    /// Optimizes the given bytecode.
    /// </summary>
    /// <param name="bytecode">The bytecode to optimize.</param>
    /// <param name="constants">The constant pool (may be modified).</param>
    /// <returns>The optimized bytecode.</returns>
    public byte[] Optimize(byte[] bytecode, ConstantPoolBuilder constants)
    {
        ArgumentNullException.ThrowIfNull(bytecode);
        ArgumentNullException.ThrowIfNull(constants);

        if (bytecode.Length == 0)
        {
            return bytecode;
        }

        var result = new List<byte>(bytecode.Length);
        var i = 0;

        while (i < bytecode.Length)
        {
            // Try peephole patterns
            if (TryOptimizePushPop(bytecode, i, result, out var consumed))
            {
                i += consumed;
                continue;
            }

            if (TryOptimizeDuplicateConst(bytecode, i, result, out consumed))
            {
                i += consumed;
                continue;
            }

            if (TryOptimizeConstantArithmetic(bytecode, i, result, constants, out consumed))
            {
                i += consumed;
                continue;
            }

            // No optimization, copy instruction as-is
            var instructionSize = GetInstructionSize((BehaviorOpcode)bytecode[i]);
            for (var j = 0; j < instructionSize && i + j < bytecode.Length; j++)
            {
                result.Add(bytecode[i + j]);
            }
            i += instructionSize;
        }

        return result.ToArray();
    }

    /// <summary>
    /// Optimizes push followed immediately by pop.
    /// Pattern: PUSH_* x; POP -> (nothing)
    /// </summary>
    private static bool TryOptimizePushPop(byte[] bytecode, int offset, List<byte> result, out int consumed)
    {
        consumed = 0;

        if (offset + 2 >= bytecode.Length)
        {
            return false;
        }

        var opcode = (BehaviorOpcode)bytecode[offset];
        var pushSize = GetInstructionSize(opcode);

        if (!IsPushInstruction(opcode))
        {
            return false;
        }

        if (offset + pushSize >= bytecode.Length)
        {
            return false;
        }

        var nextOpcode = (BehaviorOpcode)bytecode[offset + pushSize];
        if (nextOpcode == BehaviorOpcode.Pop)
        {
            // Skip both push and pop
            consumed = pushSize + 1;
            return true;
        }

        return false;
    }

    /// <summary>
    /// Optimizes consecutive duplicate constants.
    /// Pattern: PUSH_CONST x; PUSH_CONST x -> PUSH_CONST x; DUP
    /// </summary>
    private static bool TryOptimizeDuplicateConst(byte[] bytecode, int offset, List<byte> result, out int consumed)
    {
        consumed = 0;

        if (offset + 3 >= bytecode.Length)
        {
            return false;
        }

        if ((BehaviorOpcode)bytecode[offset] != BehaviorOpcode.PushConst)
        {
            return false;
        }

        var constIdx = bytecode[offset + 1];

        if ((BehaviorOpcode)bytecode[offset + 2] != BehaviorOpcode.PushConst)
        {
            return false;
        }

        if (bytecode[offset + 3] != constIdx)
        {
            return false;
        }

        // Emit: PUSH_CONST x; DUP
        result.Add((byte)BehaviorOpcode.PushConst);
        result.Add(constIdx);
        result.Add((byte)BehaviorOpcode.Dup);
        consumed = 4;
        return true;
    }

    /// <summary>
    /// Optimizes constant arithmetic.
    /// Pattern: PUSH_CONST a; PUSH_CONST b; ADD -> PUSH_CONST (a+b)
    /// </summary>
    private static bool TryOptimizeConstantArithmetic(
        byte[] bytecode,
        int offset,
        List<byte> result,
        ConstantPoolBuilder constants,
        out int consumed)
    {
        consumed = 0;

        if (offset + 4 >= bytecode.Length)
        {
            return false;
        }

        // Check for PUSH_CONST a; PUSH_CONST b; ARITH_OP
        if ((BehaviorOpcode)bytecode[offset] != BehaviorOpcode.PushConst)
        {
            return false;
        }

        if ((BehaviorOpcode)bytecode[offset + 2] != BehaviorOpcode.PushConst)
        {
            return false;
        }

        var aIdx = bytecode[offset + 1];
        var bIdx = bytecode[offset + 3];
        var op = (BehaviorOpcode)bytecode[offset + 4];

        if (!IsArithmeticOpcode(op))
        {
            return false;
        }

        // Get constant values
        if (!constants.TryGetValue(aIdx, out var a) || !constants.TryGetValue(bIdx, out var b))
        {
            return false;
        }

        // Compute result
        double computed;
        switch (op)
        {
            case BehaviorOpcode.Add:
                computed = a + b;
                break;
            case BehaviorOpcode.Sub:
                computed = a - b;
                break;
            case BehaviorOpcode.Mul:
                computed = a * b;
                break;
            case BehaviorOpcode.Div when b != 0:
                computed = a / b;
                break;
            case BehaviorOpcode.Mod when b != 0:
                computed = a % b;
                break;
            default:
                return false;
        }

        // Emit: PUSH_CONST result
        var resultIdx = constants.GetOrAdd(computed);
        result.Add((byte)BehaviorOpcode.PushConst);
        result.Add(resultIdx);
        consumed = 5;
        return true;
    }

    private static bool IsPushInstruction(BehaviorOpcode opcode)
    {
        return opcode is BehaviorOpcode.PushConst
            or BehaviorOpcode.PushInput
            or BehaviorOpcode.PushLocal
            or BehaviorOpcode.PushString;
    }

    private static bool IsArithmeticOpcode(BehaviorOpcode opcode)
    {
        return opcode is BehaviorOpcode.Add
            or BehaviorOpcode.Sub
            or BehaviorOpcode.Mul
            or BehaviorOpcode.Div
            or BehaviorOpcode.Mod;
    }

    private static int GetInstructionSize(BehaviorOpcode opcode)
    {
        return opcode switch
        {
            // Single byte instructions
            BehaviorOpcode.Pop or BehaviorOpcode.Dup or BehaviorOpcode.Swap => 1,
            BehaviorOpcode.Add or BehaviorOpcode.Sub or BehaviorOpcode.Mul or
            BehaviorOpcode.Div or BehaviorOpcode.Mod or BehaviorOpcode.Neg => 1,
            BehaviorOpcode.Eq or BehaviorOpcode.Ne or BehaviorOpcode.Lt or
            BehaviorOpcode.Le or BehaviorOpcode.Gt or BehaviorOpcode.Ge => 1,
            BehaviorOpcode.And or BehaviorOpcode.Or or BehaviorOpcode.Not => 1,
            BehaviorOpcode.Halt or BehaviorOpcode.Nop => 1,
            BehaviorOpcode.Rand => 1,

            // Two byte instructions (opcode + 1 byte operand)
            BehaviorOpcode.PushConst or BehaviorOpcode.PushInput or
            BehaviorOpcode.PushLocal or BehaviorOpcode.StoreLocal or
            BehaviorOpcode.PushString or BehaviorOpcode.SetOutput or
            BehaviorOpcode.EmitIntent or BehaviorOpcode.Trace => 2,

            // Three byte instructions (opcode + 2 byte operand)
            BehaviorOpcode.Jmp or BehaviorOpcode.JmpIf or BehaviorOpcode.JmpUnless or
            BehaviorOpcode.ContinuationPoint => 3,

            // Default for unknown opcodes
            _ => 1
        };
    }
}
