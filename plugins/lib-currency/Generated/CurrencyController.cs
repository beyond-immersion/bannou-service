//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     RELATED FILES:
//     - Request/Response models: bannou-service/Generated/Models/{Service}Models.cs
//     - Event models: bannou-service/Generated/Events/{Service}EventsModels.cs
//     - Lifecycle events: bannou-service/Generated/Events/{Service}LifecycleEvents.cs
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8600 // Disable "CS8600 Converting null literal or possible null value to non-nullable type"
#pragma warning disable 8602 // Disable "CS8602 Dereference of a possibly null reference"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace BeyondImmersion.BannouService.Currency;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface ICurrencyController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Create a new currency definition
    /// </summary>

    /// <remarks>
    /// Creates a new currency type with its behavior rules. Code, precision, and scope
    /// <br/>are immutable after creation. Only one base currency per scope is allowed.
    /// </remarks>

    /// <returns>Currency definition created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CurrencyDefinitionResponse>> CreateCurrencyDefinitionAsync(CreateCurrencyDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get currency definition by ID or code
    /// </summary>

    /// <remarks>
    /// Retrieves a currency definition by its unique ID or code.
    /// <br/>At least one of definitionId or code must be provided.
    /// </remarks>

    /// <returns>Currency definition retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CurrencyDefinitionResponse>> GetCurrencyDefinitionAsync(GetCurrencyDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List currency definitions with filters
    /// </summary>

    /// <remarks>
    /// Lists currency definitions with optional filtering by realm, scope,
    /// <br/>active status, and base currency flag.
    /// </remarks>

    /// <returns>Currency definitions retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListCurrencyDefinitionsResponse>> ListCurrencyDefinitionsAsync(ListCurrencyDefinitionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update mutable fields of a currency definition
    /// </summary>

    /// <remarks>
    /// Updates mutable fields of a currency definition. Code, precision, and scope
    /// <br/>are immutable after creation and cannot be changed.
    /// </remarks>

    /// <returns>Currency definition updated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CurrencyDefinitionResponse>> UpdateCurrencyDefinitionAsync(UpdateCurrencyDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create a new wallet for an owner
    /// </summary>

    /// <remarks>
    /// Creates a new wallet for a polymorphic owner (account, character, NPC, guild, etc.).
    /// <br/>Each owner+ownerType+realm combination can have at most one wallet.
    /// </remarks>

    /// <returns>Wallet created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<WalletResponse>> CreateWalletAsync(CreateWalletRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get wallet by ID or owner
    /// </summary>

    /// <remarks>
    /// Retrieves a wallet by its ID, or by owner+ownerType+realm combination.
    /// <br/>Returns the wallet with all non-zero balances.
    /// </remarks>

    /// <returns>Wallet retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<WalletWithBalancesResponse>> GetWalletAsync(GetWalletRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get existing wallet or create if not exists
    /// </summary>

    /// <remarks>
    /// Retrieves a wallet if it exists, otherwise creates a new one.
    /// <br/>Upsert pattern for convenience.
    /// </remarks>

    /// <returns>Wallet retrieved or created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetOrCreateWalletResponse>> GetOrCreateWalletAsync(GetOrCreateWalletRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Freeze a wallet to prevent transactions
    /// </summary>

    /// <remarks>
    /// Freezes a wallet, preventing all transactions. The reason is recorded
    /// <br/>for audit purposes. Frozen wallets can still be queried.
    /// </remarks>

    /// <returns>Wallet frozen successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<WalletResponse>> FreezeWalletAsync(FreezeWalletRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Unfreeze a frozen wallet
    /// </summary>

    /// <remarks>
    /// Restores a frozen wallet to active status, allowing transactions again.
    /// </remarks>

    /// <returns>Wallet unfrozen successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<WalletResponse>> UnfreezeWalletAsync(UnfreezeWalletRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Permanently close a wallet
    /// </summary>

    /// <remarks>
    /// Permanently closes a wallet and transfers any remaining balances to a
    /// <br/>destination wallet. Closed wallets cannot be reopened.
    /// </remarks>

    /// <returns>Wallet closed and balances transferred</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CloseWalletResponse>> CloseWalletAsync(CloseWalletRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get balance for a specific currency in a wallet
    /// </summary>

    /// <remarks>
    /// Retrieves the current balance for a specific currency in a wallet.
    /// <br/>In lazy autogain mode, this may trigger autogain calculation and emit events.
    /// <br/>Returns earn cap info and autogain info when applicable.
    /// </remarks>

    /// <returns>Balance retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetBalanceResponse>> GetBalanceAsync(GetBalanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get multiple balances in one call
    /// </summary>

    /// <remarks>
    /// Retrieves balances for multiple wallet+currency combinations.
    /// <br/>Autogain is applied where applicable.
    /// </remarks>

    /// <returns>Balances retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BatchGetBalancesResponse>> BatchGetBalancesAsync(BatchGetBalancesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Credit currency to a wallet (faucet operation)
    /// </summary>

    /// <remarks>
    /// Credits currency to a wallet. This is a faucet operation (currency enters the system).
    /// <br/>Enforces earn caps, wallet caps, and global supply caps. Requires idempotency key.
    /// </remarks>

    /// <returns>Currency credited successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreditCurrencyResponse>> CreditCurrencyAsync(CreditCurrencyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Debit currency from a wallet (sink operation)
    /// </summary>

    /// <remarks>
    /// Debits currency from a wallet. This is a sink operation (currency exits the system).
    /// <br/>Checks for sufficient funds unless negative balance is allowed.
    /// </remarks>

    /// <returns>Currency debited successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DebitCurrencyResponse>> DebitCurrencyAsync(DebitCurrencyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Transfer currency between wallets
    /// </summary>

    /// <remarks>
    /// Transfers currency from one wallet to another. Validates transferability,
    /// <br/>realm compatibility, and sufficient funds.
    /// </remarks>

    /// <returns>Transfer completed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TransferCurrencyResponse>> TransferCurrencyAsync(TransferCurrencyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Credit multiple wallets in one call
    /// </summary>

    /// <remarks>
    /// Credits currency to multiple wallets in one call. Each operation is independent;
    /// <br/>failures do not rollback others. For atomic multi-wallet operations, use lib-escrow.
    /// </remarks>

    /// <returns>Batch credit processed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BatchCreditResponse>> BatchCreditCurrencyAsync(BatchCreditRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Calculate conversion without executing
    /// </summary>

    /// <remarks>
    /// Previews a currency conversion calculation without executing it.
    /// <br/>Uses base currency exchange rates to compute the effective rate.
    /// </remarks>

    /// <returns>Conversion calculated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CalculateConversionResponse>> CalculateConversionAsync(CalculateConversionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Execute currency conversion in a wallet
    /// </summary>

    /// <remarks>
    /// Executes a currency conversion within a single wallet. Debits the source
    /// <br/>currency and credits the target currency at the computed exchange rate.
    /// </remarks>

    /// <returns>Conversion executed successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ExecuteConversionResponse>> ExecuteConversionAsync(ExecuteConversionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get exchange rate between two currencies
    /// </summary>

    /// <remarks>
    /// Retrieves the exchange rate between two currencies using the base currency
    /// <br/>as an intermediary.
    /// </remarks>

    /// <returns>Exchange rate retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetExchangeRateResponse>> GetExchangeRateAsync(GetExchangeRateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update a currency's exchange rate to base
    /// </summary>

    /// <remarks>
    /// Updates the exchange rate of a currency relative to the base currency.
    /// <br/>Cannot set rate on the base currency itself.
    /// </remarks>

    /// <returns>Exchange rate updated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateExchangeRateResponse>> UpdateExchangeRateAsync(UpdateExchangeRateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get a transaction by ID
    /// </summary>

    /// <remarks>
    /// Retrieves a single transaction record by its unique ID.
    /// </remarks>

    /// <returns>Transaction retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TransactionResponse>> GetTransactionAsync(GetTransactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get paginated transaction history for a wallet
    /// </summary>

    /// <remarks>
    /// Retrieves transaction history for a wallet with optional filters
    /// <br/>by currency, transaction type, and date range.
    /// </remarks>

    /// <returns>Transaction history retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetTransactionHistoryResponse>> GetTransactionHistoryAsync(GetTransactionHistoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get transactions by reference type and ID
    /// </summary>

    /// <remarks>
    /// Retrieves all transactions linked to a specific reference (quest, auction,
    /// <br/>escrow, etc.).
    /// </remarks>

    /// <returns>Transactions retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetTransactionsByReferenceResponse>> GetTransactionsByReferenceAsync(GetTransactionsByReferenceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get global supply statistics for a currency
    /// </summary>

    /// <remarks>
    /// Returns aggregate supply statistics including total supply, circulation,
    /// <br/>escrow amounts, and lifetime mint/burn totals.
    /// </remarks>

    /// <returns>Supply statistics retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetGlobalSupplyResponse>> GetGlobalSupplyAsync(GetGlobalSupplyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get wealth distribution statistics
    /// </summary>

    /// <remarks>
    /// Returns wealth distribution statistics including percentiles and
    /// <br/>Gini coefficient for a specific currency.
    /// </remarks>

    /// <returns>Distribution statistics retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetWalletDistributionResponse>> GetWalletDistributionAsync(GetWalletDistributionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Debit wallet for escrow deposit
    /// </summary>

    /// <remarks>
    /// Called by lib-escrow when a party deposits currency into an escrow agreement.
    /// <br/>Immediately debits the wallet (no lock tracking needed - escrow owns the funds).
    /// </remarks>

    /// <returns>Escrow deposit processed (wallet debited)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EscrowDepositResponse>> EscrowDepositAsync(EscrowDepositRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Credit recipient on escrow completion
    /// </summary>

    /// <remarks>
    /// Called by lib-escrow when an escrow agreement completes successfully.
    /// <br/>Credits the recipient wallet with the released funds.
    /// </remarks>

    /// <returns>Escrow release processed (recipient credited)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EscrowReleaseResponse>> EscrowReleaseAsync(EscrowReleaseRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Credit depositor on escrow refund
    /// </summary>

    /// <remarks>
    /// Called by lib-escrow when an escrow agreement is cancelled or refunded.
    /// <br/>Credits the original depositor wallet with the refunded funds.
    /// </remarks>

    /// <returns>Escrow refund processed (depositor credited)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EscrowRefundResponse>> EscrowRefundAsync(EscrowRefundRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create an authorization hold (reserve funds)
    /// </summary>

    /// <remarks>
    /// Creates an authorization hold that reserves funds without debiting.
    /// <br/>The held amount reduces the effective balance but does not leave the wallet.
    /// <br/>Used for pre-auth scenarios (dining, gas, hotels) where final amount may differ.
    /// </remarks>

    /// <returns>Hold created successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<HoldResponse>> CreateHoldAsync(CreateHoldRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Capture held funds (debit final amount)
    /// </summary>

    /// <remarks>
    /// Captures an active hold by debiting the final amount (which may be less than
    /// <br/>or equal to the held amount). Any difference is released back to available balance.
    /// </remarks>

    /// <returns>Hold captured successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CaptureHoldResponse>> CaptureHoldAsync(CaptureHoldRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Release held funds (make available again)
    /// </summary>

    /// <remarks>
    /// Releases an active hold, making all held funds available again.
    /// <br/>No debit occurs.
    /// </remarks>

    /// <returns>Hold released successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<HoldResponse>> ReleaseHoldAsync(ReleaseHoldRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get hold status and details
    /// </summary>

    /// <remarks>
    /// Retrieves the current status and details of an authorization hold.
    /// </remarks>

    /// <returns>Hold retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<HoldResponse>> GetHoldAsync(GetHoldRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class CurrencyController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private ICurrencyService _implementation;

    public CurrencyController(ICurrencyService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Create a new currency definition
    /// </summary>
    /// <remarks>
    /// Creates a new currency type with its behavior rules. Code, precision, and scope
    /// <br/>are immutable after creation. Only one base currency per scope is allowed.
    /// </remarks>
    /// <returns>Currency definition created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/definition/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CurrencyDefinitionResponse>> CreateCurrencyDefinition([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateCurrencyDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.CreateCurrencyDefinitionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/definition/create");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/definition/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "CreateCurrencyDefinition",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/definition/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get currency definition by ID or code
    /// </summary>
    /// <remarks>
    /// Retrieves a currency definition by its unique ID or code.
    /// <br/>At least one of definitionId or code must be provided.
    /// </remarks>
    /// <returns>Currency definition retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/definition/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CurrencyDefinitionResponse>> GetCurrencyDefinition([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetCurrencyDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetCurrencyDefinitionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/definition/get");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/definition/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "GetCurrencyDefinition",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/definition/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List currency definitions with filters
    /// </summary>
    /// <remarks>
    /// Lists currency definitions with optional filtering by realm, scope,
    /// <br/>active status, and base currency flag.
    /// </remarks>
    /// <returns>Currency definitions retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/definition/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListCurrencyDefinitionsResponse>> ListCurrencyDefinitions([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListCurrencyDefinitionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ListCurrencyDefinitionsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/definition/list");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/definition/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "ListCurrencyDefinitions",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/definition/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update mutable fields of a currency definition
    /// </summary>
    /// <remarks>
    /// Updates mutable fields of a currency definition. Code, precision, and scope
    /// <br/>are immutable after creation and cannot be changed.
    /// </remarks>
    /// <returns>Currency definition updated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/definition/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CurrencyDefinitionResponse>> UpdateCurrencyDefinition([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateCurrencyDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.UpdateCurrencyDefinitionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/definition/update");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/definition/update");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "UpdateCurrencyDefinition",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/definition/update",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Create a new wallet for an owner
    /// </summary>
    /// <remarks>
    /// Creates a new wallet for a polymorphic owner (account, character, NPC, guild, etc.).
    /// <br/>Each owner+ownerType+realm combination can have at most one wallet.
    /// </remarks>
    /// <returns>Wallet created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/wallet/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<WalletResponse>> CreateWallet([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateWalletRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.CreateWalletAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/wallet/create");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/wallet/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "CreateWallet",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/wallet/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get wallet by ID or owner
    /// </summary>
    /// <remarks>
    /// Retrieves a wallet by its ID, or by owner+ownerType+realm combination.
    /// <br/>Returns the wallet with all non-zero balances.
    /// </remarks>
    /// <returns>Wallet retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/wallet/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<WalletWithBalancesResponse>> GetWallet([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetWalletRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetWalletAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/wallet/get");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/wallet/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "GetWallet",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/wallet/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get existing wallet or create if not exists
    /// </summary>
    /// <remarks>
    /// Retrieves a wallet if it exists, otherwise creates a new one.
    /// <br/>Upsert pattern for convenience.
    /// </remarks>
    /// <returns>Wallet retrieved or created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/wallet/get-or-create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetOrCreateWalletResponse>> GetOrCreateWallet([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetOrCreateWalletRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetOrCreateWalletAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/wallet/get-or-create");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/wallet/get-or-create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "GetOrCreateWallet",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/wallet/get-or-create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Freeze a wallet to prevent transactions
    /// </summary>
    /// <remarks>
    /// Freezes a wallet, preventing all transactions. The reason is recorded
    /// <br/>for audit purposes. Frozen wallets can still be queried.
    /// </remarks>
    /// <returns>Wallet frozen successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/wallet/freeze")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<WalletResponse>> FreezeWallet([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] FreezeWalletRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.FreezeWalletAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/wallet/freeze");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/wallet/freeze");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "FreezeWallet",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/wallet/freeze",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Unfreeze a frozen wallet
    /// </summary>
    /// <remarks>
    /// Restores a frozen wallet to active status, allowing transactions again.
    /// </remarks>
    /// <returns>Wallet unfrozen successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/wallet/unfreeze")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<WalletResponse>> UnfreezeWallet([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UnfreezeWalletRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.UnfreezeWalletAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/wallet/unfreeze");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/wallet/unfreeze");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "UnfreezeWallet",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/wallet/unfreeze",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Permanently close a wallet
    /// </summary>
    /// <remarks>
    /// Permanently closes a wallet and transfers any remaining balances to a
    /// <br/>destination wallet. Closed wallets cannot be reopened.
    /// </remarks>
    /// <returns>Wallet closed and balances transferred</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/wallet/close")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CloseWalletResponse>> CloseWallet([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CloseWalletRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.CloseWalletAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/wallet/close");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/wallet/close");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "CloseWallet",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/wallet/close",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get balance for a specific currency in a wallet
    /// </summary>
    /// <remarks>
    /// Retrieves the current balance for a specific currency in a wallet.
    /// <br/>In lazy autogain mode, this may trigger autogain calculation and emit events.
    /// <br/>Returns earn cap info and autogain info when applicable.
    /// </remarks>
    /// <returns>Balance retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/balance/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetBalanceResponse>> GetBalance([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetBalanceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetBalanceAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/balance/get");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/balance/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "GetBalance",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/balance/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get multiple balances in one call
    /// </summary>
    /// <remarks>
    /// Retrieves balances for multiple wallet+currency combinations.
    /// <br/>Autogain is applied where applicable.
    /// </remarks>
    /// <returns>Balances retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/balance/batch-get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BatchGetBalancesResponse>> BatchGetBalances([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BatchGetBalancesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.BatchGetBalancesAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/balance/batch-get");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/balance/batch-get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "BatchGetBalances",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/balance/batch-get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Credit currency to a wallet (faucet operation)
    /// </summary>
    /// <remarks>
    /// Credits currency to a wallet. This is a faucet operation (currency enters the system).
    /// <br/>Enforces earn caps, wallet caps, and global supply caps. Requires idempotency key.
    /// </remarks>
    /// <returns>Currency credited successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/credit")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreditCurrencyResponse>> CreditCurrency([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreditCurrencyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.CreditCurrencyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/credit");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/credit");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "CreditCurrency",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/credit",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Debit currency from a wallet (sink operation)
    /// </summary>
    /// <remarks>
    /// Debits currency from a wallet. This is a sink operation (currency exits the system).
    /// <br/>Checks for sufficient funds unless negative balance is allowed.
    /// </remarks>
    /// <returns>Currency debited successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/debit")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DebitCurrencyResponse>> DebitCurrency([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DebitCurrencyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.DebitCurrencyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/debit");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/debit");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "DebitCurrency",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/debit",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Transfer currency between wallets
    /// </summary>
    /// <remarks>
    /// Transfers currency from one wallet to another. Validates transferability,
    /// <br/>realm compatibility, and sufficient funds.
    /// </remarks>
    /// <returns>Transfer completed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/transfer")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TransferCurrencyResponse>> TransferCurrency([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] TransferCurrencyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.TransferCurrencyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/transfer");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/transfer");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "TransferCurrency",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/transfer",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Credit multiple wallets in one call
    /// </summary>
    /// <remarks>
    /// Credits currency to multiple wallets in one call. Each operation is independent;
    /// <br/>failures do not rollback others. For atomic multi-wallet operations, use lib-escrow.
    /// </remarks>
    /// <returns>Batch credit processed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/batch-credit")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BatchCreditResponse>> BatchCreditCurrency([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BatchCreditRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.BatchCreditCurrencyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/batch-credit");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/batch-credit");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "BatchCreditCurrency",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/batch-credit",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Calculate conversion without executing
    /// </summary>
    /// <remarks>
    /// Previews a currency conversion calculation without executing it.
    /// <br/>Uses base currency exchange rates to compute the effective rate.
    /// </remarks>
    /// <returns>Conversion calculated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/convert/calculate")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CalculateConversionResponse>> CalculateConversion([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CalculateConversionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.CalculateConversionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/convert/calculate");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/convert/calculate");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "CalculateConversion",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/convert/calculate",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Execute currency conversion in a wallet
    /// </summary>
    /// <remarks>
    /// Executes a currency conversion within a single wallet. Debits the source
    /// <br/>currency and credits the target currency at the computed exchange rate.
    /// </remarks>
    /// <returns>Conversion executed successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/convert/execute")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ExecuteConversionResponse>> ExecuteConversion([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ExecuteConversionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ExecuteConversionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/convert/execute");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/convert/execute");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "ExecuteConversion",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/convert/execute",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get exchange rate between two currencies
    /// </summary>
    /// <remarks>
    /// Retrieves the exchange rate between two currencies using the base currency
    /// <br/>as an intermediary.
    /// </remarks>
    /// <returns>Exchange rate retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/exchange-rate/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetExchangeRateResponse>> GetExchangeRate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetExchangeRateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetExchangeRateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/exchange-rate/get");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/exchange-rate/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "GetExchangeRate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/exchange-rate/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update a currency's exchange rate to base
    /// </summary>
    /// <remarks>
    /// Updates the exchange rate of a currency relative to the base currency.
    /// <br/>Cannot set rate on the base currency itself.
    /// </remarks>
    /// <returns>Exchange rate updated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/exchange-rate/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateExchangeRateResponse>> UpdateExchangeRate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateExchangeRateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.UpdateExchangeRateAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/exchange-rate/update");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/exchange-rate/update");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "UpdateExchangeRate",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/exchange-rate/update",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get a transaction by ID
    /// </summary>
    /// <remarks>
    /// Retrieves a single transaction record by its unique ID.
    /// </remarks>
    /// <returns>Transaction retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/transaction/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TransactionResponse>> GetTransaction([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetTransactionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetTransactionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/transaction/get");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/transaction/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "GetTransaction",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/transaction/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get paginated transaction history for a wallet
    /// </summary>
    /// <remarks>
    /// Retrieves transaction history for a wallet with optional filters
    /// <br/>by currency, transaction type, and date range.
    /// </remarks>
    /// <returns>Transaction history retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/transaction/history")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetTransactionHistoryResponse>> GetTransactionHistory([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetTransactionHistoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetTransactionHistoryAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/transaction/history");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/transaction/history");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "GetTransactionHistory",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/transaction/history",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get transactions by reference type and ID
    /// </summary>
    /// <remarks>
    /// Retrieves all transactions linked to a specific reference (quest, auction,
    /// <br/>escrow, etc.).
    /// </remarks>
    /// <returns>Transactions retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/transaction/by-reference")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetTransactionsByReferenceResponse>> GetTransactionsByReference([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetTransactionsByReferenceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetTransactionsByReferenceAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/transaction/by-reference");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/transaction/by-reference");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "GetTransactionsByReference",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/transaction/by-reference",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get global supply statistics for a currency
    /// </summary>
    /// <remarks>
    /// Returns aggregate supply statistics including total supply, circulation,
    /// <br/>escrow amounts, and lifetime mint/burn totals.
    /// </remarks>
    /// <returns>Supply statistics retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/stats/global-supply")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetGlobalSupplyResponse>> GetGlobalSupply([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetGlobalSupplyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetGlobalSupplyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/stats/global-supply");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/stats/global-supply");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "GetGlobalSupply",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/stats/global-supply",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get wealth distribution statistics
    /// </summary>
    /// <remarks>
    /// Returns wealth distribution statistics including percentiles and
    /// <br/>Gini coefficient for a specific currency.
    /// </remarks>
    /// <returns>Distribution statistics retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/stats/wallet-distribution")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetWalletDistributionResponse>> GetWalletDistribution([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetWalletDistributionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetWalletDistributionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/stats/wallet-distribution");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/stats/wallet-distribution");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "GetWalletDistribution",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/stats/wallet-distribution",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Debit wallet for escrow deposit
    /// </summary>
    /// <remarks>
    /// Called by lib-escrow when a party deposits currency into an escrow agreement.
    /// <br/>Immediately debits the wallet (no lock tracking needed - escrow owns the funds).
    /// </remarks>
    /// <returns>Escrow deposit processed (wallet debited)</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/escrow/deposit")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EscrowDepositResponse>> EscrowDeposit([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] EscrowDepositRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.EscrowDepositAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/escrow/deposit");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/escrow/deposit");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "EscrowDeposit",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/escrow/deposit",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Credit recipient on escrow completion
    /// </summary>
    /// <remarks>
    /// Called by lib-escrow when an escrow agreement completes successfully.
    /// <br/>Credits the recipient wallet with the released funds.
    /// </remarks>
    /// <returns>Escrow release processed (recipient credited)</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/escrow/release")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EscrowReleaseResponse>> EscrowRelease([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] EscrowReleaseRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.EscrowReleaseAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/escrow/release");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/escrow/release");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "EscrowRelease",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/escrow/release",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Credit depositor on escrow refund
    /// </summary>
    /// <remarks>
    /// Called by lib-escrow when an escrow agreement is cancelled or refunded.
    /// <br/>Credits the original depositor wallet with the refunded funds.
    /// </remarks>
    /// <returns>Escrow refund processed (depositor credited)</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/escrow/refund")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EscrowRefundResponse>> EscrowRefund([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] EscrowRefundRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.EscrowRefundAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/escrow/refund");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/escrow/refund");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "EscrowRefund",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/escrow/refund",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Create an authorization hold (reserve funds)
    /// </summary>
    /// <remarks>
    /// Creates an authorization hold that reserves funds without debiting.
    /// <br/>The held amount reduces the effective balance but does not leave the wallet.
    /// <br/>Used for pre-auth scenarios (dining, gas, hotels) where final amount may differ.
    /// </remarks>
    /// <returns>Hold created successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/hold/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<HoldResponse>> CreateHold([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateHoldRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.CreateHoldAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/hold/create");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/hold/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "CreateHold",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/hold/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Capture held funds (debit final amount)
    /// </summary>
    /// <remarks>
    /// Captures an active hold by debiting the final amount (which may be less than
    /// <br/>or equal to the held amount). Any difference is released back to available balance.
    /// </remarks>
    /// <returns>Hold captured successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/hold/capture")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CaptureHoldResponse>> CaptureHold([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CaptureHoldRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.CaptureHoldAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/hold/capture");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/hold/capture");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "CaptureHold",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/hold/capture",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Release held funds (make available again)
    /// </summary>
    /// <remarks>
    /// Releases an active hold, making all held funds available again.
    /// <br/>No debit occurs.
    /// </remarks>
    /// <returns>Hold released successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/hold/release")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<HoldResponse>> ReleaseHold([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ReleaseHoldRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.ReleaseHoldAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/hold/release");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/hold/release");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "ReleaseHold",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/hold/release",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get hold status and details
    /// </summary>
    /// <remarks>
    /// Retrieves the current status and details of an authorization hold.
    /// </remarks>
    /// <returns>Hold retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("currency/hold/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<HoldResponse>> GetHold([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetHoldRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        try
        {

            var (statusCode, result) = await _implementation.GetHoldAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.BannouService.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:currency/hold/get");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CurrencyController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:currency/hold/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "currency",
                "GetHold",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:currency/hold/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            return StatusCode(500);
        }
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765