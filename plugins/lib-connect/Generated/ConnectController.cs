//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     RELATED FILES:
//     - Request/Response models: bannou-service/Generated/Models/{Service}Models.cs
//     - Event models: bannou-service/Generated/Events/{Service}EventsModels.cs
//     - Lifecycle events: bannou-service/Generated/Events/{Service}LifecycleEvents.cs
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Connect;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IConnectController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Internal API proxy for stateless requests
    /// </summary>

    /// <remarks>
    /// Stateless HTTP proxy for internal requests that don't require persistent sessions.
    /// <br/>Applies permission validation and rate limiting based on agent role and context.
    /// <br/>Perfect for AI agents making one-off API calls or bulk operations.
    /// </remarks>

    /// <returns>Request proxied successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InternalProxyResponse>> ProxyInternalRequestAsync(InternalProxyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get client capability manifest (GUID → API mappings)
    /// </summary>

    /// <remarks>
    /// Returns the capability manifest for the authenticated client's session.
    /// <br/>Maps client-salted GUIDs to available API endpoints based on the client's
    /// <br/>current permissions and session state.
    /// <br/>
    /// <br/>**Security**: Each client receives unique GUIDs for the same API endpoints.
    /// <br/>This prevents cross-session exploitation and enables per-client rate limiting.
    /// <br/>
    /// <br/>**Dynamic Updates**: Capabilities may change during a session when:
    /// <br/>- Role changes occur (admin promotion, etc.)
    /// <br/>- Subscription status changes
    /// <br/>- Session state transitions
    /// <br/>
    /// <br/>Clients should listen for capability update events via WebSocket to stay current.
    /// </remarks>

    /// <returns>Client capabilities retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ClientCapabilitiesResponse>> GetClientCapabilitiesAsync(GetClientCapabilitiesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Establish WebSocket connection
    /// </summary>

    /// <remarks>
    /// Initiates a WebSocket connection for real-time communication.
    /// <br/>Requires JWT authentication via Authorization header.
    /// <br/>
    /// <br/>**Connection Flow:**
    /// <br/>1. Send HTTP GET request with `Connection: Upgrade` and `Upgrade: websocket` headers
    /// <br/>2. Include `Authorization: Bearer &lt;jwt_token&gt;` header for authentication
    /// <br/>3. Server validates JWT and extracts user claims (roles, scopes, services)
    /// <br/>4. Connection upgrades to WebSocket protocol
    /// <br/>5. Client can send binary messages using the custom protocol
    /// <br/>
    /// <br/>**Reconnection:**
    /// <br/>For existing sessions, use `Authorization: Reconnect &lt;reconnect_token&gt;` instead.
    /// </remarks>

    /// <param name="connection">Must be "Upgrade" to initiate WebSocket connection</param>

    /// <param name="upgrade">Must be "websocket" to specify protocol upgrade</param>

    /// <param name="authorization">JWT Bearer token for new connections: "Bearer &lt;jwt_token&gt;"
    /// <br/>Reconnect token for existing sessions: "Reconnect &lt;reconnect_token&gt;"</param>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> ConnectWebSocketAsync(Connection connection, Upgrade upgrade, string authorization, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Establish WebSocket connection (POST variant)
    /// </summary>

    /// <remarks>
    /// Alternative POST method for establishing WebSocket connections.
    /// <br/>Functionally identical to the GET method but supports clients that
    /// <br/>require POST for WebSocket upgrades.
    /// </remarks>



    /// <param name="body">Optional connection parameters</param>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> ConnectWebSocketPostAsync(Connection2 connection, Upgrade2 upgrade, string authorization, ConnectRequest? body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get all active WebSocket sessions for an account
    /// </summary>

    /// <remarks>
    /// Returns all active WebSocket session IDs for a specified account.
    /// <br/>This is an internal endpoint used by services that need to know which
    /// <br/>sessions are currently connected for a given account.
    /// <br/>
    /// <br/>**Use Cases:**
    /// <br/>- GameSessionService periodic cache sync
    /// <br/>- Service-to-service session discovery
    /// <br/>- Admin session management
    /// <br/>
    /// <br/>**Note:** Session IDs returned are those with active WebSocket connections.
    /// <br/>Sessions in reconnection windows may not appear in this list.
    /// </remarks>

    /// <returns>Account sessions retrieved successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetAccountSessionsResponse>> GetAccountSessionsAsync(GetAccountSessionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public abstract class ConnectControllerBase : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IConnectService _implementation;

    public ConnectControllerBase(IConnectService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Internal API proxy for stateless requests
    /// </summary>
    /// <remarks>
    /// Stateless HTTP proxy for internal requests that don't require persistent sessions.
    /// <br/>Applies permission validation and rate limiting based on agent role and context.
    /// <br/>Perfect for AI agents making one-off API calls or bulk operations.
    /// </remarks>
    /// <returns>Request proxied successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("internal/proxy")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InternalProxyResponse>> ProxyInternalRequest([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] InternalProxyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ProxyInternalRequestAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get client capability manifest (GUID → API mappings)
    /// </summary>
    /// <remarks>
    /// Returns the capability manifest for the authenticated client's session.
    /// <br/>Maps client-salted GUIDs to available API endpoints based on the client's
    /// <br/>current permissions and session state.
    /// <br/>
    /// <br/>**Security**: Each client receives unique GUIDs for the same API endpoints.
    /// <br/>This prevents cross-session exploitation and enables per-client rate limiting.
    /// <br/>
    /// <br/>**Dynamic Updates**: Capabilities may change during a session when:
    /// <br/>- Role changes occur (admin promotion, etc.)
    /// <br/>- Subscription status changes
    /// <br/>- Session state transitions
    /// <br/>
    /// <br/>Clients should listen for capability update events via WebSocket to stay current.
    /// </remarks>
    /// <returns>Client capabilities retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("client-capabilities")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ClientCapabilitiesResponse>> GetClientCapabilities([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetClientCapabilitiesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetClientCapabilitiesAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Establish WebSocket connection
    /// </summary>
    /// <remarks>
    /// Initiates a WebSocket connection for real-time communication.
    /// <br/>Requires JWT authentication via Authorization header.
    /// <br/>
    /// <br/>**Connection Flow:**
    /// <br/>1. Send HTTP GET request with `Connection: Upgrade` and `Upgrade: websocket` headers
    /// <br/>2. Include `Authorization: Bearer &lt;jwt_token&gt;` header for authentication
    /// <br/>3. Server validates JWT and extracts user claims (roles, scopes, services)
    /// <br/>4. Connection upgrades to WebSocket protocol
    /// <br/>5. Client can send binary messages using the custom protocol
    /// <br/>
    /// <br/>**Reconnection:**
    /// <br/>For existing sessions, use `Authorization: Reconnect &lt;reconnect_token&gt;` instead.
    /// </remarks>
    /// <param name="connection">Must be "Upgrade" to initiate WebSocket connection</param>
    /// <param name="upgrade">Must be "websocket" to specify protocol upgrade</param>
    /// <param name="authorization">JWT Bearer token for new connections: "Bearer &lt;jwt_token&gt;"
    /// <br/>Reconnect token for existing sessions: "Reconnect &lt;reconnect_token&gt;"</param>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("connect")]

    public abstract System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> ConnectWebSocket([Microsoft.AspNetCore.Mvc.FromHeader] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] Connection connection, [Microsoft.AspNetCore.Mvc.FromHeader] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] Upgrade upgrade, [Microsoft.AspNetCore.Mvc.FromHeader] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string authorization, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Establish WebSocket connection (POST variant)
    /// </summary>
    /// <remarks>
    /// Alternative POST method for establishing WebSocket connections.
    /// <br/>Functionally identical to the GET method but supports clients that
    /// <br/>require POST for WebSocket upgrades.
    /// </remarks>
    /// <param name="body">Optional connection parameters</param>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("connect")]

    public abstract System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> ConnectWebSocketPost([Microsoft.AspNetCore.Mvc.FromHeader] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] Connection2 connection, [Microsoft.AspNetCore.Mvc.FromHeader] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] Upgrade2 upgrade, [Microsoft.AspNetCore.Mvc.FromHeader] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] string authorization, [Microsoft.AspNetCore.Mvc.FromBody] ConnectRequest? body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get all active WebSocket sessions for an account
    /// </summary>
    /// <remarks>
    /// Returns all active WebSocket session IDs for a specified account.
    /// <br/>This is an internal endpoint used by services that need to know which
    /// <br/>sessions are currently connected for a given account.
    /// <br/>
    /// <br/>**Use Cases:**
    /// <br/>- GameSessionService periodic cache sync
    /// <br/>- Service-to-service session discovery
    /// <br/>- Admin session management
    /// <br/>
    /// <br/>**Note:** Session IDs returned are those with active WebSocket connections.
    /// <br/>Sessions in reconnection windows may not appear in this list.
    /// </remarks>
    /// <returns>Account sessions retrieved successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("connect/get-account-sessions")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetAccountSessionsResponse>> GetAccountSessions([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetAccountSessionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetAccountSessionsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765