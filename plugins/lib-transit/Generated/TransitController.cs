//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     RELATED FILES:
//     - Request/Response models: bannou-service/Generated/Models/{Service}Models.cs
//     - Event models: bannou-service/Generated/Events/{Service}EventsModels.cs
//     - Lifecycle events: bannou-service/Generated/Events/{Service}LifecycleEvents.cs
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Transit;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface ITransitController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Register a new transit mode type
    /// </summary>

    /// <remarks>
    /// Register a new transit mode type with movement properties, terrain
    /// <br/>compatibility, entity restrictions, and requirements. Mode codes are
    /// <br/>unique string identifiers (e.g., "walking", "horseback", "wagon").
    /// </remarks>

    /// <returns>Mode registered successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ModeResponse>> RegisterModeAsync(RegisterModeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get a transit mode by code
    /// </summary>

    /// <remarks>
    /// Retrieve a transit mode definition by its unique code.
    /// </remarks>

    /// <returns>Mode found</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ModeResponse>> GetModeAsync(GetModeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all registered transit modes
    /// </summary>

    /// <remarks>
    /// List transit modes with optional filtering by realm availability,
    /// <br/>terrain compatibility, tags, and deprecation status.
    /// </remarks>

    /// <returns>Modes listed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListModesResponse>> ListModesAsync(ListModesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update a transit mode's properties
    /// </summary>

    /// <remarks>
    /// Update properties of an existing transit mode. Only provided fields
    /// <br/>are updated; null fields are left unchanged.
    /// </remarks>

    /// <returns>Mode updated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ModeResponse>> UpdateModeAsync(UpdateModeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Deprecate a transit mode
    /// </summary>

    /// <remarks>
    /// Deprecate a transit mode. Existing journeys using this mode continue,
    /// <br/>but new journeys cannot use it. Sets the triple-field deprecation model:
    /// <br/>isDeprecated=true, deprecatedAt=now, deprecationReason=reason.
    /// <br/>Idempotent: returns OK if already deprecated (caller's intent is satisfied).
    /// <br/>Category A per IMPLEMENTATION TENETS: connections store compatibleModes
    /// <br/>and journeys store primaryModeCode/legModes referencing mode codes.
    /// </remarks>

    /// <returns>Mode deprecated (or already deprecated)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ModeResponse>> DeprecateModeAsync(DeprecateModeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Reverse deprecation of a transit mode
    /// </summary>

    /// <remarks>
    /// Reverse deprecation of a transit mode (Category A — undeprecate is required).
    /// <br/>Clears isDeprecated, deprecatedAt, deprecationReason.
    /// <br/>Idempotent: returns OK if not currently deprecated.
    /// </remarks>

    /// <returns>Mode undeprecated (or was not deprecated)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ModeResponse>> UndeprecateModeAsync(UndeprecateModeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete a deprecated transit mode
    /// </summary>

    /// <remarks>
    /// Delete a deprecated transit mode (Category A — must be deprecated before
    /// <br/>deletion). Rejects if active journeys use this mode or if connections
    /// <br/>still list this mode in compatibleModes. Archived journeys retain the
    /// <br/>mode code as historical data.
    /// </remarks>

    /// <returns>Mode deleted</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteModeResponse>> DeleteModeAsync(DeleteModeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Check which transit modes an entity can currently use
    /// </summary>

    /// <remarks>
    /// Check mode availability for an entity based on item requirements,
    /// <br/>species restrictions, entity type restrictions, and optional location
    /// <br/>context. Also applies ITransitCostModifierProvider enrichment to
    /// <br/>compute preferenceCost and effectiveSpeed adjustments.
    /// </remarks>

    /// <returns>Availability checked</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CheckModeAvailabilityResponse>> CheckModeAvailabilityAsync(CheckModeAvailabilityRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create a connection between two locations
    /// </summary>

    /// <remarks>
    /// Create a directed or bidirectional connection between two locations.
    /// <br/>fromRealmId, toRealmId, and crossRealm are derived from the locations
    /// <br/>via the Location service. Season keys in seasonalAvailability are
    /// <br/>validated against the realm's Worldstate season codes.
    /// </remarks>

    /// <returns>Connection created</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConnectionResponse>> CreateConnectionAsync(CreateConnectionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get a connection by ID or code
    /// </summary>

    /// <remarks>
    /// Retrieve a connection by its unique ID or code. One of connectionId or code must be provided.
    /// </remarks>

    /// <returns>Connection found</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConnectionResponse>> GetConnectionAsync(GetConnectionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Query connections by location, terrain, mode, or status
    /// </summary>

    /// <remarks>
    /// Query connections with optional filters. All filters are optional;
    /// <br/>an empty request returns all connections paginated.
    /// </remarks>

    /// <returns>Connections queried</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryConnectionsResponse>> QueryConnectionsAsync(QueryConnectionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update a connection's properties
    /// </summary>

    /// <remarks>
    /// Update properties of an existing connection. Does not update status —
    /// <br/>use update-status for operational status changes. Only provided fields
    /// <br/>are updated; null fields are left unchanged.
    /// </remarks>

    /// <returns>Connection updated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConnectionResponse>> UpdateConnectionAsync(UpdateConnectionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Transition a connection's operational status with optimistic concurrency
    /// </summary>

    /// <remarks>
    /// Transition a connection's operational status using optimistic concurrency.
    /// <br/>Caller specifies currentStatus (what they believe the status is) and
    /// <br/>newStatus. If the actual status does not match currentStatus, returns
    /// <br/>Bad Request with the actual status. Use forceUpdate=true for administrative
    /// <br/>overrides where currentStatus is ignored. The seasonal_closed status is
    /// <br/>typically only set by the Seasonal Connection Worker via forceUpdate=true.
    /// </remarks>

    /// <returns>Status updated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConnectionResponse>> UpdateConnectionStatusAsync(UpdateConnectionStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete a connection between locations
    /// </summary>

    /// <remarks>
    /// Delete a connection. Rejects if active journeys are currently using
    /// <br/>this connection.
    /// </remarks>

    /// <returns>Connection deleted</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteConnectionResponse>> DeleteConnectionAsync(DeleteConnectionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Seed connections from configuration
    /// </summary>

    /// <remarks>
    /// Seed connections from configuration using location codes resolved via
    /// <br/>the Location service. Two-pass resolution: first pass creates connections
    /// <br/>with location code lookup, second pass validates all mode codes exist.
    /// <br/>When realmId is provided, location codes are resolved within that realm
    /// <br/>and replaceExisting deletes connections for that realm only.
    /// </remarks>

    /// <returns>Bulk seed completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BulkSeedConnectionsResponse>> BulkSeedConnectionsAsync(BulkSeedConnectionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Plan a journey (status preparing)
    /// </summary>

    /// <remarks>
    /// Plan a journey from origin to destination. Internally calls route/calculate
    /// <br/>to find the best path and populate legs. Checks mode compatibility via
    /// <br/>check-availability. Does NOT start the journey — call /transit/journey/depart
    /// <br/>for that. When preferMultiModal is true, each leg gets the fastest compatible
    /// <br/>mode the entity can use on that connection.
    /// </remarks>

    /// <returns>Journey planned</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> CreateJourneyAsync(CreateJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Start a prepared journey
    /// </summary>

    /// <remarks>
    /// Start a prepared journey, transitioning status from preparing to in_transit.
    /// <br/>Publishes transit.journey.departed event.
    /// </remarks>

    /// <returns>Journey started</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> DepartJourneyAsync(DepartJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Resume an interrupted journey
    /// </summary>

    /// <remarks>
    /// Resume an interrupted journey, transitioning status from interrupted
    /// <br/>to in_transit. Distinct from depart: depart is for initial departure
    /// <br/>(preparing to in_transit), resume is for continuing after interruption.
    /// <br/>Publishes transit.journey.resumed event.
    /// </remarks>

    /// <returns>Journey resumed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> ResumeJourneyAsync(ResumeJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Mark arrival at next waypoint
    /// </summary>

    /// <remarks>
    /// Mark arrival at the next waypoint, completing the current leg and
    /// <br/>starting the next. If this completes the final leg, journey status
    /// <br/>transitions to arrived. Publishes transit.journey.waypoint-reached
    /// <br/>or transit.journey.arrived accordingly.
    /// </remarks>

    /// <returns>Journey advanced</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> AdvanceJourneyAsync(AdvanceJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Advance multiple journeys in a single call
    /// </summary>

    /// <remarks>
    /// Advance multiple journeys in a single call for game SDK efficiency at
    /// <br/>NPC scale (10,000+ concurrent journeys). Each advance is processed
    /// <br/>independently — failure of one does not roll back others. Results
    /// <br/>include per-journey success/failure with error details. Ordering within
    /// <br/>the batch is preserved for cases where the same journeyId appears
    /// <br/>multiple times (advancing through multiple waypoints in a single tick).
    /// </remarks>

    /// <returns>Batch processed (check individual results for per-journey errors)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AdvanceBatchResponse>> AdvanceBatchJourneysAsync(AdvanceBatchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Force-arrive a journey at destination
    /// </summary>

    /// <remarks>
    /// Force-arrive a journey at its destination, skipping remaining legs.
    /// <br/>Remaining legs are marked as skipped rather than completed. Used for
    /// <br/>narrative fast-travel, teleportation, or game-driven skip.
    /// <br/>Publishes transit.journey.arrived event.
    /// </remarks>

    /// <returns>Journey force-arrived</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> ArriveJourneyAsync(ArriveJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Interrupt an active journey
    /// </summary>

    /// <remarks>
    /// Interrupt an active journey due to combat, event, or breakdown.
    /// <br/>Transitions status to interrupted. To resume, call /transit/journey/resume.
    /// <br/>To abandon, call /transit/journey/abandon.
    /// <br/>Publishes transit.journey.interrupted event.
    /// </remarks>

    /// <returns>Journey interrupted</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> InterruptJourneyAsync(InterruptJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Abandon a journey
    /// </summary>

    /// <remarks>
    /// Abandon a journey. The entity stays at its current location.
    /// <br/>Publishes transit.journey.abandoned event.
    /// </remarks>

    /// <returns>Journey abandoned</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> AbandonJourneyAsync(AbandonJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get a journey by ID
    /// </summary>

    /// <remarks>
    /// Retrieve a journey by its unique ID.
    /// </remarks>

    /// <returns>Journey found</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> GetJourneyAsync(GetJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List active journeys on a specific connection
    /// </summary>

    /// <remarks>
    /// List active journeys currently traversing a specific connection.
    /// <br/>Enables queries like "who is on this road?" for encounter generation,
    /// <br/>bandit ambush targeting, caravan interception, and road traffic monitoring.
    /// </remarks>

    /// <returns>Journeys queried</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListJourneysResponse>> QueryJourneysByConnectionAsync(QueryJourneysByConnectionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List journeys for an entity or within a realm
    /// </summary>

    /// <remarks>
    /// List journeys with optional filtering by entity, entity type, realm,
    /// <br/>cross-realm status, journey status, and active-only flag.
    /// </remarks>

    /// <returns>Journeys listed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListJourneysResponse>> ListJourneysAsync(ListJourneysRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Query archived journeys from MySQL historical store
    /// </summary>

    /// <remarks>
    /// Query archived (completed/abandoned) journeys from the MySQL historical
    /// <br/>store. Used by Trade (velocity calculations), Analytics (travel patterns),
    /// <br/>and Character History (travel biography generation).
    /// </remarks>

    /// <returns>Archived journeys queried</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListJourneysResponse>> QueryJourneyArchiveAsync(QueryJourneyArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Calculate route options between two locations
    /// </summary>

    /// <remarks>
    /// Calculate route options between two locations. Pure computation endpoint
    /// <br/>with no state mutation. Performs Dijkstra graph search over the connection
    /// <br/>graph filtered by mode compatibility, seasonal availability, and discovery
    /// <br/>status. Does NOT apply entity-specific DI cost modifiers (those are applied
    /// <br/>by the variable provider when GOAP evaluates the results).
    /// </remarks>

    /// <returns>Route options calculated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CalculateRouteResponse>> CalculateRouteAsync(CalculateRouteRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Reveal a discoverable connection to an entity
    /// </summary>

    /// <remarks>
    /// Reveal a discoverable connection to an entity via explicit grant.
    /// <br/>Also called internally by journey/advance when a leg uses a discoverable
    /// <br/>connection. Hearsay (L4) calls this when propagating route knowledge
    /// <br/>via rumor. Publishes transit.discovery.revealed event for new discoveries.
    /// </remarks>

    /// <returns>Discovery recorded</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RevealDiscoveryResponse>> RevealDiscoveryAsync(RevealDiscoveryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List connections an entity has discovered
    /// </summary>

    /// <remarks>
    /// List all discoverable connections that an entity has discovered, with optional realm filtering.
    /// </remarks>

    /// <returns>Discoveries listed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListDiscoveriesResponse>> ListDiscoveriesAsync(ListDiscoveriesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Check if an entity has discovered specific connections
    /// </summary>

    /// <remarks>
    /// Check whether an entity has discovered each of the specified connections.
    /// </remarks>

    /// <returns>Discovery status checked</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CheckDiscoveriesResponse>> CheckDiscoveriesAsync(CheckDiscoveriesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Clean up transit data for a deleted location
    /// </summary>

    /// <remarks>
    /// Called by lib-resource when a location is deleted. Closes all connections
    /// <br/>referencing the deleted location and interrupts active journeys passing
    /// <br/>through it. Internal cleanup callback, not exposed to WebSocket clients.
    /// </remarks>

    /// <returns>Cleanup completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> CleanupByLocationAsync(CleanupByLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Clean up transit data for a deleted character
    /// </summary>

    /// <remarks>
    /// Called by lib-resource when a character is deleted. Clears discovery
    /// <br/>data for the deleted entity and abandons any active journeys.
    /// <br/>Internal cleanup callback, not exposed to WebSocket clients.
    /// </remarks>

    /// <returns>Cleanup completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> CleanupByCharacterAsync(CleanupByCharacterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class TransitController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private ITransitService _implementation;
    private BeyondImmersion.BannouService.Services.ITelemetryProvider _telemetryProvider;

    public TransitController(ITransitService implementation, BeyondImmersion.BannouService.Services.ITelemetryProvider telemetryProvider)
    {
        _implementation = implementation;
        _telemetryProvider = telemetryProvider;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Register a new transit mode type
    /// </summary>
    /// <remarks>
    /// Register a new transit mode type with movement properties, terrain
    /// <br/>compatibility, entity restrictions, and requirements. Mode codes are
    /// <br/>unique string identifiers (e.g., "walking", "horseback", "wagon").
    /// </remarks>
    /// <returns>Mode registered successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/mode/register")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ModeResponse>> RegisterMode([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RegisterModeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.RegisterMode",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/mode/register");
        try
        {

            var (statusCode, result) = await _implementation.RegisterModeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/mode/register");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/mode/register");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "RegisterMode",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/mode/register",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get a transit mode by code
    /// </summary>
    /// <remarks>
    /// Retrieve a transit mode definition by its unique code.
    /// </remarks>
    /// <returns>Mode found</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/mode/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ModeResponse>> GetMode([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetModeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.GetMode",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/mode/get");
        try
        {

            var (statusCode, result) = await _implementation.GetModeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/mode/get");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/mode/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "GetMode",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/mode/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List all registered transit modes
    /// </summary>
    /// <remarks>
    /// List transit modes with optional filtering by realm availability,
    /// <br/>terrain compatibility, tags, and deprecation status.
    /// </remarks>
    /// <returns>Modes listed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/mode/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListModesResponse>> ListModes([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListModesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.ListModes",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/mode/list");
        try
        {

            var (statusCode, result) = await _implementation.ListModesAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/mode/list");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/mode/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "ListModes",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/mode/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update a transit mode's properties
    /// </summary>
    /// <remarks>
    /// Update properties of an existing transit mode. Only provided fields
    /// <br/>are updated; null fields are left unchanged.
    /// </remarks>
    /// <returns>Mode updated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/mode/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ModeResponse>> UpdateMode([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateModeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.UpdateMode",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/mode/update");
        try
        {

            var (statusCode, result) = await _implementation.UpdateModeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/mode/update");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/mode/update");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "UpdateMode",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/mode/update",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Deprecate a transit mode
    /// </summary>
    /// <remarks>
    /// Deprecate a transit mode. Existing journeys using this mode continue,
    /// <br/>but new journeys cannot use it. Sets the triple-field deprecation model:
    /// <br/>isDeprecated=true, deprecatedAt=now, deprecationReason=reason.
    /// <br/>Idempotent: returns OK if already deprecated (caller's intent is satisfied).
    /// <br/>Category A per IMPLEMENTATION TENETS: connections store compatibleModes
    /// <br/>and journeys store primaryModeCode/legModes referencing mode codes.
    /// </remarks>
    /// <returns>Mode deprecated (or already deprecated)</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/mode/deprecate")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ModeResponse>> DeprecateMode([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeprecateModeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.DeprecateMode",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/mode/deprecate");
        try
        {

            var (statusCode, result) = await _implementation.DeprecateModeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/mode/deprecate");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/mode/deprecate");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "DeprecateMode",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/mode/deprecate",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Reverse deprecation of a transit mode
    /// </summary>
    /// <remarks>
    /// Reverse deprecation of a transit mode (Category A — undeprecate is required).
    /// <br/>Clears isDeprecated, deprecatedAt, deprecationReason.
    /// <br/>Idempotent: returns OK if not currently deprecated.
    /// </remarks>
    /// <returns>Mode undeprecated (or was not deprecated)</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/mode/undeprecate")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ModeResponse>> UndeprecateMode([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UndeprecateModeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.UndeprecateMode",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/mode/undeprecate");
        try
        {

            var (statusCode, result) = await _implementation.UndeprecateModeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/mode/undeprecate");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/mode/undeprecate");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "UndeprecateMode",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/mode/undeprecate",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Delete a deprecated transit mode
    /// </summary>
    /// <remarks>
    /// Delete a deprecated transit mode (Category A — must be deprecated before
    /// <br/>deletion). Rejects if active journeys use this mode or if connections
    /// <br/>still list this mode in compatibleModes. Archived journeys retain the
    /// <br/>mode code as historical data.
    /// </remarks>
    /// <returns>Mode deleted</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/mode/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteModeResponse>> DeleteMode([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteModeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.DeleteMode",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/mode/delete");
        try
        {

            var (statusCode, result) = await _implementation.DeleteModeAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/mode/delete");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/mode/delete");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "DeleteMode",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/mode/delete",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Check which transit modes an entity can currently use
    /// </summary>
    /// <remarks>
    /// Check mode availability for an entity based on item requirements,
    /// <br/>species restrictions, entity type restrictions, and optional location
    /// <br/>context. Also applies ITransitCostModifierProvider enrichment to
    /// <br/>compute preferenceCost and effectiveSpeed adjustments.
    /// </remarks>
    /// <returns>Availability checked</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/mode/check-availability")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CheckModeAvailabilityResponse>> CheckModeAvailability([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CheckModeAvailabilityRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.CheckModeAvailability",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/mode/check-availability");
        try
        {

            var (statusCode, result) = await _implementation.CheckModeAvailabilityAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/mode/check-availability");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/mode/check-availability");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "CheckModeAvailability",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/mode/check-availability",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Create a connection between two locations
    /// </summary>
    /// <remarks>
    /// Create a directed or bidirectional connection between two locations.
    /// <br/>fromRealmId, toRealmId, and crossRealm are derived from the locations
    /// <br/>via the Location service. Season keys in seasonalAvailability are
    /// <br/>validated against the realm's Worldstate season codes.
    /// </remarks>
    /// <returns>Connection created</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/connection/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConnectionResponse>> CreateConnection([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateConnectionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.CreateConnection",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/connection/create");
        try
        {

            var (statusCode, result) = await _implementation.CreateConnectionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/connection/create");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/connection/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "CreateConnection",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/connection/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get a connection by ID or code
    /// </summary>
    /// <remarks>
    /// Retrieve a connection by its unique ID or code. One of connectionId or code must be provided.
    /// </remarks>
    /// <returns>Connection found</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/connection/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConnectionResponse>> GetConnection([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetConnectionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.GetConnection",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/connection/get");
        try
        {

            var (statusCode, result) = await _implementation.GetConnectionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/connection/get");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/connection/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "GetConnection",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/connection/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Query connections by location, terrain, mode, or status
    /// </summary>
    /// <remarks>
    /// Query connections with optional filters. All filters are optional;
    /// <br/>an empty request returns all connections paginated.
    /// </remarks>
    /// <returns>Connections queried</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/connection/query")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryConnectionsResponse>> QueryConnections([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryConnectionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.QueryConnections",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/connection/query");
        try
        {

            var (statusCode, result) = await _implementation.QueryConnectionsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/connection/query");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/connection/query");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "QueryConnections",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/connection/query",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Update a connection's properties
    /// </summary>
    /// <remarks>
    /// Update properties of an existing connection. Does not update status —
    /// <br/>use update-status for operational status changes. Only provided fields
    /// <br/>are updated; null fields are left unchanged.
    /// </remarks>
    /// <returns>Connection updated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/connection/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConnectionResponse>> UpdateConnection([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateConnectionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.UpdateConnection",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/connection/update");
        try
        {

            var (statusCode, result) = await _implementation.UpdateConnectionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/connection/update");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/connection/update");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "UpdateConnection",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/connection/update",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Transition a connection's operational status with optimistic concurrency
    /// </summary>
    /// <remarks>
    /// Transition a connection's operational status using optimistic concurrency.
    /// <br/>Caller specifies currentStatus (what they believe the status is) and
    /// <br/>newStatus. If the actual status does not match currentStatus, returns
    /// <br/>Bad Request with the actual status. Use forceUpdate=true for administrative
    /// <br/>overrides where currentStatus is ignored. The seasonal_closed status is
    /// <br/>typically only set by the Seasonal Connection Worker via forceUpdate=true.
    /// </remarks>
    /// <returns>Status updated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/connection/update-status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConnectionResponse>> UpdateConnectionStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateConnectionStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.UpdateConnectionStatus",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/connection/update-status");
        try
        {

            var (statusCode, result) = await _implementation.UpdateConnectionStatusAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/connection/update-status");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/connection/update-status");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "UpdateConnectionStatus",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/connection/update-status",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Delete a connection between locations
    /// </summary>
    /// <remarks>
    /// Delete a connection. Rejects if active journeys are currently using
    /// <br/>this connection.
    /// </remarks>
    /// <returns>Connection deleted</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/connection/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteConnectionResponse>> DeleteConnection([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteConnectionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.DeleteConnection",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/connection/delete");
        try
        {

            var (statusCode, result) = await _implementation.DeleteConnectionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/connection/delete");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/connection/delete");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "DeleteConnection",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/connection/delete",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Seed connections from configuration
    /// </summary>
    /// <remarks>
    /// Seed connections from configuration using location codes resolved via
    /// <br/>the Location service. Two-pass resolution: first pass creates connections
    /// <br/>with location code lookup, second pass validates all mode codes exist.
    /// <br/>When realmId is provided, location codes are resolved within that realm
    /// <br/>and replaceExisting deletes connections for that realm only.
    /// </remarks>
    /// <returns>Bulk seed completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/connection/bulk-seed")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BulkSeedConnectionsResponse>> BulkSeedConnections([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BulkSeedConnectionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.BulkSeedConnections",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/connection/bulk-seed");
        try
        {

            var (statusCode, result) = await _implementation.BulkSeedConnectionsAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/connection/bulk-seed");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/connection/bulk-seed");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "BulkSeedConnections",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/connection/bulk-seed",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Plan a journey (status preparing)
    /// </summary>
    /// <remarks>
    /// Plan a journey from origin to destination. Internally calls route/calculate
    /// <br/>to find the best path and populate legs. Checks mode compatibility via
    /// <br/>check-availability. Does NOT start the journey — call /transit/journey/depart
    /// <br/>for that. When preferMultiModal is true, each leg gets the fastest compatible
    /// <br/>mode the entity can use on that connection.
    /// </remarks>
    /// <returns>Journey planned</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/journey/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> CreateJourney([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.CreateJourney",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/journey/create");
        try
        {

            var (statusCode, result) = await _implementation.CreateJourneyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/journey/create");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/journey/create");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "CreateJourney",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/journey/create",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Start a prepared journey
    /// </summary>
    /// <remarks>
    /// Start a prepared journey, transitioning status from preparing to in_transit.
    /// <br/>Publishes transit.journey.departed event.
    /// </remarks>
    /// <returns>Journey started</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/journey/depart")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> DepartJourney([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DepartJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.DepartJourney",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/journey/depart");
        try
        {

            var (statusCode, result) = await _implementation.DepartJourneyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/journey/depart");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/journey/depart");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "DepartJourney",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/journey/depart",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Resume an interrupted journey
    /// </summary>
    /// <remarks>
    /// Resume an interrupted journey, transitioning status from interrupted
    /// <br/>to in_transit. Distinct from depart: depart is for initial departure
    /// <br/>(preparing to in_transit), resume is for continuing after interruption.
    /// <br/>Publishes transit.journey.resumed event.
    /// </remarks>
    /// <returns>Journey resumed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/journey/resume")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> ResumeJourney([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ResumeJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.ResumeJourney",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/journey/resume");
        try
        {

            var (statusCode, result) = await _implementation.ResumeJourneyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/journey/resume");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/journey/resume");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "ResumeJourney",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/journey/resume",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Mark arrival at next waypoint
    /// </summary>
    /// <remarks>
    /// Mark arrival at the next waypoint, completing the current leg and
    /// <br/>starting the next. If this completes the final leg, journey status
    /// <br/>transitions to arrived. Publishes transit.journey.waypoint-reached
    /// <br/>or transit.journey.arrived accordingly.
    /// </remarks>
    /// <returns>Journey advanced</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/journey/advance")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> AdvanceJourney([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AdvanceJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.AdvanceJourney",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/journey/advance");
        try
        {

            var (statusCode, result) = await _implementation.AdvanceJourneyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/journey/advance");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/journey/advance");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "AdvanceJourney",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/journey/advance",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Advance multiple journeys in a single call
    /// </summary>
    /// <remarks>
    /// Advance multiple journeys in a single call for game SDK efficiency at
    /// <br/>NPC scale (10,000+ concurrent journeys). Each advance is processed
    /// <br/>independently — failure of one does not roll back others. Results
    /// <br/>include per-journey success/failure with error details. Ordering within
    /// <br/>the batch is preserved for cases where the same journeyId appears
    /// <br/>multiple times (advancing through multiple waypoints in a single tick).
    /// </remarks>
    /// <returns>Batch processed (check individual results for per-journey errors)</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/journey/advance-batch")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AdvanceBatchResponse>> AdvanceBatchJourneys([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AdvanceBatchRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.AdvanceBatchJourneys",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/journey/advance-batch");
        try
        {

            var (statusCode, result) = await _implementation.AdvanceBatchJourneysAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/journey/advance-batch");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/journey/advance-batch");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "AdvanceBatchJourneys",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/journey/advance-batch",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Force-arrive a journey at destination
    /// </summary>
    /// <remarks>
    /// Force-arrive a journey at its destination, skipping remaining legs.
    /// <br/>Remaining legs are marked as skipped rather than completed. Used for
    /// <br/>narrative fast-travel, teleportation, or game-driven skip.
    /// <br/>Publishes transit.journey.arrived event.
    /// </remarks>
    /// <returns>Journey force-arrived</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/journey/arrive")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> ArriveJourney([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ArriveJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.ArriveJourney",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/journey/arrive");
        try
        {

            var (statusCode, result) = await _implementation.ArriveJourneyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/journey/arrive");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/journey/arrive");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "ArriveJourney",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/journey/arrive",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Interrupt an active journey
    /// </summary>
    /// <remarks>
    /// Interrupt an active journey due to combat, event, or breakdown.
    /// <br/>Transitions status to interrupted. To resume, call /transit/journey/resume.
    /// <br/>To abandon, call /transit/journey/abandon.
    /// <br/>Publishes transit.journey.interrupted event.
    /// </remarks>
    /// <returns>Journey interrupted</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/journey/interrupt")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> InterruptJourney([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] InterruptJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.InterruptJourney",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/journey/interrupt");
        try
        {

            var (statusCode, result) = await _implementation.InterruptJourneyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/journey/interrupt");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/journey/interrupt");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "InterruptJourney",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/journey/interrupt",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Abandon a journey
    /// </summary>
    /// <remarks>
    /// Abandon a journey. The entity stays at its current location.
    /// <br/>Publishes transit.journey.abandoned event.
    /// </remarks>
    /// <returns>Journey abandoned</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/journey/abandon")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> AbandonJourney([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AbandonJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.AbandonJourney",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/journey/abandon");
        try
        {

            var (statusCode, result) = await _implementation.AbandonJourneyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/journey/abandon");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/journey/abandon");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "AbandonJourney",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/journey/abandon",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Get a journey by ID
    /// </summary>
    /// <remarks>
    /// Retrieve a journey by its unique ID.
    /// </remarks>
    /// <returns>Journey found</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/journey/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<JourneyResponse>> GetJourney([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetJourneyRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.GetJourney",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/journey/get");
        try
        {

            var (statusCode, result) = await _implementation.GetJourneyAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/journey/get");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/journey/get");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "GetJourney",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/journey/get",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List active journeys on a specific connection
    /// </summary>
    /// <remarks>
    /// List active journeys currently traversing a specific connection.
    /// <br/>Enables queries like "who is on this road?" for encounter generation,
    /// <br/>bandit ambush targeting, caravan interception, and road traffic monitoring.
    /// </remarks>
    /// <returns>Journeys queried</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/journey/query-by-connection")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListJourneysResponse>> QueryJourneysByConnection([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryJourneysByConnectionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.QueryJourneysByConnection",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/journey/query-by-connection");
        try
        {

            var (statusCode, result) = await _implementation.QueryJourneysByConnectionAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/journey/query-by-connection");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/journey/query-by-connection");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "QueryJourneysByConnection",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/journey/query-by-connection",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List journeys for an entity or within a realm
    /// </summary>
    /// <remarks>
    /// List journeys with optional filtering by entity, entity type, realm,
    /// <br/>cross-realm status, journey status, and active-only flag.
    /// </remarks>
    /// <returns>Journeys listed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/journey/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListJourneysResponse>> ListJourneys([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListJourneysRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.ListJourneys",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/journey/list");
        try
        {

            var (statusCode, result) = await _implementation.ListJourneysAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/journey/list");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/journey/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "ListJourneys",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/journey/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Query archived journeys from MySQL historical store
    /// </summary>
    /// <remarks>
    /// Query archived (completed/abandoned) journeys from the MySQL historical
    /// <br/>store. Used by Trade (velocity calculations), Analytics (travel patterns),
    /// <br/>and Character History (travel biography generation).
    /// </remarks>
    /// <returns>Archived journeys queried</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/journey/query-archive")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListJourneysResponse>> QueryJourneyArchive([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryJourneyArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.QueryJourneyArchive",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/journey/query-archive");
        try
        {

            var (statusCode, result) = await _implementation.QueryJourneyArchiveAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/journey/query-archive");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/journey/query-archive");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "QueryJourneyArchive",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/journey/query-archive",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Calculate route options between two locations
    /// </summary>
    /// <remarks>
    /// Calculate route options between two locations. Pure computation endpoint
    /// <br/>with no state mutation. Performs Dijkstra graph search over the connection
    /// <br/>graph filtered by mode compatibility, seasonal availability, and discovery
    /// <br/>status. Does NOT apply entity-specific DI cost modifiers (those are applied
    /// <br/>by the variable provider when GOAP evaluates the results).
    /// </remarks>
    /// <returns>Route options calculated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/route/calculate")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CalculateRouteResponse>> CalculateRoute([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CalculateRouteRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.CalculateRoute",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/route/calculate");
        try
        {

            var (statusCode, result) = await _implementation.CalculateRouteAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/route/calculate");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/route/calculate");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "CalculateRoute",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/route/calculate",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Reveal a discoverable connection to an entity
    /// </summary>
    /// <remarks>
    /// Reveal a discoverable connection to an entity via explicit grant.
    /// <br/>Also called internally by journey/advance when a leg uses a discoverable
    /// <br/>connection. Hearsay (L4) calls this when propagating route knowledge
    /// <br/>via rumor. Publishes transit.discovery.revealed event for new discoveries.
    /// </remarks>
    /// <returns>Discovery recorded</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/discovery/reveal")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RevealDiscoveryResponse>> RevealDiscovery([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RevealDiscoveryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.RevealDiscovery",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/discovery/reveal");
        try
        {

            var (statusCode, result) = await _implementation.RevealDiscoveryAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/discovery/reveal");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/discovery/reveal");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "RevealDiscovery",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/discovery/reveal",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// List connections an entity has discovered
    /// </summary>
    /// <remarks>
    /// List all discoverable connections that an entity has discovered, with optional realm filtering.
    /// </remarks>
    /// <returns>Discoveries listed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/discovery/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListDiscoveriesResponse>> ListDiscoveries([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListDiscoveriesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.ListDiscoveries",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/discovery/list");
        try
        {

            var (statusCode, result) = await _implementation.ListDiscoveriesAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/discovery/list");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/discovery/list");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "ListDiscoveries",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/discovery/list",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Check if an entity has discovered specific connections
    /// </summary>
    /// <remarks>
    /// Check whether an entity has discovered each of the specified connections.
    /// </remarks>
    /// <returns>Discovery status checked</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/discovery/check")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CheckDiscoveriesResponse>> CheckDiscoveries([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CheckDiscoveriesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.CheckDiscoveries",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/discovery/check");
        try
        {

            var (statusCode, result) = await _implementation.CheckDiscoveriesAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode, result);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/discovery/check");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/discovery/check");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "CheckDiscoveries",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/discovery/check",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Clean up transit data for a deleted location
    /// </summary>
    /// <remarks>
    /// Called by lib-resource when a location is deleted. Closes all connections
    /// <br/>referencing the deleted location and interrupts active journeys passing
    /// <br/>through it. Internal cleanup callback, not exposed to WebSocket clients.
    /// </remarks>
    /// <returns>Cleanup completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/cleanup-by-location")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> CleanupByLocation([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CleanupByLocationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.CleanupByLocation",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/cleanup-by-location");
        try
        {

            var statusCode = await _implementation.CleanupByLocationAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/cleanup-by-location");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/cleanup-by-location");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "CleanupByLocation",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/cleanup-by-location",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

    /// <summary>
    /// Clean up transit data for a deleted character
    /// </summary>
    /// <remarks>
    /// Called by lib-resource when a character is deleted. Clears discovery
    /// <br/>data for the deleted entity and abandons any active journeys.
    /// <br/>Internal cleanup callback, not exposed to WebSocket clients.
    /// </remarks>
    /// <returns>Cleanup completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("transit/cleanup-by-character")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> CleanupByCharacter([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CleanupByCharacterRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        using var activity_ = _telemetryProvider.StartActivity(
            "bannou.transit",
            "TransitController.CleanupByCharacter",
            System.Diagnostics.ActivityKind.Server);
        activity_?.SetTag("http.route", "transit/cleanup-by-character");
        try
        {

            var statusCode = await _implementation.CleanupByCharacterAsync(body, cancellationToken);
            return ConvertToActionResult(statusCode);
        }
        catch (BeyondImmersion.Bannou.Core.ApiException ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger_, ex_, "Dependency error in {Endpoint}", "post:transit/cleanup-by-character");
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, "Dependency error");
            return StatusCode(503);
        }
        catch (System.Exception ex_)
        {
            var logger_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<TransitController>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger_, ex_, "Unexpected error in {Endpoint}", "post:transit/cleanup-by-character");
            var messageBus_ = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<BeyondImmersion.BannouService.Services.IMessageBus>(HttpContext.RequestServices);
            await messageBus_.TryPublishErrorAsync(
                "transit",
                "CleanupByCharacter",
                "unexpected_exception",
                ex_.Message,
                endpoint: "post:transit/cleanup-by-character",
                stack: ex_.StackTrace,
                cancellationToken: cancellationToken);
            activity_?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, ex_.Message);
            return StatusCode(500);
        }
    }

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765