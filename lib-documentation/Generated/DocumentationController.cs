//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#nullable enable

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8600 // Disable "CS8600 Converting null literal or possible null value to non-nullable type"
#pragma warning disable 8602 // Disable "CS8602 Dereference of a possibly null reference"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace BeyondImmersion.BannouService.Documentation;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IDocumentationController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// View documentation page in browser
    /// </summary>

    /// <remarks>
    /// Browser-facing endpoint for viewing documentation.
    /// <br/>Routed via NGINX, not exposed to WebSocket clients.
    /// <br/>Returns HTML-rendered documentation page.
    /// </remarks>

    /// <param name="slug">Document slug within namespace</param>

    /// <param name="ns">Documentation namespace (defaults to bannou)</param>

    /// <returns>HTML documentation page (returns ContentResult)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> ViewDocumentBySlugAsync(string slug, string ns, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Natural language documentation search
    /// </summary>

    /// <remarks>
    /// Search documentation using natural language queries.
    /// <br/>Returns the most relevant documents with voice-friendly summaries.
    /// </remarks>

    /// <returns>Search results with voice-friendly summaries</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryDocumentationResponse>> QueryDocumentationAsync(QueryDocumentationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get specific document by ID or slug
    /// </summary>

    /// <remarks>
    /// Retrieve a specific document by its unique identifier or slug.
    /// <br/>Returns full content with metadata.
    /// </remarks>

    /// <returns>Document content</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetDocumentResponse>> GetDocumentAsync(GetDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Full-text keyword search
    /// </summary>

    /// <remarks>
    /// Search documentation using exact keyword matching.
    /// <br/>Faster than semantic search but less flexible.
    /// </remarks>

    /// <returns>Matching documents</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SearchDocumentationResponse>> SearchDocumentationAsync(SearchDocumentationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List documents by category
    /// </summary>

    /// <remarks>
    /// List all documents in a specific category or all categories.
    /// <br/>Supports pagination for large result sets.
    /// </remarks>

    /// <returns>Document list</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListDocumentsResponse>> ListDocumentsAsync(ListDocumentsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get related topics and follow-up suggestions
    /// </summary>

    /// <remarks>
    /// Given a topic or document ID, returns related topics the user
    /// <br/>might want to explore. Useful for conversational AI flow.
    /// </remarks>

    /// <returns>Related topics</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SuggestRelatedResponse>> SuggestRelatedTopicsAsync(SuggestRelatedRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create new documentation entry
    /// </summary>


    /// <returns>Document created</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateDocumentResponse>> CreateDocumentAsync(CreateDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update existing documentation entry
    /// </summary>


    /// <returns>Document updated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateDocumentResponse>> UpdateDocumentAsync(UpdateDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Soft-delete documentation entry to trashcan
    /// </summary>

    /// <remarks>
    /// Moves document to trashcan for recovery within TTL period.
    /// <br/>Documents are automatically cleaned up after TrashcanTtlDays.
    /// </remarks>

    /// <returns>Document moved to trashcan</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteDocumentResponse>> DeleteDocumentAsync(DeleteDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Recover document from trashcan
    /// </summary>

    /// <remarks>
    /// Restores a soft-deleted document from the trashcan.
    /// <br/>Must be called before the trashcan TTL expires.
    /// </remarks>

    /// <returns>Document recovered</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RecoverDocumentResponse>> RecoverDocumentAsync(RecoverDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Bulk update document metadata
    /// </summary>

    /// <remarks>
    /// Apply category, tag, or metadata changes to multiple documents at once.
    /// <br/>Each document is processed independently - partial success is possible.
    /// </remarks>

    /// <returns>Bulk update results</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BulkUpdateResponse>> BulkUpdateDocumentsAsync(BulkUpdateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Bulk soft-delete documents to trashcan
    /// </summary>

    /// <remarks>
    /// Move multiple documents to trashcan at once.
    /// <br/>Each document is processed independently - partial success is possible.
    /// </remarks>

    /// <returns>Bulk delete results</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BulkDeleteResponse>> BulkDeleteDocumentsAsync(BulkDeleteRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Bulk import documentation from structured source
    /// </summary>

    /// <remarks>
    /// Import multiple documents. Each document processed independently.
    /// <br/>Partial success is possible - failures reported per document.
    /// </remarks>

    /// <returns>Import results (may include partial failures)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ImportDocumentationResponse>> ImportDocumentationAsync(ImportDocumentationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List documents in the trashcan
    /// </summary>

    /// <remarks>
    /// List all soft-deleted documents within the namespace's trashcan.
    /// <br/>Documents remain recoverable until TTL expires or purge is called.
    /// </remarks>

    /// <returns>Trashcan contents</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListTrashcanResponse>> ListTrashcanAsync(ListTrashcanRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Permanently delete trashcan items
    /// </summary>

    /// <remarks>
    /// Permanently delete specified documents from trashcan, or purge all.
    /// <br/>This operation is irreversible - documents cannot be recovered after purge.
    /// </remarks>

    /// <returns>Purge results</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PurgeTrashcanResponse>> PurgeTrashcanAsync(PurgeTrashcanRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get namespace documentation statistics
    /// </summary>

    /// <remarks>
    /// Retrieve usage statistics and metadata for a documentation namespace.
    /// <br/>Useful for monitoring, capacity planning, and administrative dashboards.
    /// </remarks>

    /// <returns>Namespace statistics</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<NamespaceStatsResponse>> GetNamespaceStatsAsync(GetNamespaceStatsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Bind a git repository to a documentation namespace
    /// </summary>

    /// <remarks>
    /// Bind a git repository URL to a documentation namespace.
    /// <br/>The namespace will be exclusively managed by the repository - manual edits will be blocked.
    /// <br/>Triggers initial sync after binding.
    /// </remarks>

    /// <returns>Repository binding created</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BindRepositoryResponse>> BindRepositoryAsync(BindRepositoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Remove repository binding from namespace
    /// </summary>

    /// <remarks>
    /// Remove repository binding from a namespace, making it manually editable again.
    /// <br/>Optionally delete all documents imported from the repository.
    /// </remarks>

    /// <returns>Repository binding removed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UnbindRepositoryResponse>> UnbindRepositoryAsync(UnbindRepositoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Manually trigger repository sync
    /// </summary>

    /// <remarks>
    /// Manually trigger synchronization of a bound repository.
    /// <br/>If force=true, performs full re-sync regardless of commit hash.
    /// </remarks>

    /// <returns>Sync completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SyncRepositoryResponse>> SyncRepositoryAsync(SyncRepositoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get repository binding status
    /// </summary>

    /// <remarks>
    /// Get current status of a repository binding including sync state and statistics.
    /// </remarks>

    /// <returns>Repository binding status</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RepositoryStatusResponse>> GetRepositoryStatusAsync(RepositoryStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all repository bindings
    /// </summary>

    /// <remarks>
    /// List all repository bindings with optional filtering by status.
    /// </remarks>

    /// <returns>List of repository bindings</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListRepositoryBindingsResponse>> ListRepositoryBindingsAsync(ListRepositoryBindingsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update repository binding configuration
    /// </summary>

    /// <remarks>
    /// Update sync settings, file patterns, category mappings, or archive configuration.
    /// </remarks>

    /// <returns>Repository binding updated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateRepositoryBindingResponse>> UpdateRepositoryBindingAsync(UpdateRepositoryBindingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create documentation archive
    /// </summary>

    /// <remarks>
    /// Create a .bannou bundle archive of all documents in a namespace.
    /// <br/>Archives are stored via Asset Service.
    /// </remarks>

    /// <returns>Archive created</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateArchiveResponse>> CreateDocumentationArchiveAsync(CreateArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List documentation archives
    /// </summary>

    /// <remarks>
    /// List all archives for a namespace.
    /// </remarks>

    /// <returns>List of archives</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListArchivesResponse>> ListDocumentationArchivesAsync(ListArchivesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Restore documentation from archive
    /// </summary>

    /// <remarks>
    /// Restore documents from a .bannou bundle archive.
    /// <br/>Replaces all documents in the namespace with archived content.
    /// </remarks>

    /// <returns>Archive restored</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RestoreArchiveResponse>> RestoreDocumentationArchiveAsync(RestoreArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete documentation archive
    /// </summary>

    /// <remarks>
    /// Delete an archive from Asset Service storage.
    /// </remarks>

    /// <returns>Archive deleted</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteArchiveResponse>> DeleteDocumentationArchiveAsync(DeleteArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class DocumentationController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IDocumentationService _implementation;

    public DocumentationController(IDocumentationService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.Created => Created("", result),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.Created => result != null ? Created("", result) : Created("", null),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    // Endpoint ViewDocumentBySlug requires manual implementation in partial class.
    // See x-manual-implementation: true in the OpenAPI schema.

    /// <summary>
    /// Natural language documentation search
    /// </summary>
    /// <remarks>
    /// Search documentation using natural language queries.
    /// <br/>Returns the most relevant documents with voice-friendly summaries.
    /// </remarks>
    /// <returns>Search results with voice-friendly summaries</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/query")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryDocumentationResponse>> QueryDocumentation([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryDocumentationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.QueryDocumentationAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get specific document by ID or slug
    /// </summary>
    /// <remarks>
    /// Retrieve a specific document by its unique identifier or slug.
    /// <br/>Returns full content with metadata.
    /// </remarks>
    /// <returns>Document content</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetDocumentResponse>> GetDocument([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetDocumentAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Full-text keyword search
    /// </summary>
    /// <remarks>
    /// Search documentation using exact keyword matching.
    /// <br/>Faster than semantic search but less flexible.
    /// </remarks>
    /// <returns>Matching documents</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/search")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SearchDocumentationResponse>> SearchDocumentation([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SearchDocumentationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.SearchDocumentationAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List documents by category
    /// </summary>
    /// <remarks>
    /// List all documents in a specific category or all categories.
    /// <br/>Supports pagination for large result sets.
    /// </remarks>
    /// <returns>Document list</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListDocumentsResponse>> ListDocuments([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListDocumentsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListDocumentsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get related topics and follow-up suggestions
    /// </summary>
    /// <remarks>
    /// Given a topic or document ID, returns related topics the user
    /// <br/>might want to explore. Useful for conversational AI flow.
    /// </remarks>
    /// <returns>Related topics</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/suggest")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SuggestRelatedResponse>> SuggestRelatedTopics([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SuggestRelatedRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.SuggestRelatedTopicsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Create new documentation entry
    /// </summary>
    /// <returns>Document created</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateDocumentResponse>> CreateDocument([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateDocumentAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Update existing documentation entry
    /// </summary>
    /// <returns>Document updated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateDocumentResponse>> UpdateDocument([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateDocumentAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Soft-delete documentation entry to trashcan
    /// </summary>
    /// <remarks>
    /// Moves document to trashcan for recovery within TTL period.
    /// <br/>Documents are automatically cleaned up after TrashcanTtlDays.
    /// </remarks>
    /// <returns>Document moved to trashcan</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteDocumentResponse>> DeleteDocument([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DeleteDocumentAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Recover document from trashcan
    /// </summary>
    /// <remarks>
    /// Restores a soft-deleted document from the trashcan.
    /// <br/>Must be called before the trashcan TTL expires.
    /// </remarks>
    /// <returns>Document recovered</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/recover")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RecoverDocumentResponse>> RecoverDocument([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RecoverDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RecoverDocumentAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Bulk update document metadata
    /// </summary>
    /// <remarks>
    /// Apply category, tag, or metadata changes to multiple documents at once.
    /// <br/>Each document is processed independently - partial success is possible.
    /// </remarks>
    /// <returns>Bulk update results</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BulkUpdateResponse>> BulkUpdateDocuments([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BulkUpdateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.BulkUpdateDocumentsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Bulk soft-delete documents to trashcan
    /// </summary>
    /// <remarks>
    /// Move multiple documents to trashcan at once.
    /// <br/>Each document is processed independently - partial success is possible.
    /// </remarks>
    /// <returns>Bulk delete results</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BulkDeleteResponse>> BulkDeleteDocuments([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BulkDeleteRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.BulkDeleteDocumentsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Bulk import documentation from structured source
    /// </summary>
    /// <remarks>
    /// Import multiple documents. Each document processed independently.
    /// <br/>Partial success is possible - failures reported per document.
    /// </remarks>
    /// <returns>Import results (may include partial failures)</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/import")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ImportDocumentationResponse>> ImportDocumentation([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ImportDocumentationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ImportDocumentationAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List documents in the trashcan
    /// </summary>
    /// <remarks>
    /// List all soft-deleted documents within the namespace's trashcan.
    /// <br/>Documents remain recoverable until TTL expires or purge is called.
    /// </remarks>
    /// <returns>Trashcan contents</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/trashcan")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListTrashcanResponse>> ListTrashcan([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListTrashcanRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListTrashcanAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Permanently delete trashcan items
    /// </summary>
    /// <remarks>
    /// Permanently delete specified documents from trashcan, or purge all.
    /// <br/>This operation is irreversible - documents cannot be recovered after purge.
    /// </remarks>
    /// <returns>Purge results</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/purge")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PurgeTrashcanResponse>> PurgeTrashcan([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] PurgeTrashcanRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.PurgeTrashcanAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get namespace documentation statistics
    /// </summary>
    /// <remarks>
    /// Retrieve usage statistics and metadata for a documentation namespace.
    /// <br/>Useful for monitoring, capacity planning, and administrative dashboards.
    /// </remarks>
    /// <returns>Namespace statistics</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/stats")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<NamespaceStatsResponse>> GetNamespaceStats([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetNamespaceStatsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetNamespaceStatsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Bind a git repository to a documentation namespace
    /// </summary>
    /// <remarks>
    /// Bind a git repository URL to a documentation namespace.
    /// <br/>The namespace will be exclusively managed by the repository - manual edits will be blocked.
    /// <br/>Triggers initial sync after binding.
    /// </remarks>
    /// <returns>Repository binding created</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/bind")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BindRepositoryResponse>> BindRepository([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BindRepositoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.BindRepositoryAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Remove repository binding from namespace
    /// </summary>
    /// <remarks>
    /// Remove repository binding from a namespace, making it manually editable again.
    /// <br/>Optionally delete all documents imported from the repository.
    /// </remarks>
    /// <returns>Repository binding removed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/unbind")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UnbindRepositoryResponse>> UnbindRepository([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UnbindRepositoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UnbindRepositoryAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Manually trigger repository sync
    /// </summary>
    /// <remarks>
    /// Manually trigger synchronization of a bound repository.
    /// <br/>If force=true, performs full re-sync regardless of commit hash.
    /// </remarks>
    /// <returns>Sync completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/sync")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SyncRepositoryResponse>> SyncRepository([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SyncRepositoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.SyncRepositoryAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get repository binding status
    /// </summary>
    /// <remarks>
    /// Get current status of a repository binding including sync state and statistics.
    /// </remarks>
    /// <returns>Repository binding status</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RepositoryStatusResponse>> GetRepositoryStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RepositoryStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetRepositoryStatusAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List all repository bindings
    /// </summary>
    /// <remarks>
    /// List all repository bindings with optional filtering by status.
    /// </remarks>
    /// <returns>List of repository bindings</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListRepositoryBindingsResponse>> ListRepositoryBindings([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListRepositoryBindingsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListRepositoryBindingsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Update repository binding configuration
    /// </summary>
    /// <remarks>
    /// Update sync settings, file patterns, category mappings, or archive configuration.
    /// </remarks>
    /// <returns>Repository binding updated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateRepositoryBindingResponse>> UpdateRepositoryBinding([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateRepositoryBindingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateRepositoryBindingAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Create documentation archive
    /// </summary>
    /// <remarks>
    /// Create a .bannou bundle archive of all documents in a namespace.
    /// <br/>Archives are stored via Asset Service.
    /// </remarks>
    /// <returns>Archive created</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateArchiveResponse>> CreateDocumentationArchive([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateDocumentationArchiveAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List documentation archives
    /// </summary>
    /// <remarks>
    /// List all archives for a namespace.
    /// </remarks>
    /// <returns>List of archives</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListArchivesResponse>> ListDocumentationArchives([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListArchivesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListDocumentationArchivesAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Restore documentation from archive
    /// </summary>
    /// <remarks>
    /// Restore documents from a .bannou bundle archive.
    /// <br/>Replaces all documents in the namespace with archived content.
    /// </remarks>
    /// <returns>Archive restored</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/restore")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RestoreArchiveResponse>> RestoreDocumentationArchive([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RestoreArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RestoreDocumentationArchiveAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Delete documentation archive
    /// </summary>
    /// <remarks>
    /// Delete an archive from Asset Service storage.
    /// </remarks>
    /// <returns>Archive deleted</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteArchiveResponse>> DeleteDocumentationArchive([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DeleteDocumentationArchiveAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }



    #region Meta Endpoints for ViewDocumentBySlug

    private static readonly string _ViewDocumentBySlug_RequestSchema = """
{}
""";

    private static readonly string _ViewDocumentBySlug_ResponseSchema = """
{}
""";

    private static readonly string _ViewDocumentBySlug_Info = """
{
  "summary": "View documentation page in browser",
  "description": "Browser-facing endpoint for viewing documentation.\nRouted via NGINX, not exposed to WebSocket clients.\nReturns HTML-rendered documentation page.\n",
  "tags": [
    "Browser"
  ],
  "deprecated": false,
  "operationId": "viewDocumentBySlug"
}
""";

    /// <summary>Returns endpoint information for ViewDocumentBySlug</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/view/{slug}/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ViewDocumentBySlug_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Get",
            "documentation/view/{slug}",
            _ViewDocumentBySlug_Info));

    /// <summary>Returns request schema for ViewDocumentBySlug</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/view/{slug}/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ViewDocumentBySlug_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Get",
            "documentation/view/{slug}",
            "request-schema",
            _ViewDocumentBySlug_RequestSchema));

    /// <summary>Returns response schema for ViewDocumentBySlug</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/view/{slug}/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ViewDocumentBySlug_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Get",
            "documentation/view/{slug}",
            "response-schema",
            _ViewDocumentBySlug_ResponseSchema));

    /// <summary>Returns full schema for ViewDocumentBySlug</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/view/{slug}/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ViewDocumentBySlug_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Get",
            "documentation/view/{slug}",
            _ViewDocumentBySlug_Info,
            _ViewDocumentBySlug_RequestSchema,
            _ViewDocumentBySlug_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryDocumentation

    private static readonly string _QueryDocumentation_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/QueryDocumentationRequest",
  "$defs": {
    "QueryDocumentationRequest": {
      "type": "object",
      "required": [
        "namespace",
        "query"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50,
          "description": "Documentation namespace"
        },
        "query": {
          "type": "string",
          "minLength": 3,
          "maxLength": 500,
          "description": "Natural language query"
        },
        "sessionId": {
          "type": "string",
          "format": "uuid",
          "description": "Optional session ID for conversational context"
        },
        "category": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "maxResults": {
          "type": "integer",
          "default": 5,
          "minimum": 1,
          "maximum": 20
        },
        "includeContent": {
          "type": "boolean",
          "default": false
        },
        "maxSummaryLength": {
          "type": "integer",
          "default": 300,
          "minimum": 50,
          "maximum": 500
        },
        "minRelevanceScore": {
          "type": "number",
          "format": "float",
          "default": 0.3,
          "minimum": 0.0,
          "maximum": 1.0
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    }
  }
}
""";

    private static readonly string _QueryDocumentation_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/QueryDocumentationResponse",
  "$defs": {
    "QueryDocumentationResponse": {
      "type": "object",
      "required": [
        "namespace",
        "query",
        "results"
      ],
      "properties": {
        "namespace": {
          "type": "string"
        },
        "query": {
          "type": "string"
        },
        "results": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/DocumentResult"
          }
        },
        "totalResults": {
          "type": "integer"
        },
        "voiceSummary": {
          "type": "string",
          "description": "Concise spoken summary for voice AI"
        },
        "suggestedFollowups": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "noResultsMessage": {
          "type": "string"
        }
      }
    },
    "DocumentResult": {
      "type": "object",
      "required": [
        "documentId",
        "slug",
        "title",
        "relevanceScore"
      ],
      "properties": {
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "slug": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "category": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "summary": {
          "type": "string"
        },
        "voiceSummary": {
          "type": "string"
        },
        "content": {
          "type": "string"
        },
        "relevanceScore": {
          "type": "number",
          "format": "float"
        },
        "matchHighlights": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    }
  }
}
""";

    private static readonly string _QueryDocumentation_Info = """
{
  "summary": "Natural language documentation search",
  "description": "Search documentation using natural language queries.\nReturns the most relevant documents with voice-friendly summaries.\n",
  "tags": [
    "Search"
  ],
  "deprecated": false,
  "operationId": "queryDocumentation"
}
""";

    /// <summary>Returns endpoint information for QueryDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/query/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryDocumentation_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/query",
            _QueryDocumentation_Info));

    /// <summary>Returns request schema for QueryDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/query/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryDocumentation_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/query",
            "request-schema",
            _QueryDocumentation_RequestSchema));

    /// <summary>Returns response schema for QueryDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/query/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryDocumentation_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/query",
            "response-schema",
            _QueryDocumentation_ResponseSchema));

    /// <summary>Returns full schema for QueryDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/query/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryDocumentation_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/query",
            _QueryDocumentation_Info,
            _QueryDocumentation_RequestSchema,
            _QueryDocumentation_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetDocument

    private static readonly string _GetDocument_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetDocumentRequest",
  "$defs": {
    "GetDocumentRequest": {
      "type": "object",
      "required": [
        "namespace"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "slug": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$"
        },
        "sessionId": {
          "type": "string",
          "format": "uuid"
        },
        "includeRelated": {
          "$ref": "#/$defs/RelatedDepth"
        },
        "includeContent": {
          "type": "boolean",
          "default": false
        },
        "renderHtml": {
          "type": "boolean",
          "default": false
        }
      }
    },
    "RelatedDepth": {
      "type": "string",
      "enum": [
        "none",
        "direct",
        "extended"
      ],
      "default": "direct",
      "description": "How deep to traverse related document links:\n- none: No related documents included\n- direct: Only directly linked documents (depth 1)\n- extended: Related documents + their related documents (depth 2)\n"
    }
  }
}
""";

    private static readonly string _GetDocument_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetDocumentResponse",
  "$defs": {
    "GetDocumentResponse": {
      "type": "object",
      "required": [
        "document"
      ],
      "properties": {
        "document": {
          "$ref": "#/$defs/Document"
        },
        "relatedDocuments": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/DocumentSummary"
          }
        },
        "contentFormat": {
          "type": "string",
          "enum": [
            "markdown",
            "html",
            "none"
          ]
        }
      }
    },
    "Document": {
      "type": "object",
      "required": [
        "documentId",
        "namespace",
        "slug",
        "title",
        "category",
        "createdAt",
        "updatedAt"
      ],
      "properties": {
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "namespace": {
          "type": "string"
        },
        "slug": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "category": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "content": {
          "type": "string"
        },
        "summary": {
          "type": "string"
        },
        "voiceSummary": {
          "type": "string"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "relatedDocuments": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uuid"
          }
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true
        },
        "createdAt": {
          "type": "string",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    },
    "DocumentSummary": {
      "type": "object",
      "required": [
        "documentId",
        "slug",
        "title",
        "category"
      ],
      "properties": {
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "slug": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "category": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "summary": {
          "type": "string"
        },
        "voiceSummary": {
          "type": "string"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    }
  }
}
""";

    private static readonly string _GetDocument_Info = """
{
  "summary": "Get specific document by ID or slug",
  "description": "Retrieve a specific document by its unique identifier or slug.\nReturns full content with metadata.\n",
  "tags": [
    "Documents"
  ],
  "deprecated": false,
  "operationId": "getDocument"
}
""";

    /// <summary>Returns endpoint information for GetDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDocument_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/get",
            _GetDocument_Info));

    /// <summary>Returns request schema for GetDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDocument_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/get",
            "request-schema",
            _GetDocument_RequestSchema));

    /// <summary>Returns response schema for GetDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDocument_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/get",
            "response-schema",
            _GetDocument_ResponseSchema));

    /// <summary>Returns full schema for GetDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDocument_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/get",
            _GetDocument_Info,
            _GetDocument_RequestSchema,
            _GetDocument_ResponseSchema));

    #endregion

    #region Meta Endpoints for SearchDocumentation

    private static readonly string _SearchDocumentation_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/SearchDocumentationRequest",
  "$defs": {
    "SearchDocumentationRequest": {
      "type": "object",
      "required": [
        "namespace",
        "searchTerm"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "searchTerm": {
          "type": "string",
          "minLength": 2,
          "maxLength": 200
        },
        "sessionId": {
          "type": "string",
          "format": "uuid"
        },
        "category": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "maxResults": {
          "type": "integer",
          "default": 10,
          "minimum": 1,
          "maximum": 50
        },
        "searchIn": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/SearchField"
          }
        },
        "sortBy": {
          "type": "string",
          "enum": [
            "relevance",
            "recency",
            "alphabetical"
          ],
          "default": "relevance"
        },
        "includeContent": {
          "type": "boolean",
          "default": false
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    },
    "SearchField": {
      "type": "string",
      "enum": [
        "title",
        "content",
        "tags",
        "summary"
      ]
    }
  }
}
""";

    private static readonly string _SearchDocumentation_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/SearchDocumentationResponse",
  "$defs": {
    "SearchDocumentationResponse": {
      "type": "object",
      "required": [
        "namespace",
        "results"
      ],
      "properties": {
        "namespace": {
          "type": "string"
        },
        "results": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/DocumentResult"
          }
        },
        "totalResults": {
          "type": "integer"
        },
        "searchTerm": {
          "type": "string"
        }
      }
    },
    "DocumentResult": {
      "type": "object",
      "required": [
        "documentId",
        "slug",
        "title",
        "relevanceScore"
      ],
      "properties": {
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "slug": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "category": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "summary": {
          "type": "string"
        },
        "voiceSummary": {
          "type": "string"
        },
        "content": {
          "type": "string"
        },
        "relevanceScore": {
          "type": "number",
          "format": "float"
        },
        "matchHighlights": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    }
  }
}
""";

    private static readonly string _SearchDocumentation_Info = """
{
  "summary": "Full-text keyword search",
  "description": "Search documentation using exact keyword matching.\nFaster than semantic search but less flexible.\n",
  "tags": [
    "Search"
  ],
  "deprecated": false,
  "operationId": "searchDocumentation"
}
""";

    /// <summary>Returns endpoint information for SearchDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/search/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchDocumentation_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/search",
            _SearchDocumentation_Info));

    /// <summary>Returns request schema for SearchDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/search/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchDocumentation_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/search",
            "request-schema",
            _SearchDocumentation_RequestSchema));

    /// <summary>Returns response schema for SearchDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/search/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchDocumentation_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/search",
            "response-schema",
            _SearchDocumentation_ResponseSchema));

    /// <summary>Returns full schema for SearchDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/search/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchDocumentation_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/search",
            _SearchDocumentation_Info,
            _SearchDocumentation_RequestSchema,
            _SearchDocumentation_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListDocuments

    private static readonly string _ListDocuments_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListDocumentsRequest",
  "$defs": {
    "ListDocumentsRequest": {
      "type": "object",
      "required": [
        "namespace"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "category": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "tagsMatch": {
          "type": "string",
          "enum": [
            "all",
            "any"
          ],
          "default": "all"
        },
        "createdAfter": {
          "type": "string",
          "format": "date-time"
        },
        "createdBefore": {
          "type": "string",
          "format": "date-time"
        },
        "updatedAfter": {
          "type": "string",
          "format": "date-time"
        },
        "updatedBefore": {
          "type": "string",
          "format": "date-time"
        },
        "titlesOnly": {
          "type": "boolean",
          "default": false
        },
        "page": {
          "type": "integer",
          "default": 1,
          "minimum": 1
        },
        "pageSize": {
          "type": "integer",
          "default": 20,
          "minimum": 1,
          "maximum": 100
        },
        "sortBy": {
          "$ref": "#/$defs/ListSortField"
        },
        "sortOrder": {
          "type": "string",
          "enum": [
            "asc",
            "desc"
          ],
          "default": "desc"
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    },
    "ListSortField": {
      "type": "string",
      "enum": [
        "created_at",
        "updated_at",
        "title"
      ],
      "default": "updated_at"
    }
  }
}
""";

    private static readonly string _ListDocuments_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListDocumentsResponse",
  "$defs": {
    "ListDocumentsResponse": {
      "type": "object",
      "required": [
        "namespace",
        "documents"
      ],
      "properties": {
        "namespace": {
          "type": "string"
        },
        "documents": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/DocumentSummary"
          }
        },
        "totalCount": {
          "type": "integer"
        },
        "page": {
          "type": "integer"
        },
        "pageSize": {
          "type": "integer"
        },
        "totalPages": {
          "type": "integer"
        }
      }
    },
    "DocumentSummary": {
      "type": "object",
      "required": [
        "documentId",
        "slug",
        "title",
        "category"
      ],
      "properties": {
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "slug": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "category": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "summary": {
          "type": "string"
        },
        "voiceSummary": {
          "type": "string"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    }
  }
}
""";

    private static readonly string _ListDocuments_Info = """
{
  "summary": "List documents by category",
  "description": "List all documents in a specific category or all categories.\nSupports pagination for large result sets.\n",
  "tags": [
    "Documents"
  ],
  "deprecated": false,
  "operationId": "listDocuments"
}
""";

    /// <summary>Returns endpoint information for ListDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocuments_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/list",
            _ListDocuments_Info));

    /// <summary>Returns request schema for ListDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocuments_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/list",
            "request-schema",
            _ListDocuments_RequestSchema));

    /// <summary>Returns response schema for ListDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocuments_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/list",
            "response-schema",
            _ListDocuments_ResponseSchema));

    /// <summary>Returns full schema for ListDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocuments_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/list",
            _ListDocuments_Info,
            _ListDocuments_RequestSchema,
            _ListDocuments_ResponseSchema));

    #endregion

    #region Meta Endpoints for SuggestRelatedTopics

    private static readonly string _SuggestRelatedTopics_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/SuggestRelatedRequest",
  "$defs": {
    "SuggestRelatedRequest": {
      "type": "object",
      "required": [
        "namespace",
        "suggestionSource"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "suggestionSource": {
          "$ref": "#/$defs/SuggestionSource"
        },
        "sourceValue": {
          "type": "string"
        },
        "sessionId": {
          "type": "string",
          "format": "uuid"
        },
        "maxSuggestions": {
          "type": "integer",
          "default": 5,
          "minimum": 1,
          "maximum": 10
        },
        "excludeRecentlyViewed": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "SuggestionSource": {
      "type": "string",
      "enum": [
        "document_id",
        "slug",
        "topic",
        "category"
      ]
    }
  }
}
""";

    private static readonly string _SuggestRelatedTopics_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/SuggestRelatedResponse",
  "$defs": {
    "SuggestRelatedResponse": {
      "type": "object",
      "required": [
        "namespace",
        "suggestions"
      ],
      "properties": {
        "namespace": {
          "type": "string"
        },
        "suggestions": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/TopicSuggestion"
          }
        },
        "voicePrompt": {
          "type": "string"
        },
        "sessionInfluenced": {
          "type": "boolean"
        }
      }
    },
    "TopicSuggestion": {
      "type": "object",
      "required": [
        "documentId",
        "title"
      ],
      "properties": {
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "slug": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "category": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "relevanceReason": {
          "type": "string"
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    }
  }
}
""";

    private static readonly string _SuggestRelatedTopics_Info = """
{
  "summary": "Get related topics and follow-up suggestions",
  "description": "Given a topic or document ID, returns related topics the user\nmight want to explore. Useful for conversational AI flow.\n",
  "tags": [
    "Search"
  ],
  "deprecated": false,
  "operationId": "suggestRelatedTopics"
}
""";

    /// <summary>Returns endpoint information for SuggestRelatedTopics</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/suggest/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SuggestRelatedTopics_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/suggest",
            _SuggestRelatedTopics_Info));

    /// <summary>Returns request schema for SuggestRelatedTopics</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/suggest/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SuggestRelatedTopics_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/suggest",
            "request-schema",
            _SuggestRelatedTopics_RequestSchema));

    /// <summary>Returns response schema for SuggestRelatedTopics</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/suggest/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SuggestRelatedTopics_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/suggest",
            "response-schema",
            _SuggestRelatedTopics_ResponseSchema));

    /// <summary>Returns full schema for SuggestRelatedTopics</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/suggest/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SuggestRelatedTopics_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/suggest",
            _SuggestRelatedTopics_Info,
            _SuggestRelatedTopics_RequestSchema,
            _SuggestRelatedTopics_ResponseSchema));

    #endregion

    #region Meta Endpoints for CreateDocument

    private static readonly string _CreateDocument_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/CreateDocumentRequest",
  "$defs": {
    "CreateDocumentRequest": {
      "type": "object",
      "required": [
        "namespace",
        "slug",
        "title",
        "category",
        "content"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "slug": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 100
        },
        "title": {
          "type": "string",
          "maxLength": 200
        },
        "category": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "content": {
          "type": "string",
          "description": "Markdown content (max 500KB)"
        },
        "summary": {
          "type": "string",
          "maxLength": 500
        },
        "voiceSummary": {
          "type": "string",
          "maxLength": 200
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "relatedDocuments": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uuid"
          }
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    }
  }
}
""";

    private static readonly string _CreateDocument_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/CreateDocumentResponse",
  "$defs": {
    "CreateDocumentResponse": {
      "type": "object",
      "required": [
        "documentId",
        "slug"
      ],
      "properties": {
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "slug": {
          "type": "string"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time"
        }
      }
    }
  }
}
""";

    private static readonly string _CreateDocument_Info = """
{
  "summary": "Create new documentation entry",
  "description": "",
  "tags": [
    "Admin"
  ],
  "deprecated": false,
  "operationId": "createDocument"
}
""";

    /// <summary>Returns endpoint information for CreateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocument_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/create",
            _CreateDocument_Info));

    /// <summary>Returns request schema for CreateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocument_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/create",
            "request-schema",
            _CreateDocument_RequestSchema));

    /// <summary>Returns response schema for CreateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocument_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/create",
            "response-schema",
            _CreateDocument_ResponseSchema));

    /// <summary>Returns full schema for CreateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocument_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/create",
            _CreateDocument_Info,
            _CreateDocument_RequestSchema,
            _CreateDocument_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateDocument

    private static readonly string _UpdateDocument_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/UpdateDocumentRequest",
  "$defs": {
    "UpdateDocumentRequest": {
      "type": "object",
      "required": [
        "namespace"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "slug": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "category": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "content": {
          "type": "string"
        },
        "summary": {
          "type": "string"
        },
        "voiceSummary": {
          "type": "string"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "relatedDocuments": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uuid"
          }
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    }
  }
}
""";

    private static readonly string _UpdateDocument_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/UpdateDocumentResponse",
  "$defs": {
    "UpdateDocumentResponse": {
      "type": "object",
      "required": [
        "documentId",
        "updatedAt"
      ],
      "properties": {
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time"
        }
      }
    }
  }
}
""";

    private static readonly string _UpdateDocument_Info = """
{
  "summary": "Update existing documentation entry",
  "description": "",
  "tags": [
    "Admin"
  ],
  "deprecated": false,
  "operationId": "updateDocument"
}
""";

    /// <summary>Returns endpoint information for UpdateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDocument_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/update",
            _UpdateDocument_Info));

    /// <summary>Returns request schema for UpdateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDocument_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/update",
            "request-schema",
            _UpdateDocument_RequestSchema));

    /// <summary>Returns response schema for UpdateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDocument_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/update",
            "response-schema",
            _UpdateDocument_ResponseSchema));

    /// <summary>Returns full schema for UpdateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDocument_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/update",
            _UpdateDocument_Info,
            _UpdateDocument_RequestSchema,
            _UpdateDocument_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeleteDocument

    private static readonly string _DeleteDocument_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/DeleteDocumentRequest",
  "$defs": {
    "DeleteDocumentRequest": {
      "type": "object",
      "required": [
        "namespace"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "slug": {
          "type": "string"
        }
      }
    }
  }
}
""";

    private static readonly string _DeleteDocument_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/DeleteDocumentResponse",
  "$defs": {
    "DeleteDocumentResponse": {
      "type": "object",
      "required": [
        "documentId",
        "deletedAt",
        "recoverableUntil"
      ],
      "properties": {
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "deletedAt": {
          "type": "string",
          "format": "date-time"
        },
        "recoverableUntil": {
          "type": "string",
          "format": "date-time"
        }
      }
    }
  }
}
""";

    private static readonly string _DeleteDocument_Info = """
{
  "summary": "Soft-delete documentation entry to trashcan",
  "description": "Moves document to trashcan for recovery within TTL period.\nDocuments are automatically cleaned up after TrashcanTtlDays.\n",
  "tags": [
    "Admin"
  ],
  "deprecated": false,
  "operationId": "deleteDocument"
}
""";

    /// <summary>Returns endpoint information for DeleteDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocument_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/delete",
            _DeleteDocument_Info));

    /// <summary>Returns request schema for DeleteDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocument_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/delete",
            "request-schema",
            _DeleteDocument_RequestSchema));

    /// <summary>Returns response schema for DeleteDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocument_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/delete",
            "response-schema",
            _DeleteDocument_ResponseSchema));

    /// <summary>Returns full schema for DeleteDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocument_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/delete",
            _DeleteDocument_Info,
            _DeleteDocument_RequestSchema,
            _DeleteDocument_ResponseSchema));

    #endregion

    #region Meta Endpoints for RecoverDocument

    private static readonly string _RecoverDocument_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/RecoverDocumentRequest",
  "$defs": {
    "RecoverDocumentRequest": {
      "type": "object",
      "required": [
        "namespace",
        "documentId"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "documentId": {
          "type": "string",
          "format": "uuid"
        }
      }
    }
  }
}
""";

    private static readonly string _RecoverDocument_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/RecoverDocumentResponse",
  "$defs": {
    "RecoverDocumentResponse": {
      "type": "object",
      "required": [
        "documentId",
        "recoveredAt"
      ],
      "properties": {
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "recoveredAt": {
          "type": "string",
          "format": "date-time"
        }
      }
    }
  }
}
""";

    private static readonly string _RecoverDocument_Info = """
{
  "summary": "Recover document from trashcan",
  "description": "Restores a soft-deleted document from the trashcan.\nMust be called before the trashcan TTL expires.\n",
  "tags": [
    "Admin"
  ],
  "deprecated": false,
  "operationId": "recoverDocument"
}
""";

    /// <summary>Returns endpoint information for RecoverDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/recover/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RecoverDocument_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/recover",
            _RecoverDocument_Info));

    /// <summary>Returns request schema for RecoverDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/recover/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RecoverDocument_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/recover",
            "request-schema",
            _RecoverDocument_RequestSchema));

    /// <summary>Returns response schema for RecoverDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/recover/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RecoverDocument_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/recover",
            "response-schema",
            _RecoverDocument_ResponseSchema));

    /// <summary>Returns full schema for RecoverDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/recover/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RecoverDocument_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/recover",
            _RecoverDocument_Info,
            _RecoverDocument_RequestSchema,
            _RecoverDocument_ResponseSchema));

    #endregion

    #region Meta Endpoints for BulkUpdateDocuments

    private static readonly string _BulkUpdateDocuments_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/BulkUpdateRequest",
  "$defs": {
    "BulkUpdateRequest": {
      "type": "object",
      "required": [
        "namespace",
        "documentIds"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "documentIds": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uuid"
          }
        },
        "category": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "addTags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "removeTags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    }
  }
}
""";

    private static readonly string _BulkUpdateDocuments_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/BulkUpdateResponse",
  "$defs": {
    "BulkUpdateResponse": {
      "type": "object",
      "required": [
        "succeeded",
        "failed"
      ],
      "properties": {
        "succeeded": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uuid"
          }
        },
        "failed": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/BulkOperationFailure"
          }
        }
      }
    },
    "BulkOperationFailure": {
      "type": "object",
      "required": [
        "documentId",
        "error"
      ],
      "properties": {
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "error": {
          "type": "string"
        }
      }
    }
  }
}
""";

    private static readonly string _BulkUpdateDocuments_Info = """
{
  "summary": "Bulk update document metadata",
  "description": "Apply category, tag, or metadata changes to multiple documents at once.\nEach document is processed independently - partial success is possible.\n",
  "tags": [
    "Admin"
  ],
  "deprecated": false,
  "operationId": "bulkUpdateDocuments"
}
""";

    /// <summary>Returns endpoint information for BulkUpdateDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkUpdateDocuments_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/bulk-update",
            _BulkUpdateDocuments_Info));

    /// <summary>Returns request schema for BulkUpdateDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkUpdateDocuments_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/bulk-update",
            "request-schema",
            _BulkUpdateDocuments_RequestSchema));

    /// <summary>Returns response schema for BulkUpdateDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkUpdateDocuments_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/bulk-update",
            "response-schema",
            _BulkUpdateDocuments_ResponseSchema));

    /// <summary>Returns full schema for BulkUpdateDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkUpdateDocuments_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/bulk-update",
            _BulkUpdateDocuments_Info,
            _BulkUpdateDocuments_RequestSchema,
            _BulkUpdateDocuments_ResponseSchema));

    #endregion

    #region Meta Endpoints for BulkDeleteDocuments

    private static readonly string _BulkDeleteDocuments_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/BulkDeleteRequest",
  "$defs": {
    "BulkDeleteRequest": {
      "type": "object",
      "required": [
        "namespace",
        "documentIds"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "documentIds": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uuid"
          }
        }
      }
    }
  }
}
""";

    private static readonly string _BulkDeleteDocuments_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/BulkDeleteResponse",
  "$defs": {
    "BulkDeleteResponse": {
      "type": "object",
      "required": [
        "succeeded",
        "failed"
      ],
      "properties": {
        "succeeded": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uuid"
          }
        },
        "failed": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/BulkOperationFailure"
          }
        }
      }
    },
    "BulkOperationFailure": {
      "type": "object",
      "required": [
        "documentId",
        "error"
      ],
      "properties": {
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "error": {
          "type": "string"
        }
      }
    }
  }
}
""";

    private static readonly string _BulkDeleteDocuments_Info = """
{
  "summary": "Bulk soft-delete documents to trashcan",
  "description": "Move multiple documents to trashcan at once.\nEach document is processed independently - partial success is possible.\n",
  "tags": [
    "Admin"
  ],
  "deprecated": false,
  "operationId": "bulkDeleteDocuments"
}
""";

    /// <summary>Returns endpoint information for BulkDeleteDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkDeleteDocuments_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/bulk-delete",
            _BulkDeleteDocuments_Info));

    /// <summary>Returns request schema for BulkDeleteDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkDeleteDocuments_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/bulk-delete",
            "request-schema",
            _BulkDeleteDocuments_RequestSchema));

    /// <summary>Returns response schema for BulkDeleteDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkDeleteDocuments_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/bulk-delete",
            "response-schema",
            _BulkDeleteDocuments_ResponseSchema));

    /// <summary>Returns full schema for BulkDeleteDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkDeleteDocuments_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/bulk-delete",
            _BulkDeleteDocuments_Info,
            _BulkDeleteDocuments_RequestSchema,
            _BulkDeleteDocuments_ResponseSchema));

    #endregion

    #region Meta Endpoints for ImportDocumentation

    private static readonly string _ImportDocumentation_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ImportDocumentationRequest",
  "$defs": {
    "ImportDocumentationRequest": {
      "type": "object",
      "required": [
        "namespace",
        "documents"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "documents": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ImportDocument"
          }
        },
        "onConflict": {
          "type": "string",
          "enum": [
            "skip",
            "update",
            "fail"
          ],
          "default": "skip"
        }
      }
    },
    "ImportDocument": {
      "type": "object",
      "required": [
        "slug",
        "title",
        "category",
        "content"
      ],
      "properties": {
        "slug": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "category": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "content": {
          "type": "string"
        },
        "summary": {
          "type": "string"
        },
        "voiceSummary": {
          "type": "string"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    }
  }
}
""";

    private static readonly string _ImportDocumentation_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ImportDocumentationResponse",
  "$defs": {
    "ImportDocumentationResponse": {
      "type": "object",
      "required": [
        "namespace",
        "created",
        "updated",
        "skipped",
        "failed"
      ],
      "properties": {
        "namespace": {
          "type": "string"
        },
        "created": {
          "type": "integer"
        },
        "updated": {
          "type": "integer"
        },
        "skipped": {
          "type": "integer"
        },
        "failed": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ImportFailure"
          }
        }
      }
    },
    "ImportFailure": {
      "type": "object",
      "required": [
        "slug",
        "error"
      ],
      "properties": {
        "slug": {
          "type": "string"
        },
        "error": {
          "type": "string"
        }
      }
    }
  }
}
""";

    private static readonly string _ImportDocumentation_Info = """
{
  "summary": "Bulk import documentation from structured source",
  "description": "Import multiple documents. Each document processed independently.\nPartial success is possible - failures reported per document.\n",
  "tags": [
    "Admin"
  ],
  "deprecated": false,
  "operationId": "importDocumentation"
}
""";

    /// <summary>Returns endpoint information for ImportDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/import/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ImportDocumentation_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/import",
            _ImportDocumentation_Info));

    /// <summary>Returns request schema for ImportDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/import/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ImportDocumentation_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/import",
            "request-schema",
            _ImportDocumentation_RequestSchema));

    /// <summary>Returns response schema for ImportDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/import/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ImportDocumentation_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/import",
            "response-schema",
            _ImportDocumentation_ResponseSchema));

    /// <summary>Returns full schema for ImportDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/import/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ImportDocumentation_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/import",
            _ImportDocumentation_Info,
            _ImportDocumentation_RequestSchema,
            _ImportDocumentation_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListTrashcan

    private static readonly string _ListTrashcan_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListTrashcanRequest",
  "$defs": {
    "ListTrashcanRequest": {
      "type": "object",
      "required": [
        "namespace"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "page": {
          "type": "integer",
          "default": 1
        },
        "pageSize": {
          "type": "integer",
          "default": 20
        }
      }
    }
  }
}
""";

    private static readonly string _ListTrashcan_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListTrashcanResponse",
  "$defs": {
    "ListTrashcanResponse": {
      "type": "object",
      "required": [
        "namespace",
        "items"
      ],
      "properties": {
        "namespace": {
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/TrashcanItem"
          }
        },
        "totalCount": {
          "type": "integer"
        }
      }
    },
    "TrashcanItem": {
      "type": "object",
      "required": [
        "documentId",
        "title",
        "deletedAt",
        "expiresAt"
      ],
      "properties": {
        "documentId": {
          "type": "string",
          "format": "uuid"
        },
        "slug": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "category": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "deletedAt": {
          "type": "string",
          "format": "date-time"
        },
        "expiresAt": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    }
  }
}
""";

    private static readonly string _ListTrashcan_Info = """
{
  "summary": "List documents in the trashcan",
  "description": "List all soft-deleted documents within the namespace's trashcan.\nDocuments remain recoverable until TTL expires or purge is called.\n",
  "tags": [
    "Admin"
  ],
  "deprecated": false,
  "operationId": "listTrashcan"
}
""";

    /// <summary>Returns endpoint information for ListTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/trashcan/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListTrashcan_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/trashcan",
            _ListTrashcan_Info));

    /// <summary>Returns request schema for ListTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/trashcan/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListTrashcan_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/trashcan",
            "request-schema",
            _ListTrashcan_RequestSchema));

    /// <summary>Returns response schema for ListTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/trashcan/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListTrashcan_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/trashcan",
            "response-schema",
            _ListTrashcan_ResponseSchema));

    /// <summary>Returns full schema for ListTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/trashcan/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListTrashcan_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/trashcan",
            _ListTrashcan_Info,
            _ListTrashcan_RequestSchema,
            _ListTrashcan_ResponseSchema));

    #endregion

    #region Meta Endpoints for PurgeTrashcan

    private static readonly string _PurgeTrashcan_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/PurgeTrashcanRequest",
  "$defs": {
    "PurgeTrashcanRequest": {
      "type": "object",
      "required": [
        "namespace"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "documentIds": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uuid"
          },
          "description": "If empty, purges all trashcan items"
        }
      }
    }
  }
}
""";

    private static readonly string _PurgeTrashcan_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/PurgeTrashcanResponse",
  "$defs": {
    "PurgeTrashcanResponse": {
      "type": "object",
      "required": [
        "purgedCount"
      ],
      "properties": {
        "purgedCount": {
          "type": "integer"
        }
      }
    }
  }
}
""";

    private static readonly string _PurgeTrashcan_Info = """
{
  "summary": "Permanently delete trashcan items",
  "description": "Permanently delete specified documents from trashcan, or purge all.\nThis operation is irreversible - documents cannot be recovered after purge.\n",
  "tags": [
    "Admin"
  ],
  "deprecated": false,
  "operationId": "purgeTrashcan"
}
""";

    /// <summary>Returns endpoint information for PurgeTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/purge/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PurgeTrashcan_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/purge",
            _PurgeTrashcan_Info));

    /// <summary>Returns request schema for PurgeTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/purge/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PurgeTrashcan_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/purge",
            "request-schema",
            _PurgeTrashcan_RequestSchema));

    /// <summary>Returns response schema for PurgeTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/purge/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PurgeTrashcan_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/purge",
            "response-schema",
            _PurgeTrashcan_ResponseSchema));

    /// <summary>Returns full schema for PurgeTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/purge/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PurgeTrashcan_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/purge",
            _PurgeTrashcan_Info,
            _PurgeTrashcan_RequestSchema,
            _PurgeTrashcan_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetNamespaceStats

    private static readonly string _GetNamespaceStats_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetNamespaceStatsRequest",
  "$defs": {
    "GetNamespaceStatsRequest": {
      "type": "object",
      "required": [
        "namespace"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        }
      }
    }
  }
}
""";

    private static readonly string _GetNamespaceStats_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/NamespaceStatsResponse",
  "$defs": {
    "NamespaceStatsResponse": {
      "type": "object",
      "required": [
        "namespace",
        "documentCount"
      ],
      "properties": {
        "namespace": {
          "type": "string"
        },
        "documentCount": {
          "type": "integer"
        },
        "categoryCounts": {
          "type": "object",
          "additionalProperties": {
            "type": "integer"
          }
        },
        "trashcanCount": {
          "type": "integer"
        },
        "totalContentSizeBytes": {
          "type": "integer"
        },
        "lastUpdated": {
          "type": "string",
          "format": "date-time"
        }
      }
    }
  }
}
""";

    private static readonly string _GetNamespaceStats_Info = """
{
  "summary": "Get namespace documentation statistics",
  "description": "Retrieve usage statistics and metadata for a documentation namespace.\nUseful for monitoring, capacity planning, and administrative dashboards.\n",
  "tags": [
    "Admin"
  ],
  "deprecated": false,
  "operationId": "getNamespaceStats"
}
""";

    /// <summary>Returns endpoint information for GetNamespaceStats</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/stats/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetNamespaceStats_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/stats",
            _GetNamespaceStats_Info));

    /// <summary>Returns request schema for GetNamespaceStats</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/stats/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetNamespaceStats_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/stats",
            "request-schema",
            _GetNamespaceStats_RequestSchema));

    /// <summary>Returns response schema for GetNamespaceStats</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/stats/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetNamespaceStats_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/stats",
            "response-schema",
            _GetNamespaceStats_ResponseSchema));

    /// <summary>Returns full schema for GetNamespaceStats</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/stats/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetNamespaceStats_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/stats",
            _GetNamespaceStats_Info,
            _GetNamespaceStats_RequestSchema,
            _GetNamespaceStats_ResponseSchema));

    #endregion

    #region Meta Endpoints for BindRepository

    private static readonly string _BindRepository_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/BindRepositoryRequest",
  "$defs": {
    "BindRepositoryRequest": {
      "type": "object",
      "required": [
        "namespace",
        "repositoryUrl"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50,
          "description": "Documentation namespace to bind"
        },
        "repositoryUrl": {
          "type": "string",
          "description": "Git clone URL (HTTPS for public repos)"
        },
        "branch": {
          "type": "string",
          "default": "main",
          "description": "Branch to sync from"
        },
        "syncIntervalMinutes": {
          "type": "integer",
          "default": 60,
          "minimum": 5,
          "maximum": 1440,
          "description": "How often to sync (5 min to 24 hours)"
        },
        "filePatterns": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "default": [
            "**/*.md"
          ],
          "description": "Glob patterns for files to include"
        },
        "excludePatterns": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "default": [
            ".git/**",
            ".obsidian/**",
            "node_modules/**"
          ],
          "description": "Glob patterns for files to exclude"
        },
        "categoryMapping": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Map directory prefixes to categories"
        },
        "defaultCategory": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "archiveEnabled": {
          "type": "boolean",
          "default": false,
          "description": "Enable archive functionality"
        },
        "archiveOnSync": {
          "type": "boolean",
          "default": false,
          "description": "Create archive after each sync"
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    }
  }
}
""";

    private static readonly string _BindRepository_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/BindRepositoryResponse",
  "$defs": {
    "BindRepositoryResponse": {
      "type": "object",
      "required": [
        "bindingId",
        "namespace",
        "status"
      ],
      "properties": {
        "bindingId": {
          "type": "string",
          "format": "uuid"
        },
        "namespace": {
          "type": "string"
        },
        "repositoryUrl": {
          "type": "string"
        },
        "branch": {
          "type": "string"
        },
        "status": {
          "$ref": "#/$defs/BindingStatus"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "BindingStatus": {
      "type": "string",
      "enum": [
        "pending",
        "syncing",
        "synced",
        "error",
        "disabled"
      ],
      "description": "Status of a repository binding"
    }
  }
}
""";

    private static readonly string _BindRepository_Info = """
{
  "summary": "Bind a git repository to a documentation namespace",
  "description": "Bind a git repository URL to a documentation namespace.\nThe namespace will be exclusively managed by the repository - manual edits will be blocked.\nTriggers initial sync after binding.\n",
  "tags": [
    "Repository"
  ],
  "deprecated": false,
  "operationId": "bindRepository"
}
""";

    /// <summary>Returns endpoint information for BindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/bind/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BindRepository_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/bind",
            _BindRepository_Info));

    /// <summary>Returns request schema for BindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/bind/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BindRepository_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/bind",
            "request-schema",
            _BindRepository_RequestSchema));

    /// <summary>Returns response schema for BindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/bind/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BindRepository_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/bind",
            "response-schema",
            _BindRepository_ResponseSchema));

    /// <summary>Returns full schema for BindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/bind/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BindRepository_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/bind",
            _BindRepository_Info,
            _BindRepository_RequestSchema,
            _BindRepository_ResponseSchema));

    #endregion

    #region Meta Endpoints for UnbindRepository

    private static readonly string _UnbindRepository_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/UnbindRepositoryRequest",
  "$defs": {
    "UnbindRepositoryRequest": {
      "type": "object",
      "required": [
        "namespace"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "deleteDocuments": {
          "type": "boolean",
          "default": false,
          "description": "Also delete all documents from the namespace"
        }
      }
    }
  }
}
""";

    private static readonly string _UnbindRepository_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/UnbindRepositoryResponse",
  "$defs": {
    "UnbindRepositoryResponse": {
      "type": "object",
      "required": [
        "namespace",
        "documentsDeleted"
      ],
      "properties": {
        "namespace": {
          "type": "string"
        },
        "documentsDeleted": {
          "type": "integer",
          "description": "Number of documents deleted (0 if deleteDocuments was false)"
        }
      }
    }
  }
}
""";

    private static readonly string _UnbindRepository_Info = """
{
  "summary": "Remove repository binding from namespace",
  "description": "Remove repository binding from a namespace, making it manually editable again.\nOptionally delete all documents imported from the repository.\n",
  "tags": [
    "Repository"
  ],
  "deprecated": false,
  "operationId": "unbindRepository"
}
""";

    /// <summary>Returns endpoint information for UnbindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/unbind/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UnbindRepository_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/unbind",
            _UnbindRepository_Info));

    /// <summary>Returns request schema for UnbindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/unbind/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UnbindRepository_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/unbind",
            "request-schema",
            _UnbindRepository_RequestSchema));

    /// <summary>Returns response schema for UnbindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/unbind/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UnbindRepository_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/unbind",
            "response-schema",
            _UnbindRepository_ResponseSchema));

    /// <summary>Returns full schema for UnbindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/unbind/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UnbindRepository_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/unbind",
            _UnbindRepository_Info,
            _UnbindRepository_RequestSchema,
            _UnbindRepository_ResponseSchema));

    #endregion

    #region Meta Endpoints for SyncRepository

    private static readonly string _SyncRepository_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/SyncRepositoryRequest",
  "$defs": {
    "SyncRepositoryRequest": {
      "type": "object",
      "required": [
        "namespace"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "force": {
          "type": "boolean",
          "default": false,
          "description": "Force full re-sync even if commit hash unchanged"
        }
      }
    }
  }
}
""";

    private static readonly string _SyncRepository_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/SyncRepositoryResponse",
  "$defs": {
    "SyncRepositoryResponse": {
      "type": "object",
      "required": [
        "syncId",
        "status"
      ],
      "properties": {
        "syncId": {
          "type": "string",
          "format": "uuid"
        },
        "status": {
          "$ref": "#/$defs/SyncStatus"
        },
        "commitHash": {
          "type": "string"
        },
        "documentsCreated": {
          "type": "integer"
        },
        "documentsUpdated": {
          "type": "integer"
        },
        "documentsDeleted": {
          "type": "integer"
        },
        "documentsFailed": {
          "type": "integer"
        },
        "durationMs": {
          "type": "integer"
        },
        "errorMessage": {
          "type": "string",
          "nullable": true
        }
      }
    },
    "SyncStatus": {
      "type": "string",
      "enum": [
        "success",
        "partial",
        "failed"
      ],
      "description": "Result status of a sync operation"
    }
  }
}
""";

    private static readonly string _SyncRepository_Info = """
{
  "summary": "Manually trigger repository sync",
  "description": "Manually trigger synchronization of a bound repository.\nIf force=true, performs full re-sync regardless of commit hash.\n",
  "tags": [
    "Repository"
  ],
  "deprecated": false,
  "operationId": "syncRepository"
}
""";

    /// <summary>Returns endpoint information for SyncRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/sync/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SyncRepository_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/sync",
            _SyncRepository_Info));

    /// <summary>Returns request schema for SyncRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/sync/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SyncRepository_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/sync",
            "request-schema",
            _SyncRepository_RequestSchema));

    /// <summary>Returns response schema for SyncRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/sync/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SyncRepository_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/sync",
            "response-schema",
            _SyncRepository_ResponseSchema));

    /// <summary>Returns full schema for SyncRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/sync/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SyncRepository_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/sync",
            _SyncRepository_Info,
            _SyncRepository_RequestSchema,
            _SyncRepository_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetRepositoryStatus

    private static readonly string _GetRepositoryStatus_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/RepositoryStatusRequest",
  "$defs": {
    "RepositoryStatusRequest": {
      "type": "object",
      "required": [
        "namespace"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        }
      }
    }
  }
}
""";

    private static readonly string _GetRepositoryStatus_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/RepositoryStatusResponse",
  "$defs": {
    "RepositoryStatusResponse": {
      "type": "object",
      "properties": {
        "binding": {
          "$ref": "#/$defs/RepositoryBindingInfo"
        },
        "lastSync": {
          "$ref": "#/$defs/SyncInfo"
        }
      }
    },
    "RepositoryBindingInfo": {
      "type": "object",
      "required": [
        "bindingId",
        "namespace",
        "repositoryUrl",
        "status"
      ],
      "properties": {
        "bindingId": {
          "type": "string",
          "format": "uuid"
        },
        "namespace": {
          "type": "string"
        },
        "repositoryUrl": {
          "type": "string"
        },
        "branch": {
          "type": "string"
        },
        "status": {
          "$ref": "#/$defs/BindingStatus"
        },
        "syncEnabled": {
          "type": "boolean"
        },
        "syncIntervalMinutes": {
          "type": "integer"
        },
        "documentCount": {
          "type": "integer"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time"
        },
        "createdBy": {
          "type": "string",
          "format": "uuid"
        }
      }
    },
    "BindingStatus": {
      "type": "string",
      "enum": [
        "pending",
        "syncing",
        "synced",
        "error",
        "disabled"
      ],
      "description": "Status of a repository binding"
    },
    "SyncInfo": {
      "type": "object",
      "properties": {
        "syncId": {
          "type": "string",
          "format": "uuid"
        },
        "status": {
          "$ref": "#/$defs/SyncStatus"
        },
        "triggeredBy": {
          "$ref": "#/$defs/SyncTrigger"
        },
        "startedAt": {
          "type": "string",
          "format": "date-time"
        },
        "completedAt": {
          "type": "string",
          "format": "date-time"
        },
        "commitHash": {
          "type": "string"
        },
        "documentsProcessed": {
          "type": "integer"
        }
      }
    },
    "SyncStatus": {
      "type": "string",
      "enum": [
        "success",
        "partial",
        "failed"
      ],
      "description": "Result status of a sync operation"
    },
    "SyncTrigger": {
      "type": "string",
      "enum": [
        "manual",
        "scheduled"
      ],
      "description": "What triggered the sync operation"
    }
  }
}
""";

    private static readonly string _GetRepositoryStatus_Info = """
{
  "summary": "Get repository binding status",
  "description": "Get current status of a repository binding including sync state and statistics.\n",
  "tags": [
    "Repository"
  ],
  "deprecated": false,
  "operationId": "getRepositoryStatus"
}
""";

    /// <summary>Returns endpoint information for GetRepositoryStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/status/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetRepositoryStatus_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/status",
            _GetRepositoryStatus_Info));

    /// <summary>Returns request schema for GetRepositoryStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/status/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetRepositoryStatus_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/status",
            "request-schema",
            _GetRepositoryStatus_RequestSchema));

    /// <summary>Returns response schema for GetRepositoryStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/status/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetRepositoryStatus_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/status",
            "response-schema",
            _GetRepositoryStatus_ResponseSchema));

    /// <summary>Returns full schema for GetRepositoryStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/status/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetRepositoryStatus_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/status",
            _GetRepositoryStatus_Info,
            _GetRepositoryStatus_RequestSchema,
            _GetRepositoryStatus_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListRepositoryBindings

    private static readonly string _ListRepositoryBindings_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListRepositoryBindingsRequest",
  "$defs": {
    "ListRepositoryBindingsRequest": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/$defs/BindingStatus"
        },
        "limit": {
          "type": "integer",
          "default": 50,
          "minimum": 1,
          "maximum": 100
        },
        "offset": {
          "type": "integer",
          "default": 0,
          "minimum": 0
        }
      }
    },
    "BindingStatus": {
      "type": "string",
      "enum": [
        "pending",
        "syncing",
        "synced",
        "error",
        "disabled"
      ],
      "description": "Status of a repository binding"
    }
  }
}
""";

    private static readonly string _ListRepositoryBindings_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListRepositoryBindingsResponse",
  "$defs": {
    "ListRepositoryBindingsResponse": {
      "type": "object",
      "required": [
        "bindings",
        "total"
      ],
      "properties": {
        "bindings": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/RepositoryBindingInfo"
          }
        },
        "total": {
          "type": "integer"
        }
      }
    },
    "RepositoryBindingInfo": {
      "type": "object",
      "required": [
        "bindingId",
        "namespace",
        "repositoryUrl",
        "status"
      ],
      "properties": {
        "bindingId": {
          "type": "string",
          "format": "uuid"
        },
        "namespace": {
          "type": "string"
        },
        "repositoryUrl": {
          "type": "string"
        },
        "branch": {
          "type": "string"
        },
        "status": {
          "$ref": "#/$defs/BindingStatus"
        },
        "syncEnabled": {
          "type": "boolean"
        },
        "syncIntervalMinutes": {
          "type": "integer"
        },
        "documentCount": {
          "type": "integer"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time"
        },
        "createdBy": {
          "type": "string",
          "format": "uuid"
        }
      }
    },
    "BindingStatus": {
      "type": "string",
      "enum": [
        "pending",
        "syncing",
        "synced",
        "error",
        "disabled"
      ],
      "description": "Status of a repository binding"
    }
  }
}
""";

    private static readonly string _ListRepositoryBindings_Info = """
{
  "summary": "List all repository bindings",
  "description": "List all repository bindings with optional filtering by status.\n",
  "tags": [
    "Repository"
  ],
  "deprecated": false,
  "operationId": "listRepositoryBindings"
}
""";

    /// <summary>Returns endpoint information for ListRepositoryBindings</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListRepositoryBindings_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/list",
            _ListRepositoryBindings_Info));

    /// <summary>Returns request schema for ListRepositoryBindings</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListRepositoryBindings_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/list",
            "request-schema",
            _ListRepositoryBindings_RequestSchema));

    /// <summary>Returns response schema for ListRepositoryBindings</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListRepositoryBindings_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/list",
            "response-schema",
            _ListRepositoryBindings_ResponseSchema));

    /// <summary>Returns full schema for ListRepositoryBindings</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListRepositoryBindings_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/list",
            _ListRepositoryBindings_Info,
            _ListRepositoryBindings_RequestSchema,
            _ListRepositoryBindings_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateRepositoryBinding

    private static readonly string _UpdateRepositoryBinding_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/UpdateRepositoryBindingRequest",
  "$defs": {
    "UpdateRepositoryBindingRequest": {
      "type": "object",
      "required": [
        "namespace"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "syncEnabled": {
          "type": "boolean"
        },
        "syncIntervalMinutes": {
          "type": "integer",
          "minimum": 5,
          "maximum": 1440
        },
        "filePatterns": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "excludePatterns": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "categoryMapping": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "defaultCategory": {
          "$ref": "#/$defs/DocumentCategory"
        },
        "archiveEnabled": {
          "type": "boolean"
        },
        "archiveOnSync": {
          "type": "boolean"
        }
      }
    },
    "DocumentCategory": {
      "type": "string",
      "enum": [
        "getting-started",
        "api-reference",
        "architecture",
        "deployment",
        "troubleshooting",
        "tutorials",
        "game-systems",
        "world-lore",
        "npc-ai",
        "other"
      ],
      "description": "Fixed categories for type-safe filtering"
    }
  }
}
""";

    private static readonly string _UpdateRepositoryBinding_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/UpdateRepositoryBindingResponse",
  "$defs": {
    "UpdateRepositoryBindingResponse": {
      "type": "object",
      "required": [
        "binding"
      ],
      "properties": {
        "binding": {
          "$ref": "#/$defs/RepositoryBindingInfo"
        }
      }
    },
    "RepositoryBindingInfo": {
      "type": "object",
      "required": [
        "bindingId",
        "namespace",
        "repositoryUrl",
        "status"
      ],
      "properties": {
        "bindingId": {
          "type": "string",
          "format": "uuid"
        },
        "namespace": {
          "type": "string"
        },
        "repositoryUrl": {
          "type": "string"
        },
        "branch": {
          "type": "string"
        },
        "status": {
          "$ref": "#/$defs/BindingStatus"
        },
        "syncEnabled": {
          "type": "boolean"
        },
        "syncIntervalMinutes": {
          "type": "integer"
        },
        "documentCount": {
          "type": "integer"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time"
        },
        "createdBy": {
          "type": "string",
          "format": "uuid"
        }
      }
    },
    "BindingStatus": {
      "type": "string",
      "enum": [
        "pending",
        "syncing",
        "synced",
        "error",
        "disabled"
      ],
      "description": "Status of a repository binding"
    }
  }
}
""";

    private static readonly string _UpdateRepositoryBinding_Info = """
{
  "summary": "Update repository binding configuration",
  "description": "Update sync settings, file patterns, category mappings, or archive configuration.\n",
  "tags": [
    "Repository"
  ],
  "deprecated": false,
  "operationId": "updateRepositoryBinding"
}
""";

    /// <summary>Returns endpoint information for UpdateRepositoryBinding</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateRepositoryBinding_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/update",
            _UpdateRepositoryBinding_Info));

    /// <summary>Returns request schema for UpdateRepositoryBinding</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateRepositoryBinding_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/update",
            "request-schema",
            _UpdateRepositoryBinding_RequestSchema));

    /// <summary>Returns response schema for UpdateRepositoryBinding</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateRepositoryBinding_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/update",
            "response-schema",
            _UpdateRepositoryBinding_ResponseSchema));

    /// <summary>Returns full schema for UpdateRepositoryBinding</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateRepositoryBinding_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/update",
            _UpdateRepositoryBinding_Info,
            _UpdateRepositoryBinding_RequestSchema,
            _UpdateRepositoryBinding_ResponseSchema));

    #endregion

    #region Meta Endpoints for CreateDocumentationArchive

    private static readonly string _CreateDocumentationArchive_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/CreateArchiveRequest",
  "$defs": {
    "CreateArchiveRequest": {
      "type": "object",
      "required": [
        "namespace"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "description": {
          "type": "string",
          "maxLength": 500,
          "description": "Optional description for the archive"
        }
      }
    }
  }
}
""";

    private static readonly string _CreateDocumentationArchive_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/CreateArchiveResponse",
  "$defs": {
    "CreateArchiveResponse": {
      "type": "object",
      "required": [
        "archiveId",
        "namespace"
      ],
      "properties": {
        "archiveId": {
          "type": "string",
          "format": "uuid"
        },
        "namespace": {
          "type": "string"
        },
        "bundleAssetId": {
          "type": "string",
          "format": "uuid",
          "description": "Asset ID in Asset Service"
        },
        "documentCount": {
          "type": "integer"
        },
        "sizeBytes": {
          "type": "integer"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time"
        },
        "commitHash": {
          "type": "string",
          "nullable": true,
          "description": "Git commit hash if namespace is bound"
        }
      }
    }
  }
}
""";

    private static readonly string _CreateDocumentationArchive_Info = """
{
  "summary": "Create documentation archive",
  "description": "Create a .bannou bundle archive of all documents in a namespace.\nArchives are stored via Asset Service.\n",
  "tags": [
    "Archive"
  ],
  "deprecated": false,
  "operationId": "createDocumentationArchive"
}
""";

    /// <summary>Returns endpoint information for CreateDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocumentationArchive_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/create",
            _CreateDocumentationArchive_Info));

    /// <summary>Returns request schema for CreateDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocumentationArchive_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/create",
            "request-schema",
            _CreateDocumentationArchive_RequestSchema));

    /// <summary>Returns response schema for CreateDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocumentationArchive_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/create",
            "response-schema",
            _CreateDocumentationArchive_ResponseSchema));

    /// <summary>Returns full schema for CreateDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocumentationArchive_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/create",
            _CreateDocumentationArchive_Info,
            _CreateDocumentationArchive_RequestSchema,
            _CreateDocumentationArchive_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListDocumentationArchives

    private static readonly string _ListDocumentationArchives_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListArchivesRequest",
  "$defs": {
    "ListArchivesRequest": {
      "type": "object",
      "required": [
        "namespace"
      ],
      "properties": {
        "namespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50
        },
        "limit": {
          "type": "integer",
          "default": 20,
          "minimum": 1,
          "maximum": 100
        },
        "offset": {
          "type": "integer",
          "default": 0,
          "minimum": 0
        }
      }
    }
  }
}
""";

    private static readonly string _ListDocumentationArchives_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListArchivesResponse",
  "$defs": {
    "ListArchivesResponse": {
      "type": "object",
      "required": [
        "archives",
        "total"
      ],
      "properties": {
        "archives": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ArchiveInfo"
          }
        },
        "total": {
          "type": "integer"
        }
      }
    },
    "ArchiveInfo": {
      "type": "object",
      "required": [
        "archiveId",
        "namespace",
        "createdAt"
      ],
      "properties": {
        "archiveId": {
          "type": "string",
          "format": "uuid"
        },
        "namespace": {
          "type": "string"
        },
        "bundleAssetId": {
          "type": "string",
          "format": "uuid"
        },
        "description": {
          "type": "string"
        },
        "documentCount": {
          "type": "integer"
        },
        "sizeBytes": {
          "type": "integer"
        },
        "commitHash": {
          "type": "string",
          "nullable": true
        },
        "createdAt": {
          "type": "string",
          "format": "date-time"
        },
        "createdBy": {
          "type": "string",
          "format": "uuid"
        }
      }
    }
  }
}
""";

    private static readonly string _ListDocumentationArchives_Info = """
{
  "summary": "List documentation archives",
  "description": "List all archives for a namespace.\n",
  "tags": [
    "Archive"
  ],
  "deprecated": false,
  "operationId": "listDocumentationArchives"
}
""";

    /// <summary>Returns endpoint information for ListDocumentationArchives</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocumentationArchives_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/list",
            _ListDocumentationArchives_Info));

    /// <summary>Returns request schema for ListDocumentationArchives</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocumentationArchives_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/list",
            "request-schema",
            _ListDocumentationArchives_RequestSchema));

    /// <summary>Returns response schema for ListDocumentationArchives</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocumentationArchives_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/list",
            "response-schema",
            _ListDocumentationArchives_ResponseSchema));

    /// <summary>Returns full schema for ListDocumentationArchives</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocumentationArchives_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/list",
            _ListDocumentationArchives_Info,
            _ListDocumentationArchives_RequestSchema,
            _ListDocumentationArchives_ResponseSchema));

    #endregion

    #region Meta Endpoints for RestoreDocumentationArchive

    private static readonly string _RestoreDocumentationArchive_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/RestoreArchiveRequest",
  "$defs": {
    "RestoreArchiveRequest": {
      "type": "object",
      "required": [
        "archiveId"
      ],
      "properties": {
        "archiveId": {
          "type": "string",
          "format": "uuid"
        },
        "targetNamespace": {
          "type": "string",
          "pattern": "^[a-z0-9-]+$",
          "maxLength": 50,
          "description": "If not provided, restores to original namespace"
        }
      }
    }
  }
}
""";

    private static readonly string _RestoreDocumentationArchive_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/RestoreArchiveResponse",
  "$defs": {
    "RestoreArchiveResponse": {
      "type": "object",
      "required": [
        "namespace",
        "documentsRestored"
      ],
      "properties": {
        "namespace": {
          "type": "string"
        },
        "documentsRestored": {
          "type": "integer"
        },
        "previousDocumentsDeleted": {
          "type": "integer"
        }
      }
    }
  }
}
""";

    private static readonly string _RestoreDocumentationArchive_Info = """
{
  "summary": "Restore documentation from archive",
  "description": "Restore documents from a .bannou bundle archive.\nReplaces all documents in the namespace with archived content.\n",
  "tags": [
    "Archive"
  ],
  "deprecated": false,
  "operationId": "restoreDocumentationArchive"
}
""";

    /// <summary>Returns endpoint information for RestoreDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/restore/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestoreDocumentationArchive_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/restore",
            _RestoreDocumentationArchive_Info));

    /// <summary>Returns request schema for RestoreDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/restore/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestoreDocumentationArchive_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/restore",
            "request-schema",
            _RestoreDocumentationArchive_RequestSchema));

    /// <summary>Returns response schema for RestoreDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/restore/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestoreDocumentationArchive_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/restore",
            "response-schema",
            _RestoreDocumentationArchive_ResponseSchema));

    /// <summary>Returns full schema for RestoreDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/restore/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestoreDocumentationArchive_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/restore",
            _RestoreDocumentationArchive_Info,
            _RestoreDocumentationArchive_RequestSchema,
            _RestoreDocumentationArchive_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeleteDocumentationArchive

    private static readonly string _DeleteDocumentationArchive_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/DeleteArchiveRequest",
  "$defs": {
    "DeleteArchiveRequest": {
      "type": "object",
      "required": [
        "archiveId"
      ],
      "properties": {
        "archiveId": {
          "type": "string",
          "format": "uuid"
        }
      }
    }
  }
}
""";

    private static readonly string _DeleteDocumentationArchive_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/DeleteArchiveResponse",
  "$defs": {
    "DeleteArchiveResponse": {
      "type": "object",
      "required": [
        "deleted"
      ],
      "properties": {
        "deleted": {
          "type": "boolean"
        }
      }
    }
  }
}
""";

    private static readonly string _DeleteDocumentationArchive_Info = """
{
  "summary": "Delete documentation archive",
  "description": "Delete an archive from Asset Service storage.\n",
  "tags": [
    "Archive"
  ],
  "deprecated": false,
  "operationId": "deleteDocumentationArchive"
}
""";

    /// <summary>Returns endpoint information for DeleteDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocumentationArchive_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/delete",
            _DeleteDocumentationArchive_Info));

    /// <summary>Returns request schema for DeleteDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocumentationArchive_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/delete",
            "request-schema",
            _DeleteDocumentationArchive_RequestSchema));

    /// <summary>Returns response schema for DeleteDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocumentationArchive_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/delete",
            "response-schema",
            _DeleteDocumentationArchive_ResponseSchema));

    /// <summary>Returns full schema for DeleteDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocumentationArchive_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/delete",
            _DeleteDocumentationArchive_Info,
            _DeleteDocumentationArchive_RequestSchema,
            _DeleteDocumentationArchive_ResponseSchema));

    #endregion

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
