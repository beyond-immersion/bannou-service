//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Documentation;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IDocumentationController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// View documentation page in browser
    /// </summary>

    /// <remarks>
    /// Browser-facing endpoint for viewing documentation.
    /// <br/>Routed via NGINX, not exposed to WebSocket clients.
    /// <br/>Returns HTML-rendered documentation page.
    /// </remarks>

    /// <param name="slug">Document slug within namespace</param>

    /// <param name="ns">Documentation namespace (defaults to bannou)</param>

    /// <returns>HTML documentation page (returns ContentResult)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> ViewDocumentBySlugAsync(string slug, string ns, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get raw markdown content
    /// </summary>

    /// <remarks>
    /// Browser-facing endpoint for retrieving raw markdown content.
    /// <br/>Routed via NGINX, not exposed to WebSocket clients.
    /// <br/>Returns raw markdown with text/markdown content type.
    /// </remarks>

    /// <param name="slug">Document slug within namespace</param>

    /// <param name="ns">Documentation namespace (defaults to bannou)</param>

    /// <returns>Raw markdown content</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<string>> RawDocumentBySlugAsync(string slug, string ns, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Natural language documentation search
    /// </summary>

    /// <remarks>
    /// Search documentation using natural language queries.
    /// <br/>Returns the most relevant documents with voice-friendly summaries.
    /// </remarks>

    /// <returns>Search results with voice-friendly summaries</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryDocumentationResponse>> QueryDocumentationAsync(QueryDocumentationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get specific document by ID or slug
    /// </summary>

    /// <remarks>
    /// Retrieve a specific document by its unique identifier or slug.
    /// <br/>Returns full content with metadata.
    /// </remarks>

    /// <returns>Document content</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetDocumentResponse>> GetDocumentAsync(GetDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Full-text keyword search
    /// </summary>

    /// <remarks>
    /// Search documentation using exact keyword matching.
    /// <br/>Faster than semantic search but less flexible.
    /// </remarks>

    /// <returns>Matching documents</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SearchDocumentationResponse>> SearchDocumentationAsync(SearchDocumentationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List documents by category
    /// </summary>

    /// <remarks>
    /// List all documents in a specific category or all categories.
    /// <br/>Supports pagination for large result sets.
    /// </remarks>

    /// <returns>Document list</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListDocumentsResponse>> ListDocumentsAsync(ListDocumentsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get related topics and follow-up suggestions
    /// </summary>

    /// <remarks>
    /// Given a topic or document ID, returns related topics the user
    /// <br/>might want to explore. Useful for conversational AI flow.
    /// </remarks>

    /// <returns>Related topics</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SuggestRelatedResponse>> SuggestRelatedTopicsAsync(SuggestRelatedRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create new documentation entry
    /// </summary>


    /// <returns>Document created</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateDocumentResponse>> CreateDocumentAsync(CreateDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update existing documentation entry
    /// </summary>


    /// <returns>Document updated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateDocumentResponse>> UpdateDocumentAsync(UpdateDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Soft-delete documentation entry to trashcan
    /// </summary>

    /// <remarks>
    /// Moves document to trashcan for recovery within TTL period.
    /// <br/>Documents are automatically cleaned up after TrashcanTtlDays.
    /// </remarks>

    /// <returns>Document moved to trashcan</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteDocumentResponse>> DeleteDocumentAsync(DeleteDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Recover document from trashcan
    /// </summary>

    /// <remarks>
    /// Restores a soft-deleted document from the trashcan.
    /// <br/>Must be called before the trashcan TTL expires.
    /// </remarks>

    /// <returns>Document recovered</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RecoverDocumentResponse>> RecoverDocumentAsync(RecoverDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Bulk update document metadata
    /// </summary>

    /// <remarks>
    /// Apply category, tag, or metadata changes to multiple documents at once.
    /// <br/>Each document is processed independently - partial success is possible.
    /// </remarks>

    /// <returns>Bulk update results</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BulkUpdateResponse>> BulkUpdateDocumentsAsync(BulkUpdateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Bulk soft-delete documents to trashcan
    /// </summary>

    /// <remarks>
    /// Move multiple documents to trashcan at once.
    /// <br/>Each document is processed independently - partial success is possible.
    /// </remarks>

    /// <returns>Bulk delete results</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BulkDeleteResponse>> BulkDeleteDocumentsAsync(BulkDeleteRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Bulk import documentation from structured source
    /// </summary>

    /// <remarks>
    /// Import multiple documents. Each document processed independently.
    /// <br/>Partial success is possible - failures reported per document.
    /// </remarks>

    /// <returns>Import results (may include partial failures)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ImportDocumentationResponse>> ImportDocumentationAsync(ImportDocumentationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List documents in the trashcan
    /// </summary>

    /// <remarks>
    /// List all soft-deleted documents within the namespace's trashcan.
    /// <br/>Documents remain recoverable until TTL expires or purge is called.
    /// </remarks>

    /// <returns>Trashcan contents</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListTrashcanResponse>> ListTrashcanAsync(ListTrashcanRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Permanently delete trashcan items
    /// </summary>

    /// <remarks>
    /// Permanently delete specified documents from trashcan, or purge all.
    /// <br/>This operation is irreversible - documents cannot be recovered after purge.
    /// </remarks>

    /// <returns>Purge results</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PurgeTrashcanResponse>> PurgeTrashcanAsync(PurgeTrashcanRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get namespace documentation statistics
    /// </summary>

    /// <remarks>
    /// Retrieve usage statistics and metadata for a documentation namespace.
    /// <br/>Useful for monitoring, capacity planning, and administrative dashboards.
    /// </remarks>

    /// <returns>Namespace statistics</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<NamespaceStatsResponse>> GetNamespaceStatsAsync(GetNamespaceStatsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Bind a git repository to a documentation namespace
    /// </summary>

    /// <remarks>
    /// Bind a git repository URL to a documentation namespace.
    /// <br/>The namespace will be exclusively managed by the repository - manual edits will be blocked.
    /// <br/>Triggers initial sync after binding.
    /// </remarks>

    /// <returns>Repository binding created</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BindRepositoryResponse>> BindRepositoryAsync(BindRepositoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Remove repository binding from namespace
    /// </summary>

    /// <remarks>
    /// Remove repository binding from a namespace, making it manually editable again.
    /// <br/>Optionally delete all documents imported from the repository.
    /// </remarks>

    /// <returns>Repository binding removed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UnbindRepositoryResponse>> UnbindRepositoryAsync(UnbindRepositoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Manually trigger repository sync
    /// </summary>

    /// <remarks>
    /// Manually trigger synchronization of a bound repository.
    /// <br/>If force=true, performs full re-sync regardless of commit hash.
    /// </remarks>

    /// <returns>Sync completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SyncRepositoryResponse>> SyncRepositoryAsync(SyncRepositoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get repository binding status
    /// </summary>

    /// <remarks>
    /// Get current status of a repository binding including sync state and statistics.
    /// </remarks>

    /// <returns>Repository binding status</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RepositoryStatusResponse>> GetRepositoryStatusAsync(RepositoryStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List all repository bindings
    /// </summary>

    /// <remarks>
    /// List all repository bindings with optional filtering by status.
    /// </remarks>

    /// <returns>List of repository bindings</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListRepositoryBindingsResponse>> ListRepositoryBindingsAsync(ListRepositoryBindingsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update repository binding configuration
    /// </summary>

    /// <remarks>
    /// Update sync settings, file patterns, category mappings, or archive configuration.
    /// </remarks>

    /// <returns>Repository binding updated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateRepositoryBindingResponse>> UpdateRepositoryBindingAsync(UpdateRepositoryBindingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create documentation archive
    /// </summary>

    /// <remarks>
    /// Create a .bannou bundle archive of all documents in a namespace.
    /// <br/>Archives are stored via Asset Service.
    /// </remarks>

    /// <returns>Archive created</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateArchiveResponse>> CreateDocumentationArchiveAsync(CreateArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List documentation archives
    /// </summary>

    /// <remarks>
    /// List all archives for a namespace.
    /// </remarks>

    /// <returns>List of archives</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListArchivesResponse>> ListDocumentationArchivesAsync(ListArchivesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Restore documentation from archive
    /// </summary>

    /// <remarks>
    /// Restore documents from a .bannou bundle archive.
    /// <br/>Replaces all documents in the namespace with archived content.
    /// </remarks>

    /// <returns>Archive restored</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RestoreArchiveResponse>> RestoreDocumentationArchiveAsync(RestoreArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete documentation archive
    /// </summary>

    /// <remarks>
    /// Delete an archive from Asset Service storage.
    /// </remarks>

    /// <returns>Archive deleted</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteArchiveResponse>> DeleteDocumentationArchiveAsync(DeleteArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class DocumentationController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IDocumentationService _implementation;

    public DocumentationController(IDocumentationService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.Created => Created("", result),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.Created => result != null ? Created("", result) : Created("", null),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    // Endpoint ViewDocumentBySlug requires manual implementation in partial class.
    // See x-manual-implementation: true in the OpenAPI schema.

    // Endpoint RawDocumentBySlug requires manual implementation in partial class.
    // See x-manual-implementation: true in the OpenAPI schema.

    /// <summary>
    /// Natural language documentation search
    /// </summary>
    /// <remarks>
    /// Search documentation using natural language queries.
    /// <br/>Returns the most relevant documents with voice-friendly summaries.
    /// </remarks>
    /// <returns>Search results with voice-friendly summaries</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/query")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryDocumentationResponse>> QueryDocumentation([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryDocumentationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.QueryDocumentationAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get specific document by ID or slug
    /// </summary>
    /// <remarks>
    /// Retrieve a specific document by its unique identifier or slug.
    /// <br/>Returns full content with metadata.
    /// </remarks>
    /// <returns>Document content</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<GetDocumentResponse>> GetDocument([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetDocumentAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Full-text keyword search
    /// </summary>
    /// <remarks>
    /// Search documentation using exact keyword matching.
    /// <br/>Faster than semantic search but less flexible.
    /// </remarks>
    /// <returns>Matching documents</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/search")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SearchDocumentationResponse>> SearchDocumentation([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SearchDocumentationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.SearchDocumentationAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List documents by category
    /// </summary>
    /// <remarks>
    /// List all documents in a specific category or all categories.
    /// <br/>Supports pagination for large result sets.
    /// </remarks>
    /// <returns>Document list</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListDocumentsResponse>> ListDocuments([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListDocumentsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListDocumentsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get related topics and follow-up suggestions
    /// </summary>
    /// <remarks>
    /// Given a topic or document ID, returns related topics the user
    /// <br/>might want to explore. Useful for conversational AI flow.
    /// </remarks>
    /// <returns>Related topics</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/suggest")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SuggestRelatedResponse>> SuggestRelatedTopics([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SuggestRelatedRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.SuggestRelatedTopicsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Create new documentation entry
    /// </summary>
    /// <returns>Document created</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateDocumentResponse>> CreateDocument([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateDocumentAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Update existing documentation entry
    /// </summary>
    /// <returns>Document updated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateDocumentResponse>> UpdateDocument([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateDocumentAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Soft-delete documentation entry to trashcan
    /// </summary>
    /// <remarks>
    /// Moves document to trashcan for recovery within TTL period.
    /// <br/>Documents are automatically cleaned up after TrashcanTtlDays.
    /// </remarks>
    /// <returns>Document moved to trashcan</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteDocumentResponse>> DeleteDocument([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DeleteDocumentAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Recover document from trashcan
    /// </summary>
    /// <remarks>
    /// Restores a soft-deleted document from the trashcan.
    /// <br/>Must be called before the trashcan TTL expires.
    /// </remarks>
    /// <returns>Document recovered</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/recover")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RecoverDocumentResponse>> RecoverDocument([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RecoverDocumentRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RecoverDocumentAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Bulk update document metadata
    /// </summary>
    /// <remarks>
    /// Apply category, tag, or metadata changes to multiple documents at once.
    /// <br/>Each document is processed independently - partial success is possible.
    /// </remarks>
    /// <returns>Bulk update results</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BulkUpdateResponse>> BulkUpdateDocuments([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BulkUpdateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.BulkUpdateDocumentsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Bulk soft-delete documents to trashcan
    /// </summary>
    /// <remarks>
    /// Move multiple documents to trashcan at once.
    /// <br/>Each document is processed independently - partial success is possible.
    /// </remarks>
    /// <returns>Bulk delete results</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BulkDeleteResponse>> BulkDeleteDocuments([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BulkDeleteRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.BulkDeleteDocumentsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Bulk import documentation from structured source
    /// </summary>
    /// <remarks>
    /// Import multiple documents. Each document processed independently.
    /// <br/>Partial success is possible - failures reported per document.
    /// </remarks>
    /// <returns>Import results (may include partial failures)</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/import")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ImportDocumentationResponse>> ImportDocumentation([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ImportDocumentationRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ImportDocumentationAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List documents in the trashcan
    /// </summary>
    /// <remarks>
    /// List all soft-deleted documents within the namespace's trashcan.
    /// <br/>Documents remain recoverable until TTL expires or purge is called.
    /// </remarks>
    /// <returns>Trashcan contents</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/trashcan")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListTrashcanResponse>> ListTrashcan([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListTrashcanRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListTrashcanAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Permanently delete trashcan items
    /// </summary>
    /// <remarks>
    /// Permanently delete specified documents from trashcan, or purge all.
    /// <br/>This operation is irreversible - documents cannot be recovered after purge.
    /// </remarks>
    /// <returns>Purge results</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/purge")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PurgeTrashcanResponse>> PurgeTrashcan([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] PurgeTrashcanRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.PurgeTrashcanAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get namespace documentation statistics
    /// </summary>
    /// <remarks>
    /// Retrieve usage statistics and metadata for a documentation namespace.
    /// <br/>Useful for monitoring, capacity planning, and administrative dashboards.
    /// </remarks>
    /// <returns>Namespace statistics</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/stats")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<NamespaceStatsResponse>> GetNamespaceStats([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetNamespaceStatsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetNamespaceStatsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Bind a git repository to a documentation namespace
    /// </summary>
    /// <remarks>
    /// Bind a git repository URL to a documentation namespace.
    /// <br/>The namespace will be exclusively managed by the repository - manual edits will be blocked.
    /// <br/>Triggers initial sync after binding.
    /// </remarks>
    /// <returns>Repository binding created</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/bind")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BindRepositoryResponse>> BindRepository([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] BindRepositoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.BindRepositoryAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Remove repository binding from namespace
    /// </summary>
    /// <remarks>
    /// Remove repository binding from a namespace, making it manually editable again.
    /// <br/>Optionally delete all documents imported from the repository.
    /// </remarks>
    /// <returns>Repository binding removed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/unbind")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UnbindRepositoryResponse>> UnbindRepository([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UnbindRepositoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UnbindRepositoryAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Manually trigger repository sync
    /// </summary>
    /// <remarks>
    /// Manually trigger synchronization of a bound repository.
    /// <br/>If force=true, performs full re-sync regardless of commit hash.
    /// </remarks>
    /// <returns>Sync completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/sync")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<SyncRepositoryResponse>> SyncRepository([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] SyncRepositoryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.SyncRepositoryAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get repository binding status
    /// </summary>
    /// <remarks>
    /// Get current status of a repository binding including sync state and statistics.
    /// </remarks>
    /// <returns>Repository binding status</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RepositoryStatusResponse>> GetRepositoryStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RepositoryStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetRepositoryStatusAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List all repository bindings
    /// </summary>
    /// <remarks>
    /// List all repository bindings with optional filtering by status.
    /// </remarks>
    /// <returns>List of repository bindings</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListRepositoryBindingsResponse>> ListRepositoryBindings([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListRepositoryBindingsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListRepositoryBindingsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Update repository binding configuration
    /// </summary>
    /// <remarks>
    /// Update sync settings, file patterns, category mappings, or archive configuration.
    /// </remarks>
    /// <returns>Repository binding updated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<UpdateRepositoryBindingResponse>> UpdateRepositoryBinding([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateRepositoryBindingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateRepositoryBindingAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Create documentation archive
    /// </summary>
    /// <remarks>
    /// Create a .bannou bundle archive of all documents in a namespace.
    /// <br/>Archives are stored via Asset Service.
    /// </remarks>
    /// <returns>Archive created</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CreateArchiveResponse>> CreateDocumentationArchive([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateDocumentationArchiveAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List documentation archives
    /// </summary>
    /// <remarks>
    /// List all archives for a namespace.
    /// </remarks>
    /// <returns>List of archives</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListArchivesResponse>> ListDocumentationArchives([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListArchivesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListDocumentationArchivesAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Restore documentation from archive
    /// </summary>
    /// <remarks>
    /// Restore documents from a .bannou bundle archive.
    /// <br/>Replaces all documents in the namespace with archived content.
    /// </remarks>
    /// <returns>Archive restored</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/restore")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RestoreArchiveResponse>> RestoreDocumentationArchive([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RestoreArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RestoreDocumentationArchiveAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Delete documentation archive
    /// </summary>
    /// <remarks>
    /// Delete an archive from Asset Service storage.
    /// </remarks>
    /// <returns>Archive deleted</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteArchiveResponse>> DeleteDocumentationArchive([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteArchiveRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DeleteDocumentationArchiveAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }



    #region Meta Endpoints for ViewDocumentBySlug

    private static readonly string _ViewDocumentBySlug_RequestSchema = """
{}
""";

    private static readonly string _ViewDocumentBySlug_ResponseSchema = """
{}
""";

    private static readonly string _ViewDocumentBySlug_Info = """
{
    "summary": "View documentation page in browser",
    "description": "Browser-facing endpoint for viewing documentation.\nRouted via NGINX, not exposed to WebSocket clients.\nReturns HTML-rendered documentation page.\n",
    "tags": [
        "Browser"
    ],
    "deprecated": false,
    "operationId": "viewDocumentBySlug"
}
""";

    /// <summary>Returns endpoint information for ViewDocumentBySlug</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/view/{slug}/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ViewDocumentBySlug_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Get",
            "documentation/view/{slug}",
            _ViewDocumentBySlug_Info));

    /// <summary>Returns request schema for ViewDocumentBySlug</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/view/{slug}/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ViewDocumentBySlug_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Get",
            "documentation/view/{slug}",
            "request-schema",
            _ViewDocumentBySlug_RequestSchema));

    /// <summary>Returns response schema for ViewDocumentBySlug</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/view/{slug}/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ViewDocumentBySlug_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Get",
            "documentation/view/{slug}",
            "response-schema",
            _ViewDocumentBySlug_ResponseSchema));

    /// <summary>Returns full schema for ViewDocumentBySlug</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/view/{slug}/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ViewDocumentBySlug_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Get",
            "documentation/view/{slug}",
            _ViewDocumentBySlug_Info,
            _ViewDocumentBySlug_RequestSchema,
            _ViewDocumentBySlug_ResponseSchema));

    #endregion

    #region Meta Endpoints for RawDocumentBySlug

    private static readonly string _RawDocumentBySlug_RequestSchema = """
{}
""";

    private static readonly string _RawDocumentBySlug_ResponseSchema = """
{}
""";

    private static readonly string _RawDocumentBySlug_Info = """
{
    "summary": "Get raw markdown content",
    "description": "Browser-facing endpoint for retrieving raw markdown content.\nRouted via NGINX, not exposed to WebSocket clients.\nReturns raw markdown with text/markdown content type.\n",
    "tags": [
        "Browser"
    ],
    "deprecated": false,
    "operationId": "rawDocumentBySlug"
}
""";

    /// <summary>Returns endpoint information for RawDocumentBySlug</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/raw/{slug}/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RawDocumentBySlug_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Get",
            "documentation/raw/{slug}",
            _RawDocumentBySlug_Info));

    /// <summary>Returns request schema for RawDocumentBySlug</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/raw/{slug}/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RawDocumentBySlug_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Get",
            "documentation/raw/{slug}",
            "request-schema",
            _RawDocumentBySlug_RequestSchema));

    /// <summary>Returns response schema for RawDocumentBySlug</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/raw/{slug}/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RawDocumentBySlug_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Get",
            "documentation/raw/{slug}",
            "response-schema",
            _RawDocumentBySlug_ResponseSchema));

    /// <summary>Returns full schema for RawDocumentBySlug</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/raw/{slug}/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RawDocumentBySlug_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Get",
            "documentation/raw/{slug}",
            _RawDocumentBySlug_Info,
            _RawDocumentBySlug_RequestSchema,
            _RawDocumentBySlug_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryDocumentation

    private static readonly string _QueryDocumentation_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryDocumentationRequest",
    "$defs": {
        "QueryDocumentationRequest": {
            "description": "Request to search documentation using natural language queries",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "query"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace to search within"
                },
                "query": {
                    "type": "string",
                    "minLength": 3,
                    "maxLength": 500,
                    "description": "Natural language query to search for"
                },
                "sessionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Optional session ID for conversational context"
                },
                "category": {
                    "$ref": "#/$defs/DocumentCategory",
                    "description": "Filter results to a specific category"
                },
                "maxResults": {
                    "type": "integer",
                    "default": 5,
                    "minimum": 1,
                    "maximum": 20,
                    "description": "Maximum number of results to return"
                },
                "includeContent": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether to include full document content in results"
                },
                "maxSummaryLength": {
                    "type": "integer",
                    "default": 300,
                    "minimum": 50,
                    "maximum": 500,
                    "description": "Maximum length of summaries in characters"
                },
                "minRelevanceScore": {
                    "type": "number",
                    "format": "float",
                    "default": 0.3,
                    "minimum": 0.0,
                    "maximum": 1.0,
                    "description": "Minimum relevance score threshold for results"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        }
    }
}
""";

    private static readonly string _QueryDocumentation_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryDocumentationResponse",
    "$defs": {
        "QueryDocumentationResponse": {
            "description": "Response containing search results and voice-friendly summaries",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "query",
                "results"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace that was searched"
                },
                "query": {
                    "type": "string",
                    "description": "The original query string"
                },
                "results": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/DocumentResult"
                    },
                    "description": "List of matching documents"
                },
                "totalResults": {
                    "type": "integer",
                    "description": "Total number of matching documents"
                },
                "voiceSummary": {
                    "type": "string",
                    "description": "Concise spoken summary for voice AI"
                },
                "suggestedFollowups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Suggested follow-up queries"
                },
                "noResultsMessage": {
                    "type": "string",
                    "description": "User-friendly message when no results found"
                }
            }
        },
        "DocumentResult": {
            "description": "Search result with relevance scoring and match highlights",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "documentId",
                "slug",
                "title",
                "relevanceScore"
            ],
            "properties": {
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the document"
                },
                "slug": {
                    "type": "string",
                    "description": "URL-friendly unique identifier"
                },
                "title": {
                    "type": "string",
                    "description": "Display title of the document"
                },
                "category": {
                    "$ref": "#/$defs/DocumentCategory",
                    "description": "Category of the document"
                },
                "summary": {
                    "type": "string",
                    "nullable": true,
                    "description": "Brief text summary of the document"
                },
                "voiceSummary": {
                    "type": "string",
                    "nullable": true,
                    "description": "Concise summary optimized for voice AI"
                },
                "content": {
                    "type": "string",
                    "nullable": true,
                    "description": "Full document content if requested"
                },
                "relevanceScore": {
                    "type": "number",
                    "format": "float",
                    "description": "Relevance score from 0.0 to 1.0"
                },
                "matchHighlights": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Text snippets showing where matches occurred"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        }
    }
}
""";

    private static readonly string _QueryDocumentation_Info = """
{
    "summary": "Natural language documentation search",
    "description": "Search documentation using natural language queries.\nReturns the most relevant documents with voice-friendly summaries.\n",
    "tags": [
        "Search"
    ],
    "deprecated": false,
    "operationId": "queryDocumentation"
}
""";

    /// <summary>Returns endpoint information for QueryDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/query/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryDocumentation_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/query",
            _QueryDocumentation_Info));

    /// <summary>Returns request schema for QueryDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/query/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryDocumentation_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/query",
            "request-schema",
            _QueryDocumentation_RequestSchema));

    /// <summary>Returns response schema for QueryDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/query/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryDocumentation_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/query",
            "response-schema",
            _QueryDocumentation_ResponseSchema));

    /// <summary>Returns full schema for QueryDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/query/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryDocumentation_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/query",
            _QueryDocumentation_Info,
            _QueryDocumentation_RequestSchema,
            _QueryDocumentation_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetDocument

    private static readonly string _GetDocument_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetDocumentRequest",
    "$defs": {
        "GetDocumentRequest": {
            "description": "Request to retrieve a specific document by ID or slug",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace containing the document"
                },
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Unique identifier of the document to retrieve (null if using slug)"
                },
                "slug": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "nullable": true,
                    "description": "URL-friendly slug of the document to retrieve (null if using documentId)"
                },
                "sessionId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Optional session ID for tracking document views (null if not tracking)"
                },
                "includeRelated": {
                    "$ref": "#/$defs/RelatedDepth",
                    "nullable": true,
                    "description": "How deep to fetch related documents (null for no related documents)"
                },
                "includeContent": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether to include full document content"
                },
                "renderHtml": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether to render markdown content as HTML"
                }
            }
        },
        "RelatedDepth": {
            "type": "string",
            "enum": [
                "none",
                "direct",
                "extended"
            ],
            "default": "direct",
            "description": "How deep to traverse related document links:\n- none: No related documents included\n- direct: Only directly linked documents (depth 1)\n- extended: Related documents + their related documents (depth 2)\n"
        }
    }
}
""";

    private static readonly string _GetDocument_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetDocumentResponse",
    "$defs": {
        "GetDocumentResponse": {
            "description": "Response containing the requested document and optional related documents",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "document"
            ],
            "properties": {
                "document": {
                    "$ref": "#/$defs/Document",
                    "description": "The requested document"
                },
                "relatedDocuments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/DocumentSummary"
                    },
                    "description": "List of related documents based on includeRelated depth"
                },
                "contentFormat": {
                    "type": "string",
                    "enum": [
                        "markdown",
                        "html",
                        "none"
                    ],
                    "description": "Format of the content field in the response"
                }
            }
        },
        "Document": {
            "description": "Complete document with all metadata and content",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "documentId",
                "namespace",
                "slug",
                "title",
                "category",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the document"
                },
                "namespace": {
                    "type": "string",
                    "description": "Namespace the document belongs to"
                },
                "slug": {
                    "type": "string",
                    "description": "URL-friendly unique identifier"
                },
                "title": {
                    "type": "string",
                    "description": "Display title of the document"
                },
                "category": {
                    "$ref": "#/$defs/DocumentCategory",
                    "description": "Category for organizing the document"
                },
                "content": {
                    "type": "string",
                    "description": "Full markdown content of the document"
                },
                "summary": {
                    "type": "string",
                    "nullable": true,
                    "description": "Brief text summary of the document"
                },
                "voiceSummary": {
                    "type": "string",
                    "nullable": true,
                    "description": "Concise summary optimized for voice AI"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags for filtering and search"
                },
                "relatedDocuments": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "uuid"
                    },
                    "description": "IDs of related documents"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Custom metadata key-value pairs"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the document was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the document was last updated"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        },
        "DocumentSummary": {
            "description": "Lightweight document representation for listings and references",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "documentId",
                "slug",
                "title",
                "category"
            ],
            "properties": {
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the document"
                },
                "slug": {
                    "type": "string",
                    "description": "URL-friendly unique identifier"
                },
                "title": {
                    "type": "string",
                    "description": "Display title of the document"
                },
                "category": {
                    "$ref": "#/$defs/DocumentCategory",
                    "description": "Category of the document"
                },
                "summary": {
                    "type": "string",
                    "nullable": true,
                    "description": "Brief text summary of the document"
                },
                "voiceSummary": {
                    "type": "string",
                    "nullable": true,
                    "description": "Concise summary optimized for voice AI"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags associated with the document"
                }
            }
        }
    }
}
""";

    private static readonly string _GetDocument_Info = """
{
    "summary": "Get specific document by ID or slug",
    "description": "Retrieve a specific document by its unique identifier or slug.\nReturns full content with metadata.\n",
    "tags": [
        "Documents"
    ],
    "deprecated": false,
    "operationId": "getDocument"
}
""";

    /// <summary>Returns endpoint information for GetDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDocument_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/get",
            _GetDocument_Info));

    /// <summary>Returns request schema for GetDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDocument_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/get",
            "request-schema",
            _GetDocument_RequestSchema));

    /// <summary>Returns response schema for GetDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDocument_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/get",
            "response-schema",
            _GetDocument_ResponseSchema));

    /// <summary>Returns full schema for GetDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDocument_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/get",
            _GetDocument_Info,
            _GetDocument_RequestSchema,
            _GetDocument_ResponseSchema));

    #endregion

    #region Meta Endpoints for SearchDocumentation

    private static readonly string _SearchDocumentation_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/SearchDocumentationRequest",
    "$defs": {
        "SearchDocumentationRequest": {
            "description": "Request to search documentation using keyword matching",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "searchTerm"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace to search within"
                },
                "searchTerm": {
                    "type": "string",
                    "minLength": 2,
                    "maxLength": 200,
                    "description": "Keyword or phrase to search for"
                },
                "sessionId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Optional session ID for tracking searches (null if not tracking)"
                },
                "category": {
                    "$ref": "#/$defs/DocumentCategory",
                    "nullable": true,
                    "description": "Filter results to a specific category (null for all categories)"
                },
                "maxResults": {
                    "type": "integer",
                    "default": 10,
                    "minimum": 1,
                    "maximum": 50,
                    "description": "Maximum number of results to return"
                },
                "searchIn": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/SearchField"
                    },
                    "nullable": true,
                    "description": "Fields to search within (null for default fields)"
                },
                "sortBy": {
                    "type": "string",
                    "enum": [
                        "relevance",
                        "recency",
                        "alphabetical"
                    ],
                    "default": "relevance",
                    "description": "How to sort the search results"
                },
                "includeContent": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether to include full document content in results"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        },
        "SearchField": {
            "type": "string",
            "enum": [
                "title",
                "content",
                "tags",
                "summary"
            ],
            "description": "Fields that can be searched within documents"
        }
    }
}
""";

    private static readonly string _SearchDocumentation_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/SearchDocumentationResponse",
    "$defs": {
        "SearchDocumentationResponse": {
            "description": "Response containing keyword search results",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "results"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace that was searched"
                },
                "results": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/DocumentResult"
                    },
                    "description": "List of matching documents"
                },
                "totalResults": {
                    "type": "integer",
                    "description": "Total number of matching documents"
                },
                "searchTerm": {
                    "type": "string",
                    "description": "The original search term"
                }
            }
        },
        "DocumentResult": {
            "description": "Search result with relevance scoring and match highlights",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "documentId",
                "slug",
                "title",
                "relevanceScore"
            ],
            "properties": {
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the document"
                },
                "slug": {
                    "type": "string",
                    "description": "URL-friendly unique identifier"
                },
                "title": {
                    "type": "string",
                    "description": "Display title of the document"
                },
                "category": {
                    "$ref": "#/$defs/DocumentCategory",
                    "description": "Category of the document"
                },
                "summary": {
                    "type": "string",
                    "nullable": true,
                    "description": "Brief text summary of the document"
                },
                "voiceSummary": {
                    "type": "string",
                    "nullable": true,
                    "description": "Concise summary optimized for voice AI"
                },
                "content": {
                    "type": "string",
                    "nullable": true,
                    "description": "Full document content if requested"
                },
                "relevanceScore": {
                    "type": "number",
                    "format": "float",
                    "description": "Relevance score from 0.0 to 1.0"
                },
                "matchHighlights": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Text snippets showing where matches occurred"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        }
    }
}
""";

    private static readonly string _SearchDocumentation_Info = """
{
    "summary": "Full-text keyword search",
    "description": "Search documentation using exact keyword matching.\nFaster than semantic search but less flexible.\n",
    "tags": [
        "Search"
    ],
    "deprecated": false,
    "operationId": "searchDocumentation"
}
""";

    /// <summary>Returns endpoint information for SearchDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/search/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchDocumentation_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/search",
            _SearchDocumentation_Info));

    /// <summary>Returns request schema for SearchDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/search/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchDocumentation_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/search",
            "request-schema",
            _SearchDocumentation_RequestSchema));

    /// <summary>Returns response schema for SearchDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/search/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchDocumentation_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/search",
            "response-schema",
            _SearchDocumentation_ResponseSchema));

    /// <summary>Returns full schema for SearchDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/search/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SearchDocumentation_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/search",
            _SearchDocumentation_Info,
            _SearchDocumentation_RequestSchema,
            _SearchDocumentation_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListDocuments

    private static readonly string _ListDocuments_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListDocumentsRequest",
    "$defs": {
        "ListDocumentsRequest": {
            "description": "Request to list documents with optional filtering and pagination",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace to list documents from"
                },
                "category": {
                    "$ref": "#/$defs/DocumentCategory",
                    "description": "Filter to a specific category"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Filter by tags (null to skip tag filtering)"
                },
                "tagsMatch": {
                    "type": "string",
                    "enum": [
                        "all",
                        "any"
                    ],
                    "default": "all",
                    "description": "Whether documents must match all tags or any tag"
                },
                "createdAfter": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Filter to documents created after this timestamp"
                },
                "createdBefore": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Filter to documents created before this timestamp"
                },
                "updatedAfter": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Filter to documents updated after this timestamp"
                },
                "updatedBefore": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Filter to documents updated before this timestamp"
                },
                "titlesOnly": {
                    "type": "boolean",
                    "default": false,
                    "description": "Return only document titles without summaries"
                },
                "page": {
                    "type": "integer",
                    "default": 1,
                    "minimum": 1,
                    "description": "Page number for pagination"
                },
                "pageSize": {
                    "type": "integer",
                    "default": 20,
                    "minimum": 1,
                    "maximum": 100,
                    "description": "Number of documents per page"
                },
                "sortBy": {
                    "$ref": "#/$defs/ListSortField",
                    "description": "Field to sort results by"
                },
                "sortOrder": {
                    "type": "string",
                    "enum": [
                        "asc",
                        "desc"
                    ],
                    "default": "desc",
                    "description": "Sort order direction"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        },
        "ListSortField": {
            "type": "string",
            "enum": [
                "created_at",
                "updated_at",
                "title"
            ],
            "default": "updated_at",
            "description": "Fields available for sorting document lists"
        }
    }
}
""";

    private static readonly string _ListDocuments_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListDocumentsResponse",
    "$defs": {
        "ListDocumentsResponse": {
            "description": "Response containing a paginated list of documents",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "documents"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace that was listed"
                },
                "documents": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/DocumentSummary"
                    },
                    "description": "List of documents in the namespace"
                },
                "totalCount": {
                    "type": "integer",
                    "description": "Total number of documents matching filters"
                },
                "page": {
                    "type": "integer",
                    "description": "Current page number"
                },
                "pageSize": {
                    "type": "integer",
                    "description": "Number of documents per page"
                },
                "totalPages": {
                    "type": "integer",
                    "description": "Total number of pages available"
                }
            }
        },
        "DocumentSummary": {
            "description": "Lightweight document representation for listings and references",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "documentId",
                "slug",
                "title",
                "category"
            ],
            "properties": {
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the document"
                },
                "slug": {
                    "type": "string",
                    "description": "URL-friendly unique identifier"
                },
                "title": {
                    "type": "string",
                    "description": "Display title of the document"
                },
                "category": {
                    "$ref": "#/$defs/DocumentCategory",
                    "description": "Category of the document"
                },
                "summary": {
                    "type": "string",
                    "nullable": true,
                    "description": "Brief text summary of the document"
                },
                "voiceSummary": {
                    "type": "string",
                    "nullable": true,
                    "description": "Concise summary optimized for voice AI"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Tags associated with the document"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        }
    }
}
""";

    private static readonly string _ListDocuments_Info = """
{
    "summary": "List documents by category",
    "description": "List all documents in a specific category or all categories.\nSupports pagination for large result sets.\n",
    "tags": [
        "Documents"
    ],
    "deprecated": false,
    "operationId": "listDocuments"
}
""";

    /// <summary>Returns endpoint information for ListDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocuments_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/list",
            _ListDocuments_Info));

    /// <summary>Returns request schema for ListDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocuments_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/list",
            "request-schema",
            _ListDocuments_RequestSchema));

    /// <summary>Returns response schema for ListDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocuments_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/list",
            "response-schema",
            _ListDocuments_ResponseSchema));

    /// <summary>Returns full schema for ListDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocuments_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/list",
            _ListDocuments_Info,
            _ListDocuments_RequestSchema,
            _ListDocuments_ResponseSchema));

    #endregion

    #region Meta Endpoints for SuggestRelatedTopics

    private static readonly string _SuggestRelatedTopics_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/SuggestRelatedRequest",
    "$defs": {
        "SuggestRelatedRequest": {
            "description": "Request to get related topic suggestions based on a source",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "suggestionSource"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace for suggestions"
                },
                "suggestionSource": {
                    "$ref": "#/$defs/SuggestionSource",
                    "description": "Type of source to base suggestions on"
                },
                "sourceValue": {
                    "type": "string",
                    "description": "The value for the suggestion source (document ID, slug, topic, or category)"
                },
                "sessionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Optional session ID for personalized suggestions"
                },
                "maxSuggestions": {
                    "type": "integer",
                    "default": 5,
                    "minimum": 1,
                    "maximum": 10,
                    "description": "Maximum number of suggestions to return"
                },
                "excludeRecentlyViewed": {
                    "type": "boolean",
                    "default": true,
                    "description": "Exclude documents viewed in current session"
                }
            }
        },
        "SuggestionSource": {
            "type": "string",
            "enum": [
                "document_id",
                "slug",
                "topic",
                "category"
            ],
            "description": "Source type for generating related topic suggestions"
        }
    }
}
""";

    private static readonly string _SuggestRelatedTopics_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/SuggestRelatedResponse",
    "$defs": {
        "SuggestRelatedResponse": {
            "description": "Response containing suggested related topics for conversational flow",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "suggestions"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace suggestions are from"
                },
                "suggestions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/TopicSuggestion"
                    },
                    "description": "List of suggested related topics"
                },
                "voicePrompt": {
                    "type": "string",
                    "description": "Voice-friendly prompt for presenting suggestions"
                },
                "sessionInfluenced": {
                    "type": "boolean",
                    "description": "Whether suggestions were influenced by session history"
                }
            }
        },
        "TopicSuggestion": {
            "description": "A suggested related topic with relevance context",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "documentId",
                "title"
            ],
            "properties": {
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the suggested document"
                },
                "slug": {
                    "type": "string",
                    "description": "URL-friendly slug of the suggested document"
                },
                "title": {
                    "type": "string",
                    "description": "Title of the suggested document"
                },
                "category": {
                    "$ref": "#/$defs/DocumentCategory",
                    "description": "Category of the suggested document"
                },
                "relevanceReason": {
                    "type": "string",
                    "description": "Explanation of why this document is relevant"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        }
    }
}
""";

    private static readonly string _SuggestRelatedTopics_Info = """
{
    "summary": "Get related topics and follow-up suggestions",
    "description": "Given a topic or document ID, returns related topics the user\nmight want to explore. Useful for conversational AI flow.\n",
    "tags": [
        "Search"
    ],
    "deprecated": false,
    "operationId": "suggestRelatedTopics"
}
""";

    /// <summary>Returns endpoint information for SuggestRelatedTopics</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/suggest/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SuggestRelatedTopics_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/suggest",
            _SuggestRelatedTopics_Info));

    /// <summary>Returns request schema for SuggestRelatedTopics</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/suggest/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SuggestRelatedTopics_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/suggest",
            "request-schema",
            _SuggestRelatedTopics_RequestSchema));

    /// <summary>Returns response schema for SuggestRelatedTopics</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/suggest/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SuggestRelatedTopics_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/suggest",
            "response-schema",
            _SuggestRelatedTopics_ResponseSchema));

    /// <summary>Returns full schema for SuggestRelatedTopics</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/suggest/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SuggestRelatedTopics_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/suggest",
            _SuggestRelatedTopics_Info,
            _SuggestRelatedTopics_RequestSchema,
            _SuggestRelatedTopics_ResponseSchema));

    #endregion

    #region Meta Endpoints for CreateDocument

    private static readonly string _CreateDocument_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateDocumentRequest",
    "$defs": {
        "CreateDocumentRequest": {
            "description": "Request to create a new documentation entry",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "slug",
                "title",
                "category",
                "content"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace to create document in"
                },
                "slug": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 100,
                    "description": "URL-friendly unique identifier for the document"
                },
                "title": {
                    "type": "string",
                    "maxLength": 200,
                    "description": "Display title of the document"
                },
                "category": {
                    "$ref": "#/$defs/DocumentCategory",
                    "description": "Category for organizing the document"
                },
                "content": {
                    "type": "string",
                    "description": "Markdown content (max 500KB)"
                },
                "summary": {
                    "type": "string",
                    "maxLength": 500,
                    "nullable": true,
                    "description": "Brief text summary of the document (null if not provided)"
                },
                "voiceSummary": {
                    "type": "string",
                    "maxLength": 200,
                    "nullable": true,
                    "description": "Concise summary optimized for voice AI (null if not provided)"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Tags for filtering and search (null to skip tagging)"
                },
                "relatedDocuments": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "uuid"
                    },
                    "nullable": true,
                    "description": "IDs of related documents to link (null to skip linking)"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Custom metadata key-value pairs (null if not needed)"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        }
    }
}
""";

    private static readonly string _CreateDocument_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateDocumentResponse",
    "$defs": {
        "CreateDocumentResponse": {
            "description": "Response confirming document creation with assigned identifiers",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "documentId",
                "slug"
            ],
            "properties": {
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the created document"
                },
                "slug": {
                    "type": "string",
                    "description": "URL-friendly slug of the created document"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the document was created"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateDocument_Info = """
{
    "summary": "Create new documentation entry",
    "description": "",
    "tags": [
        "Admin"
    ],
    "deprecated": false,
    "operationId": "createDocument"
}
""";

    /// <summary>Returns endpoint information for CreateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocument_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/create",
            _CreateDocument_Info));

    /// <summary>Returns request schema for CreateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocument_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/create",
            "request-schema",
            _CreateDocument_RequestSchema));

    /// <summary>Returns response schema for CreateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocument_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/create",
            "response-schema",
            _CreateDocument_ResponseSchema));

    /// <summary>Returns full schema for CreateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocument_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/create",
            _CreateDocument_Info,
            _CreateDocument_RequestSchema,
            _CreateDocument_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateDocument

    private static readonly string _UpdateDocument_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateDocumentRequest",
    "$defs": {
        "UpdateDocumentRequest": {
            "description": "Request to update an existing document's fields",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "documentId"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace containing the document"
                },
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the document to update"
                },
                "slug": {
                    "type": "string",
                    "nullable": true,
                    "description": "New URL-friendly slug for the document (null to keep unchanged)"
                },
                "title": {
                    "type": "string",
                    "nullable": true,
                    "description": "New display title for the document (null to keep unchanged)"
                },
                "category": {
                    "$ref": "#/$defs/DocumentCategory",
                    "nullable": true,
                    "description": "New category for the document (null to keep unchanged)"
                },
                "content": {
                    "type": "string",
                    "nullable": true,
                    "description": "New markdown content for the document (null to keep unchanged)"
                },
                "summary": {
                    "type": "string",
                    "nullable": true,
                    "description": "New text summary for the document (null to keep unchanged)"
                },
                "voiceSummary": {
                    "type": "string",
                    "nullable": true,
                    "description": "New voice-optimized summary for the document (null to keep unchanged)"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "New set of tags for the document (null to keep unchanged)"
                },
                "relatedDocuments": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "uuid"
                    },
                    "nullable": true,
                    "description": "New set of related document IDs (null to keep unchanged)"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "New custom metadata key-value pairs (null to keep unchanged)"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        }
    }
}
""";

    private static readonly string _UpdateDocument_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateDocumentResponse",
    "$defs": {
        "UpdateDocumentResponse": {
            "description": "Response confirming document update with timestamp",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "documentId",
                "updatedAt"
            ],
            "properties": {
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the updated document"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the document was updated"
                }
            }
        }
    }
}
""";

    private static readonly string _UpdateDocument_Info = """
{
    "summary": "Update existing documentation entry",
    "description": "",
    "tags": [
        "Admin"
    ],
    "deprecated": false,
    "operationId": "updateDocument"
}
""";

    /// <summary>Returns endpoint information for UpdateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDocument_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/update",
            _UpdateDocument_Info));

    /// <summary>Returns request schema for UpdateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDocument_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/update",
            "request-schema",
            _UpdateDocument_RequestSchema));

    /// <summary>Returns response schema for UpdateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDocument_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/update",
            "response-schema",
            _UpdateDocument_ResponseSchema));

    /// <summary>Returns full schema for UpdateDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDocument_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/update",
            _UpdateDocument_Info,
            _UpdateDocument_RequestSchema,
            _UpdateDocument_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeleteDocument

    private static readonly string _DeleteDocument_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteDocumentRequest",
    "$defs": {
        "DeleteDocumentRequest": {
            "description": "Request to soft-delete a document to the trashcan",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace containing the document"
                },
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "nullable": true,
                    "description": "Unique identifier of the document to delete (null if using slug)"
                },
                "slug": {
                    "type": "string",
                    "nullable": true,
                    "description": "URL-friendly slug of the document to delete (null if using documentId)"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteDocument_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteDocumentResponse",
    "$defs": {
        "DeleteDocumentResponse": {
            "description": "Response confirming document deletion with recovery deadline",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "documentId",
                "deletedAt",
                "recoverableUntil"
            ],
            "properties": {
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the deleted document"
                },
                "deletedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the document was deleted"
                },
                "recoverableUntil": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Deadline for recovering the document from trashcan"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteDocument_Info = """
{
    "summary": "Soft-delete documentation entry to trashcan",
    "description": "Moves document to trashcan for recovery within TTL period.\nDocuments are automatically cleaned up after TrashcanTtlDays.\n",
    "tags": [
        "Admin"
    ],
    "deprecated": false,
    "operationId": "deleteDocument"
}
""";

    /// <summary>Returns endpoint information for DeleteDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocument_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/delete",
            _DeleteDocument_Info));

    /// <summary>Returns request schema for DeleteDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocument_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/delete",
            "request-schema",
            _DeleteDocument_RequestSchema));

    /// <summary>Returns response schema for DeleteDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocument_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/delete",
            "response-schema",
            _DeleteDocument_ResponseSchema));

    /// <summary>Returns full schema for DeleteDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocument_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/delete",
            _DeleteDocument_Info,
            _DeleteDocument_RequestSchema,
            _DeleteDocument_ResponseSchema));

    #endregion

    #region Meta Endpoints for RecoverDocument

    private static readonly string _RecoverDocument_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RecoverDocumentRequest",
    "$defs": {
        "RecoverDocumentRequest": {
            "description": "Request to recover a deleted document from the trashcan",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "documentId"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace containing the trashcan"
                },
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the document to recover"
                }
            }
        }
    }
}
""";

    private static readonly string _RecoverDocument_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RecoverDocumentResponse",
    "$defs": {
        "RecoverDocumentResponse": {
            "description": "Response confirming document recovery with timestamp",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "documentId",
                "recoveredAt"
            ],
            "properties": {
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the recovered document"
                },
                "recoveredAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the document was recovered"
                }
            }
        }
    }
}
""";

    private static readonly string _RecoverDocument_Info = """
{
    "summary": "Recover document from trashcan",
    "description": "Restores a soft-deleted document from the trashcan.\nMust be called before the trashcan TTL expires.\n",
    "tags": [
        "Admin"
    ],
    "deprecated": false,
    "operationId": "recoverDocument"
}
""";

    /// <summary>Returns endpoint information for RecoverDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/recover/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RecoverDocument_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/recover",
            _RecoverDocument_Info));

    /// <summary>Returns request schema for RecoverDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/recover/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RecoverDocument_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/recover",
            "request-schema",
            _RecoverDocument_RequestSchema));

    /// <summary>Returns response schema for RecoverDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/recover/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RecoverDocument_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/recover",
            "response-schema",
            _RecoverDocument_ResponseSchema));

    /// <summary>Returns full schema for RecoverDocument</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/recover/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RecoverDocument_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/recover",
            _RecoverDocument_Info,
            _RecoverDocument_RequestSchema,
            _RecoverDocument_ResponseSchema));

    #endregion

    #region Meta Endpoints for BulkUpdateDocuments

    private static readonly string _BulkUpdateDocuments_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BulkUpdateRequest",
    "$defs": {
        "BulkUpdateRequest": {
            "description": "Request to update multiple documents at once",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "documentIds"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace containing the documents"
                },
                "documentIds": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "uuid"
                    },
                    "description": "List of document IDs to update"
                },
                "category": {
                    "$ref": "#/$defs/DocumentCategory",
                    "description": "New category to apply to all documents"
                },
                "addTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Tags to add to all documents (null to skip adding)"
                },
                "removeTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Tags to remove from all documents (null to skip removing)"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        }
    }
}
""";

    private static readonly string _BulkUpdateDocuments_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BulkUpdateResponse",
    "$defs": {
        "BulkUpdateResponse": {
            "description": "Response reporting bulk update results with success and failure details",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "succeeded",
                "failed"
            ],
            "properties": {
                "succeeded": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "uuid"
                    },
                    "description": "IDs of documents successfully updated"
                },
                "failed": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/BulkOperationFailure"
                    },
                    "description": "Details of documents that failed to update"
                }
            }
        },
        "BulkOperationFailure": {
            "description": "Details of a single document that failed in a bulk operation",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "documentId",
                "error"
            ],
            "properties": {
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the document that failed"
                },
                "error": {
                    "type": "string",
                    "description": "Error message explaining the failure"
                }
            }
        }
    }
}
""";

    private static readonly string _BulkUpdateDocuments_Info = """
{
    "summary": "Bulk update document metadata",
    "description": "Apply category, tag, or metadata changes to multiple documents at once.\nEach document is processed independently - partial success is possible.\n",
    "tags": [
        "Admin"
    ],
    "deprecated": false,
    "operationId": "bulkUpdateDocuments"
}
""";

    /// <summary>Returns endpoint information for BulkUpdateDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkUpdateDocuments_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/bulk-update",
            _BulkUpdateDocuments_Info));

    /// <summary>Returns request schema for BulkUpdateDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkUpdateDocuments_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/bulk-update",
            "request-schema",
            _BulkUpdateDocuments_RequestSchema));

    /// <summary>Returns response schema for BulkUpdateDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkUpdateDocuments_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/bulk-update",
            "response-schema",
            _BulkUpdateDocuments_ResponseSchema));

    /// <summary>Returns full schema for BulkUpdateDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkUpdateDocuments_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/bulk-update",
            _BulkUpdateDocuments_Info,
            _BulkUpdateDocuments_RequestSchema,
            _BulkUpdateDocuments_ResponseSchema));

    #endregion

    #region Meta Endpoints for BulkDeleteDocuments

    private static readonly string _BulkDeleteDocuments_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BulkDeleteRequest",
    "$defs": {
        "BulkDeleteRequest": {
            "description": "Request to delete multiple documents at once",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "documentIds"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace containing the documents"
                },
                "documentIds": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "uuid"
                    },
                    "description": "List of document IDs to delete"
                }
            }
        }
    }
}
""";

    private static readonly string _BulkDeleteDocuments_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BulkDeleteResponse",
    "$defs": {
        "BulkDeleteResponse": {
            "description": "Response reporting bulk deletion results with success and failure details",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "succeeded",
                "failed"
            ],
            "properties": {
                "succeeded": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "uuid"
                    },
                    "description": "IDs of documents successfully deleted"
                },
                "failed": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/BulkOperationFailure"
                    },
                    "description": "Details of documents that failed to delete"
                }
            }
        },
        "BulkOperationFailure": {
            "description": "Details of a single document that failed in a bulk operation",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "documentId",
                "error"
            ],
            "properties": {
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the document that failed"
                },
                "error": {
                    "type": "string",
                    "description": "Error message explaining the failure"
                }
            }
        }
    }
}
""";

    private static readonly string _BulkDeleteDocuments_Info = """
{
    "summary": "Bulk soft-delete documents to trashcan",
    "description": "Move multiple documents to trashcan at once.\nEach document is processed independently - partial success is possible.\n",
    "tags": [
        "Admin"
    ],
    "deprecated": false,
    "operationId": "bulkDeleteDocuments"
}
""";

    /// <summary>Returns endpoint information for BulkDeleteDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkDeleteDocuments_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/bulk-delete",
            _BulkDeleteDocuments_Info));

    /// <summary>Returns request schema for BulkDeleteDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkDeleteDocuments_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/bulk-delete",
            "request-schema",
            _BulkDeleteDocuments_RequestSchema));

    /// <summary>Returns response schema for BulkDeleteDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkDeleteDocuments_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/bulk-delete",
            "response-schema",
            _BulkDeleteDocuments_ResponseSchema));

    /// <summary>Returns full schema for BulkDeleteDocuments</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/bulk-delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BulkDeleteDocuments_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/bulk-delete",
            _BulkDeleteDocuments_Info,
            _BulkDeleteDocuments_RequestSchema,
            _BulkDeleteDocuments_ResponseSchema));

    #endregion

    #region Meta Endpoints for ImportDocumentation

    private static readonly string _ImportDocumentation_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ImportDocumentationRequest",
    "$defs": {
        "ImportDocumentationRequest": {
            "description": "Request to import multiple documents into a namespace",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "documents"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace to import into"
                },
                "documents": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ImportDocument"
                    },
                    "description": "List of documents to import"
                },
                "onConflict": {
                    "type": "string",
                    "enum": [
                        "skip",
                        "update",
                        "fail"
                    ],
                    "default": "skip",
                    "description": "How to handle documents with existing slugs"
                }
            }
        },
        "ImportDocument": {
            "description": "A single document to import with required fields",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "slug",
                "title",
                "category",
                "content"
            ],
            "properties": {
                "slug": {
                    "type": "string",
                    "description": "URL-friendly unique identifier for the document"
                },
                "title": {
                    "type": "string",
                    "description": "Display title of the document"
                },
                "category": {
                    "$ref": "#/$defs/DocumentCategory",
                    "description": "Category for organizing the document"
                },
                "content": {
                    "type": "string",
                    "description": "Markdown content of the document"
                },
                "summary": {
                    "type": "string",
                    "nullable": true,
                    "description": "Brief text summary of the document (null if not provided)"
                },
                "voiceSummary": {
                    "type": "string",
                    "nullable": true,
                    "description": "Concise summary optimized for voice AI (null if not provided)"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "Tags for filtering and search (null to skip tagging)"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "nullable": true,
                    "description": "Custom metadata key-value pairs (null if not needed)"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        }
    }
}
""";

    private static readonly string _ImportDocumentation_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ImportDocumentationResponse",
    "$defs": {
        "ImportDocumentationResponse": {
            "description": "Response reporting import results with counts and failure details",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "created",
                "updated",
                "skipped",
                "failed"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace documents were imported into"
                },
                "created": {
                    "type": "integer",
                    "description": "Number of new documents created"
                },
                "updated": {
                    "type": "integer",
                    "description": "Number of existing documents updated"
                },
                "skipped": {
                    "type": "integer",
                    "description": "Number of documents skipped due to conflicts"
                },
                "failed": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ImportFailure"
                    },
                    "description": "Details of documents that failed to import"
                }
            }
        },
        "ImportFailure": {
            "description": "Details of a document that failed to import",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "slug",
                "error"
            ],
            "properties": {
                "slug": {
                    "type": "string",
                    "description": "Slug of the document that failed to import"
                },
                "error": {
                    "type": "string",
                    "description": "Error message explaining the failure"
                }
            }
        }
    }
}
""";

    private static readonly string _ImportDocumentation_Info = """
{
    "summary": "Bulk import documentation from structured source",
    "description": "Import multiple documents. Each document processed independently.\nPartial success is possible - failures reported per document.\n",
    "tags": [
        "Admin"
    ],
    "deprecated": false,
    "operationId": "importDocumentation"
}
""";

    /// <summary>Returns endpoint information for ImportDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/import/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ImportDocumentation_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/import",
            _ImportDocumentation_Info));

    /// <summary>Returns request schema for ImportDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/import/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ImportDocumentation_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/import",
            "request-schema",
            _ImportDocumentation_RequestSchema));

    /// <summary>Returns response schema for ImportDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/import/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ImportDocumentation_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/import",
            "response-schema",
            _ImportDocumentation_ResponseSchema));

    /// <summary>Returns full schema for ImportDocumentation</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/import/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ImportDocumentation_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/import",
            _ImportDocumentation_Info,
            _ImportDocumentation_RequestSchema,
            _ImportDocumentation_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListTrashcan

    private static readonly string _ListTrashcan_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListTrashcanRequest",
    "$defs": {
        "ListTrashcanRequest": {
            "description": "Request to list deleted documents in the trashcan",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace to list trashcan from"
                },
                "page": {
                    "type": "integer",
                    "default": 1,
                    "description": "Page number for pagination"
                },
                "pageSize": {
                    "type": "integer",
                    "default": 20,
                    "description": "Number of items per page"
                }
            }
        }
    }
}
""";

    private static readonly string _ListTrashcan_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListTrashcanResponse",
    "$defs": {
        "ListTrashcanResponse": {
            "description": "Response containing deleted documents awaiting permanent deletion",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "items"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace the trashcan belongs to"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/TrashcanItem"
                    },
                    "description": "List of deleted documents in trashcan"
                },
                "totalCount": {
                    "type": "integer",
                    "description": "Total number of items in trashcan"
                }
            }
        },
        "TrashcanItem": {
            "description": "A deleted document in the trashcan with expiration information",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "documentId",
                "title",
                "deletedAt",
                "expiresAt"
            ],
            "properties": {
                "documentId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the deleted document"
                },
                "slug": {
                    "type": "string",
                    "description": "URL-friendly slug of the deleted document"
                },
                "title": {
                    "type": "string",
                    "description": "Title of the deleted document"
                },
                "category": {
                    "$ref": "#/$defs/DocumentCategory",
                    "description": "Category of the deleted document"
                },
                "deletedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the document was deleted"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the document will be permanently deleted"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        }
    }
}
""";

    private static readonly string _ListTrashcan_Info = """
{
    "summary": "List documents in the trashcan",
    "description": "List all soft-deleted documents within the namespace's trashcan.\nDocuments remain recoverable until TTL expires or purge is called.\n",
    "tags": [
        "Admin"
    ],
    "deprecated": false,
    "operationId": "listTrashcan"
}
""";

    /// <summary>Returns endpoint information for ListTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/trashcan/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListTrashcan_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/trashcan",
            _ListTrashcan_Info));

    /// <summary>Returns request schema for ListTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/trashcan/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListTrashcan_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/trashcan",
            "request-schema",
            _ListTrashcan_RequestSchema));

    /// <summary>Returns response schema for ListTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/trashcan/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListTrashcan_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/trashcan",
            "response-schema",
            _ListTrashcan_ResponseSchema));

    /// <summary>Returns full schema for ListTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/trashcan/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListTrashcan_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/trashcan",
            _ListTrashcan_Info,
            _ListTrashcan_RequestSchema,
            _ListTrashcan_ResponseSchema));

    #endregion

    #region Meta Endpoints for PurgeTrashcan

    private static readonly string _PurgeTrashcan_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/PurgeTrashcanRequest",
    "$defs": {
        "PurgeTrashcanRequest": {
            "description": "Request to permanently delete documents from the trashcan",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace to purge trashcan from"
                },
                "documentIds": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "uuid"
                    },
                    "description": "If empty, purges all trashcan items"
                }
            }
        }
    }
}
""";

    private static readonly string _PurgeTrashcan_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/PurgeTrashcanResponse",
    "$defs": {
        "PurgeTrashcanResponse": {
            "description": "Response confirming permanent deletion of trashcan items",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "purgedCount"
            ],
            "properties": {
                "purgedCount": {
                    "type": "integer",
                    "description": "Number of documents permanently deleted"
                }
            }
        }
    }
}
""";

    private static readonly string _PurgeTrashcan_Info = """
{
    "summary": "Permanently delete trashcan items",
    "description": "Permanently delete specified documents from trashcan, or purge all.\nThis operation is irreversible - documents cannot be recovered after purge.\n",
    "tags": [
        "Admin"
    ],
    "deprecated": false,
    "operationId": "purgeTrashcan"
}
""";

    /// <summary>Returns endpoint information for PurgeTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/purge/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PurgeTrashcan_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/purge",
            _PurgeTrashcan_Info));

    /// <summary>Returns request schema for PurgeTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/purge/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PurgeTrashcan_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/purge",
            "request-schema",
            _PurgeTrashcan_RequestSchema));

    /// <summary>Returns response schema for PurgeTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/purge/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PurgeTrashcan_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/purge",
            "response-schema",
            _PurgeTrashcan_ResponseSchema));

    /// <summary>Returns full schema for PurgeTrashcan</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/purge/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PurgeTrashcan_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/purge",
            _PurgeTrashcan_Info,
            _PurgeTrashcan_RequestSchema,
            _PurgeTrashcan_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetNamespaceStats

    private static readonly string _GetNamespaceStats_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetNamespaceStatsRequest",
    "$defs": {
        "GetNamespaceStatsRequest": {
            "description": "Request to get statistics for a documentation namespace",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace to get statistics for"
                }
            }
        }
    }
}
""";

    private static readonly string _GetNamespaceStats_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/NamespaceStatsResponse",
    "$defs": {
        "NamespaceStatsResponse": {
            "description": "Response containing namespace statistics and document counts",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "documentCount"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace statistics are for"
                },
                "documentCount": {
                    "type": "integer",
                    "description": "Total number of documents in the namespace"
                },
                "categoryCounts": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    },
                    "description": "Document count per category"
                },
                "trashcanCount": {
                    "type": "integer",
                    "description": "Number of documents in the trashcan"
                },
                "totalContentSizeBytes": {
                    "type": "integer",
                    "description": "Total size of all document content in bytes"
                },
                "lastUpdated": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp of most recent document update"
                }
            }
        }
    }
}
""";

    private static readonly string _GetNamespaceStats_Info = """
{
    "summary": "Get namespace documentation statistics",
    "description": "Retrieve usage statistics and metadata for a documentation namespace.\nUseful for monitoring, capacity planning, and administrative dashboards.\n",
    "tags": [
        "Admin"
    ],
    "deprecated": false,
    "operationId": "getNamespaceStats"
}
""";

    /// <summary>Returns endpoint information for GetNamespaceStats</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/stats/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetNamespaceStats_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/stats",
            _GetNamespaceStats_Info));

    /// <summary>Returns request schema for GetNamespaceStats</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/stats/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetNamespaceStats_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/stats",
            "request-schema",
            _GetNamespaceStats_RequestSchema));

    /// <summary>Returns response schema for GetNamespaceStats</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/stats/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetNamespaceStats_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/stats",
            "response-schema",
            _GetNamespaceStats_ResponseSchema));

    /// <summary>Returns full schema for GetNamespaceStats</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/stats/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetNamespaceStats_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/stats",
            _GetNamespaceStats_Info,
            _GetNamespaceStats_RequestSchema,
            _GetNamespaceStats_ResponseSchema));

    #endregion

    #region Meta Endpoints for BindRepository

    private static readonly string _BindRepository_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BindRepositoryRequest",
    "$defs": {
        "BindRepositoryRequest": {
            "description": "Request to bind a Git repository for automatic documentation sync",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "repositoryUrl",
                "owner"
            ],
            "properties": {
                "owner": {
                    "type": "string",
                    "description": "Owner of this binding. NOT a session ID.\nFor user-initiated bindings: the accountId (UUID format).\nFor service-initiated bindings: the service name (e.g., \"orchestrator\").\n"
                },
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace to bind"
                },
                "repositoryUrl": {
                    "type": "string",
                    "description": "Git clone URL (HTTPS for public repos)"
                },
                "branch": {
                    "type": "string",
                    "default": "main",
                    "description": "Branch to sync from"
                },
                "syncIntervalMinutes": {
                    "type": "integer",
                    "default": 60,
                    "minimum": 5,
                    "maximum": 1440,
                    "description": "How often to sync (5 min to 24 hours)"
                },
                "filePatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "default": [
                        "**/*.md"
                    ],
                    "description": "Glob patterns for files to include"
                },
                "excludePatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "default": [
                        ".git/**",
                        ".obsidian/**",
                        "node_modules/**"
                    ],
                    "description": "Glob patterns for files to exclude"
                },
                "categoryMapping": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map directory prefixes to categories"
                },
                "defaultCategory": {
                    "$ref": "#/$defs/DocumentCategory",
                    "description": "Default category for documents without mapping"
                },
                "archiveEnabled": {
                    "type": "boolean",
                    "default": false,
                    "description": "Enable archive functionality"
                },
                "archiveOnSync": {
                    "type": "boolean",
                    "default": false,
                    "description": "Create archive after each sync"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        }
    }
}
""";

    private static readonly string _BindRepository_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/BindRepositoryResponse",
    "$defs": {
        "BindRepositoryResponse": {
            "description": "Response confirming repository binding creation",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bindingId",
                "namespace",
                "status"
            ],
            "properties": {
                "bindingId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the repository binding"
                },
                "namespace": {
                    "type": "string",
                    "description": "Namespace the repository is bound to"
                },
                "repositoryUrl": {
                    "type": "string",
                    "description": "URL of the bound repository"
                },
                "branch": {
                    "type": "string",
                    "description": "Branch being synced"
                },
                "status": {
                    "$ref": "#/$defs/BindingStatus",
                    "description": "Current status of the binding"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the binding was created"
                }
            }
        },
        "BindingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "syncing",
                "synced",
                "error",
                "disabled"
            ],
            "description": "Status of a repository binding"
        }
    }
}
""";

    private static readonly string _BindRepository_Info = """
{
    "summary": "Bind a git repository to a documentation namespace",
    "description": "Bind a git repository URL to a documentation namespace.\nThe namespace will be exclusively managed by the repository - manual edits will be blocked.\nTriggers initial sync after binding.\n",
    "tags": [
        "Repository"
    ],
    "deprecated": false,
    "operationId": "bindRepository"
}
""";

    /// <summary>Returns endpoint information for BindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/bind/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BindRepository_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/bind",
            _BindRepository_Info));

    /// <summary>Returns request schema for BindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/bind/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BindRepository_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/bind",
            "request-schema",
            _BindRepository_RequestSchema));

    /// <summary>Returns response schema for BindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/bind/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BindRepository_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/bind",
            "response-schema",
            _BindRepository_ResponseSchema));

    /// <summary>Returns full schema for BindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/bind/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> BindRepository_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/bind",
            _BindRepository_Info,
            _BindRepository_RequestSchema,
            _BindRepository_ResponseSchema));

    #endregion

    #region Meta Endpoints for UnbindRepository

    private static readonly string _UnbindRepository_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UnbindRepositoryRequest",
    "$defs": {
        "UnbindRepositoryRequest": {
            "description": "Request to remove a repository binding from a namespace",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace to unbind"
                },
                "deleteDocuments": {
                    "type": "boolean",
                    "default": false,
                    "description": "Also delete all documents from the namespace"
                }
            }
        }
    }
}
""";

    private static readonly string _UnbindRepository_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UnbindRepositoryResponse",
    "$defs": {
        "UnbindRepositoryResponse": {
            "description": "Response confirming repository unbinding with cleanup details",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "documentsDeleted"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": "Namespace that was unbound"
                },
                "documentsDeleted": {
                    "type": "integer",
                    "description": "Number of documents deleted (0 if deleteDocuments was false)"
                }
            }
        }
    }
}
""";

    private static readonly string _UnbindRepository_Info = """
{
    "summary": "Remove repository binding from namespace",
    "description": "Remove repository binding from a namespace, making it manually editable again.\nOptionally delete all documents imported from the repository.\n",
    "tags": [
        "Repository"
    ],
    "deprecated": false,
    "operationId": "unbindRepository"
}
""";

    /// <summary>Returns endpoint information for UnbindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/unbind/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UnbindRepository_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/unbind",
            _UnbindRepository_Info));

    /// <summary>Returns request schema for UnbindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/unbind/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UnbindRepository_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/unbind",
            "request-schema",
            _UnbindRepository_RequestSchema));

    /// <summary>Returns response schema for UnbindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/unbind/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UnbindRepository_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/unbind",
            "response-schema",
            _UnbindRepository_ResponseSchema));

    /// <summary>Returns full schema for UnbindRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/unbind/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UnbindRepository_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/unbind",
            _UnbindRepository_Info,
            _UnbindRepository_RequestSchema,
            _UnbindRepository_ResponseSchema));

    #endregion

    #region Meta Endpoints for SyncRepository

    private static readonly string _SyncRepository_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/SyncRepositoryRequest",
    "$defs": {
        "SyncRepositoryRequest": {
            "description": "Request to trigger a manual repository sync",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace to sync"
                },
                "force": {
                    "type": "boolean",
                    "default": false,
                    "description": "Force full re-sync even if commit hash unchanged"
                }
            }
        }
    }
}
""";

    private static readonly string _SyncRepository_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/SyncRepositoryResponse",
    "$defs": {
        "SyncRepositoryResponse": {
            "description": "Response containing sync operation results and statistics",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "syncId",
                "status"
            ],
            "properties": {
                "syncId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of this sync operation"
                },
                "status": {
                    "$ref": "#/$defs/SyncStatus",
                    "description": "Result status of the sync"
                },
                "commitHash": {
                    "type": "string",
                    "nullable": true,
                    "description": "Git commit hash that was synced (null if sync failed or repo is empty)"
                },
                "documentsCreated": {
                    "type": "integer",
                    "description": "Number of new documents created"
                },
                "documentsUpdated": {
                    "type": "integer",
                    "description": "Number of existing documents updated"
                },
                "documentsDeleted": {
                    "type": "integer",
                    "description": "Number of documents deleted"
                },
                "documentsFailed": {
                    "type": "integer",
                    "description": "Number of documents that failed to process"
                },
                "durationMs": {
                    "type": "integer",
                    "description": "Time taken for sync in milliseconds"
                },
                "errorMessage": {
                    "type": "string",
                    "nullable": true,
                    "description": "Error message if sync failed"
                }
            }
        },
        "SyncStatus": {
            "type": "string",
            "enum": [
                "success",
                "partial",
                "failed"
            ],
            "description": "Result status of a sync operation"
        }
    }
}
""";

    private static readonly string _SyncRepository_Info = """
{
    "summary": "Manually trigger repository sync",
    "description": "Manually trigger synchronization of a bound repository.\nIf force=true, performs full re-sync regardless of commit hash.\n",
    "tags": [
        "Repository"
    ],
    "deprecated": false,
    "operationId": "syncRepository"
}
""";

    /// <summary>Returns endpoint information for SyncRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/sync/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SyncRepository_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/sync",
            _SyncRepository_Info));

    /// <summary>Returns request schema for SyncRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/sync/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SyncRepository_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/sync",
            "request-schema",
            _SyncRepository_RequestSchema));

    /// <summary>Returns response schema for SyncRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/sync/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SyncRepository_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/sync",
            "response-schema",
            _SyncRepository_ResponseSchema));

    /// <summary>Returns full schema for SyncRepository</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/sync/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> SyncRepository_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/sync",
            _SyncRepository_Info,
            _SyncRepository_RequestSchema,
            _SyncRepository_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetRepositoryStatus

    private static readonly string _GetRepositoryStatus_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RepositoryStatusRequest",
    "$defs": {
        "RepositoryStatusRequest": {
            "description": "Request to get current repository binding and sync status",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace to get status for"
                }
            }
        }
    }
}
""";

    private static readonly string _GetRepositoryStatus_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RepositoryStatusResponse",
    "$defs": {
        "RepositoryStatusResponse": {
            "description": "Response containing binding configuration and recent sync information",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "binding": {
                    "$ref": "#/$defs/RepositoryBindingInfo",
                    "description": "Current binding configuration and status"
                },
                "lastSync": {
                    "$ref": "#/$defs/SyncInfo",
                    "description": "Information about the most recent sync"
                }
            }
        },
        "RepositoryBindingInfo": {
            "description": "Detailed repository binding configuration and status",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bindingId",
                "namespace",
                "repositoryUrl",
                "status"
            ],
            "properties": {
                "bindingId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the repository binding"
                },
                "namespace": {
                    "type": "string",
                    "description": "Namespace the repository is bound to"
                },
                "repositoryUrl": {
                    "type": "string",
                    "description": "URL of the bound repository"
                },
                "branch": {
                    "type": "string",
                    "description": "Branch being synced"
                },
                "status": {
                    "$ref": "#/$defs/BindingStatus",
                    "description": "Current status of the binding"
                },
                "syncEnabled": {
                    "type": "boolean",
                    "description": "Whether automatic sync is enabled"
                },
                "syncIntervalMinutes": {
                    "type": "integer",
                    "description": "Sync interval in minutes"
                },
                "documentCount": {
                    "type": "integer",
                    "description": "Number of documents from this repository"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the binding was created"
                },
                "owner": {
                    "type": "string",
                    "description": "Owner of this binding. NOT a session ID.\nContains either an accountId (UUID format) for user-initiated bindings\nor a service name for service-initiated bindings.\n"
                }
            }
        },
        "BindingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "syncing",
                "synced",
                "error",
                "disabled"
            ],
            "description": "Status of a repository binding"
        },
        "SyncInfo": {
            "description": "Information about a repository sync operation",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "syncId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the sync operation"
                },
                "status": {
                    "$ref": "#/$defs/SyncStatus",
                    "description": "Result status of the sync"
                },
                "triggeredBy": {
                    "$ref": "#/$defs/SyncTrigger",
                    "description": "What triggered the sync"
                },
                "startedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when sync started"
                },
                "completedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when sync completed"
                },
                "commitHash": {
                    "type": "string",
                    "nullable": true,
                    "description": "Git commit hash that was synced (null if sync failed or repo is empty)"
                },
                "documentsProcessed": {
                    "type": "integer",
                    "description": "Total documents processed in sync"
                }
            }
        },
        "SyncStatus": {
            "type": "string",
            "enum": [
                "success",
                "partial",
                "failed"
            ],
            "description": "Result status of a sync operation"
        },
        "SyncTrigger": {
            "type": "string",
            "enum": [
                "manual",
                "scheduled"
            ],
            "description": "What triggered the sync operation"
        }
    }
}
""";

    private static readonly string _GetRepositoryStatus_Info = """
{
    "summary": "Get repository binding status",
    "description": "Get current status of a repository binding including sync state and statistics.\n",
    "tags": [
        "Repository"
    ],
    "deprecated": false,
    "operationId": "getRepositoryStatus"
}
""";

    /// <summary>Returns endpoint information for GetRepositoryStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/status/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetRepositoryStatus_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/status",
            _GetRepositoryStatus_Info));

    /// <summary>Returns request schema for GetRepositoryStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/status/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetRepositoryStatus_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/status",
            "request-schema",
            _GetRepositoryStatus_RequestSchema));

    /// <summary>Returns response schema for GetRepositoryStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/status/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetRepositoryStatus_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/status",
            "response-schema",
            _GetRepositoryStatus_ResponseSchema));

    /// <summary>Returns full schema for GetRepositoryStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/status/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetRepositoryStatus_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/status",
            _GetRepositoryStatus_Info,
            _GetRepositoryStatus_RequestSchema,
            _GetRepositoryStatus_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListRepositoryBindings

    private static readonly string _ListRepositoryBindings_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListRepositoryBindingsRequest",
    "$defs": {
        "ListRepositoryBindingsRequest": {
            "description": "Request to list all repository bindings with optional filtering",
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "status": {
                    "$ref": "#/$defs/BindingStatus",
                    "description": "Filter by binding status"
                },
                "limit": {
                    "type": "integer",
                    "default": 50,
                    "minimum": 1,
                    "maximum": 100,
                    "description": "Maximum number of bindings to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "minimum": 0,
                    "description": "Number of bindings to skip"
                }
            }
        },
        "BindingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "syncing",
                "synced",
                "error",
                "disabled"
            ],
            "description": "Status of a repository binding"
        }
    }
}
""";

    private static readonly string _ListRepositoryBindings_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListRepositoryBindingsResponse",
    "$defs": {
        "ListRepositoryBindingsResponse": {
            "description": "Response containing a list of repository bindings",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bindings",
                "total"
            ],
            "properties": {
                "bindings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/RepositoryBindingInfo"
                    },
                    "description": "List of repository bindings"
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of bindings matching filter"
                }
            }
        },
        "RepositoryBindingInfo": {
            "description": "Detailed repository binding configuration and status",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bindingId",
                "namespace",
                "repositoryUrl",
                "status"
            ],
            "properties": {
                "bindingId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the repository binding"
                },
                "namespace": {
                    "type": "string",
                    "description": "Namespace the repository is bound to"
                },
                "repositoryUrl": {
                    "type": "string",
                    "description": "URL of the bound repository"
                },
                "branch": {
                    "type": "string",
                    "description": "Branch being synced"
                },
                "status": {
                    "$ref": "#/$defs/BindingStatus",
                    "description": "Current status of the binding"
                },
                "syncEnabled": {
                    "type": "boolean",
                    "description": "Whether automatic sync is enabled"
                },
                "syncIntervalMinutes": {
                    "type": "integer",
                    "description": "Sync interval in minutes"
                },
                "documentCount": {
                    "type": "integer",
                    "description": "Number of documents from this repository"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the binding was created"
                },
                "owner": {
                    "type": "string",
                    "description": "Owner of this binding. NOT a session ID.\nContains either an accountId (UUID format) for user-initiated bindings\nor a service name for service-initiated bindings.\n"
                }
            }
        },
        "BindingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "syncing",
                "synced",
                "error",
                "disabled"
            ],
            "description": "Status of a repository binding"
        }
    }
}
""";

    private static readonly string _ListRepositoryBindings_Info = """
{
    "summary": "List all repository bindings",
    "description": "List all repository bindings with optional filtering by status.\n",
    "tags": [
        "Repository"
    ],
    "deprecated": false,
    "operationId": "listRepositoryBindings"
}
""";

    /// <summary>Returns endpoint information for ListRepositoryBindings</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListRepositoryBindings_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/list",
            _ListRepositoryBindings_Info));

    /// <summary>Returns request schema for ListRepositoryBindings</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListRepositoryBindings_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/list",
            "request-schema",
            _ListRepositoryBindings_RequestSchema));

    /// <summary>Returns response schema for ListRepositoryBindings</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListRepositoryBindings_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/list",
            "response-schema",
            _ListRepositoryBindings_ResponseSchema));

    /// <summary>Returns full schema for ListRepositoryBindings</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListRepositoryBindings_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/list",
            _ListRepositoryBindings_Info,
            _ListRepositoryBindings_RequestSchema,
            _ListRepositoryBindings_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateRepositoryBinding

    private static readonly string _UpdateRepositoryBinding_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateRepositoryBindingRequest",
    "$defs": {
        "UpdateRepositoryBindingRequest": {
            "description": "Request to update repository binding configuration",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace of the binding to update"
                },
                "syncEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable automatic syncing"
                },
                "syncIntervalMinutes": {
                    "type": "integer",
                    "minimum": 5,
                    "maximum": 1440,
                    "description": "New sync interval in minutes"
                },
                "filePatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "New glob patterns for files to include (null to keep unchanged)"
                },
                "excludePatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "New glob patterns for files to exclude (null to keep unchanged)"
                },
                "categoryMapping": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "nullable": true,
                    "description": "New directory-to-category mapping (null to keep unchanged)"
                },
                "defaultCategory": {
                    "$ref": "#/$defs/DocumentCategory",
                    "description": "New default category for unmapped documents"
                },
                "archiveEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable archive functionality"
                },
                "archiveOnSync": {
                    "type": "boolean",
                    "description": "Enable or disable archiving after each sync"
                }
            }
        },
        "DocumentCategory": {
            "type": "string",
            "enum": [
                "getting-started",
                "api-reference",
                "architecture",
                "deployment",
                "troubleshooting",
                "tutorials",
                "game-systems",
                "world-lore",
                "npc-ai",
                "other"
            ],
            "description": "Fixed categories for type-safe filtering"
        }
    }
}
""";

    private static readonly string _UpdateRepositoryBinding_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateRepositoryBindingResponse",
    "$defs": {
        "UpdateRepositoryBindingResponse": {
            "description": "Response containing the updated binding configuration",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "binding"
            ],
            "properties": {
                "binding": {
                    "$ref": "#/$defs/RepositoryBindingInfo",
                    "description": "Updated binding configuration"
                }
            }
        },
        "RepositoryBindingInfo": {
            "description": "Detailed repository binding configuration and status",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "bindingId",
                "namespace",
                "repositoryUrl",
                "status"
            ],
            "properties": {
                "bindingId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the repository binding"
                },
                "namespace": {
                    "type": "string",
                    "description": "Namespace the repository is bound to"
                },
                "repositoryUrl": {
                    "type": "string",
                    "description": "URL of the bound repository"
                },
                "branch": {
                    "type": "string",
                    "description": "Branch being synced"
                },
                "status": {
                    "$ref": "#/$defs/BindingStatus",
                    "description": "Current status of the binding"
                },
                "syncEnabled": {
                    "type": "boolean",
                    "description": "Whether automatic sync is enabled"
                },
                "syncIntervalMinutes": {
                    "type": "integer",
                    "description": "Sync interval in minutes"
                },
                "documentCount": {
                    "type": "integer",
                    "description": "Number of documents from this repository"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the binding was created"
                },
                "owner": {
                    "type": "string",
                    "description": "Owner of this binding. NOT a session ID.\nContains either an accountId (UUID format) for user-initiated bindings\nor a service name for service-initiated bindings.\n"
                }
            }
        },
        "BindingStatus": {
            "type": "string",
            "enum": [
                "pending",
                "syncing",
                "synced",
                "error",
                "disabled"
            ],
            "description": "Status of a repository binding"
        }
    }
}
""";

    private static readonly string _UpdateRepositoryBinding_Info = """
{
    "summary": "Update repository binding configuration",
    "description": "Update sync settings, file patterns, category mappings, or archive configuration.\n",
    "tags": [
        "Repository"
    ],
    "deprecated": false,
    "operationId": "updateRepositoryBinding"
}
""";

    /// <summary>Returns endpoint information for UpdateRepositoryBinding</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateRepositoryBinding_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/update",
            _UpdateRepositoryBinding_Info));

    /// <summary>Returns request schema for UpdateRepositoryBinding</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateRepositoryBinding_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/update",
            "request-schema",
            _UpdateRepositoryBinding_RequestSchema));

    /// <summary>Returns response schema for UpdateRepositoryBinding</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateRepositoryBinding_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/update",
            "response-schema",
            _UpdateRepositoryBinding_ResponseSchema));

    /// <summary>Returns full schema for UpdateRepositoryBinding</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateRepositoryBinding_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/update",
            _UpdateRepositoryBinding_Info,
            _UpdateRepositoryBinding_RequestSchema,
            _UpdateRepositoryBinding_ResponseSchema));

    #endregion

    #region Meta Endpoints for CreateDocumentationArchive

    private static readonly string _CreateDocumentationArchive_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateArchiveRequest",
    "$defs": {
        "CreateArchiveRequest": {
            "description": "Request to create a point-in-time snapshot of namespace documentation",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "owner"
            ],
            "properties": {
                "owner": {
                    "type": "string",
                    "description": "Owner of this archive. NOT a session ID.\nFor user-initiated archives: the accountId (UUID format).\nFor service-initiated archives: the service name (e.g., \"orchestrator\").\n"
                },
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace to archive"
                },
                "description": {
                    "type": "string",
                    "maxLength": 500,
                    "description": "Optional description for the archive"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateDocumentationArchive_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateArchiveResponse",
    "$defs": {
        "CreateArchiveResponse": {
            "description": "Response containing the created archive details",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "archiveId",
                "namespace"
            ],
            "properties": {
                "archiveId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the created archive"
                },
                "namespace": {
                    "type": "string",
                    "description": "Namespace that was archived"
                },
                "bundleAssetId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Asset ID in Asset Service"
                },
                "documentCount": {
                    "type": "integer",
                    "description": "Number of documents in the archive"
                },
                "sizeBytes": {
                    "type": "integer",
                    "description": "Total size of the archive in bytes"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the archive was created"
                },
                "commitHash": {
                    "type": "string",
                    "nullable": true,
                    "description": "Git commit hash if namespace is bound"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateDocumentationArchive_Info = """
{
    "summary": "Create documentation archive",
    "description": "Create a .bannou bundle archive of all documents in a namespace.\nArchives are stored via Asset Service.\n",
    "tags": [
        "Archive"
    ],
    "deprecated": false,
    "operationId": "createDocumentationArchive"
}
""";

    /// <summary>Returns endpoint information for CreateDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocumentationArchive_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/create",
            _CreateDocumentationArchive_Info));

    /// <summary>Returns request schema for CreateDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocumentationArchive_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/create",
            "request-schema",
            _CreateDocumentationArchive_RequestSchema));

    /// <summary>Returns response schema for CreateDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocumentationArchive_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/create",
            "response-schema",
            _CreateDocumentationArchive_ResponseSchema));

    /// <summary>Returns full schema for CreateDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDocumentationArchive_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/create",
            _CreateDocumentationArchive_Info,
            _CreateDocumentationArchive_RequestSchema,
            _CreateDocumentationArchive_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListDocumentationArchives

    private static readonly string _ListDocumentationArchives_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListArchivesRequest",
    "$defs": {
        "ListArchivesRequest": {
            "description": "Request to list available archives for a namespace",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "Documentation namespace to list archives for"
                },
                "limit": {
                    "type": "integer",
                    "default": 20,
                    "minimum": 1,
                    "maximum": 100,
                    "description": "Maximum number of archives to return"
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "minimum": 0,
                    "description": "Number of archives to skip"
                }
            }
        }
    }
}
""";

    private static readonly string _ListDocumentationArchives_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListArchivesResponse",
    "$defs": {
        "ListArchivesResponse": {
            "description": "Response containing a paginated list of archives",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "archives",
                "total"
            ],
            "properties": {
                "archives": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/ArchiveInfo"
                    },
                    "description": "List of archives for the namespace"
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of archives"
                }
            }
        },
        "ArchiveInfo": {
            "description": "Archive metadata including size and document count",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "archiveId",
                "namespace",
                "createdAt"
            ],
            "properties": {
                "archiveId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the archive"
                },
                "namespace": {
                    "type": "string",
                    "description": "Namespace the archive belongs to"
                },
                "bundleAssetId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Asset ID in Asset Service"
                },
                "description": {
                    "type": "string",
                    "nullable": true,
                    "description": "Description of the archive"
                },
                "documentCount": {
                    "type": "integer",
                    "description": "Number of documents in the archive"
                },
                "sizeBytes": {
                    "type": "integer",
                    "description": "Total size of the archive in bytes"
                },
                "commitHash": {
                    "type": "string",
                    "nullable": true,
                    "description": "Git commit hash if namespace was bound at archive time"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp when the archive was created"
                },
                "owner": {
                    "type": "string",
                    "description": "Owner of this archive. NOT a session ID.\nContains either an accountId (UUID format) for user-initiated archives\nor a service name for service-initiated archives.\n"
                }
            }
        }
    }
}
""";

    private static readonly string _ListDocumentationArchives_Info = """
{
    "summary": "List documentation archives",
    "description": "List all archives for a namespace.\n",
    "tags": [
        "Archive"
    ],
    "deprecated": false,
    "operationId": "listDocumentationArchives"
}
""";

    /// <summary>Returns endpoint information for ListDocumentationArchives</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocumentationArchives_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/list",
            _ListDocumentationArchives_Info));

    /// <summary>Returns request schema for ListDocumentationArchives</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocumentationArchives_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/list",
            "request-schema",
            _ListDocumentationArchives_RequestSchema));

    /// <summary>Returns response schema for ListDocumentationArchives</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocumentationArchives_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/list",
            "response-schema",
            _ListDocumentationArchives_ResponseSchema));

    /// <summary>Returns full schema for ListDocumentationArchives</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDocumentationArchives_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/list",
            _ListDocumentationArchives_Info,
            _ListDocumentationArchives_RequestSchema,
            _ListDocumentationArchives_ResponseSchema));

    #endregion

    #region Meta Endpoints for RestoreDocumentationArchive

    private static readonly string _RestoreDocumentationArchive_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RestoreArchiveRequest",
    "$defs": {
        "RestoreArchiveRequest": {
            "description": "Request to restore documents from an archive",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "archiveId"
            ],
            "properties": {
                "archiveId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the archive to restore"
                },
                "targetNamespace": {
                    "type": "string",
                    "pattern": "^[a-z0-9-]+$",
                    "maxLength": 50,
                    "description": "If not provided, restores to original namespace"
                }
            }
        }
    }
}
""";

    private static readonly string _RestoreDocumentationArchive_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RestoreArchiveResponse",
    "$defs": {
        "RestoreArchiveResponse": {
            "description": "Response containing restore operation results",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "namespace",
                "documentsRestored"
            ],
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": "Namespace documents were restored to"
                },
                "documentsRestored": {
                    "type": "integer",
                    "description": "Number of documents restored from archive"
                },
                "previousDocumentsDeleted": {
                    "type": "integer",
                    "description": "Number of existing documents deleted before restore"
                }
            }
        }
    }
}
""";

    private static readonly string _RestoreDocumentationArchive_Info = """
{
    "summary": "Restore documentation from archive",
    "description": "Restore documents from a .bannou bundle archive.\nReplaces all documents in the namespace with archived content.\n",
    "tags": [
        "Archive"
    ],
    "deprecated": false,
    "operationId": "restoreDocumentationArchive"
}
""";

    /// <summary>Returns endpoint information for RestoreDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/restore/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestoreDocumentationArchive_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/restore",
            _RestoreDocumentationArchive_Info));

    /// <summary>Returns request schema for RestoreDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/restore/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestoreDocumentationArchive_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/restore",
            "request-schema",
            _RestoreDocumentationArchive_RequestSchema));

    /// <summary>Returns response schema for RestoreDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/restore/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestoreDocumentationArchive_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/restore",
            "response-schema",
            _RestoreDocumentationArchive_ResponseSchema));

    /// <summary>Returns full schema for RestoreDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/restore/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestoreDocumentationArchive_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/restore",
            _RestoreDocumentationArchive_Info,
            _RestoreDocumentationArchive_RequestSchema,
            _RestoreDocumentationArchive_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeleteDocumentationArchive

    private static readonly string _DeleteDocumentationArchive_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteArchiveRequest",
    "$defs": {
        "DeleteArchiveRequest": {
            "description": "Request to permanently delete an archive",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "archiveId"
            ],
            "properties": {
                "archiveId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the archive to delete"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteDocumentationArchive_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteArchiveResponse",
    "$defs": {
        "DeleteArchiveResponse": {
            "description": "Response confirming archive deletion",
            "type": "object",
            "additionalProperties": false,
            "required": [
                "deleted"
            ],
            "properties": {
                "deleted": {
                    "type": "boolean",
                    "description": "Whether the archive was successfully deleted"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteDocumentationArchive_Info = """
{
    "summary": "Delete documentation archive",
    "description": "Delete an archive from Asset Service storage.\n",
    "tags": [
        "Archive"
    ],
    "deprecated": false,
    "operationId": "deleteDocumentationArchive"
}
""";

    /// <summary>Returns endpoint information for DeleteDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocumentationArchive_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/delete",
            _DeleteDocumentationArchive_Info));

    /// <summary>Returns request schema for DeleteDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocumentationArchive_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/delete",
            "request-schema",
            _DeleteDocumentationArchive_RequestSchema));

    /// <summary>Returns response schema for DeleteDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocumentationArchive_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/delete",
            "response-schema",
            _DeleteDocumentationArchive_ResponseSchema));

    /// <summary>Returns full schema for DeleteDocumentationArchive</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("documentation/repo/archive/delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDocumentationArchive_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Documentation",
            "Post",
            "documentation/repo/archive/delete",
            _DeleteDocumentationArchive_Info,
            _DeleteDocumentationArchive_RequestSchema,
            _DeleteDocumentationArchive_ResponseSchema));

    #endregion

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
