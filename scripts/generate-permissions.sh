#!/bin/bash

# Permission registration code generator
# Usage: ./generate-permissions.sh <service-name> <schema-file>
# Extracts x-permissions from OpenAPI schema and generates RegisterServicePermissionsAsync code

set -e

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m'

if [ $# -lt 2 ]; then
    echo -e "${RED}Usage: $0 <service-name> <schema-file>${NC}"
    exit 1
fi

SERVICE_NAME="$1"
SCHEMA_FILE="$2"

# Helper function to convert to PascalCase
to_pascal_case() {
    local input="$1"
    echo "$input" | sed 's/-/ /g' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2))} 1' | sed 's/ //g'
}

SERVICE_PASCAL=$(to_pascal_case "$SERVICE_NAME")
PROJECT_DIR="../lib-${SERVICE_NAME}"
OUTPUT_DIR="${PROJECT_DIR}/Generated"
OUTPUT_FILE="${OUTPUT_DIR}/${SERVICE_PASCAL}PermissionRegistration.cs"

echo -e "${BLUE}ðŸ” Generating permission registration for: $SERVICE_NAME${NC}"

# Check if schema file exists
if [ ! -f "$SCHEMA_FILE" ]; then
    echo -e "${RED}âŒ Schema file not found: $SCHEMA_FILE${NC}"
    exit 1
fi

# Check if project directory exists
if [ ! -d "$PROJECT_DIR" ]; then
    echo -e "${YELLOW}âš ï¸  Project directory not found: $PROJECT_DIR - skipping permission generation${NC}"
    exit 0
fi

# Ensure Generated directory exists
mkdir -p "$OUTPUT_DIR"

# Clean up old .Generated.cs file if it exists (legacy naming)
OLD_FILE="${OUTPUT_DIR}/${SERVICE_PASCAL}PermissionRegistration.Generated.cs"
if [ -f "$OLD_FILE" ]; then
    rm "$OLD_FILE"
    echo -e "  ðŸ§¹ Cleaned up legacy file: $(basename "$OLD_FILE")"
fi

# Extract service version from schema info.version
SERVICE_VERSION=$(grep -A1 '^info:' "$SCHEMA_FILE" | grep 'version:' | head -1 | sed "s/.*version:[[:space:]]*['\"]*//" | sed "s/['\"].*//")
if [ -z "$SERVICE_VERSION" ]; then
    SERVICE_VERSION="1.0.0"
fi

echo -e "  ðŸ“‹ Service version: $SERVICE_VERSION"

# Use Python to parse YAML and extract x-permissions (more reliable than bash YAML parsing)
# Fall back to a simpler approach if Python/PyYAML not available

PYTHON_SCRIPT=$(cat << 'PYEOF'
import sys
import json

try:
    import yaml
except ImportError:
    # PyYAML not available - use simple regex extraction
    print("PYYAML_NOT_AVAILABLE", file=sys.stderr)
    sys.exit(2)

schema_file = sys.argv[1]

with open(schema_file, 'r') as f:
    schema = yaml.safe_load(f)

endpoints = []

paths = schema.get('paths', {})
for path, methods in paths.items():
    if not isinstance(methods, dict):
        continue

    for method, operation in methods.items():
        if method.startswith('x-') or not isinstance(operation, dict):
            continue

        permissions = operation.get('x-permissions', [])
        if not permissions:
            continue

        endpoint_info = {
            'path': path,
            'method': method.upper(),
            'operationId': operation.get('operationId', ''),
            'permissions': []
        }

        for perm in permissions:
            if isinstance(perm, dict):
                endpoint_info['permissions'].append({
                    'role': perm.get('role', 'user'),
                    'states': perm.get('states', {}) or {}
                })

        if endpoint_info['permissions']:
            endpoints.append(endpoint_info)

# Output as JSON
print(json.dumps(endpoints))
PYEOF
)

# Try Python extraction first
PERMISSIONS_JSON=""
if command -v python3 &> /dev/null; then
    PERMISSIONS_JSON=$(echo "$PYTHON_SCRIPT" | python3 - "$SCHEMA_FILE" 2>/dev/null) || true
fi

# If Python extraction failed or returned empty, check if there are any x-permissions in the file
if [ -z "$PERMISSIONS_JSON" ] || [ "$PERMISSIONS_JSON" == "[]" ]; then
    # Check if x-permissions exists in the file at all
    if ! grep -q "x-permissions:" "$SCHEMA_FILE"; then
        echo -e "${YELLOW}âš ï¸  No x-permissions found in schema - generating empty registration${NC}"
        PERMISSIONS_JSON="[]"
    else
        echo -e "${YELLOW}âš ï¸  Could not parse x-permissions (Python/PyYAML required for complex parsing)${NC}"
        echo -e "  To enable permission extraction, install: pip install pyyaml"
        PERMISSIONS_JSON="[]"
    fi
fi

# Count endpoints with permissions
ENDPOINT_COUNT=$(echo "$PERMISSIONS_JSON" | python3 -c "import sys,json; print(len(json.load(sys.stdin)))" 2>/dev/null || echo "0")
echo -e "  ðŸ“Š Found $ENDPOINT_COUNT endpoints with permissions"

# Generate C# code
cat > "$OUTPUT_FILE" << CSHARP_EOF
// <auto-generated>
// This file was generated by generate-permissions.sh from ${SERVICE_NAME}-api.yaml
// Do not edit this file directly - changes will be overwritten.
// To modify permissions, edit x-permissions sections in the OpenAPI schema.
// </auto-generated>

#nullable enable

using BeyondImmersion.BannouService.Events;
using Dapr.Client;
using Microsoft.Extensions.Logging;

namespace BeyondImmersion.BannouService.${SERVICE_PASCAL};

/// <summary>
/// Generated permission registration for ${SERVICE_PASCAL} service.
/// Contains permission matrix extracted from x-permissions sections in OpenAPI schema.
/// </summary>
public static class ${SERVICE_PASCAL}PermissionRegistration
{
    /// <summary>
    /// Service ID for permission registration.
    /// </summary>
    public const string ServiceId = "${SERVICE_NAME}";

    /// <summary>
    /// Service version from OpenAPI schema.
    /// </summary>
    public const string ServiceVersion = "${SERVICE_VERSION}";

    /// <summary>
    /// Generates the ServiceRegistrationEvent containing all endpoint permissions.
    /// </summary>
    public static ServiceRegistrationEvent CreateRegistrationEvent()
    {
        return new ServiceRegistrationEvent
        {
            EventId = Guid.NewGuid().ToString(),
            Timestamp = DateTimeOffset.UtcNow,
            ServiceId = ServiceId,
            Version = ServiceVersion,
            AppId = Environment.GetEnvironmentVariable("DAPR_APP_ID") ?? "bannou",
            Endpoints = GetEndpoints()
        };
    }

    /// <summary>
    /// Gets the list of endpoints with their permission requirements.
    /// </summary>
    public static ICollection<ServiceEndpoint> GetEndpoints()
    {
        var endpoints = new List<ServiceEndpoint>();
CSHARP_EOF

# Parse JSON and generate endpoint entries
if [ "$PERMISSIONS_JSON" != "[]" ] && [ -n "$PERMISSIONS_JSON" ]; then
    echo "$PERMISSIONS_JSON" | python3 -c "
import sys
import json

data = json.load(sys.stdin)

for endpoint in data:
    path = endpoint['path']
    method = endpoint['method']
    operation_id = endpoint.get('operationId', '')
    permissions = endpoint['permissions']

    print(f'''
        endpoints.Add(new ServiceEndpoint
        {{
            Path = \"{path}\",
            Method = ServiceEndpointMethod.{method},
            Description = \"{operation_id}\",
            Permissions = new List<PermissionRequirement>
            {{''')

    for perm in permissions:
        role = perm['role']
        states = perm['states']
        states_dict = ', '.join([f'{{\"{k}\", \"{v}\"}}' for k, v in states.items()]) if states else ''

        print(f'''                new PermissionRequirement
                {{
                    Role = \"{role}\",
                    RequiredStates = new Dictionary<string, string> {{ {states_dict} }}
                }},''')

    print('''            }
        });''')
" >> "$OUTPUT_FILE"
fi

# Complete the C# file
cat >> "$OUTPUT_FILE" << 'CSHARP_FOOTER'

        return endpoints;
    }

    /// <summary>
    /// Builds the permission matrix for RegisterServicePermissionsAsync.
    /// Key structure: state -> role -> list of methods
    /// State key construction must match PermissionsService.RecompileSessionPermissionsAsync:
    /// - Same service (s.Key == ServiceId): use just s.Value (e.g., "ringing")
    /// - Cross-service: use "{s.Key}:{s.Value}" (e.g., "game-session:in_game")
    /// </summary>
    public static Dictionary<string, IDictionary<string, ICollection<string>>> BuildPermissionMatrix()
    {
        var matrix = new Dictionary<string, IDictionary<string, ICollection<string>>>();

        foreach (var endpoint in GetEndpoints())
        {
            var methodKey = $"{endpoint.Method}:{endpoint.Path}";

            foreach (var permission in endpoint.Permissions)
            {
                // Determine state key - use "default" if no specific states required
                // For same-service states, use just the value to match lookup logic
                var stateKey = permission.RequiredStates.Count > 0
                    ? string.Join("|", permission.RequiredStates.Select(s =>
                        s.Key == ServiceId ? s.Value : $"{s.Key}:{s.Value}"))
                    : "default";

                if (!matrix.TryGetValue(stateKey, out var roleMap))
                {
                    roleMap = new Dictionary<string, ICollection<string>>();
                    matrix[stateKey] = roleMap;
                }

                if (!roleMap.TryGetValue(permission.Role, out var methods))
                {
                    methods = new List<string>();
                    roleMap[permission.Role] = methods;
                }

                if (!methods.Contains(methodKey))
                {
                    methods.Add(methodKey);
                }
            }
        }

        return matrix;
    }

    /// <summary>
    /// Registers service permissions via event publishing.
    /// Should only be called after Dapr connectivity is confirmed.
    /// </summary>
    public static async Task RegisterViaEventAsync(DaprClient daprClient, ILogger? logger = null)
    {
        try
        {
            var registrationEvent = CreateRegistrationEvent();

            await daprClient.PublishEventAsync(
                "bannou-pubsub",
                "permissions.service-registered",
                registrationEvent);

            logger?.LogInformation(
                "Published service registration event for {ServiceId} v{Version} with {EndpointCount} endpoints",
                ServiceId, ServiceVersion, registrationEvent.Endpoints.Count);
        }
        catch (Exception ex)
        {
            logger?.LogError(ex, "Failed to publish service registration event for {ServiceId}", ServiceId);
            throw;
        }
    }

}
CSHARP_FOOTER

echo -e "${GREEN}âœ… Generated: $OUTPUT_FILE${NC}"
