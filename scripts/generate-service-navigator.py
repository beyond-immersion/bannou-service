#!/usr/bin/env python3
"""
Generate IServiceNavigator interface extensions and ServiceNavigator implementation.

This script scans Generated/Clients/ for service client interfaces and generates:
1. IServiceNavigator.cs - partial interface with service client properties
2. ServiceNavigator.cs - concrete implementation

Architecture:
- Extends the manually-defined IServiceNavigator with service client properties
- ServiceNavigator aggregates all I*Client interfaces via DI
- Provides session context access via ServiceRequestContext
- Auto-forwards session ID headers through outbound mesh calls

Usage:
    python3 scripts/generate-service-navigator.py

Output:
    bannou-service/Generated/IServiceNavigator.cs
    bannou-service/Generated/ServiceNavigator.cs
"""

import re
import sys
from pathlib import Path
from typing import List, NamedTuple


class ClientInfo(NamedTuple):
    """Information about a service client."""
    interface_name: str  # e.g., 'IAccountClient'
    class_name: str      # e.g., 'AccountClient'
    namespace: str       # e.g., 'BeyondImmersion.BannouService.Account'
    property_name: str   # e.g., 'Account'
    field_name: str      # e.g., '_account'


def to_pascal_case(name: str) -> str:
    """Convert service name to PascalCase."""
    return ''.join(p[0].upper() + p[1:] if p else '' for p in name.replace('-', ' ').replace('_', ' ').split())


def extract_namespace_from_file(file_path: Path) -> str:
    """Extract the namespace from a C# file."""
    content = file_path.read_text()
    match = re.search(r'namespace\s+([\w.]+)', content)
    return match.group(1) if match else ''


def discover_clients(clients_dir: Path) -> List[ClientInfo]:
    """Discover all service clients from Generated/Clients directory."""
    clients = []

    for client_file in sorted(clients_dir.glob('*Client.cs')):
        # Skip if the file doesn't exist or is a base class
        if not client_file.exists():
            continue

        class_name = client_file.stem  # e.g., 'AccountClient'

        # Extract interface name
        interface_name = f'I{class_name}'  # e.g., 'IAccountClient'

        # Extract namespace
        namespace = extract_namespace_from_file(client_file)
        if not namespace:
            print(f"  Warning: Could not extract namespace from {client_file.name}")
            continue

        # Derive property name by removing 'Client' suffix
        property_name = class_name.replace('Client', '')  # e.g., 'Account'

        # Derive field name
        field_name = f'_{property_name[0].lower()}{property_name[1:]}'  # e.g., '_account'

        clients.append(ClientInfo(
            interface_name=interface_name,
            class_name=class_name,
            namespace=namespace,
            property_name=property_name,
            field_name=field_name
        ))

    return clients


def generate_interface_extension(clients: List[ClientInfo]) -> str:
    """Generate the partial IServiceNavigator interface with client properties."""
    # Collect unique namespaces
    namespaces = sorted(set(c.namespace for c in clients))

    lines = [
        "// <auto-generated>",
        "// This code was generated by generate-service-navigator.py",
        "// Do not edit this file manually.",
        "// </auto-generated>",
        "",
        "#nullable enable",
        "",
    ]

    # Add using statements for each client namespace
    for ns in namespaces:
        lines.append(f"using {ns};")

    lines.extend([
        "",
        "namespace BeyondImmersion.BannouService.ServiceClients;",
        "",
        "/// <summary>",
        "/// Generated partial interface adding service client properties to IServiceNavigator.",
        "/// </summary>",
        "public partial interface IServiceNavigator",
        "{",
    ])

    # Generate property declarations
    for client in clients:
        lines.extend([
            "    /// <summary>",
            f"    /// Gets the {client.property_name} service client.",
            "    /// </summary>",
            f"    {client.interface_name} {client.property_name} {{ get; }}",
            "",
        ])

    lines.append("}")
    lines.append("")

    return '\n'.join(lines)


def generate_implementation(clients: List[ClientInfo]) -> str:
    """Generate the ServiceNavigator implementation class."""
    # Collect unique namespaces
    namespaces = sorted(set(c.namespace for c in clients))

    lines = [
        "// <auto-generated>",
        "// This code was generated by generate-service-navigator.py",
        "// Do not edit this file manually.",
        "// </auto-generated>",
        "",
        "#nullable enable",
        "",
        "using BeyondImmersion.Bannou.Core;",
        "using BeyondImmersion.BannouService.ClientEvents;",
        "using BeyondImmersion.BannouService.Configuration;",
        "using BeyondImmersion.BannouService.Services;",
    ]

    # Add using statements for each client namespace
    for ns in namespaces:
        lines.append(f"using {ns};")

    lines.extend([
        "",
        "namespace BeyondImmersion.BannouService.ServiceClients;",
        "",
        "/// <summary>",
        "/// Concrete implementation of IServiceNavigator that aggregates all service clients",
        "/// and provides session context access for client event publishing.",
        "/// </summary>",
        "/// <remarks>",
        "/// <para>",
        "/// Registered as Scoped in DI to ensure per-request isolation of service clients.",
        "/// Session context is read from ServiceRequestContext (AsyncLocal storage).",
        "/// </para>",
        "/// <para>",
        "/// This is a partial class. Raw API execution methods are implemented in",
        "/// ServiceClients/ServiceNavigator.RawApi.cs (manual file).",
        "/// </para>",
        "/// </remarks>",
        "public partial class ServiceNavigator : IServiceNavigator",
        "{",
        "    private readonly IClientEventPublisher _clientEventPublisher;",
        "    private readonly IHttpClientFactory _httpClientFactory;",
        "    private readonly IServiceAppMappingResolver _appMappingResolver;",
        "    private readonly IMeshInvocationClient _meshInvocationClient;",
        "    private readonly AppConfiguration _configuration;",
        "",
    ])

    # Generate private readonly fields for each client
    for client in clients:
        lines.append(f"    private readonly {client.interface_name} {client.field_name};")

    lines.append("")

    # Generate constructor
    lines.append("    /// <summary>")
    lines.append("    /// Creates a new ServiceNavigator with all service client dependencies.")
    lines.append("    /// </summary>")
    lines.append("    public ServiceNavigator(")
    lines.append("        IClientEventPublisher clientEventPublisher,")
    lines.append("        IHttpClientFactory httpClientFactory,")
    lines.append("        IServiceAppMappingResolver appMappingResolver,")
    lines.append("        IMeshInvocationClient meshInvocationClient,")
    lines.append("        AppConfiguration configuration,")

    # Add constructor parameters
    for i, client in enumerate(clients):
        comma = "," if i < len(clients) - 1 else ")"
        lines.append(f"        {client.interface_name} {client.field_name.lstrip('_')}{comma}")

    lines.append("    {")
    lines.append("        _clientEventPublisher = clientEventPublisher;")
    lines.append("        _httpClientFactory = httpClientFactory;")
    lines.append("        _appMappingResolver = appMappingResolver;")
    lines.append("        _meshInvocationClient = meshInvocationClient;")
    lines.append("        _configuration = configuration;")

    for client in clients:
        param_name = client.field_name.lstrip('_')
        lines.append(f"        {client.field_name} = {param_name};")

    lines.append("    }")
    lines.append("")

    # Generate context properties and methods
    lines.extend([
        "    // ═══════════════════════════════════════════════════════════════════════════",
        "    // Context Methods",
        "    // ═══════════════════════════════════════════════════════════════════════════",
        "",
        "    /// <inheritdoc />",
        "    public string? GetRequesterSessionId() => ServiceRequestContext.SessionId;",
        "",
        "    /// <inheritdoc />",
        "    public string? GetCorrelationId() => ServiceRequestContext.CorrelationId;",
        "",
        "    /// <inheritdoc />",
        "    public bool HasClientContext => ServiceRequestContext.HasClientContext;",
        "",
        "    // ═══════════════════════════════════════════════════════════════════════════",
        "    // Client Event Methods",
        "    // ═══════════════════════════════════════════════════════════════════════════",
        "",
        "    /// <inheritdoc />",
        "    public async Task<bool> PublishToRequesterAsync<TEvent>(",
        "        TEvent eventData,",
        "        CancellationToken cancellationToken = default)",
        "        where TEvent : BaseClientEvent",
        "    {",
        "        var sessionId = ServiceRequestContext.SessionId;",
        "        if (string.IsNullOrEmpty(sessionId))",
        "            return false;",
        "",
        "        return await _clientEventPublisher.PublishToSessionAsync(sessionId, eventData, cancellationToken);",
        "    }",
        "",
        "    /// <inheritdoc />",
        "    public Task<bool> PublishToSessionAsync<TEvent>(",
        "        string sessionId,",
        "        TEvent eventData,",
        "        CancellationToken cancellationToken = default)",
        "        where TEvent : BaseClientEvent",
        "    {",
        "        return _clientEventPublisher.PublishToSessionAsync(sessionId, eventData, cancellationToken);",
        "    }",
        "",
        "    // ═══════════════════════════════════════════════════════════════════════════",
        "    // Service Client Properties",
        "    // ═══════════════════════════════════════════════════════════════════════════",
        "",
    ])

    # Generate property implementations
    for client in clients:
        lines.extend([
            "    /// <inheritdoc />",
            f"    public {client.interface_name} {client.property_name} => {client.field_name};",
            "",
        ])

    lines.append("}")
    lines.append("")

    return '\n'.join(lines)


def main():
    """Main entry point."""
    script_dir = Path(__file__).parent
    repo_root = script_dir.parent
    clients_dir = repo_root / 'bannou-service' / 'Generated' / 'Clients'
    output_dir = repo_root / 'bannou-service' / 'Generated'

    if not clients_dir.exists():
        print(f"ERROR: Clients directory not found: {clients_dir}")
        print("Run generate-all-services.sh first to generate service clients.")
        sys.exit(1)

    print("Generating ServiceNavigator from discovered service clients...")
    print(f"  Reading from: bannou-service/Generated/Clients/")
    print(f"  Writing to: bannou-service/Generated/")
    print()

    # Discover all clients
    clients = discover_clients(clients_dir)

    if not clients:
        print("ERROR: No service clients found")
        sys.exit(1)

    print(f"  Found {len(clients)} service clients:")
    for client in clients:
        print(f"    - {client.interface_name}")

    # Generate interface extension
    interface_code = generate_interface_extension(clients)
    interface_file = output_dir / 'IServiceNavigator.cs'
    interface_file.write_text(interface_code)
    print(f"\n  Generated IServiceNavigator.cs ({len(clients)} properties)")

    # Clean up old .Generated.cs file if it exists (legacy naming)
    old_file = output_dir / 'IServiceNavigator.Generated.cs'
    if old_file.exists():
        old_file.unlink()
        print(f"  Removed legacy file: IServiceNavigator.Generated.cs")

    # Generate implementation
    impl_code = generate_implementation(clients)
    impl_file = output_dir / 'ServiceNavigator.cs'
    impl_file.write_text(impl_code)
    print(f"  Generated ServiceNavigator.cs")

    print(f"\nGeneration complete. {len(clients)} service clients aggregated.")


if __name__ == '__main__':
    main()
