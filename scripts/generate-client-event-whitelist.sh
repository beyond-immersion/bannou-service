#!/bin/bash

# Generate ClientEventWhitelist.cs from all client event schemas
# Extracts all event_name enum values and creates a HashSet for O(1) validation
# Output: bannou-service/Generated/ClientEventWhitelist.Generated.cs

set -e

# Change to scripts directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Source common utilities
source "./common.sh"

log_info "üîê Generating client event whitelist"

# Output file
TARGET_DIR="../bannou-service/Generated"
mkdir -p "$TARGET_DIR"
OUTPUT_FILE="$TARGET_DIR/ClientEventWhitelist.Generated.cs"

# Collect all event names from all client event schemas
declare -a EVENT_NAMES=()

echo -e "${YELLOW}üìÑ Scanning client event schemas...${NC}"

# Find all client event schema files
for schema_file in ../schemas/*-client-events.yaml; do
    [ -e "$schema_file" ] || continue

    echo -e "  üìã Processing $(basename "$schema_file")..."

    # Extract event_name default values using grep and sed
    # Look for patterns like: default: "connect.capability_manifest"
    # These appear after eventName: property definitions
    while IFS= read -r line; do
        # Clean up the event name (remove quotes, whitespace)
        event_name=$(echo "$line" | sed -E 's/.*default:\s*"([^"]+)".*/\1/' | xargs)

        # Skip empty lines or lines that don't look like event names
        if [[ -n "$event_name" && "$event_name" == *"."* ]]; then
            EVENT_NAMES+=("$event_name")
            echo -e "    ‚úÖ Found: $event_name"
        fi
    done < <(grep -E 'default:\s*"[a-z_]+(\.[a-z_]+)+"' "$schema_file" 2>/dev/null || true)
done

# Check if we found any events
if [ ${#EVENT_NAMES[@]} -eq 0 ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  No event names found in schemas${NC}"
    # Create empty whitelist file anyway
    EVENT_NAMES=()
fi

# Remove duplicates and sort
UNIQUE_EVENTS=($(printf '%s\n' "${EVENT_NAMES[@]}" | sort -u))

echo ""
echo -e "${BLUE}üìù Generating whitelist file...${NC}"

# Generate the C# file
cat > "$OUTPUT_FILE" << 'HEADER'
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by generate-client-event-whitelist.sh
//     DO NOT MODIFY - Changes will be overwritten during regeneration.
//
//     To add new client events:
//     1. Add the event to the appropriate *-client-events.yaml schema
//     2. Run: scripts/generate-client-event-whitelist.sh
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

namespace BeyondImmersion.BannouService.ClientEvents;

/// <summary>
/// Generated whitelist of valid client event names.
/// Used by Connect service for O(1) validation before forwarding events to WebSocket clients.
/// </summary>
public static class ClientEventWhitelist
{
    /// <summary>
    /// HashSet of all valid client event names extracted from *-client-events.yaml schemas.
    /// </summary>
    private static readonly HashSet<string> ValidEventNames = new(StringComparer.OrdinalIgnoreCase)
    {
HEADER

# Add each event name to the HashSet
for event_name in "${UNIQUE_EVENTS[@]}"; do
    echo "        \"$event_name\"," >> "$OUTPUT_FILE"
done

# Close the HashSet and add helper methods
cat >> "$OUTPUT_FILE" << 'FOOTER'
    };

    /// <summary>
    /// Check if an event name is in the whitelist.
    /// </summary>
    /// <param name="eventName">The event name to validate (e.g., "connect.capability_manifest")</param>
    /// <returns>True if the event name is valid, false otherwise</returns>
    public static bool IsValidEventName(string? eventName)
    {
        if (string.IsNullOrWhiteSpace(eventName))
            return false;

        return ValidEventNames.Contains(eventName);
    }

    /// <summary>
    /// Get all valid event names (for debugging/logging).
    /// </summary>
    public static IReadOnlySet<string> GetAllValidEventNames() => ValidEventNames;

    /// <summary>
    /// Get the count of registered client event types.
    /// </summary>
    public static int Count => ValidEventNames.Count;
}
FOOTER

echo -e "${GREEN}‚úÖ Whitelist generated successfully${NC}"
echo -e "   üìÅ Output: $OUTPUT_FILE"
echo -e "   üìä Event count: ${#UNIQUE_EVENTS[@]}"
echo ""

echo -e "${BLUE}Registered client events:${NC}"
for event_name in "${UNIQUE_EVENTS[@]}"; do
    echo -e "  ‚Ä¢ $event_name"
done
echo ""

echo -e "${YELLOW}üí° Usage: ClientEventWhitelist.IsValidEventName(eventName)${NC}"
