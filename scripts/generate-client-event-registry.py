#!/usr/bin/env python3
"""
Generate ClientEventRegistry for the Bannou Client SDK.

This script reads client event schemas from schemas/*-client-events.yaml and generates
a C# registry that maps event type names to their eventName strings.

Architecture:
- Reads x-client-event marked schemas from YAML
- Extracts eventName default values
- Generates static registry class with Type->eventName mapping

Output:
- sdks/client/Generated/Events/ClientEventRegistry.cs

Usage:
    python3 scripts/generate-client-event-registry.py
"""

import re
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

try:
    from ruamel.yaml import YAML
    yaml = YAML()
    yaml.preserve_quotes = True
except ImportError:
    print("ERROR: ruamel.yaml is required. Install with: pip install ruamel.yaml")
    sys.exit(1)


def to_pascal_case(name: str) -> str:
    """Convert kebab-case or snake_case to PascalCase."""
    parts = name.replace('_', '-').split('-')
    return ''.join(p.capitalize() for p in parts)


class EventInfo:
    """Information about a client event."""

    def __init__(self, type_name: str, event_name: str, namespace: str):
        self.type_name = type_name
        self.event_name = event_name
        self.namespace = namespace

    @property
    def full_type_name(self) -> str:
        """Get fully qualified type name."""
        return f"{self.namespace}.{self.type_name}"


def extract_events_from_schema(schema_path: Path) -> List[EventInfo]:
    """Extract client event information from a schema file."""
    events = []

    with open(schema_path) as f:
        try:
            schema = yaml.load(f)
        except Exception as e:
            print(f"  Warning: Failed to parse {schema_path.name}: {e}")
            return events

    if schema is None or 'components' not in schema or 'schemas' not in schema['components']:
        return events

    # Determine namespace based on file
    filename = schema_path.stem
    if filename == 'common-client-events':
        namespace = "BeyondImmersion.BannouService.ClientEvents"
    else:
        # e.g., "game-session-client-events" -> "GameSession"
        service_name = filename.replace('-client-events', '')
        pascal_name = to_pascal_case(service_name)
        namespace = f"BeyondImmersion.Bannou.{pascal_name}.ClientEvents"

    schemas = schema['components']['schemas']
    for schema_name, schema_def in schemas.items():
        if not isinstance(schema_def, dict):
            continue

        # Skip BaseClientEvent and non-event schemas
        if schema_name == 'BaseClientEvent':
            continue

        # Check for x-client-event marker
        if not schema_def.get('x-client-event'):
            continue

        # Get eventName from properties
        props = schema_def.get('properties', {})
        event_name_prop = props.get('eventName', {})

        # The default value is the event name
        event_name = event_name_prop.get('default')
        if not event_name:
            # Try to find in allOf if present
            all_of = schema_def.get('allOf', [])
            for item in all_of:
                if isinstance(item, dict) and 'properties' in item:
                    sub_props = item['properties']
                    if 'eventName' in sub_props:
                        event_name = sub_props['eventName'].get('default')
                        break

        if event_name:
            events.append(EventInfo(schema_name, event_name, namespace))

    return events


def generate_registry(events: List[EventInfo]) -> str:
    """Generate C# registry class."""
    # Group events by namespace for using statements
    namespaces = sorted(set(e.namespace for e in events))

    lines = [
        "// <auto-generated>",
        "// This code was generated by generate-client-event-registry.py",
        "// Do not edit this file manually.",
        "// </auto-generated>",
        "",
        "#nullable enable",
        "",
        "using BeyondImmersion.Bannou.Core;",
    ]

    # Add namespace imports
    for ns in namespaces:
        lines.append(f"using {ns};")

    lines.extend([
        "",
        "namespace BeyondImmersion.Bannou.Client.Events;",
        "",
        "/// <summary>",
        "/// Registry mapping client event types to their eventName strings.",
        "/// Generated from schemas/*-client-events.yaml files.",
        "/// </summary>",
        "public static class ClientEventRegistry",
        "{",
        "    private static readonly Dictionary<Type, string> TypeToEventName = new()",
        "    {",
    ])

    # Add mappings
    for event in sorted(events, key=lambda e: e.type_name):
        lines.append(f"        {{ typeof({event.type_name}), \"{event.event_name}\" }},")

    lines.extend([
        "    };",
        "",
        "    private static readonly Dictionary<string, Type> EventNameToType = new()",
        "    {",
    ])

    # Add reverse mappings
    for event in sorted(events, key=lambda e: e.event_name):
        lines.append(f"        {{ \"{event.event_name}\", typeof({event.type_name}) }},")

    lines.extend([
        "    };",
        "",
        "    /// <summary>",
        "    /// Gets the event name string for a client event type.",
        "    /// </summary>",
        "    /// <typeparam name=\"TEvent\">The event type.</typeparam>",
        "    /// <returns>The event name, or null if type is not registered.</returns>",
        "    public static string? GetEventName<TEvent>() where TEvent : BaseClientEvent",
        "    {",
        "        return TypeToEventName.GetValueOrDefault(typeof(TEvent));",
        "    }",
        "",
        "    /// <summary>",
        "    /// Gets the event name string for a client event type.",
        "    /// </summary>",
        "    /// <param name=\"eventType\">The event type.</param>",
        "    /// <returns>The event name, or null if type is not registered.</returns>",
        "    public static string? GetEventName(Type eventType)",
        "    {",
        "        return TypeToEventName.GetValueOrDefault(eventType);",
        "    }",
        "",
        "    /// <summary>",
        "    /// Gets the C# type for an event name string.",
        "    /// </summary>",
        "    /// <param name=\"eventName\">The event name (e.g., \"game_session.player_joined\").</param>",
        "    /// <returns>The event type, or null if name is not registered.</returns>",
        "    public static Type? GetEventType(string eventName)",
        "    {",
        "        return EventNameToType.GetValueOrDefault(eventName);",
        "    }",
        "",
        "    /// <summary>",
        "    /// Checks if an event type is registered.",
        "    /// </summary>",
        "    public static bool IsRegistered<TEvent>() where TEvent : BaseClientEvent",
        "    {",
        "        return TypeToEventName.ContainsKey(typeof(TEvent));",
        "    }",
        "",
        "    /// <summary>",
        "    /// Checks if an event name is registered.",
        "    /// </summary>",
        "    public static bool IsRegistered(string eventName)",
        "    {",
        "        return EventNameToType.ContainsKey(eventName);",
        "    }",
        "",
        "    /// <summary>",
        "    /// Gets all registered event types.",
        "    /// </summary>",
        "    public static IEnumerable<Type> GetAllEventTypes() => TypeToEventName.Keys;",
        "",
        "    /// <summary>",
        "    /// Gets all registered event names.",
        "    /// </summary>",
        "    public static IEnumerable<string> GetAllEventNames() => EventNameToType.Keys;",
        "}",
        "",
    ])

    return '\n'.join(lines)


def main():
    """Process all client event schemas and generate registry."""
    script_dir = Path(__file__).parent
    repo_root = script_dir.parent
    schema_dir = repo_root / 'schemas'
    output_dir = repo_root / 'sdks' / 'client' / 'Generated' / 'Events'

    if not schema_dir.exists():
        print(f"ERROR: Schema directory not found: {schema_dir}")
        sys.exit(1)

    # Create output directory
    output_dir.mkdir(parents=True, exist_ok=True)

    print("Generating client event registry from schemas...")
    print(f"  Reading from: schemas/*-client-events.yaml")
    print(f"  Writing to: sdks/client/Generated/Events/")
    print()

    all_events: List[EventInfo] = []
    errors = []

    for schema_path in sorted(schema_dir.glob('*-client-events.yaml')):
        try:
            events = extract_events_from_schema(schema_path)
            all_events.extend(events)
            print(f"  {schema_path.name}: {len(events)} events")

        except Exception as e:
            errors.append(f"{schema_path.name}: {e}")

    if errors:
        print("\nErrors:")
        for error in errors:
            print(f"  {error}")
        sys.exit(1)

    if all_events:
        # Generate registry
        registry_code = generate_registry(all_events)
        output_file = output_dir / "ClientEventRegistry.cs"

        with open(output_file, 'w', newline='\n') as f:
            f.write(registry_code)

        print(f"\n  Generated ClientEventRegistry.cs ({len(all_events)} events)")
    else:
        print("\nNo client events found to generate registry for")


if __name__ == '__main__':
    main()
