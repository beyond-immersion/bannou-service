#!/usr/bin/env python3
"""
Generate ClientEventRegistry for the Bannou TypeScript Client SDK.

This script reads client event schemas from schemas/*-client-events.yaml and generates
a TypeScript registry that maps event type names to their eventName strings.

Architecture:
- Reads x-client-event marked schemas from YAML
- Extracts eventName default values
- Generates static registry with eventName->type mapping

Output:
- sdks/typescript/client/Generated/events/ClientEventRegistry.ts

Usage:
    python3 scripts/generate-client-event-registry-ts.py
"""

import sys
from pathlib import Path
from typing import List

try:
    from ruamel.yaml import YAML
    yaml = YAML()
    yaml.preserve_quotes = True
except ImportError:
    print("ERROR: ruamel.yaml is required. Install with: pip install ruamel.yaml")
    sys.exit(1)


def to_pascal_case(name: str) -> str:
    """Convert kebab-case or snake_case to PascalCase."""
    parts = name.replace('_', '-').split('-')
    return ''.join(p.capitalize() for p in parts)


class EventInfo:
    """Information about a client event."""

    def __init__(self, type_name: str, event_name: str, service_name: str):
        self.type_name = type_name
        self.event_name = event_name
        self.service_name = service_name


def extract_events_from_schema(schema_path: Path) -> List[EventInfo]:
    """Extract client event information from a schema file."""
    events = []

    with open(schema_path) as f:
        try:
            schema = yaml.load(f)
        except Exception as e:
            print(f"  Warning: Failed to parse {schema_path.name}: {e}")
            return events

    if schema is None or 'components' not in schema or 'schemas' not in schema['components']:
        return events

    # Determine service name from file
    filename = schema_path.stem
    if filename == 'common-client-events':
        service_name = 'common'
    else:
        service_name = filename.replace('-client-events', '')

    schemas = schema['components']['schemas']
    for schema_name, schema_def in schemas.items():
        if not isinstance(schema_def, dict):
            continue

        # Skip BaseClientEvent and non-event schemas
        if schema_name == 'BaseClientEvent':
            continue

        # Check for x-client-event marker
        if not schema_def.get('x-client-event'):
            continue

        # Skip internal events (not exposed to clients)
        if schema_def.get('x-internal'):
            continue

        # Get eventName from properties
        props = schema_def.get('properties', {})
        event_name_prop = props.get('eventName', {})

        # The default value is the event name
        event_name = event_name_prop.get('default')
        if not event_name:
            # Try to find in allOf if present
            all_of = schema_def.get('allOf', [])
            for item in all_of:
                if isinstance(item, dict) and 'properties' in item:
                    sub_props = item['properties']
                    if 'eventName' in sub_props:
                        event_name = sub_props['eventName'].get('default')
                        break

        if event_name:
            events.append(EventInfo(schema_name, event_name, service_name))

    return events


def generate_registry(events: List[EventInfo]) -> str:
    """Generate TypeScript registry file."""
    lines = [
        "// <auto-generated>",
        "// This code was generated by generate-client-event-registry-ts.py",
        "// Do not edit this file manually.",
        "// </auto-generated>",
        "",
        "import type { BaseClientEvent } from '@beyondimmersion/bannou-core';",
        "",
        "/**",
        " * Registry mapping client event names to metadata.",
        " * Generated from schemas/*-client-events.yaml files.",
        " */",
        "",
        "/**",
        " * Event metadata entry.",
        " */",
        "export interface EventMetadata {",
        "  /** The event name (e.g., 'game_session.player_joined') */",
        "  eventName: string;",
        "  /** TypeScript type name for the event */",
        "  typeName: string;",
        "  /** Service that emits this event */",
        "  service: string;",
        "}",
        "",
        "/**",
        " * Map of event names to their metadata.",
        " */",
        "export const eventRegistry = new Map<string, EventMetadata>([",
    ]

    # Add mappings
    for event in sorted(events, key=lambda e: e.event_name):
        lines.append(f"  ['{event.event_name}', {{ eventName: '{event.event_name}', typeName: '{event.type_name}', service: '{event.service_name}' }}],")

    lines.extend([
        "]);",
        "",
        "/**",
        " * Gets event metadata by event name.",
        " * @param eventName - The event name (e.g., 'game_session.player_joined')",
        " * @returns Event metadata, or undefined if not registered",
        " */",
        "export function getEventMetadata(eventName: string): EventMetadata | undefined {",
        "  return eventRegistry.get(eventName);",
        "}",
        "",
        "/**",
        " * Checks if an event name is registered.",
        " * @param eventName - The event name to check",
        " */",
        "export function isRegisteredEvent(eventName: string): boolean {",
        "  return eventRegistry.has(eventName);",
        "}",
        "",
        "/**",
        " * Gets all registered event names.",
        " */",
        "export function getAllEventNames(): string[] {",
        "  return Array.from(eventRegistry.keys());",
        "}",
        "",
        "/**",
        " * Gets all events for a specific service.",
        " * @param service - Service name (e.g., 'game-session', 'connect')",
        " */",
        "export function getEventsByService(service: string): EventMetadata[] {",
        "  return Array.from(eventRegistry.values()).filter(e => e.service === service);",
        "}",
        "",
        "/**",
        " * Type guard to check if an object has the BaseClientEvent shape.",
        " */",
        "export function isClientEvent(obj: unknown): obj is BaseClientEvent {",
        "  if (typeof obj !== 'object' || obj === null) {",
        "    return false;",
        "  }",
        "  const event = obj as Record<string, unknown>;",
        "  return (",
        "    typeof event.eventName === 'string' &&",
        "    typeof event.eventId === 'string' &&",
        "    typeof event.timestamp === 'string'",
        "  );",
        "}",
        "",
    ])

    return '\n'.join(lines)


def main():
    """Process all client event schemas and generate registry."""
    script_dir = Path(__file__).parent
    repo_root = script_dir.parent
    schema_dir = repo_root / 'schemas'
    output_dir = repo_root / 'sdks' / 'typescript' / 'client' / 'Generated' / 'events'

    if not schema_dir.exists():
        print(f"ERROR: Schema directory not found: {schema_dir}")
        sys.exit(1)

    # Create output directory
    output_dir.mkdir(parents=True, exist_ok=True)

    print("Generating TypeScript client event registry from schemas...")
    print(f"  Reading from: schemas/*-client-events.yaml")
    print(f"  Writing to: sdks/typescript/client/Generated/events/")
    print()

    all_events: List[EventInfo] = []
    errors = []

    for schema_path in sorted(schema_dir.glob('*-client-events.yaml')):
        try:
            events = extract_events_from_schema(schema_path)
            all_events.extend(events)
            print(f"  {schema_path.name}: {len(events)} events")

        except Exception as e:
            errors.append(f"{schema_path.name}: {e}")

    if errors:
        print("\nErrors:")
        for error in errors:
            print(f"  {error}")
        sys.exit(1)

    if all_events:
        # Generate registry
        registry_code = generate_registry(all_events)
        output_file = output_dir / "ClientEventRegistry.ts"

        with open(output_file, 'w', newline='\n') as f:
            f.write(registry_code)

        # Generate index file
        index_content = [
            "// <auto-generated>",
            "// This code was generated by generate-client-event-registry-ts.py",
            "// Do not edit this file manually.",
            "// </auto-generated>",
            "",
            "export * from './ClientEventRegistry.js';",
            "",
        ]
        index_file = output_dir / "index.ts"
        with open(index_file, 'w', newline='\n') as f:
            f.write('\n'.join(index_content))

        print(f"\n  Generated ClientEventRegistry.ts ({len(all_events)} events)")
    else:
        print("\nNo client events found to generate registry for")


if __name__ == '__main__':
    main()
