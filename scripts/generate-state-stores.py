#!/usr/bin/env python3
"""
Generate State Store Code and Documentation from Schema.

This script reads schemas/state-stores.yaml and generates:
1. bannou-service/Generated/StateStoreDefinitions.cs - Typed constants and configuration
2. docs/GENERATED-STATE-STORES.md - Documentation

Usage:
    python3 scripts/generate-state-stores.py
"""

import re
import sys
from pathlib import Path

# Use ruamel.yaml to parse YAML files
try:
    from ruamel.yaml import YAML
    yaml = YAML()
    yaml.preserve_quotes = True
except ImportError:
    print("ERROR: ruamel.yaml is required. Install with: pip install ruamel.yaml")
    sys.exit(1)


def to_pascal_case(name: str) -> str:
    """Convert kebab-case or snake_case to PascalCase."""
    # Split on hyphens and underscores
    parts = re.split(r'[-_]', name)
    # Capitalize each part
    return ''.join(p.capitalize() for p in parts)


def to_constant_name(name: str) -> str:
    """Convert store name to C# constant name (PascalCase without 'Statestore' suffix)."""
    pascal = to_pascal_case(name)
    # Remove common suffixes for cleaner constant names
    if pascal.endswith('Statestore'):
        pascal = pascal[:-10]
    return pascal


def generate_csharp(stores: dict) -> str:
    """Generate C# code for StateStoreDefinitions.cs."""
    lines = [
        "// <auto-generated>",
        "// This file is auto-generated from schemas/state-stores.yaml",
        "// Do not edit manually - regenerate with: python3 scripts/generate-state-stores.py",
        "//",
        "// IMPLEMENTATION TENETS - Configuration-First:",
        "// If a Redis cache store is defined for your service, you MUST implement",
        "// cache read-through (check cache -> fallback to persistent -> populate cache).",
        "// If a store is unused, remove it from schemas/state-stores.yaml.",
        "// See: docs/reference/tenets/IMPLEMENTATION.md",
        "// </auto-generated>",
        "",
        "#nullable enable",
        "",
        "namespace BeyondImmersion.BannouService.Services;",
        "",
        "/// <summary>",
        "/// State store name constants and configuration definitions.",
        "/// Generated from schemas/state-stores.yaml.",
        "/// </summary>",
        "public static class StateStoreDefinitions",
        "{",
        "    #region Store Name Constants",
        "",
    ]

    # Group stores by service for organization
    stores_by_service: dict[str, list[tuple[str, dict]]] = {}
    for store_name, store_config in stores.items():
        service = store_config.get('service', 'Unknown')
        if service not in stores_by_service:
            stores_by_service[service] = []
        stores_by_service[service].append((store_name, store_config))

    # Generate constants grouped by service
    for service in sorted(stores_by_service.keys()):
        service_stores = stores_by_service[service]
        lines.append(f"    // {service} Service")
        for store_name, store_config in sorted(service_stores, key=lambda x: x[0]):
            const_name = to_constant_name(store_name)
            purpose = store_config.get('purpose', '')
            lines.append(f"    /// <summary>{purpose}</summary>")
            lines.append(f'    public const string {const_name} = "{store_name}";')
        lines.append("")

    lines.append("    #endregion")
    lines.append("")
    lines.append("    #region Store Configurations")
    lines.append("")
    lines.append("    /// <summary>")
    lines.append("    /// All state store configurations indexed by store name.")
    lines.append("    /// Use this to configure StateStoreFactory at startup.")
    lines.append("    /// </summary>")
    lines.append("    public static readonly IReadOnlyDictionary<string, StoreConfiguration> Configurations =")
    lines.append("        new Dictionary<string, StoreConfiguration>")
    lines.append("        {")

    # Generate configuration entries
    for store_name, store_config in sorted(stores.items()):
        backend = store_config.get('backend', 'redis')
        prefix = store_config.get('prefix')
        enable_search = store_config.get('enableSearch', False)

        # Build configuration
        backend_enum = f"StateBackend.{backend.capitalize()}"
        if backend == 'mysql':
            backend_enum = "StateBackend.MySql"

        config_parts = [f"Backend = {backend_enum}"]

        if prefix and backend == 'redis':
            config_parts.append(f'KeyPrefix = "{prefix}"')

        if backend == 'mysql':
            # Table name: convert kebab-case to snake_case
            table_name = store_name.replace('-', '_')
            config_parts.append(f'TableName = "{table_name}"')

        if enable_search:
            config_parts.append("EnableSearch = true")

        config_str = ", ".join(config_parts)
        lines.append(f'            [{to_constant_name(store_name)}] = new StoreConfiguration {{ {config_str} }},')

    lines.append("        };")
    lines.append("")
    lines.append("    #endregion")
    lines.append("")
    lines.append("    #region Metadata")
    lines.append("")
    lines.append("    /// <summary>")
    lines.append("    /// Store metadata for documentation and tooling.")
    lines.append("    /// </summary>")
    lines.append("    public static readonly IReadOnlyDictionary<string, StoreMetadata> Metadata =")
    lines.append("        new Dictionary<string, StoreMetadata>")
    lines.append("        {")

    for store_name, store_config in sorted(stores.items()):
        service = store_config.get('service', 'Unknown')
        purpose = store_config.get('purpose', '').replace('"', '\\"')
        backend = store_config.get('backend', 'redis')
        lines.append(f'            [{to_constant_name(store_name)}] = new StoreMetadata("{service}", "{purpose}", "{backend}"),')

    lines.append("        };")
    lines.append("")
    lines.append("    #endregion")
    lines.append("}")
    lines.append("")
    lines.append("/// <summary>")
    lines.append("/// Metadata about a state store for documentation and tooling.")
    lines.append("/// </summary>")
    lines.append("/// <param name=\"Service\">Primary service that owns this store.</param>")
    lines.append("/// <param name=\"Purpose\">Human-readable description of the store's purpose.</param>")
    lines.append("/// <param name=\"Backend\">Backend type (redis, mysql, memory).</param>")
    lines.append("public readonly record struct StoreMetadata(string Service, string Purpose, string Backend);")
    lines.append("")

    return '\n'.join(lines)


def generate_markdown(stores: dict) -> str:
    """Generate markdown documentation for GENERATED-STATE-STORES.md."""
    lines = [
        "# Generated State Store Reference",
        "",
        "> **Source**: `schemas/state-stores.yaml`",
        "> **Do not edit manually** - regenerate with `make generate-docs`",
        "",
        "This document lists all state store components used in Bannou.",
        "",
        "## State Store Components",
        "",
        "| Component Name | Backend | Service | Purpose |",
        "|----------------|---------|---------|---------|",
    ]

    # Sort stores by name
    for store_name, store_config in sorted(stores.items()):
        backend = store_config.get('backend', 'redis').capitalize()
        if backend == 'Mysql':
            backend = 'MySQL'
        service = store_config.get('service', 'Unknown')
        purpose = store_config.get('purpose', '')
        lines.append(f"| `{store_name}` | {backend} | {service} | {purpose} |")

    # Count by backend
    redis_count = sum(1 for s in stores.values() if s.get('backend') == 'redis')
    mysql_count = sum(1 for s in stores.values() if s.get('backend') == 'mysql')

    lines.extend([
        "",
        f"**Total**: {len(stores)} stores ({redis_count} Redis, {mysql_count} MySQL)",
        "",
        "## Naming Conventions",
        "",
        "| Pattern | Backend | Description |",
        "|---------|---------|-------------|",
        "| `{service}-statestore` | Redis/MySQL | Service-specific state storage |",
        "| `{service}-{feature}` | Redis | Feature-specific ephemeral state |",
        "| `mysql-{service}-statestore` | MySQL | Legacy pattern (prefer `{service}-statestore`) |",
        "",
        "## Backend Selection Guide",
        "",
        "| Use Case | Backend | Rationale |",
        "|----------|---------|-----------|",
        "| Session data, tokens | Redis | Fast, ephemeral, supports TTL |",
        "| Caches, rankings | Redis | In-memory performance, sorted sets |",
        "| Persistent entities | MySQL | Durable, queryable, relational |",
        "| Full-text search | Redis + Search | RedisSearch module for indexing |",
        "",
        "## Deployment Flexibility",
        "",
        "The state store abstraction means multiple logical state stores can share physical",
        "Redis/MySQL instances in simple deployments, while production deployments can map",
        "to dedicated infrastructure without code changes.",
        "",
        "### Example: Development (Shared Infrastructure)",
        "",
        "```yaml",
        "# All Redis state stores point to same instance",
        "auth-statestore:     bannou-redis:6379",
        "connect-statestore:  bannou-redis:6379",
        "permission-statestore: bannou-redis:6379",
        "```",
        "",
        "### Example: Production (Dedicated Infrastructure)",
        "",
        "```yaml",
        "# Each service can have its own infrastructure",
        "auth-statestore:     auth-redis-cluster.prod:6379",
        "connect-statestore:  connect-redis-cluster.prod:6379",
        "permission-statestore: permission-redis.prod:6379",
        "```",
        "",
        "## Generated Code",
        "",
        "State store definitions are generated to `bannou-service/Generated/StateStoreDefinitions.cs`,",
        "providing:",
        "",
        "- **Name constants**: `StateStoreDefinitions.Auth`, `StateStoreDefinitions.Account`, etc.",
        "- **Configurations**: `StateStoreDefinitions.Configurations` dictionary",
        "- **Metadata**: `StateStoreDefinitions.Metadata` for tooling",
        "",
        "---",
        "",
        "*This file is auto-generated. See [TENETS.md](reference/TENETS.md) for architectural context.*",
        "",
    ])

    return '\n'.join(lines)


def main():
    script_dir = Path(__file__).parent
    repo_root = script_dir.parent

    # Read schema
    schema_file = repo_root / 'schemas' / 'state-stores.yaml'
    if not schema_file.exists():
        print(f"ERROR: Schema file not found: {schema_file}")
        sys.exit(1)

    with open(schema_file) as f:
        content = yaml.load(f)

    if content is None:
        print("ERROR: Failed to parse schema file")
        sys.exit(1)

    stores = content.get('x-state-stores', {})
    if not stores:
        print("Warning: No state stores defined in schema")

    # Generate C# code (output to bannou-service where StoreConfiguration is defined)
    csharp_code = generate_csharp(stores)
    csharp_output = repo_root / 'bannou-service' / 'Generated' / 'StateStoreDefinitions.cs'
    csharp_output.parent.mkdir(parents=True, exist_ok=True)
    with open(csharp_output, 'w') as f:
        f.write(csharp_code)
    print(f"Generated {csharp_output}")

    # Generate documentation
    markdown = generate_markdown(stores)
    md_output = repo_root / 'docs' / 'GENERATED-STATE-STORES.md'
    with open(md_output, 'w') as f:
        f.write(markdown)
    print(f"Generated {md_output}")

    print(f"Processed {len(stores)} state stores")


if __name__ == '__main__':
    main()
