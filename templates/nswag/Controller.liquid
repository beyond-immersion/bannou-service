{% if GeneratePartialControllers -%}
[System.CodeDom.Compiler.GeneratedCode("NSwag", "{{ ToolchainVersion }}")]
public interface I{{ Class }}Controller : BeyondImmersion.BannouService.Controllers.IBannouController
{
{%-     for operation in Operations %}
{%-         comment -%}
        Interface includes ALL methods (including controller-only).
        Controller-only methods will be implemented in the partial controller class.
{%-         endcomment -%}
{%-         if operation.HasSummary %}
    /// <summary>
    /// {{ operation.Summary | csharpdocs }}
    /// </summary>
{%-         endif %}
{%          if operation.HasDescription -%}
    /// <remarks>
    /// {{ operation.Description | csharpdocs }}
    /// </remarks>
{%          endif -%}
{%-         for parameter in operation.Parameters %}
{%-             if parameter.HasDescription %}
    /// <param name="{{ parameter.VariableName }}">{{ parameter.Description | csharpdocs }}</param>
{%-             endif %}
{%-         endfor %}
{%-         if operation.HasResultDescription %}
    /// <returns>{{ operation.ResultDescription | csharpdocs }}</returns>
{%         endif -%}
{%-         if operation.IsDeprecated %}
    [System.Obsolete]
{%-         endif %}
    {{ operation.ResultType }} {{ operation.ActualOperationName }}Async({% for parameter in operation.Parameters %}{% assign parameterOptional = GenerateOptionalParameters and parameter.IsOptional %}{{ parameter.TypeInControllerInterface }} {{ parameter.VariableName }}{% if parameterOptional and parameter.HasDefault == false %} = null{% endif %}{% if parameter.IsLast == false or UseCancellationToken %}, {% endif %}{% endfor %}{% if UseCancellationToken %}System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken){% endif %});

{%-      endfor %}
}
{%- endif %}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "{{ ToolchainVersion }}")]
{%- if HasBasePath -%}
{%-     if IsAspNetCore -%}
[{{ AspNetNamespace }}.Route("{{ BasePath }}")]
{%-     else -%}
[{{ AspNetNamespace }}.RoutePrefix("{{ BasePath }}")]
{%-     endif -%}
{%- endif -%}
{%- if GeneratePartialControllers -%}
{% template Controller.Class.Annotations %}
{%- assign hasControllerOnlyMethods = false -%}
{%- for operation in Operations -%}
{%-   assign isControllerOnly = operation.ExtensionData["x-controller-only"] -%}
{%-   if isControllerOnly -%}
{%-     assign hasControllerOnlyMethods = true -%}
{%-     break -%}
{%-   endif -%}
{%- endfor -%}
public {% if hasControllerOnlyMethods %}abstract{% else %}partial{% endif %} class {{ Class }}Controller{% if hasControllerOnlyMethods %}Base{% endif %} : {% if HasBaseClass %}{{ BaseClass }}{% else %}{{ AspNetNamespace }}.{% if IsAspNetCore %}ControllerBase{% else %}ApiController{% endif %}{% endif %}
{
    private I{{ Class }}Service _implementation;

    public {{ Class }}Controller{% if hasControllerOnlyMethods %}Base{% endif %}(I{{ Class }}Service implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.Created => Created("", result),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.Created => result != null ? Created("", result) : Created("", null),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

{%     for operation in Operations -%}
{%         comment -%}
        Check for x-manual-implementation extension.
        If yes, skip generating this method entirely - it will be provided by partial class.
        Check if operation has x-controller-only extension.
        If yes, make it abstract (implemented in partial controller class).
        If no, provide concrete implementation that delegates to service.
{%-     endcomment -%}
{%         assign isManualImplementation = operation.ExtensionData["x-manual-implementation"] -%}
{%         if isManualImplementation -%}
    // Endpoint {{ operation.ActualOperationName }} requires manual implementation in partial class.
    // See x-manual-implementation: true in the OpenAPI schema.

{%         else -%}
{%         assign isControllerOnly = operation.ExtensionData["x-controller-only"] -%}
{%         if operation.HasSummary -%}
    /// <summary>
    /// {{ operation.Summary | csharpdocs }}
    /// </summary>
{%         endif -%}
{%         if operation.HasDescription -%}
    /// <remarks>
    /// {{ operation.Description | csharpdocs }}
    /// </remarks>
{%         endif -%}
{%         for parameter in operation.Parameters -%}
{%             if parameter.HasDescription -%}
    /// <param name="{{ parameter.VariableName }}">{{ parameter.Description | csharpdocs }}</param>
{%             endif -%}
{%         endfor -%}
{%         if operation.HasResultDescription -%}
    /// <returns>{{ operation.ResultDescription | csharpdocs }}</returns>
{%         endif -%}
{%         if operation.IsDeprecated -%}
    [System.Obsolete]
{%         endif -%}
    {% template Controller.Method.Annotations %}
    [{{ AspNetNamespace }}.Http{{ operation.HttpMethodUpper }}, {{ AspNetNamespace }}.Route("{{ operation.Path }}"{% if operation.HasRouteName %}, Name = "{{ operation.RouteName }}"{% endif %})]
{%-         if isControllerOnly %}
    public abstract {% if IsAspNetCore and operation.WrapResponse %}System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult>{% elsif operation.WrapResponse %}System.Threading.Tasks.Task<HttpResponseMessage>{% else %}{{ operation.ResultType }}{% endif %} {{ operation.ActualOperationName }}({% for parameter in operation.Parameters %}{% assign hasHeaderExtraction = parameter.ExtensionData["x-from-authorization"] or parameter.ExtensionData["x-from-header"] %}{% unless hasHeaderExtraction %}{% if parameter.IsQuery %}[{{ AspNetNamespace }}.{% if IsAspNetCore -%}FromQuery{% else -%}FromUri{%- endif %}{% if parameter.IsValidIdentifier == false %}(Name = "{{ parameter.Name }}"){% endif %}] {% endif %}{% if parameter.IsHeader %}[{% if IsAspNetCore -%}{{ AspNetNamespace }}.{%- endif %}FromHeader{% if parameter.IsValidIdentifier == false %}(Name = "{{ parameter.Name }}"){% endif %}] {% endif %}{% if parameter.IsBody and parameter.IsBinaryBody == false %}[{{ AspNetNamespace }}.FromBody] {% endif %}{% if GenerateModelValidationAttributes and parameter.IsRequired %}[{{ RequiredAttributeType }}] {% endif %}{{ parameter.Type }} {{ parameter.VariableName }}{% if GenerateOptionalParameters and parameter.IsOptional %} = null{% endif %}{% if parameter.IsLast == false or UseCancellationToken %}, {% endif %}{% endunless %}{% endfor %}{% if UseCancellationToken %}System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken){% endif %});
{%-         else %}
    public async {% if IsAspNetCore and operation.WrapResponse %}System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult>{% elsif operation.WrapResponse %}System.Threading.Tasks.Task<HttpResponseMessage>{% else %}{{ operation.ResultType }}{% endif %} {{ operation.ActualOperationName }}({% for parameter in operation.Parameters %}{% assign hasHeaderExtraction = parameter.ExtensionData["x-from-authorization"] or parameter.ExtensionData["x-from-header"] %}{% unless hasHeaderExtraction %}{% if parameter.IsQuery %}[{{ AspNetNamespace }}.{% if IsAspNetCore -%}FromQuery{% else -%}FromUri{%- endif %}{% if parameter.IsValidIdentifier == false %}(Name = "{{ parameter.Name }}"){% endif %}] {% endif %}{% if parameter.IsHeader %}[{% if IsAspNetCore -%}{{ AspNetNamespace }}.{%- endif %}FromHeader{% if parameter.IsValidIdentifier == false %}(Name = "{{ parameter.Name }}"){% endif %}] {% endif %}{% if parameter.IsBody and parameter.IsBinaryBody == false %}[{{ AspNetNamespace }}.FromBody] {% endif %}{% if GenerateModelValidationAttributes and parameter.IsRequired %}[{{ RequiredAttributeType }}] {% endif %}{{ parameter.Type }} {{ parameter.VariableName }}{% if GenerateOptionalParameters and parameter.IsOptional %} = null{% endif %}{% if parameter.IsLast == false or UseCancellationToken %}, {% endif %}{% endunless %}{% endfor %}{% if UseCancellationToken %}System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken){% endif %})
    {
{%-         comment -%}
        Extract header values for parameters with x-from-authorization or x-from-header metadata
{%-         endcomment -%}
{%-         for parameter in operation.Parameters -%}
{%-             assign fromAuth = parameter.ExtensionData["x-from-authorization"] -%}
{%-             assign fromHeader = parameter.ExtensionData["x-from-header"] -%}
{%-             if fromAuth -%}
{%-                 if fromAuth == "bearer" %}
        var {{ parameter.VariableName }} = HttpContext.ExtractBearerToken();
        if (string.IsNullOrEmpty({{ parameter.VariableName }}))
            return Unauthorized("Missing or invalid Authorization header");
{%-                 else %}
        var {{ parameter.VariableName }} = HttpContext.ExtractHeader("Authorization");
        if (string.IsNullOrEmpty({{ parameter.VariableName }}))
            return Unauthorized("Missing Authorization header");
{%-                 endif -%}
{%-             elsif fromHeader %}
        var {{ parameter.VariableName }} = HttpContext.ExtractHeader("{{ fromHeader }}");
{%-                 if parameter.IsRequired %}
        if (string.IsNullOrEmpty({{ parameter.VariableName }}))
            return BadRequest("Missing required header: {{ fromHeader }}");
{%-                 endif -%}
{%-             endif -%}
{%-         endfor %}
{%-             if IsAspNetCore and operation.WrapResponse %}
        var result = await _implementation.{{ operation.ActualOperationName }}Async({% for parameter in operation.Parameters %}{{ parameter.VariableName }}{% if parameter.HasDefault %} ?? {{parameter.Default}}{% endif %}{% if parameter.IsLast == false or UseCancellationToken %}, {% endif %}{% endfor %}{% if UseCancellationToken %}cancellationToken{% endif %}).ConfigureAwait(false);

        var status = result.StatusCode;
        Microsoft.AspNetCore.Mvc.ObjectResult response = new Microsoft.AspNetCore.Mvc.ObjectResult(result{% if operation.UnwrappedResultType != "void" %}.Result{% endif %}) { StatusCode = status };

        foreach (var header in result.Headers)
            Request.HttpContext.Response.Headers.Add(header.Key, new Microsoft.Extensions.Primitives.StringValues(header.Value.ToArray()));

        return response;
{%-             elsif operation.WrapResponse %}
        var result = await _implementation.{{ operation.ActualOperationName }}Async({% for parameter in operation.Parameters %}{{ parameter.VariableName }}{% if parameter.HasDefault %} ?? {{parameter.Default}}{% endif %}{% if parameter.IsLast == false or UseCancellationToken %}, {% endif %}{% endfor %}{% if UseCancellationToken %}cancellationToken{% endif %}).ConfigureAwait(false);

        var status = (System.Net.HttpStatusCode)result.StatusCode;
        HttpResponseMessage response = Request.CreateResponse(status{% if operation.UnwrappedResultType != "void" %}, result.Result{% endif %});

        foreach (var header in result.Headers)
            response.Headers.Add(header.Key, header.Value);

        return response;
{%-             else %}
{%-               comment -%}
        Check if operation has no response body (e.g., 204 No Content).
        In this case, the service returns Task<StatusCodes> instead of Task<(StatusCodes, T?)>
        NSwag sets UnwrappedResultType to "void" or "FileResponse" for operations without JSON response body.
{%-               endcomment -%}
{%-               assign hasResponseBody = true -%}
{%-               if operation.UnwrappedResultType == "void" or operation.UnwrappedResultType == "FileResponse" -%}
{%-                 assign hasResponseBody = false -%}
{%-               endif -%}
{%-               if hasResponseBody %}
        var (statusCode, result) = await _implementation.{{ operation.ActualOperationName }}Async({% for parameter in operation.Parameters %}{{ parameter.VariableName }}{% if parameter.HasDefault %} ?? {{parameter.Default}}{% endif %}{% if parameter.IsLast == false or UseCancellationToken %}, {% endif %}{% endfor %}{% if UseCancellationToken %}cancellationToken{% endif %});
        return ConvertToActionResult(statusCode, result);
{%-               else %}
        var statusCode = await _implementation.{{ operation.ActualOperationName }}Async({% for parameter in operation.Parameters %}{{ parameter.VariableName }}{% if parameter.HasDefault %} ?? {{parameter.Default}}{% endif %}{% if parameter.IsLast == false or UseCancellationToken %}, {% endif %}{% endfor %}{% if UseCancellationToken %}cancellationToken{% endif %});
        return ConvertToActionResult(statusCode);
{%-               endif -%}
{%             endif -%}
    }
{%-         endif %}
{%-         endif %}

{%     endfor -%}

{%- comment -%}
=== META ENDPOINTS GENERATION ===
Generate companion endpoints for runtime schema introspection.
Each operation with x-request-schema-json gets 4 meta endpoints:
- /meta/info - Human-readable endpoint description
- /meta/request-schema - JSON Schema for request body
- /meta/response-schema - JSON Schema for response body
- /meta/schema - Complete schema (info + request + response)
{%- endcomment -%}
{%- for operation in Operations -%}
{%-   assign hasMetaSchemas = operation.ExtensionData["x-request-schema-json"] -%}
{%-   if hasMetaSchemas %}

    #region Meta Endpoints for {{ operation.ActualOperationName }}

    private static readonly string _{{ operation.ActualOperationName }}_RequestSchema = """
{{ operation.ExtensionData["x-request-schema-json"] }}
""";

    private static readonly string _{{ operation.ActualOperationName }}_ResponseSchema = """
{{ operation.ExtensionData["x-response-schema-json"] }}
""";

    private static readonly string _{{ operation.ActualOperationName }}_Info = """
{{ operation.ExtensionData["x-endpoint-info-json"] }}
""";

    /// <summary>Returns endpoint information for {{ operation.ActualOperationName }}</summary>
    [{{ AspNetNamespace }}.HttpGet, {{ AspNetNamespace }}.Route("{{ operation.Path }}/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> {{ operation.ActualOperationName }}_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "{{ Class }}",
            "{{ operation.HttpMethodUpper }}",
            "{{ operation.Path }}",
            _{{ operation.ActualOperationName }}_Info));

    /// <summary>Returns request schema for {{ operation.ActualOperationName }}</summary>
    [{{ AspNetNamespace }}.HttpGet, {{ AspNetNamespace }}.Route("{{ operation.Path }}/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> {{ operation.ActualOperationName }}_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "{{ Class }}",
            "{{ operation.HttpMethodUpper }}",
            "{{ operation.Path }}",
            "request-schema",
            _{{ operation.ActualOperationName }}_RequestSchema));

    /// <summary>Returns response schema for {{ operation.ActualOperationName }}</summary>
    [{{ AspNetNamespace }}.HttpGet, {{ AspNetNamespace }}.Route("{{ operation.Path }}/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> {{ operation.ActualOperationName }}_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "{{ Class }}",
            "{{ operation.HttpMethodUpper }}",
            "{{ operation.Path }}",
            "response-schema",
            _{{ operation.ActualOperationName }}_ResponseSchema));

    /// <summary>Returns full schema for {{ operation.ActualOperationName }}</summary>
    [{{ AspNetNamespace }}.HttpGet, {{ AspNetNamespace }}.Route("{{ operation.Path }}/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> {{ operation.ActualOperationName }}_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "{{ Class }}",
            "{{ operation.HttpMethodUpper }}",
            "{{ operation.Path }}",
            _{{ operation.ActualOperationName }}_Info,
            _{{ operation.ActualOperationName }}_RequestSchema,
            _{{ operation.ActualOperationName }}_ResponseSchema));

    #endregion
{%-   endif -%}
{%- endfor -%}

{%- comment -%}
Generate event handler methods from x-event-subscriptions in OpenAPI spec
{%- endcomment -%}
{%- if ExtensionData["x-event-subscriptions"] -%}
{%-     for subscription in ExtensionData["x-event-subscriptions"] -%}
{%-         comment -%}
            Convert topic name to PascalCase method name
            Handle both dots and hyphens as word separators
            e.g., "permissions.capabilities-updated" -> "PermissionsCapabilitiesUpdated"
{%-         endcomment -%}
{%-         assign normalizedTopic = subscription.topic | replace: "-", "." -%}
{%-         assign topicParts = normalizedTopic | split: "." -%}
{%-         assign eventName = "" -%}
{%-         for part in topicParts -%}
{%-             assign capitalizedPart = part | capitalize -%}
{%-             assign eventName = eventName | append: capitalizedPart -%}
{%-         endfor -%}
{%-         assign methodName = "Handle" | append: eventName | append: "Event" -%}

    /// <summary>
    /// Event handler for {{ subscription.topic }} events
    /// </summary>
    /// <remarks>
    /// {{ subscription.description }}
    /// </remarks>
    [BeyondImmersion.BannouService.Attributes.Topic("{{ subscription.pubsub }}", "{{ subscription.topic }}")]
    [{{ AspNetNamespace }}.HttpPost("{{ subscription.path }}")]
    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> {{ methodName }}([{{ AspNetNamespace }}.FromBody] object eventData)
    {
        try
        {
            var logger = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<{{ Class }}Controller>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogDebug(logger, "Processing pub/sub event: {Topic}", "{{ subscription.topic }}");

            // Use BannouJson for consistent serialization with generated models
            var serializedData = BeyondImmersion.BannouService.Configuration.BannouJson.Serialize(eventData);

{%-         comment -%}
            Extract event type information from schema $ref
            Format: 'accounts-events.yaml#/components/schemas/AccountDeletedEvent'
{%-         endcomment -%}
{%-         assign schemaRef = subscription.schema["$ref"] -%}
{%-         assign refParts = schemaRef | split: "#/components/schemas/" -%}
{%-         assign sourceFile = refParts[0] | remove: ".yaml" | remove: "'" -%}
{%-         assign eventTypeName = refParts[1] -%}
{%-         comment -%}
            Map source file to namespace - accounts-events -> Accounts
{%-         endcomment -%}
{%-         assign serviceName = sourceFile | split: "-" | first | capitalize -%}
{%-         assign fullTypeName = "BeyondImmersion.BannouService." | append: serviceName | append: "." | append: eventTypeName -%}

            // Deserialize using BannouJson for consistent handling
            var typedEventData = BeyondImmersion.BannouService.Configuration.BannouJson.Deserialize<{{ fullTypeName }}>(serializedData);

            if (typedEventData != null)
            {
                Microsoft.Extensions.Logging.LoggerExtensions.LogInformation(logger, "Processing {{ subscription.topic }} event for entity: {EntityId}", typedEventData.AccountId);
                await _implementation.OnEventReceivedAsync("{{ subscription.topic }}", typedEventData);
            }
            else
            {
                Microsoft.Extensions.Logging.LoggerExtensions.LogWarning(logger, "Failed to deserialize {{ subscription.topic }} event data");
            }
            return Ok();
        }
        catch (System.Exception ex)
        {
            var logger = Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<Microsoft.Extensions.Logging.ILogger<{{ Class }}Controller>>(HttpContext.RequestServices);
            Microsoft.Extensions.Logging.LoggerExtensions.LogError(logger, ex, "Failed to process {{ subscription.topic }} event");
            return StatusCode(500, new { error = "Event processing failed" });
        }
    }

{%-     endfor -%}
{%- endif -%}
}
{% elsif GenerateAbstractControllers -%}
{% template Controller.Class.Annotations %}
public abstract class {{ Class }}ControllerBase : {% if HasBaseClass %}{{ BaseClass }}{% else %}{{ AspNetNamespace }}.{% if IsAspNetCore %}ControllerBase{% else %}ApiController{% endif %}{% endif %}
{
{%     for operation in Operations -%}
{%         if operation.HasSummary -%}
    /// <summary>
    /// {{ operation.Summary | csharpdocs }}
    /// </summary>
{%         endif -%}
{%         if operation.HasDescription -%}
    /// <remarks>
    /// {{ operation.Description | csharpdocs }}
    /// </remarks>
{%         endif -%}
{%         for parameter in operation.Parameters -%}
{%             if parameter.HasDescription -%}
    /// <param name="{{ parameter.VariableName }}">{{ parameter.Description | csharpdocs }}</param>
{%             endif -%}
{%         endfor -%}
{%         if operation.HasResultDescription -%}
    /// <returns>{{ operation.ResultDescription | csharpdocs }}</returns>
{%         endif -%}
{%         if operation.IsDeprecated -%}
    [System.Obsolete]
{%         endif -%}
    {% template Controller.Method.Annotations %}
    [{{ AspNetNamespace }}.Http{{ operation.HttpMethodUpper }}, {{ AspNetNamespace }}.Route("{{ operation.Path }}"{% if operation.HasRouteName %}, Name = "{{ operation.RouteName }}"{% endif %})]
    public abstract {%  if operation.WrapResponse %}System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage>{% else %}{{ operation.ResultType }}{% endif %} {{ operation.ActualOperationName }}({% for parameter in operation.Parameters %}{% if parameter.IsQuery %}[{{ AspNetNamespace }}.{% if IsAspNetCore -%}FromQuery{% else -%}FromUri{%- endif %}{% if parameter.IsValidIdentifier == false %}(Name = "{{ parameter.Name }}"){% endif %}] {% endif %}{% if parameter.IsHeader %}[{% if IsAspNetCore -%}{{ AspNetNamespace }}.{%- endif %}FromHeader{% if parameter.IsValidIdentifier == false %}(Name = "{{ parameter.Name }}"){% endif %}] {% endif %}{% if parameter.IsBody and parameter.IsBinaryBody == false %}[{{ AspNetNamespace }}.FromBody] {% endif %}{% if GenerateModelValidationAttributes and parameter.IsRequired %}[{{ RequiredAttributeType }}] {% endif %}{{ parameter.Type }} {{ parameter.VariableName }}{% if parameter.HasDefault %} = {{parameter.Default}}{% endif %}{% if GenerateOptionalParameters and parameter.IsOptional and parameter.HasDefault == false %} = null{% endif %}{% if parameter.IsLast == false or UseCancellationToken %}, {% endif %}{% endfor %}{% if UseCancellationToken %}System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken){% endif %});

{%     endfor -%}
{%- comment -%}
Generate event handler methods from x-event-subscriptions in OpenAPI spec (for abstract controllers)
{%- endcomment -%}
{%- if ExtensionData["x-event-subscriptions"] -%}
{%-     for subscription in ExtensionData["x-event-subscriptions"] -%}
{%-         comment -%}
            Convert topic name to PascalCase method name
            Handle both dots and hyphens as word separators
            e.g., "permissions.capabilities-updated" -> "PermissionsCapabilitiesUpdated"
{%-         endcomment -%}
{%-         assign normalizedTopic = subscription.topic | replace: "-", "." -%}
{%-         assign topicParts = normalizedTopic | split: "." -%}
{%-         assign eventName = "" -%}
{%-         for part in topicParts -%}
{%-             assign capitalizedPart = part | capitalize -%}
{%-             assign eventName = eventName | append: capitalizedPart -%}
{%-         endfor -%}
{%-         assign methodName = "Handle" | append: eventName | append: "Event" -%}

    /// <summary>
    /// Event handler for {{ subscription.topic }} events
    /// </summary>
    /// <remarks>
    /// {{ subscription.description }}
    /// </remarks>
    [BeyondImmersion.BannouService.Attributes.Topic("{{ subscription.pubsub }}", "{{ subscription.topic }}")]
    [{{ AspNetNamespace }}.HttpPost("{{ subscription.path }}")]
    public abstract System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.IActionResult> {{ methodName }}([{{ AspNetNamespace }}.FromBody] object eventData);

{%-     endfor -%}
{%- endif -%}
}
{%- endif %}
