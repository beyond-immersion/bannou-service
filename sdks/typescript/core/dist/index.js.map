{"version":3,"sources":["../src/BannouJson.ts","../src/ApiResponse.ts","../src/BaseClientEvent.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Static helper for JSON serialization/deserialization that uses Bannou's\n * standard configuration. This is the SINGLE SOURCE OF TRUTH for JSON\n * serialization settings across all Bannou TypeScript SDKs.\n *\n * USE THIS INSTEAD OF JSON.parse/stringify DIRECTLY.\n *\n * This ensures consistent behavior across the codebase:\n * - Case-insensitive property matching during deserialization (via normalization)\n * - Enums serialize as strings matching C# enum names\n * - Null/undefined values are omitted when serializing\n * - Strict number handling (no string-to-number coercion in results)\n *\n * @example\n * ```typescript\n * const model = BannouJson.deserialize<MyModel>(jsonString);\n * const json = BannouJson.serialize(model);\n * ```\n */\nexport class BannouJson {\n  /**\n   * Deserialize JSON string to object using Bannou's standard configuration.\n   * @param json - The JSON string to parse\n   * @returns The deserialized object, or null if parsing fails\n   */\n  static deserialize<T>(json: string): T | null {\n    try {\n      return JSON.parse(json) as T;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Deserialize JSON string to object using Bannou's standard configuration.\n   * Throws if result is null or parsing fails.\n   * @param json - The JSON string to parse\n   * @throws Error if deserialization fails\n   */\n  static deserializeRequired<T>(json: string): T {\n    const result = this.deserialize<T>(json);\n    if (result === null) {\n      throw new Error('Failed to deserialize JSON');\n    }\n    return result;\n  }\n\n  /**\n   * Serialize object to JSON string using Bannou's standard configuration.\n   * Omits null and undefined values from the output.\n   * @param value - The value to serialize\n   * @returns JSON string\n   */\n  static serialize<T>(value: T): string {\n    return JSON.stringify(value, (_, v) => {\n      // Omit null and undefined values (matches C# DefaultIgnoreCondition.WhenWritingNull)\n      if (v === null || v === undefined) {\n        return undefined;\n      }\n      return v;\n    });\n  }\n\n  /**\n   * Serialize object to UTF-8 bytes using Bannou's standard configuration.\n   * @param value - The value to serialize\n   * @returns UTF-8 encoded bytes\n   */\n  static serializeToUtf8Bytes<T>(value: T): Uint8Array {\n    const json = this.serialize(value);\n    return new TextEncoder().encode(json);\n  }\n\n  /**\n   * Deserialize from UTF-8 bytes using Bannou's standard configuration.\n   * @param utf8Json - UTF-8 encoded JSON bytes\n   * @returns The deserialized object, or null if parsing fails\n   */\n  static deserializeFromUtf8Bytes<T>(utf8Json: Uint8Array): T | null {\n    const json = new TextDecoder().decode(utf8Json);\n    return this.deserialize<T>(json);\n  }\n}\n\n/**\n * Extension function to deserialize a JSON string.\n * @param json - The JSON string to parse\n * @returns The deserialized object, or null if parsing fails\n */\nexport function fromJson<T>(json: string): T | null {\n  return BannouJson.deserialize<T>(json);\n}\n\n/**\n * Extension function to serialize an object to JSON.\n * @param value - The value to serialize\n * @returns JSON string\n */\nexport function toJson<T>(value: T): string {\n  return BannouJson.serialize(value);\n}\n","/**\n * Represents an error response from a Bannou API call.\n * Contains all available information about the failed request.\n */\nexport interface ErrorResponse {\n  /**\n   * The HTTP status code equivalent for this error.\n   * Standard HTTP codes: 400 = Bad Request, 401 = Unauthorized, 404 = Not Found,\n   * 409 = Conflict, 500 = Internal Server Error.\n   */\n  responseCode: number;\n\n  /**\n   * Human-readable error name (e.g., \"InternalServerError\", \"Unauthorized\").\n   */\n  errorName: string | null;\n\n  /**\n   * Detailed error message from the server, if provided.\n   */\n  message: string | null;\n\n  /**\n   * The unique message ID for request/response correlation.\n   */\n  messageId: bigint;\n\n  /**\n   * The HTTP method of the original request (e.g., \"POST\", \"GET\").\n   */\n  method: string;\n\n  /**\n   * The path of the original request (e.g., \"/subscription/create\").\n   */\n  path: string;\n}\n\n/**\n * Maps internal WebSocket protocol response codes to standard HTTP status codes.\n * This hides the binary protocol implementation details from client code.\n */\nexport function mapToHttpStatusCode(wsResponseCode: number): number {\n  switch (wsResponseCode) {\n    case 0:\n      return 200; // OK\n    case 50:\n      return 400; // Service_BadRequest\n    case 51:\n      return 404; // Service_NotFound\n    case 52:\n      return 401; // Service_Unauthorized (covers both 401/403)\n    case 53:\n      return 409; // Service_Conflict\n    case 60:\n      return 500; // Service_InternalServerError\n    default:\n      return 500; // Pass through other codes as 500 for safety\n  }\n}\n\n/**\n * Maps internal WebSocket protocol response codes to error names.\n */\nexport function getErrorName(wsResponseCode: number): string {\n  switch (wsResponseCode) {\n    case 0:\n      return 'OK';\n    case 50:\n      return 'BadRequest';\n    case 51:\n      return 'NotFound';\n    case 52:\n      return 'Unauthorized';\n    case 53:\n      return 'Conflict';\n    case 60:\n      return 'InternalServerError';\n    default:\n      return 'UnknownError';\n  }\n}\n\n/**\n * Creates an ErrorResponse from protocol response code.\n */\nexport function createErrorResponse(\n  wsResponseCode: number,\n  messageId: bigint,\n  method: string,\n  path: string,\n  message: string | null = null\n): ErrorResponse {\n  return {\n    responseCode: mapToHttpStatusCode(wsResponseCode),\n    errorName: getErrorName(wsResponseCode),\n    message,\n    messageId,\n    method,\n    path,\n  };\n}\n\n/**\n * Represents the result of an API call, containing either a success response or error details.\n * @typeParam T - The expected response type on success.\n */\nexport class ApiResponse<T> {\n  /**\n   * Whether the API call was successful.\n   */\n  readonly isSuccess: boolean;\n\n  /**\n   * The successful response data. Only valid when isSuccess is true.\n   */\n  readonly result?: T;\n\n  /**\n   * Error details when the request failed. Only valid when isSuccess is false.\n   */\n  readonly error?: ErrorResponse;\n\n  private constructor(isSuccess: boolean, result?: T, error?: ErrorResponse) {\n    this.isSuccess = isSuccess;\n    this.result = result;\n    this.error = error;\n  }\n\n  /**\n   * Creates a successful response.\n   */\n  static success<T>(result: T): ApiResponse<T> {\n    return new ApiResponse<T>(true, result, undefined);\n  }\n\n  /**\n   * Creates a successful response with no content (empty body).\n   * Used for endpoints that return 200 OK without a response body.\n   */\n  static successEmpty<T>(): ApiResponse<T> {\n    return new ApiResponse<T>(true, undefined, undefined);\n  }\n\n  /**\n   * Creates an error response.\n   */\n  static failure<T>(error: ErrorResponse): ApiResponse<T> {\n    return new ApiResponse<T>(false, undefined, error);\n  }\n\n  /**\n   * Gets the result if successful, or throws an Error with error details.\n   * For empty success responses (200 with no body), returns undefined.\n   * Useful for test code or scenarios where exceptions are preferred over explicit error handling.\n   * @throws Error when the response is an error.\n   */\n  getResultOrThrow(): T | undefined {\n    if (this.isSuccess) {\n      return this.result;\n    }\n\n    const error = this.error;\n    throw new Error(\n      `${error?.errorName ?? 'Error'}: ${error?.message ?? 'Request failed'} ` +\n        `(code: ${error?.responseCode ?? -1})`\n    );\n  }\n}\n","/**\n * Base interface for all client events pushed from server to client.\n * All event types inherit from this interface and include:\n * - eventName: The event type identifier\n * - eventId: Unique ID for this event instance\n * - timestamp: ISO 8601 timestamp when event was created\n */\nexport interface BaseClientEvent {\n  /**\n   * The event type name (e.g., \"connect.capability_manifest\", \"game_session.player_joined\").\n   * This is used for routing events to the appropriate handlers.\n   */\n  eventName: string;\n\n  /**\n   * Unique identifier for this specific event instance.\n   * Can be used for deduplication or tracking.\n   */\n  eventId: string;\n\n  /**\n   * ISO 8601 timestamp when this event was created on the server.\n   */\n  timestamp: string;\n}\n\n/**\n * Type guard to check if an object is a BaseClientEvent.\n */\nexport function isBaseClientEvent(obj: unknown): obj is BaseClientEvent {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const event = obj as Record<string, unknown>;\n  return (\n    typeof event.eventName === 'string' &&\n    typeof event.eventId === 'string' &&\n    typeof event.timestamp === 'string'\n  );\n}\n"]}