/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/character/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create new character */
    post: operations['createCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get character by ID */
    post: operations['getCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update character */
    post: operations['updateCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Delete character (permanent removal) */
    post: operations['deleteCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** List characters with filtering */
    post: operations['listCharacters'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/get-enriched': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get character with optional related data (personality, backstory, family)
     * @description Retrieves a character with optional include flags for related data.
     *     Use this endpoint when you need aggregated character data from multiple services.
     *     Each included dataset is fetched from its respective service.
     */
    post: operations['getEnrichedCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/compress': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Compress a dead character to archive format
     * @description Compresses a dead character's data for long-term storage.
     *     Generates text summaries of personality, backstory, and relationships.
     *     After compression, detailed data can be deleted to save storage.
     *     Only works on characters with status 'dead'.
     */
    post: operations['compressCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/get-archive': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get compressed archive data for a character */
    post: operations['getCharacterArchive'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/check-references': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check reference count for cleanup eligibility
     * @description Returns the current reference count for a compressed character.
     *     Characters with refCount=0 for the grace period are eligible for deletion.
     *     References include: family relationships, past lives, historical events, memories.
     */
    post: operations['checkCharacterReferences'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/by-realm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get all characters in a realm (primary query pattern) */
    post: operations['getCharactersByRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /**
     * @description Character lifecycle status
     * @enum {string}
     */
    CharacterStatus: 'alive' | 'dead' | 'dormant';
    /** @description Request payload for creating a new character in the game world */
    CreateCharacterRequest: {
      /** @description Character name */
      name: string;
      /**
       * Format: uuid
       * @description Realm ID (foreign key to future Realm service, partition key)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Species ID (foreign key to future Species service)
       */
      speciesId: string;
      /**
       * Format: date-time
       * @description In-game birth timestamp
       */
      birthDate: string;
      /**
       * @description Initial lifecycle status for the character
       * @default alive
       */
      status: components['schemas']['CharacterStatus'];
    };
    /** @description Request payload for retrieving a single character by ID */
    GetCharacterRequest: {
      /**
       * Format: uuid
       * @description ID of the character to retrieve
       */
      characterId: string;
    };
    /** @description Request payload for updating an existing character's properties */
    UpdateCharacterRequest: {
      /**
       * Format: uuid
       * @description ID of the character to update
       */
      characterId: string;
      /** @description New name for the character */
      name?: string | null;
      /**
       * Format: uuid
       * @description Update character's species (used for species merge migrations)
       */
      speciesId?: string | null;
      /** @description New lifecycle status for the character */
      status?: components['schemas']['CharacterStatus'] | null;
      /**
       * Format: date-time
       * @description In-game death timestamp (sets status to dead)
       */
      deathDate?: string | null;
    };
    /** @description Request payload for permanently deleting a character */
    DeleteCharacterRequest: {
      /**
       * Format: uuid
       * @description ID of the character to delete
       */
      characterId: string;
    };
    /** @description Request payload for listing characters with filtering and pagination */
    ListCharactersRequest: {
      /**
       * Format: uuid
       * @description Realm to list characters from (required for efficiency)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Filter by species
       */
      speciesId?: string | null;
      /** @description Filter by status */
      status?: components['schemas']['CharacterStatus'] | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request payload for retrieving all characters within a specific realm */
    GetCharactersByRealmRequest: {
      /**
       * Format: uuid
       * @description Realm ID to query (uses partition key for efficiency)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Filter by species
       */
      speciesId?: string | null;
      /** @description Optional status filter */
      status?: components['schemas']['CharacterStatus'] | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Complete character data returned from character operations */
    CharacterResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the character
       */
      characterId: string;
      /** @description Display name of the character */
      name: string;
      /**
       * Format: uuid
       * @description Realm ID (partition key)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Species ID (foreign key to Species service)
       */
      speciesId: string;
      /**
       * Format: date-time
       * @description In-game birth timestamp
       */
      birthDate: string;
      /**
       * Format: date-time
       * @description In-game death timestamp
       */
      deathDate?: string | null;
      /** @description Current lifecycle status of the character */
      status: components['schemas']['CharacterStatus'];
      /**
       * Format: date-time
       * @description Real-world creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Real-world last update timestamp
       */
      updatedAt?: string | null;
    };
    /** @description Paginated list of characters with metadata for navigation */
    CharacterListResponse: {
      /** @description List of characters matching the query */
      characters: components['schemas']['CharacterResponse'][];
      /** @description Total number of characters matching the filter criteria */
      totalCount: number;
      /** @description Current page number (1-based) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more results after this page */
      hasNextPage?: boolean;
      /** @description Whether there are results before this page */
      hasPreviousPage?: boolean;
    };
    /** @description Event published when a character joins a realm */
    CharacterRealmJoinedEvent: {
      /** @description Unique identifier for this event instance */
      eventId: string;
      /**
       * Format: date-time
       * @description When the event occurred
       */
      timestamp: string;
      /**
       * Format: uuid
       * @description ID of the character
       */
      characterId: string;
      /**
       * Format: uuid
       * @description Realm being joined
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Previous realm (if transitioning)
       */
      previousRealmId?: string | null;
    };
    /** @description Event published when a character leaves a realm */
    CharacterRealmLeftEvent: {
      /** @description Unique identifier for this event instance */
      eventId: string;
      /**
       * Format: date-time
       * @description When the event occurred
       */
      timestamp: string;
      /**
       * Format: uuid
       * @description ID of the character
       */
      characterId: string;
      /**
       * Format: uuid
       * @description Realm being left
       */
      realmId: string;
      /** @description Reason for leaving (death, transfer, deletion) */
      reason?: string | null;
    };
    /**
     * @description Request payload for retrieving a character with optional related data.
     *     Each include flag fetches data from its respective service (zero overhead if not requested).
     */
    GetEnrichedCharacterRequest: {
      /**
       * Format: uuid
       * @description ID of the character to retrieve
       */
      characterId: string;
      /**
       * @description Include personality traits from character-personality service
       * @default false
       */
      includePersonality: boolean;
      /**
       * @description Include backstory elements from character-history service
       * @default false
       */
      includeBackstory: boolean;
      /**
       * @description Include family relationships from relationship service
       * @default false
       */
      includeFamilyTree: boolean;
      /**
       * @description Include combat preferences from character-personality service
       * @default false
       */
      includeCombatPreferences: boolean;
    };
    /**
     * @description Character data with optional enriched fields.
     *     Fields are only populated if the corresponding include flag was set in the request.
     */
    EnrichedCharacterResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the character
       */
      characterId: string;
      /** @description Display name of the character */
      name: string;
      /**
       * Format: uuid
       * @description Realm ID (partition key)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Species ID (foreign key to Species service)
       */
      speciesId: string;
      /**
       * Format: date-time
       * @description In-game birth timestamp
       */
      birthDate: string;
      /**
       * Format: date-time
       * @description In-game death timestamp
       */
      deathDate?: string | null;
      /** @description Current lifecycle status of the character */
      status: components['schemas']['CharacterStatus'];
      /**
       * Format: date-time
       * @description Real-world creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Real-world last update timestamp
       */
      updatedAt?: string | null;
      /** @description Personality traits (included if includePersonality=true) */
      personality?: components['schemas']['PersonalitySnapshot'];
      /** @description Backstory elements (included if includeBackstory=true) */
      backstory?: components['schemas']['BackstorySnapshot'];
      /** @description Family relationships (included if includeFamilyTree=true) */
      familyTree?: components['schemas']['FamilyTreeResponse'];
      /** @description Combat preferences (included if includeCombatPreferences=true) */
      combatPreferences?: components['schemas']['CombatPreferencesSnapshot'];
    };
    /** @description Snapshot of personality traits for enriched response */
    PersonalitySnapshot: {
      /** @description Trait values keyed by trait name (OPENNESS, AGREEABLENESS, etc.) */
      traits: {
        [key: string]: number;
      };
      /** @description Personality version number (increments on evolution) */
      version: number;
    };
    /** @description Snapshot of backstory for enriched response */
    BackstorySnapshot: {
      /** @description List of backstory elements */
      elements: components['schemas']['BackstoryElementSnapshot'][];
    };
    /** @description Single backstory element */
    BackstoryElementSnapshot: {
      /** @description Type of backstory element (ORIGIN, TRAUMA, GOAL, etc.) */
      elementType: string;
      /** @description Machine-readable key (homeland, past_job, etc.) */
      key: string;
      /** @description Machine-readable value (northlands, blacksmith, etc.) */
      value: string;
      /**
       * Format: float
       * @description How strongly this affects behavior (0.0 to 1.0)
       */
      strength: number;
    };
    /** @description Snapshot of combat preferences for enriched response */
    CombatPreferencesSnapshot: {
      /** @description Combat style (DEFENSIVE, BALANCED, AGGRESSIVE, BERSERKER, TACTICAL) */
      style: string;
      /** @description Preferred engagement distance (MELEE, CLOSE, MEDIUM, RANGED) */
      preferredRange: string;
      /** @description Role in group combat (FRONTLINE, SUPPORT, FLANKER, LEADER, SOLO) */
      groupRole: string;
      /**
       * Format: float
       * @description Willingness to take risky actions (0.0 to 1.0)
       */
      riskTolerance: number;
      /**
       * Format: float
       * @description Health percentage at which retreat is considered (0.0 to 1.0)
       */
      retreatThreshold: number;
      /** @description Whether to prioritize ally protection */
      protectAllies: boolean;
    };
    /** @description Family relationships for a character */
    FamilyTreeResponse: {
      /** @description Parent relationships (biological and adoptive) */
      parents?: components['schemas']['FamilyMember'][];
      /** @description Child relationships */
      children?: components['schemas']['FamilyMember'][];
      /** @description Sibling relationships (including half-siblings) */
      siblings?: components['schemas']['FamilyMember'][];
      /** @description Current spouse (if any) */
      spouse?: components['schemas']['FamilyMember'];
      /** @description Previous incarnations (if reincarnation tracked) */
      pastLives?: components['schemas']['PastLifeReference'][];
    };
    /** @description Reference to a family member */
    FamilyMember: {
      /**
       * Format: uuid
       * @description ID of the related character
       */
      characterId: string;
      /** @description Display name (if available) */
      name?: string | null;
      /** @description Specific relationship type (MOTHER, FATHER, SON, DAUGHTER, etc.) */
      relationshipType: string;
      /** @description Whether the related character is alive */
      isAlive?: boolean;
    };
    /** @description Reference to a past incarnation */
    PastLifeReference: {
      /**
       * Format: uuid
       * @description ID of the previous incarnation
       */
      characterId: string;
      /** @description Display name of the past life */
      name?: string | null;
      /**
       * Format: date-time
       * @description When the past life ended
       */
      deathDate?: string | null;
    };
    /** @description Request to compress a dead character for archival */
    CompressCharacterRequest: {
      /**
       * Format: uuid
       * @description ID of the dead character to compress
       */
      characterId: string;
      /**
       * @description If true, delete personality/backstory data after compression.
       *     The archive becomes the only record of this information.
       * @default false
       */
      deleteSourceData: boolean;
    };
    /** @description Request to retrieve a character's compressed archive */
    GetCharacterArchiveRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get archive for
       */
      characterId: string;
    };
    /** @description Request to check reference count for a character */
    CheckReferencesRequest: {
      /**
       * Format: uuid
       * @description ID of the character to check references for
       */
      characterId: string;
    };
    /**
     * @description Compressed archive of a dead character.
     *     Contains text summaries instead of structured data for long-term storage.
     *     Self-contained with no external references (suitable for cleanup).
     */
    CharacterArchive: {
      /**
       * Format: uuid
       * @description Original character ID
       */
      characterId: string;
      /** @description Character display name */
      name: string;
      /**
       * Format: uuid
       * @description Realm the character belonged to
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Character's species
       */
      speciesId: string;
      /**
       * Format: date-time
       * @description In-game birth date
       */
      birthDate: string;
      /**
       * Format: date-time
       * @description In-game death date
       */
      deathDate: string;
      /**
       * Format: date-time
       * @description When this archive was created
       */
      compressedAt: string;
      /**
       * @description Text summary of personality traits.
       *     Example: "Brave and loyal, somewhat hot-tempered with a strong sense of justice"
       */
      personalitySummary?: string | null;
      /**
       * @description Key backstory elements as text.
       *     Example: ["Trained by the Knights Guild", "Born in the Northlands"]
       */
      keyBackstoryPoints?: string[];
      /**
       * @description Significant life events as text.
       *     Example: ["Fought in the Battle of Stormgate (Hero)", "Survived the Great Flood"]
       */
      majorLifeEvents?: string[];
      /**
       * @description Text summary of family relationships.
       *     Example: "Father of 3, married to Elena, orphaned at young age"
       */
      familySummary?: string | null;
    };
    /** @description Reference count information for cleanup eligibility */
    CharacterRefCount: {
      /**
       * Format: uuid
       * @description Character ID
       */
      characterId: string;
      /** @description Number of active references to this character */
      referenceCount: number;
      /** @description Types of references found (FAMILY, PAST_LIFE, HISTORY, MEMORY) */
      referenceTypes?: string[];
      /** @description Whether the character has been compressed */
      isCompressed?: boolean;
      /**
       * @description True if compressed, refCount=0, and grace period has passed.
       *     Safe to permanently delete if true.
       */
      isEligibleForCleanup: boolean;
      /**
       * Format: date-time
       * @description When refCount first reached zero (null if refCount > 0)
       */
      zeroRefSince?: string | null;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  createCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateCharacterRequest'];
      };
    };
    responses: {
      /** @description Character created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterResponse'];
        };
      };
      /** @description Invalid character data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Character already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCharacterRequest'];
      };
    };
    responses: {
      /** @description Character retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterResponse'];
        };
      };
      /** @description Character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateCharacterRequest'];
      };
    };
    responses: {
      /** @description Character updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterResponse'];
        };
      };
      /** @description Invalid update data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteCharacterRequest'];
      };
    };
    responses: {
      /** @description Character deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listCharacters: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListCharactersRequest'];
      };
    };
    responses: {
      /** @description Characters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterListResponse'];
        };
      };
    };
  };
  getEnrichedCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEnrichedCharacterRequest'];
      };
    };
    responses: {
      /** @description Character retrieved with requested includes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EnrichedCharacterResponse'];
        };
      };
      /** @description Character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  compressCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CompressCharacterRequest'];
      };
    };
    responses: {
      /** @description Character compressed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterArchive'];
        };
      };
      /** @description Character is not dead (cannot compress alive characters) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCharacterArchive: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCharacterArchiveRequest'];
      };
    };
    responses: {
      /** @description Archive retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterArchive'];
        };
      };
      /** @description Archive not found (character may not be compressed yet) */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  checkCharacterReferences: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckReferencesRequest'];
      };
    };
    responses: {
      /** @description Reference count retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterRefCount'];
        };
      };
      /** @description Character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCharactersByRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCharactersByRealmRequest'];
      };
    };
    responses: {
      /** @description Characters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterListResponse'];
        };
      };
    };
  };
}
