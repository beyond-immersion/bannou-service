/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/sessions/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List available game sessions
     * @description List available game sessions. This endpoint is not directly accessible via WebSocket API.
     *     Access is granted through session shortcuts or internal service calls.
     */
    post: operations['listGameSessions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create new game session
     * @description Create a new game session. This endpoint is not directly accessible via WebSocket API.
     *     Access is granted through session shortcuts or internal service calls.
     */
    post: operations['createGameSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get game session details
     * @description Get details of the current game session the user has joined.
     */
    post: operations['getGameSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/join': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Join a game session
     * @description Join an existing game session. This endpoint is not directly accessible via WebSocket API.
     *     Access is granted through session shortcuts published by the game-session service when
     *     a subscribed user connects. The shortcut contains a pre-bound JoinGameSessionRequest
     *     with the target session ID already filled in.
     */
    post: operations['joinGameSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/leave': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Leave a game session */
    post: operations['leaveGameSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/kick': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Kick player from game session (admin only) */
    post: operations['kickPlayer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/chat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Send chat message to game session */
    post: operations['sendChatMessage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/actions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Perform game action (enhanced permissions after joining) */
    post: operations['performGameAction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/join-session': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Join a specific game session by ID
     * @description Join a game session by its session ID. Used for matchmade games where the session
     *     is pre-created by the matchmaking service and the player has a reservation.
     *     For matchmade sessions, a valid reservation token is required.
     *     For lobby sessions, this allows joining by ID without going through gameType lookup.
     */
    post: operations['joinGameSessionById'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/leave-session': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Leave a specific game session by ID
     * @description Leave a game session by its session ID. This is the session-specific alternative
     *     to /sessions/leave which uses gameType. Useful for matchmade sessions.
     */
    post: operations['leaveGameSessionById'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/publish-join-shortcut': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Publish join shortcut for matchmade session
     * @description Internal endpoint for the matchmaking service to trigger shortcut publishing
     *     to a specific player for a matchmade session. The shortcut allows the player
     *     to join the session with their reservation token pre-bound.
     */
    post: operations['publishJoinShortcut'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Request to list available game sessions */
    ListGameSessionsRequest: {
      /**
       * @description Filter by game type
       * @enum {string}
       */
      gameType?: 'arcadia' | 'generic';
      /**
       * @description Filter by session status
       * @enum {string}
       */
      status?: 'waiting' | 'active' | 'full';
    };
    /** @description Request to get a specific game session */
    GetGameSessionRequest: {
      /**
       * Format: uuid
       * @description ID of the game session to retrieve
       */
      sessionId: string;
    };
    /** @description Request to leave a game session */
    LeaveGameSessionRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the client leaving. Provided by shortcut system.
       */
      sessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player leaving. Provided by shortcut system.
       */
      accountId: string;
      /** @description Game type being left. Determines which lobby to leave. Provided by shortcut system. */
      gameType: string;
    };
    /** @description Request to create a new game session with specified settings */
    CreateGameSessionRequest: {
      /**
       * @description Type of game for this session (arcadia or generic)
       * @enum {string}
       */
      gameType: 'arcadia' | 'generic';
      /** @description Maximum number of players allowed in the session */
      maxPlayers: number;
      /** @description Optional display name for the session */
      sessionName?: string | null;
      /**
       * @description Whether the session requires a password to join
       * @default false
       */
      isPrivate: boolean;
      /**
       * Format: uuid
       * @description Account ID of the session owner. If not provided, defaults to caller's account.
       */
      ownerId?: string;
      /** @description Game-specific configuration settings (null to use defaults) */
      gameSettings?: {
        [key: string]: unknown;
      } | null;
      /** @description Type of session - lobby (persistent) or matchmade (time-limited with reservations). Defaults to lobby. */
      sessionType?: components['schemas']['SessionType'];
      /** @description For matchmade sessions - list of account IDs expected to join. Reservations created for each. */
      expectedPlayers?: string[] | null;
      /**
       * @description For matchmade sessions - how long reservations last before expiring (seconds)
       * @default 60
       */
      reservationTtlSeconds: number;
    };
    /** @description Complete details of a game session including players and settings */
    GameSessionResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the game session
       */
      sessionId: string;
      /**
       * @description Type of game for this session
       * @enum {string}
       */
      gameType: 'arcadia' | 'generic';
      /** @description Type of session - lobby or matchmade */
      sessionType: components['schemas']['SessionType'];
      /** @description Display name for the session */
      sessionName?: string | null;
      /**
       * @description Current status of the game session
       * @enum {string}
       */
      status: 'waiting' | 'active' | 'full' | 'finished';
      /** @description Maximum number of players allowed in the session */
      maxPlayers?: number;
      /** @description Current number of players in the session */
      currentPlayers?: number;
      /** @description Whether the session requires a password to join */
      isPrivate?: boolean;
      /**
       * Format: uuid
       * @description Account ID of the session owner
       */
      owner?: string;
      /** @description List of players currently in the session */
      players?: components['schemas']['GamePlayer'][];
      /**
       * Format: date-time
       * @description Timestamp when the session was created
       */
      createdAt: string;
      /** @description Game-specific configuration settings */
      gameSettings?: {
        [key: string]: unknown;
      } | null;
      /** @description For matchmade sessions - reservation tokens for expected players */
      reservations?: components['schemas']['ReservationInfo'][] | null;
      /**
       * Format: date-time
       * @description For matchmade sessions - when reservations expire
       */
      reservationExpiresAt?: string | null;
    };
    /** @description Response containing a list of game sessions matching filter criteria */
    GameSessionListResponse: {
      /** @description List of game sessions matching the filter criteria */
      sessions: components['schemas']['GameSessionResponse'][];
      /** @description Total number of sessions matching the filter (for pagination) */
      totalCount?: number;
    };
    /** @description Request to join an existing game session as a player */
    JoinGameSessionRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the client joining. Provided by shortcut system. Used for event delivery.
       */
      sessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player joining. Provided by shortcut system.
       */
      accountId: string;
      /** @description Game type to join (e.g., 'arcadia', 'generic'). Determines which lobby to join. Provided by shortcut system. */
      gameType: string;
      /** @description Password for private sessions (null for public sessions) */
      password?: string | null;
      /** @description Game-specific character data (null if no character data) */
      characterData?: {
        [key: string]: unknown;
      } | null;
      /** @description Client's SIP endpoint for voice communication (null if not using voice) */
      voiceEndpoint?: components['schemas']['VoiceSipEndpoint'];
    };
    /** @description Response after successfully joining a game session with role and permissions */
    JoinGameSessionResponse: {
      /**
       * Format: uuid
       * @description ID of the joined game session
       */
      sessionId: string;
      /**
       * @description Role assigned to the player in this session
       * @enum {string}
       */
      playerRole: 'player' | 'spectator' | 'moderator';
      /** @description Initial game state data */
      gameData?: {
        [key: string]: unknown;
      };
      /** @description Additional permissions granted by joining */
      newPermissions?: string[];
      /** @description Voice connection info (if voice is enabled for this session) */
      voice?: components['schemas']['VoiceConnectionInfo'];
    };
    /** @description Information about a player currently participating in a game session */
    GamePlayer: {
      /**
       * Format: uuid
       * @description Unique identifier for the player's account
       */
      accountId: string;
      /** @description WebSocket session ID that joined the game. Chat and events are delivered to this specific session only. */
      sessionId: string;
      /** @description Display name shown to other players */
      displayName?: string | null;
      /**
       * @description Role of the player in the game session
       * @enum {string}
       */
      role: 'player' | 'spectator' | 'moderator';
      /**
       * Format: date-time
       * @description Timestamp when the player joined the session
       */
      joinedAt: string;
      /** @description Game-specific character data for this player (null if none provided) */
      characterData?: {
        [key: string]: unknown;
      } | null;
      /** @description Voice participant session ID (if player has joined voice) */
      voiceSessionId?: string | null;
    };
    /** @description Request to remove a player from a game session (admin only) */
    KickPlayerRequest: {
      /**
       * Format: uuid
       * @description ID of the game session
       */
      sessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player to kick
       */
      targetAccountId: string;
      /** @description Reason for kicking the player */
      reason?: string | null;
    };
    /** @description Request to send a chat message to players in a game session */
    ChatMessageRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the sender. Provided by shortcut system.
       */
      sessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the sender. Provided by shortcut system.
       */
      accountId: string;
      /** @description Game type for the chat. Determines which lobby's players receive the message. Provided by shortcut system. */
      gameType: string;
      /** @description Content of the chat message */
      message: string;
      /**
       * @description Type of message (public to all, whisper to one player, or system announcement)
       * @default public
       * @enum {string}
       */
      messageType: 'public' | 'whisper' | 'system';
      /**
       * Format: uuid
       * @description For whisper messages
       */
      targetPlayerId?: string | null;
    };
    /** @description Request to perform a game action such as movement or combat */
    GameActionRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the client. Provided by shortcut system.
       */
      sessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player. Provided by shortcut system.
       */
      accountId: string;
      /** @description Game type for the action. Determines which lobby to apply the action. Provided by shortcut system. */
      gameType: string;
      /**
       * @description Type of game action to perform
       * @enum {string}
       */
      actionType: 'move' | 'interact' | 'attack' | 'cast_spell' | 'use_item';
      /** @description Action-specific data */
      actionData?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: uuid
       * @description Target of the action (if applicable)
       */
      targetId?: string | null;
    };
    /** @description Response indicating the result of a game action with any state changes */
    GameActionResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for this action instance
       */
      actionId: string;
      /** @description Action result data */
      result?: {
        [key: string]: unknown;
      } | null;
      /** @description Updated game state (if applicable) */
      newGameState?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Client's SIP/WebRTC endpoint for voice communication */
    VoiceSipEndpoint: {
      /** @description SDP offer for WebRTC negotiation */
      sdpOffer: string;
      /** @description ICE candidates for NAT traversal */
      iceCandidates?: string[] | null;
    };
    /**
     * @description Minimal voice metadata returned when joining a session.
     *
     *     **Event-Only Pattern**: Peer connection details are NOT included here.
     *     Clients receive VoicePeerJoinedEvent when other peers join (with their SDP offers).
     *     This avoids race conditions between response processing and event handling.
     */
    VoiceConnectionInfo: {
      /** @description Whether voice is enabled for this game session */
      voiceEnabled: boolean;
      /**
       * Format: uuid
       * @description Voice room ID (null until room is created when 2+ participants join with voice)
       */
      roomId?: string | null;
      /**
       * @description Expected voice tier (may change based on participant count)
       * @enum {string|null}
       */
      tier?: 'p2p' | 'scaled' | null;
      /**
       * @description Audio codec to use
       * @enum {string|null}
       */
      codec?: 'opus' | 'g711' | 'g722' | null;
      /** @description STUN server URIs for NAT traversal (clients should configure these early) */
      stunServers?: string[] | null;
    };
    /**
     * @description Type of game session - determines join behavior
     * @enum {string}
     */
    SessionType: 'lobby' | 'matchmade';
    /** @description Reservation token returned when creating a matchmade session */
    ReservationInfo: {
      /**
       * Format: uuid
       * @description Account ID this reservation is for
       */
      accountId: string;
      /** @description Token to claim this reservation */
      token: string;
      /**
       * Format: date-time
       * @description When this reservation expires
       */
      expiresAt: string;
    };
    /** @description Request to join a specific game session by ID (for matchmade sessions) */
    JoinGameSessionByIdRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the client joining. Used for event delivery.
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player joining.
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the game session to join.
       */
      gameSessionId: string;
      /** @description Token proving reservation (required for matchmade sessions) */
      reservationToken?: string | null;
      /** @description Game-specific character data (null if no character data) */
      characterData?: {
        [key: string]: unknown;
      } | null;
      /** @description Client's SIP endpoint for voice communication (null if not using voice) */
      voiceEndpoint?: components['schemas']['VoiceSipEndpoint'];
    };
    /** @description Request to publish a join shortcut for a matchmade session to a player */
    PublishJoinShortcutRequest: {
      /** @description WebSocket session ID to receive the shortcut */
      targetWebSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the game session to join
       */
      gameSessionId: string;
      /** @description Token for this player's reservation */
      reservationToken: string;
    };
    /** @description Response after publishing a join shortcut */
    PublishJoinShortcutResponse: {
      /** @description Whether the shortcut was published successfully */
      success: boolean;
      /**
       * Format: uuid
       * @description The route GUID for the published shortcut (null if failed)
       */
      shortcutRouteGuid?: string | null;
    };
    /** @description Request to leave a specific game session by ID */
    LeaveGameSessionByIdRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the client leaving.
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player leaving.
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the game session to leave.
       */
      gameSessionId: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  listGameSessions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListGameSessionsRequest'];
      };
    };
    responses: {
      /** @description Game sessions retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GameSessionListResponse'];
        };
      };
    };
  };
  createGameSession: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateGameSessionRequest'];
      };
    };
    responses: {
      /** @description Game session created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GameSessionResponse'];
        };
      };
    };
  };
  getGameSession: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetGameSessionRequest'];
      };
    };
    responses: {
      /** @description Game session retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GameSessionResponse'];
        };
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  joinGameSession: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['JoinGameSessionRequest'];
      };
    };
    responses: {
      /** @description Successfully joined game session */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['JoinGameSessionResponse'];
        };
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Session full or already joined */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  leaveGameSession: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveGameSessionRequest'];
      };
    };
    responses: {
      /** @description Successfully left game session */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  kickPlayer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KickPlayerRequest'];
      };
    };
    responses: {
      /** @description Player kicked successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to kick players */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session or player not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  sendChatMessage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ChatMessageRequest'];
      };
    };
    responses: {
      /** @description Chat message sent successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  performGameAction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GameActionRequest'];
      };
    };
    responses: {
      /** @description Game action performed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GameActionResponse'];
        };
      };
      /** @description Invalid game action */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  joinGameSessionById: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['JoinGameSessionByIdRequest'];
      };
    };
    responses: {
      /** @description Successfully joined game session */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['JoinGameSessionResponse'];
        };
      };
      /** @description Invalid or missing reservation token for matchmade session */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Session full, reservation expired, or already joined */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  leaveGameSessionById: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveGameSessionByIdRequest'];
      };
    };
    responses: {
      /** @description Successfully left game session */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found or player not in session */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  publishJoinShortcut: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PublishJoinShortcutRequest'];
      };
    };
    responses: {
      /** @description Shortcut published successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PublishJoinShortcutResponse'];
        };
      };
      /** @description Invalid reservation token */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session or WebSocket session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
