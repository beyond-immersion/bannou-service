/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/matchmaking/queue/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List available matchmaking queues
     * @description List all available matchmaking queues that players can join.
     *     Returns queue configuration details including skill settings.
     */
    post: operations['listQueues'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/queue/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get queue details
     * @description Get detailed configuration for a specific matchmaking queue.
     */
    post: operations['getQueue'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/queue/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new matchmaking queue
     * @description Create a new matchmaking queue with specified configuration.
     *     Admin only. Queue configuration includes skill settings, party limits,
     *     and exclusive group membership.
     */
    post: operations['createQueue'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/queue/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a matchmaking queue
     * @description Update configuration of an existing matchmaking queue.
     *     Admin only. Changes take effect for new tickets only.
     */
    post: operations['updateQueue'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/queue/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a matchmaking queue
     * @description Delete a matchmaking queue. Admin only.
     *     Existing tickets in the queue will be cancelled with reason 'queue_disabled'.
     */
    post: operations['deleteQueue'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/join': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Join matchmaking queue
     * @description Join a matchmaking queue with specified properties and query.
     *     Creates a matchmaking ticket and begins searching for compatible players.
     *     Returns immediately after ticket creation. Match results are delivered
     *     via WebSocket push events.
     */
    post: operations['joinMatchmaking'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/leave': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Leave matchmaking queue
     * @description Leave a matchmaking queue and cancel the ticket.
     *     Only available when actively in a queue (shortcut/prebound).
     */
    post: operations['leaveMatchmaking'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get matchmaking status
     * @description Get current matchmaking status for the player's active ticket.
     *     Only available when actively in a queue (shortcut/prebound).
     */
    post: operations['getMatchmakingStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/accept': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Accept a formed match
     * @description Accept a match that has been formed. Only available when a match
     *     is pending acceptance (shortcut/prebound after match formation).
     *     All players must accept within the timeout for the match to start.
     */
    post: operations['acceptMatch'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/decline': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Decline a formed match
     * @description Decline a match that has been formed. Only available when a match
     *     is pending acceptance (shortcut/prebound after match formation).
     *     Declining cancels the match for all participants.
     */
    post: operations['declineMatch'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/stats': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get queue statistics
     * @description Get operational statistics for matchmaking queues.
     *     Includes queue depths, average wait times, and match rates.
     */
    post: operations['getMatchmakingStats'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Request to list available matchmaking queues */
    ListQueuesRequest: {
      /** @description Filter by game ID (null for all games) */
      gameId?: string | null;
      /**
       * @description Include disabled queues in the list (admin only)
       * @default false
       */
      includeDisabled: boolean;
    };
    /** @description Response containing available matchmaking queues */
    ListQueuesResponse: {
      /** @description List of available queues */
      queues: components['schemas']['QueueSummary'][];
    };
    /** @description Summary information about a matchmaking queue */
    QueueSummary: {
      /** @description Unique identifier for the queue */
      queueId: string;
      /** @description Game this queue is for */
      gameId: string;
      /** @description Human-readable queue name */
      displayName: string;
      /** @description Whether the queue is currently accepting tickets */
      enabled: boolean;
      /** @description Minimum players required for a match */
      minCount: number;
      /** @description Maximum players in a match */
      maxCount: number;
      /** @description Current number of tickets in queue (if available) */
      currentTickets?: number | null;
      /** @description Average wait time in seconds (if available) */
      averageWaitSeconds?: number | null;
    };
    /** @description Request to get details of a specific queue */
    GetQueueRequest: {
      /** @description ID of the queue to retrieve */
      queueId: string;
    };
    /** @description Full configuration details of a matchmaking queue */
    QueueResponse: {
      /** @description Unique identifier for the queue */
      queueId: string;
      /** @description Game this queue is for */
      gameId: string;
      /** @description Game type for created sessions (maps to game-session service) */
      sessionGameType?: components['schemas']['SessionGameType'];
      /** @description Human-readable queue name */
      displayName: string;
      /** @description Detailed description of the queue */
      description?: string | null;
      /** @description Whether the queue is currently accepting tickets */
      enabled: boolean;
      /** @description Minimum players required for a match */
      minCount: number;
      /** @description Maximum players in a match */
      maxCount: number;
      /** @description Player count must be divisible by this (e.g., 2 for pairs) */
      countMultiple: number;
      /** @description Seconds between match processing intervals */
      intervalSeconds: number;
      /** @description Maximum intervals before relaxing to minCount */
      maxIntervals: number;
      /** @description Skill window expansion steps */
      skillExpansion?: components['schemas']['SkillExpansionStep'][] | null;
      /** @description How to calculate party skill rating */
      partySkillAggregation?: components['schemas']['PartySkillAggregation'];
      /** @description Weights for weighted party skill aggregation */
      partySkillWeights?: number[] | null;
      /** @description Maximum party size for this queue */
      partyMaxSize?: number | null;
      /**
       * @description Whether players can be in multiple queues
       * @default true
       */
      allowConcurrent: boolean;
      /** @description Exclusive group name (player can only be in one queue of the group) */
      exclusiveGroup?: string | null;
      /**
       * @description Whether to use lib-analytics skill rating for matching
       * @default true
       */
      useSkillRating: boolean;
      /** @description lib-analytics rating category to use */
      ratingCategory?: string | null;
      /**
       * @description Start match with minCount after maxIntervals (for large lobbies)
       * @default false
       */
      startWhenMinimumReached: boolean;
      /**
       * @description Whether players must be registered for a tournament
       * @default false
       */
      requiresRegistration: boolean;
      /**
       * @description Whether a tournament ID is required to join
       * @default false
       */
      tournamentIdRequired: boolean;
      /**
       * @description Seconds players have to accept/decline a formed match
       * @default 30
       */
      matchAcceptTimeoutSeconds: number;
      /**
       * Format: date-time
       * @description When the queue was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the queue was last updated
       */
      updatedAt?: string | null;
    };
    /** @description Request to create a new matchmaking queue */
    CreateQueueRequest: {
      /** @description Unique identifier for the queue (lowercase alphanumeric with hyphens) */
      queueId: string;
      /** @description Game this queue is for */
      gameId: string;
      /** @description Game type for created sessions (maps to game-session service) */
      sessionGameType?: components['schemas']['SessionGameType'];
      /** @description Human-readable queue name */
      displayName: string;
      /** @description Detailed description of the queue */
      description?: string | null;
      /** @description Minimum players required for a match */
      minCount: number;
      /** @description Maximum players in a match */
      maxCount: number;
      /**
       * @description Player count must be divisible by this
       * @default 1
       */
      countMultiple: number;
      /**
       * @description Seconds between match processing intervals
       * @default 15
       */
      intervalSeconds: number;
      /**
       * @description Maximum intervals before relaxing to minCount
       * @default 6
       */
      maxIntervals: number;
      /** @description Skill window expansion steps */
      skillExpansion?: components['schemas']['SkillExpansionStep'][] | null;
      /** @description How to calculate party skill rating */
      partySkillAggregation?: components['schemas']['PartySkillAggregation'];
      /** @description Weights for weighted party skill aggregation */
      partySkillWeights?: number[] | null;
      /** @description Maximum party size for this queue */
      partyMaxSize?: number | null;
      /**
       * @description Whether players can be in multiple queues
       * @default true
       */
      allowConcurrent: boolean;
      /** @description Exclusive group name */
      exclusiveGroup?: string | null;
      /**
       * @description Whether to use lib-analytics skill rating
       * @default true
       */
      useSkillRating: boolean;
      /** @description lib-analytics rating category to use */
      ratingCategory?: string | null;
      /**
       * @description Start match with minCount after maxIntervals
       * @default false
       */
      startWhenMinimumReached: boolean;
      /**
       * @description Require tournament registration
       * @default false
       */
      requiresRegistration: boolean;
      /**
       * @description Require tournament ID to join
       * @default false
       */
      tournamentIdRequired: boolean;
      /**
       * @description Seconds to accept/decline a match
       * @default 30
       */
      matchAcceptTimeoutSeconds: number;
    };
    /** @description Request to update a matchmaking queue */
    UpdateQueueRequest: {
      /** @description ID of the queue to update */
      queueId: string;
      /** @description New display name */
      displayName?: string | null;
      /** @description New description */
      description?: string | null;
      /** @description Enable or disable the queue */
      enabled?: boolean | null;
      /** @description New minimum count */
      minCount?: number | null;
      /** @description New maximum count */
      maxCount?: number | null;
      /** @description New count multiple */
      countMultiple?: number | null;
      /** @description New interval seconds */
      intervalSeconds?: number | null;
      /** @description New max intervals */
      maxIntervals?: number | null;
      /** @description New skill expansion steps */
      skillExpansion?: components['schemas']['SkillExpansionStep'][] | null;
      /** @description New party skill aggregation method */
      partySkillAggregation?: components['schemas']['PartySkillAggregation'];
      /** @description New party max size */
      partyMaxSize?: number | null;
      /** @description New match accept timeout */
      matchAcceptTimeoutSeconds?: number | null;
    };
    /** @description Request to delete a matchmaking queue */
    DeleteQueueRequest: {
      /** @description ID of the queue to delete */
      queueId: string;
    };
    /** @description A step in the skill window expansion curve */
    SkillExpansionStep: {
      /** @description Number of intervals after which this step applies */
      intervals: number;
      /** @description Skill range (null means any skill level) */
      range?: number | null;
    };
    /**
     * @description Method for aggregating party member skills
     * @enum {string}
     */
    PartySkillAggregation: 'highest' | 'average' | 'weighted';
    /**
     * @description Game type for created sessions (maps to game-session service GameType)
     * @default generic
     * @enum {string}
     */
    SessionGameType: 'generic' | 'arcadia';
    /** @description Request to join a matchmaking queue */
    JoinMatchmakingRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID for event delivery
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player joining
       */
      accountId: string;
      /** @description ID of the queue to join */
      queueId: string;
      /**
       * Format: uuid
       * @description Party ID if joining as part of a party
       */
      partyId?: string | null;
      /** @description Party member information (required if partyId provided) */
      partyMembers?: components['schemas']['PartyMemberInfo'][] | null;
      /** @description String properties for query matching */
      stringProperties?: {
        [key: string]: string;
      } | null;
      /** @description Numeric properties for query matching */
      numericProperties?: {
        [key: string]: number;
      } | null;
      /** @description Lucene-like query for opponent matching */
      query?: string | null;
      /**
       * Format: uuid
       * @description Tournament ID if joining tournament queue
       */
      tournamentId?: string | null;
    };
    /** @description Information about a party member for matchmaking */
    PartyMemberInfo: {
      /**
       * Format: uuid
       * @description Account ID of the party member
       */
      accountId: string;
      /**
       * Format: uuid
       * @description WebSocket session ID for event delivery
       */
      webSocketSessionId: string;
      /** @description Pre-fetched skill rating (optional, will be looked up if not provided) */
      skillRating?: number | null;
    };
    /** @description Response after joining a matchmaking queue */
    JoinMatchmakingResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for this matchmaking ticket
       */
      ticketId: string;
      /** @description Queue that was joined */
      queueId: string;
      /** @description Estimated wait time based on current queue (null if unknown) */
      estimatedWaitSeconds: number | null;
      /** @description Approximate position in queue (null if not tracked) */
      position?: number | null;
    };
    /** @description Request to leave a matchmaking queue */
    LeaveMatchmakingRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the ticket to cancel
       */
      ticketId: string;
    };
    /** @description Request to get matchmaking status */
    GetMatchmakingStatusRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the ticket to query
       */
      ticketId: string;
    };
    /** @description Current matchmaking status for a ticket */
    MatchmakingStatusResponse: {
      /**
       * Format: uuid
       * @description Ticket identifier
       */
      ticketId: string;
      /** @description Queue the ticket is in */
      queueId: string;
      /** @description Current ticket status */
      status: components['schemas']['TicketStatus'];
      /** @description Number of processing intervals elapsed */
      intervalsElapsed: number;
      /** @description Current skill matching range (null if skill not used) */
      currentSkillRange?: number | null;
      /** @description Updated estimated wait time */
      estimatedWaitSeconds?: number | null;
      /**
       * Format: date-time
       * @description When the ticket was created
       */
      createdAt: string;
      /**
       * Format: uuid
       * @description Match ID if a match has been found
       */
      matchId?: string | null;
    };
    /**
     * @description Current status of a matchmaking ticket
     * @enum {string}
     */
    TicketStatus: 'searching' | 'match_found' | 'match_accepted' | 'cancelled' | 'expired';
    /** @description Request to accept a formed match */
    AcceptMatchRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the match to accept
       */
      matchId: string;
    };
    /** @description Response after accepting a match */
    AcceptMatchResponse: {
      /**
       * Format: uuid
       * @description Match identifier
       */
      matchId: string;
      /** @description Whether all players have accepted */
      allAccepted: boolean;
      /** @description Number of players who have accepted */
      acceptedCount?: number | null;
      /** @description Total players who need to accept */
      totalCount?: number | null;
      /**
       * Format: uuid
       * @description Game session ID (set when all players accept)
       */
      gameSessionId?: string | null;
    };
    /** @description Request to decline a formed match */
    DeclineMatchRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the match to decline
       */
      matchId: string;
    };
    /** @description Request to get matchmaking statistics */
    GetMatchmakingStatsRequest: {
      /** @description Filter by specific queue (null for all queues) */
      queueId?: string | null;
      /** @description Filter by game ID */
      gameId?: string | null;
    };
    /** @description Matchmaking operational statistics */
    MatchmakingStatsResponse: {
      /**
       * Format: date-time
       * @description When these stats were collected
       */
      timestamp: string;
      /** @description Statistics per queue */
      queueStats: components['schemas']['QueueStats'][];
    };
    /** @description Statistics for a single matchmaking queue */
    QueueStats: {
      /** @description Queue identifier */
      queueId: string;
      /** @description Number of active tickets */
      currentTickets: number;
      /** @description Matches formed in the last hour */
      matchesFormedLastHour: number;
      /** @description Average wait time in seconds */
      averageWaitSeconds: number;
      /** @description Median wait time in seconds */
      medianWaitSeconds?: number | null;
      /** @description Percentage of tickets that timed out */
      timeoutRatePercent?: number | null;
      /** @description Percentage of tickets cancelled by user */
      cancelRatePercent?: number | null;
    };
    /**
     * @description Reason codes for matchmaking cancellation
     * @enum {string}
     */
    CancelReason:
      | 'cancelled_by_user'
      | 'timeout'
      | 'session_disconnected'
      | 'party_disbanded'
      | 'match_declined'
      | 'queue_disabled';
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  listQueues: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListQueuesRequest'];
      };
    };
    responses: {
      /** @description Queues retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListQueuesResponse'];
        };
      };
    };
  };
  getQueue: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetQueueRequest'];
      };
    };
    responses: {
      /** @description Queue details retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueueResponse'];
        };
      };
      /** @description Queue not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createQueue: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateQueueRequest'];
      };
    };
    responses: {
      /** @description Queue created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueueResponse'];
        };
      };
      /** @description Queue with this ID already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateQueue: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateQueueRequest'];
      };
    };
    responses: {
      /** @description Queue updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueueResponse'];
        };
      };
      /** @description Queue not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteQueue: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteQueueRequest'];
      };
    };
    responses: {
      /** @description Queue deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Queue not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  joinMatchmaking: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['JoinMatchmakingRequest'];
      };
    };
    responses: {
      /** @description Successfully joined matchmaking queue */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['JoinMatchmakingResponse'];
        };
      };
      /** @description Invalid query syntax or properties */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Already in queue, queue limit reached, or exclusive group conflict */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  leaveMatchmaking: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveMatchmakingRequest'];
      };
    };
    responses: {
      /** @description Successfully left matchmaking queue */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Ticket not found or not in queue */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getMatchmakingStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetMatchmakingStatusRequest'];
      };
    };
    responses: {
      /** @description Status retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MatchmakingStatusResponse'];
        };
      };
      /** @description No active matchmaking ticket */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  acceptMatch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AcceptMatchRequest'];
      };
    };
    responses: {
      /** @description Match acceptance recorded */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AcceptMatchResponse'];
        };
      };
      /** @description No pending match or already processed */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  declineMatch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeclineMatchRequest'];
      };
    };
    responses: {
      /** @description Match declined */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description No pending match or already processed */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getMatchmakingStats: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetMatchmakingStatsRequest'];
      };
    };
    responses: {
      /** @description Statistics retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MatchmakingStatsResponse'];
        };
      };
    };
  };
}
