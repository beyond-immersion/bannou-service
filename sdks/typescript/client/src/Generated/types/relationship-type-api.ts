/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/relationship-type/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get relationship type by ID */
    post: operations['getRelationshipType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get relationship type by code
     * @description Retrieve a relationship type using its unique code (e.g., "SON", "MOTHER", "FRIEND")
     */
    post: operations['getRelationshipTypeByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all relationship types
     * @description Retrieve all relationship types with optional hierarchy filtering
     */
    post: operations['listRelationshipTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get-children': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get child types for a parent type
     * @description Retrieve all relationship types that have the specified type as their parent
     */
    post: operations['getChildRelationshipTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/matches-hierarchy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if type matches ancestor in hierarchy
     * @description Checks if a relationship type matches or descends from an ancestor type.
     *     For example, "SON" matches "CHILD" because CHILD is an ancestor of SON.
     *     This enables queries like "find all CHILD relationships" to match SON, DAUGHTER, etc.
     */
    post: operations['matchesHierarchy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get-ancestors': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all ancestors of a relationship type
     * @description Returns the full ancestry chain from the specified type up to the root.
     *     For example, for "SON" might return ["CHILD", "FAMILY"].
     */
    post: operations['getAncestors'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create new relationship type */
    post: operations['createRelationshipType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update relationship type */
    post: operations['updateRelationshipType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete relationship type
     * @description Hard delete a relationship type. This will fail if the type is still in use.
     *     For safe removal, first deprecate the type, then merge it into another type
     *     (or VOID), then delete. Only deprecated types with zero references can be deleted.
     */
    post: operations['deleteRelationshipType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/deprecate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Deprecate a relationship type
     * @description Soft-delete a relationship type by marking it as deprecated.
     *     Deprecated types:
     *     - Remain queryable for historical data
     *     - Cannot be used for creating new relationships
     *     - Can be merged into other types using the merge endpoint
     *     - Can be hard-deleted after all references are removed
     */
    post: operations['deprecateRelationshipType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/undeprecate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Restore a deprecated relationship type
     * @description Remove the deprecated status from a relationship type, making it
     *     available for new relationships again.
     */
    post: operations['undeprecateRelationshipType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/merge': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Merge a deprecated type into another type
     * @description Migrate all relationships using a deprecated type to a target type.
     *     This is the recommended way to handle type removal:
     *     1. Deprecate the source type
     *     2. Merge into the target type (or VOID for effective deletion)
     *     3. Optionally hard-delete the now-empty deprecated type
     *
     *     The merge operation:
     *     - Updates all relationships using sourceTypeId to use targetTypeId
     *     - Publishes events for each affected relationship
     *     - Returns count of migrated relationships
     *     - Fails if source is not deprecated (safety check)
     */
    post: operations['mergeRelationshipType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/seed': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Seed relationship types from configuration
     * @description Idempotent operation to seed relationship types from provided data.
     *     Creates types that don't exist, optionally updates existing types.
     *     Typically called at service startup with YAML-defined types.
     */
    post: operations['seedRelationshipTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Request to retrieve a relationship type by its unique identifier */
    GetRelationshipTypeRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the relationship type
       */
      relationshipTypeId: string;
    };
    /** @description Request to retrieve a relationship type by its unique code string */
    GetRelationshipTypeByCodeRequest: {
      /** @description Unique code for the relationship type (e.g., "SON", "MOTHER", "FRIEND") */
      code: string;
    };
    /** @description Request to list relationship types with optional filtering by category, hierarchy, and deprecation status */
    ListRelationshipTypesRequest: {
      /** @description Filter by category (e.g., "FAMILY", "SOCIAL", "ECONOMIC") (null to include all) */
      category?: string | null;
      /**
       * @description Whether to include child types in the response
       * @default true
       */
      includeChildren: boolean;
      /**
       * @description Only return types with no parent (root types)
       * @default false
       */
      rootsOnly: boolean;
      /**
       * @description Whether to include deprecated types in the response
       * @default false
       */
      includeDeprecated: boolean;
    };
    /** @description Request to retrieve all child relationship types for a given parent type */
    GetChildRelationshipTypesRequest: {
      /**
       * Format: uuid
       * @description ID of the parent relationship type
       */
      parentTypeId: string;
      /**
       * @description Include all descendants, not just direct children
       * @default false
       */
      recursive: boolean;
    };
    /** @description Request to check if a relationship type matches or descends from an ancestor type in the hierarchy */
    MatchesHierarchyRequest: {
      /**
       * Format: uuid
       * @description The relationship type to check
       */
      typeId: string;
      /**
       * Format: uuid
       * @description The potential ancestor type
       */
      ancestorTypeId: string;
    };
    /** @description Request to retrieve all ancestor types in the hierarchy chain from a relationship type up to the root */
    GetAncestorsRequest: {
      /**
       * Format: uuid
       * @description The relationship type to get ancestors for
       */
      typeId: string;
    };
    /** @description Request to create a new relationship type with code, name, and optional hierarchy and inverse settings */
    CreateRelationshipTypeRequest: {
      /** @description Unique code for the relationship type (e.g., "SON", "MOTHER") */
      code: string;
      /** @description Display name for the relationship type */
      name: string;
      /** @description Description of the relationship type (null if not provided) */
      description?: string | null;
      /** @description Category for grouping (e.g., "FAMILY", "SOCIAL", "ECONOMIC") (null if not categorized) */
      category?: string | null;
      /**
       * Format: uuid
       * @description Parent type ID for hierarchy (null for root types)
       */
      parentTypeId?: string | null;
      /** @description Code of the inverse relationship (e.g., "PARENT" for "CHILD") */
      inverseTypeCode?: string | null;
      /**
       * @description Whether the relationship is the same in both directions (e.g., "SIBLING")
       * @default false
       */
      isBidirectional: boolean;
      /** @description Additional metadata for the relationship type */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update an existing relationship type's properties such as name, description, category, or hierarchy */
    UpdateRelationshipTypeRequest: {
      /**
       * Format: uuid
       * @description ID of the relationship type to update
       */
      relationshipTypeId: string;
      /** @description Display name for the relationship type */
      name?: string | null;
      /** @description Description of the relationship type */
      description?: string | null;
      /** @description Category for grouping */
      category?: string | null;
      /**
       * Format: uuid
       * @description Parent type ID for hierarchy
       */
      parentTypeId?: string | null;
      /** @description Code of the inverse relationship */
      inverseTypeCode?: string | null;
      /** @description Whether the relationship is bidirectional */
      isBidirectional?: boolean | null;
      /** @description Additional metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to permanently delete a relationship type (typically after deprecation and merge) */
    DeleteRelationshipTypeRequest: {
      /**
       * Format: uuid
       * @description ID of the relationship type to delete
       */
      relationshipTypeId: string;
    };
    /** @description Request to deprecate a relationship type, preventing its use for new relationships while preserving existing ones */
    DeprecateRelationshipTypeRequest: {
      /**
       * Format: uuid
       * @description ID of the relationship type to deprecate
       */
      relationshipTypeId: string;
      /** @description Optional reason for deprecation (for audit purposes) */
      reason?: string | null;
    };
    /** @description Request to restore a deprecated relationship type back to active status */
    UndeprecateRelationshipTypeRequest: {
      /**
       * Format: uuid
       * @description ID of the relationship type to restore
       */
      relationshipTypeId: string;
    };
    /** @description Request to migrate all relationships from a deprecated source type to a target type */
    MergeRelationshipTypeRequest: {
      /**
       * Format: uuid
       * @description ID of the deprecated type to merge from (must be deprecated)
       */
      sourceTypeId: string;
      /**
       * Format: uuid
       * @description ID of the type to merge into (can be VOID for effective deletion)
       */
      targetTypeId: string;
      /**
       * @description If true, hard-delete the source type after successful merge
       * @default false
       */
      deleteAfterMerge: boolean;
    };
    /** @description Request to bulk seed relationship types from configuration, typically used at startup */
    SeedRelationshipTypesRequest: {
      /** @description List of relationship types to seed */
      types: components['schemas']['SeedRelationshipType'][];
      /**
       * @description Whether to update types that already exist
       * @default false
       */
      updateExisting: boolean;
    };
    /** @description A relationship type definition used for seeding, with code-based parent and inverse references */
    SeedRelationshipType: {
      /** @description Unique code for the relationship type */
      code: string;
      /** @description Display name for the relationship type */
      name: string;
      /** @description Human-readable description of the relationship type (null if not provided) */
      description?: string | null;
      /** @description Category for grouping relationship types (null if not categorized) */
      category?: string | null;
      /** @description Code of the parent type (resolved during seeding) (null for root types) */
      parentTypeCode?: string | null;
      /** @description Code of the inverse relationship (null if not applicable) */
      inverseTypeCode?: string | null;
      /**
       * @description Whether the relationship is the same in both directions
       * @default false
       */
      isBidirectional: boolean;
      /** @description Additional custom metadata for the relationship type (null if none) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Complete representation of a relationship type including hierarchy, inverse, and deprecation information */
    RelationshipTypeResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the relationship type
       */
      relationshipTypeId: string;
      /** @description Unique code for the relationship type (e.g., "SON", "MOTHER") */
      code: string;
      /** @description Human-readable display name for the relationship type */
      name: string;
      /** @description Detailed description of the relationship type */
      description?: string | null;
      /** @description Category for grouping relationship types (e.g., "FAMILY", "SOCIAL") */
      category?: string | null;
      /**
       * Format: uuid
       * @description ID of the parent type in the hierarchy (null for root types)
       */
      parentTypeId?: string | null;
      /** @description Code of the parent type (for convenience) */
      parentTypeCode?: string | null;
      /**
       * Format: uuid
       * @description ID of the inverse relationship type (e.g., PARENT is inverse of CHILD)
       */
      inverseTypeId?: string | null;
      /** @description Code of the inverse relationship type (for convenience) */
      inverseTypeCode?: string | null;
      /** @description Whether the relationship is the same in both directions (e.g., SIBLING) */
      isBidirectional: boolean;
      /** @description Whether this type is deprecated and cannot be used for new relationships */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this type was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation */
      deprecationReason?: string | null;
      /** @description Depth in the hierarchy (0 for root types) */
      depth: number;
      /** @description Additional custom metadata for the relationship type */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Timestamp when the relationship type was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the relationship type was last updated
       */
      updatedAt: string;
    };
    /** @description Response containing a list of relationship types with total count */
    RelationshipTypeListResponse: {
      /** @description List of relationship types matching the query */
      types: components['schemas']['RelationshipTypeResponse'][];
      /** @description Total number of relationship types returned */
      totalCount: number;
    };
    /** @description Response indicating whether a type matches an ancestor in the hierarchy and the depth between them */
    MatchesHierarchyResponse: {
      /** @description True if typeId equals or descends from ancestorTypeId */
      matches: boolean;
      /** @description Number of levels between the types (0 if same, -1 if no match) */
      depth?: number;
    };
    /** @description Response summarizing the results of a bulk seed operation with counts of created, updated, and skipped types */
    SeedRelationshipTypesResponse: {
      /** @description Number of new types created */
      created: number;
      /** @description Number of existing types updated */
      updated: number;
      /** @description Number of types skipped (already exist, updateExisting=false) */
      skipped: number;
      /** @description List of error messages for types that failed to seed */
      errors: string[];
    };
    /** @description Response summarizing the results of a merge operation including the number of relationships migrated and any failures */
    MergeRelationshipTypeResponse: {
      /**
       * Format: uuid
       * @description ID of the deprecated type that was merged from
       */
      sourceTypeId: string;
      /**
       * Format: uuid
       * @description ID of the type that relationships were merged into
       */
      targetTypeId: string;
      /** @description Number of relationships successfully updated to use the target type */
      relationshipsMigrated: number;
      /** @description Number of relationships that failed to migrate */
      relationshipsFailed: number;
      /** @description Whether the source type was hard-deleted after merge */
      sourceDeleted: boolean;
      /** @description Details of individual migration failures (limited to first 100) */
      migrationErrors?: components['schemas']['MigrationError'][];
    };
    /** @description Details of a single relationship that failed to migrate */
    MigrationError: {
      /**
       * Format: uuid
       * @description ID of the relationship that failed to migrate
       */
      relationshipId: string;
      /** @description Error message explaining why the migration failed */
      error: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  getRelationshipType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipTypeRequest'];
      };
    };
    responses: {
      /** @description Relationship type retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeResponse'];
        };
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRelationshipTypeByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipTypeByCodeRequest'];
      };
    };
    responses: {
      /** @description Relationship type retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeResponse'];
        };
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRelationshipTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRelationshipTypesRequest'];
      };
    };
    responses: {
      /** @description Relationship types retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeListResponse'];
        };
      };
    };
  };
  getChildRelationshipTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetChildRelationshipTypesRequest'];
      };
    };
    responses: {
      /** @description Child relationship types retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeListResponse'];
        };
      };
      /** @description Parent relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  matchesHierarchy: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MatchesHierarchyRequest'];
      };
    };
    responses: {
      /** @description Hierarchy match result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MatchesHierarchyResponse'];
        };
      };
      /** @description One or both relationship types not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAncestors: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAncestorsRequest'];
      };
    };
    responses: {
      /** @description Ancestors retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeListResponse'];
        };
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createRelationshipType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateRelationshipTypeRequest'];
      };
    };
    responses: {
      /** @description Relationship type created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeResponse'];
        };
      };
      /** @description Invalid relationship type data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Relationship type with this code already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateRelationshipType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateRelationshipTypeRequest'];
      };
    };
    responses: {
      /** @description Relationship type updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeResponse'];
        };
      };
      /** @description Invalid update data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteRelationshipType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteRelationshipTypeRequest'];
      };
    };
    responses: {
      /** @description Relationship type deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cannot delete - type is in use by relationships or has child types */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deprecateRelationshipType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeprecateRelationshipTypeRequest'];
      };
    };
    responses: {
      /** @description Relationship type deprecated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeResponse'];
        };
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Relationship type is already deprecated */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  undeprecateRelationshipType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UndeprecateRelationshipTypeRequest'];
      };
    };
    responses: {
      /** @description Relationship type restored successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeResponse'];
        };
      };
      /** @description Relationship type is not deprecated */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  mergeRelationshipType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MergeRelationshipTypeRequest'];
      };
    };
    responses: {
      /** @description Merge completed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MergeRelationshipTypeResponse'];
        };
      };
      /** @description Source type must be deprecated before merging */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Source or target relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cannot merge into a deprecated type */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  seedRelationshipTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SeedRelationshipTypesRequest'];
      };
    };
    responses: {
      /** @description Seed operation completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedRelationshipTypesResponse'];
        };
      };
      /** @description Invalid seed data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
