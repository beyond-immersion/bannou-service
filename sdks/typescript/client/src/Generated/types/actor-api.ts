/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/actor/template/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create an actor template (category definition) */
    post: operations['CreateActorTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/template/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get an actor template by ID or category */
    post: operations['GetActorTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/template/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** List all actor templates */
    post: operations['ListActorTemplates'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/template/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update an actor template */
    post: operations['UpdateActorTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/template/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Delete an actor template */
    post: operations['DeleteActorTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/spawn': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Spawn a new actor from a template */
    post: operations['SpawnActor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get actor instance (instantiate-on-access if template allows)
     * @description If the actor exists, returns its current state.
     *     If the actor doesn't exist but a matching template has auto-spawn enabled,
     *     instantiates the actor and returns it.
     */
    post: operations['GetActor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Stop a running actor */
    post: operations['StopActor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** List actors with optional filters */
    post: operations['ListActors'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/inject-perception': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Inject a perception event into an actor's queue (testing)
     * @description Injects a perception event directly into the actor's perception queue
     *     for testing purposes. Useful for testing actor behavior without a
     *     full game server setup.
     */
    post: operations['InjectPerception'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/query-options': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query an actor for its available options
     * @description Query an actor for its available options (combat, dialogue, exploration, etc.).
     *     Options are maintained by the actor in its state and returned based on requested
     *     freshness level. This enables Event Brain actors to ask participants "what can
     *     you do?" for choreography and coordination.
     *
     *     Freshness levels:
     *     - fresh: Inject context and wait for actor to recompute options
     *     - cached: Return cached options if within maxAgeMs, else recompute
     *     - stale_ok: Return cached options regardless of age
     */
    post: operations['QueryOptions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/encounter/start': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Start an encounter managed by an Event Brain actor
     * @description Initializes an encounter with the specified participants. The Event Brain actor
     *     will coordinate the encounter, sending instructions to participant NPC Brain actors
     *     via their character perception channels.
     */
    post: operations['StartEncounter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/encounter/update-phase': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update the phase of an active encounter
     * @description Updates the phase of an encounter being managed by an Event Brain actor.
     *     Phase changes are logged and can trigger behavior changes in participant actors.
     */
    post: operations['UpdateEncounterPhase'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/encounter/end': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * End an active encounter
     * @description Ends an encounter being managed by an Event Brain actor. This clears the
     *     encounter state and allows the actor to manage a new encounter.
     */
    post: operations['EndEncounter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/encounter/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get the current encounter state for an actor
     * @description Retrieves the current encounter state for an Event Brain actor. Returns
     *     null encounter data if the actor is not managing an encounter.
     */
    post: operations['GetEncounter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Request to create a new actor template definition */
    CreateActorTemplateRequest: {
      /** @description Category identifier (e.g., "npc-brain", "world-admin", "cron-cleanup") */
      category: string;
      /** @description Reference to behavior in lib-assets (e.g., "asset://behaviors/npc-brain-v1") */
      behaviorRef: string;
      /** @description Default configuration passed to behavior execution */
      configuration?: {
        [key: string]: unknown;
      } | null;
      /** @description Auto-spawn configuration for instantiate-on-access */
      autoSpawn?: components['schemas']['AutoSpawnConfig'];
      /**
       * @description Milliseconds between behavior loop iterations
       * @default 1000
       */
      tickIntervalMs: number;
      /**
       * @description Seconds between automatic state saves (0 to disable)
       * @default 60
       */
      autoSaveIntervalSeconds: number;
      /**
       * @description Maximum actors of this category per pool node
       * @default 100
       */
      maxInstancesPerNode: number;
    };
    /** @description Configuration for instantiate-on-access behavior */
    AutoSpawnConfig: {
      /**
       * @description If true, accessing a non-existent actor creates it
       * @default false
       */
      enabled: boolean;
      /**
       * @description Regex pattern for actor IDs that trigger auto-spawn.
       *     Examples: "npc-.*" matches "npc-grok", "npc-merchant-123"
       */
      idPattern?: string | null;
      /** @description Maximum auto-spawned instances (0 = unlimited) */
      maxInstances?: number | null;
      /**
       * @description 1-based regex capture group index for extracting CharacterId from actor ID.
       *     Example: With idPattern "npc-brain-([a-f0-9-]+)" and characterIdCaptureGroup: 1,
       *     actor ID "npc-brain-abc-123-def" extracts "abc-123-def" as CharacterId (parsed as GUID).
       */
      characterIdCaptureGroup?: number | null;
    };
    /** @description Response containing actor template details */
    ActorTemplateResponse: {
      /**
       * Format: uuid
       * @description Unique template identifier
       */
      templateId: string;
      /** @description Category identifier */
      category: string;
      /** @description Reference to behavior in lib-assets */
      behaviorRef: string;
      /** @description Default configuration passed to behavior execution */
      configuration?: {
        [key: string]: unknown;
      } | null;
      /** @description Auto-spawn configuration for instantiate-on-access */
      autoSpawn?: components['schemas']['AutoSpawnConfig'];
      /** @description Milliseconds between behavior loop iterations */
      tickIntervalMs: number;
      /** @description Seconds between automatic state saves */
      autoSaveIntervalSeconds: number;
      /** @description Maximum actors of this category per pool node */
      maxInstancesPerNode: number;
      /**
       * Format: date-time
       * @description When the template was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the template was last updated
       */
      updatedAt: string;
    };
    /** @description Request to get an actor template by ID or category */
    GetActorTemplateRequest: {
      /**
       * Format: uuid
       * @description Template ID to retrieve
       */
      templateId?: string | null;
      /** @description Or retrieve by category name */
      category?: string | null;
    };
    /** @description Request to list actor templates with pagination */
    ListActorTemplatesRequest: {
      /**
       * @description Maximum number of templates to return
       * @default 100
       */
      limit: number;
      /**
       * @description Number of templates to skip
       * @default 0
       */
      offset: number;
    };
    /** @description Response containing a list of actor templates */
    ListActorTemplatesResponse: {
      /** @description List of actor templates */
      templates: components['schemas']['ActorTemplateResponse'][];
      /** @description Total number of templates available */
      total: number;
    };
    /** @description Request to update an existing actor template */
    UpdateActorTemplateRequest: {
      /**
       * Format: uuid
       * @description ID of the template to update
       */
      templateId: string;
      /** @description New behavior reference (triggers behavior.updated subscription) */
      behaviorRef?: string | null;
      /** @description Updated configuration settings */
      configuration?: {
        [key: string]: unknown;
      } | null;
      /** @description Updated auto-spawn configuration */
      autoSpawn?: components['schemas']['AutoSpawnConfig'];
      /** @description Updated tick interval in milliseconds */
      tickIntervalMs?: number | null;
      /** @description Updated auto-save interval in seconds */
      autoSaveIntervalSeconds?: number | null;
    };
    /** @description Request to delete an actor template */
    DeleteActorTemplateRequest: {
      /**
       * Format: uuid
       * @description ID of the template to delete
       */
      templateId: string;
      /**
       * @description If true, stops all running actors using this template
       * @default false
       */
      forceStopActors: boolean;
    };
    /** @description Response confirming template deletion */
    DeleteActorTemplateResponse: {
      /** @description Whether the template was successfully deleted */
      deleted: boolean;
      /** @description Number of running actors that were stopped */
      stoppedActorCount: number;
    };
    /** @description Request to spawn a new actor from a template */
    SpawnActorRequest: {
      /**
       * Format: uuid
       * @description Template to instantiate from
       */
      templateId: string;
      /** @description Optional custom actor ID (auto-generated if not provided) */
      actorId?: string | null;
      /** @description Override template defaults */
      configurationOverrides?: {
        [key: string]: unknown;
      } | null;
      /** @description Initial state passed to behavior */
      initialState?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: uuid
       * @description Optional character ID for NPC brain actors
       */
      characterId?: string | null;
    };
    /** @description Request to get an actor instance by ID */
    GetActorRequest: {
      /** @description Actor ID to retrieve */
      actorId: string;
    };
    /** @description Response containing actor instance details */
    ActorInstanceResponse: {
      /** @description Unique actor identifier */
      actorId: string;
      /**
       * Format: uuid
       * @description Template this actor was instantiated from
       */
      templateId: string;
      /** @description Actor category from template */
      category: string;
      /** @description Pool node running this actor (null in bannou mode) */
      nodeId?: string | null;
      /** @description Pool node's app-id for direct messaging */
      nodeAppId?: string | null;
      /** @description Current actor lifecycle state */
      status: components['schemas']['ActorStatus'];
      /**
       * Format: uuid
       * @description Associated character ID (for NPC brains)
       */
      characterId?: string | null;
      /**
       * Format: date-time
       * @description When the actor started running
       */
      startedAt: string;
      /**
       * Format: date-time
       * @description Last heartbeat timestamp from the actor
       */
      lastHeartbeat?: string | null;
      /**
       * Format: int64
       * @description Number of behavior loop iterations executed
       */
      loopIterations: number;
    };
    /**
     * @description Current actor lifecycle state
     * @enum {string}
     */
    ActorStatus: 'pending' | 'starting' | 'running' | 'paused' | 'stopping' | 'stopped' | 'error';
    /** @description Request to stop a running actor */
    StopActorRequest: {
      /** @description ID of the actor to stop */
      actorId: string;
      /**
       * @description If true, allows behavior to complete current iteration
       * @default true
       */
      graceful: boolean;
    };
    /** @description Response confirming actor stop operation */
    StopActorResponse: {
      /** @description Whether the actor was successfully stopped */
      stopped: boolean;
      /** @description Final status of the actor after stopping */
      finalStatus: components['schemas']['ActorStatus'];
    };
    /** @description Request to list actor instances with optional filters */
    ListActorsRequest: {
      /** @description Filter by category */
      category?: string | null;
      /** @description Filter by pool node */
      nodeId?: string | null;
      /** @description Filter by actor status */
      status?: components['schemas']['ActorStatus'];
      /**
       * Format: uuid
       * @description Filter by associated character
       */
      characterId?: string | null;
      /**
       * @description Maximum number of actors to return
       * @default 100
       */
      limit: number;
      /**
       * @description Number of actors to skip
       * @default 0
       */
      offset: number;
    };
    /** @description Response containing a list of actor instances */
    ListActorsResponse: {
      /** @description List of actor instances */
      actors: components['schemas']['ActorInstanceResponse'][];
      /** @description Total number of actors matching the filter */
      total: number;
    };
    /** @description Request to inject a perception event into an actor's queue */
    InjectPerceptionRequest: {
      /** @description Target actor to inject perception into */
      actorId: string;
      /** @description Perception data to inject */
      perception: components['schemas']['PerceptionData'];
    };
    /**
     * @description Data representing a perception event for an actor.
     *
     *     Spatial context can be provided in two ways (hybrid approach):
     *     1. Typed: Use the optional spatialContext field for structured spatial data
     *     2. Schema-less: Use perceptionType="spatial" with data containing spatial info
     *
     *     The typed approach is recommended when game server has structured spatial data.
     *     The schema-less approach allows flexibility for game-specific spatial formats.
     */
    PerceptionData: {
      /**
       * @description Perception type. Common values: visual, auditory, tactile, olfactory,
       *     proprioceptive, spatial. Use "spatial" for schema-less spatial data in 'data' field.
       */
      perceptionType: string;
      /** @description ID of the entity causing this perception */
      sourceId: string;
      /** @description Type of source (character, npc, object, environment) */
      sourceType?: string | null;
      /**
       * @description Perception-specific data. For perceptionType="spatial", this can contain
       *     game-specific spatial context in any format the game server defines.
       */
      data?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: float
       * @description How urgent this perception is (0-1)
       * @default 0.5
       */
      urgency: number;
      /**
       * @description Optional typed spatial context from game server's local spatial state.
       *     Provides structured information about terrain, nearby objects, hazards, etc.
       *     Alternative to using perceptionType="spatial" with schema-less data.
       */
      spatialContext?: components['schemas']['SpatialContext'] | null;
    };
    /**
     * @description Spatial context derived from game server's authoritative spatial state.
     *     Included in perception events to give NPC actors awareness of their environment
     *     without requiring direct map subscriptions.
     *
     *     Note: additionalProperties=true allows game-specific extensions.
     */
    SpatialContext: {
      /** @description Terrain type at character position (grass, stone, water, etc.) */
      terrainType?: string | null;
      /**
       * Format: float
       * @description Elevation at character position
       */
      elevation?: number | null;
      /** @description Objects within perception radius */
      nearbyObjects?: components['schemas']['NearbyObject'][] | null;
      /** @description Active hazards within detection range */
      hazardsInRange?: components['schemas']['HazardInfo'][] | null;
      /** @description Directions the character can move (for navigation awareness) */
      pathableDirections?: string[] | null;
      /** @description Whether cover is available within close range */
      coverNearby?: boolean | null;
      /** @description Whether character is currently indoors/under roof */
      indoors?: boolean | null;
    } & {
      [key: string]: unknown;
    };
    /** @description Information about a nearby object perceived by the character */
    NearbyObject: {
      /**
       * Format: uuid
       * @description Unique identifier of the object
       */
      objectId?: string;
      /** @description Type of object (boulder_cluster, tree, building, etc.) */
      objectType?: string;
      /**
       * Format: float
       * @description Distance from character in game units
       */
      distance?: number;
      /** @description Relative direction (north, south, east, west, above, below, etc.) */
      direction?: string;
      /** @description Optional absolute position */
      position?: components['schemas']['Position3D'] | null;
    } & {
      [key: string]: unknown;
    };
    /** @description Information about a hazard in range */
    HazardInfo: {
      /** @description Type of hazard (fire, poison, radiation, deep_water, etc.) */
      hazardType?: string;
      /**
       * Format: float
       * @description Distance to hazard edge
       */
      distance?: number;
      /**
       * Format: float
       * @description Hazard severity (0-1)
       */
      severity?: number;
      /** @description Direction to hazard center */
      direction?: string | null;
    } & {
      [key: string]: unknown;
    };
    /** @description 3D position in world coordinates */
    Position3D: {
      /**
       * Format: float
       * @description X coordinate
       */
      x: number;
      /**
       * Format: float
       * @description Y coordinate (typically vertical)
       */
      y: number;
      /**
       * Format: float
       * @description Z coordinate
       */
      z: number;
    };
    /** @description Response confirming perception injection */
    InjectPerceptionResponse: {
      /** @description Whether the perception was successfully queued */
      queued: boolean;
      /** @description Current depth of the perception queue */
      queueDepth: number;
    };
    /**
     * @description Query an actor for its available options. Options are maintained by the actor
     *     in its state.memories.{queryType}_options and returned based on requested freshness.
     */
    QueryOptionsRequest: {
      /** @description ID of the actor to query */
      actorId: string;
      /** @description Type of options to query */
      queryType: components['schemas']['OptionsQueryType'];
      /**
       * @description Requested freshness level. Defaults to 'cached'.
       *     - fresh: Inject context and wait for actor to recompute
       *     - cached: Return cached options if within maxAgeMs
       *     - stale_ok: Return whatever is cached, even if expired
       */
      freshness?: components['schemas']['OptionsFreshness'];
      /**
       * @description Maximum age of cached options in milliseconds (for 'cached' freshness).
       *     Defaults to 5000ms. If cached options are older, behavior depends on
       *     freshness level.
       */
      maxAgeMs?: number | null;
      /**
       * @description Optional context for the query. When provided with freshness='fresh',
       *     this context is injected as a perception to the actor, triggering
       *     context-sensitive option recomputation.
       */
      context?: components['schemas']['OptionsQueryContext'];
    };
    /** @description Response containing the actor's available options */
    QueryOptionsResponse: {
      /** @description ID of the queried actor */
      actorId: string;
      /** @description Type of options returned */
      queryType: components['schemas']['OptionsQueryType'];
      /** @description Available options for the queried type */
      options: components['schemas']['ActorOption'][];
      /**
       * Format: date-time
       * @description When these options were last computed by the actor
       */
      computedAt: string;
      /** @description Age of options in milliseconds (now - computedAt) */
      ageMs: number;
      /**
       * @description Character-specific context that influenced these options.
       *     Only present for character-based actors.
       */
      characterContext?: components['schemas']['CharacterOptionContext'];
    };
    /**
     * @description Type of options to query. Actors maintain options in state.memories.{type}_options.
     *     Well-known types are defined; actors can also expose custom types.
     * @enum {string}
     */
    OptionsQueryType: 'combat' | 'dialogue' | 'exploration' | 'social' | 'custom';
    /**
     * @description Controls caching behavior for options queries
     * @default cached
     * @enum {string}
     */
    OptionsFreshness: 'fresh' | 'cached' | 'stale_ok';
    /**
     * @description A single option available to the actor. The standardized fields enable
     *     Event Brain to reason about options; additional fields allow actor-specific data.
     */
    ActorOption: {
      /**
       * @description Unique identifier for this action within the option type.
       *     Examples: "sword_slash", "greet_friendly", "climb_wall"
       */
      actionId: string;
      /**
       * Format: float
       * @description How much the actor prefers this option (0-1), based on personality,
       *     combat preferences, current state, etc. Higher = more preferred.
       */
      preference: number;
      /**
       * Format: float
       * @description Estimated risk of this action (0=safe, 1=very risky)
       */
      risk?: number | null;
      /** @description Whether this option is currently available (requirements met) */
      available: boolean;
      /** @description Requirements that must be met for this option */
      requirements?: string[] | null;
      /** @description Milliseconds until this option becomes available again (if on cooldown) */
      cooldownMs?: number | null;
      /** @description Tags for categorization (e.g., ["melee", "aggressive", "loud"]) */
      tags?: string[] | null;
    } & {
      [key: string]: unknown;
    };
    /**
     * @description Context provided with a fresh query. Injected as a perception to the actor
     *     to trigger context-sensitive option recomputation.
     */
    OptionsQueryContext: {
      /** @description Current combat state (approaching, engaged, retreating, etc.) */
      combatState?: string | null;
      /** @description IDs of opponents in the current encounter */
      opponentIds?: string[] | null;
      /** @description IDs of allies in the current encounter */
      allyIds?: string[] | null;
      /** @description Environment tags (indoor, elevated, destructibles, narrow, etc.) */
      environmentTags?: string[] | null;
      /**
       * Format: float
       * @description How urgent is this query (affects option prioritization)
       */
      urgency?: number | null;
      /** @description Actor-specific context data */
      customContext?: {
        [key: string]: unknown;
      } | null;
    } & {
      [key: string]: unknown;
    };
    /** @description Character-specific context that influenced option computation */
    CharacterOptionContext: {
      /** @description Character's combat style (aggressive, defensive, balanced, etc.) */
      combatStyle?: string | null;
      /**
       * Format: float
       * @description Character's risk tolerance (0=cautious, 1=reckless)
       */
      riskTolerance?: number | null;
      /** @description Whether character prioritizes ally protection */
      protectAllies?: boolean | null;
      /** @description Character's current primary goal */
      currentGoal?: string | null;
      /** @description Character's current dominant emotion */
      emotionalState?: string | null;
    };
    /**
     * @description Instruction sent to a participant actor by Event Brain to execute a choreographed sequence.
     *     Delivered via emit_perception with perception_type "choreography_instruction".
     */
    ChoreographyInstruction: {
      /** @description ID of the coordinated encounter this instruction belongs to */
      encounterId: string;
      /**
       * @description Unique ID for this sequence within the choreography.
       *     Used for acknowledgment and sync point coordination.
       */
      sequenceId: string;
      /**
       * @description Ordered list of actions for the participant to execute.
       *     Multiple actions allow for combos or reaction sequences.
       */
      actions: components['schemas']['ChoreographyAction'][];
      /** @description When and how to start executing this sequence */
      timing: components['schemas']['ChoreographyTiming'];
      /**
       * @description How strongly to prefer this choreography over actor's own choices.
       *     Higher priority may interrupt current actions.
       */
      priority: components['schemas']['ChoreographyPriority'];
      /**
       * @description Whether participant can interrupt the sequence if a better opportunity arises.
       *     If false, participant should complete the sequence unless impossible.
       */
      canInterrupt?: boolean | null;
      /**
       * @description Expected outcome of this sequence (e.g., "hit", "miss", "block").
       *     Used for coordinating reactions with other participants.
       */
      expectedOutcome?: string | null;
      /**
       * @description Event to emit when sequence completes (e.g., "sync_point.attack_landed").
       *     Other participants may be waiting on this.
       */
      onComplete?: string | null;
    };
    /**
     * @description A single action within a choreographed sequence.
     *     ActionId should match one from the participant's options.
     */
    ChoreographyAction: {
      /**
       * @description Action identifier matching one from the actor's options.
       *     Examples: "sword_slash", "dodge_roll", "taunt"
       */
      actionId: string;
      /**
       * @description Target actor ID for the action, if applicable.
       *     Null for untargeted actions like movement or taunts.
       */
      targetId?: string | null;
      /** @description Target position for movement or placement actions */
      position?: components['schemas']['ChoreographyPosition'];
      /**
       * @description Expected duration in milliseconds.
       *     Used for timing subsequent actions and sync points.
       */
      durationMs?: number | null;
      /**
       * @description Stylistic modifier for the action (e.g., "dramatic", "desperate", "confident").
       *     Actors may adjust animation/presentation based on style.
       */
      style?: string | null;
      /**
       * @description Delay before starting this action (relative to previous action completion).
       *     Allows precise timing within sequences.
       */
      delayMs?: number | null;
    } & {
      [key: string]: unknown;
    };
    /** @description Controls when a choreographed sequence should begin execution */
    ChoreographyTiming: {
      /**
       * @description When to start executing the sequence.
       *     - immediate: Start as soon as instruction received
       *     - after_previous: Start after current action completes
       *     - sync_point: Wait for specified sync point event
       */
      startAt: components['schemas']['ChoreographyStartCondition'];
      /**
       * @description Sync point to wait for (required when startAt=sync_point).
       *     Examples: "attack_landed", "guard_raised", "combo_ready"
       */
      syncPointId?: string | null;
      /**
       * @description Maximum time to wait for sync point in milliseconds.
       *     If exceeded, sequence may start anyway or be cancelled.
       */
      maxWaitMs?: number | null;
      /**
       * @description Time window during which the action can start.
       *     Allows for natural timing variation.
       */
      windowMs?: number | null;
    };
    /**
     * @description How strongly the actor should prefer the choreographed action over their own choices.
     *     - low: Suggestion; actor may ignore if they prefer something else
     *     - normal: Standard choreography; follow unless clearly suboptimal
     *     - high: Important sequence; should follow even if not preferred
     *     - override: Critical moment; must follow unless physically impossible
     * @enum {string}
     */
    ChoreographyPriority: 'low' | 'normal' | 'high' | 'override';
    /**
     * @description When to begin executing a choreographed sequence
     * @enum {string}
     */
    ChoreographyStartCondition: 'immediate' | 'after_previous' | 'sync_point';
    /** @description 3D position for choreography movement and placement actions */
    ChoreographyPosition: {
      /**
       * Format: float
       * @description X coordinate
       */
      x?: number;
      /**
       * Format: float
       * @description Y coordinate (vertical)
       */
      y?: number;
      /**
       * Format: float
       * @description Z coordinate
       */
      z?: number;
    };
    /** @description Request to start an encounter managed by an Event Brain actor */
    StartEncounterRequest: {
      /** @description ID of the Event Brain actor that will manage this encounter */
      actorId: string;
      /** @description Unique identifier for this encounter */
      encounterId: string;
      /** @description Type of encounter (e.g., "combat", "conversation", "choreography") */
      encounterType: string;
      /** @description Character IDs of participants in the encounter */
      participants: string[];
      /** @description Optional initial data for the encounter */
      initialData?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update the phase of an active encounter */
    UpdateEncounterPhaseRequest: {
      /** @description ID of the Event Brain actor managing the encounter */
      actorId: string;
      /** @description New phase name for the encounter */
      phase: string;
    };
    /** @description Response after updating encounter phase */
    UpdateEncounterPhaseResponse: {
      /** @description ID of the actor managing the encounter */
      actorId: string;
      /** @description Previous phase name */
      previousPhase?: string | null;
      /** @description Current phase name after update */
      currentPhase: string;
    };
    /** @description Request to end an active encounter */
    EndEncounterRequest: {
      /** @description ID of the Event Brain actor managing the encounter */
      actorId: string;
    };
    /** @description Response after ending an encounter */
    EndEncounterResponse: {
      /** @description ID of the actor */
      actorId: string;
      /** @description ID of the ended encounter */
      encounterId: string;
      /** @description Duration of the encounter in milliseconds */
      durationMs?: number | null;
    };
    /** @description Request to get the current encounter state for an actor */
    GetEncounterRequest: {
      /** @description ID of the Event Brain actor to query */
      actorId: string;
    };
    /** @description Response containing the current encounter state */
    GetEncounterResponse: {
      /** @description ID of the queried actor */
      actorId: string;
      /** @description Whether the actor is currently managing an encounter */
      hasActiveEncounter: boolean;
      /** @description Current encounter state (null if no active encounter) */
      encounter?: components['schemas']['EncounterState'];
    };
    /** @description State of an active encounter being managed by an Event Brain actor */
    EncounterState: {
      /** @description Unique identifier for this encounter */
      encounterId: string;
      /** @description Type of encounter */
      encounterType: string;
      /** @description Character IDs participating in the encounter */
      participants: string[];
      /** @description Current phase of the encounter */
      phase: string;
      /**
       * Format: date-time
       * @description When the encounter started
       */
      startedAt: string;
      /** @description Custom encounter-specific data */
      data?: {
        [key: string]: unknown;
      } | null;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  CreateActorTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateActorTemplateRequest'];
      };
    };
    responses: {
      /** @description Template created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorTemplateResponse'];
        };
      };
    };
  };
  GetActorTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetActorTemplateRequest'];
      };
    };
    responses: {
      /** @description Template retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorTemplateResponse'];
        };
      };
    };
  };
  ListActorTemplates: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListActorTemplatesRequest'];
      };
    };
    responses: {
      /** @description Templates listed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListActorTemplatesResponse'];
        };
      };
    };
  };
  UpdateActorTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateActorTemplateRequest'];
      };
    };
    responses: {
      /** @description Template updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorTemplateResponse'];
        };
      };
    };
  };
  DeleteActorTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteActorTemplateRequest'];
      };
    };
    responses: {
      /** @description Template deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteActorTemplateResponse'];
        };
      };
    };
  };
  SpawnActor: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SpawnActorRequest'];
      };
    };
    responses: {
      /** @description Actor spawned successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorInstanceResponse'];
        };
      };
    };
  };
  GetActor: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetActorRequest'];
      };
    };
    responses: {
      /** @description Actor retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorInstanceResponse'];
        };
      };
    };
  };
  StopActor: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StopActorRequest'];
      };
    };
    responses: {
      /** @description Actor stopped successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StopActorResponse'];
        };
      };
    };
  };
  ListActors: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListActorsRequest'];
      };
    };
    responses: {
      /** @description Actors listed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListActorsResponse'];
        };
      };
    };
  };
  InjectPerception: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InjectPerceptionRequest'];
      };
    };
    responses: {
      /** @description Perception injected successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InjectPerceptionResponse'];
        };
      };
    };
  };
  QueryOptions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryOptionsRequest'];
      };
    };
    responses: {
      /** @description Options retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryOptionsResponse'];
        };
      };
    };
  };
  StartEncounter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StartEncounterRequest'];
      };
    };
    responses: {
      /** @description Encounter started successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateEncounterPhase: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateEncounterPhaseRequest'];
      };
    };
    responses: {
      /** @description Encounter phase updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateEncounterPhaseResponse'];
        };
      };
    };
  };
  EndEncounter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EndEncounterRequest'];
      };
    };
    responses: {
      /** @description Encounter ended successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EndEncounterResponse'];
        };
      };
    };
  };
  GetEncounter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEncounterRequest'];
      };
    };
    responses: {
      /** @description Encounter state retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetEncounterResponse'];
        };
      };
    };
  };
}
