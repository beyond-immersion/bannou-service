/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/orchestrator/health/infrastructure': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check infrastructure component health
     * @description Validates connectivity and health of core infrastructure components:
     *     - Redis (direct connection via StackExchange.Redis)
     *     - RabbitMQ (direct connection via RabbitMQ.Client)
     *     -
     */
    post: operations['GetInfrastructureHealth'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/health/services': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get health status of all services
     * @description Retrieves health information from all services via Redis heartbeat monitoring.
     *     Uses existing ServiceHeartbeatEvent schema from common-events.yaml.
     */
    post: operations['GetServicesHealth'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/services/restart': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Restart service with optional configuration
     * @description Performs intelligent service restart based on health metrics.
     *     Only restarts if truly necessary (e.g., 5+ minute degradation).
     *
     *     Supports optional environment variable updates during restart.
     */
    post: operations['RestartService'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/services/should-restart': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if service needs restart
     * @description Evaluates service health and determines if restart is necessary.
     *
     *     Restart logic:
     *     - Healthy: No restart needed
     *     - Degraded < 5 min: No restart needed
     *     - Degraded > 5 min: Restart recommended
     *     - Unavailable: Restart needed
     */
    post: operations['ShouldRestartService'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/backends/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Detect available container orchestration backends
     * @description Detects which container orchestration backends are available on this system.
     *     Returns availability status and capabilities for each backend.
     *
     *     **Priority Order** (for automatic selection):
     *     1. Kubernetes - Full cluster orchestration with operators
     *     2. Portainer - API abstraction over Compose/Swarm with web UI
     *     3. Docker Swarm - Native Docker cluster orchestration
     *     4. Docker Compose - Single-host container management
     *
     *     Detection methods:
     *     - Kubernetes: Check for kubectl and cluster connectivity
     *     - Portainer: Check for Portainer API endpoint
     *     - Swarm: Check `docker info` for swarm mode
     *     - Compose: Check for docker compose v2 availability
     */
    post: operations['GetBackends'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/presets/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List available deployment presets
     * @description Returns all available deployment presets from the orchestrator's preset directory.
     *     Presets define service combinations and configuration for specific use cases.
     *
     *     Built-in presets:
     *     - `local-development`: All services in single container with mesh infrastructure
     *     - `local-testing`: Test environment with infrastructure services
     *     - `integration-http`: HTTP integration testing preset
     *     - `integration-edge`: WebSocket/edge testing preset
     *     - `split-auth-account`: Auth and Account in separate containers
     *     - `distributed-npc`: NPC processing distributed across nodes
     */
    post: operations['GetPresets'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/deploy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Deploy or update an environment
     * @description Deploys a complete environment using a preset or custom configuration.
     *     Supports graceful transitions, forced deployments, and clean rebuilds.
     *
     *     **Deployment Modes**:
     *     - `graceful`: Wait for existing connections to drain before changing topology
     *     - `force`: Immediately apply changes (may interrupt active connections)
     *     - `clean`: Tear down completely and rebuild from scratch
     *
     *     **Backend Selection**:
     *     - If `backend` not specified, uses highest-priority available backend
     *     - If `backend` specified but unavailable, returns error (no fallback)
     *
     *     **Live Topology Changes**:
     *     Supports changing service distribution without full restart:
     *     - Move auth/account to separate container while keeping other services together
     *     - Scale specific services to additional nodes
     *     - Update environment variables without restart (where supported)
     */
    post: operations['Deploy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/service-routing': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current service-to-app-id routing mappings
     * @description Returns the current service-to-app-id routing mappings used for mesh service invocation through lib-mesh.
     *     This is the authoritative source of truth for how services are routed in the current deployment.
     *
     *     In development, all services route to "bannou" by default. In production, services may be
     *     distributed across multiple app-ids based on deployment topology.
     *
     *     **Use Cases**:
     *     - Services querying routing on startup
     *     - Debugging service communication issues
     *     - Monitoring deployment topology
     */
    post: operations['GetServiceRouting'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current environment status
     * @description Returns comprehensive status of the current deployment including:
     *     - Active backend and deployment configuration
     *     - Service topology (which services on which containers)
     *     - Container health and resource usage
     *     - Infrastructure component status
     *     - Active preset and any customizations
     */
    post: operations['GetStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/teardown': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Tear down the current environment
     * @description Tears down all containers and services in the current deployment.
     *     Optionally preserves volumes and networks for faster redeployment.
     *
     *     **Teardown Modes**:
     *     - `graceful`: Signal shutdown and wait for clean exit
     *     - `force`: Immediately stop all containers (SIGKILL)
     *     - `preserve-data`: Keep volumes and networks, only remove containers
     */
    post: operations['Teardown'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/clean': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Clean up unused resources
     * @description Prunes unused Docker resources to reclaim disk space and clean up
     *     orphaned containers, networks, volumes, and images.
     *
     *     Equivalent to running various `docker system prune` commands.
     *
     *     **Clean Targets**:
     *     - `containers`: Remove stopped containers
     *     - `networks`: Remove unused networks
     *     - `volumes`: Remove unused volumes (CAUTION: data loss)
     *     - `images`: Remove dangling images
     *     - `all`: All of the above
     */
    post: operations['Clean'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/logs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get service/container logs
     * @description Retrieves logs from services or containers with filtering options.
     *     Supports real-time streaming via WebSocket upgrade.
     */
    post: operations['GetLogs'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/topology': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update service topology without full redeploy
     * @description Changes which services run on which containers without tearing down
     *     the entire environment. Enables live topology changes.
     *
     *     **Use Cases**:
     *     - Move auth service to dedicated container for scaling
     *     - Consolidate services during low-traffic periods
     *     - Split services for debugging/isolation
     *     - Add new service nodes to running environment
     */
    post: operations['UpdateTopology'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/containers/request-restart': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request container restart (self-service pattern)
     * @description Plugins call this endpoint to request restart of their own container.
     *     This is part of the self-service configuration update pattern where
     *     plugins decide if they care about config changes and request restarts.
     *
     *     **Flow**:
     *     1. Orchestrator publishes ConfigurationChangedEvent with changed keys
     *     2. Plugins check if any changed keys match their dependencies
     *     3. Plugins that care call this endpoint to request restart
     *     4. Orchestrator performs rolling restart of requested containers
     *
     *     **Priority Levels**:
     *     - `graceful`: Rolling update, wait for healthy before cycling next instance
     *     - `immediate`: Rolling update but don't wait for connection drain
     *     - `force`: Kill all instances simultaneously (causes downtime)
     */
    post: operations['RequestContainerRestart'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/containers/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get container health and restart history
     * @description Returns detailed status of a container including health, restart history,
     *     running plugins, and current configuration.
     */
    post: operations['GetContainerStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/config/rollback': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Rollback to previous configuration
     * @description Quickly rollback to the previous configuration without waiting for CI.
     *     Swaps currentConfig with previousConfig and publishes ConfigurationChangedEvent
     *     with the reverted keys so services can request restart.
     *
     *     **Note**: This is a quick fix. GitHub secrets should still be corrected
     *     to prevent re-breaking on next orchestrator deploy.
     */
    post: operations['RollbackConfiguration'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/config/version': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current configuration version and metadata
     * @description Returns the current configuration version, last update time,
     *     and summary of configuration state (not actual values for security).
     */
    post: operations['GetConfigVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/processing-pool/acquire': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Acquire a processor from a pool
     * @description Requests an available processor instance from the specified pool type.
     *     Returns the app-id of an available processor or 429 if none available.
     *     The processor is marked as busy until explicitly released.
     */
    post: operations['AcquireProcessor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/processing-pool/release': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Release a processor back to the pool
     * @description Releases a previously acquired processor, making it available for other requests.
     *     Should be called when processing is complete or on error cleanup.
     */
    post: operations['ReleaseProcessor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/processing-pool/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get processing pool status
     * @description Returns current status of a processing pool including:
     *     - Total instances (running and available)
     *     - Current utilization
     *     - Queue depth (waiting requests)
     *     - Recent processing metrics
     */
    post: operations['GetPoolStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/processing-pool/scale': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Scale a processing pool
     * @description Manually adjust the size of a processing pool.
     *     Can scale up (add instances) or scale down (remove idle instances).
     *     Respects min/max constraints from pool configuration.
     */
    post: operations['ScalePool'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/orchestrator/processing-pool/cleanup': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cleanup idle processing pool instances
     * @description Scales pool back to minimum instances by removing idle processors.
     *     Used for resource reclamation during low-activity periods.
     */
    post: operations['CleanupPool'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Request to check infrastructure health (empty body allowed) */
    InfrastructureHealthRequest: {
      /** @description Optional filter for specific components (redis, rabbitmq, placement) */
      components?: string[] | null;
    };
    /** @description Request to get service health status (empty body allowed) */
    ServiceHealthRequest: {
      /** @description Optional filter by service name */
      serviceFilter?: string | null;
    };
    /** @description Request to get service routing mappings (empty body allowed) */
    GetServiceRoutingRequest: {
      /** @description Optional filter by service name prefix */
      serviceFilter?: string | null;
    };
    /** @description Response containing service-to-app-id routing mappings for mesh invocation */
    ServiceRoutingResponse: {
      /**
       * @description Map of service names to Bannou app-id routing destinations.
       *     Example: { "account": "bannou", "behavior": "npc-processing-01" }
       */
      mappings: {
        [key: string]: string;
      };
      /**
       * @description Default app-id used when no specific mapping exists
       * @default bannou
       */
      defaultAppId: string;
      /**
       * Format: date-time
       * @description When this routing information was generated
       */
      generatedAt: string;
      /** @description Total number of services with routing mappings */
      totalServices?: number;
      /** @description Current deployment identifier (if environment is deployed) */
      deploymentId?: string | null;
    };
    /** @description Request to list available backends (empty body allowed) */
    ListBackendsRequest: {
      /**
       * @description Force refresh detection instead of using cached results
       * @default false
       */
      refresh: boolean;
    };
    /** @description Request to list available presets (empty body allowed) */
    ListPresetsRequest: {
      /**
       * @description Optional filter by category
       * @enum {string|null}
       */
      category?: 'development' | 'testing' | 'production' | 'custom' | null;
    };
    /** @description Request to get environment status (empty body allowed) */
    GetStatusRequest: {
      /**
       * @description Include resource usage metrics
       * @default true
       */
      includeResources: boolean;
    };
    /** @description Request to get service/container logs */
    GetLogsRequest: {
      /** @description Service name to get logs for */
      service?: string | null;
      /** @description Container ID or name (alternative to service) */
      container?: string | null;
      /** @description Return logs since timestamp (RFC3339 or relative like "5m") */
      since?: string | null;
      /** @description Return logs until timestamp */
      until?: string | null;
      /**
       * @description Number of lines from end of logs
       * @default 100
       */
      tail: number;
      /**
       * @description Stream logs in real-time (WebSocket upgrade)
       * @default false
       */
      follow: boolean;
    };
    /** @description Request body for restarting a container by its app-id */
    ContainerRestartRequestBody: {
      /** @description Container's app-id for mesh routing (e.g., "bannou", "npc-omega") */
      appName: string;
      /**
       * @description Why restart is needed (for logging/auditing)
       * @example configuration_change
       */
      reason: string;
      /** @description Urgency level for the restart */
      priority?: components['schemas']['RestartPriority'];
      /**
       * @description Seconds to allow graceful shutdown before force-kill
       * @default 30
       */
      shutdownGracePeriod: number;
    };
    /** @description Request to retrieve the current status of a specific container */
    GetContainerStatusRequest: {
      /** @description Container's app-id for mesh routing */
      appName: string;
    };
    /** @description Request to get configuration version (empty body allowed) */
    GetConfigVersionRequest: {
      /**
       * @description Include list of configuration key prefixes
       * @default true
       */
      includeKeyPrefixes: boolean;
    };
    /** @description Response containing overall infrastructure health status and individual component details */
    InfrastructureHealthResponse: {
      /** @description Overall infrastructure health status */
      healthy: boolean;
      /**
       * Format: date-time
       * @description When health check was performed
       */
      timestamp: string;
      /** @description Individual component health status */
      components: components['schemas']['ComponentHealth'][];
    };
    /** @description Health status information for a single infrastructure component (Redis, RabbitMQ, etc.) */
    ComponentHealth: {
      /** @description Component name (redis, rabbitmq, placement) */
      name: string;
      /**
       * @description Component health status
       * @enum {string}
       */
      status: 'healthy' | 'degraded' | 'unavailable';
      /**
       * Format: date-time
       * @description Last successful connection time
       */
      lastSeen: string;
      /** @description Additional status information (null if no additional context needed) */
      message?: string | null;
      /** @description Component-specific metrics (e.g., ping time) */
      metrics?: {
        [key: string]: unknown;
      };
    };
    /** @description Service capacity metrics from heartbeat monitoring including connection counts and resource usage */
    Capacity: {
      /** @description Maximum number of connections this service can handle */
      maxConnections?: number;
      /** @description Current number of active connections */
      currentConnections?: number;
      /**
       * Format: float
       * @description CPU usage as a percentage (0.0 to 1.0)
       */
      cpuUsage?: number;
      /**
       * Format: float
       * @description Memory usage as a percentage (0.0 to 1.0)
       */
      memoryUsage?: number;
    };
    /** @description Health check information for a container including last check status and failure tracking */
    HealthChecks: {
      /**
       * Format: date-time
       * @description When the last health check was performed
       */
      lastCheck?: string;
      /** @description Result of the last health check */
      status?: string;
      /** @description Number of consecutive health check failures */
      consecutiveFailures?: number;
    };
    /** @description Aggregated health report for all services based on heartbeat monitoring */
    ServiceHealthReport: {
      /**
       * Format: date-time
       * @description When report was generated
       */
      timestamp: string;
      /** @description Total number of services */
      totalServices: number;
      /**
       * Format: float
       * @description Percentage of healthy services (0-100)
       */
      healthPercentage: number;
      /** @description Services with recent heartbeats */
      healthyServices: components['schemas']['ServiceHealthStatus'][];
      /** @description Services with expired heartbeats */
      unhealthyServices: components['schemas']['ServiceHealthStatus'][];
    };
    /**
     * @description Service health status from heartbeat monitoring.
     *     Uses ServiceHeartbeatEvent schema from common-events.yaml.
     */
    ServiceHealthStatus: {
      /** @description Service ID (e.g., "behavior", "account") */
      serviceId: string;
      /** @description App-id for mesh routing (e.g., "bannou", "npc-omega-01") */
      appId: string;
      /** @description Service status from heartbeat */
      status: string;
      /**
       * Format: date-time
       * @description Last heartbeat timestamp
       */
      lastSeen: string;
      /** @description Current capacity metrics including load and available slots */
      capacity?: components['schemas']['Capacity'];
      /** @description Additional service metadata (null if not provided) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to restart a specific service with optional configuration updates */
    ServiceRestartRequest: {
      /** @description Name of service to restart */
      serviceName: string;
      /** @description Optional environment variable updates */
      environment?: {
        [key: string]: string;
      };
      /** @description Force restart even if healthy (default false) */
      force?: boolean;
      /** @description Timeout for service to become healthy (seconds, default 120) */
      timeout?: number;
    };
    /** @description Result of a service restart operation including timing and status information */
    ServiceRestartResult: {
      /** @description Restart success status */
      success: boolean;
      /** @description Service that was restarted */
      serviceName: string;
      /** @description Time taken to restart and become healthy */
      duration: string;
      /** @description Service status before restart */
      previousStatus?: string;
      /** @description Service status after restart */
      currentStatus?: string;
      /** @description Restart result message */
      message?: string;
    };
    /** @description Request to evaluate whether a service should be restarted based on health metrics */
    ShouldRestartServiceRequest: {
      /** @description Name of service to evaluate */
      serviceName: string;
    };
    /** @description Recommendation on whether a service should be restarted with supporting rationale */
    RestartRecommendation: {
      /** @description Whether restart is recommended */
      shouldRestart: boolean;
      /** @description Service being evaluated */
      serviceName: string;
      /** @description Current service health status */
      currentStatus: string;
      /**
       * Format: date-time
       * @description Last heartbeat timestamp
       */
      lastSeen?: string;
      /** @description How long service has been degraded (null if not degraded) */
      degradedDuration?: string | null;
      /** @description Explanation for recommendation */
      reason: string;
    };
    /**
     * @description Container orchestration backend type.
     *     Priority order: kubernetes > portainer > swarm > compose
     * @enum {string}
     */
    BackendType: 'kubernetes' | 'portainer' | 'swarm' | 'compose';
    /** @description Information about a container orchestration backend including availability and capabilities */
    BackendInfo: {
      /** @description Backend type identifier */
      type: components['schemas']['BackendType'];
      /** @description Whether this backend is currently available */
      available: boolean;
      /** @description Selection priority (1 = highest) */
      priority: number;
      /** @description Backend version (e.g., "1.28.0" for Docker) */
      version?: string;
      /** @description Backend API endpoint (if applicable) */
      endpoint?: string;
      /**
       * @description Supported capabilities for this backend:
       *     - live-topology: Can change service distribution without restart
       *     - scaling: Can scale services horizontally
       *     - rolling-update: Supports rolling deployments
       *     - secrets: Native secrets management
       *     - volumes: Persistent volume support
       *     - networks: Custom network creation
       */
      capabilities?: string[];
      /** @description Error message if detection failed */
      error?: string;
    };
    /** @description Response listing all detected container orchestration backends with recommended selection */
    BackendsResponse: {
      /**
       * Format: date-time
       * @description When detection was performed
       */
      timestamp: string;
      /** @description All detected backends with status */
      backends: components['schemas']['BackendInfo'][];
      /** @description Highest priority available backend */
      recommended: components['schemas']['BackendType'];
      /** @description Currently active backend (if environment deployed) */
      activeBackend?: components['schemas']['BackendType'];
    };
    /** @description Predefined deployment configuration defining service topology and environment settings */
    DeploymentPreset: {
      /** @description Unique preset identifier (e.g., "local-development") */
      name: string;
      /** @description Human-readable preset description */
      description: string;
      /**
       * @description Preset category
       * @enum {string}
       */
      category?: 'development' | 'testing' | 'production' | 'custom';
      /** @description Service topology defined by this preset */
      topology: components['schemas']['ServiceTopology'];
      /** @description Default environment variables for this preset */
      environment?: {
        [key: string]: string;
      };
      /** @description Backends that support this preset (empty = all) */
      requiredBackends?: components['schemas']['BackendType'][];
      /** @description Whether this is a built-in preset */
      builtIn?: boolean;
      /** @description Path to preset configuration file */
      filePath?: string;
    };
    /** @description Response containing available deployment presets and the currently active preset */
    PresetsResponse: {
      /** @description Available deployment presets */
      presets: components['schemas']['DeploymentPreset'][];
      /** @description Currently active preset name (if any) */
      activePreset?: string;
    };
    /** @description Service distribution topology defining which services run on which nodes */
    ServiceTopology: {
      /** @description Container/pod definitions with service assignments */
      nodes: components['schemas']['TopologyNode'][];
      /** @description Infrastructure service configuration */
      infrastructure?: components['schemas']['InfrastructureConfig'];
    };
    /** @description A container or pod in the service topology with its assigned services and configuration */
    TopologyNode: {
      /** @description Node/container name (e.g., "bannou-main", "bannou-auth") */
      name: string;
      /**
       * @description Services enabled on this node.
       *     Uses {SERVICE}_SERVICE_ENABLED=true pattern.
       *     Example: ["account", "auth", "permission"]
       */
      services: string[];
      /**
       * @description Number of replicas for this node
       * @default 1
       */
      replicas: number;
      /** @description Resource limits and requests for this node */
      resources?: components['schemas']['ResourceLimits'];
      /** @description Node-specific environment overrides */
      environment?: {
        [key: string]: string;
      };
      /**
       * @description Whether mesh routing is enabled
       * @default true
       */
      meshEnabled: boolean;
      /** @description App-id override for mesh routing (default derives from node name) */
      appId?: string;
    };
    /** @description Configuration for infrastructure services */
    InfrastructureConfig: {
      /** @description Redis configuration */
      redis?: components['schemas']['InfraServiceConfig'];
      /** @description RabbitMQ configuration */
      rabbitmq?: components['schemas']['InfraServiceConfig'];
      /** @description MySQL configuration */
      mysql?: components['schemas']['InfraServiceConfig'];
      /** @description Ingress/reverse proxy configuration */
      ingress?: components['schemas']['IngressConfig'];
    };
    /** @description Configuration for an infrastructure service */
    InfraServiceConfig: {
      /**
       * @description Whether this infrastructure service is enabled
       * @default true
       */
      enabled: boolean;
      /** @description Docker image override */
      image?: string;
      /** @description Resource limits and requests */
      resources?: components['schemas']['ResourceLimits'];
      /** @description Environment variables for this service */
      environment?: {
        [key: string]: string;
      };
      /** @description Volume mounts */
      volumes?: string[];
    };
    /** @description Ingress/reverse proxy configuration */
    IngressConfig: {
      /**
       * @description Whether ingress is enabled
       * @default true
       */
      enabled: boolean;
      /**
       * @description Type of ingress/reverse proxy to use
       * @default openresty
       * @enum {string}
       */
      type: 'openresty' | 'nginx' | 'traefik' | 'none';
      /** @description Port configuration for HTTP and HTTPS traffic */
      ports?: components['schemas']['Ports'];
      /**
       * @description Whether SSL/TLS is enabled
       * @default false
       */
      ssl: boolean;
    };
    /** @description Port configuration for ingress specifying HTTP and HTTPS port numbers */
    Ports: {
      /**
       * @description HTTP port number
       * @default 80
       */
      http: number;
      /**
       * @description HTTPS port number
       * @default 443
       */
      https: number;
    };
    /** @description Resource limits and requests for container scheduling */
    ResourceLimits: {
      /** @description CPU limit (e.g., "0.5", "2") */
      cpuLimit?: string;
      /** @description Memory limit (e.g., "512m", "2g") */
      memoryLimit?: string;
      /** @description CPU request (Kubernetes) */
      cpuRequest?: string;
      /** @description Memory request (Kubernetes) */
      memoryRequest?: string;
    };
    /**
     * @description Deployment mode:
     *     - graceful: Wait for connections to drain
     *     - force: Apply immediately
     *     - clean: Tear down and rebuild
     * @enum {string}
     */
    DeploymentMode: 'graceful' | 'force' | 'clean';
    /** @description Request to deploy or update an environment using a preset or custom topology */
    DeployRequest: {
      /** @description Preset name to deploy (mutually exclusive with topology) */
      preset?: string | null;
      /** @description Custom topology (mutually exclusive with preset) */
      topology?: components['schemas']['ServiceTopology'] | null;
      /** @description Specific backend to use (fails if unavailable) */
      backend?: components['schemas']['BackendType'] | null;
      /**
       * @description How the deployment should be performed
       * @default graceful
       */
      mode: components['schemas']['DeploymentMode'];
      /** @description Environment variable overrides */
      environment?: {
        [key: string]: string;
      } | null;
      /**
       * @description Deployment timeout in seconds
       * @default 300
       */
      timeout: number;
      /**
       * @description Wait for all services to report healthy
       * @default true
       */
      waitForHealthy: boolean;
      /**
       * @description Preview what would be deployed without making changes
       * @default false
       */
      dryRun: boolean;
    };
    /** @description Result of a deployment operation including status and deployed service information */
    DeployResponse: {
      /** @description Whether all nodes were deployed successfully (false indicates partial failure) */
      success: boolean;
      /** @description Unique deployment identifier for tracking */
      deploymentId: string;
      /** @description Container orchestration backend used for deployment */
      backend: components['schemas']['BackendType'];
      /** @description Preset used (if applicable) */
      preset?: string;
      /** @description Time taken to deploy */
      duration: string;
      /** @description Final applied topology */
      topology?: components['schemas']['ServiceTopology'];
      /** @description Status of deployed services */
      services?: components['schemas']['DeployedService'][];
      /** @description Non-fatal warnings during deployment */
      warnings?: string[];
      /** @description Human-readable deployment summary */
      message?: string;
    };
    /** @description Status information for a single deployed service instance */
    DeployedService: {
      /** @description Service name */
      name: string;
      /**
       * @description Current status of the deployed service
       * @enum {string}
       */
      status: 'starting' | 'running' | 'healthy' | 'unhealthy' | 'stopped';
      /** @description Node/container hosting this service */
      node: string;
      /** @description Container ID (Compose/Swarm) */
      containerId?: string;
      /** @description Pod name (Kubernetes) */
      podName?: string;
      /** @description Exposed endpoints */
      endpoints?: string[];
    };
    /** @description Current status of the deployed environment including topology and resource usage */
    EnvironmentStatus: {
      /** @description Whether an environment is currently deployed */
      deployed: boolean;
      /**
       * Format: date-time
       * @description When this status was generated
       */
      timestamp: string;
      /** @description Current deployment identifier */
      deploymentId?: string;
      /** @description Container orchestration backend in use */
      backend?: components['schemas']['BackendType'];
      /** @description Active preset name */
      preset?: string;
      /** @description Current topology configuration */
      topology?: components['schemas']['ServiceTopology'];
      /** @description All deployed services with status */
      services?: components['schemas']['DeployedService'][];
      /** @description Infrastructure component health */
      infrastructure?: components['schemas']['InfrastructureHealthResponse'];
      /** @description Overall resource usage */
      resources?: components['schemas']['ResourceUsage'];
      /** @description Time since deployment */
      uptime?: string;
    };
    /** @description System resource utilization metrics including CPU, memory, disk, and network */
    ResourceUsage: {
      /**
       * Format: float
       * @description Total CPU usage percentage
       */
      cpuPercent?: number;
      /** @description Total memory used (MB) */
      memoryUsedMb?: number;
      /** @description Total memory available (MB) */
      memoryTotalMb?: number;
      /**
       * Format: float
       * @description Disk space used (GB)
       */
      diskUsedGb?: number;
      /**
       * Format: float
       * @description Network input (MB)
       */
      networkInMb?: number;
      /**
       * Format: float
       * @description Network output (MB)
       */
      networkOutMb?: number;
    };
    /**
     * @description Teardown mode:
     *     - graceful: Signal shutdown, wait for clean exit
     *     - force: Immediately stop (SIGKILL)
     *     - preserve-data: Keep volumes/networks, remove containers
     * @enum {string}
     */
    TeardownMode: 'graceful' | 'force' | 'preserve-data';
    /** @description Request to tear down a deployed environment with options for data preservation */
    TeardownRequest: {
      /**
       * @description When true, simulates teardown without actually stopping or removing containers.
       *     Returns what would be torn down. ALWAYS use dryRun=true first to preview the impact.
       * @default false
       */
      dryRun: boolean;
      /**
       * @description How the teardown should be performed
       * @default graceful
       */
      mode: components['schemas']['TeardownMode'];
      /**
       * @description Graceful shutdown timeout in seconds
       * @default 60
       */
      timeout: number;
      /**
       * @description Also remove associated volumes
       * @default false
       */
      removeVolumes: boolean;
      /**
       * @description Also remove associated networks
       * @default false
       */
      removeNetworks: boolean;
      /**
       * @description When true, also removes support infrastructure (Redis, RabbitMQ, MySQL, etc.).
       *     This is determined by scanning compose files or finding containers in the same
       *     Docker swarm/Kubernetes namespace as bannou services. USE WITH EXTREME CAUTION -
       *     this will destroy all data and require a full re-deployment.
       * @default false
       */
      includeInfrastructure: boolean;
    };
    /** @description Result of an environment teardown including removed resources and any errors */
    TeardownResponse: {
      /** @description Whether all containers were torn down successfully (false indicates partial failure) */
      success: boolean;
      /** @description Time taken to complete teardown */
      duration: string;
      /** @description Container IDs that were stopped */
      stoppedContainers?: string[];
      /** @description Volumes that were removed */
      removedVolumes?: string[];
      /** @description Networks that were removed */
      removedNetworks?: string[];
      /** @description Infrastructure services that were removed (Redis, RabbitMQ, MySQL, etc.) */
      removedInfrastructure?: string[];
      /** @description Non-fatal errors during teardown */
      errors?: string[];
      /** @description Human-readable teardown summary */
      message?: string;
    };
    /**
     * @description Type of resource to clean
     * @enum {string}
     */
    CleanTarget: 'containers' | 'networks' | 'volumes' | 'images' | 'all';
    /** @description Request to clean up Docker resources such as containers, volumes, and images */
    CleanRequest: {
      /** @description Resources to clean (or "all") */
      targets: components['schemas']['CleanTarget'][];
      /**
       * @description Force removal without confirmation
       * @default false
       */
      force: boolean;
      /** @description Only clean resources older than (e.g., "24h", "7d") */
      olderThan?: string | null;
      /** @description Only clean resources matching labels */
      labelFilter?: {
        [key: string]: string;
      } | null;
    };
    /** @description Result of a cleanup operation including reclaimed space and removed resource counts */
    CleanResponse: {
      /** @description Whether all requested cleanup operations completed (false indicates partial failure) */
      success: boolean;
      /** @description Disk space reclaimed (MB) */
      reclaimedSpaceMb?: number;
      /** @description Number of containers removed */
      removedContainers?: number;
      /** @description Number of networks removed */
      removedNetworks?: number;
      /** @description Number of volumes removed */
      removedVolumes?: number;
      /** @description Number of images removed */
      removedImages?: number;
      /** @description Non-fatal errors during cleanup */
      errors?: string[];
      /** @description Human-readable cleanup summary */
      message?: string;
    };
    /** @description Response containing log entries from a service or container */
    LogsResponse: {
      /** @description Service name (if queried by service) */
      service?: string;
      /** @description Container ID/name */
      container?: string;
      /** @description Log entries matching the query */
      logs: components['schemas']['LogEntry'][];
      /** @description Whether output was truncated */
      truncated?: boolean;
    };
    /** @description A single log entry with timestamp, stream, and message content */
    LogEntry: {
      /**
       * Format: date-time
       * @description When this log entry was recorded
       */
      timestamp: string;
      /**
       * @description Output stream type (stdout or stderr)
       * @enum {string}
       */
      stream?: 'stdout' | 'stderr';
      /** @description Log message content */
      message: string;
    };
    /** @description Request to apply incremental changes to the current service topology */
    TopologyUpdateRequest: {
      /** @description List of topology changes to apply */
      changes: components['schemas']['TopologyChange'][];
      /**
       * @description How the topology update should be performed
       * @default graceful
       */
      mode: components['schemas']['DeploymentMode'];
      /**
       * @description Timeout for topology update
       * @default 120
       */
      timeout: number;
    };
    /** @description A single topology modification such as adding a node, moving a service, or scaling */
    TopologyChange: {
      /**
       * @description Type of topology change
       * @enum {string}
       */
      action: 'add-node' | 'remove-node' | 'move-service' | 'scale' | 'update-env';
      /** @description Target node name */
      nodeName?: string;
      /** @description Services affected by this change */
      services?: string[];
      /** @description New replica count (for scale action) */
      replicas?: number;
      /** @description Environment updates (for update-env action) */
      environment?: {
        [key: string]: string;
      };
      /** @description Full node config (for add-node action) */
      nodeConfig?: components['schemas']['TopologyNode'];
    };
    /** @description Result of a topology update including applied changes and the new topology state */
    TopologyUpdateResponse: {
      /** @description Whether all topology changes were applied successfully (false indicates partial failure) */
      success: boolean;
      /** @description Details of each applied change */
      appliedChanges: components['schemas']['AppliedChange'][];
      /** @description New topology after changes */
      topology?: components['schemas']['ServiceTopology'];
      /** @description Time taken to apply topology changes */
      duration?: string;
      /** @description Non-fatal warnings during topology update */
      warnings?: string[];
      /** @description Human-readable update summary */
      message?: string;
    };
    /** @description Details of a single topology change that was applied, including success status */
    AppliedChange: {
      /** @description Type of topology change that was applied */
      action: string;
      /** @description Node or service affected */
      target?: string;
      /** @description Whether this specific change was applied successfully */
      success: boolean;
      /** @description Error message if failed */
      error?: string;
    };
    /**
     * @description Published when deployment state changes.
     *     Topic: bannou.deployment-events
     */
    DeploymentEvent: {
      /** @description Unique identifier for this event */
      eventId: string;
      /**
       * Format: date-time
       * @description When this event occurred
       */
      timestamp: string;
      /**
       * @description Type of deployment action that triggered this event
       * @enum {string}
       */
      action: 'started' | 'completed' | 'failed' | 'topology-changed';
      /** @description Unique identifier for the deployment */
      deploymentId: string;
      /** @description Preset name used for deployment (if applicable) */
      preset?: string | null;
      /** @description Container orchestration backend used */
      backend?: components['schemas']['BackendType'];
      /** @description Summary of changes made */
      changes?: string[];
      /** @description Error message if failed */
      error?: string | null;
    };
    /**
     * @description Published when a service is restarted.
     *     Topic: bannou.service-lifecycle
     */
    ServiceRestartEvent: {
      /** @description Unique identifier for this event */
      eventId: string;
      /** @description Name of the service that was restarted */
      serviceName: string;
      /** @description Reason for the restart */
      reason: string;
      /** @description Whether restart was forced without waiting for graceful shutdown */
      forced?: boolean;
      /** @description Environment variables updated during restart */
      newEnvironment?: {
        [key: string]: string;
      };
    };
    /**
     * @description Published by orchestrator when configuration or secrets change.
     *     All containers receive this event via RabbitMQ. Plugins decide if they care
     *     based on the changedKeys prefixes and request restart if needed.
     *     Topic: bannou.configuration-events
     */
    ConfigurationChangedEvent: {
      /** @description Unique identifier for this event instance */
      eventId: string;
      /**
       * Format: date-time
       * @description When this configuration change occurred
       */
      timestamp: string;
      /** @description Monotonically increasing version number */
      configVersion: number;
      /**
       * @description Configuration keys that changed (not values for security).
       *     Key prefixes indicate scope:
       *     - "auth.*" - Authentication-related
       *     - "database.*" - Database connections
       *     - "mesh.*" - Mesh components (typically global impact)
       *     - "connect.*" - WebSocket/connection settings
       */
      changedKeys: string[];
    };
    /**
     * @description Restart urgency level:
     *     - graceful: Rolling update, wait for healthy before cycling next instance
     *     - immediate: Rolling update but don't wait for connection drain
     *     - force: Kill all instances simultaneously (causes downtime)
     * @enum {string}
     */
    RestartPriority: 'graceful' | 'immediate' | 'force';
    /** @description Request to restart a container */
    ContainerRestartRequest: {
      /**
       * @description Why restart is needed (for logging/auditing)
       * @example configuration_change
       */
      reason: string;
      /**
       * @description Urgency level for the restart
       * @default graceful
       */
      priority: components['schemas']['RestartPriority'];
      /**
       * @description Seconds to allow graceful shutdown before force-kill
       * @default 30
       */
      shutdownGracePeriod: number;
    };
    /** @description Response after accepting a container restart request with scheduling details */
    ContainerRestartResponse: {
      /** @description Whether the restart request was accepted */
      accepted: boolean;
      /** @description Container that will be restarted */
      appName: string;
      /**
       * Format: date-time
       * @description When restart is scheduled (may be queued)
       */
      scheduledFor?: string;
      /** @description Number of running instances */
      currentInstances?: number;
      /**
       * @description How restart will be performed
       * @enum {string}
       */
      restartStrategy?: 'rolling' | 'simultaneous';
      /** @description Additional information */
      message?: string;
    };
    /** @description Current status of a container including health, restart history, and running plugins */
    ContainerStatus: {
      /** @description Container's app-id for mesh routing */
      appName: string;
      /**
       * @description Current container status
       * @enum {string}
       */
      status: 'running' | 'starting' | 'stopping' | 'stopped' | 'unhealthy';
      /**
       * Format: date-time
       * @description When this status was captured
       */
      timestamp: string;
      /** @description Number of running instances */
      instances?: number;
      /** @description Plugins running in this container */
      plugins?: string[];
      /**
       * Format: date-time
       * @description When container was last restarted
       */
      lastRestart?: string;
      /** @description Number of restarts in last 24 hours */
      restartCount?: number;
      /** @description Recent restart history */
      restartHistory?: components['schemas']['RestartHistoryEntry'][];
      /** @description Health check configuration and current health status results */
      healthChecks?: components['schemas']['HealthChecks'];
      /** @description Container labels for metadata and management */
      labels?: {
        [key: string]: string;
      };
    };
    /** @description Record of a past container restart including reason, timing, and outcome */
    RestartHistoryEntry: {
      /**
       * Format: date-time
       * @description When the restart occurred
       */
      timestamp: string;
      /** @description Why the restart was triggered */
      reason: string;
      /** @description Priority level used for the restart */
      priority?: components['schemas']['RestartPriority'];
      /** @description Time taken to restart */
      duration?: string;
      /** @description Whether the restart completed successfully */
      success?: boolean;
      /** @description Error message if restart failed */
      error?: string;
    };
    /** @description Request to rollback configuration to the previous version */
    ConfigRollbackRequest: {
      /**
       * @description Why rollback is needed (for auditing)
       * @example auth.jwt_secret broke authentication
       */
      reason: string;
    };
    /** @description Result of a configuration rollback including version changes and affected keys */
    ConfigRollbackResponse: {
      /** @description Config version before rollback */
      previousVersion: number;
      /** @description Config version after rollback (now active) */
      currentVersion: number;
      /** @description Keys that were reverted */
      changedKeys?: string[];
      /** @description Human-readable rollback summary */
      message?: string;
    };
    /** @description Current configuration version information with metadata about available keys */
    ConfigVersionResponse: {
      /** @description Current configuration version number */
      version: number;
      /**
       * Format: date-time
       * @description When current config was applied
       */
      timestamp: string;
      /** @description Whether a previous config is available for rollback */
      hasPreviousConfig?: boolean;
      /** @description Number of configuration keys (not values for security) */
      keyCount?: number;
      /** @description Configuration key prefixes present (e.g., "auth", "database") */
      keyPrefixes?: string[];
    };
    /** @description Request to acquire a processor instance from a processing pool */
    AcquireProcessorRequest: {
      /** @description Type of processing pool (e.g., "asset-processor", "texture-processor") */
      poolType: string;
      /**
       * @description Request priority (higher = more urgent)
       * @default 0
       */
      priority: number;
      /**
       * @description How long the lease is valid for
       * @default 300
       */
      timeoutSeconds: number;
      /** @description Optional metadata about the processing job (null if not needed) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response with acquired processor details including lease information */
    AcquireProcessorResponse: {
      /** @description Unique identifier for this processor instance */
      processorId: string;
      /** @description App-id for mesh service invocation to this processor */
      appId: string;
      /**
       * Format: uuid
       * @description Unique lease identifier (used for release)
       */
      leaseId: string;
      /**
       * Format: date-time
       * @description When the lease expires (must release before this)
       */
      expiresAt: string;
    };
    /** @description Request to release a processor back to the pool after processing completes */
    ReleaseProcessorRequest: {
      /**
       * Format: uuid
       * @description The lease ID returned from AcquireProcessor
       */
      leaseId: string;
      /**
       * @description Whether the processing completed successfully
       * @default true
       */
      success: boolean;
      /** @description Optional processing metrics (duration, items processed, etc.) */
      metrics?: {
        [key: string]: unknown;
      };
    };
    /** @description Confirmation that a processor was released back to the pool */
    ReleaseProcessorResponse: {
      /** @description Whether the processor was successfully released */
      released: boolean;
      /** @description ID of the released processor */
      processorId?: string;
    };
    /** @description Request to retrieve status and metrics for a processing pool */
    GetPoolStatusRequest: {
      /** @description Type of processing pool to query */
      poolType: string;
      /**
       * @description Include recent processing metrics
       * @default true
       */
      includeMetrics: boolean;
    };
    /** @description Current status of a processing pool including instance counts and utilization */
    PoolStatusResponse: {
      /** @description Pool type */
      poolType: string;
      /** @description Total processor instances in the pool */
      totalInstances: number;
      /** @description Instances ready to accept work */
      availableInstances: number;
      /** @description Instances currently processing */
      busyInstances: number;
      /** @description Number of requests waiting for a processor */
      queueDepth?: number;
      /**
       * Format: float
       * @description Current utilization percentage (0.0 to 1.0)
       */
      utilization: number;
      /** @description Minimum configured instances */
      minInstances?: number;
      /** @description Maximum configured instances */
      maxInstances?: number;
      /**
       * Format: float
       * @description Utilization threshold for auto-scale-up
       */
      scaleUpThreshold?: number;
      /** @description Recent processing statistics */
      recentMetrics?: components['schemas']['PoolMetrics'];
    };
    /** @description Processing pool performance metrics */
    PoolMetrics: {
      /** @description Jobs completed in the last hour */
      jobsCompleted1h?: number;
      /** @description Jobs failed in the last hour */
      jobsFailed1h?: number;
      /** @description Average processing time in milliseconds */
      avgProcessingTimeMs?: number;
      /**
       * Format: date-time
       * @description When the pool was last scaled
       */
      lastScaleEvent?: string;
    };
    /** @description Request to scale a processing pool to a target number of instances */
    ScalePoolRequest: {
      /** @description Type of processing pool to scale */
      poolType: string;
      /** @description Desired number of instances */
      targetInstances: number;
      /**
       * @description Force scale even if it would interrupt processing
       * @default false
       */
      force: boolean;
    };
    /** @description Result of a pool scaling operation with before and after instance counts */
    ScalePoolResponse: {
      /** @description Pool type that was scaled */
      poolType: string;
      /** @description Instance count before scaling */
      previousInstances: number;
      /** @description Instance count after scaling */
      currentInstances: number;
      /** @description Number of instances added */
      scaledUp?: number;
      /** @description Number of instances removed */
      scaledDown?: number;
      /** @description Status message */
      message?: string;
    };
    /** @description Request to clean up idle processor instances from a pool */
    CleanupPoolRequest: {
      /** @description Type of processing pool to cleanup */
      poolType: string;
      /**
       * @description Keep at least minInstances running
       * @default true
       */
      preserveMinimum: boolean;
    };
    /** @description Result of a pool cleanup operation with removed instance count */
    CleanupPoolResponse: {
      /** @description Pool type that was cleaned up */
      poolType: string;
      /** @description Number of idle instances removed */
      instancesRemoved: number;
      /** @description Instance count after cleanup */
      currentInstances?: number;
      /** @description Status message */
      message?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  GetInfrastructureHealth: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InfrastructureHealthRequest'];
      };
    };
    responses: {
      /** @description Infrastructure health status (check response body for component health) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InfrastructureHealthResponse'];
        };
      };
    };
  };
  GetServicesHealth: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ServiceHealthRequest'];
      };
    };
    responses: {
      /** @description Service health report */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ServiceHealthReport'];
        };
      };
    };
  };
  RestartService: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ServiceRestartRequest'];
      };
    };
    responses: {
      /** @description Service restarted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ServiceRestartResult'];
        };
      };
      /** @description Invalid restart request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Service restart not needed (healthy status) */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ShouldRestartService: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ShouldRestartServiceRequest'];
      };
    };
    responses: {
      /** @description Restart recommendation */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RestartRecommendation'];
        };
      };
    };
  };
  GetBackends: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListBackendsRequest'];
      };
    };
    responses: {
      /** @description Available backends with capabilities */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BackendsResponse'];
        };
      };
    };
  };
  GetPresets: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListPresetsRequest'];
      };
    };
    responses: {
      /** @description Available deployment presets */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PresetsResponse'];
        };
      };
    };
  };
  Deploy: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeployRequest'];
      };
    };
    responses: {
      /** @description Deployment initiated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeployResponse'];
        };
      };
      /** @description Invalid deployment configuration */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Backend not available (when explicitly requested) */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Deployment failed */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetServiceRouting: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetServiceRoutingRequest'];
      };
    };
    responses: {
      /** @description Service routing mappings */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ServiceRoutingResponse'];
        };
      };
    };
  };
  GetStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetStatusRequest'];
      };
    };
    responses: {
      /** @description Current environment status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EnvironmentStatus'];
        };
      };
    };
  };
  Teardown: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TeardownRequest'];
      };
    };
    responses: {
      /** @description Teardown completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TeardownResponse'];
        };
      };
      /** @description Teardown failed */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  Clean: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CleanRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CleanResponse'];
        };
      };
      /** @description Cleanup failed */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetLogs: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLogsRequest'];
      };
    };
    responses: {
      /** @description Switching to WebSocket for streaming (when follow=true) */
      101: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Log output */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogsResponse'];
          'text/plain': string;
        };
      };
      /** @description Service or container not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateTopology: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TopologyUpdateRequest'];
      };
    };
    responses: {
      /** @description Topology update applied */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TopologyUpdateResponse'];
        };
      };
      /** @description Invalid topology configuration */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Topology change conflicts with current state */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Topology update failed */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  RequestContainerRestart: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ContainerRestartRequestBody'];
      };
    };
    responses: {
      /** @description Restart request accepted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContainerRestartResponse'];
        };
      };
      /** @description Invalid restart request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Container not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetContainerStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetContainerStatusRequest'];
      };
    };
    responses: {
      /** @description Container status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContainerStatus'];
        };
      };
      /** @description Container not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  RollbackConfiguration: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConfigRollbackRequest'];
      };
    };
    responses: {
      /** @description Rollback completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ConfigRollbackResponse'];
        };
      };
      /** @description No previous configuration to rollback to */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rollback failed */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetConfigVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetConfigVersionRequest'];
      };
    };
    responses: {
      /** @description Configuration version info */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ConfigVersionResponse'];
        };
      };
    };
  };
  AcquireProcessor: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AcquireProcessorRequest'];
      };
    };
    responses: {
      /** @description Processor acquired successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AcquireProcessorResponse'];
        };
      };
      /** @description No processors available (all busy or pool at capacity) */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ReleaseProcessor: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReleaseProcessorRequest'];
      };
    };
    responses: {
      /** @description Processor released successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReleaseProcessorResponse'];
        };
      };
      /** @description Processor or lease not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetPoolStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetPoolStatusRequest'];
      };
    };
    responses: {
      /** @description Pool status retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PoolStatusResponse'];
        };
      };
    };
  };
  ScalePool: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ScalePoolRequest'];
      };
    };
    responses: {
      /** @description Pool scaled successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScalePoolResponse'];
        };
      };
      /** @description Invalid scale request (exceeds limits) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CleanupPool: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CleanupPoolRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CleanupPoolResponse'];
        };
      };
    };
  };
}
