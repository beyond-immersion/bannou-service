/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/scene/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new scene document
     * @description Creates a new scene document and stores it in lib-asset.
     *     Publishes scene.created event on success.
     *     Returns Conflict if a scene with the same sceneId already exists.
     */
    post: operations['createScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Retrieve a scene by ID
     * @description Retrieves a scene document. Optionally resolves nested scene references
     *     up to a configurable depth.
     */
    post: operations['getScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List scenes with filtering
     * @description Lists scenes matching the provided filters. Supports pagination.
     *     Results are ordered by updatedAt descending (most recent first).
     */
    post: operations['listScenes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a scene document
     * @description Updates an existing scene document. Scene must not be checked out by
     *     another user. Increments the PATCH version automatically.
     *     Publishes scene.updated event on success.
     */
    post: operations['updateScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a scene
     * @description Soft-deletes a scene. The scene data remains recoverable via lib-asset
     *     for approximately 30 days. Cannot delete if other scenes reference this one.
     *     Publishes scene.deleted event on success.
     */
    post: operations['deleteScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate a scene structure
     * @description Validates a scene document without saving it. Checks structural validity
     *     and optionally applies game-specific validation rules.
     */
    post: operations['validateScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/instantiate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Declare that a scene was instantiated in the game world
     * @description Records a scene instantiation and publishes an event. This is a
     *     NOTIFICATION endpoint - the caller has already instantiated the scene.
     *
     *     1. Validates scene exists and is accessible
     *     2. Publishes scene.instantiated event
     *
     *     Consumers (Mapping, Actor, etc.) react to the event independently.
     */
    post: operations['instantiateScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/destroy-instance': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Declare that a scene instance was removed
     * @description Records instance destruction and publishes an event.
     *     Consumers react to clean up spatial data, despawn NPCs, etc.
     */
    post: operations['destroyInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/checkout': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Lock a scene for editing
     * @description Acquires an exclusive lock on the scene for editing.
     *     Returns a checkout token required for commit.
     *     Lock expires after TTL if not extended via heartbeat.
     */
    post: operations['checkoutScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/commit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Save changes and release lock
     * @description Commits the changes made during checkout, increments version,
     *     and releases the lock. Publishes scene.committed event.
     */
    post: operations['commitScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/discard': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Release lock without saving changes
     * @description Discards any changes and releases the checkout lock.
     *     Scene remains at its pre-checkout version.
     */
    post: operations['discardCheckout'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/heartbeat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Extend checkout lock TTL
     * @description Extends the checkout lock TTL. Should be called periodically
     *     during editing to prevent lock expiration.
     */
    post: operations['heartbeatCheckout'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/history': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get version history for a scene
     * @description Returns the version history for a scene, up to the configured
     *     retention limit per gameId.
     */
    post: operations['getSceneHistory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/register-validation-rules': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Register validation rules for a gameId+sceneType
     * @description Registers game-specific validation rules. Replaces any existing
     *     rules for the gameId+sceneType combination.
     */
    post: operations['registerValidationRules'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/get-validation-rules': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get validation rules for a gameId+sceneType
     * @description Retrieves the registered validation rules for a specific
     *     gameId and sceneType combination.
     */
    post: operations['getValidationRules'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Full-text search across scenes
     * @description Searches scene names, descriptions, tags, and node names
     *     for matching content.
     */
    post: operations['searchScenes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/find-references': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find scenes that reference a given scene
     * @description Returns all scenes that contain reference nodes pointing
     *     to the specified scene.
     */
    post: operations['findReferences'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/find-asset-usage': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find scenes using a specific asset
     * @description Returns all scenes containing nodes that reference
     *     a specific asset ID.
     */
    post: operations['findAssetUsage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/duplicate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Duplicate a scene with a new ID
     * @description Creates a copy of a scene with a new sceneId and name.
     *     All node IDs are regenerated. Version resets to 1.0.0.
     */
    post: operations['duplicateScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /**
     * @description Scene classification for querying and validation rule lookup.
     *     Different types may have different validation requirements per game.
     * @enum {string}
     */
    SceneType:
      | 'unknown'
      | 'region'
      | 'city'
      | 'district'
      | 'lot'
      | 'building'
      | 'room'
      | 'dungeon'
      | 'arena'
      | 'vehicle'
      | 'prefab'
      | 'cutscene'
      | 'other';
    /**
     * @description Structural node type. Indicates what kind of data the node contains,
     *     not how it will be used at runtime. Consumers interpret nodes according
     *     to their own needs via tags and annotations.
     * @enum {string}
     */
    NodeType: 'group' | 'mesh' | 'marker' | 'volume' | 'emitter' | 'reference' | 'custom';
    /**
     * @description Shape of a volume node for spatial bounds
     * @enum {string}
     */
    VolumeShape: 'box' | 'sphere' | 'capsule' | 'cylinder';
    /**
     * @description Types of affordances describing what an object can do or how it can be interacted with.
     *     Used by AI navigation, character controllers, and procedural content systems.
     * @enum {string}
     */
    AffordanceType:
      | 'walkable'
      | 'climbable'
      | 'sittable'
      | 'interactive'
      | 'collectible'
      | 'destructible'
      | 'container'
      | 'door'
      | 'teleport';
    /**
     * @description Types of marker nodes for spawn points, waypoints, and other positional markers.
     * @enum {string}
     */
    MarkerType:
      | 'generic'
      | 'spawn_point'
      | 'npc_spawn'
      | 'waypoint'
      | 'camera_point'
      | 'light_point'
      | 'audio_point'
      | 'trigger_point';
    /**
     * @description A predefined location where child objects can be attached.
     *     Used for decorating furniture, walls, and other objects with accessories.
     *     Example: A wall may have attachment points for paintings, shelves, or light fixtures.
     */
    AttachmentPoint: {
      /**
       * @description Unique name for this attachment point within the node.
       *     Examples: wall_hook_left, shelf_1, lamp_socket
       */
      name: string;
      /** @description Position and orientation relative to the owning node */
      localTransform: components['schemas']['Transform'];
      /**
       * @description Tags of assets that can attach here.
       *     Examples: wall_decoration, picture_frame, plant
       */
      acceptsTags?: string[];
      /** @description Default asset to display if no specific attachment is specified */
      defaultAsset?: components['schemas']['AssetReference'];
      /**
       * Format: uuid
       * @description ID of the node currently attached at this point (runtime state)
       */
      attachedNodeId?: string | null;
    };
    /**
     * @description Describes a capability or interaction mode for a node.
     *     Used by AI systems to understand what actions are possible and by
     *     character controllers for contextual animations.
     */
    Affordance: {
      /** @description The type of affordance */
      type: components['schemas']['AffordanceType'];
      /**
       * @description Type-specific parameters. Examples:
       *     - sittable: { height: 0.5, facing: [0,0,1] }
       *     - door: { openAngle: 90, locked: false }
       *     - container: { capacity: 10, itemTypes: ["weapon", "consumable"] }
       */
      parameters?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Defines acceptable asset types for procedural swapping at this node.
     *     Used by procedural generation systems to substitute assets while
     *     maintaining scene coherence.
     */
    AssetSlot: {
      /**
       * @description Category of acceptable assets.
       *     Examples: chair, table, wall_art, floor_lamp
       */
      slotType: string;
      /**
       * @description Tags that acceptable assets must have.
       *     Used for filtering when selecting random variations.
       */
      acceptsTags?: string[];
      /** @description Default asset if no specific asset is bound */
      defaultAsset?: components['schemas']['AssetReference'];
      /**
       * @description Pre-approved asset variations for random selection.
       *     Procedural systems pick from this list rather than searching all assets.
       */
      variations?: components['schemas']['AssetReference'][];
    };
    /**
     * @description Reason why a scene reference could not be resolved
     * @enum {string}
     */
    UnresolvedReferenceReason:
      | 'not_found'
      | 'circular_reference'
      | 'depth_exceeded'
      | 'access_denied';
    /**
     * @description Severity level of a validation issue
     * @enum {string}
     */
    ValidationSeverity: 'error' | 'warning';
    /**
     * @description Type of validation check to perform
     * @enum {string}
     */
    ValidationRuleType:
      | 'require_tag'
      | 'require_node_type'
      | 'forbid_tag'
      | 'require_annotation'
      | 'custom_expression';
    /**
     * @description Where the search match was found
     * @enum {string}
     */
    SearchMatchType: 'name' | 'description' | 'tag' | 'node_name';
    /** @description A point or direction in 3D space */
    Vector3: {
      /**
       * Format: double
       * @description X coordinate
       */
      x: number;
      /**
       * Format: double
       * @description Y coordinate
       */
      y: number;
      /**
       * Format: double
       * @description Z coordinate
       */
      z: number;
    };
    /** @description Rotation represented as a quaternion */
    Quaternion: {
      /**
       * Format: double
       * @description X component
       */
      x: number;
      /**
       * Format: double
       * @description Y component
       */
      y: number;
      /**
       * Format: double
       * @description Z component
       */
      z: number;
      /**
       * Format: double
       * @description W component (scalar)
       */
      w: number;
    };
    /** @description Position, rotation, and scale in 3D space */
    Transform: {
      /** @description Position relative to parent */
      position: components['schemas']['Vector3'];
      /** @description Rotation relative to parent */
      rotation: components['schemas']['Quaternion'];
      /** @description Scale relative to parent */
      scale: components['schemas']['Vector3'];
    };
    /** @description Reference to an asset in lib-asset */
    AssetReference: {
      /**
       * Format: uuid
       * @description Optional bundle containing the asset
       */
      bundleId?: string | null;
      /**
       * Format: uuid
       * @description Asset identifier in lib-asset
       */
      assetId: string;
      /** @description Variant identifier (consumer interprets meaning) */
      variantId?: string | null;
    };
    /**
     * @description A node in the scene hierarchy. Nodes can contain children to form
     *     a tree structure. Each node has a local transform relative to its parent.
     */
    SceneNode: {
      /**
       * Format: uuid
       * @description Globally unique node identifier
       */
      nodeId: string;
      /**
       * @description Scene-local reference identifier. Must be unique within the scene.
       *     Used for scripting and cross-referencing. Examples: main_door, npc_spawn_1
       */
      refId: string;
      /**
       * Format: uuid
       * @description Parent node ID. Null for the root node only.
       */
      parentNodeId?: string | null;
      /** @description Human-readable display name for the node */
      name: string;
      /** @description The structural type of this node */
      nodeType: components['schemas']['NodeType'];
      /** @description Transform relative to parent node */
      localTransform: components['schemas']['Transform'];
      /** @description Optional asset binding (mesh, sound, particle effect) */
      asset?: components['schemas']['AssetReference'];
      /** @description Child nodes in the hierarchy */
      children?: components['schemas']['SceneNode'][];
      /**
       * @description Whether this node is active in the scene definition
       * @default true
       */
      enabled: boolean;
      /**
       * @description Ordering among siblings for deterministic iteration
       * @default 0
       */
      sortOrder: number;
      /** @description Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive) */
      tags?: string[];
      /**
       * @description Consumer-specific data stored without interpretation.
       *     Use namespaced keys (e.g., render.castShadows, arcadia.interactionType).
       */
      annotations?: {
        [key: string]: unknown;
      } | null;
      /**
       * @description Predefined locations for attaching child objects.
       *     Used by Scene Composer for furniture decoration, wall accessories, etc.
       */
      attachmentPoints?: components['schemas']['AttachmentPoint'][];
      /**
       * @description Interaction capabilities of this node.
       *     Used by AI navigation and character controllers.
       */
      affordances?: components['schemas']['Affordance'][];
      /**
       * @description Procedural asset swapping configuration.
       *     Defines which assets can substitute for this node's asset.
       */
      assetSlot?: components['schemas']['AssetSlot'];
      /**
       * @description Type of marker for marker nodes.
       *     Only relevant when nodeType is 'marker'.
       */
      markerType?: components['schemas']['MarkerType'];
      /**
       * @description Shape of volume for volume nodes.
       *     Only relevant when nodeType is 'volume'.
       */
      volumeShape?: components['schemas']['VolumeShape'];
      /**
       * @description Size/extents of the volume (interpretation depends on volumeShape).
       *     For box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.
       */
      volumeSize?: components['schemas']['Vector3'];
      /**
       * Format: uuid
       * @description Scene ID to embed for reference nodes.
       *     Only relevant when nodeType is 'reference'.
       */
      referenceSceneId?: string | null;
    };
    /** @description A complete scene document with hierarchical node structure */
    Scene: {
      /**
       * @description Schema identifier for validation
       * @default bannou://schemas/scene/v1
       */
      schema: string;
      /**
       * Format: uuid
       * @description Unique scene identifier
       */
      sceneId: string;
      /**
       * @description Game service identifier for partitioning. Treated as opaque string.
       *     Default is the nil UUID for unpartitioned scenes.
       * @default 00000000-0000-0000-0000-000000000000
       */
      gameId: string;
      /** @description Scene classification for querying and validation */
      sceneType: components['schemas']['SceneType'];
      /** @description Human-readable scene name */
      name: string;
      /** @description Optional scene description */
      description?: string | null;
      /** @description Semantic version (MAJOR.MINOR.PATCH) */
      version: string;
      /** @description Root node of the scene hierarchy */
      root: components['schemas']['SceneNode'];
      /** @description Searchable tags for filtering scenes */
      tags?: string[];
      /**
       * @description Scene-level metadata. Not interpreted by Scene service.
       *     Examples: author, thumbnail, editor preferences, generator config.
       */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When the scene was first created
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description When the scene was last modified
       */
      updatedAt?: string;
    };
    /** @description Request to create a new scene */
    CreateSceneRequest: {
      /** @description The scene document to create */
      scene: components['schemas']['Scene'];
    };
    /** @description Request to retrieve a scene */
    GetSceneRequest: {
      /**
       * Format: uuid
       * @description ID of the scene to retrieve
       */
      sceneId: string;
      /** @description Specific version to retrieve (null = latest) */
      version?: string | null;
      /**
       * @description Whether to resolve and embed referenced scenes
       * @default false
       */
      resolveReferences: boolean;
      /**
       * @description Maximum depth for reference resolution (prevents infinite recursion)
       * @default 3
       */
      maxReferenceDepth: number;
    };
    /** @description Response containing a scene and resolution metadata */
    GetSceneResponse: {
      /** @description The retrieved scene */
      scene: components['schemas']['Scene'];
      /** @description List of resolved references (if resolveReferences was true) */
      resolvedReferences?: components['schemas']['ResolvedReference'][] | null;
      /** @description References that could not be resolved (circular, missing, depth exceeded) */
      unresolvedReferences?: components['schemas']['UnresolvedReference'][] | null;
      /** @description Error messages for reference resolution issues */
      resolutionErrors?: string[] | null;
    };
    /** @description A successfully resolved scene reference */
    ResolvedReference: {
      /**
       * Format: uuid
       * @description Node ID containing the reference
       */
      nodeId: string;
      /** @description refId of the referencing node */
      refId: string;
      /**
       * Format: uuid
       * @description ID of the referenced scene
       */
      referencedSceneId: string;
      /** @description Version that was resolved */
      referencedVersion?: string | null;
      /** @description The resolved scene content */
      scene: components['schemas']['Scene'];
      /** @description Depth level of this reference */
      depth?: number;
    };
    /** @description A scene reference that could not be resolved */
    UnresolvedReference: {
      /**
       * Format: uuid
       * @description Node ID containing the reference
       */
      nodeId: string;
      /** @description refId of the referencing node */
      refId: string;
      /**
       * Format: uuid
       * @description ID of the scene that could not be resolved
       */
      referencedSceneId: string;
      /** @description Why the reference could not be resolved */
      reason: components['schemas']['UnresolvedReferenceReason'];
      /** @description For circular references, the cycle path (sceneId chain) */
      cyclePath?: string[] | null;
    };
    /** @description Request to list scenes with optional filters */
    ListScenesRequest: {
      /** @description Filter by game ID */
      gameId?: string | null;
      /** @description Filter by single scene type */
      sceneType?: components['schemas']['SceneType'];
      /** @description Filter by multiple scene types (OR) */
      sceneTypes?: components['schemas']['SceneType'][] | null;
      /** @description Filter by tags (scenes must have ALL specified tags) */
      tags?: string[] | null;
      /** @description Filter by name containing this substring (case-insensitive) */
      nameContains?: string | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results to return
       * @default 50
       */
      limit: number;
    };
    /** @description Response containing scene list and pagination info */
    ListScenesResponse: {
      /** @description List of scene summaries (not full documents) */
      scenes: components['schemas']['SceneSummary'][];
      /** @description Total number of matching scenes */
      total: number;
      /** @description Current offset */
      offset?: number;
      /** @description Applied limit */
      limit?: number;
    };
    /** @description Summary of a scene for list results (excludes full node tree) */
    SceneSummary: {
      /**
       * Format: uuid
       * @description Unique scene identifier
       */
      sceneId: string;
      /** @description Game service identifier */
      gameId: string;
      /** @description Scene classification */
      sceneType: components['schemas']['SceneType'];
      /** @description Scene name */
      name: string;
      /** @description Scene description */
      description?: string | null;
      /** @description Current version */
      version: string;
      /** @description Scene tags */
      tags?: string[];
      /** @description Total number of nodes in scene */
      nodeCount?: number;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description Last update timestamp
       */
      updatedAt?: string;
      /** @description Whether scene is currently checked out */
      isCheckedOut?: boolean;
    };
    /** @description Request to update an existing scene */
    UpdateSceneRequest: {
      /** @description The updated scene document (sceneId must match existing) */
      scene: components['schemas']['Scene'];
      /** @description Checkout token if updating via checkout workflow */
      checkoutToken?: string | null;
    };
    /** @description Request to delete a scene */
    DeleteSceneRequest: {
      /**
       * Format: uuid
       * @description ID of the scene to delete
       */
      sceneId: string;
      /** @description Optional reason for deletion (included in event) */
      reason?: string | null;
    };
    /** @description Response confirming scene deletion */
    DeleteSceneResponse: {
      /** @description Whether the scene was successfully deleted */
      deleted: boolean;
      /**
       * Format: uuid
       * @description ID of the deleted scene
       */
      sceneId?: string;
      /** @description If deletion failed, IDs of scenes that reference this one */
      referencingScenes?: string[] | null;
    };
    /** @description Standard response containing a scene */
    SceneResponse: {
      /** @description The scene document */
      scene: components['schemas']['Scene'];
    };
    /** @description Request to validate a scene structure */
    ValidateSceneRequest: {
      /** @description The scene to validate */
      scene: components['schemas']['Scene'];
      /**
       * @description Whether to apply registered game-specific validation rules
       * @default true
       */
      applyGameRules: boolean;
    };
    /** @description Result of scene validation */
    ValidationResult: {
      /** @description Whether the scene passed all validation checks */
      valid: boolean;
      /** @description Validation errors (severity = error) */
      errors?: components['schemas']['ValidationError'][] | null;
      /** @description Validation warnings (severity = warning) */
      warnings?: components['schemas']['ValidationError'][] | null;
    };
    /** @description A single validation error or warning */
    ValidationError: {
      /** @description Identifier of the validation rule that triggered this */
      ruleId: string;
      /** @description Human-readable error message */
      message: string;
      /** @description Severity level */
      severity: components['schemas']['ValidationSeverity'];
      /** @description Path to the problematic node (e.g., root.children[0].children[2]) */
      nodePath?: string | null;
      /**
       * Format: uuid
       * @description ID of the problematic node
       */
      nodeId?: string | null;
      /** @description Additional context for the error */
      context?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to record a scene instantiation */
    InstantiateSceneRequest: {
      /**
       * Format: uuid
       * @description Scene asset ID that was instantiated
       */
      sceneAssetId: string;
      /** @description Specific version (null = validates latest exists) */
      version?: string | null;
      /**
       * Format: uuid
       * @description Caller-provided unique instance ID
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Region where scene was placed
       */
      regionId: string;
      /** @description World-space transform for scene origin */
      worldTransform: components['schemas']['Transform'];
      /** @description Caller-provided metadata passed to event */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response confirming instantiation */
    InstantiateSceneResponse: {
      /**
       * Format: uuid
       * @description The instance ID
       */
      instanceId: string;
      /** @description Version that was instantiated */
      sceneVersion: string;
      /** @description Whether the event was successfully published */
      eventPublished?: boolean;
    };
    /** @description Request to record instance destruction */
    DestroyInstanceRequest: {
      /**
       * Format: uuid
       * @description Instance ID to destroy
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Region where instance was (for event metadata)
       */
      regionId?: string | null;
      /**
       * Format: uuid
       * @description Scene asset ID (for event metadata)
       */
      sceneAssetId?: string | null;
      /** @description Caller-provided metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response confirming destruction */
    DestroyInstanceResponse: {
      /** @description Whether destruction was recorded */
      destroyed: boolean;
      /** @description Whether the event was successfully published */
      eventPublished?: boolean;
    };
    /** @description Request to checkout a scene for editing */
    CheckoutRequest: {
      /**
       * Format: uuid
       * @description Scene to checkout
       */
      sceneId: string;
      /** @description Optional editor identifier (defaults to caller identity) */
      editorId?: string | null;
      /** @description Custom lock TTL (uses default if not specified) */
      ttlMinutes?: number | null;
    };
    /** @description Response containing checkout token and scene */
    CheckoutResponse: {
      /** @description Token required for commit/discard/heartbeat */
      checkoutToken: string;
      /** @description Current scene document */
      scene: components['schemas']['Scene'];
      /**
       * Format: date-time
       * @description When the checkout lock expires
       */
      expiresAt: string;
    };
    /** @description Request to commit checkout changes */
    CommitRequest: {
      /**
       * Format: uuid
       * @description Scene being committed
       */
      sceneId: string;
      /** @description Checkout token from checkout response */
      checkoutToken: string;
      /** @description Updated scene document */
      scene: components['schemas']['Scene'];
      /** @description Optional summary of changes for audit */
      changesSummary?: string | null;
    };
    /** @description Response confirming commit */
    CommitResponse: {
      /** @description Whether commit was successful */
      committed: boolean;
      /** @description New version after commit */
      newVersion: string;
      /** @description Committed scene with updated metadata */
      scene?: components['schemas']['Scene'];
    };
    /** @description Request to discard checkout */
    DiscardRequest: {
      /**
       * Format: uuid
       * @description Scene to discard changes for
       */
      sceneId: string;
      /** @description Checkout token */
      checkoutToken: string;
    };
    /** @description Response confirming discard */
    DiscardResponse: {
      /** @description Whether discard was successful */
      discarded: boolean;
    };
    /** @description Request to extend checkout lock */
    HeartbeatRequest: {
      /**
       * Format: uuid
       * @description Scene being edited
       */
      sceneId: string;
      /** @description Checkout token */
      checkoutToken: string;
    };
    /** @description Response confirming lock extension */
    HeartbeatResponse: {
      /** @description Whether extension was successful */
      extended: boolean;
      /**
       * Format: date-time
       * @description New expiration time
       */
      newExpiresAt: string;
      /** @description Number of extensions remaining */
      extensionsRemaining?: number;
    };
    /** @description Request for scene version history */
    HistoryRequest: {
      /**
       * Format: uuid
       * @description Scene to get history for
       */
      sceneId: string;
      /**
       * @description Maximum versions to return
       * @default 10
       */
      limit: number;
    };
    /** @description Scene version history */
    HistoryResponse: {
      /**
       * Format: uuid
       * @description Scene ID
       */
      sceneId: string;
      /** @description Current active version */
      currentVersion?: string;
      /** @description Version history entries */
      versions: components['schemas']['VersionInfo'][];
    };
    /** @description Information about a specific version */
    VersionInfo: {
      /** @description Version string */
      version: string;
      /**
       * Format: date-time
       * @description When this version was created
       */
      createdAt: string;
      /** @description Who created this version */
      createdBy?: string | null;
      /** @description Summary of changes */
      changesSummary?: string | null;
      /** @description Node count at this version */
      nodeCount?: number;
    };
    /** @description Request to register validation rules */
    RegisterValidationRulesRequest: {
      /** @description Game ID for these rules */
      gameId: string;
      /** @description Scene type for these rules */
      sceneType: components['schemas']['SceneType'];
      /** @description Validation rules to register */
      rules: components['schemas']['ValidationRule'][];
    };
    /** @description Response confirming rule registration */
    RegisterValidationRulesResponse: {
      /** @description Whether registration was successful */
      registered: boolean;
      /** @description Number of rules registered */
      ruleCount: number;
    };
    /** @description Request to get validation rules */
    GetValidationRulesRequest: {
      /** @description Game ID */
      gameId: string;
      /** @description Scene type */
      sceneType: components['schemas']['SceneType'];
    };
    /** @description Response containing validation rules */
    GetValidationRulesResponse: {
      /** @description Game ID */
      gameId: string;
      /** @description Scene type */
      sceneType: components['schemas']['SceneType'];
      /** @description Registered rules (empty if none) */
      rules?: components['schemas']['ValidationRule'][];
    };
    /** @description A validation rule definition */
    ValidationRule: {
      /** @description Unique rule identifier within the gameId+sceneType */
      ruleId: string;
      /** @description Human-readable description of the rule */
      description: string;
      /** @description Whether violation is an error or warning */
      severity: components['schemas']['ValidationSeverity'];
      /** @description Type of validation check */
      ruleType: components['schemas']['ValidationRuleType'];
      /** @description Rule-specific configuration */
      config?: components['schemas']['ValidationRuleConfig'];
    };
    /** @description Configuration for a validation rule */
    ValidationRuleConfig: {
      /** @description Filter to nodes of this type (for require_tag) */
      nodeType?: string | null;
      /** @description Tag to check for */
      tag?: string | null;
      /** @description Minimum occurrences required */
      minCount?: number | null;
      /** @description Maximum occurrences allowed */
      maxCount?: number | null;
      /** @description JSONPath to required annotation field (for require_annotation) */
      annotationPath?: string | null;
      /** @description Custom validation expression (for custom_expression) */
      expression?: string | null;
    };
    /** @description Request for full-text search */
    SearchScenesRequest: {
      /** @description Search query text */
      query: string;
      /** @description Filter by game ID */
      gameId?: string | null;
      /** @description Filter by scene types */
      sceneTypes?: components['schemas']['SceneType'][] | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results
       * @default 50
       */
      limit: number;
    };
    /** @description Search results */
    SearchScenesResponse: {
      /** @description Matching scenes */
      results: components['schemas']['SearchResult'][];
      /** @description Total matches */
      total: number;
    };
    /** @description A single search result */
    SearchResult: {
      /** @description Matching scene summary */
      scene: components['schemas']['SceneSummary'];
      /** @description Where the match was found */
      matchType: components['schemas']['SearchMatchType'];
      /** @description Context around the match */
      matchContext?: string | null;
    };
    /** @description Request to find referencing scenes */
    FindReferencesRequest: {
      /**
       * Format: uuid
       * @description Scene ID to find references to
       */
      sceneId: string;
    };
    /** @description Scenes that reference the target */
    FindReferencesResponse: {
      /** @description Scenes containing references */
      referencingScenes: components['schemas']['ReferenceInfo'][];
    };
    /** @description Information about a reference */
    ReferenceInfo: {
      /**
       * Format: uuid
       * @description Scene containing the reference
       */
      sceneId: string;
      /** @description Name of the referencing scene */
      sceneName: string;
      /**
       * Format: uuid
       * @description Node containing the reference
       */
      nodeId: string;
      /** @description refId of the referencing node */
      nodeRefId: string;
      /** @description Name of the referencing node */
      nodeName?: string;
    };
    /** @description Request to find asset usage */
    FindAssetUsageRequest: {
      /**
       * Format: uuid
       * @description Asset ID to find usage of
       */
      assetId: string;
      /** @description Optional game filter */
      gameId?: string | null;
    };
    /** @description Scenes using the asset */
    FindAssetUsageResponse: {
      /** @description Asset usage instances */
      usages: components['schemas']['AssetUsageInfo'][];
    };
    /** @description Information about asset usage */
    AssetUsageInfo: {
      /**
       * Format: uuid
       * @description Scene using the asset
       */
      sceneId: string;
      /** @description Scene name */
      sceneName: string;
      /**
       * Format: uuid
       * @description Node using the asset
       */
      nodeId: string;
      /** @description refId of the node */
      nodeRefId: string;
      /** @description Node name */
      nodeName?: string;
      /** @description Type of the node */
      nodeType?: components['schemas']['NodeType'];
    };
    /** @description Request to duplicate a scene */
    DuplicateSceneRequest: {
      /**
       * Format: uuid
       * @description Scene to duplicate
       */
      sourceSceneId: string;
      /** @description Name for the duplicate */
      newName: string;
      /** @description Optional different game ID */
      newGameId?: string | null;
      /** @description Optional different scene type */
      newSceneType?: components['schemas']['SceneType'];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  createScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSceneRequest'];
      };
    };
    responses: {
      /** @description Scene created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SceneResponse'];
        };
      };
      /** @description Invalid scene structure (validation failed) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene with this sceneId already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSceneRequest'];
      };
    };
    responses: {
      /** @description Scene retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetSceneResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listScenes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListScenesRequest'];
      };
    };
    responses: {
      /** @description Scenes listed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListScenesResponse'];
        };
      };
    };
  };
  updateScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateSceneRequest'];
      };
    };
    responses: {
      /** @description Scene updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SceneResponse'];
        };
      };
      /** @description Invalid scene structure */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene is checked out by another user */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteSceneRequest'];
      };
    };
    responses: {
      /** @description Scene deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteSceneResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cannot delete - other scenes reference this scene */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  validateScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidateSceneRequest'];
      };
    };
    responses: {
      /** @description Validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidationResult'];
        };
      };
    };
  };
  instantiateScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InstantiateSceneRequest'];
      };
    };
    responses: {
      /** @description Instantiation recorded and event published */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InstantiateSceneResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  destroyInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DestroyInstanceRequest'];
      };
    };
    responses: {
      /** @description Destruction recorded and event published */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DestroyInstanceResponse'];
        };
      };
    };
  };
  checkoutScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckoutRequest'];
      };
    };
    responses: {
      /** @description Checkout successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CheckoutResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene already checked out by another user */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  commitScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CommitRequest'];
      };
    };
    responses: {
      /** @description Commit successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CommitResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Checkout expired */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  discardCheckout: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DiscardRequest'];
      };
    };
    responses: {
      /** @description Discard successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DiscardResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  heartbeatCheckout: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HeartbeatRequest'];
      };
    };
    responses: {
      /** @description Lock extended */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HeartbeatResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Checkout expired */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSceneHistory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HistoryRequest'];
      };
    };
    responses: {
      /** @description History retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HistoryResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  registerValidationRules: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterValidationRulesRequest'];
      };
    };
    responses: {
      /** @description Rules registered */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RegisterValidationRulesResponse'];
        };
      };
    };
  };
  getValidationRules: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetValidationRulesRequest'];
      };
    };
    responses: {
      /** @description Rules retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetValidationRulesResponse'];
        };
      };
    };
  };
  searchScenes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SearchScenesRequest'];
      };
    };
    responses: {
      /** @description Search results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SearchScenesResponse'];
        };
      };
    };
  };
  findReferences: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FindReferencesRequest'];
      };
    };
    responses: {
      /** @description Referencing scenes found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FindReferencesResponse'];
        };
      };
    };
  };
  findAssetUsage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FindAssetUsageRequest'];
      };
    };
    responses: {
      /** @description Asset usage found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FindAssetUsageResponse'];
        };
      };
    };
  };
  duplicateScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DuplicateSceneRequest'];
      };
    };
    responses: {
      /** @description Scene duplicated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SceneResponse'];
        };
      };
      /** @description Source scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
