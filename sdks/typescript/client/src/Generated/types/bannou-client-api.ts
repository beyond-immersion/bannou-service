/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/account/profile/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update account profile */
    post: operations['updateProfile'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/account/password/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update account password hash */
    post: operations['updatePasswordHash'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/account/mfa/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update MFA settings for an account
     * @description Sets or clears MFA-related fields (mfaEnabled, mfaSecret, mfaRecoveryCodes) atomically.
     *     Used by Auth service during MFA enable/disable flows. Auth owns the encryption logic;
     *     Account stores the opaque encrypted data.
     */
    post: operations['updateMfa'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/account/verification/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update email verification status */
    post: operations['updateVerificationStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/definition/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new achievement definition
     * @description Create a new achievement with specified criteria and platform mappings.
     *     Developer-only endpoint.
     */
    post: operations['createAchievementDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/definition/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List achievement definitions
     * @description List achievements for a game service with optional platform filtering.
     */
    post: operations['listAchievementDefinitions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/definition/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update achievement definition
     * @description Update properties of an existing achievement.
     *     Developer-only endpoint.
     */
    post: operations['updateAchievementDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/definition/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete achievement definition
     * @description Delete an achievement. Earned instances are preserved in history.
     *     Developer-only endpoint.
     */
    post: operations['deleteAchievementDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/progress/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get entity's achievement progress
     * @description Get progress for an entity across all achievements or a specific one.
     */
    post: operations['getAchievementProgress'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/list-unlocked': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List unlocked achievements
     * @description Get all achievements unlocked by an entity.
     */
    post: operations['listUnlockedAchievements'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/template/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create an actor template (category definition) */
    post: operations['CreateActorTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/template/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update an actor template */
    post: operations['UpdateActorTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/template/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Delete an actor template */
    post: operations['DeleteActorTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/spawn': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Spawn a new actor from a template */
    post: operations['SpawnActor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Stop a running actor */
    post: operations['StopActor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/bind-character': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Bind an unbound actor to a character
     * @description Transitions an unbound (event-mode) actor to a bound (character-mode) actor.
     *     After binding, the actor receives character perception events and variable
     *     providers begin loading character-specific data on subsequent ticks.
     *     Fails if the actor is already bound to a character.
     */
    post: operations['BindActorCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/cleanup-by-character': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cleanup actors referencing a deleted character
     * @description Called by lib-resource cleanup coordination when a character is deleted.
     *     Stops and removes all actors that reference the specified characterId.
     *     This endpoint is designed for internal service-to-service calls during
     *     cascading resource cleanup.
     */
    post: operations['CleanupByCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/inject-perception': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Inject a perception event into an actor's queue (testing)
     * @description Injects a perception event directly into the actor's perception queue
     *     for testing purposes. Useful for testing actor behavior without a
     *     full game server setup.
     */
    post: operations['InjectPerception'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/encounter/start': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Start an encounter managed by an Event Brain actor
     * @description Initializes an encounter with the specified participants. The Event Brain actor
     *     will coordinate the encounter, sending instructions to participant NPC Brain actors
     *     via their character perception channels.
     */
    post: operations['StartEncounter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/encounter/update-phase': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update the phase of an active encounter
     * @description Updates the phase of an encounter being managed by an Event Brain actor.
     *     Phase changes are logged and can trigger behavior changes in participant actors.
     */
    post: operations['UpdateEncounterPhase'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/encounter/end': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * End an active encounter
     * @description Ends an encounter being managed by an Event Brain actor. This clears the
     *     encounter state and allows the actor to manage a new encounter.
     */
    post: operations['EndEncounter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/upload/request': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request upload URL for a new asset
     * @description Generate a pre-signed URL for uploading a new asset directly to storage.
     *     For large files (>50MB), returns multipart upload configuration.
     */
    post: operations['requestUpload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/upload/complete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Mark upload as complete, trigger processing
     * @description Called after the client has uploaded the file to the pre-signed URL.
     *     Triggers the asset processing pipeline (texture conversion, model validation, etc.)
     *     and emits completion events via WebSocket.
     */
    post: operations['completeUpload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get asset metadata and download URL
     * @description Retrieve asset metadata and generate a pre-signed download URL.
     *     Specify version to download a specific version, or omit for latest.
     */
    post: operations['getAsset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/list-versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all versions of an asset
     * @description Retrieve version history for an asset with pagination.
     *     Includes version IDs, creation timestamps, and archive status.
     */
    post: operations['listAssetVersions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Search assets by tags, type, or realm
     * @description Search assets using various filters with pagination.
     *     All filters are optional and combine with AND logic.
     */
    post: operations['searchAssets'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create asset bundle from multiple assets
     * @description Create a .bannou bundle containing multiple assets.
     *     For large bundles, processing is delegated to the processing pool.
     *     Completion notification sent via WebSocket event.
     */
    post: operations['createBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get bundle manifest and download URL
     * @description Retrieve bundle metadata and generate a pre-signed download URL.
     *     Supports both native .bannou format and ZIP conversion (cached).
     */
    post: operations['getBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/upload/request': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request upload URL for a pre-made bundle
     * @description Upload a pre-built bundle (.bannou or .zip format).
     *     After upload, the bundle undergoes validation before registration.
     */
    post: operations['requestBundleUpload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/metabundle/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create metabundle from source bundles
     * @description Compose a metabundle by extracting and repackaging assets from multiple
     *     source bundles. The resulting metabundle is a complete physical copy with
     *     provenance metadata tracking the source bundles.
     *
     *     Assets are deduplicated by content hash. If the same asset ID exists in
     *     multiple source bundles with different content hashes, the request fails
     *     with conflict details.
     */
    post: operations['createMetabundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/job/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get async metabundle job status
     * @description Poll the status of an async metabundle creation job.
     *     Use the jobId returned from createMetabundle when status was 'queued'.
     *
     *     Clients can either poll this endpoint or wait for the
     *     MetabundleCreationCompleteEvent via WebSocket for completion notification.
     */
    post: operations['getJobStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/job/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel an async metabundle job
     * @description Cancel a pending or processing metabundle creation job.
     *     Jobs that are already completed (ready or failed) cannot be cancelled.
     *
     *     Successfully cancelled jobs will emit a MetabundleCreationCompleteEvent
     *     with status 'cancelled' via WebSocket.
     */
    post: operations['cancelJob'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/resolve': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Compute optimal bundles for requested assets
     * @description Given a list of asset IDs, compute the optimal set of bundles to download
     *     to obtain all requested assets with minimal transfers.
     *
     *     The algorithm uses greedy set-cover optimization:
     *     1. Find all bundles containing requested assets
     *     2. Select bundles that cover the most uncovered assets
     *     3. Prefer metabundles when coverage is equal (tie-breaker)
     *     4. Include standalone assets for any remaining unresolved IDs
     *
     *     Returns pre-signed download URLs for all selected bundles and assets.
     */
    post: operations['resolveBundles'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/query/by-asset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find all bundles containing a specific asset
     * @description Query the reverse index to find all bundles (source and metabundle)
     *     that contain a specific asset ID. Useful for understanding asset
     *     distribution and debugging resolution issues.
     */
    post: operations['queryBundlesByAsset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update bundle metadata
     * @description Update metadata for an existing bundle (name, description, tags).
     *     Does not modify bundle contents - for that, create a new bundle.
     *
     *     Increments the bundle version and records the change in version history.
     *     Only the bundle owner or admin can update.
     */
    post: operations['updateBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Soft-delete a bundle
     * @description Soft-delete a bundle, marking it as deleted but retaining data
     *     for the configured retention period (default 30 days).
     *
     *     Deleted bundles are excluded from resolution and queries by default.
     *     Use permanent=true for immediate, unrecoverable deletion (admin only).
     *
     *     Only the bundle owner or admin can delete.
     */
    post: operations['deleteBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/restore': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Restore a soft-deleted bundle
     * @description Restore a bundle that was soft-deleted, making it active again.
     *     Can only restore bundles within their retention period.
     *
     *     Only the bundle owner or admin can restore.
     */
    post: operations['restoreBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query bundles with advanced filters
     * @description Query bundles with flexible filtering options including:
     *     - Tag matching (exact, exists, not exists)
     *     - Status filtering (active, deleted)
     *     - Date range filtering
     *     - Name search (contains)
     *     - Owner filtering
     *     - Realm and bundle type filtering
     *
     *     Supports pagination and sorting.
     */
    post: operations['queryBundles'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/list-versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List version history for a bundle
     * @description Get the version history for a bundle, showing all metadata changes
     *     over time. Each version record includes:
     *     - Version number
     *     - When the change was made
     *     - Who made the change
     *     - What changed
     *     - Optional reason for the change
     *
     *     The current version's full metadata snapshot is always included.
     */
    post: operations['listBundleVersions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/bulk-get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Batch asset metadata lookup
     * @description Retrieve metadata for multiple assets in a single request.
     *     Optionally includes pre-signed download URLs.
     *     Maximum 100 asset IDs per request.
     */
    post: operations['bulkGetAssets'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/login': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Login with email/password */
    post: operations['login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/register': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Register new user account */
    post: operations['register'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/oauth/{provider}/init': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Initialize OAuth2 flow (browser redirect)
     * @description Browser-facing endpoint for initiating OAuth flows. The user's browser navigates
     *     to this URL directly, which then redirects to the OAuth provider.
     *
     *     **Note**: This endpoint uses GET with path parameters because it's a browser
     *     redirect flow, not a WebSocket-routed API call.
     */
    get: operations['initOAuth'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/oauth/{provider}/callback': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Complete OAuth2 flow (browser redirect callback)
     * @description Browser-facing callback endpoint for OAuth providers. The OAuth provider redirects
     *     the user's browser back to this URL after authentication.
     *
     *     **Note**: This endpoint uses path parameters because the callback URL is registered
     *     with OAuth providers and cannot be changed without updating provider configurations.
     */
    post: operations['completeOAuth'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/steam/verify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Verify Steam Session Ticket
     * @description Validates a Steam Session Ticket obtained from the game client via ISteamUser::GetAuthTicketForWebApi().
     *     The server validates the ticket with Steam's Web API and retrieves the SteamID from Steam's response.
     *     NEVER trust client-provided SteamID - it must come from Steam's authenticated response.
     */
    post: operations['verifySteamAuth'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/refresh': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Refresh access token */
    post: operations['refreshToken'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Validate access token */
    post: operations['validateToken'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/logout': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Logout and invalidate tokens */
    post: operations['logout'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/sessions/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get active sessions for account */
    post: operations['getSessions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/sessions/terminate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Terminate specific session */
    post: operations['terminateSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/password/reset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Request password reset */
    post: operations['requestPasswordReset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/password/confirm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Confirm password reset with token */
    post: operations['confirmPasswordReset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/providers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List available authentication providers
     * @description Returns a list of available OAuth and authentication providers based on server configuration.
     *     Providers are only listed if their client credentials are configured.
     *     Steam authentication uses session tickets, not OAuth, but is included for completeness.
     */
    post: operations['listProviders'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/mfa/setup': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Initialize MFA setup
     * @description Generates a TOTP secret and 10 recovery codes. Returns an otpauth:// URI for QR
     *     code scanning and the recovery codes in plain text (shown only once). The setup is
     *     not active until confirmed via /auth/mfa/enable with a valid TOTP code.
     */
    post: operations['setupMfa'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/mfa/enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Confirm MFA setup with TOTP code
     * @description Verifies a TOTP code against the pending setup secret to prove the authenticator
     *     app is correctly configured. On success, persists MFA settings to the account and
     *     MFA is active for all subsequent password logins.
     */
    post: operations['enableMfa'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/mfa/disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Disable MFA for current account
     * @description Disables MFA for the authenticated account. Requires a valid TOTP code or
     *     recovery code to prevent unauthorized disable. Clears the TOTP secret and
     *     recovery codes from the account.
     */
    post: operations['disableMfa'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/mfa/verify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Verify MFA code during login
     * @description Completes the MFA challenge issued during login by verifying a TOTP code or
     *     recovery code. On success, returns full authentication tokens (same as a
     *     non-MFA login would). The challenge token is single-use and has a configurable
     *     TTL (default 5 minutes).
     */
    post: operations['verifyMfa'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/compile': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Compile ABML behavior definition
     * @description Compiles a YAML-based ABML behavior definition into executable behavior trees.
     *     Handles stackable behavior sets, cultural adaptations, and context variable resolution.
     */
    post: operations['CompileAbmlBehavior'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate ABML definition
     * @description Validates ABML YAML against schema and checks for semantic correctness.
     *     Includes context variable validation and service dependency checking.
     */
    post: operations['ValidateAbml'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cache/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get cached compiled behavior
     * @description Retrieves a previously compiled behavior from the cache.
     *     Used for performance optimization in high-frequency behavior execution.
     */
    post: operations['GetCachedBehavior'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cache/invalidate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Invalidate cached behavior
     * @description Removes a behavior from the cache, forcing recompilation on next access.
     *     Used when behavior definitions are updated.
     */
    post: operations['InvalidateCachedBehavior'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/goap/plan': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate GOAP plan
     * @description Generates a GOAP plan to achieve a goal from the current world state.
     *     Uses A* search to find the optimal sequence of actions.
     */
    post: operations['GenerateGoapPlan'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/goap/validate-plan': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate existing GOAP plan
     * @description Validates an existing GOAP plan against the current world state.
     *     Returns whether the plan is still valid or needs replanning.
     */
    post: operations['ValidateGoapPlan'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get character by ID */
    post: operations['getCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** List characters with filtering */
    post: operations['listCharacters'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/get-enriched': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get character with optional related data (personality, backstory, family)
     * @description Retrieves a character with optional include flags for related data.
     *     Use this endpoint when you need aggregated character data from multiple services.
     *     Each included dataset is fetched from its respective service.
     */
    post: operations['getEnrichedCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/get-archive': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get compressed archive data for a character */
    post: operations['getCharacterArchive'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/by-realm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get all characters in a realm (primary query pattern) */
    post: operations['getCharactersByRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/get-compress-data': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get character base data for compression
     * @description Called by Resource service during compression.
     *     Returns core character data (name, dates, family summary).
     *     Returns BadRequest if character is alive - only dead characters can be compressed.
     */
    post: operations['getCompressData'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/type/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get encounter type by code
     * @description Retrieve an encounter type by its unique code.
     */
    post: operations['getEncounterType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/type/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all encounter types
     * @description Retrieve all encounter types including built-in and custom types.
     */
    post: operations['listEncounterTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/query/by-character': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get character's encounters (paginated)
     * @description Retrieves all encounters for a character with optional filtering.
     *     Memory decay is applied lazily on access.
     */
    post: operations['queryByCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/query/between': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get encounters between two characters
     * @description Retrieves all encounters between two specific characters.
     *     Useful for relationship history and dialogue context.
     */
    post: operations['queryBetween'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/query/by-location': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Recent encounters at location
     * @description Retrieves recent encounters at a specific location.
     *     Useful for scene context and area history.
     */
    post: operations['queryByLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/has-met': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Quick check if two characters have met
     * @description Fast boolean check for whether two characters have any recorded encounters.
     *     Does not apply memory decay or return encounter details.
     */
    post: operations['hasMet'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/get-sentiment': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Aggregate sentiment toward another character
     * @description Calculates the aggregate sentiment a character has toward another based
     *     on all their encounters. Memory strength is factored into the calculation.
     */
    post: operations['getSentiment'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/get-perspective': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get character's view of encounter
     * @description Retrieves a specific character's perspective on an encounter.
     *     Includes emotional impact, sentiment shift, and memory strength.
     */
    post: operations['getPerspective'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/get-compress-data': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get encounter data for compression
     * @description Called by Resource service during character compression.
     *     Returns encounters and perspectives involving this character for archival.
     */
    post: operations['getCompressData'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-history/get-participation': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all historical events a character participated in
     * @description Retrieves all historical event participation records for a character.
     *     Supports filtering by event category and minimum significance.
     */
    post: operations['getParticipation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-history/get-event-participants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all characters who participated in a historical event
     * @description Retrieves all characters who participated in a specific historical event.
     *     Useful for generating event summaries or finding related characters.
     */
    post: operations['getEventParticipants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-history/get-backstory': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get machine-readable backstory elements for behavior system
     * @description Retrieves structured backstory elements for a character. These elements
     *     are machine-readable key-value pairs used by the behavior system for
     *     decision-making, not narrative text for players.
     */
    post: operations['getBackstory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-history/get-compress-data': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get history data for compression
     * @description Called by Resource service during character compression.
     *     Returns historical participations, backstory elements, and text summaries for archival.
     */
    post: operations['getCompressData'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-personality/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get personality for a character
     * @description Retrieves the personality profile for a character. Returns 404 if no
     *     personality has been defined for this character.
     */
    post: operations['getPersonality'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-personality/get-combat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get combat preferences for a character
     * @description Retrieves the combat preferences for a character. Combat preferences
     *     influence tactical decisions in the behavior system, including engagement
     *     style, positioning, and retreat conditions.
     */
    post: operations['getCombatPreferences'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-personality/get-compress-data': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get personality data for compression
     * @description Called by Resource service during character compression.
     *     Returns personality traits and combat preferences for archival.
     */
    post: operations['getCompressData'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-personality/cleanup-by-character': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cleanup all personality data for a deleted character
     * @description Called by lib-resource cleanup coordination when a character is deleted.
     *     Removes BOTH personality traits AND combat preferences for the specified character.
     *     This endpoint is designed for internal service-to-service calls during
     *     cascading resource cleanup.
     */
    post: operations['cleanupByCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/type/register': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Register a new room type
     * @description Registers a new room type definition. Room types are a dynamic registry of string codes. Built-in types (text, sentiment, emoji) are pre-registered on startup. Custom types are added via this endpoint. Returns conflict if code already exists for the given game service scope.
     */
    post: operations['RegisterRoomType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/type/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get room type by code
     * @description Returns the room type definition for the specified code and optional game service scope.
     */
    post: operations['GetRoomType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/type/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List room types with filters
     * @description Returns room types matching the specified filters with pagination.
     */
    post: operations['ListRoomTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/type/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a room type definition
     * @description Updates mutable fields of a room type definition. Cannot change code or message format.
     */
    post: operations['UpdateRoomType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/type/deprecate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Soft-deprecate a room type
     * @description Sets the room type status to Deprecated. Existing rooms continue to work but no new rooms can be created with this type.
     */
    post: operations['DeprecateRoomType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/room/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a chat room
     * @description Creates a new chat room of the specified type. Optionally associates a governing contract that drives room lifecycle (lock, archive, delete) on contract state changes.
     */
    post: operations['CreateRoom'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/room/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get room by ID
     * @description Returns the chat room metadata for the specified room ID.
     */
    post: operations['GetRoom'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/room/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List rooms with filters
     * @description Returns rooms matching the specified filters with pagination.
     */
    post: operations['ListRooms'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/room/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update room settings
     * @description Updates mutable room settings. Caller must be the room owner.
     */
    post: operations['UpdateRoom'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/room/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a room
     * @description Deletes a room, removing all participants and messages. Caller must be the room owner or the room must be empty.
     */
    post: operations['DeleteRoom'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/room/archive': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Archive a room to Resource
     * @description Archives a persistent room via lib-resource, preserving message history and metadata. Room is marked as archived after successful archival.
     */
    post: operations['ArchiveRoom'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/room/join': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Join a chat room
     * @description Joins the caller to the specified room. For companion rooms in AutoJoinLazy or Manual mode, the room is created on-the-fly if it does not yet exist. Returns conflict if the room is full or forbidden if the caller is banned.
     */
    post: operations['JoinRoom'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/room/leave': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Leave a chat room
     * @description Removes the caller from the room. If the owner leaves, promotes the next moderator or oldest member.
     */
    post: operations['LeaveRoom'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/room/participants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List room participants
     * @description Returns all current participants in the room with their roles and status.
     */
    post: operations['ListParticipants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/room/participant/kick': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Remove a participant from the room
     * @description Kicks a participant from the room. Caller must be Owner or Moderator with higher role than target.
     */
    post: operations['KickParticipant'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/room/participant/ban': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Ban a participant from the room
     * @description Bans a participant. If currently in the room, they are kicked first. Optionally set a duration; null means permanent.
     */
    post: operations['BanParticipant'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/room/participant/unban': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Unban a participant
     * @description Removes a ban record for a participant. Caller must be Owner or Moderator.
     */
    post: operations['UnbanParticipant'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/room/participant/mute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Mute a participant
     * @description Mutes a participant, preventing them from sending messages. Optionally set a duration; null means permanent.
     */
    post: operations['MuteParticipant'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/message/send': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Send a message to a room
     * @description Sends a message to the specified room. Content is validated against the room type's message format and validator config. For AutoJoinLazy companion rooms, the room is created and the sender auto-joined if the room does not yet exist.
     */
    post: operations['SendMessage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/message/send-batch': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Send multiple messages
     * @description Sends multiple messages to a room atomically. Intended for bulk sentiment pushes from higher-layer services.
     */
    post: operations['SendMessageBatch'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/message/history': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get message history
     * @description Returns paginated message history for a room, ordered by timestamp descending. Uses cursor-based pagination.
     */
    post: operations['GetMessageHistory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/message/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a message
     * @description Deletes a specific message. Caller must be the message sender, room Owner, or Moderator.
     */
    post: operations['DeleteMessage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/message/pin': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Pin a message
     * @description Pins a message in the room. Caller must be Owner or Moderator. Returns conflict if max pinned messages reached.
     */
    post: operations['PinMessage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/message/unpin': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Unpin a message
     * @description Unpins a previously pinned message. Caller must be Owner or Moderator.
     */
    post: operations['UnpinMessage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/message/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Full-text search in persistent rooms
     * @description Searches message content in persistent rooms using MySQL full-text search. Not available for ephemeral rooms.
     */
    post: operations['SearchMessages'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/admin/rooms': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all rooms system-wide
     * @description Returns all rooms across the system for administrative purposes. Supports filtering by status and type.
     */
    post: operations['AdminListRooms'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/admin/stats': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Room and message statistics
     * @description Returns system-wide chat statistics for monitoring and debugging.
     */
    post: operations['AdminGetStats'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/chat/admin/cleanup': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Force cleanup of idle rooms
     * @description Triggers an immediate idle room cleanup cycle, bypassing the normal interval.
     */
    post: operations['AdminForceCleanup'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/entry-template/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create an entry template
     * @description Create an entry template defining a collectible content item. Each template
     *     has a unique code within its collection type and game service, references
     *     an item template for inventory placement, and includes display/metadata fields.
     */
    post: operations['createEntryTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/entry-template/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get an entry template by ID
     * @description Retrieves an entry template by its unique identifier.
     */
    post: operations['getEntryTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/entry-template/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List entry templates
     * @description Paginated list of entry templates filtered by collection type, game service, and optional category.
     */
    post: operations['listEntryTemplates'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/entry-template/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update an entry template
     * @description Update mutable fields of an entry template (displayName, tags, assets, unlockHint, themes, music metadata).
     */
    post: operations['updateEntryTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/entry-template/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete an entry template
     * @description Delete an entry template. Warns if instances reference it but does not block deletion.
     */
    post: operations['deleteEntryTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/entry-template/seed': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Bulk seed entry templates
     * @description Bulk create entry templates from a payload, skipping duplicates. Validates item template IDs. Returns count of created templates.
     */
    post: operations['seedEntryTemplates'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a collection for an owner
     * @description Create a collection instance for an owner entity. One collection per type
     *     per game service per owner (ownerId + ownerType). Creates an inventory
     *     container (unlimited type) to hold unlocked entry items.
     */
    post: operations['createCollection'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a collection with unlocked entry summary
     * @description Retrieves a collection instance with its unlocked entry count.
     */
    post: operations['getCollection'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all collections for an owner
     * @description List all collection instances for an owner entity, with optional game service filter.
     */
    post: operations['listCollections'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a collection and its inventory container
     * @description Delete a collection instance, destroying its inventory container and all contained entry items.
     */
    post: operations['deleteCollection'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/grant': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Grant/unlock an entry (idempotent)
     * @description Grant an entry to a collection. Idempotent: returns existing if already
     *     unlocked. Auto-creates collection instance (and inventory container)
     *     if one does not exist for this owner+type+game. Creates an item instance
     *     and places it in the collection container.
     */
    post: operations['grantEntry'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/has': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if owner has a specific entry
     * @description Check if an owner has a specific entry unlocked in their collection.
     */
    post: operations['hasEntry'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query unlocked entries with filtering
     * @description Query unlocked entries in a collection with optional filtering by category, tags, and metadata.
     */
    post: operations['queryEntries'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/update-metadata': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update entry instance metadata
     * @description Update metadata for an unlocked entry (play count, kill count, favorites, discovery level, custom data).
     */
    post: operations['updateEntryMetadata'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/stats': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get completion statistics per collection type
     * @description Get completion statistics for a collection including total entries, unlocked count, percentage, and breakdown by category.
     */
    post: operations['getCompletionStats'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/content/select-for-area': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Select content for an area based on unlocked library
     * @description Select a content entry for an area based on the owner's unlocked collection
     *     and area theme configuration. Uses weighted random selection based on theme overlap.
     *     Falls back to the area's default entry if no matches are found.
     */
    post: operations['selectContentForArea'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/content/area-config/set': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Set area-to-theme mapping
     * @description Create or update an area content configuration that maps an area code to themes and a default entry.
     */
    post: operations['setAreaContentConfig'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/content/area-config/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get area content config
     * @description Get the content configuration for a specific area and game service.
     */
    post: operations['getAreaContentConfig'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/content/area-config/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List area configs for a game service
     * @description List all area content configurations for a game service.
     */
    post: operations['listAreaContentConfigs'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/discovery/advance': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Advance progressive discovery level
     * @description Advance the discovery level of an unlocked entry (bestiary-style progressive
     *     reveal). Each level reveals additional information about the entry as defined
     *     in the entry template's discovery levels.
     */
    post: operations['advanceDiscovery'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collection/cleanup-by-character': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cleanup all collections for a deleted character
     * @description Called by lib-resource cleanup coordination when a character is deleted.
     *     Removes all collections owned by the specified characterId, including
     *     their inventory containers, cache entries, and publishes collection.deleted
     *     lifecycle events.
     *     This endpoint is designed for internal service-to-service calls during
     *     cascading resource cleanup.
     */
    post: operations['cleanupByCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/client-capabilities': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get client capability manifest (GUID  API mappings)
     * @description Returns the capability manifest for the authenticated client's session.
     *     Maps client-salted GUIDs to available API endpoints based on the client's
     *     current permissions and session state.
     *
     *     **Security**: Each client receives unique GUIDs for the same API endpoints.
     *     This prevents cross-session exploitation and enables per-client rate limiting.
     *
     *     **Dynamic Updates**: Capabilities may change during a session when:
     *     - Role changes occur (admin promotion, etc.)
     *     - Subscription status changes
     *     - Session state transitions
     *
     *     Clients should listen for capability update events via WebSocket to stay current.
     */
    post: operations['getClientCapabilities'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/template/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get template by ID or code
     * @description Retrieves a contract template by its unique ID or code.
     *     At least one of templateId or code must be provided.
     */
    post: operations['getContractTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/template/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List templates with filters
     * @description Lists contract templates with optional filtering by realm, active status,
     *     and search term.
     */
    post: operations['listContractTemplates'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create contract instance from template
     * @description Creates a new contract instance from a template. The instance starts
     *     in 'draft' status and must be proposed to parties before activation.
     */
    post: operations['createContractInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/propose': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Propose contract to parties (starts consent flow)
     * @description Moves a draft contract to 'proposed' status and notifies parties.
     *     Parties must consent before the contract becomes active.
     */
    post: operations['proposeContractInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/consent': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Party consents to contract
     * @description Records a party's consent to a proposed contract. When all required
     *     parties consent, the contract moves to 'accepted' then 'active' status.
     */
    post: operations['consentToContract'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get instance by ID
     * @description Retrieves a contract instance by its unique ID.
     */
    post: operations['getContractInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query instances by party, template, status
     * @description Queries contract instances with various filters. At least one filter
     *     must be provided.
     */
    post: operations['queryContractInstances'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/terminate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request early termination
     * @description Requests early termination of an active contract. Depending on the
     *     contract's termination policy, this may require mutual consent or
     *     incur penalties.
     */
    post: operations['terminateContractInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/get-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current status and milestone progress
     * @description Gets the current status of a contract including milestone progress,
     *     pending consents, and any active breaches.
     */
    post: operations['getContractInstanceStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/milestone/complete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * External system reports milestone completed
     * @description Called by external systems to report that a milestone's conditions
     *     have been met. Triggers onComplete prebound APIs and may advance
     *     contract status.
     */
    post: operations['completeMilestone'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/milestone/fail': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * External system reports milestone failed
     * @description Called by external systems to report that a milestone has failed
     *     (e.g., deadline passed, conditions cannot be met). Triggers onExpire
     *     prebound APIs and may record a breach.
     */
    post: operations['failMilestone'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/milestone/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get milestone details and status
     * @description Gets the current state of a specific milestone.
     */
    post: operations['getMilestone'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/breach/report': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Report a contract breach
     * @description Reports a breach of contract terms. This can be called by parties
     *     or external systems. The breach enters a grace period for cure
     *     if configured.
     */
    post: operations['reportBreach'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/breach/cure': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Mark breach as cured (system/admin action)
     * @description Marks a breach as cured within the grace period. This prevents
     *     consequences from being applied. Called by systems that verify
     *     the breach has been remedied.
     */
    post: operations['cureBreach'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/breach/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get breach details
     * @description Retrieves details of a specific breach record.
     */
    post: operations['getBreach'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/metadata/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update game metadata on instance
     * @description Updates game-specific metadata on a contract instance without
     *     touching contract state. Used by higher-level systems (quests, etc.)
     *     to store additional context.
     */
    post: operations['updateContractMetadata'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/metadata/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get game metadata
     * @description Retrieves game-specific metadata from a contract instance.
     */
    post: operations['getContractMetadata'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/check-constraint': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if entity can take action given contracts
     * @description Checks whether an entity's proposed action would violate any
     *     active contract constraints (exclusivity, non-compete, territory, etc.).
     */
    post: operations['checkContractConstraint'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/query-active': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query active contracts for entity
     * @description Returns all active contracts where the specified entity is a party.
     *     Useful for displaying current obligations in UI.
     */
    post: operations['queryActiveContracts'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/lock': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Lock contract under guardian custody
     * @description Locks a contract under guardian custody (e.g., escrow). A locked contract
     *     cannot be modified, terminated, or have parties transferred except by the
     *     guardian. Requires the contract template to have `transferable: true`.
     */
    post: operations['lockContract'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/unlock': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Unlock contract from guardian custody
     * @description Unlocks a contract from guardian custody. Only the current guardian can
     *     unlock a contract. Called on escrow refund to restore contract to original state.
     */
    post: operations['unlockContract'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/transfer-party': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Transfer party role to new entity
     * @description Transfers a party role to a new entity. Used by escrow to reassign contract
     *     roles on release (e.g., transfer landlord role to new property owner).
     *     Contract must be locked and caller must be the guardian.
     */
    post: operations['transferContractParty'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/clause-type/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all registered clause types
     * @description Lists all registered clause types including built-in types and
     *     custom-registered types.
     */
    post: operations['listClauseTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/set-template-values': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Set template values on contract instance
     * @description Sets template values on a contract instance. Called by escrow when binding
     *     a contract to an escrow agreement. Template values are used for variable
     *     substitution in clause handlers (e.g., wallet IDs, container IDs).
     */
    post: operations['setContractTemplateValues'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/check-asset-requirements': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if asset requirement clauses are satisfied
     * @description Checks if all asset requirement clauses are satisfied. Uses template values
     *     (e.g., PartyA_EscrowWalletId) to query actual balances in escrow wallets/containers
     *     via the registered clause type handlers.
     */
    post: operations['checkAssetRequirements'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/execute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Execute all contract clauses (idempotent)
     * @description Executes all contract distribution clauses - distribute assets per clauses,
     *     collect fees, mark contract as executed. This is idempotent - calling twice
     *     returns the same result without re-executing. Contract must be in fulfilled
     *     status and all template values must be set.
     */
    post: operations['executeContract'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/definition/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get currency definition by ID or code
     * @description Retrieves a currency definition by its unique ID or code.
     *     At least one of definitionId or code must be provided.
     */
    post: operations['getCurrencyDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/definition/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List currency definitions with filters
     * @description Lists currency definitions with optional filtering by realm, scope,
     *     active status, and base currency flag.
     */
    post: operations['listCurrencyDefinitions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/wallet/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new wallet for an owner
     * @description Creates a new wallet for a polymorphic owner (account, character, NPC, guild, etc.).
     *     Each owner+ownerType+realm combination can have at most one wallet.
     */
    post: operations['createWallet'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/wallet/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get wallet by ID or owner
     * @description Retrieves a wallet by its ID, or by owner+ownerType+realm combination.
     *     Returns the wallet with all non-zero balances.
     */
    post: operations['getWallet'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/wallet/get-or-create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get existing wallet or create if not exists
     * @description Retrieves a wallet if it exists, otherwise creates a new one.
     *     Upsert pattern for convenience.
     */
    post: operations['getOrCreateWallet'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/balance/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get balance for a specific currency in a wallet
     * @description Retrieves the current balance for a specific currency in a wallet.
     *     In lazy autogain mode, this may trigger autogain calculation and emit events.
     *     Returns earn cap info and autogain info when applicable.
     */
    post: operations['getBalance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/balance/batch-get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get multiple balances in one call
     * @description Retrieves balances for multiple wallet+currency combinations.
     *     Autogain is applied where applicable.
     */
    post: operations['batchGetBalances'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/credit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Credit currency to a wallet (faucet operation)
     * @description Credits currency to a wallet. This is a faucet operation (currency enters the system).
     *     Enforces earn caps, wallet caps, and global supply caps. Requires idempotency key.
     */
    post: operations['creditCurrency'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/debit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Debit currency from a wallet (sink operation)
     * @description Debits currency from a wallet. This is a sink operation (currency exits the system).
     *     Checks for sufficient funds unless negative balance is allowed.
     */
    post: operations['debitCurrency'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/transfer': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Transfer currency between wallets
     * @description Transfers currency from one wallet to another. Validates transferability,
     *     realm compatibility, and sufficient funds.
     */
    post: operations['transferCurrency'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/batch-credit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Credit multiple wallets in one call
     * @description Credits currency to multiple wallets in one call. Each operation is independent;
     *     failures do not rollback others. For atomic multi-wallet operations, use lib-escrow.
     */
    post: operations['batchCreditCurrency'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/batch-debit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Debit multiple wallets in one call
     * @description Debits currency from multiple wallets in one call. Each operation is independent;
     *     failures do not rollback others. For atomic multi-wallet operations, use lib-escrow.
     */
    post: operations['batchDebitCurrency'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/convert/calculate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Calculate conversion without executing
     * @description Previews a currency conversion calculation without executing it.
     *     Uses base currency exchange rates to compute the effective rate.
     */
    post: operations['calculateConversion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/convert/execute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Execute currency conversion in a wallet
     * @description Executes a currency conversion within a single wallet. Debits the source
     *     currency and credits the target currency at the computed exchange rate.
     */
    post: operations['executeConversion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/exchange-rate/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get exchange rate between two currencies
     * @description Retrieves the exchange rate between two currencies using the base currency
     *     as an intermediary.
     */
    post: operations['getExchangeRate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/transaction/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a transaction by ID
     * @description Retrieves a single transaction record by its unique ID.
     */
    post: operations['getTransaction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/transaction/history': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get paginated transaction history for a wallet
     * @description Retrieves transaction history for a wallet with optional filters
     *     by currency, transaction type, and date range.
     */
    post: operations['getTransactionHistory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/transaction/by-reference': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get transactions by reference type and ID
     * @description Retrieves all transactions linked to a specific reference (quest, auction,
     *     escrow, etc.).
     */
    post: operations['getTransactionsByReference'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/stats/global-supply': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get global supply statistics for a currency
     * @description Returns aggregate supply statistics including total supply, circulation,
     *     escrow amounts, and lifetime mint/burn totals.
     */
    post: operations['getGlobalSupply'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/escrow/deposit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Debit wallet for escrow deposit
     * @description Called by lib-escrow when a party deposits currency into an escrow agreement.
     *     Immediately debits the wallet (no lock tracking needed - escrow owns the funds).
     */
    post: operations['escrowDeposit'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/escrow/release': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Credit recipient on escrow completion
     * @description Called by lib-escrow when an escrow agreement completes successfully.
     *     Credits the recipient wallet with the released funds.
     */
    post: operations['escrowRelease'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/escrow/refund': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Credit depositor on escrow refund
     * @description Called by lib-escrow when an escrow agreement is cancelled or refunded.
     *     Credits the original depositor wallet with the refunded funds.
     */
    post: operations['escrowRefund'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/hold/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create an authorization hold (reserve funds)
     * @description Creates an authorization hold that reserves funds without debiting.
     *     The held amount reduces the effective balance but does not leave the wallet.
     *     Used for pre-auth scenarios (dining, gas, hotels) where final amount may differ.
     */
    post: operations['createHold'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/hold/capture': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Capture held funds (debit final amount)
     * @description Captures an active hold by debiting the final amount (which may be less than
     *     or equal to the held amount). Any difference is released back to available balance.
     */
    post: operations['captureHold'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/hold/release': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Release held funds (make available again)
     * @description Releases an active hold, making all held funds available again.
     *     No debit occurs.
     */
    post: operations['releaseHold'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/hold/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get hold status and details
     * @description Retrieves the current status and details of an authorization hold.
     */
    post: operations['getHold'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/deity/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new deity
     * @description Creates a deity entity with domain influences and personality traits.
     *     Provisions a divinity currency wallet, a domain power seed, and optionally
     *     starts a deity watcher actor via Puppetmaster.
     */
    post: operations['createDeity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/deity/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a deity by ID
     * @description Returns a single deity entity by its unique identifier.
     */
    post: operations['getDeity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/deity/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a deity by code within a game service
     * @description Looks up a deity by its unique code within a game service scope.
     */
    post: operations['getDeityByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/deity/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List deities with optional filters
     * @description Returns a paginated list of deities for a game service, optionally
     *     filtered by domain code and status.
     */
    post: operations['listDeities'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/deity/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update deity properties
     * @description Partial update of deity properties. Only non-null fields are applied.
     *     Requires a distributed lock on the deity.
     */
    post: operations['updateDeity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/deity/activate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Activate a dormant deity
     * @description Sets the deity status to Active. If Puppetmaster is available and no
     *     watcher actor exists, starts one. Publishes a deity activated event.
     */
    post: operations['activateDeity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/deity/deactivate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Deactivate an active deity
     * @description Sets the deity status to Dormant. Stops the watcher actor if Puppetmaster
     *     is available. Clears all attention slots. Publishes a deity dormant event.
     */
    post: operations['deactivateDeity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/deity/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a deity
     * @description Permanently deletes a deity and all dependent data. Deactivates the deity
     *     if active, revokes all blessings, removes all follower relationships, deletes
     *     attention slots, and coordinates cleanup via lib-resource. Publishes a
     *     lifecycle deleted event.
     */
    post: operations['deleteDeity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/divinity/get-balance': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a deity's divinity balance
     * @description Returns the current divinity balance for a deity by querying its currency wallet.
     */
    post: operations['getDivinityBalance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/divinity/credit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Credit divinity to a deity
     * @description Credits divinity to a deity's currency wallet. Used for mortal actions
     *     in the deity's domain, direct grants, or other divinity generation sources.
     */
    post: operations['creditDivinity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/divinity/debit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Debit divinity from a deity
     * @description Debits divinity from a deity's currency wallet. Used for blessing grants,
     *     miracles, or other divinity expenditures. Validates sufficient balance
     *     before debiting.
     */
    post: operations['debitDivinity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/divinity/get-history': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get divinity transaction history
     * @description Returns paginated transaction history for a deity's divinity wallet.
     */
    post: operations['getDivinityHistory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/blessing/grant': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Grant a blessing from a deity to an entity
     * @description Orchestrates the full blessing ceremony: validates deity is active, validates
     *     target entity exists, checks blessing capacity, calculates divinity cost from tier,
     *     debits divinity, grants the blessing via lib-collection (Greater/Supreme) or
     *     Status Inventory (Minor/Standard), and records the blessing. Blessings are
     *     entity-agnostic -- characters, accounts, deities, or any entity type can receive them.
     */
    post: operations['grantBlessing'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/blessing/revoke': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Revoke an active blessing
     * @description Revokes a blessing. For status-type blessings (Minor/Standard), removes
     *     the status item. For permanent blessings (Greater/Supreme), marks as
     *     revoked in collection. Updates the blessing record with revocation timestamp.
     */
    post: operations['revokeBlessing'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/blessing/list-by-entity': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List blessings for an entity
     * @description Returns paginated blessings granted to a specific entity.
     */
    post: operations['listBlessingsByEntity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/blessing/list-by-deity': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List blessings granted by a deity
     * @description Returns paginated blessings granted by a specific deity, optionally filtered by tier.
     */
    post: operations['listBlessingsByDeity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/blessing/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a blessing by ID
     * @description Returns a single blessing record by its unique identifier.
     */
    post: operations['getBlessing'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/follower/register': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Register a character as a follower of a deity
     * @description Creates a deity-character follower relationship via lib-relationship,
     *     increments the deity's follower count, and adds the character to the
     *     deity's attention slots if capacity is available.
     */
    post: operations['registerFollower'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/follower/unregister': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Unregister a character as a follower
     * @description Removes the deity-character follower relationship, decrements the
     *     deity's follower count, and removes the character from attention slots.
     */
    post: operations['unregisterFollower'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/follower/get-followers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get followers of a deity
     * @description Returns paginated follower list for a deity by querying relationships.
     */
    post: operations['getFollowers'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/cleanup-by-character': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cleanup divine data for a deleted character
     * @description Called by lib-resource when a character is deleted. Revokes all active
     *     blessings targeting this character (entityType=character), removes follower
     *     relationships from all deities, updates follower counts, and clears
     *     attention slots.
     */
    post: operations['cleanupByCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/divine/cleanup-by-game-service': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cleanup divine data for a deleted game service
     * @description Called by lib-resource when a game service is deleted. Deletes all deities
     *     for this game service along with their blessings, followers, attention
     *     slots, and associated resources.
     */
    post: operations['cleanupByGameService'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Natural language documentation search
     * @description Search documentation using natural language queries.
     *     Returns the most relevant documents with voice-friendly summaries.
     */
    post: operations['queryDocumentation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get specific document by ID or slug
     * @description Retrieve a specific document by its unique identifier or slug.
     *     Returns full content with metadata.
     */
    post: operations['getDocument'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Full-text keyword search
     * @description Search documentation using exact keyword matching.
     *     Faster than semantic search but less flexible.
     */
    post: operations['searchDocumentation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List documents by category
     * @description List all documents in a specific category or all categories.
     *     Supports pagination for large result sets.
     */
    post: operations['listDocuments'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/suggest': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get related topics and follow-up suggestions
     * @description Given a topic or document ID, returns related topics the user
     *     might want to explore. Useful for conversational AI flow.
     */
    post: operations['suggestRelatedTopics'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/bind': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Bind a git repository to a documentation namespace
     * @description Bind a git repository URL to a documentation namespace.
     *     The namespace will be exclusively managed by the repository - manual edits will be blocked.
     *     Triggers initial sync after binding.
     */
    post: operations['bindRepository'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/sync': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Manually trigger repository sync
     * @description Manually trigger synchronization of a bound repository.
     *     If force=true, performs full re-sync regardless of commit hash.
     */
    post: operations['syncRepository'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get repository binding status
     * @description Get current status of a repository binding including sync state and statistics.
     */
    post: operations['getRepositoryStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all repository bindings
     * @description List all repository bindings with optional filtering by status.
     */
    post: operations['listRepositoryBindings'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update repository binding configuration
     * @description Update sync settings, file patterns, category mappings, or archive configuration.
     */
    post: operations['updateRepositoryBinding'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/archive/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create documentation archive
     * @description Create a .bannou bundle archive of all documents in a namespace.
     *     Archives are stored via Asset Service.
     */
    post: operations['createDocumentationArchive'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/archive/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List documentation archives
     * @description List all archives for a namespace.
     */
    post: operations['listDocumentationArchives'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new escrow agreement
     * @description Create a new escrow agreement. For each party, creates a dedicated escrow wallet
     *     and container (owned by escrow entity). Issues deposit tokens and returns ALL
     *     tokens to the creating service, which is responsible for distributing them to
     *     parties through appropriate channels. Sets template values on bound contract.
     */
    post: operations['createEscrow'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get escrow details
     * @description Get escrow agreement details by ID.
     */
    post: operations['getEscrow'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List escrows for a party
     * @description List escrow agreements with filtering options.
     */
    post: operations['listEscrows'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/deposit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Deposit assets into escrow
     * @description Deposit assets into escrow. Transfers currency from party's own wallet to that
     *     party's escrow wallet. Moves items from party's own container to that party's
     *     escrow container. Locks contracts with escrow as guardian.
     *     Rejects soulbound/non-tradeable items. After each deposit, queries bound contract
     *     to check if all asset requirements are satisfied.
     */
    post: operations['deposit'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/deposit/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate a deposit without executing
     * @description Validate a deposit without executing (dry run).
     */
    post: operations['validateDeposit'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/deposit/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get deposit status for a party
     * @description Get deposit status for a party in an escrow.
     */
    post: operations['getDepositStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/consent': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Record party consent
     * @description Record party consent for release, refund, or re-affirmation.
     */
    post: operations['recordConsent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/consent/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get consent status for escrow
     * @description Get consent status for all parties in an escrow.
     */
    post: operations['getConsentStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/release': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Trigger release
     * @description Trigger release (for trusted modes or after consent).
     *     If boundContractId is set, checks contract status first (must be fulfilled).
     *     Runs finalization flow before releasing remaining assets.
     */
    post: operations['release'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/refund': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Trigger refund
     * @description Trigger refund (for trusted modes or consent).
     */
    post: operations['refund'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel escrow before fully funded
     * @description Cancel escrow before fully funded, refunding any deposits.
     */
    post: operations['cancel'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/dispute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Raise a dispute on funded escrow
     * @description Raise a dispute on a funded escrow.
     */
    post: operations['dispute'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/confirm-release': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Confirm receipt of released assets
     * @description Called by parties to confirm they received their released assets.
     *     Required when ReleaseMode is party_required or service_and_party.
     */
    post: operations['confirmRelease'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/confirm-refund': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Confirm receipt of refunded assets
     * @description Called by parties to confirm they received their refunded deposits.
     *     Required when RefundMode is party_required.
     */
    post: operations['confirmRefund'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/resolve': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Arbiter resolves disputed escrow
     * @description Arbiter resolves a disputed escrow.
     */
    post: operations['resolve'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/verify-condition': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Verify condition for conditional escrow
     * @description Verify condition for conditional escrow (non-contract path).
     *     For escrows with boundContractId, use contract milestones instead.
     */
    post: operations['verifyCondition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/reaffirm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Re-affirm after validation failure
     * @description Re-affirm after validation failure (party accepts changed state).
     */
    post: operations['reaffirm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new faction
     * @description Creates a new faction entity and automatically creates a seed via lib-seed
     *     with ownerType "faction" and the configured seed type code. The seed starts
     *     in the "nascent" phase with no capabilities unlocked.
     *
     *     The faction code must be unique within the game service scope.
     *
     *     If parentFactionId is provided, validates that the parent exists, belongs
     *     to the same game service and realm, and that the resulting hierarchy depth
     *     does not exceed the configured maximum.
     */
    post: operations['createFaction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a faction by ID
     * @description Retrieves a faction by its unique identifier. Includes the current seed
     *     growth phase (denormalized from lib-seed for convenience) and member count.
     */
    post: operations['getFaction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a faction by code
     * @description Retrieves a faction by its unique code within a game service scope.
     *     Codes are human-readable identifiers like "thieves_guild" or "royal_guard".
     */
    post: operations['getFactionByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List factions with filters
     * @description Returns a paginated list of factions with optional filters by realm,
     *     game service, status, and parent faction. Supports cursor-based pagination.
     */
    post: operations['listFactions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a faction
     * @description Updates mutable faction properties (name, description, code). The faction
     *     code must remain unique within its game service scope. Cannot change
     *     gameServiceId or realmId after creation.
     */
    post: operations['updateFaction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/deprecate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Deprecate a faction
     * @description Marks a faction as deprecated. Deprecated factions cannot accept new members
     *     or define new norms, but existing memberships and norms remain active.
     *     Existing norm enforcement continues until the faction is dissolved.
     */
    post: operations['deprecateFaction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/undeprecate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Reactivate a deprecated faction
     * @description Restores a deprecated faction to active status.
     */
    post: operations['undeprecateFaction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/designate-realm-baseline': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Designate a faction as realm baseline
     * @description Sets a faction as the realm's baseline cultural faction. The baseline
     *     faction provides realm-wide default norms (honor codes, cultural taboos,
     *     species instincts) that apply to all characters in the realm unless
     *     overridden by more specific faction norms.
     *
     *     Only one faction per realm can be the baseline. Setting a new baseline
     *     clears the previous one. The faction must belong to the specified realm.
     */
    post: operations['designateRealmBaseline'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/get-realm-baseline': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get the realm baseline faction
     * @description Returns the faction designated as the baseline cultural faction for a realm.
     *     Returns 404 if no baseline has been designated.
     */
    post: operations['getRealmBaseline'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/member/add': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Add a character to a faction
     * @description Adds a character as a member of a faction. The faction must be active
     *     (not deprecated or dissolved). If no role is specified, the configured
     *     default member role is used.
     *
     *     A character can be a member of multiple factions simultaneously. Duplicate
     *     membership (same character + same faction) returns Conflict.
     *
     *     Publishes a faction.member.added event for downstream consumers.
     */
    post: operations['addMember'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/member/remove': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Remove a character from a faction
     * @description Removes a character's membership in a faction. Publishes a
     *     faction.member.removed event for downstream consumers.
     */
    post: operations['removeMember'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/member/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List members of a faction
     * @description Returns a paginated list of members for a faction. Supports filtering
     *     by role and cursor-based pagination. Ordered by join date descending.
     */
    post: operations['listMembers'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/member/list-by-character': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List a character's faction memberships
     * @description Returns all faction memberships for a character. Used by lib-obligation
     *     to determine which guild faction norms apply to a character, and by the
     *     ${faction.*} variable provider for ABML behavior expressions.
     */
    post: operations['listMembershipsByCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/member/update-role': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a member's role
     * @description Changes a member's role within a faction. Publishes a
     *     faction.member.role-changed event for downstream consumers.
     */
    post: operations['updateMemberRole'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/member/check': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if a character is a member of a faction
     * @description Returns whether a character is currently a member of the specified faction,
     *     and if so, their role. Lightweight lookup for permission/capability checks.
     */
    post: operations['checkMembership'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/territory/claim': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Claim a location for a faction
     * @description Claims a location as faction territory. Requires the faction's seed to
     *     have unlocked the "territory.claim" capability. A location can only have
     *     one controlling faction at a time (exclusive claim). If the location is
     *     already claimed by another faction, the claim is rejected with Conflict.
     *
     *     The faction must belong to the same realm as the location.
     */
    post: operations['claimTerritory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/territory/release': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Release a territory claim
     * @description Releases a faction's claim on a location. The territory becomes unclaimed
     *     and available for other factions. Publishes a faction.territory.released event.
     */
    post: operations['releaseTerritory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/territory/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List territory claims for a faction
     * @description Returns all territory claims for a faction with optional status filtering
     *     and cursor-based pagination.
     */
    post: operations['listTerritoryClaims'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/territory/get-controlling': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get the controlling faction for a location
     * @description Returns the faction that currently controls a location. Used by
     *     lib-obligation and the norm resolution hierarchy to determine which
     *     location faction norms apply at a character's current position.
     *
     *     Returns 404 if the location has no controlling faction.
     */
    post: operations['getControllingFaction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/norm/define': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Define a behavioral norm for a faction
     * @description Creates a new behavioral norm definition for a faction. Requires the
     *     faction's seed to have unlocked the "norm.define" capability (growth
     *     threshold must be reached). Higher-severity norms may require additional
     *     capabilities (norm.enforce.basic for Standard, norm.enforce.sanctions
     *     for Strict).
     *
     *     Norms are stored as faction configuration and queried by lib-obligation
     *     for NPC cognition cost modifiers. They are NOT contract instances --
     *     this avoids the scaling problem of 100K NPCs each needing individual
     *     contract instances for ambient social rules.
     *
     *     The violationType is an opaque string that maps to lib-obligation's
     *     violation type vocabulary (e.g., "theft", "deception", "violence",
     *     "honor_combat"). No separate taxonomy is maintained -- the vocabulary
     *     is defined by contract templates and action tag mappings.
     */
    post: operations['defineNorm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/norm/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update an existing norm
     * @description Updates properties of an existing norm definition. The violationType
     *     cannot be changed (delete and recreate if needed). Severity changes
     *     are subject to capability checks.
     */
    post: operations['updateNorm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/norm/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a norm definition
     * @description Removes a behavioral norm definition from a faction.
     */
    post: operations['deleteNorm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/norm/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List norms defined by a faction
     * @description Returns all norm definitions for a faction with optional filtering
     *     by severity and scope.
     */
    post: operations['listNorms'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/cleanup-by-character': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cleanup faction data for a deleted character
     * @description Called by lib-resource cleanup coordination when a character is deleted.
     *     Removes all faction memberships for the character. Territory claims and
     *     norm definitions are faction-owned, not character-owned, so they remain.
     */
    post: operations['cleanupByCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/cleanup-by-realm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cleanup faction data for a deleted realm
     * @description Called by lib-resource cleanup coordination when a realm is deleted.
     *     Removes all factions belonging to the realm, including their memberships,
     *     territory claims, norm definitions, and associated seeds.
     */
    post: operations['cleanupByRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/cleanup-by-location': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cleanup territory claims for a deleted location
     * @description Called by lib-resource cleanup coordination when a location is deleted.
     *     Removes all territory claims referencing the location. The faction itself
     *     remains intact.
     */
    post: operations['cleanupByLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faction/get-compress-data': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get faction data for character archival compression
     * @description Called by Resource service during character compression. Returns faction
     *     memberships and roles for the character for archival. Norm definitions
     *     are faction-owned data and not included in character archives.
     */
    post: operations['getCompressData'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/game-service/services/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all registered game services
     * @description Returns all game services, optionally filtered by active status.
     */
    post: operations['listServices'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/game-service/services/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get service by ID or stub name
     * @description Retrieves a single service by either serviceId (GUID) or stubName.
     */
    post: operations['getService'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get game session details
     * @description Get details of the current game session the user has joined.
     */
    post: operations['getGameSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/leave': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Leave a game session */
    post: operations['leaveGameSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/chat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Send chat message to game session */
    post: operations['sendChatMessage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/actions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Perform game action (enhanced permissions after joining) */
    post: operations['performGameAction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/leave-session': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Leave a specific game session by ID
     * @description Leave a game session by its session ID. This is the session-specific alternative
     *     to /sessions/leave which uses gameType. Useful for matchmade sessions.
     */
    post: operations['leaveGameSessionById'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/garden/enter': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Enter the garden
     * @description Creates a garden instance for the player. Finds or creates the player's
     *     active guardian seed, initializes drift metrics, and returns the initial
     *     garden state. First tick of the garden orchestrator spawns POIs.
     */
    post: operations['enterGarden'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/garden/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current garden state
     * @description Returns the player's current garden instance with active POIs.
     */
    post: operations['getGardenState'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/garden/update-position': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update player position in the garden
     * @description Updates the player's position and velocity in garden space. Accumulates
     *     drift metrics and checks proximity triggers against active POIs.
     */
    post: operations['updatePosition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/garden/leave': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Leave the garden
     * @description Cleans up the garden instance, all associated POIs, and publishes a
     *     garden-left event with session duration.
     */
    post: operations['leaveGarden'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/poi/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List active POIs
     * @description Returns all active POIs for the player's current garden instance.
     */
    post: operations['listPois'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/poi/interact': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Interact with a POI
     * @description Triggers interaction with a POI. Result depends on the POI's trigger mode:
     *     prompted POIs return scenario info with choices, proximity/interaction POIs
     *     enter the scenario directly.
     */
    post: operations['interactWithPoi'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/poi/decline': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Decline a POI
     * @description Marks a POI as declined. The template is added to the garden instance's
     *     scenario history for diversity scoring.
     */
    post: operations['declinePoi'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/scenario/enter': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Enter a scenario
     * @description Validates prerequisites, creates a game session, creates a scenario
     *     instance, destroys the garden instance (player leaves the garden), and
     *     publishes scenario-started events.
     */
    post: operations['enterScenario'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/scenario/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current scenario state
     * @description Returns the player's active scenario instance.
     */
    post: operations['getScenarioState'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/scenario/complete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Complete a scenario
     * @description Calculates and awards growth per domain, closes the game session,
     *     writes history, and returns the player to the garden.
     */
    post: operations['completeScenario'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/scenario/abandon': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Abandon a scenario
     * @description Awards partial growth proportional to time spent, cleans up the
     *     game session, and writes history.
     */
    post: operations['abandonScenario'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/scenario/chain': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Chain to another scenario
     * @description Completes the current scenario with growth awards and immediately
     *     creates a new scenario instance from the target template. Validates
     *     chaining rules (leadsTo list, max chain depth).
     */
    post: operations['chainScenario'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/template/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a scenario template
     * @description Creates a new scenario template definition.
     */
    post: operations['createTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/template/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get scenario template by ID
     * @description Returns a scenario template by its unique identifier.
     */
    post: operations['getTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/template/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get scenario template by code
     * @description Returns a scenario template by its unique code string.
     */
    post: operations['getTemplateByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/template/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List scenario templates
     * @description Returns paginated scenario templates with optional filters.
     */
    post: operations['listTemplates'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/template/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update scenario template
     * @description Updates non-null fields of an existing template.
     */
    post: operations['updateTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/template/deprecate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Deprecate scenario template
     * @description Sets the template status to Deprecated, preventing new instances.
     */
    post: operations['deprecateTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/template/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete scenario template
     * @description Permanently deletes a scenario template. Template must be in Deprecated status before deletion. Publishes a scenario-template.deleted lifecycle event.
     */
    post: operations['deleteTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/phase/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get deployment phase configuration
     * @description Returns the current deployment phase configuration. Creates defaults if none exists.
     */
    post: operations['getPhaseConfig'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/phase/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update deployment phase configuration
     * @description Updates non-null fields of the phase configuration. Publishes phase-changed event if phase changes.
     */
    post: operations['updatePhaseConfig'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/phase/get-metrics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get deployment phase metrics
     * @description Returns current counts of active garden instances, scenario instances, and capacity utilization.
     */
    post: operations['getPhaseMetrics'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/bond/enter-together': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Enter a scenario together with a bonded player
     * @description Both bonded players enter a shared scenario instance. Validates bond state,
     *     both participants' garden instances, and template multiplayer support.
     */
    post: operations['enterScenarioTogether'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/gardener/bond/get-shared-garden': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get shared garden state for bonded players
     * @description Returns the merged garden state for both bond participants including shared POIs.
     */
    post: operations['getSharedGardenState'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/container/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new container
     * @description Creates a new container with the specified constraint model and capacity.
     *     Container types are game-defined strings (e.g., "inventory", "bank", "equipment_slot").
     */
    post: operations['createContainer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/container/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get container with contents
     * @description Retrieves a container by ID, optionally including its contents.
     */
    post: operations['getContainer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/container/get-or-create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get container or create if not exists
     * @description Enables lazy container creation for character inventories.
     *     If a container doesn't exist for the owner/type combination, creates it
     *     with the specified defaults.
     */
    post: operations['getOrCreateContainer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/container/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List containers for owner
     * @description Returns all containers owned by the specified entity.
     */
    post: operations['listContainers'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/container/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update container properties
     * @description Updates mutable container properties like capacity limits and filtering.
     */
    post: operations['updateContainer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/add': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Add item to container
     * @description Adds an item instance to a container. Validates container constraints
     *     (slots, weight, grid, category filters). For stackable items, may
     *     merge with existing stacks.
     */
    post: operations['addItemToContainer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/remove': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Remove item from container
     * @description Removes an item from its container. The item still exists but has no
     *     container assignment. Use destroy via lib-item to permanently delete.
     */
    post: operations['removeItemFromContainer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/move': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Move item to different slot or container
     * @description Moves an item within the same container (slot change) or to a different
     *     container. Validates destination constraints. For equipment slots, this
     *     effectively equips/unequips items.
     */
    post: operations['moveItem'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/transfer': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Transfer item to different owner
     * @description Transfers an item to a container owned by a different entity.
     *     Used for trades, gifts, and loot distribution.
     */
    post: operations['transferItem'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/split': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Split stack into two
     * @description Splits a stack of items into two stacks. The original stack keeps the
     *     remainder, and a new stack is created with the split quantity.
     */
    post: operations['splitStack'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/merge': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Merge two stacks
     * @description Merges two stacks of the same item template. The source stack is
     *     destroyed and its quantity added to the target stack.
     */
    post: operations['mergeStacks'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find items across containers
     * @description Searches for items across all containers owned by an entity.
     *     Can filter by template, category, tags, and other criteria.
     */
    post: operations['queryItems'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/count': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Count items of a template
     * @description Counts total quantity of a specific item template across containers.
     */
    post: operations['countItems'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/has': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if entity has required items
     * @description Checks if an entity has the required quantities of specified items.
     *     Used for crafting and quest requirements validation.
     */
    post: operations['hasItems'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/find-space': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find where item would fit
     * @description Finds available space for an item in the owner's containers.
     *     Returns candidate containers and slots where the item could be placed.
     */
    post: operations['findSpace'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/template/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new item template
     * @description Creates a new item definition for a game. Code, gameId, quantityModel, and scope
     *     are immutable after creation.
     */
    post: operations['createItemTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/template/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get item template by ID or code
     * @description Retrieves an item template by its unique ID or by code+gameId combination.
     *     At least one of templateId or (code + gameId) must be provided.
     */
    post: operations['getItemTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/template/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List item templates with filters
     * @description Lists item templates with optional filtering by gameId, category, tags,
     *     rarity, scope, and active status.
     */
    post: operations['listItemTemplates'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/template/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update mutable fields of an item template
     * @description Updates mutable fields of an item template. Code, gameId, quantityModel, and scope
     *     are immutable after creation and cannot be changed.
     */
    post: operations['updateItemTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/instance/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new item instance
     * @description Creates a new item instance from a template. The instance must be placed
     *     in a container (containerId required). Use lib-inventory's /inventory/add
     *     for most use cases - this endpoint is for low-level instance creation.
     */
    post: operations['createItemInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/instance/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get item instance by ID
     * @description Retrieves an item instance by its unique ID.
     */
    post: operations['getItemInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/instance/modify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Modify item instance state
     * @description Modifies an item instance's mutable state: durability, custom stats,
     *     custom name, and metadata. Cannot modify bound items unless admin.
     */
    post: operations['modifyItemInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/instance/bind': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Bind item to character
     * @description Binds an item instance to a character. The bind type must be allowed by
     *     the template's soulboundType. Once bound, the item cannot be traded.
     */
    post: operations['bindItemInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/instance/destroy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Destroy item instance
     * @description Permanently destroys an item instance. The reason is recorded for audit.
     *     Cannot destroy bound items unless admin or reason is 'admin'.
     */
    post: operations['destroyItemInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/use': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Use an item (execute its behavior contract)
     * @description Uses an item by executing its behavior contract. The item's template must have
     *     a useBehaviorContractTemplateId defined. Creates a transient contract instance,
     *     completes the "use" milestone (triggering prebound APIs), and consumes the item
     *     on success if the template defines it as consumable. Returns failure if the
     *     contract's prebound APIs fail.
     */
    post: operations['useItem'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/use-step': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Complete a specific step of a multi-step item use
     * @description For items with multi-milestone use behaviors, completes a specific milestone.
     *     The first call (without an existing contractInstanceId on the item) creates
     *     the contract instance and stores it on the item; subsequent calls progress
     *     the existing contract. Item is consumed only when all required milestones
     *     are complete (per itemUseBehavior).
     */
    post: operations['useItemStep'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/instance/list-by-container': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List items in a container
     * @description Returns all item instances in the specified container.
     */
    post: operations['listItemsByContainer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/instance/batch-get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get multiple item instances by ID
     * @description Retrieves multiple item instances in a single request.
     */
    post: operations['batchGetItemInstances'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/definition/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new leaderboard definition
     * @description Create a new leaderboard with specified properties.
     *     Developer-only endpoint for setting up game leaderboards.
     */
    post: operations['createLeaderboardDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/definition/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update leaderboard definition
     * @description Update properties of an existing leaderboard.
     *     Developer-only endpoint.
     */
    post: operations['updateLeaderboardDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/definition/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete leaderboard definition
     * @description Delete a leaderboard and all its scores.
     *     Developer-only endpoint. This action is irreversible.
     */
    post: operations['deleteLeaderboardDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/rank/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get entity's rank
     * @description Get the current rank and score for a specific entity.
     */
    post: operations['getEntityRank'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/rank/top': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get top entries
     * @description Get the top N entries on a leaderboard.
     */
    post: operations['getTopRanks'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/rank/around': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get entries around entity
     * @description Get leaderboard entries surrounding a specific entity.
     *     Useful for showing a player's position with nearby competitors.
     */
    post: operations['getRanksAround'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/season/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current season info
     * @description Get information about the current or a specific past season.
     */
    post: operations['getSeason'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/board-template/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new board template
     * @description Create a board template with grid dimensions, starting nodes, adjacency mode,
     *     and a reference to the contract template that controls unlock behavior.
     *     Board templates are scoped to a game service.
     */
    post: operations['createBoardTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/board-template/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a board template by ID
     * @description Retrieves a board template by its unique identifier.
     */
    post: operations['getBoardTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/board-template/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List board templates for a game service
     * @description Paginated list of board templates filtered by game service ID.
     */
    post: operations['listBoardTemplates'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/board-template/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a board template
     * @description Update mutable fields of a board template. Grid dimensions, starting nodes,
     *     and contract template are immutable after creation.
     */
    post: operations['updateBoardTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/board-template/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a board template
     * @description Delete a board template. Blocked if active board instances exist
     *     that reference this template.
     */
    post: operations['deleteBoardTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/definition/add': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Add a license definition to a board template
     * @description Add a license definition (node) to a board template at a specific grid position.
     *     Each definition has a unique code within the template, a grid position, an LP cost,
     *     and a reference to the item template that is created when the license is unlocked.
     *     Optional non-adjacent prerequisites can reference other license codes on the board.
     */
    post: operations['addLicenseDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/definition/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a license definition
     * @description Get a license definition by board template ID and license code.
     */
    post: operations['getLicenseDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/definition/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all license definitions for a board template
     * @description Returns the full grid layout of all license definitions for a board template.
     */
    post: operations['listLicenseDefinitions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/definition/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a license definition
     * @description Update mutable fields of a license definition. Position and code are immutable
     *     after creation.
     */
    post: operations['updateLicenseDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/definition/remove': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Remove a license definition from a board template
     * @description Remove a license definition from a board template. Blocked if any board
     *     instances have this license unlocked.
     */
    post: operations['removeLicenseDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/board/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a board instance for an owner
     * @description Create a board instance for an owner from a board template. Validates the owner type
     *     is in the template's allowedOwnerTypes, game service matches, and no duplicate board
     *     exists (one board per template per owner). For character owners, validates the character
     *     exists and resolves realm context. Creates an inventory container (slot_only,
     *     maxSlots = gridWidth * gridHeight) to hold unlocked license items.
     */
    post: operations['createBoard'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/board/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a board instance by ID
     * @description Retrieves a board instance by its unique identifier.
     */
    post: operations['getBoard'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/board/list-by-owner': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List boards for an owner
     * @description List all board instances for an owner (by ownerType + ownerId), with optional game service filter.
     */
    post: operations['listBoardsByOwner'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/board/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a board instance
     * @description Delete a board instance. Destroys the inventory container and all license
     *     items within it.
     */
    post: operations['deleteBoard'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/unlock': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Unlock a license on a board
     * @description The core operation. Validates adjacency and prerequisites, creates a contract
     *     instance from the board template's contract template, executes the unlock
     *     milestone (LP deduction, ability grants via prebound APIs), then creates an
     *     item instance and places it in the board container. Atomic: if contract
     *     execution fails, no license is placed.
     */
    post: operations['unlockLicense'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/check-unlockable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if a license can be unlocked
     * @description Check if a license can be unlocked without performing the unlock. Returns
     *     adjacency status, prerequisite status, and whether the character has
     *     sufficient LP.
     */
    post: operations['checkUnlockable'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/board-state': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get full board state
     * @description Get the full board state: all defined license positions with unlock status
     *     (unlocked, locked, unlockable) and adjacency info. Primary endpoint for
     *     client UI rendering.
     */
    post: operations['getBoardState'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/board-template/seed': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Bulk seed a board template with license definitions
     * @description Bulk seed a board template with license definitions from a JSON payload.
     *     Two-pass: creates definitions, then resolves prerequisite references.
     */
    post: operations['seedBoardTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/board/clone': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Clone a board's unlock state to a new owner
     * @description Developer-only endpoint for cloning NPC progression. Reads unlock state
     *     from a source board, creates a new board for the target owner, and bulk-creates
     *     item instances for all unlocked licenses. Skips contracts entirely (admin tooling,
     *     not gameplay). Publishes a single license.board.cloned event.
     *     Does not publish individual license.unlocked events.
     */
    post: operations['cloneBoard'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/license/cleanup-by-owner': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cleanup boards referencing a deleted owner
     * @description Called by lib-resource cleanup coordination when an owner entity is deleted.
     *     Deletes all board instances for the specified owner (ownerType + ownerId),
     *     destroying their inventory containers and all contained license items.
     *     This endpoint is designed for internal service-to-service calls during
     *     cascading resource cleanup.
     */
    post: operations['cleanupByOwner'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get location by ID */
    post: operations['getLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get location by code and realm
     * @description Retrieve a location using its unique code within a specific realm
     */
    post: operations['getLocationByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List locations with filtering
     * @description Retrieve locations with optional realm, parent, and type filtering
     */
    post: operations['listLocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list-by-realm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all locations in a realm (primary query pattern)
     * @description Returns all locations within a specific realm, optionally filtered by
     *     location type and parent. This is the primary access pattern for
     *     realm-scoped location queries.
     */
    post: operations['listLocationsByRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list-by-parent': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get child locations for a parent location
     * @description Retrieve all locations that have the specified location as their parent.
     *     Useful for getting all cities in a region, all buildings in a city, etc.
     */
    post: operations['listLocationsByParent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list-root': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get root locations in a realm
     * @description Returns all top-level locations in a realm (locations with no parent).
     *     These are typically regions or major areas within the realm.
     */
    post: operations['listRootLocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get-ancestors': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all ancestors of a location
     * @description Returns the full ancestry chain from the specified location up to the
     *     root location (parentLocationId=null). For example, for a specific building
     *     might return [district, city, region].
     */
    post: operations['getLocationAncestors'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/validate-territory': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate location against territory boundaries
     * @description Checks if a proposed location falls within or outside specified territory boundaries.
     *     Used by Contract service's clause type handler system for territory validation.
     *
     *     Territory modes:
     *     - exclusive: Location must NOT be within any territory location (or descendants)
     *     - inclusive: Location MUST be within at least one territory location (or descendants)
     */
    post: operations['validateTerritory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get-descendants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all descendants of a location
     * @description Returns all locations that are descendants of the specified location
     *     (direct children, grandchildren, etc.). Useful for finding all places
     *     within a region or city.
     */
    post: operations['getLocationDescendants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/exists': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if location exists and is active
     * @description Fast validation endpoint for other services to check location validity.
     *     Returns true if location exists and is not deprecated, false otherwise.
     */
    post: operations['locationExists'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/query/by-position': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find locations containing a spatial position
     * @description Given a Position3D and realmId, returns all locations whose bounds contain
     *     that position, ordered by depth descending (most specific first). Only
     *     locations with spatial bounds data are considered. A position is "in" a
     *     location if it falls within the location's axis-aligned bounding box.
     */
    post: operations['queryLocationsByPosition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/report-entity-position': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Report entity presence at a location
     * @description Reports that an entity is present at a location. Creates or refreshes an ephemeral
     *     presence binding with configurable TTL. Reporters must call this periodically to
     *     keep the presence alive. Publishes arrival/departure events only when the entity's
     *     location actually changes (pure refreshes are silent).
     *
     *     The optional previousLocationId provides a caller-hint optimization: if provided
     *     and matches the current stored location, only a TTL refresh occurs (no GET needed).
     *     If omitted, the service reads the current value to detect location changes.
     */
    post: operations['reportEntityPosition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get-entity-location': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get the current location of an entity
     * @description Queries where an entity currently is. Returns the entity's location if a
     *     non-expired presence binding exists.
     */
    post: operations['getEntityLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list-entities-at-location': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List entities currently at a location
     * @description Queries which entities are currently present at a location. Supports optional
     *     entity type filtering and pagination. Results are hydrated from the entity
     *     presence store for reporting metadata.
     */
    post: operations['listEntitiesAtLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/clear-entity-position': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Remove entity presence from its current location
     * @description Clears an entity's presence binding, removing it from its current location.
     *     Publishes a departure event if the entity was present at a location.
     */
    post: operations['clearEntityPosition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/request-snapshot': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request full snapshot for cold start
     * @description Consumers use this when starting up to get initial state.
     *     Returns current snapshot of requested region/kinds.
     *     For very large maps, payloadRef points to lib-asset storage.
     */
    post: operations['requestSnapshot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/point': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query map data at a specific point
     * @description Returns all map data at a point across requested kinds.
     *     Used by behavior stacks for contextual decisions.
     *     Optionally includes objects within radius.
     */
    post: operations['queryPoint'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/bounds': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query map data within bounds
     * @description Returns map data within a bounding box.
     *     For event actors needing region overview.
     *     Limited to maxObjects per kind.
     */
    post: operations['queryBounds'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/objects-by-type': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find all objects of a type in region
     * @description Returns all objects matching an objectType filter.
     *     For event actors asking "where are all the boulder clusters?"
     */
    post: operations['queryObjectsByType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/affordance': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find locations that afford a specific action or scene type
     * @description Affordance queries answer "where can I do X?" by combining
     *     multiple map kinds and applying game-specific scoring logic.
     *
     *     Used by Event Brain for procedural scene orchestration:
     *     - "Find ambush locations"
     *     - "Find dramatic reveal spots"
     *     - "Find sheltered rest areas"
     *
     *     Well-known types have predefined scoring; use affordanceType=custom
     *     with customAffordance for novel scenarios.
     */
    post: operations['queryAffordance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/authoring/checkout': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Acquire exclusive edit lock for design-time editing
     * @description For level editors and design tools only.
     *     Game servers do NOT use this - they use create-channel for implicit authority.
     *     Returns authority token for publishing edits.
     */
    post: operations['checkoutForAuthoring'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/authoring/commit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Commit design-time changes
     * @description Commits pending changes and releases the checkout lock.
     *     Optionally includes a commit message for history.
     */
    post: operations['commitAuthoring'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/authoring/release': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Release authoring checkout without committing
     * @description Discards pending changes and releases the checkout lock.
     *     Use when abandoning edits.
     */
    post: operations['releaseAuthoring'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a map definition template
     * @description Creates a new map definition (template) that describes the structure
     *     of a region. Definitions are templates that can be used to bootstrap
     *     channels with predefined layer configurations.
     */
    post: operations['createDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a map definition by ID
     * @description Returns the full map definition including all layer configurations.
     */
    post: operations['getDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List map definitions with optional filters
     * @description Returns a paginated list of map definitions.
     */
    post: operations['listDefinitions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a map definition
     * @description Updates an existing map definition. Cannot change the definition ID.
     *     Layer configurations can be modified.
     */
    post: operations['updateDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/queue/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List available matchmaking queues
     * @description List all available matchmaking queues that players can join.
     *     Returns queue configuration details including skill settings.
     */
    post: operations['listQueues'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/queue/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get queue details
     * @description Get detailed configuration for a specific matchmaking queue.
     */
    post: operations['getQueue'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/join': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Join matchmaking queue
     * @description Join a matchmaking queue with specified properties and query.
     *     Creates a matchmaking ticket and begins searching for compatible players.
     *     Returns immediately after ticket creation. Match results are delivered
     *     via WebSocket push events.
     */
    post: operations['joinMatchmaking'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/leave': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Leave matchmaking queue
     * @description Leave a matchmaking queue and cancel the ticket.
     *     Only available when actively in a queue (shortcut/prebound).
     */
    post: operations['leaveMatchmaking'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get matchmaking status
     * @description Get current matchmaking status for the player's active ticket.
     *     Only available when actively in a queue (shortcut/prebound).
     */
    post: operations['getMatchmakingStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/accept': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Accept a formed match
     * @description Accept a match that has been formed. Only available when a match
     *     is pending acceptance (shortcut/prebound after match formation).
     *     All players must accept within the timeout for the match to start.
     */
    post: operations['acceptMatch'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/decline': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Decline a formed match
     * @description Decline a match that has been formed. Only available when a match
     *     is pending acceptance (shortcut/prebound after match formation).
     *     Declining cancels the match for all participants.
     */
    post: operations['declineMatch'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/stats': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get queue statistics
     * @description Get operational statistics for matchmaking queues.
     *     Includes queue depths, average wait times, and match rates.
     */
    post: operations['getMatchmakingStats'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/generate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate composition from style and constraints
     * @description Generates a complete musical composition using the specified style definition
     *     and compositional constraints. Returns MIDI-JSON format output.
     */
    post: operations['GenerateComposition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate MIDI-JSON structure
     * @description Validates a MIDI-JSON structure for correctness including note ranges,
     *     timing, and format compliance.
     */
    post: operations['ValidateMidiJson'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/style/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get style definition
     * @description Retrieves a style definition by ID or name. Styles define mode preferences,
     *     interval rules, form templates, and genre-specific parameters.
     */
    post: operations['GetStyle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/style/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List available styles
     * @description Lists all available style definitions with optional filtering by category.
     */
    post: operations['ListStyles'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/theory/progression': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate chord progression
     * @description Generates a chord progression using harmonic function theory.
     *     Supports multiple harmonic styles including functional harmony,
     *     modal interchange, and jazz voicings.
     */
    post: operations['GenerateProgression'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/theory/melody': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate melody over harmony
     * @description Generates a melodic line over a chord progression using contour rules,
     *     interval preferences, and rhythmic patterns from the specified style.
     */
    post: operations['GenerateMelody'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/theory/voice-lead': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Apply voice leading to chords
     * @description Applies voice leading rules to a chord sequence, ensuring smooth
     *     part-writing according to traditional or style-specific rules.
     */
    post: operations['ApplyVoiceLeading'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/obligation/action-mapping/set': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create or update an action tag to violation type mapping
     * @description Registers or replaces a mapping from a GOAP action tag to one or more
     *     violation type codes. These mappings define how the obligation service
     *     connects GOAP planner actions (e.g., tag "steal_food") to contract
     *     behavioral clause violation types (e.g., "theft", "dishonesty").
     *
     *     Mappings are idempotent by tag  setting a mapping for an existing tag
     *     replaces the previous mapping entirely.
     *
     *     By default, action tags are matched 1:1 against violation type codes
     *     (tag "theft" matches violation type "theft"). Explicit mappings are only
     *     needed when the vocabularies differ or when one action triggers multiple
     *     violation types (e.g., "attack_surrendered_enemy"  ["honor_combat", "show_mercy"]).
     */
    post: operations['setActionMapping'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/obligation/action-mapping/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List registered action tag mappings
     * @description Returns all registered action tag to violation type mappings.
     *     Supports cursor-based pagination and optional text search.
     */
    post: operations['listActionMappings'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/obligation/action-mapping/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete an action tag mapping
     * @description Removes a registered action tag mapping. After deletion, the tag will
     *     fall back to convention-based 1:1 matching (tag name == violation type code).
     */
    post: operations['deleteActionMapping'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/obligation/query-violations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query violation history for a character
     * @description Returns the violation history for a character with cursor-based pagination.
     *     Supports filtering by contract, violation type, and time range.
     *     Ordered by timestamp descending (most recent first).
     */
    post: operations['queryViolations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/obligation/invalidate-cache': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Force obligation cache refresh for a character
     * @description Forces a full cache rebuild for a character's obligation manifest.
     *     Queries all active contracts for the character, extracts behavioral
     *     clauses, and rebuilds the cached obligation state.
     *
     *     Normally, the cache is maintained automatically via contract lifecycle
     *     events. This endpoint is for administrative and debugging purposes.
     */
    post: operations['invalidateCache'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/obligation/get-compress-data': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get obligation data for character archival compression
     * @description Called by Resource service during character compression.
     *     Returns violation history and cached obligation state for archival.
     */
    post: operations['getCompressData'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/obligation/cleanup-by-character': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cleanup all obligation data for a deleted character
     * @description Called by lib-resource cleanup coordination when a character is deleted.
     *     Removes cached obligation manifests and violation history for the
     *     specified character. This endpoint is designed for internal
     *     service-to-service calls during cascading resource cleanup.
     */
    post: operations['cleanupByCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/puppetmaster/watchers/start': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Manually start a regional watcher
     * @description Starts a regional watcher for the specified realm with the given behavior.
     *     If a watcher already exists for this realm and watcher type, returns the existing watcher.
     */
    post: operations['startWatcher'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/puppetmaster/watchers/stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Stop a regional watcher
     * @description Stops an active regional watcher by its ID.
     */
    post: operations['stopWatcher'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/puppetmaster/watchers/start-for-realm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Start all relevant watchers for a realm
     * @description Starts all applicable regional watchers for the specified realm.
     *     Uses configured watcher templates to determine which watchers to start.
     */
    post: operations['startWatchersForRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/quest/definition/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new quest definition
     * @description Creates a quest definition wrapping a contract template with quest metadata.
     */
    post: operations['createQuestDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/quest/definition/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get quest definition by ID or code
     * @description Retrieves a quest definition by its unique identifier or code.
     */
    post: operations['getQuestDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/quest/definition/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List quest definitions with filtering
     * @description Lists quest definitions with optional filtering by category, difficulty, tags.
     */
    post: operations['listQuestDefinitions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/quest/definition/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update quest definition metadata
     * @description Updates quest metadata (not contract template - that's immutable).
     */
    post: operations['updateQuestDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/quest/definition/deprecate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Mark quest definition as deprecated
     * @description Marks a quest definition as deprecated. No new instances can be created.
     */
    post: operations['deprecateQuestDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/quest/accept': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Accept a quest
     * @description Creates a contract instance and auto-consents for the questor. Returns the active quest.
     */
    post: operations['acceptQuest'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/quest/abandon': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Abandon an active quest
     * @description Terminates the underlying contract and marks the quest as abandoned.
     */
    post: operations['abandonQuest'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/quest/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get quest instance details
     * @description Retrieves detailed quest instance information including objectives.
     */
    post: operations['getQuest'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/quest/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List character's quests
     * @description Lists quests for a character filtered by status.
     */
    post: operations['listQuests'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/quest/list-available': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List quests available to accept
     * @description Lists quests a character can accept (prerequisites met, not on cooldown, not active).
     */
    post: operations['listAvailableQuests'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/quest/log': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get player-facing quest log
     * @description Returns UI-optimized quest log with progress summaries.
     */
    post: operations['getQuestLog'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/quest/objective/progress': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Report progress on an objective
     * @description Manually reports progress on a quest objective. Used by game systems.
     */
    post: operations['reportObjectiveProgress'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/quest/objective/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get objective progress details
     * @description Returns detailed progress information for a specific objective.
     */
    post: operations['getObjectiveProgress'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/quest/get-compress-data': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get quest data for compression
     * @description Called by Resource service during character compression.
     *     Returns active quests, completion counts, and category breakdown for archival.
     */
    post: operations['getCompressData'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get realm by ID */
    post: operations['getRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get realm by code
     * @description Retrieve a realm using its unique code (e.g., "REALM_1", "REALM_2")
     */
    post: operations['getRealmByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all realms
     * @description Retrieve all realms with optional filtering
     */
    post: operations['listRealms'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm/exists': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if realm exists and is active
     * @description Fast validation endpoint for other services to check realm validity.
     *     Returns true if realm exists and is not deprecated, false otherwise.
     */
    post: operations['realmExists'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm/exists-batch': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if multiple realms exist and are active
     * @description Batch validation endpoint for services creating multi-realm entities.
     *     Returns validation results for each realm ID in a single call, avoiding
     *     N+1 API calls when validating multiple realms.
     */
    post: operations['realmsExistBatch'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm-history/get-participation': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all historical events a realm participated in
     * @description Retrieves all historical event participation records for a realm.
     *     Supports filtering by event category and minimum impact.
     */
    post: operations['getRealmParticipation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm-history/get-event-participants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all realms that participated in a historical event
     * @description Retrieves all realms that participated in a specific historical event.
     *     Useful for generating event summaries or finding related realms.
     */
    post: operations['getRealmEventParticipants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm-history/get-lore': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get machine-readable lore elements for behavior system
     * @description Retrieves structured lore elements for a realm. These elements
     *     are machine-readable key-value pairs used by the behavior system for
     *     decision-making, not narrative text for players.
     */
    post: operations['getRealmLore'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get a relationship by ID */
    post: operations['getRelationship'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/list-by-entity': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all relationships for an entity
     * @description Returns all relationships where the specified entity is either
     *     entity1 or entity2. Supports filtering by relationship type,
     *     other entity type, and whether to include ended relationships.
     */
    post: operations['listRelationshipsByEntity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/get-between': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all relationships between two specific entities
     * @description Returns all relationships that exist between two specific entities,
     *     regardless of which is entity1 or entity2.
     */
    post: operations['getRelationshipsBetween'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/list-by-type': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all relationships of a specific type
     * @description Returns all relationships that use a specific relationship type.
     *     Useful for finding all "FRIEND" relationships, for example.
     */
    post: operations['listRelationshipsByType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/cleanup-by-entity': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cleanup relationships referencing a deleted entity
     * @description Called by lib-resource cleanup coordination when a foundational entity
     *     (character, realm) is deleted. Ends all active relationships where the
     *     specified entity is either entity1 or entity2. Ended relationships are
     *     preserved for history (soft-delete via endedAt). This endpoint is designed
     *     for internal service-to-service calls during cascading resource cleanup.
     */
    post: operations['cleanupByEntity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get relationship type by ID */
    post: operations['getRelationshipType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get relationship type by code
     * @description Retrieve a relationship type using its unique code (e.g., "SON", "MOTHER", "FRIEND")
     */
    post: operations['getRelationshipTypeByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all relationship types
     * @description Retrieve all relationship types with optional hierarchy filtering
     */
    post: operations['listRelationshipTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get-children': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get child types for a parent type
     * @description Retrieve all relationship types that have the specified type as their parent
     */
    post: operations['getChildRelationshipTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/matches-hierarchy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if type matches ancestor in hierarchy
     * @description Checks if a relationship type matches or descends from an ancestor type.
     *     For example, "SON" matches "CHILD" because CHILD is an ancestor of SON.
     *     This enables queries like "find all CHILD relationships" to match SON, DAUGHTER, etc.
     */
    post: operations['matchesHierarchy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get-ancestors': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all ancestors of a relationship type
     * @description Returns the full ancestry chain from the specified type up to the root.
     *     For example, for "SON" might return ["CHILD", "FAMILY"].
     */
    post: operations['getAncestors'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/resource/register': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Register a reference to a resource
     * @description Records that sourceType:sourceId references resourceType:resourceId.
     *     Typically called via event handlers, not directly.
     */
    post: operations['registerReference'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/resource/unregister': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Remove a reference to a resource
     * @description Records that sourceType:sourceId no longer references resourceType:resourceId.
     *     Typically called via event handlers, not directly.
     */
    post: operations['unregisterReference'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/resource/check': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check reference count and cleanup eligibility
     * @description Returns the current reference count for a resource and whether it is
     *     eligible for cleanup (refcount=0 and grace period passed).
     */
    post: operations['checkReferences'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/resource/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all references to a resource
     * @description Returns all entities currently referencing a resource.
     *     Useful for debugging and understanding reference chains.
     */
    post: operations['listReferences'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/resource/cleanup/execute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Execute cleanup for a resource
     * @description Validates refcount=0, grace period passed, acquires distributed lock,
     *     re-validates under lock, then executes all cleanup callbacks.
     *     Returns Conflict if refcount changed during execution.
     */
    post: operations['executeCleanup'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/resource/cleanup/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List registered cleanup callbacks
     * @description Returns all cleanup callbacks registered for a resource type.
     *     Useful for debugging and admin inspection of cleanup chains.
     */
    post: operations['listCleanupCallbacks'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/resource/compress/execute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Compress a resource and all dependents
     * @description Gathers data from all registered compression callbacks, bundles into
     *     a unified archive, and stores in MySQL. Optionally deletes source data
     *     after successful archival via existing cleanup callbacks.
     *
     *     Flow:
     *     1. Get all compression callbacks for resourceType, sorted by priority
     *     2. If dryRun, return preview without executing
     *     3. Acquire distributed lock
     *     4. Execute each callback to gather data
     *     5. Bundle responses into archive (gzipped JSON per entry)
     *     6. Store archive in MySQL
     *     7. If deleteSourceData, invoke cleanup callbacks
     *     8. Publish resource.compressed event
     */
    post: operations['executeCompress'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/resource/compress/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List registered compression callbacks
     * @description Returns all compression callbacks registered for a resource type.
     *     Useful for debugging and admin inspection of compression chains.
     */
    post: operations['listCompressCallbacks'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/resource/archive/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Retrieve compressed archive
     * @description Retrieves a compressed archive by resource type and ID.
     *     Returns the latest version unless a specific archiveId is provided.
     */
    post: operations['getArchive'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/resource/snapshot/execute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create ephemeral snapshot of a living resource
     * @description Creates a non-destructive snapshot of a resource using the same compression
     *     callbacks, but stores the result in Redis with a configurable TTL instead
     *     of permanent MySQL storage.
     *
     *     **Use Case**: The Storyline Composer needs compressed data from living
     *     entities (not just dead/archived ones) to seed emergent narratives.
     *     This endpoint provides that capability without affecting the source data.
     *
     *     **Key Differences from compress/execute**:
     *     1. Stores in Redis (ephemeral) not MySQL (permanent)
     *     2. Never deletes source data
     *     3. Publishes `resource.snapshot.created` event (not `resource.compressed`)
     *     4. Snapshot expires after TTL (default 1 hour, max 24 hours)
     *
     *     **Intended Consumers**:
     *     - Actor behaviors (via ABML service_call)
     *     - Regional Watchers for storyline composition
     *     - Analytics for living entity state capture
     */
    post: operations['executeSnapshot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/resource/snapshot/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Retrieve an ephemeral snapshot
     * @description Retrieves a previously created snapshot by its ID.
     *     Returns 404 if the snapshot has expired or doesn't exist.
     *
     *     Snapshots are stored with TTL - if the TTL has elapsed, the snapshot
     *     is automatically deleted by Redis.
     */
    post: operations['getSnapshot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create or configure a save slot
     * @description Creates a new save slot or updates configuration of an existing slot.
     *     Slots are auto-created on first save, but pre-creation allows setting
     *     custom configuration (max versions, retention policy, etc.).
     */
    post: operations['CreateSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get slot metadata
     * @description Returns slot configuration and version summary.
     */
    post: operations['GetSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List slots for owner
     * @description Returns all slots owned by the specified entity.
     */
    post: operations['ListSlots'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete slot and all versions
     * @description Permanently deletes a slot and all save versions within it.
     *     This is irreversible. Requires owner access or admin role.
     */
    post: operations['DeleteSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/rename': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Rename a save slot
     * @description Renames an existing slot without affecting its versions or data.
     *     The new name must not already exist for this owner.
     */
    post: operations['RenameSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/save': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Save data to slot
     * @description Creates a new version in the specified slot with the provided data.
     *     If the slot doesn't exist, it's auto-created with default configuration.
     *
     *     Large saves (>1MB by default) are automatically compressed.
     *     Rolling version cleanup is applied based on slot configuration.
     */
    post: operations['Save'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/load': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Load data from slot
     * @description Retrieves save data from the specified slot. By default, loads the
     *     latest version. Optionally specify a version number or checkpoint name.
     */
    post: operations['Load'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/save-delta': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Save incremental changes from base version
     * @description Creates a new version by applying a delta (patch) to a base version.
     *     Significantly reduces storage for large saves with small incremental changes.
     *
     *     Uses JSON Patch (RFC 6902) by default. The implementation is designed to
     *     allow swapping to binary diff algorithms (bsdiff/xdelta) if needed for
     *     specific use cases (e.g., binary game state).
     *
     *     Delta versions store only the patch; full data is reconstructed on load.
     */
    post: operations['SaveDelta'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/load-with-deltas': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Load save reconstructing from delta chain
     * @description Loads save data, automatically reconstructing from delta chain if needed.
     *     Returns the full reconstructed data, not the raw delta.
     *
     *     For performance, the service may cache reconstructed data or collapse
     *     delta chains during background cleanup.
     */
    post: operations['LoadWithDeltas'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/collapse-deltas': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Collapse delta chain into full snapshot
     * @description Collapses a chain of delta versions into a single full snapshot.
     *     Useful for reducing load latency or before deleting base versions.
     */
    post: operations['CollapseDeltas'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List versions in slot
     * @description Returns all versions in a slot with metadata.
     */
    post: operations['ListVersions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/pin': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Pin a version as checkpoint
     * @description Pins a specific version, excluding it from rolling cleanup.
     *     Optionally assigns a checkpoint name for easy retrieval.
     */
    post: operations['PinVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/unpin': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Unpin a version
     * @description Removes pin from a version, making it eligible for rolling cleanup.
     */
    post: operations['UnpinVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete specific version
     * @description Permanently deletes a specific version from a slot.
     *     Cannot delete pinned versions; unpin first.
     */
    post: operations['DeleteVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query saves with filters
     * @description Search and filter saves across slots. Supports filtering by owner,
     *     category, date range, metadata, and more. Paginated results.
     */
    post: operations['QuerySaves'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/copy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Copy save to different slot or owner
     * @description Copies a save version to a different slot or owner.
     *     Can copy to same owner (different slot) or different owner (with admin).
     */
    post: operations['CopySave'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Export saves for backup/portability
     * @description Exports one or more slots with all versions as a downloadable archive.
     *     Returns a pre-signed URL to download the export bundle.
     */
    post: operations['ExportSaves'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/verify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Verify save data integrity
     * @description Verifies the integrity of stored save data by comparing content hash
     *     against the stored SHA-256 hash. Detects corruption or tampering.
     */
    post: operations['VerifyIntegrity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/promote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Promote old version to latest
     * @description Creates a new version from an existing older version, effectively
     *     "promoting" it to be the latest. Useful for rollback scenarios.
     */
    post: operations['PromoteVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/migrate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Migrate save to new schema version
     * @description Applies migration handlers to upgrade a save from one schema version
     *     to another. Creates a new version with the migrated data.
     */
    post: operations['MigrateSave'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/schema/register': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Register a save data schema
     * @description Registers a JSON schema for validation of save data.
     *     Optionally includes migration handlers from previous versions.
     */
    post: operations['RegisterSchema'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/schema/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List registered schemas
     * @description Returns all registered schemas for a game/namespace.
     */
    post: operations['ListSchemas'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new scene document
     * @description Creates a new scene document and stores it in lib-asset.
     *     Publishes scene.created event on success.
     *     Returns Conflict if a scene with the same sceneId already exists.
     */
    post: operations['createScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Retrieve a scene by ID
     * @description Retrieves a scene document. Optionally resolves nested scene references
     *     up to a configurable depth.
     */
    post: operations['getScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List scenes with filtering
     * @description Lists scenes matching the provided filters. Supports pagination.
     *     Results are ordered by updatedAt descending (most recent first).
     */
    post: operations['listScenes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a scene document
     * @description Updates an existing scene document. Scene must not be checked out by
     *     another user. Increments the PATCH version automatically.
     *     Publishes scene.updated event on success.
     */
    post: operations['updateScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a scene
     * @description Soft-deletes a scene. The scene data remains recoverable via lib-asset
     *     for approximately 30 days. Cannot delete if other scenes reference this one.
     *     Publishes scene.deleted event on success.
     */
    post: operations['deleteScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate a scene structure
     * @description Validates a scene document without saving it. Checks structural validity
     *     and optionally applies game-specific validation rules.
     */
    post: operations['validateScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/checkout': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Lock a scene for editing
     * @description Acquires an exclusive lock on the scene for editing.
     *     Returns a checkout token required for commit.
     *     Lock expires after TTL if not extended via heartbeat.
     */
    post: operations['checkoutScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/commit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Save changes and release lock
     * @description Commits the changes made during checkout, increments version,
     *     and releases the lock. Publishes scene.committed event.
     */
    post: operations['commitScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/discard': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Release lock without saving changes
     * @description Discards any changes and releases the checkout lock.
     *     Scene remains at its pre-checkout version.
     */
    post: operations['discardCheckout'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/heartbeat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Extend checkout lock TTL
     * @description Extends the checkout lock TTL. Should be called periodically
     *     during editing to prevent lock expiration.
     */
    post: operations['heartbeatCheckout'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/history': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get version history for a scene
     * @description Returns the version history for a scene, up to the configured
     *     retention limit per gameId.
     */
    post: operations['getSceneHistory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/get-validation-rules': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get validation rules for a gameId+sceneType
     * @description Retrieves the registered validation rules for a specific
     *     gameId and sceneType combination.
     */
    post: operations['getValidationRules'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Full-text search across scenes
     * @description Searches scene names, descriptions, tags, and node names
     *     for matching content.
     */
    post: operations['searchScenes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/find-references': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find scenes that reference a given scene
     * @description Returns all scenes that contain reference nodes pointing
     *     to the specified scene.
     */
    post: operations['findReferences'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/find-asset-usage': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find scenes using a specific asset
     * @description Returns all scenes containing nodes that reference
     *     a specific asset ID.
     */
    post: operations['findAssetUsage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/duplicate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Duplicate a scene with a new ID
     * @description Creates a copy of a scene with a new sceneId and name.
     *     All node IDs are regenerated. Version resets to 1.0.0.
     */
    post: operations['duplicateScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new seed
     * @description Creates a new seed bound to the specified owner. The seed type must be registered and the owner type must be allowed by the seed type definition. Returns conflict if creating this seed would exceed the type's MaxPerOwner limit.
     */
    post: operations['CreateSeed'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get seed by ID
     * @description Returns the seed entity with current growth phase and summary data.
     */
    post: operations['GetSeed'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/get-by-owner': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get seeds by owner ID and type
     * @description Returns all seeds owned by the specified entity. Optionally filter by seed type code and status.
     */
    post: operations['GetSeedsByOwner'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List seeds with filtering
     * @description Returns seeds matching the specified filters. Supports filtering by seed type, owner type, growth phase, status, and game service.
     */
    post: operations['ListSeeds'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update seed metadata or display name
     * @description Updates mutable fields of a seed. Cannot change owner or seed type.
     */
    post: operations['UpdateSeed'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/activate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Set a seed as active
     * @description Activates the specified seed. Only one seed of a given type can be active per owner at a time. Deactivates any previously active seed of the same type.
     */
    post: operations['ActivateSeed'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/archive': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Archive a seed
     * @description Soft-deletes a seed, preserving its data but removing it from active rotation. Archived seeds do not count toward the MaxPerOwner limit. Cannot archive an active seed.
     */
    post: operations['ArchiveSeed'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/growth/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get full growth domain map
     * @description Returns the complete growth domain map for a seed, including all top-level and sub-domain entries with their current depth values.
     */
    post: operations['GetGrowth'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/growth/record': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Record growth in a domain
     * @description Records growth in a specific domain for a seed. Primarily called internally by consuming services after processing game events. Triggers capability manifest recomputation if thresholds are crossed.
     */
    post: operations['RecordGrowth'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/growth/record-batch': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Record growth across multiple domains atomically
     * @description Records growth across multiple domains in a single atomic operation. Useful when a single game event contributes to multiple domains simultaneously.
     */
    post: operations['RecordGrowthBatch'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/growth/get-phase': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current growth phase
     * @description Returns the current computed growth phase for the seed, based on the seed type's configured phase thresholds.
     */
    post: operations['GetGrowthPhase'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/capability/get-manifest': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current capability manifest
     * @description Returns the most recently computed capability manifest for the seed. Consumers interpret what capabilities mean (UX modules, spawning permissions, faction actions, etc.).
     */
    post: operations['GetCapabilityManifest'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/type/register': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Register a new seed type definition
     * @description Registers a seed type with its growth phase definitions, capability rules, bond cardinality, and owner type restrictions. Seed types are scoped to game services.
     */
    post: operations['RegisterSeedType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/type/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get seed type definition
     * @description Returns the full seed type definition including phases and capability rules.
     */
    post: operations['GetSeedType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/type/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List registered seed types
     * @description Returns all seed types registered for the specified game service.
     */
    post: operations['ListSeedTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/type/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update seed type definition
     * @description Updates a seed type definition. Changes to phase thresholds or capability rules trigger recomputation for all seeds of this type.
     */
    post: operations['UpdateSeedType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/type/deprecate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Deprecate a seed type
     * @description Marks a seed type as deprecated. Deprecated seed types cannot be used to create new seeds. Existing seeds of this type remain unaffected. Must be deprecated before it can be deleted.
     */
    post: operations['DeprecateSeedType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/type/undeprecate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Restore a deprecated seed type
     * @description Removes deprecated status from a seed type, allowing new seeds of this type to be created again.
     */
    post: operations['UndeprecateSeedType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/type/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a seed type
     * @description Hard deletes a deprecated seed type. Fails if any non-archived seeds of this type exist. Must deprecate first, then ensure all seeds are archived or deleted before calling this endpoint.
     */
    post: operations['DeleteSeedType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/bond/initiate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Begin bond process between seeds
     * @description Initiates a bond between seeds of the same type. All participants must confirm for the bond to become active. Returns conflict if any participant already has a bond and the type's cardinality is 1.
     */
    post: operations['InitiateBond'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/bond/confirm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Confirm a pending bond
     * @description Confirms a pending bond. When all participants have confirmed, the bond becomes active. Bond permanence is determined by the seed type.
     */
    post: operations['ConfirmBond'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/bond/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get bond by ID
     * @description Returns the bond record with all participants and status.
     */
    post: operations['GetBond'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/bond/get-for-seed': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get bond for a specific seed
     * @description Returns the bond that the specified seed participates in, if any.
     */
    post: operations['GetBondForSeed'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/seed/bond/get-partners': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get partner seed(s) public info
     * @description Returns public information about the other seeds in the bond.
     */
    post: operations['GetBondPartners'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/species/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get species by ID */
    post: operations['getSpecies'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/species/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get species by code
     * @description Retrieve a species using its unique code (e.g., "HUMAN", "ELF", "DWARF")
     */
    post: operations['getSpeciesByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/species/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all species
     * @description Retrieve all species with optional realm filtering
     */
    post: operations['listSpecies'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/species/list-by-realm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List species available in a realm
     * @description Retrieve all species that are available in a specific realm
     */
    post: operations['listSpeciesByRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/template/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a status template
     * @description Create a status template defining a status effect type. Each template has
     *     a unique code within its game service, references an item template for
     *     inventory placement, and configures stacking behavior and optional contract
     *     integration for lifecycle management.
     */
    post: operations['createStatusTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/template/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a status template by ID
     * @description Retrieves a status template by its unique identifier.
     */
    post: operations['getStatusTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/template/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a status template by code
     * @description Retrieves a status template by its game service and unique code.
     */
    post: operations['getStatusTemplateByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/template/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List status templates
     * @description Paginated list of status templates filtered by game service with optional category filter.
     */
    post: operations['listStatusTemplates'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/template/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a status template
     * @description Update mutable fields of a status template. Only non-null fields in the request are updated.
     */
    post: operations['updateStatusTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/template/seed': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Bulk seed status templates
     * @description Bulk create status templates from a payload, skipping duplicates. Validates item template IDs. Returns count of created templates.
     */
    post: operations['seedStatusTemplates'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/grant': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Grant a status effect to an entity
     * @description Grant a status effect to an entity. Creates an item instance in the entity's
     *     status container and optionally creates a contract instance for lifecycle
     *     management. Auto-creates the status container (and inventory container) if
     *     one does not exist for this entity and game service.
     *
     *     Stacking behavior is determined by the template:
     *     - refresh_duration: resets timer, increments stack count
     *     - independent: creates a separate instance per application
     *     - increase_intensity: increments stack, resets timer
     *     - replace: removes existing, creates new
     *     - ignore: rejects if already present
     */
    post: operations['grantStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/remove': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Remove a specific status instance
     * @description Remove a specific status instance by ID. Destroys the item via lib-item,
     *     cancels any associated contract, deletes the instance record, and invalidates
     *     the active status cache.
     */
    post: operations['removeStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/remove-by-source': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Remove all statuses from a source
     * @description Remove all status instances granted by a specific source for an entity. Used for cascading removal when a source entity is deleted.
     */
    post: operations['removeBySource'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/remove-by-category': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Remove all statuses of a category (cleanse)
     * @description Remove all status instances of a given category for an entity. Used for cleanse mechanics (remove all debuffs, etc.).
     */
    post: operations['removeByCategory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/has': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if an entity has a specific status
     * @description Check if an entity has a specific status template code active. Returns the status instance ID and stack count if found.
     */
    post: operations['hasStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List active statuses for an entity
     * @description List active status effects for an entity with optional category filter
     *     and seed-derived passive effect inclusion. Merges item-based statuses
     *     from cache with seed-derived effects when includePassive is true.
     */
    post: operations['listStatuses'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a specific status instance
     * @description Retrieves a status instance by its unique identifier with full details including metadata.
     */
    post: operations['getStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/effects/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get unified effects for an entity
     * @description Get all active effects for an entity including both item-based statuses
     *     and seed-derived passive capabilities. Returns a unified view with source
     *     attribution via the effectSource field.
     */
    post: operations['getEffects'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/effects/get-seed': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get seed-derived passive effects for an entity
     * @description Get seed-derived passive effects only. Queries ISeedClient for capability
     *     manifests across all seeds owned by the entity. Returns capabilities with
     *     domain, fidelity, and seed attribution.
     */
    post: operations['getSeedEffects'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/status/cleanup-by-owner': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Remove all statuses and containers for an owner
     * @description Remove all status containers, instances, and inventory containers for an
     *     owner entity. Called by lib-resource cleanup callbacks when a character or
     *     account is deleted. Destroys inventory containers (cascades to items),
     *     deletes all instance records, and invalidates all caches.
     */
    post: operations['cleanupByOwner'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storyline/compose': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Compose a storyline plan from archive seeds
     * @description Generates a storyline plan using data from compressed archives and/or
     *     live snapshots. The plan describes phases, actions, and entity requirements
     *     but does NOT create any entities - callers decide whether to instantiate.
     *
     *     **Workflow**:
     *     1. Fetch archive/snapshot data via IResourceClient
     *     2. Extract world state from archive bundle
     *     3. Select template based on goal and constraints
     *     4. Run GOAP planner to generate action sequences
     *     5. Cache plan and publish storyline.composed event
     */
    post: operations['Compose'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storyline/plan/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Retrieve a cached storyline plan
     * @description Retrieves a previously generated storyline plan by its ID.
     *     Returns 404 if the plan has expired from cache or doesn't exist.
     */
    post: operations['GetPlan'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storyline/plan/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List cached storyline plans
     * @description Lists storyline plans in the cache, optionally filtered by realm.
     *     Plans are ordered by creation time (newest first).
     */
    post: operations['ListPlans'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storyline/scenario/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new scenario definition
     * @description Creates a reusable scenario definition template.
     *     Scenarios are passive building blocks with triggering conditions,
     *     phases, mutations, and optional quest hooks.
     */
    post: operations['CreateScenarioDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storyline/scenario/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a scenario definition by ID or code
     * @description Retrieves a scenario definition by its ID or code.
     *     Uses read-through cache for performance.
     */
    post: operations['GetScenarioDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storyline/scenario/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List scenario definitions
     * @description Lists scenario definitions with optional filtering by realm, game service, and tags.
     *     Results are paginated and ordered by priority (descending), then creation time.
     */
    post: operations['ListScenarioDefinitions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storyline/scenario/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a scenario definition
     * @description Updates an existing scenario definition.
     *     Uses ETag for optimistic concurrency control.
     */
    post: operations['UpdateScenarioDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storyline/scenario/deprecate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Deprecate a scenario definition
     * @description Soft-deletes a scenario definition by marking it deprecated.
     *     Deprecated scenarios are not returned by find-available.
     */
    post: operations['DeprecateScenarioDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storyline/scenario/test': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Dry-run scenario trigger
     * @description Tests whether a scenario would trigger for a character without
     *     actually executing it. Returns detailed condition evaluation results
     *     and predicted mutations.
     */
    post: operations['TestScenarioTrigger'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storyline/scenario/get-active': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get active scenarios for a character
     * @description Returns currently executing scenarios for a character.
     */
    post: operations['GetActiveScenarios'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storyline/scenario/get-history': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get scenario execution history
     * @description Returns historical scenario executions for a character with pagination.
     */
    post: operations['GetScenarioHistory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storyline/get-compress-data': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get storyline data for compression
     * @description Called by Resource service during character compression.
     *     Returns scenario participations, active arcs, and completion counts for archival.
     */
    post: operations['getCompressData'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/subscription/account/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get subscriptions for an account
     * @description Returns all subscriptions for a given account, with optional filtering.
     */
    post: operations['getAccountSubscriptions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/subscription/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get a specific subscription by ID */
    post: operations['getSubscription'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/subscription/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel a subscription
     * @description Cancels a subscription. Users can cancel their own subscriptions,
     *     admins can cancel any subscription.
     */
    post: operations['cancelSubscription'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/voice/peer/answer': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Send SDP answer to complete WebRTC handshake
     * @description Called by clients after receiving a VoicePeerJoinedEvent containing an SDP offer.
     *     The client generates an SDP answer and sends it via this endpoint.
     *     The answering peer is notified via VoicePeerUpdatedEvent.
     *
     *     **Access Control**: This endpoint requires the `voice:ringing` state, which is
     *     automatically set by the Voice service when a VoicePeerJoinedEvent is sent to the client.
     *     The state is cleared after the answer is processed or times out.
     */
    post: operations['answerPeer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/voice/room/broadcast/request': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request broadcast consent from all room participants
     * @description Initiates the broadcast consent flow. All current room participants receive a VoiceBroadcastConsentRequestEvent. Broadcasting only starts after all participants consent. If ANY participant declines, the broadcast request is denied.
     *     This endpoint is the ONLY way to initiate voice room broadcasting. lib-stream subscribes to the resulting approval/decline events.
     */
    post: operations['requestBroadcastConsent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/voice/room/broadcast/consent': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Respond to a broadcast consent request
     * @description Called by each participant to consent or decline broadcasting. When all participants consent, lib-voice publishes voice.room.broadcast.approved. If any participant declines, lib-voice publishes voice.room.broadcast.declined.
     */
    post: operations['respondBroadcastConsent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/voice/room/broadcast/stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Stop broadcasting from a voice room
     * @description Any participant can stop an active broadcast at any time. This is equivalent to revoking consent. Publishes voice.room.broadcast.stopped with reason ConsentRevoked.
     */
    post: operations['stopBroadcast'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/voice/room/broadcast/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get broadcast status for a voice room
     * @description Returns the current broadcast state: whether consent is pending, active, or inactive.
     */
    post: operations['getBroadcastStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get website status and version */
    get: operations['getStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/content/{slug}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get dynamic page content from CMS */
    get: operations['getPageContent'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/news': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get latest news and announcements */
    get: operations['getNews'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/downloads': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get download links for game clients */
    get: operations['getDownloads'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/contact': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Submit contact form */
    post: operations['submitContact'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/account/profile': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get account profile for logged-in user */
    get: operations['getAccountProfile'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/cms/pages': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all CMS pages */
    get: operations['listPages'];
    put?: never;
    /** Create new CMS page */
    post: operations['createPage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/cms/pages/{slug}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /** Update CMS page */
    put: operations['updatePage'];
    post?: never;
    /** Delete CMS page */
    delete: operations['deletePage'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/cms/site-settings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get site configuration */
    get: operations['getSiteSettings'];
    /** Update site configuration */
    put: operations['updateSiteSettings'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/cms/theme': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get current theme configuration */
    get: operations['getTheme'];
    /** Update theme configuration */
    put: operations['updateTheme'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/clock/get-realm-time': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current game time for a realm
     * @description Returns full GameTimeSnapshot for a realm. Reads from Redis cache (hot path).
     */
    post: operations['getRealmTime'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/clock/get-realm-time-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current game time by realm code
     * @description Convenience endpoint accepting realm code string instead of GUID. Resolves to realm ID via IRealmClient, then delegates to GetRealmTime.
     */
    post: operations['getRealmTimeByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/clock/batch-get-realm-times': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current game time for multiple realms
     * @description Returns GameTimeSnapshot for multiple realms in a single call. Used by services operating across realms.
     */
    post: operations['batchGetRealmTimes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/clock/get-elapsed-game-time': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Compute elapsed game-time between two real timestamps
     * @description Given a realmId, fromRealTime, and toRealTime, computes total game-seconds elapsed. Integrates over ratio history segments. Critical for lazy evaluation patterns.
     */
    post: operations['getElapsedGameTime'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/clock/trigger-sync': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Trigger a time sync event for an entity's sessions
     * @description Publishes a WorldstateTimeSyncEvent with syncReason TriggerSync to a specific entity's connected sessions. Primary caller is Agency (L4) on realm entry for immediate client time sync.
     */
    post: operations['triggerTimeSync'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/clock/initialize': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Initialize a clock for a realm
     * @description The primary path from "realm exists" to "realm has a clock." Validates realm existence, calendar template existence, and that no clock already exists. Registers reference with lib-resource.
     */
    post: operations['initializeRealmClock'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/clock/set-ratio': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Change the time ratio for a realm
     * @description Materializes current clock state, records new ratio segment in history, updates realm clock. Setting ratio to 0.0 pauses the clock.
     */
    post: operations['setTimeRatio'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/clock/advance': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Manually advance a realm's clock
     * @description Advances a realm's clock by a specified amount of game time. Used for testing and administrative fast-forward. Publishes all boundary events crossed during advancement.
     */
    post: operations['advanceClock'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/calendar/seed': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a calendar template
     * @description Creates a calendar template for a game service. Validates structural consistency (day period coverage, season-month mapping, day count sums). Registers reference with lib-resource for game-service target.
     */
    post: operations['seedCalendar'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/calendar/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a calendar template
     * @description Returns a calendar template by game service ID and template code.
     */
    post: operations['getCalendar'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/calendar/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List calendar templates for a game service
     * @description Returns all calendar templates registered for a game service.
     */
    post: operations['listCalendars'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/calendar/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a calendar template
     * @description Partial update of a calendar template. Acquires distributed lock. Validates structural consistency. Cannot change template code or game service ID. Invalidates local cache and publishes CalendarTemplateUpdatedEvent for cross-node invalidation.
     */
    post: operations['updateCalendar'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/calendar/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a calendar template
     * @description Deletes a calendar template. Fails with Conflict if any active realm clocks reference this template. Acquires distributed lock. Unregisters reference with lib-resource.
     */
    post: operations['deleteCalendar'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/realm-config/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get realm worldstate configuration
     * @description Returns the realm's worldstate configuration including calendar template, time ratio, downtime policy, epoch, and active status.
     */
    post: operations['getRealmConfig'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/realm-config/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update realm worldstate configuration
     * @description Partial update of realm-level configuration. Acquires distributed lock. Supports changing downtimePolicy and calendarTemplateCode. Cannot change time ratio (use SetTimeRatio) or epoch (immutable).
     */
    post: operations['updateRealmConfig'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/worldstate/realm-config/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List active realm clocks
     * @description Lists all active realm clocks with summary info. Supports pagination and optional gameServiceId filter.
     */
    post: operations['listRealmClocks'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Request to abandon an active quest */
    AbandonQuestRequest: {
      /**
       * Format: uuid
       * @description Quest instance to abandon
       */
      questInstanceId: string;
      /**
       * Format: uuid
       * @description Character abandoning
       */
      questorCharacterId: string;
    };
    /** @description Request to abandon a scenario */
    AbandonScenarioRequest: {
      /**
       * Format: uuid
       * @description Account abandoning the scenario
       */
      accountId: string;
      /**
       * Format: uuid
       * @description Scenario instance to abandon
       */
      scenarioInstanceId: string;
    };
    /** @description Response after abandoning a scenario */
    AbandonScenarioResponse: {
      /**
       * Format: uuid
       * @description Abandoned scenario instance ID
       */
      scenarioInstanceId: string;
      /** @description Partial growth awarded based on time spent */
      partialGrowthAwarded: {
        [key: string]: number;
      };
    };
    /** @description Request to accept a formed match */
    AcceptMatchRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the match to accept
       */
      matchId: string;
    };
    /** @description Response after accepting a match */
    AcceptMatchResponse: {
      /**
       * Format: uuid
       * @description Match identifier
       */
      matchId: string;
      /** @description Whether all players have accepted */
      allAccepted: boolean;
      /** @description Number of players who have accepted */
      acceptedCount?: number | null;
      /** @description Total players who need to accept */
      totalCount?: number | null;
      /**
       * Format: uuid
       * @description Game session ID (set when all players accept)
       */
      gameSessionId?: string | null;
    };
    /** @description Request to accept a quest and create an active instance */
    AcceptQuestRequest: {
      /**
       * Format: uuid
       * @description Quest definition ID (provide either this or code)
       */
      definitionId?: string | null;
      /** @description Quest code (provide either this or definitionId) */
      code?: string | null;
      /**
       * Format: uuid
       * @description Character accepting the quest
       */
      questorCharacterId: string;
      /**
       * Format: uuid
       * @description NPC offering the quest
       */
      questGiverCharacterId?: string | null;
      /** @description Template variable overrides */
      termOverrides?: {
        [key: string]: string;
      } | null;
    };
    /** @description User account information displayed on the website profile page */
    AccountProfile: {
      /**
       * Format: uuid
       * @description Unique identifier for the account
       */
      accountId: string;
      /**
       * Format: email
       * @description Email address associated with the account
       */
      email: string;
      /** @description User-chosen display name */
      displayName?: string | null;
      /**
       * Format: date-time
       * @description Date and time when the account was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Date and time of the last successful login
       */
      lastLogin?: string | null;
    };
    /** @description Account information response */
    AccountResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the account
       */
      accountId: string;
      /**
       * Format: email
       * @description Email address associated with the account. Null for OAuth/Steam accounts without email.
       */
      email?: string | null;
      /** @description Display name for the account */
      displayName?: string | null;
      /** @description BCrypt hashed password for authentication */
      passwordHash?: string | null;
      /**
       * Format: date-time
       * @description Timestamp when the account was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the account was last updated
       */
      updatedAt?: string | null;
      /** @description Whether the email address has been verified */
      emailVerified: boolean;
      /** @description List of roles assigned to the account */
      roles: string[];
      /** @description List of authentication methods linked to the account */
      authMethods: components['schemas']['AuthMethodInfo'][];
      /** @description Client-only metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * @description Whether multi-factor authentication is enabled for this account
       * @default false
       */
      mfaEnabled: boolean;
      /** @description Encrypted TOTP secret (AES-256-GCM ciphertext). Auth service encrypts and decrypts. Account stores opaque ciphertext. */
      mfaSecret?: string | null;
      /** @description BCrypt-hashed single-use recovery codes. Auth service generates and verifies. Account stores opaque hashes. */
      mfaRecoveryCodes?: string[] | null;
    };
    /** @description Achievement definition details */
    AchievementDefinitionResponse: {
      /**
       * Format: uuid
       * @description ID of the owning game service
       */
      gameServiceId: string;
      /** @description Unique identifier */
      achievementId: string;
      /** @description Human-readable name */
      displayName: string;
      /** @description How to earn this achievement */
      description: string;
      /** @description Description for hidden achievements */
      hiddenDescription?: string | null;
      /** @description Classification of the achievement */
      achievementType: components['schemas']['AchievementType'];
      /** @description Allowed entity types */
      entityTypes?: components['schemas']['EntityType'][];
      /** @description Target for progressive achievements */
      progressTarget?: number | null;
      /** @description Point value */
      points: number;
      /** @description Achievement icon URL */
      iconUrl?: string | null;
      /** @description Available platforms */
      platforms?: components['schemas']['Platform'][];
      /** @description Platform-specific IDs */
      platformIds?: {
        [key: string]: string;
      } | null;
      /** @description Required achievements */
      prerequisites?: string[] | null;
      /** @description Whether achievement is earnable */
      isActive: boolean;
      /**
       * Format: int64
       * @description How many entities have earned this
       */
      earnedCount?: number;
      /**
       * Format: date-time
       * @description When the achievement was created
       */
      createdAt: string;
      /** @description Additional metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Progress toward a single achievement */
    AchievementProgress: {
      /** @description Achievement identifier */
      achievementId: string;
      /** @description Achievement display name */
      displayName?: string;
      /** @description Current progress (for progressive) */
      currentProgress?: number | null;
      /** @description Target progress (for progressive) */
      targetProgress?: number | null;
      /**
       * Format: double
       * @description Completion percentage (0-100)
       */
      percentComplete?: number | null;
      /** @description Whether achievement is unlocked */
      isUnlocked: boolean;
      /**
       * Format: date-time
       * @description When achievement was unlocked
       */
      unlockedAt?: string | null;
    };
    /** @description Achievement progress for an entity */
    AchievementProgressResponse: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type that owns this progress summary */
      entityType: components['schemas']['EntityType'];
      /** @description Progress for each achievement */
      progress: components['schemas']['AchievementProgress'][];
      /** @description Total points from unlocked achievements */
      totalPoints?: number;
      /** @description Number of unlocked achievements */
      unlockedCount?: number;
    };
    /**
     * @description Type of achievement
     * @enum {string}
     */
    AchievementType: 'standard' | 'progressive' | 'hidden' | 'secret';
    /** @description Effect of an action on world state */
    ActionEffect: {
      /** @description State key to modify */
      key: string;
      /** @description New value to set (any type) */
      value: unknown;
      /** @description How the effect is applied */
      cardinality?: components['schemas']['EffectCardinality'];
    };
    /** @description A registered mapping from a GOAP action tag to violation type codes */
    ActionMappingResponse: {
      /** @description The GOAP action tag (e.g., "steal_food", "deceive_merchant") */
      tag: string;
      /** @description Violation type codes this tag maps to (e.g., ["theft", "dishonesty"]) */
      violationTypes: string[];
      /** @description Human-readable description of what this mapping represents */
      description?: string | null;
      /**
       * Format: date-time
       * @description When this mapping was first created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When this mapping was last modified
       */
      updatedAt?: string | null;
    };
    /** @description Request to activate a dormant deity */
    ActivateDeityRequest: {
      /**
       * Format: uuid
       * @description Deity to activate
       */
      deityId: string;
    };
    /** @description Request to activate a seed. */
    ActivateSeedRequest: {
      /**
       * Format: uuid
       * @description The seed to activate.
       */
      seedId: string;
    };
    /** @description Summary of an active quest for archive purposes */
    ActiveQuestSummary: {
      /**
       * Format: uuid
       * @description Quest instance ID
       */
      questId: string;
      /** @description Quest code for lookup */
      questCode: string;
      /** @description Quest display name */
      name: string;
      /** @description Number of completed objectives */
      currentObjective: number;
      /** @description Total number of objectives */
      totalObjectives: number;
      /**
       * Format: date-time
       * @description When the quest was accepted
       */
      startedAt: string;
      /** @description Quest category (if available) */
      category?: components['schemas']['QuestCategory'];
    };
    /**
     * @description Actor-specific capabilities that affect affordance evaluation.
     *     Same location may afford different actions to different actor types.
     */
    ActorCapabilities: {
      /** @description Affects cover requirements and passage width */
      size?: components['schemas']['ActorSize'];
      /** @description Actor height in meters (affects cover, sightlines) */
      height?: number | null;
      /**
       * @description Can reach elevated positions
       * @default false
       */
      canClimb: boolean;
      /**
       * @description Includes water-based positions
       * @default false
       */
      canSwim: boolean;
      /**
       * @description Includes aerial positions
       * @default false
       */
      canFly: boolean;
      /** @description Affects sightline distance requirements */
      perceptionRange?: number | null;
      /** @description Affects escape route viability calculations */
      movementSpeed?: number | null;
      /** @description Affects ambush/hidden_path affordance scoring */
      stealthRating?: number | null;
    };
    /** @description Response containing actor instance details */
    ActorInstanceResponse: {
      /** @description Unique actor identifier */
      actorId: string;
      /**
       * Format: uuid
       * @description Template this actor was instantiated from
       */
      templateId: string;
      /** @description Actor category from template */
      category: string;
      /** @description Pool node running this actor (null in bannou mode) */
      nodeId?: string | null;
      /** @description Pool node's app-id for direct messaging */
      nodeAppId?: string | null;
      /** @description Current actor lifecycle state */
      status: components['schemas']['ActorStatus'];
      /**
       * Format: uuid
       * @description Associated character ID (for NPC brains)
       */
      characterId?: string | null;
      /**
       * Format: uuid
       * @description Realm the actor operates in (resolved at spawn time)
       */
      realmId?: string | null;
      /**
       * Format: date-time
       * @description When the actor started running
       */
      startedAt: string;
      /**
       * Format: date-time
       * @description Last heartbeat timestamp from the actor
       */
      lastHeartbeat?: string | null;
      /**
       * Format: int64
       * @description Number of behavior loop iterations executed. Null when the actor is running on a remote pool node and the iteration count is not locally available.
       */
      loopIterations?: number | null;
    };
    /**
     * @description Size classification affecting cover requirements and passage width
     * @default medium
     * @enum {string}
     */
    ActorSize: 'tiny' | 'small' | 'medium' | 'large' | 'huge';
    /**
     * @description Current actor lifecycle state
     * @enum {string}
     */
    ActorStatus: 'pending' | 'starting' | 'running' | 'paused' | 'stopping' | 'stopped' | 'error';
    /** @description Response containing actor template details */
    ActorTemplateResponse: {
      /**
       * Format: uuid
       * @description Unique template identifier
       */
      templateId: string;
      /** @description Category identifier */
      category: string;
      /** @description Reference to behavior in lib-assets */
      behaviorRef: string;
      /** @description Game-specific configuration passed to ABML behavior execution scope. No Bannou plugin reads specific keys from this field by convention. */
      configuration?: {
        [key: string]: unknown;
      } | null;
      /** @description Auto-spawn configuration for instantiate-on-access */
      autoSpawn?: components['schemas']['AutoSpawnConfig'];
      /** @description Milliseconds between behavior loop iterations */
      tickIntervalMs: number;
      /** @description Seconds between automatic state saves */
      autoSaveIntervalSeconds: number;
      /** @description Maximum actors of this category per pool node */
      maxInstancesPerNode: number;
      /**
       * @description Cognition template ID for this actor type. Primary source for cognition
       *     pipeline resolution. When null, falls back to ABML metadata, then category default.
       */
      cognitionTemplateId?: string | null;
      /** @description Static template-level cognition overrides (polymorphic JSON). Deserialized internally to CognitionOverrides type with discriminated subtypes. No Bannou plugin reads specific keys from this field by convention. */
      cognitionOverrides?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When the template was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the template was last updated
       */
      updatedAt: string;
    };
    /** @description Request to add item to container */
    AddItemRequest: {
      /**
       * Format: uuid
       * @description Item instance ID to add
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Target container ID
       */
      containerId: string;
      /** @description Specific slot (auto-assign if null) */
      slotIndex?: number | null;
      /** @description Grid X position */
      slotX?: number | null;
      /** @description Grid Y position */
      slotY?: number | null;
      /** @description Rotate in grid */
      rotated?: boolean | null;
      /**
       * @description Auto-merge with existing stacks
       * @default true
       */
      autoStack: boolean;
    };
    /** @description Response after adding item. HTTP 200 confirms placement. */
    AddItemResponse: {
      /** @description Assigned slot */
      slotIndex?: number | null;
      /** @description Assigned X position */
      slotX?: number | null;
      /** @description Assigned Y position */
      slotY?: number | null;
      /**
       * Format: uuid
       * @description Instance merged into if stacked
       */
      mergedWithInstanceId?: string | null;
    };
    /** @description Request to add a license definition to a board template */
    AddLicenseDefinitionRequest: {
      /**
       * Format: uuid
       * @description Board template to add this definition to
       */
      boardTemplateId: string;
      /** @description Unique license code within this board template */
      code: string;
      /** @description Grid position for this license node */
      position: components['schemas']['GridPosition'];
      /** @description License Point cost to unlock this node */
      lpCost: number;
      /**
       * Format: uuid
       * @description Item template created when this license is unlocked
       */
      itemTemplateId: string;
      /** @description License codes that must be unlocked before this one (non-adjacent requirements) */
      prerequisites?: string[] | null;
      /** @description Human-readable description of what this license grants */
      description?: string | null;
      /** @description Game-specific metadata for this license node. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to add a character to a faction */
    AddMemberRequest: {
      /**
       * Format: uuid
       * @description Faction to add the character to
       */
      factionId: string;
      /**
       * Format: uuid
       * @description Character to add as a member
       */
      characterId: string;
      /** @description Role to assign (null uses configured default) */
      role?: components['schemas']['FactionMemberRole'];
    };
    /**
     * @description Grid traversal adjacency mode for a board template.
     *     - four_way: Orthogonal only (up, down, left, right)
     *     - eight_way: Orthogonal + diagonal (all 8 surrounding cells)
     * @enum {string}
     */
    AdjacencyMode: 'four_way' | 'eight_way';
    /** @description Result of admin-triggered idle room cleanup */
    AdminCleanupResponse: {
      /** @description Total rooms processed by cleanup */
      cleanedRooms: number;
      /** @description Number of rooms archived */
      archivedRooms: number;
      /** @description Number of rooms deleted */
      deletedRooms: number;
    };
    /** @description Empty request body for force cleanup */
    AdminForceCleanupRequest: Record<string, never>;
    /** @description Empty request body for stats endpoint */
    AdminGetStatsRequest: Record<string, never>;
    /** @description Admin request to list all rooms with filters and pagination */
    AdminListRoomsRequest: {
      /** @description Filter by room type */
      roomTypeCode?: string | null;
      /** @description Filter by status */
      status?: components['schemas']['ChatRoomStatus'] | null;
      /**
       * @description Page number (zero-based)
       * @default 0
       */
      page: number;
      /**
       * @description Number of items per page
       * @default 50
       */
      pageSize: number;
    };
    /** @description System-wide chat statistics for admin monitoring */
    AdminStatsResponse: {
      /** @description Total number of rooms in the system */
      totalRooms: number;
      /** @description Number of active rooms */
      activeRooms: number;
      /** @description Number of locked rooms */
      lockedRooms: number;
      /** @description Number of archived rooms */
      archivedRooms: number;
      /** @description Total participants across all rooms */
      totalParticipants: number;
      /** @description Total registered room types */
      totalRoomTypes: number;
    };
    /** @description Request to manually advance a realm's clock by a specified amount */
    AdvanceClockRequest: {
      /**
       * Format: uuid
       * @description Realm to advance the clock for
       */
      realmId: string;
      /**
       * Format: int64
       * @description Number of game-seconds to advance
       */
      gameSeconds?: number | null;
      /** @description Number of game-days to advance */
      gameDays?: number | null;
      /** @description Number of game-months to advance (uses current calendar structure) */
      gameMonths?: number | null;
      /** @description Number of game-years to advance (uses current calendar structure) */
      gameYears?: number | null;
    };
    /** @description Result of manual clock advancement */
    AdvanceClockResponse: {
      /**
       * Format: uuid
       * @description Realm the clock was advanced for
       */
      realmId: string;
      /** @description Game time before advancement */
      previousTime: components['schemas']['GameTimeSnapshot'];
      /** @description Game time after advancement */
      newTime: components['schemas']['GameTimeSnapshot'];
      /** @description Number of boundary events published during advancement */
      boundaryEventsPublished: number;
    };
    /** @description Request to advance the discovery level of an unlocked entry */
    AdvanceDiscoveryRequest: {
      /**
       * Format: uuid
       * @description Collection containing the entry
       */
      collectionId: string;
      /** @description Entry code to advance discovery for */
      entryCode: string;
    };
    /** @description Result of advancing discovery level */
    AdvanceDiscoveryResponse: {
      /** @description Entry code that was advanced */
      entryCode: string;
      /** @description New discovery level after advancement */
      newLevel: number;
      /** @description Information keys revealed at the new level */
      reveals: string[];
    };
    /**
     * @description Describes a capability or interaction mode for a node.
     *     Used by AI systems to understand what actions are possible and by
     *     character controllers for contextual animations.
     */
    Affordance: {
      /** @description The type of affordance */
      type: components['schemas']['AffordanceType'];
      /** @description Game-specific affordance parameters interpreted by game engines and AI systems. No Bannou plugin reads specific keys from this field by convention. */
      parameters?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Controls caching behavior for affordance queries
     * @default cached
     * @enum {string}
     */
    AffordanceFreshness: 'fresh' | 'cached' | 'aggressive_cache';
    /** @description A location that affords the requested action */
    AffordanceLocation: {
      /** @description Location position */
      position?: components['schemas']['Position3D'];
      /** @description Area bounds if affordance spans an area */
      bounds?: components['schemas']['Bounds'];
      /** @description How well this location affords the action (0-1) */
      score?: number;
      /** @description Game-specific features of this affordance result. No Bannou plugin reads specific keys from this field by convention. */
      features?: {
        [key: string]: unknown;
      } | null;
      /** @description Map objects contributing to this affordance */
      objectIds?: string[] | null;
    };
    /** @description Metadata about the affordance query execution */
    AffordanceQueryMetadata: {
      /** @description Map kinds that were queried */
      kindsSearched?: string[] | null;
      /** @description Number of candidate objects evaluated */
      objectsEvaluated?: number;
      /** @description Number of candidate positions generated */
      candidatesGenerated?: number;
      /** @description Query execution time in milliseconds */
      searchDurationMs?: number;
      /** @description Whether results came from cache */
      cacheHit?: boolean;
    };
    /** @description Query for locations that afford a specific action */
    AffordanceQueryRequest: {
      /**
       * Format: uuid
       * @description Region to search
       */
      regionId: string;
      /** @description Type of affordance to search for */
      affordanceType: components['schemas']['AffordanceType'];
      /** @description Custom affordance definition (when affordanceType=custom) */
      customAffordance?: components['schemas']['CustomAffordance'];
      /** @description Optional bounds to search within */
      bounds?: components['schemas']['Bounds'];
      /**
       * @description Maximum locations to return
       * @default 10
       */
      maxResults: number;
      /**
       * @description Minimum affordance score to include
       * @default 0.5
       */
      minScore: number;
      /** @description Expected participants (affects space requirements) */
      participantCount?: number | null;
      /** @description Positions to exclude (e.g., player's current location) */
      excludePositions?: components['schemas']['Position3D'][] | null;
      /** @description Actor capabilities affecting evaluation */
      actorCapabilities?: components['schemas']['ActorCapabilities'];
      /** @description Cache freshness level */
      freshness?: components['schemas']['AffordanceFreshness'];
      /** @description Max age of cached results (for cached/aggressive_cache) */
      maxAgeSeconds?: number | null;
    };
    /** @description Affordance query results */
    AffordanceQueryResponse: {
      /** @description Scored locations (highest score first) */
      locations?: components['schemas']['AffordanceLocation'][];
      /** @description Metadata about query execution (optional) */
      queryMetadata?: components['schemas']['AffordanceQueryMetadata'];
    };
    /**
     * @description Well-known affordance types with predefined scoring logic.
     *     Use 'custom' for novel affordance definitions.
     * @enum {string}
     */
    AffordanceType:
      | 'ambush'
      | 'shelter'
      | 'vista'
      | 'choke_point'
      | 'gathering_spot'
      | 'dramatic_reveal'
      | 'hidden_path'
      | 'defensible_position'
      | 'custom';
    /** @description Analytics and tracking configuration for website visitor metrics */
    Analytics: {
      /** @description Google Analytics tracking ID */
      googleAnalyticsId?: string | null;
      /** @description Configuration for other analytics trackers. No Bannou plugin reads specific keys from this field by convention. */
      otherTrackers?: {
        [key: string]: unknown;
      };
    };
    /**
     * @description Request to send an SDP answer to complete a WebRTC handshake.
     *     Sent by clients after receiving a VoicePeerJoinedEvent with an SDP offer.
     */
    AnswerPeerRequest: {
      /**
       * Format: uuid
       * @description Voice room ID
       */
      roomId: string;
      /**
       * Format: uuid
       * @description Session ID of the answering peer (caller of this endpoint)
       */
      senderSessionId: string;
      /**
       * Format: uuid
       * @description Session ID of the peer whose offer we're answering
       */
      targetSessionId: string;
      /** @description SDP answer generated by this client's WebRTC stack */
      sdpAnswer: string;
      /** @description ICE candidates for NAT traversal (can be trickled later) */
      iceCandidates?: string[];
    };
    /**
     * @description Emotional arc shapes from Reagan et al. research.
     *     RagsToRiches: Rise (1)
     *     Tragedy: Fall (2)
     *     ManInHole: Fall then rise (3)
     *     Icarus: Rise then fall (4)
     *     Cinderella: Rise, fall, rise (5)
     *     Oedipus: Fall, rise, fall (6)
     * @enum {string}
     */
    ArcType: 'RagsToRiches' | 'Tragedy' | 'ManInHole' | 'Icarus' | 'Cinderella' | 'Oedipus';
    /** @description Single entry in the archive bundle */
    ArchiveBundleEntry: {
      /** @description Type of data (e.g., "character-personality") */
      sourceType: string;
      /** @description Service that provided the data */
      serviceName: string;
      /** @description Base64-encoded gzipped JSON from the service callback */
      data: string;
      /**
       * Format: date-time
       * @description When this entry was compressed
       */
      compressedAt: string;
      /** @description SHA256 hash for integrity verification */
      dataChecksum?: string | null;
      /** @description Size before compression */
      originalSizeBytes?: number | null;
    };
    /** @description Archive metadata including size and document count */
    ArchiveInfo: {
      /**
       * Format: uuid
       * @description Unique identifier of the archive
       */
      archiveId: string;
      /** @description Namespace the archive belongs to */
      namespace: string;
      /**
       * Format: uuid
       * @description Asset ID in Asset Service
       */
      bundleAssetId?: string;
      /** @description Description of the archive */
      description?: string | null;
      /** @description Number of documents in the archive */
      documentCount?: number;
      /** @description Total size of the archive in bytes */
      sizeBytes?: number;
      /** @description Git commit hash if namespace was bound at archive time */
      commitHash?: string | null;
      /**
       * Format: date-time
       * @description Timestamp when the archive was created
       */
      createdAt: string;
      /**
       * @description Owner of this archive. NOT a session ID.
       *     Contains either an accountId (UUID format) for user-initiated archives
       *     or a service name for service-initiated archives.
       */
      owner?: string;
    };
    /** @description Request to archive a room (makes it read-only) */
    ArchiveRoomRequest: {
      /**
       * Format: uuid
       * @description Room ID to archive
       */
      roomId: string;
    };
    /** @description Request to archive a seed. */
    ArchiveSeedRequest: {
      /**
       * Format: uuid
       * @description The seed to archive.
       */
      seedId: string;
    };
    /** @description Area content configuration */
    AreaContentConfigResponse: {
      /**
       * Format: uuid
       * @description Unique area config identifier
       */
      areaConfigId: string;
      /** @description Area code */
      areaCode: string;
      /**
       * Format: uuid
       * @description Game service this area config belongs to
       */
      gameServiceId: string;
      /** @description Type of collection this config applies to */
      collectionType: components['schemas']['CollectionType'];
      /** @description Theme tags for this area */
      themes: string[];
      /** @description Default entry code */
      defaultEntryCode: string;
      /**
       * Format: date-time
       * @description When this area config was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When this area config was last updated
       */
      updatedAt?: string | null;
    };
    /** @description Describes a conflict when the same asset ID has different content hashes */
    AssetConflict: {
      /** @description The conflicting asset identifier */
      assetId: string;
      /** @description Bundles with conflicting versions of this asset */
      conflictingBundles: components['schemas']['ConflictingBundleEntry'][];
    };
    /** @description Complete asset metadata including system-generated fields */
    AssetMetadata: {
      /** @description Unique asset identifier */
      assetId: string;
      /** @description SHA256 hash of file contents */
      contentHash: string;
      /** @description Original filename */
      filename: string;
      /** @description MIME content type */
      contentType: string;
      /**
       * Format: int64
       * @description File size in bytes
       */
      size: number;
      /** @description Type classification for the asset */
      assetType: components['schemas']['AssetType'];
      /** @description Game realm the asset belongs to */
      realm: components['schemas']['GameRealm'];
      /** @description Searchable tags for the asset */
      tags: string[];
      /** @description Current status of asset processing pipeline */
      processingStatus: components['schemas']['ProcessingStatus'];
      /**
       * @description Whether the asset is in cold/archival storage
       * @default false
       */
      isArchived: boolean;
      /**
       * Format: date-time
       * @description Timestamp when the asset was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the asset was last updated
       */
      updatedAt: string;
    };
    /** @description User-provided metadata for asset categorization */
    AssetMetadataInput: {
      /** @description Type classification for the asset */
      assetType?: components['schemas']['AssetType'];
      /** @description Game realm the asset belongs to */
      realm?: components['schemas']['GameRealm'];
      /** @description Searchable tags for the asset */
      tags?: string[];
    };
    /** @description Reference to an asset in lib-asset */
    AssetReference: {
      /**
       * Format: uuid
       * @description Optional bundle containing the asset
       */
      bundleId?: string | null;
      /**
       * Format: uuid
       * @description Asset identifier in lib-asset
       */
      assetId: string;
      /** @description Variant identifier (consumer interprets meaning) */
      variantId?: string | null;
    };
    /** @description Information about a required asset */
    AssetRequirementInfo: {
      /** @description Asset type (currency, item, item_stack) */
      type: string;
      /** @description Currency code or item template code */
      code: string;
      /** @description Amount or quantity required */
      amount: number;
    };
    /** @description Search criteria for filtering assets with pagination */
    AssetSearchRequest: {
      /** @description Filter by tags (assets must have all specified tags) (null to skip tag filtering) */
      tags?: string[] | null;
      /** @description Filter by asset type */
      assetType: components['schemas']['AssetType'];
      /** @description Filter by game realm */
      realm: components['schemas']['GameRealm'];
      /** @description MIME content type filter (null to skip content type filtering) */
      contentType?: string | null;
      /**
       * @description Maximum number of results to return
       * @default 50
       */
      limit: number;
      /**
       * @description Number of results to skip for pagination
       * @default 0
       */
      offset: number;
    };
    /** @description Paginated results from an asset search query */
    AssetSearchResult: {
      /** @description List of matching assets */
      assets: components['schemas']['AssetMetadata'][];
      /** @description Total number of matching assets */
      total: number;
      /** @description Maximum number of results returned per page */
      limit: number;
      /** @description Number of results skipped */
      offset: number;
    };
    /**
     * @description Defines acceptable asset types for procedural swapping at this node.
     *     Used by procedural generation systems to substitute assets while
     *     maintaining scene coherence.
     */
    AssetSlot: {
      /**
       * @description Category of acceptable assets.
       *     Examples: chair, table, wall_art, floor_lamp
       */
      slotType: string;
      /**
       * @description Tags that acceptable assets must have.
       *     Used for filtering when selecting random variations.
       */
      acceptsTags?: string[];
      /** @description Default asset if no specific asset is bound */
      defaultAsset?: components['schemas']['AssetReference'];
      /**
       * @description Pre-approved asset variations for random selection.
       *     Procedural systems pick from this list rather than searching all assets.
       */
      variations?: components['schemas']['AssetReference'][];
    };
    /**
     * @description Type classification for assets
     * @enum {string}
     */
    AssetType: 'texture' | 'model' | 'audio' | 'behavior' | 'bundle' | 'prefab' | 'other';
    /** @description Information about asset usage */
    AssetUsageInfo: {
      /**
       * Format: uuid
       * @description Scene using the asset
       */
      sceneId: string;
      /** @description Scene name */
      sceneName: string;
      /**
       * Format: uuid
       * @description Node using the asset
       */
      nodeId: string;
      /** @description refId of the node */
      nodeRefId: string;
      /** @description Node name */
      nodeName?: string;
      /** @description Type of the node */
      nodeType?: components['schemas']['NodeType'];
    };
    /** @description Metadata for a specific version of an asset */
    AssetVersion: {
      /** @description Unique version identifier */
      versionId: string;
      /**
       * Format: date-time
       * @description Timestamp when this version was created
       */
      createdAt: string;
      /**
       * Format: int64
       * @description File size in bytes for this version
       */
      size: number;
      /** @description Whether this version is in cold storage */
      isArchived: boolean;
    };
    /** @description Paginated list of asset versions */
    AssetVersionList: {
      /** @description Asset identifier */
      assetId: string;
      /** @description List of asset versions */
      versions: components['schemas']['AssetVersion'][];
      /** @description Total number of versions available */
      total: number;
      /** @description Maximum number of versions returned per page */
      limit: number;
      /** @description Number of versions skipped */
      offset: number;
    };
    /** @description Asset metadata with optional pre-signed download URL */
    AssetWithDownloadUrl: {
      /** @description Unique asset identifier */
      assetId: string;
      /** @description Version identifier for this specific asset version */
      versionId: string;
      /**
       * Format: uri
       * @description Pre-signed download URL (only populated when requested)
       */
      downloadUrl?: string | null;
      /**
       * Format: date-time
       * @description When the download URL expires (only populated when requested)
       */
      expiresAt?: string | null;
      /**
       * Format: int64
       * @description File size in bytes
       */
      size: number;
      /** @description SHA256 hash of file contents */
      contentHash: string;
      /** @description MIME content type */
      contentType: string;
      /** @description Complete asset metadata */
      metadata: components['schemas']['AssetMetadata'];
    };
    /**
     * @description A predefined location where child objects can be attached.
     *     Used for decorating furniture, walls, and other objects with accessories.
     *     Example: A wall may have attachment points for paintings, shelves, or light fixtures.
     */
    AttachmentPoint: {
      /**
       * @description Unique name for this attachment point within the node.
       *     Examples: wall_hook_left, shelf_1, lamp_socket
       */
      name: string;
      /** @description Position and orientation relative to the owning node */
      localTransform: components['schemas']['Transform'];
      /**
       * @description Tags of assets that can attach here.
       *     Examples: wall_decoration, picture_frame, plant
       */
      acceptsTags?: string[];
      /** @description Default asset to display if no specific attachment is specified */
      defaultAsset?: components['schemas']['AssetReference'];
      /**
       * Format: uuid
       * @description ID of the node currently attached at this point (runtime state)
       */
      attachedNodeId?: string | null;
    };
    /** @description Information about a linked authentication method */
    AuthMethodInfo: {
      /**
       * Format: uuid
       * @description Unique identifier for the authentication method
       */
      methodId?: string | null;
      /** @description Authentication provider type */
      provider: components['schemas']['AuthProvider'];
      /** @description External user ID from the authentication provider */
      externalId?: string | null;
      /** @description Display name from the authentication provider */
      displayName?: string | null;
      /**
       * Format: date-time
       * @description Timestamp when the authentication method was linked
       */
      linkedAt: string;
    };
    /**
     * @description All authentication provider types including email
     * @enum {string}
     */
    AuthProvider: 'email' | 'google' | 'discord' | 'twitch' | 'steam';
    /** @description Successful authentication response containing tokens and session information */
    AuthResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the authenticated account
       */
      accountId: string;
      /** @description JWT access token for API authentication */
      accessToken: string;
      /** @description Token used to obtain new access tokens when the current one expires */
      refreshToken: string;
      /** @description Seconds until access token expires */
      expiresIn: number;
      /**
       * Format: uri
       * @description WebSocket endpoint for Connect service
       */
      connectUrl: string;
      /** @description List of roles assigned to the authenticated user */
      roles?: string[] | null;
    };
    /**
     * @description Authentication mechanism type (oauth = browser redirect, ticket = game client token)
     * @enum {string}
     */
    AuthType: 'oauth' | 'ticket';
    /** @description Request to checkout for authoring */
    AuthoringCheckoutRequest: {
      /**
       * Format: uuid
       * @description Region to checkout
       */
      regionId: string;
      /** @description Map kind to checkout */
      kind: components['schemas']['MapKind'];
      /** @description Identifier for the editor/user */
      editorId: string;
    };
    /** @description Checkout response */
    AuthoringCheckoutResponse: {
      /** @description Token for publishing changes (if successful) */
      authorityToken?: string | null;
      /**
       * Format: date-time
       * @description When the checkout expires
       */
      expiresAt?: string | null;
      /** @description Who has the lock (if checkout failed) */
      lockedBy?: string | null;
      /**
       * Format: date-time
       * @description When the lock was acquired (if checkout failed)
       */
      lockedAt?: string | null;
    };
    /** @description Request to commit authoring changes */
    AuthoringCommitRequest: {
      /**
       * Format: uuid
       * @description Region being edited
       */
      regionId: string;
      /** @description Map kind being edited */
      kind: components['schemas']['MapKind'];
      /** @description Checkout authority token */
      authorityToken: string;
      /** @description Optional commit message for history */
      commitMessage?: string | null;
    };
    /** @description Commit response */
    AuthoringCommitResponse: {
      /**
       * Format: int64
       * @description Committed version number
       */
      version?: number | null;
    };
    /** @description Request to release authoring checkout */
    AuthoringReleaseRequest: {
      /**
       * Format: uuid
       * @description Region being edited
       */
      regionId: string;
      /** @description Map kind being edited */
      kind: components['schemas']['MapKind'];
      /** @description Checkout authority token */
      authorityToken: string;
    };
    /** @description Release response */
    AuthoringReleaseResponse: {
      /** @description Whether checkout was released */
      released?: boolean;
    };
    /** @description Configuration for instantiate-on-access behavior */
    AutoSpawnConfig: {
      /**
       * @description If true, accessing a non-existent actor creates it
       * @default false
       */
      enabled: boolean;
      /**
       * @description Regex pattern for actor IDs that trigger auto-spawn.
       *     Examples: "npc-.*" matches "npc-grok", "npc-merchant-123"
       */
      idPattern?: string | null;
      /** @description Maximum auto-spawned instances (0 = unlimited) */
      maxInstances?: number | null;
      /**
       * @description 1-based regex capture group index for extracting CharacterId from actor ID.
       *     Example: With idPattern "npc-brain-([a-f0-9-]+)" and characterIdCaptureGroup: 1,
       *     actor ID "npc-brain-abc-123-def" extracts "abc-123-def" as CharacterId (parsed as GUID).
       */
      characterIdCaptureGroup?: number | null;
      /**
       * Format: uuid
       * @description Default realm ID for auto-spawned actors when no CharacterId is available to resolve a realm.
       *     Required when characterIdCaptureGroup is not configured and auto-spawn is enabled.
       */
      defaultRealmId?: string | null;
    };
    /** @description Autogain status for a balance */
    AutogainInfo: {
      /**
       * Format: date-time
       * @description When autogain was last calculated
       */
      lastCalculatedAt: string;
      /**
       * Format: date-time
       * @description When the next autogain will apply
       */
      nextGainAt: string;
      /**
       * Format: double
       * @description Estimated next gain amount
       */
      nextGainAmount: number;
      /** @description Current autogain mode */
      mode: components['schemas']['AutogainMode'];
    };
    /**
     * @description How autogain (energy/interest) is calculated
     * @enum {string}
     */
    AutogainMode: 'simple' | 'compound';
    /** @description A machine-readable backstory element for behavior system consumption */
    BackstoryElement: {
      /** @description Category of this backstory element */
      elementType: components['schemas']['BackstoryElementType'];
      /**
       * @description Machine-readable key (e.g., "homeland", "trained_by", "past_job").
       *     Used by behavior system to query specific aspects.
       */
      key: string;
      /**
       * @description Machine-readable value (e.g., "northlands", "knights_guild", "blacksmith").
       *     Referenced in behavior rules.
       */
      value: string;
      /**
       * Format: float
       * @description How strongly this element affects behavior (0.0 to 1.0).
       *     Higher strength = greater influence on decisions.
       * @default 0.5
       */
      strength: number;
      /**
       * Format: uuid
       * @description Optional related entity (location, organization, character)
       */
      relatedEntityId?: string | null;
      /** @description Type of the related entity (if any) */
      relatedEntityType?: string | null;
    };
    /**
     * @description Types of backstory elements. Each type represents a different aspect
     *     of the character's background that influences behavior.
     * @enum {string}
     */
    BackstoryElementType:
      | 'ORIGIN'
      | 'OCCUPATION'
      | 'TRAINING'
      | 'TRAUMA'
      | 'ACHIEVEMENT'
      | 'SECRET'
      | 'GOAL'
      | 'FEAR'
      | 'BELIEF';
    /** @description Complete backstory data for a character */
    BackstoryResponse: {
      /**
       * Format: uuid
       * @description ID of the character this backstory belongs to
       */
      characterId: string;
      /** @description All backstory elements for this character */
      elements: components['schemas']['BackstoryElement'][];
      /**
       * Format: date-time
       * @description When this backstory was first created
       */
      createdAt?: string | null;
      /**
       * Format: date-time
       * @description When this backstory was last modified
       */
      updatedAt?: string | null;
    };
    /** @description Snapshot of a backstory element */
    BackstorySnapshot: {
      /** @description Backstory element type (e.g., TRAUMA, GOAL) */
      elementType: string;
      /** @description Backstory element key */
      key: string;
    };
    /** @description A single balance query */
    BalanceQuery: {
      /**
       * Format: uuid
       * @description Wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency definition ID
       */
      currencyDefinitionId: string;
    };
    /** @description Summary of a balance in a wallet */
    BalanceSummary: {
      /**
       * Format: uuid
       * @description Currency definition ID
       */
      currencyDefinitionId: string;
      /** @description Currency code for convenience */
      currencyCode: string;
      /**
       * Format: double
       * @description Total balance amount
       */
      amount: number;
      /**
       * Format: double
       * @description Amount reserved by authorization holds
       */
      lockedAmount: number;
      /**
       * Format: double
       * @description Available balance (amount - lockedAmount)
       */
      effectiveAmount: number;
    };
    /** @description Request to ban a participant from a room */
    BanParticipantRequest: {
      /**
       * Format: uuid
       * @description Room ID
       */
      roomId: string;
      /**
       * Format: uuid
       * @description Session ID of participant to ban
       */
      targetSessionId: string;
      /** @description Optional reason for the ban */
      reason?: string | null;
      /** @description Ban duration in minutes (null for permanent) */
      durationMinutes?: number | null;
    };
    /** @description Result of a single balance query in a batch */
    BatchBalanceResult: {
      /**
       * Format: uuid
       * @description Wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency definition ID
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Total balance
       */
      amount: number;
      /**
       * Format: double
       * @description Amount in holds
       */
      lockedAmount: number;
      /**
       * Format: double
       * @description Available balance
       */
      effectiveAmount: number;
    };
    /** @description A single credit operation in a batch */
    BatchCreditOperation: {
      /**
       * Format: uuid
       * @description Target wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to credit
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to credit (must be positive)
       */
      amount: number;
      /** @description Faucet transaction type */
      transactionType: components['schemas']['TransactionType'];
      /** @description Reference type */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference ID
       */
      referenceId?: string | null;
    };
    /** @description Request to credit multiple wallets */
    BatchCreditRequest: {
      /** @description Credit operations to execute */
      operations: components['schemas']['BatchCreditOperation'][];
      /** @description Unique key covering the entire batch */
      idempotencyKey: string;
    };
    /** @description Results of batch credit operations */
    BatchCreditResponse: {
      /** @description Results for each operation */
      results: components['schemas']['BatchCreditResult'][];
    };
    /** @description Result of a single credit in a batch */
    BatchCreditResult: {
      /** @description Index in the operations array */
      index: number;
      /** @description Whether the operation succeeded */
      success: boolean;
      /** @description Transaction record if successful */
      transaction?: components['schemas']['CurrencyTransactionRecord'];
      /** @description Error code if failed */
      error?: string | null;
    };
    /** @description A single debit operation in a batch */
    BatchDebitOperation: {
      /**
       * Format: uuid
       * @description Source wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to debit
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to debit (must be positive)
       */
      amount: number;
      /** @description Sink transaction type (burn, vendor_purchase, fee, etc.) */
      transactionType: components['schemas']['TransactionType'];
      /** @description What triggered this transaction */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference entity ID
       */
      referenceId?: string | null;
      /** @description Override negative balance allowance for this transaction */
      allowNegative?: boolean | null;
      /** @description Free-form transaction metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to debit multiple wallets */
    BatchDebitRequest: {
      /** @description Debit operations to execute */
      operations: components['schemas']['BatchDebitOperation'][];
      /** @description Unique key covering the entire batch */
      idempotencyKey: string;
    };
    /** @description Results of batch debit operations */
    BatchDebitResponse: {
      /** @description Results for each operation */
      results: components['schemas']['BatchDebitResult'][];
    };
    /** @description Result of a single debit in a batch */
    BatchDebitResult: {
      /** @description Index in the operations array */
      index: number;
      /** @description Whether the operation succeeded */
      success: boolean;
      /** @description Transaction record if successful */
      transaction?: components['schemas']['CurrencyTransactionRecord'];
      /** @description Error code if failed */
      error?: string | null;
    };
    /** @description Request to get multiple balances */
    BatchGetBalancesRequest: {
      /** @description Balance queries to execute */
      queries: components['schemas']['BalanceQuery'][];
    };
    /** @description Results of batch balance queries */
    BatchGetBalancesResponse: {
      /** @description Balance results (same order as queries) */
      balances: components['schemas']['BatchBalanceResult'][];
    };
    /** @description Request to get multiple item instances */
    BatchGetItemInstancesRequest: {
      /** @description Instance IDs to retrieve */
      instanceIds: string[];
    };
    /** @description Multiple item instances */
    BatchGetItemInstancesResponse: {
      /** @description Found items */
      items: components['schemas']['ItemInstanceResponse'][];
      /** @description Instance IDs that were not found */
      notFound: string[];
    };
    /** @description Request to get current game time for multiple realms */
    BatchGetRealmTimesRequest: {
      /** @description Realm IDs to get current game time for */
      realmIds: string[];
    };
    /** @description Game time snapshots for multiple realms */
    BatchGetRealmTimesResponse: {
      /** @description Game time snapshots for each requested realm (omits realms without initialized clocks) */
      snapshots: components['schemas']['GameTimeSnapshot'][];
    };
    /** @description Individual message entry in a batch send operation */
    BatchMessageEntry: {
      /** @description Message content matching the room format */
      content: components['schemas']['SendMessageContent'];
      /** @description Opaque sender type */
      senderType?: string | null;
      /**
       * Format: uuid
       * @description Sender entity ID
       */
      senderId?: string | null;
      /** @description Sender display name */
      displayName?: string | null;
    };
    /** @description Details of a single message that failed in a batch send operation */
    BatchMessageFailure: {
      /** @description Zero-based index of the failed message in the request messages array */
      index: number;
      /** @description Human-readable error reason */
      error: string;
    };
    /** @description Compiled behavior tree data with bytecode or download reference */
    BehaviorTreeData: {
      /** @description Base64-encoded compiled bytecode for the behavior tree */
      bytecode?: string | null;
      /** @description Size of the bytecode in bytes */
      bytecodeSize?: number;
      /** @description URL to download the compiled behavior asset */
      downloadUrl?: string | null;
    };
    /** @description Request to bind an unbound actor to a character. After binding, the actor subscribes to the character's perception stream and variable providers begin loading character-specific data. The actor's behavior document continues executing  it should already handle both unbound and bound modes gracefully. */
    BindActorCharacterRequest: {
      /** @description ID of the actor to bind */
      actorId: string;
      /**
       * Format: uuid
       * @description ID of the character to bind to
       */
      characterId: string;
    };
    /** @description Request to bind an item to a character */
    BindItemInstanceRequest: {
      /**
       * Format: uuid
       * @description Instance ID to bind
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Character to bind the item to
       */
      characterId: string;
      /** @description Type of binding to apply */
      bindType: components['schemas']['SoulboundType'];
    };
    /** @description Request to bind a Git repository for automatic documentation sync */
    BindRepositoryRequest: {
      /**
       * @description Owner of this binding. NOT a session ID.
       *     For user-initiated bindings: the accountId (UUID format).
       *     For service-initiated bindings: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Documentation namespace to bind */
      namespace: string;
      /** @description Git clone URL (HTTPS for public repos) */
      repositoryUrl: string;
      /**
       * @description Branch to sync from
       * @default main
       */
      branch: string;
      /**
       * @description How often to sync (5 min to 24 hours)
       * @default 60
       */
      syncIntervalMinutes: number;
      /**
       * @description Glob patterns for files to include (defaults to all markdown files if not provided)
       * @default [
       *       "**\/*.md"
       *     ]
       */
      filePatterns: string[] | null;
      /**
       * @description Glob patterns for files to exclude (defaults to common non-content directories if not provided)
       * @default [
       *       ".git/**",
       *       ".obsidian/**",
       *       "node_modules/**"
       *     ]
       */
      excludePatterns: string[] | null;
      /** @description Map directory prefixes to categories (empty mapping if not provided) */
      categoryMapping?: {
        [key: string]: string;
      } | null;
      /** @description Default category for documents without mapping */
      defaultCategory?: components['schemas']['DocumentCategory'];
      /**
       * @description Enable archive functionality
       * @default false
       */
      archiveEnabled: boolean;
      /**
       * @description Create archive after each sync
       * @default false
       */
      archiveOnSync: boolean;
    };
    /** @description Response confirming repository binding creation */
    BindRepositoryResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the repository binding
       */
      bindingId: string;
      /** @description Namespace the repository is bound to */
      namespace: string;
      /** @description URL of the bound repository */
      repositoryUrl?: string;
      /** @description Branch being synced */
      branch?: string;
      /** @description Current status of the binding */
      status: components['schemas']['BindingStatus'];
      /**
       * Format: date-time
       * @description Timestamp when the binding was created
       */
      createdAt?: string;
    };
    /**
     * @description Status of a repository binding
     * @enum {string}
     */
    BindingStatus: 'pending' | 'syncing' | 'synced' | 'error' | 'disabled';
    /** @description Full blessing record response */
    BlessingResponse: {
      /**
       * Format: uuid
       * @description Unique blessing identifier
       */
      blessingId: string;
      /**
       * Format: uuid
       * @description Deity that granted this blessing
       */
      deityId: string;
      /**
       * Format: uuid
       * @description Entity that received this blessing
       */
      entityId: string;
      /** @description Type of entity that received this blessing */
      entityType: components['schemas']['EntityType'];
      /** @description Tier of the blessing */
      tier: components['schemas']['BlessingTier'];
      /** @description Item template code for the blessing effect */
      itemTemplateCode: string;
      /**
       * Format: uuid
       * @description Item or collection entry instance backing this blessing
       */
      itemInstanceId: string;
      /** @description Why the blessing was granted */
      reason: string;
      /**
       * Format: date-time
       * @description When the blessing was granted
       */
      grantedAt: string;
      /**
       * Format: date-time
       * @description When the blessing was revoked (null if still active)
       */
      revokedAt?: string | null;
      /** @description Current status of the blessing */
      status: components['schemas']['BlessingStatus'];
    };
    /**
     * @description Current status of a granted blessing
     * @enum {string}
     */
    BlessingStatus: 'active' | 'revoked';
    /** @description Compact blessing record for list responses */
    BlessingSummary: {
      /**
       * Format: uuid
       * @description Unique identifier for this blessing
       */
      blessingId: string;
      /**
       * Format: uuid
       * @description Deity that granted this blessing
       */
      deityId: string;
      /**
       * Format: uuid
       * @description Entity that received this blessing
       */
      entityId: string;
      /** @description Type of entity that received this blessing */
      entityType: components['schemas']['EntityType'];
      /** @description Tier of the blessing */
      tier: components['schemas']['BlessingTier'];
      /**
       * Format: uuid
       * @description Item or collection entry instance backing this blessing
       */
      itemInstanceId: string;
      /**
       * Format: date-time
       * @description When the blessing was granted
       */
      grantedAt: string;
      /** @description Current status of the blessing */
      status: components['schemas']['BlessingStatus'];
    };
    /**
     * @description Tier of a blessing determining its power, cost, and storage mechanism
     * @enum {string}
     */
    BlessingTier: 'minor' | 'standard' | 'greater' | 'supreme';
    /** @description State of a single license node on a board, including unlock status */
    BoardNodeState: {
      /** @description Unique license code within this board template */
      code: string;
      /** @description Grid position of this license node */
      position: components['schemas']['GridPosition'];
      /** @description License Point cost to unlock this node */
      lpCost: number;
      /** @description Current unlock status of this node */
      status: components['schemas']['LicenseStatus'];
      /**
       * Format: uuid
       * @description Item template that is created when this license is unlocked
       */
      itemTemplateId: string;
      /**
       * Format: uuid
       * @description Item instance ID if this license has been unlocked
       */
      itemInstanceId?: string | null;
      /** @description License codes that must be unlocked before this one (non-adjacent) */
      prerequisites?: string[] | null;
      /** @description Human-readable description of what this license grants */
      description?: string | null;
      /** @description Game-specific metadata for this license node. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Board instance with all fields */
    BoardResponse: {
      /**
       * Format: uuid
       * @description Unique board instance identifier
       */
      boardId: string;
      /** @description Type of entity that owns this board */
      ownerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Entity that owns this board
       */
      ownerId: string;
      /**
       * Format: uuid
       * @description Realm context for this board. Null for realm-agnostic boards.
       */
      realmId?: string | null;
      /**
       * Format: uuid
       * @description Board template this instance was created from
       */
      boardTemplateId: string;
      /**
       * Format: uuid
       * @description Game service this board belongs to
       */
      gameServiceId: string;
      /**
       * Format: uuid
       * @description Inventory container holding unlocked license items
       */
      containerId: string;
      /**
       * Format: date-time
       * @description When this board instance was created
       */
      createdAt: string;
    };
    /** @description Request to get the full board state */
    BoardStateRequest: {
      /**
       * Format: uuid
       * @description Board instance to get state for
       */
      boardId: string;
    };
    /** @description Full board state with all node statuses for client UI rendering */
    BoardStateResponse: {
      /**
       * Format: uuid
       * @description Board instance identifier
       */
      boardId: string;
      /** @description Type of entity that owns this board (e.g., character, account, guild) */
      ownerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the entity that owns this board
       */
      ownerId: string;
      /**
       * Format: uuid
       * @description Board template this instance was created from
       */
      boardTemplateId: string;
      /** @description Width of the board grid (columns) */
      gridWidth: number;
      /** @description Height of the board grid (rows) */
      gridHeight: number;
      /** @description All license nodes with their current status */
      nodes: components['schemas']['BoardNodeState'][];
    };
    /** @description Board template with all fields */
    BoardTemplateResponse: {
      /**
       * Format: uuid
       * @description Unique board template identifier
       */
      boardTemplateId: string;
      /**
       * Format: uuid
       * @description Game service this template belongs to
       */
      gameServiceId: string;
      /** @description Display name */
      name: string;
      /** @description Human-readable description */
      description?: string | null;
      /** @description Width of the board grid (columns) */
      gridWidth: number;
      /** @description Height of the board grid (rows) */
      gridHeight: number;
      /** @description Grid positions where unlocking can begin without adjacency */
      startingNodes: components['schemas']['GridPosition'][];
      /**
       * Format: uuid
       * @description Contract template that controls unlock behavior
       */
      boardContractTemplateId: string;
      /** @description Grid traversal mode for this template */
      adjacencyMode: components['schemas']['AdjacencyMode'];
      /** @description Owner types allowed to create boards from this template */
      allowedOwnerTypes: components['schemas']['EntityType'][];
      /** @description Whether the template is active (can create new board instances) */
      isActive: boolean;
      /**
       * Format: date-time
       * @description When the template was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the template was last updated
       */
      updatedAt?: string | null;
    };
    /** @description A participant in a seed bond. */
    BondParticipant: {
      /**
       * Format: uuid
       * @description Participant seed ID.
       */
      seedId: string;
      /**
       * Format: date-time
       * @description When this seed joined the bond.
       */
      joinedAt: string;
      /** @description Optional role within the bond. */
      role?: string | null;
    };
    /** @description Partner seed summaries for a bond. */
    BondPartnersResponse: {
      /**
       * Format: uuid
       * @description The bond.
       */
      bondId: string;
      /** @description Partner seed summaries. */
      partners: components['schemas']['PartnerSummary'][];
    };
    /** @description Full bond record response. */
    BondResponse: {
      /**
       * Format: uuid
       * @description Unique bond identifier.
       */
      bondId: string;
      /** @description Seed type this bond connects. */
      seedTypeCode: string;
      /** @description Seeds participating in this bond. */
      participants: components['schemas']['BondParticipant'][];
      /**
       * Format: date-time
       * @description When the bond was formed.
       */
      createdAt: string;
      /** @description Current bond lifecycle status. */
      status: components['schemas']['BondStatus'];
      /**
       * Format: float
       * @description Grows with shared growth. Consumer-interpreted.
       */
      bondStrength: number;
      /**
       * Format: float
       * @description Total accumulated shared growth.
       */
      sharedGrowth: number;
    };
    /**
     * @description Lifecycle status of a seed bond.
     * @enum {string}
     */
    BondStatus: 'PendingConfirmation' | 'Active';
    /** @description Per-player garden state within a shared bond garden */
    BondedPlayerGardenState: {
      /**
       * Format: uuid
       * @description Seed ID of the bonded player
       */
      seedId: string;
      /**
       * Format: uuid
       * @description Account ID of the bonded player
       */
      accountId: string;
      /** @description Player position in shared garden space */
      position: components['schemas']['Vec3'];
    };
    /** @description Axis-aligned bounding box in world coordinates (meters, Y-up, right-handed) */
    BoundingBox3D: {
      /**
       * Format: float
       * @description Minimum X bound in world space
       */
      minX: number;
      /**
       * Format: float
       * @description Minimum Y bound in world space
       */
      minY: number;
      /**
       * Format: float
       * @description Minimum Z bound in world space
       */
      minZ: number;
      /**
       * Format: float
       * @description Maximum X bound in world space
       */
      maxX: number;
      /**
       * Format: float
       * @description Maximum Y bound in world space
       */
      maxY: number;
      /**
       * Format: float
       * @description Maximum Z bound in world space
       */
      maxZ: number;
    };
    /** @description An axis-aligned bounding box in 3D space */
    Bounds: {
      /** @description Minimum corner (lowest x, y, z values) */
      min: components['schemas']['Position3D'];
      /** @description Maximum corner (highest x, y, z values) */
      max: components['schemas']['Position3D'];
    };
    /**
     * @description Precision level of spatial bounds for a location
     * @enum {string}
     */
    BoundsPrecision: 'exact' | 'approximate' | 'none';
    /** @description Breach record details */
    BreachResponse: {
      /**
       * Format: uuid
       * @description Unique breach identifier
       */
      breachId: string;
      /**
       * Format: uuid
       * @description Contract that was breached
       */
      contractId: string;
      /**
       * Format: uuid
       * @description Entity that breached (null for system-initiated breaches such as deadline enforcement)
       */
      breachingEntityId?: string | null;
      /** @description Type of breaching entity (null for system-initiated breaches) */
      breachingEntityType?: components['schemas']['EntityType'] | null;
      /** @description Type of breach */
      breachType: components['schemas']['BreachType'];
      /** @description What was breached */
      breachedTermOrMilestone?: string | null;
      /** @description Breach description */
      description?: string | null;
      /** @description Current status */
      status: components['schemas']['BreachStatus'];
      /**
       * Format: date-time
       * @description When breach was detected
       */
      detectedAt: string;
      /**
       * Format: date-time
       * @description Deadline to cure breach
       */
      cureDeadline?: string | null;
      /**
       * Format: date-time
       * @description When breach was cured
       */
      curedAt?: string | null;
      /**
       * Format: date-time
       * @description When consequences were applied
       */
      consequencesAppliedAt?: string | null;
    };
    /**
     * @description Current status of a breach record
     * @enum {string}
     */
    BreachStatus:
      | 'detected'
      | 'cure_period'
      | 'cured'
      | 'consequences_applied'
      | 'disputed'
      | 'forgiven';
    /** @description Brief breach information */
    BreachSummary: {
      /**
       * Format: uuid
       * @description Breach ID
       */
      breachId: string;
      /** @description Type of breach */
      breachType: components['schemas']['BreachType'];
      /** @description Current status */
      status: components['schemas']['BreachStatus'];
    };
    /**
     * @description Type of contract breach
     * @enum {string}
     */
    BreachType:
      | 'term_violation'
      | 'milestone_missed'
      | 'milestone_deadline'
      | 'unauthorized_action'
      | 'non_payment';
    /** @description Request to initiate broadcast consent for a voice room */
    BroadcastConsentRequest: {
      /**
       * Format: uuid
       * @description Voice room to broadcast
       */
      roomId: string;
      /**
       * Format: uuid
       * @description Session ID of the participant requesting broadcast (server can derive from auth context)
       */
      requestingSessionId?: string | null;
    };
    /** @description Response to a broadcast consent request from a participant */
    BroadcastConsentResponse: {
      /**
       * Format: uuid
       * @description Voice room ID
       */
      roomId: string;
      /**
       * Format: uuid
       * @description Session ID of the responding participant
       */
      sessionId: string;
      /** @description True if participant consents to broadcasting */
      consented: boolean;
    };
    /**
     * @description Current state of broadcast consent for a room. Inactive: No broadcast request pending. Pending: Consent request sent, awaiting all responses. Approved: All participants consented. Voice treats this as terminal.
     * @enum {string}
     */
    BroadcastConsentState: 'Inactive' | 'Pending' | 'Approved';
    /** @description Current broadcast consent status for a voice room */
    BroadcastConsentStatus: {
      /**
       * Format: uuid
       * @description Voice room ID
       */
      roomId?: string;
      /** @description Current broadcast consent state */
      state?: components['schemas']['BroadcastConsentState'];
      /**
       * Format: uuid
       * @description Who initiated the broadcast request (null if inactive)
       */
      requestedBySessionId?: string | null;
      /** @description Sessions that have consented so far */
      consentedSessionIds?: string[];
      /** @description Sessions that haven't responded yet */
      pendingSessionIds?: string[];
      /** @description RTP audio endpoint for the room's mixed audio output. Only populated when room is in scaled tier. Provided to lib-stream so it can connect its RTMP output to the voice room's audio. */
      rtpAudioEndpoint?: string | null;
    };
    /** @description Request to get broadcast consent status for a voice room */
    BroadcastStatusRequest: {
      /**
       * Format: uuid
       * @description Voice room ID
       */
      roomId: string;
    };
    /** @description Request to retrieve metadata for multiple assets */
    BulkGetAssetsRequest: {
      /** @description Asset IDs to retrieve (max 100) */
      assetIds: string[];
      /**
       * @description Whether to generate pre-signed download URLs
       * @default false
       */
      includeDownloadUrls: boolean;
    };
    /** @description Batch asset metadata response */
    BulkGetAssetsResponse: {
      /** @description Found assets with metadata */
      assets: components['schemas']['AssetWithDownloadUrl'][];
      /** @description Asset IDs that weren't found */
      notFound: string[];
    };
    /**
     * @description Bundle file format
     * @enum {string}
     */
    BundleFormat: 'bannou' | 'zip';
    /** @description Complete metadata for an asset bundle (API response model) */
    BundleInfo: {
      /** @description Human-readable bundle identifier (e.g., "synty/polygon-adventure", "my-bundle-v1") */
      bundleId: string;
      /** @description Whether source or metabundle */
      bundleType: components['schemas']['BundleType'];
      /** @description Bundle content version string */
      version: string;
      /** @description Metadata version number (increments on metadata changes) */
      metadataVersion: number;
      /** @description Human-readable bundle name */
      name?: string | null;
      /** @description Bundle description */
      description?: string | null;
      /** @description Owner account ID or service name (null for system-owned bundles) */
      owner?: string | null;
      /** @description Game realm this bundle belongs to */
      realm: components['schemas']['GameRealm'];
      /** @description Key-value tags for categorization and filtering */
      tags?: {
        [key: string]: string;
      } | null;
      /** @description Bundle lifecycle status */
      status: components['schemas']['BundleLifecycle'];
      /** @description Number of assets in the bundle */
      assetCount: number;
      /**
       * Format: int64
       * @description Bundle file size in bytes (null if not yet calculated)
       */
      sizeBytes?: number | null;
      /**
       * Format: date-time
       * @description When the bundle was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the bundle metadata was last updated
       */
      updatedAt?: string | null;
      /**
       * Format: date-time
       * @description When the bundle was soft-deleted (null if active)
       */
      deletedAt?: string | null;
    };
    /**
     * @description Bundle lifecycle status:
     *     - active: Bundle is available for use
     *     - deleted: Bundle has been soft-deleted (within retention period)
     *     - processing: Bundle is being processed (metabundle creation)
     * @enum {string}
     */
    BundleLifecycle: 'active' | 'deleted' | 'processing';
    /** @description Preview of bundle manifest for validation */
    BundleManifestPreview: {
      /** @description Human-readable bundle identifier from the manifest */
      bundleId: string;
      /** @description Bundle version from the manifest */
      version: string;
      /** @description Number of assets declared in the manifest */
      assetCount: number;
    };
    /** @description Summary information about a bundle */
    BundleSummary: {
      /** @description Human-readable bundle identifier */
      bundleId: string;
      /** @description Source or metabundle */
      bundleType: components['schemas']['BundleType'];
      /** @description Bundle version */
      version: string;
      /** @description Number of assets in bundle */
      assetCount: number;
      /**
       * Format: int64
       * @description Bundle file size
       */
      sizeBytes?: number | null;
      /** @description Game realm */
      realm: components['schemas']['GameRealm'];
      /**
       * Format: date-time
       * @description When the bundle was created
       */
      createdAt?: string | null;
    };
    /**
     * @description Bundle category:
     *     - source: Original bundle (uploaded or server-created from assets)
     *     - metabundle: Composed from other bundles server-side
     * @enum {string}
     */
    BundleType: 'source' | 'metabundle';
    /** @description Request to upload a pre-built asset bundle file */
    BundleUploadRequest: {
      /**
       * @description Owner of this bundle upload. NOT a session ID.
       *     For user-initiated uploads: the accountId (UUID format).
       *     For service-initiated uploads: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Must end with .bannou or .zip */
      filename: string;
      /**
       * Format: int64
       * @description Bundle file size in bytes
       */
      size: number;
      /** @description Optional preview of bundle manifest for validation */
      manifestPreview?: components['schemas']['BundleManifestPreview'] | null;
    };
    /** @description A single version record in bundle history */
    BundleVersionRecord: {
      /** @description Version number */
      version: number;
      /**
       * Format: date-time
       * @description When this version was created
       */
      createdAt: string;
      /** @description Account ID that made the change */
      createdBy: string;
      /** @description List of changes in this version */
      changes: string[];
      /** @description Reason provided for the change */
      reason?: string | null;
      /** @description Full metadata snapshot at this version (only for current version) */
      snapshot?: components['schemas']['BundleInfo'] | null;
    };
    /** @description Bundle metadata combined with a pre-signed download URL */
    BundleWithDownloadUrl: {
      /** @description Human-readable bundle identifier (e.g., "synty/polygon-adventure", "my-bundle-v1") */
      bundleId: string;
      /** @description Bundle version string */
      version: string;
      /**
       * Format: uri
       * @description Pre-signed URL for downloading the bundle
       */
      downloadUrl: string;
      /** @description Format of the downloadable bundle */
      format: components['schemas']['BundleFormat'];
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Bundle file size in bytes
       */
      size: number;
      /** @description Number of assets contained in the bundle */
      assetCount: number;
      /** @description True if ZIP format was served from conversion cache */
      fromCache: boolean;
    };
    /** @description Response containing a previously compiled behavior retrieved from cache */
    CachedBehaviorResponse: {
      /** @description Unique identifier for the cached behavior */
      behaviorId: string;
      /** @description The compiled behavior data retrieved from cache */
      compiledBehavior: components['schemas']['CompiledBehavior'];
      /**
       * Format: date-time
       * @description When the behavior was cached
       */
      cacheTimestamp?: string | null;
      /** @description Whether this was a cache hit or miss */
      cacheHit?: boolean;
    };
    /** @description Information about a cadence */
    CadenceInfo: {
      /**
       * @description Cadence type
       * @enum {string}
       */
      type: 'authentic' | 'half' | 'plagal' | 'deceptive';
      /** @description Chord index where cadence ends */
      position: number;
      /**
       * @description Cadence strength
       * @enum {string|null}
       */
      strength?: 'perfect' | 'imperfect' | null;
    };
    /** @description Request to preview a currency conversion */
    CalculateConversionRequest: {
      /**
       * Format: uuid
       * @description Source currency definition ID
       */
      fromCurrencyId: string;
      /**
       * Format: uuid
       * @description Target currency definition ID
       */
      toCurrencyId: string;
      /**
       * Format: double
       * @description Amount to convert (must be positive)
       */
      fromAmount: number;
    };
    /** @description Conversion preview result */
    CalculateConversionResponse: {
      /**
       * Format: double
       * @description Amount that would be received
       */
      toAmount: number;
      /**
       * Format: double
       * @description Effective conversion rate applied
       */
      effectiveRate: number;
      /** @description Steps in the conversion */
      conversionPath: components['schemas']['ConversionStep'][];
      /** @description Base currency used for conversion */
      baseCurrency: string;
    };
    /** @description A calendar template definition with computed summary fields */
    CalendarTemplateResponse: {
      /** @description Calendar template identifier */
      templateCode: string;
      /**
       * Format: uuid
       * @description Game service this calendar belongs to
       */
      gameServiceId: string;
      /** @description Number of game hours in a day */
      gameHoursPerDay: number;
      /** @description Named time-of-day periods */
      dayPeriods: components['schemas']['DayPeriodDefinition'][];
      /** @description Ordered list of months in a year */
      months: components['schemas']['MonthDefinition'][];
      /** @description Ordered list of seasons in a year */
      seasons: components['schemas']['SeasonDefinition'][];
      /** @description Computed total days per year (sum of all months' daysInMonth) */
      daysPerYear: number;
      /** @description Computed number of months per year */
      monthsPerYear: number;
      /** @description Computed number of seasons per year */
      seasonsPerYear: number;
      /** @description Named time spans for display purposes (null if none defined) */
      eraLabels?: components['schemas']['EraLabel'][] | null;
    };
    /**
     * @description Controls CanUse validation behavior.
     *     - disabled: Skip CanUse validation even if template is configured
     *     - block: CanUse failure prevents use (default)
     *     - warn_and_proceed: CanUse failure logs warning but proceeds with use
     * @enum {string}
     */
    CanUseBehavior: 'disabled' | 'block' | 'warn_and_proceed';
    /** @description Request to cancel an async metabundle creation job */
    CancelJobRequest: {
      /**
       * Format: uuid
       * @description Job ID from the createMetabundle response
       */
      jobId: string;
    };
    /** @description Result of job cancellation attempt */
    CancelJobResponse: {
      /**
       * Format: uuid
       * @description Job identifier
       */
      jobId: string;
      /** @description Whether the job was successfully cancelled */
      cancelled: boolean;
      /**
       * @description Current job status after cancellation attempt
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed' | 'cancelled';
      /** @description Additional context about the cancellation result */
      message?: string | null;
    };
    /** @description Request to cancel escrow before fully funded */
    CancelRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /** @description Reason for cancellation */
      reason?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from cancelling an escrow */
    CancelResponse: {
      /** @description Cancelled escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Refund results for any deposits */
      refunds: components['schemas']['RefundResult'][];
    };
    /** @description Request to cancel a subscription */
    CancelSubscriptionRequest: {
      /**
       * Format: uuid
       * @description ID of the subscription to cancel
       */
      subscriptionId: string;
      /** @description Optional reason for cancellation */
      reason?: string | null;
    };
    /**
     * @description What happens when a credit would exceed the wallet cap
     * @enum {string}
     */
    CapOverflowBehavior: 'reject' | 'cap_and_lose' | 'cap_and_return';
    /** @description A single capability entry in the manifest. */
    Capability: {
      /** @description Unique capability identifier. Consumer-interpreted (e.g., UX module ID, spawning permission, faction action). */
      capabilityCode: string;
      /** @description Growth domain this capability maps to. */
      domain: string;
      /**
       * Format: float
       * @description Capability fidelity from 0.0 to 1.0. Higher values mean the seed has more developed capability in this area.
       */
      fidelity: number;
      /** @description Whether this capability is available at all. */
      unlocked: boolean;
    };
    /** @description Computed capability manifest for a seed. */
    CapabilityManifestResponse: {
      /**
       * Format: uuid
       * @description The seed this manifest belongs to.
       */
      seedId: string;
      /** @description The seed type for consumer interpretation. */
      seedTypeCode: string;
      /**
       * Format: date-time
       * @description When this manifest was last computed.
       */
      computedAt: string;
      /** @description Monotonically increasing version number. */
      version: number;
      /** @description List of capabilities with availability and fidelity. */
      capabilities: components['schemas']['Capability'][];
    };
    /** @description Maps a growth domain to a capability with unlock threshold and fidelity formula. */
    CapabilityRule: {
      /** @description Unique capability identifier (e.g., "combat.stance"). */
      capabilityCode: string;
      /** @description Which growth domain this capability maps to. */
      domain: string;
      /**
       * Format: float
       * @description Minimum domain depth to unlock this capability.
       */
      unlockThreshold: number;
      /** @description How domain depth maps to fidelity (0.0-1.0). Values: "linear", "logarithmic", "step". Consumers may define additional formulas. */
      fidelityFormula: string;
    };
    /** @description Request to capture (finalize) a hold */
    CaptureHoldRequest: {
      /**
       * Format: uuid
       * @description Hold ID to capture
       */
      holdId: string;
      /**
       * Format: double
       * @description Final amount to debit (may be less than hold amount)
       */
      captureAmount: number;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Result of hold capture */
    CaptureHoldResponse: {
      /** @description Updated hold record */
      hold: components['schemas']['HoldRecord'];
      /** @description Debit transaction */
      transaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Balance after capture
       */
      newBalance: number;
      /**
       * Format: double
       * @description Difference between hold and capture (released back)
       */
      amountReleased: number;
    };
    /** @description Completion statistics for a single category */
    CategoryStats: {
      /** @description Total entries in this category */
      total: number;
      /** @description Unlocked entries in this category */
      unlocked: number;
      /**
       * Format: double
       * @description Completion percentage for this category
       */
      percentage: number;
    };
    /** @description Request to chain from one scenario to another */
    ChainScenarioRequest: {
      /**
       * Format: uuid
       * @description Account chaining scenarios
       */
      accountId: string;
      /**
       * Format: uuid
       * @description Currently active scenario instance
       */
      currentScenarioInstanceId: string;
      /**
       * Format: uuid
       * @description Template to chain into
       */
      targetTemplateId: string;
    };
    /**
     * @description Compressed archive of a dead character.
     *     Contains text summaries instead of structured data for long-term storage.
     *     Self-contained with no external references (suitable for cleanup).
     */
    CharacterArchive: {
      /**
       * Format: uuid
       * @description Original character ID
       */
      characterId: string;
      /** @description Character display name */
      name: string;
      /**
       * Format: uuid
       * @description Realm the character belonged to
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Character's species
       */
      speciesId: string;
      /**
       * Format: date-time
       * @description In-game birth date
       */
      birthDate: string;
      /**
       * Format: date-time
       * @description In-game death date
       */
      deathDate: string;
      /**
       * Format: date-time
       * @description When this archive was created
       */
      compressedAt: string;
      /**
       * @description Text summary of personality traits.
       *     Example: "Brave and loyal, somewhat hot-tempered with a strong sense of justice"
       */
      personalitySummary?: string | null;
      /**
       * @description Key backstory elements as text. Null when compression did not include backstory data.
       *     Example: ["Trained by the Knights Guild", "Born in the Northlands"]
       */
      keyBackstoryPoints?: string[] | null;
      /**
       * @description Significant life events as text. Null when compression did not include history data.
       *     Example: ["Fought in the Battle of Stormgate (Hero)", "Survived the Great Flood"]
       */
      majorLifeEvents?: string[] | null;
      /**
       * @description Text summary of family relationships.
       *     Example: "Father of 3, married to Elena, orphaned at young age"
       */
      familySummary?: string | null;
    };
    /**
     * @description Core character data for archive storage and storyline SDK consumption.
     *     Inherits base archive properties from ResourceArchiveBase.
     *     The characterId field equals resourceId for convenience.
     *
     *     Note: This is distinct from CharacterArchive which contains text summaries
     *     for cleanup. CharacterBaseArchive contains structured data for SDK consumption.
     */
    CharacterBaseArchive: {
      /**
       * Format: uuid
       * @description Unique identifier for the character (equals resourceId)
       */
      characterId: string;
      /** @description Display name of the character */
      name: string;
      /**
       * Format: uuid
       * @description Realm ID (partition key)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Species ID (foreign key to Species service)
       */
      speciesId: string;
      /**
       * Format: date-time
       * @description In-game birth timestamp
       */
      birthDate: string;
      /**
       * Format: date-time
       * @description In-game death timestamp (required for compression)
       */
      deathDate: string;
      /** @description Current lifecycle status (must be dead for compression) */
      status: components['schemas']['CharacterStatus'];
      /**
       * @description Text summary of family relationships.
       *     Example: "Father of 3, married to Elena, orphaned at young age"
       */
      familySummary?: string | null;
      /**
       * Format: date-time
       * @description Real-world creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Real-world last update timestamp
       */
      updatedAt?: string | null;
    } & components['schemas']['ResourceArchiveBase'];
    /** @description Context information about a character for behavior resolution */
    CharacterContext: {
      /**
       * @description Unique identifier for the NPC
       * @example npc_12345
       */
      npcId?: string | null;
      /**
       * @description Cultural background identifier
       * @example european_medieval
       */
      culture?: string | null;
      /**
       * @description Character profession identifier
       * @example blacksmith
       */
      profession?: string | null;
      /**
       * @description Character statistics and attributes
       * @example {
       *       "energy": 0.8,
       *       "health": 1,
       *       "hunger": 0.3
       *     }
       */
      stats?: {
        [key: string]: number;
      } | null;
      /**
       * @description Character skill levels
       * @example {
       *       "blacksmithing": 85,
       *       "trading": 42
       *     }
       */
      skills?: {
        [key: string]: number;
      } | null;
      /** @description Current location information for the character */
      location?: components['schemas']['Location'];
      /** @description Relationship values with other characters */
      relationships?: {
        [key: string]: number;
      } | null;
      /** @description Relevant world state information */
      worldState?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Complete encounter data for archive storage and storyline SDK consumption.
     *     Inherits base archive properties from ResourceArchiveBase.
     *     The characterId field equals resourceId for convenience.
     */
    CharacterEncounterArchive: {
      /**
       * Format: uuid
       * @description Character this data belongs to (equals resourceId)
       */
      characterId: string;
      /** @description Whether encounters exist for this character */
      hasEncounters: boolean;
      /** @description Number of encounters archived */
      encounterCount: number;
      /** @description Encounters with perspectives (empty if hasEncounters=false) */
      encounters?: components['schemas']['EncounterResponse'][];
      /**
       * @description Map of target characterId to aggregate sentiment.
       *     Preserves sentiment relationships for historical reference.
       */
      aggregateSentiment?: {
        [key: string]: number;
      } | null;
    } & components['schemas']['ResourceArchiveBase'];
    /**
     * @description Complete history data for archive storage and storyline SDK consumption.
     *     Inherits base archive properties from ResourceArchiveBase.
     *     The characterId field equals resourceId for convenience.
     */
    CharacterHistoryArchive: {
      /**
       * Format: uuid
       * @description Character this data belongs to (equals resourceId)
       */
      characterId: string;
      /** @description Whether historical participations exist */
      hasParticipations: boolean;
      /** @description Historical event participations (empty if hasParticipations=false) */
      participations?: components['schemas']['HistoricalParticipation'][];
      /** @description Whether backstory elements exist */
      hasBackstory: boolean;
      /** @description Backstory data (null if hasBackstory=false) */
      backstory?: components['schemas']['BackstoryResponse'];
      /** @description Text summaries for reference */
      summaries?: components['schemas']['HistorySummaryResponse'];
    } & components['schemas']['ResourceArchiveBase'];
    /** @description Paginated list of characters with metadata for navigation */
    CharacterListResponse: {
      /** @description List of characters matching the query */
      characters: components['schemas']['CharacterResponse'][];
      /** @description Total number of characters matching the filter criteria */
      totalCount: number;
      /** @description Current page number (1-based) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more results after this page */
      hasNextPage: boolean;
      /** @description Whether there are results before this page */
      hasPreviousPage: boolean;
    };
    /** @description A character's membership in a faction with faction details */
    CharacterMembershipEntry: {
      /**
       * Format: uuid
       * @description Faction the character belongs to
       */
      factionId: string;
      /** @description Display name of the faction */
      factionName: string;
      /** @description Unique code of the faction */
      factionCode: string;
      /** @description Character's role in this faction */
      role: components['schemas']['FactionMemberRole'];
      /**
       * Format: date-time
       * @description When the character joined this faction
       */
      joinedAt: string;
    };
    /**
     * @description Complete personality data for archive storage and storyline SDK consumption.
     *     Inherits base archive properties from ResourceArchiveBase.
     *     The characterId field equals resourceId for convenience.
     */
    CharacterPersonalityArchive: {
      /**
       * Format: uuid
       * @description Character this data belongs to (equals resourceId)
       */
      characterId: string;
      /** @description Whether personality traits exist */
      hasPersonality: boolean;
      /** @description Personality traits (null if hasPersonality=false) */
      personality?: components['schemas']['PersonalityResponse'];
      /** @description Whether combat preferences exist */
      hasCombatPreferences: boolean;
      /** @description Combat preferences (null if hasCombatPreferences=false) */
      combatPreferences?: components['schemas']['CombatPreferencesResponse'];
    } & components['schemas']['ResourceArchiveBase'];
    /** @description Complete character data returned from character operations */
    CharacterResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the character
       */
      characterId: string;
      /** @description Display name of the character */
      name: string;
      /**
       * Format: uuid
       * @description Realm ID (partition key)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Species ID (foreign key to Species service)
       */
      speciesId: string;
      /**
       * Format: date-time
       * @description In-game birth timestamp
       */
      birthDate: string;
      /**
       * Format: date-time
       * @description In-game death timestamp
       */
      deathDate?: string | null;
      /** @description Current lifecycle status of the character */
      status: components['schemas']['CharacterStatus'];
      /**
       * Format: date-time
       * @description Real-world creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Real-world last update timestamp
       */
      updatedAt?: string | null;
    };
    /** @description Snapshot of character state for condition evaluation */
    CharacterStateSnapshot: {
      /** @description Character age in years */
      age?: number | null;
      /** @description Current personality traits */
      traits?: components['schemas']['TraitSnapshot'][] | null;
      /** @description Current backstory elements */
      backstoryElements?: components['schemas']['BackstorySnapshot'][] | null;
      /** @description Current relationships */
      relationships?: components['schemas']['RelationshipSnapshot'][] | null;
    };
    /**
     * @description Character lifecycle status
     * @enum {string}
     */
    CharacterStatus: 'alive' | 'dead' | 'dormant';
    /** @description Request to send a chat message to players in a game session */
    ChatMessageRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the sender. Provided by shortcut system.
       */
      sessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the sender. Provided by shortcut system.
       */
      accountId: string;
      /** @description Game type for the chat. Determines which lobby's players receive the message. Provided by shortcut system. */
      gameType: components['schemas']['GameType'];
      /** @description Content of the chat message */
      message: string;
      /**
       * @description Type of message (public to all, whisper to one player, or system announcement)
       * @default public
       */
      messageType: components['schemas']['ChatMessageType'];
      /**
       * Format: uuid
       * @description For whisper messages
       */
      targetPlayerId?: string | null;
    };
    /** @description A chat message with metadata and content */
    ChatMessageResponse: {
      /**
       * Format: uuid
       * @description Unique message identifier
       */
      messageId: string;
      /**
       * Format: uuid
       * @description Room the message belongs to
       */
      roomId: string;
      /** @description Opaque sender type */
      senderType?: string | null;
      /**
       * Format: uuid
       * @description Sender entity ID
       */
      senderId?: string | null;
      /** @description Sender display name */
      displayName?: string | null;
      /**
       * Format: date-time
       * @description When the message was sent
       */
      timestamp: string;
      /** @description Room type code for this message */
      roomTypeCode: string;
      /** @description Message content (null for deleted messages) */
      content?: components['schemas']['SendMessageContent'] | null;
      /** @description Whether the message is pinned */
      isPinned: boolean;
    };
    /**
     * @description Type of chat message
     * @enum {string}
     */
    ChatMessageType: 'public' | 'whisper' | 'system';
    /**
     * @description Participant role within a chat room determining moderation privileges
     * @enum {string}
     */
    ChatParticipantRole: 'Owner' | 'Moderator' | 'Member' | 'ReadOnly';
    /** @description Chat room details including status and participant count */
    ChatRoomResponse: {
      /**
       * Format: uuid
       * @description Unique room identifier
       */
      roomId: string;
      /** @description Room type code */
      roomTypeCode: string;
      /**
       * Format: uuid
       * @description Connect session ID if companion room
       */
      sessionId?: string | null;
      /**
       * Format: uuid
       * @description Governing contract ID
       */
      contractId?: string | null;
      /** @description Human-readable room name */
      displayName?: string | null;
      /** @description Current room status */
      status: components['schemas']['ChatRoomStatus'];
      /** @description Current number of participants */
      participantCount: number;
      /** @description Maximum participant limit */
      maxParticipants?: number | null;
      /** @description Whether the room has been archived */
      isArchived: boolean;
      /**
       * Format: date-time
       * @description When the room was created
       */
      createdAt: string;
      /** @description Client-only metadata stored as JSON string. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: string | null;
    };
    /**
     * @description Current state of a chat room
     * @enum {string}
     */
    ChatRoomStatus: 'Active' | 'Locked' | 'Archived';
    /** @description Request to check asset requirement clauses */
    CheckAssetRequirementsRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractInstanceId: string;
    };
    /** @description Response from checking asset requirements */
    CheckAssetRequirementsResponse: {
      /** @description Whether all requirements across all parties are satisfied */
      allSatisfied: boolean;
      /** @description Status broken down by party */
      byParty: components['schemas']['PartyAssetRequirementStatus'][];
    };
    /** @description Request to check constraint */
    CheckConstraintRequest: {
      /**
       * Format: uuid
       * @description Entity to check
       */
      entityId: string;
      /** @description Entity type */
      entityType: components['schemas']['EntityType'];
      /** @description Type of constraint to check */
      constraintType: components['schemas']['ConstraintType'];
      /** @description Client-only proposed action data. No Bannou plugin reads specific keys from this field by convention. */
      proposedAction?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Constraint check result */
    CheckConstraintResponse: {
      /** @description Whether action is allowed */
      allowed: boolean;
      /** @description Contracts that would be violated */
      conflictingContracts?: components['schemas']['ContractSummary'][] | null;
      /** @description Explanation if not allowed */
      reason?: string | null;
    };
    /** @description Request to check faction membership */
    CheckMembershipRequest: {
      /**
       * Format: uuid
       * @description Faction to check membership in
       */
      factionId: string;
      /**
       * Format: uuid
       * @description Character to check
       */
      characterId: string;
    };
    /** @description Result of a membership check */
    CheckMembershipResponse: {
      /**
       * Format: uuid
       * @description Faction that was checked
       */
      factionId: string;
      /**
       * Format: uuid
       * @description Character that was checked
       */
      characterId: string;
      /** @description Whether the character is a member */
      isMember: boolean;
      /** @description Member's role (null if not a member) */
      role?: components['schemas']['FactionMemberRole'];
    };
    /** @description Request to check reference count for a character */
    CheckReferencesRequest: {
      /**
       * Format: uuid
       * @description ID of the character to check references for
       */
      characterId: string;
    };
    /** @description Response containing reference status for a resource */
    CheckReferencesResponse: {
      /** @description Type of resource checked */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource checked
       */
      resourceId: string;
      /** @description Current reference count */
      refCount: number;
      /** @description List of entities referencing this resource (optional, for diagnostics) */
      sources?: components['schemas']['ResourceReference'][] | null;
      /** @description True if refCount=0 and grace period has passed */
      isCleanupEligible: boolean;
      /**
       * Format: date-time
       * @description When grace period ends (null if refCount > 0 or already passed)
       */
      gracePeriodEndsAt?: string | null;
      /**
       * Format: date-time
       * @description When refCount last became zero
       */
      lastZeroTimestamp?: string | null;
    };
    /** @description Request to check if a license can be unlocked */
    CheckUnlockableRequest: {
      /**
       * Format: uuid
       * @description Board instance to check on
       */
      boardId: string;
      /** @description License code to check */
      licenseCode: string;
    };
    /** @description Result of unlockability check */
    CheckUnlockableResponse: {
      /** @description Whether the license can be unlocked (all conditions met) */
      unlockable: boolean;
      /** @description Whether adjacency requirement is satisfied */
      adjacencyMet: boolean;
      /** @description Whether all non-adjacent prerequisites are unlocked */
      prerequisitesMet: boolean;
      /** @description Whether the owner has enough LP. Null if LP check is not applicable for this owner type. */
      lpSufficient?: boolean | null;
      /** @description Current LP balance of the owner (null if balance check failed or not applicable) */
      currentLp?: number | null;
      /** @description LP cost for this license */
      requiredLp: number;
    };
    /** @description Request to checkout a scene for editing */
    CheckoutRequest: {
      /**
       * Format: uuid
       * @description Scene to checkout
       */
      sceneId: string;
      /** @description Optional editor identifier (defaults to caller identity) */
      editorId?: string | null;
      /** @description Custom lock TTL (uses default if not specified) */
      ttlMinutes?: number | null;
    };
    /** @description Response containing checkout token and scene */
    CheckoutResponse: {
      /** @description Token required for commit/discard/heartbeat */
      checkoutToken: string;
      /** @description Current scene document */
      scene: components['schemas']['Scene'];
      /**
       * Format: date-time
       * @description When the checkout lock expires
       */
      expiresAt: string;
    };
    /** @description A chord with timing information */
    ChordEvent: {
      /** @description Chord symbol */
      chord: components['schemas']['ChordSymbol'];
      /** @description Start position in ticks */
      startTick: number;
      /** @description Duration in ticks */
      durationTicks: number;
      /** @description Roman numeral analysis (e.g., "IV", "V7") */
      romanNumeral?: string | null;
    };
    /** @description A chord symbol with root and quality */
    ChordSymbol: {
      /** @description Chord root */
      root: components['schemas']['PitchClass'];
      /**
       * @description Chord quality
       * @enum {string}
       */
      quality:
        | 'major'
        | 'minor'
        | 'diminished'
        | 'augmented'
        | 'dominant7'
        | 'major7'
        | 'minor7'
        | 'diminished7'
        | 'halfDiminished7'
        | 'augmented7'
        | 'sus2'
        | 'sus4';
      /** @description Bass note (for inversions/slash chords) */
      bass?: components['schemas']['PitchClass'];
      /** @description Chord extensions (e.g., "9", "11", "13") */
      extensions?: string[] | null;
    };
    /** @description Request to claim a location as faction territory */
    ClaimTerritoryRequest: {
      /**
       * Format: uuid
       * @description Faction claiming the territory
       */
      factionId: string;
      /**
       * Format: uuid
       * @description Location to claim
       */
      locationId: string;
    };
    /** @description Status of a single clause's asset requirements */
    ClauseAssetStatus: {
      /** @description Clause identifier */
      clauseId: string;
      /** @description Whether requirement is satisfied */
      satisfied: boolean;
      /** @description What the clause requires */
      required: components['schemas']['AssetRequirementInfo'];
      /** @description Current amount present */
      current: number;
      /** @description Amount still needed (0 if satisfied) */
      missing: number;
    };
    /**
     * @description Category of clause type
     * @enum {string}
     */
    ClauseCategory: 'validation' | 'execution' | 'both';
    /** @description Per-clause distribution outcome during contract execution; excludes wallet/container IDs so consumers correlate via clauseId */
    ClauseDistributionResult: {
      /**
       * Format: uuid
       * @description The clause that was executed
       */
      clauseId: string;
      /** @description Type of clause (e.g., currency_transfer, item_transfer, fee) */
      clauseType: string;
      /** @description Descriptive type of asset involved (e.g. "currency", "item") providing human-readable context */
      assetType: string;
      /** @description Quantity transferred (currency amount, item count, etc.) */
      amount: number;
      /** @description Whether this clause executed successfully */
      succeeded: boolean;
      /** @description If succeeded is false, describes what went wrong */
      failureReason?: string | null;
    };
    /** @description Summary of a clause type */
    ClauseTypeSummary: {
      /** @description Unique identifier */
      typeCode: string;
      /** @description Human-readable description */
      description: string;
      /** @description Clause category */
      category: components['schemas']['ClauseCategory'];
      /** @description Whether a validation handler is registered */
      hasValidationHandler: boolean;
      /** @description Whether an execution handler is registered */
      hasExecutionHandler: boolean;
      /** @description Whether this is a built-in type */
      isBuiltIn: boolean;
    };
    /** @description Request to cleanup actors referencing a deleted character */
    CleanupByCharacterRequest: {
      /**
       * Format: uuid
       * @description ID of the character that was deleted
       */
      characterId: string;
    };
    /** @description Response from character cleanup operation */
    CleanupByCharacterResponse: {
      /** @description Number of actors that were stopped and cleaned up */
      actorsCleanedUp: number;
      /** @description IDs of actors that were cleaned up */
      actorIds: string[];
    };
    /** @description Request to end all relationships referencing a deleted entity during cascading resource cleanup */
    CleanupByEntityRequest: {
      /**
       * Format: uuid
       * @description ID of the deleted entity whose relationships should be ended
       */
      entityId: string;
      /** @description Type of the deleted entity (e.g., Character, Realm) */
      entityType: components['schemas']['EntityType'];
    };
    /** @description Response summarizing the results of a cascading relationship cleanup operation */
    CleanupByEntityResponse: {
      /** @description Number of active relationships that were ended during cleanup */
      relationshipsEnded: number;
      /** @description Number of relationships that were already ended (skipped) */
      alreadyEnded?: number;
      /** @description Whether the cleanup completed without errors */
      success: boolean;
    };
    /** @description Request to cleanup divine data for a deleted game service (called by lib-resource) */
    CleanupByGameServiceRequest: {
      /**
       * Format: uuid
       * @description Game service whose divine data to clean up
       */
      gameServiceId: string;
    };
    /** @description Request to cleanup territory claims for a deleted location */
    CleanupByLocationRequest: {
      /**
       * Format: uuid
       * @description ID of the location that was deleted
       */
      locationId: string;
    };
    /** @description Result of location territory claim cleanup */
    CleanupByLocationResponse: {
      /** @description Number of territory claims removed */
      claimsRemoved: number;
      /** @description Whether cleanup completed successfully */
      success: boolean;
    };
    /** @description Request to cleanup all boards for a deleted owner entity */
    CleanupByOwnerRequest: {
      /** @description Type of entity whose boards should be cleaned up */
      ownerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the entity whose boards should be cleaned up
       */
      ownerId: string;
    };
    /** @description Result of owner board cleanup */
    CleanupByOwnerResponse: {
      /** @description Type of entity that was cleaned up */
      ownerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the entity that was cleaned up
       */
      ownerId: string;
      /** @description Number of boards deleted during cleanup */
      boardsDeleted: number;
    };
    /** @description Request to cleanup faction data for a deleted realm */
    CleanupByRealmRequest: {
      /**
       * Format: uuid
       * @description ID of the realm that was deleted
       */
      realmId: string;
    };
    /** @description Result of realm faction data cleanup */
    CleanupByRealmResponse: {
      /** @description Number of factions removed */
      factionsRemoved: number;
      /** @description Number of memberships removed across all factions */
      membershipsRemoved: number;
      /** @description Number of territory claims removed */
      territoryClaimsRemoved: number;
      /** @description Number of norm definitions removed */
      normsRemoved: number;
      /** @description Whether cleanup completed successfully */
      success: boolean;
    };
    /** @description Result of executing a single cleanup callback */
    CleanupCallbackResult: {
      /** @description Source type that was cleaned up (opaque identifier) */
      sourceType: string;
      /** @description Service that was called */
      serviceName: string;
      /** @description Endpoint that was called */
      endpoint: string;
      /** @description Whether callback succeeded */
      success: boolean;
      /** @description HTTP status code from callback */
      statusCode?: number | null;
      /** @description Error message if callback failed */
      errorMessage?: string | null;
      /** @description Callback execution time in milliseconds */
      durationMs?: number;
    };
    /** @description Summary of a registered cleanup callback */
    CleanupCallbackSummary: {
      /** @description Type of resource this callback handles */
      resourceType: string;
      /** @description Type of entity that will be cleaned up */
      sourceType: string;
      /** @description Action taken when resource is deleted */
      onDeleteAction: components['schemas']['OnDeleteAction'];
      /** @description Target service for callback invocation */
      serviceName: string;
      /** @description Endpoint path called during cleanup */
      callbackEndpoint: string;
      /**
       * Format: date-time
       * @description When this callback was registered
       */
      registeredAt: string;
      /** @description Human-readable description */
      description?: string | null;
    };
    /**
     * @description Policy for cleanup callback execution.
     *     BEST_EFFORT: Proceed with deletion even if some callbacks fail
     *     ALL_REQUIRED: Abort deletion if any callback fails
     * @enum {string}
     */
    CleanupPolicy: 'BEST_EFFORT' | 'ALL_REQUIRED';
    /** @description Result of an owner cleanup operation */
    CleanupResponse: {
      /** @description Number of status instances removed */
      statusesRemoved: number;
      /** @description Number of status containers deleted */
      containersDeleted: number;
    };
    /** @description Request to clear an entity's presence from its current location */
    ClearEntityPositionRequest: {
      /** @description Type of entity (opaque string - character, actor, npc, player, etc.) */
      entityType: string;
      /**
       * Format: uuid
       * @description ID of the entity to clear
       */
      entityId: string;
    };
    /** @description Result of clearing entity presence. HTTP 200 confirms the operation completed. */
    ClearEntityPositionResponse: {
      /**
       * Format: uuid
       * @description Location the entity was removed from (null if entity had no active presence)
       */
      previousLocationId?: string | null;
    };
    /** @description Response containing the client's capability manifest with available API endpoints and shortcuts */
    ClientCapabilitiesResponse: {
      /**
       * Format: uuid
       * @description Session ID this capability manifest belongs to
       */
      sessionId: string;
      /** @description Available API capabilities for this client */
      capabilities: components['schemas']['ClientCapability'][];
      /**
       * @description Pre-bound API calls available for this session.
       *     Shortcuts are invoked like normal capabilities but Connect injects
       *     a pre-bound payload instead of using the client's payload.
       */
      shortcuts?: components['schemas']['ClientShortcut'][] | null;
      /** @description Capability manifest version (increments on changes) */
      version: number;
      /**
       * Format: date-time
       * @description When these capabilities expire and need refresh
       */
      expiresAt?: string | null;
    };
    /** @description A single API capability available to the client, mapping a client-salted GUID to a service endpoint */
    ClientCapability: {
      /**
       * Format: uuid
       * @description Client-salted GUID for this API endpoint (unique per session)
       */
      guid: string;
      /** @description Service name (e.g., "account", "auth") */
      service: string;
      /** @description API endpoint path (e.g., "/account/create") */
      endpoint: string;
      /** @description HTTP method for this endpoint */
      method: components['schemas']['HttpMethodType'];
      /** @description Human-readable description of this capability */
      description?: string | null;
      /**
       * Format: uint16
       * @description Preferred WebSocket channel for this capability
       * @default 0
       */
      channel: number;
    };
    /**
     * @description Session shortcut information sent to clients in the capability manifest.
     *     Shortcuts appear as invocable capabilities but Connect injects a pre-bound
     *     payload when the shortcut GUID is used, replacing any client-provided payload.
     */
    ClientShortcut: {
      /**
       * Format: uuid
       * @description GUID to use in WebSocket message header when invoking this shortcut.
       *     Uses UUID version 7 bits to distinguish from regular service GUIDs (version 5).
       */
      guid: string;
      /** @description The service this shortcut invokes (for client display purposes). */
      targetService: string;
      /** @description The endpoint this shortcut invokes (for client display purposes). */
      targetEndpoint: string;
      /** @description Machine-readable shortcut identifier (e.g., "get_my_stats", "join_game"). */
      name: string;
      /** @description Human-readable description of what this shortcut does. */
      description?: string | null;
      /** @description User-friendly name for display in client UIs. */
      displayName?: string | null;
      /** @description The service that created this shortcut. */
      sourceService?: string | null;
      /** @description Categorization tags for client-side organization. */
      tags?: string[] | null;
      /**
       * Format: date-time
       * @description When this shortcut expires (if time-limited).
       */
      expiresAt?: string | null;
    };
    /** @description Request to clone a board's unlock state to a new owner (developer tooling) */
    CloneBoardRequest: {
      /**
       * Format: uuid
       * @description Source board instance to clone unlock state from
       */
      sourceBoardId: string;
      /** @description Type of entity to clone the board to (must be in template's allowedOwnerTypes) */
      targetOwnerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the target entity
       */
      targetOwnerId: string;
      /**
       * Format: uuid
       * @description Realm context for the cloned board. Required for character owners (auto-resolved from character). For realm owners, must equal targetOwnerId. Null for realm-agnostic boards.
       */
      targetRealmId?: string | null;
    };
    /** @description Result of a board clone operation */
    CloneBoardResponse: {
      /**
       * Format: uuid
       * @description Source board that was cloned from
       */
      sourceBoardId: string;
      /**
       * Format: uuid
       * @description New board instance created for the target
       */
      targetBoardId: string;
      /** @description Type of entity the board was cloned to */
      targetOwnerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the entity the board was cloned to
       */
      targetOwnerId: string;
      /**
       * Format: uuid
       * @description Inventory container created for the cloned board
       */
      targetContainerId: string;
      /** @description Number of licenses cloned (item instances created) */
      licensesCloned: number;
    };
    /** @description Request to collapse a delta chain into a full snapshot */
    CollapseDeltasRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the save slot
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Name of the slot containing deltas to collapse */
      slotName: string;
      /** @description Version to collapse to (latest if null) */
      versionNumber?: number | null;
      /**
       * @description Delete intermediate delta versions after collapse
       * @default true
       */
      deleteIntermediates: boolean;
    };
    /** @description Maps a tag prefix on a collection entry to a growth domain and amount. When an entry is unlocked, its tags are matched against tagPrefix. Matching tags determine the growth domain (tagPrefix becomes the domain path) and the growth amount to record. */
    CollectionDomainMapping: {
      /** @description Tag prefix to match against entry tags. An entry tag "combat.melee.sword" matches prefix "combat" and "combat.melee". The full matching tag becomes the growth domain path. */
      tagPrefix: string;
      /**
       * Format: float
       * @description Base growth amount to record when a tag matches this prefix.
       */
      baseAmount: number;
      /**
       * Format: float
       * @description Additional growth amount per discovery level of the entry. Total growth = baseAmount + (discoveryLevel * discoveryBonusPerLevel). Null or 0 means no discovery bonus.
       */
      discoveryBonusPerLevel?: number | null;
    };
    /** @description Maps a collection type to growth domain mappings. When a collection entry is unlocked, Seed uses these mappings to determine which growth domains receive growth and how much. Matched by collection type code. */
    CollectionGrowthMapping: {
      /** @description Collection type code to match against (e.g., "bestiary", "music_library"). */
      collectionType: string;
      /** @description Mappings from entry tag prefixes to growth domains. */
      domainMappings: components['schemas']['CollectionDomainMapping'][];
    };
    /** @description Collection instance with summary */
    CollectionResponse: {
      /**
       * Format: uuid
       * @description Unique collection instance identifier
       */
      collectionId: string;
      /**
       * Format: uuid
       * @description Entity that owns this collection
       */
      ownerId: string;
      /** @description Entity type discriminator */
      ownerType: components['schemas']['EntityType'];
      /** @description Type of collection */
      collectionType: components['schemas']['CollectionType'];
      /**
       * Format: uuid
       * @description Game service this collection is scoped to
       */
      gameServiceId: string;
      /**
       * Format: uuid
       * @description Inventory container holding unlocked entry items
       */
      containerId: string;
      /** @description Number of unlocked entries in this collection */
      entryCount: number;
      /**
       * Format: date-time
       * @description When this collection was created
       */
      createdAt: string;
    };
    /**
     * @description Opaque string code identifying the type of collection content.
     *     Collection types are game-defined and extensible  new types can be
     *     registered without schema changes. Common conventions include
     *     voice_gallery, scene_archive, music_library, bestiary, recipe_book,
     *     but any string code is valid.
     */
    CollectionType: string;
    /**
     * @description Combat behavior preferences that influence tactical decisions.
     *     These values affect GOAP action selection, retreat conditions,
     *     and group coordination behavior.
     */
    CombatPreferences: {
      /** @description Overall combat approach */
      style: components['schemas']['CombatStyle'];
      /** @description Preferred engagement distance */
      preferredRange: components['schemas']['PreferredRange'];
      /** @description Role when fighting in groups */
      groupRole: components['schemas']['GroupRole'];
      /**
       * Format: float
       * @description Willingness to take dangerous actions (0.0 = very cautious, 1.0 = reckless).
       *     Affects ability selection and target prioritization.
       */
      riskTolerance: number;
      /**
       * Format: float
       * @description Health percentage at which retreat is considered (0.0 = fight to death,
       *     0.5 = retreat at half health, 1.0 = retreat at any damage).
       */
      retreatThreshold: number;
      /**
       * @description Whether to prioritize ally protection over self-preservation.
       *     Affects target selection and positioning decisions.
       */
      protectAllies: boolean;
    };
    /** @description Combat preferences profile for behavior system consumption */
    CombatPreferencesResponse: {
      /**
       * Format: uuid
       * @description Character these preferences belong to
       */
      characterId: string;
      /** @description The combat preferences values */
      preferences: components['schemas']['CombatPreferences'];
      /** @description Preferences version number (increments on each evolution) */
      version: number;
      /**
       * Format: date-time
       * @description When these preferences were first created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When these preferences were last modified
       */
      updatedAt?: string | null;
    };
    /**
     * @description Overall approach to combat situations. Affects target selection,
     *     ability usage, and engagement decisions.
     * @enum {string}
     */
    CombatStyle: 'DEFENSIVE' | 'BALANCED' | 'AGGRESSIVE' | 'BERSERKER' | 'TACTICAL';
    /** @description Request to commit checkout changes */
    CommitRequest: {
      /**
       * Format: uuid
       * @description Scene being committed
       */
      sceneId: string;
      /** @description Checkout token from checkout response */
      checkoutToken: string;
      /** @description Updated scene document */
      scene: components['schemas']['Scene'];
      /** @description Optional summary of changes for audit */
      changesSummary?: string | null;
    };
    /** @description Response confirming commit */
    CommitResponse: {
      /** @description Whether commit was successful */
      committed: boolean;
      /** @description New version after commit */
      newVersion: string;
      /** @description Committed scene with updated metadata */
      scene?: components['schemas']['Scene'];
    };
    /**
     * @description Comparison operators for numeric conditions
     * @enum {string}
     */
    ComparisonOperator: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte';
    /** @description Options controlling the ABML compilation process including optimizations and caching */
    CompilationOptions: {
      /**
       * @description Enable behavior tree optimizations
       * @default true
       */
      enableOptimizations: boolean;
      /**
       * @description Cache the compiled behavior for reuse
       * @default true
       */
      cacheCompiledResult: boolean;
      /**
       * @description Enable strict validation mode
       * @default false
       */
      strictValidation: boolean;
      /**
       * @description Apply cultural adaptations during compilation
       * @default true
       */
      culturalAdaptations: boolean;
      /**
       * @description Generate GOAP goals from behaviors
       * @default true
       */
      goapIntegration: boolean;
    };
    /** @description Request to compile an ABML behavior definition into executable behavior trees */
    CompileBehaviorRequest: {
      /**
       * @description Raw ABML YAML content to compile
       * @example version: "1.0.0"
       *     metadata:
       *       id: "example_behavior"
       *       category: "basic"
       *     behaviors:
       *       example:
       *         triggers:
       *           - condition: "true"
       *         actions:
       *           - log:
       *               message: "Hello World"
       */
      abmlContent: string;
      /**
       * @description Optional human-readable name for the behavior.
       *     If not provided, extracted from ABML metadata.id or generated from content hash.
       * @example blacksmith_daily_routine
       */
      behaviorName?: string | null;
      /**
       * @description Category for organizing behaviors (e.g., profession, cultural, situational).
       *     Used for filtering and grouping in bundles.
       * @example professional
       * @enum {string|null}
       */
      behaviorCategory?:
        | 'base'
        | 'cultural'
        | 'professional'
        | 'personal'
        | 'situational'
        | 'ambient'
        | null;
      /**
       * @description Optional bundle identifier for grouping related behaviors.
       *     When specified, the compiled behavior will be added to a bundle with this ID.
       *     Clients can then download entire bundles for efficient bulk loading.
       *     If the bundle doesn't exist, it will be created.
       * @example blacksmith-behaviors-v1
       */
      bundleId?: string | null;
      /** @description Character context for context variable resolution during compilation */
      characterContext?: components['schemas']['CharacterContext'];
      /** @description Options controlling the compilation process */
      compilationOptions?: components['schemas']['CompilationOptions'];
    };
    /** @description Response containing the results of an ABML behavior compilation */
    CompileBehaviorResponse: {
      /**
       * @description Unique identifier for the compiled behavior (content-addressable hash)
       * @example behavior-a1b2c3d4e5f6g7h8
       */
      behaviorId: string;
      /**
       * @description Human-readable name of the behavior
       * @example blacksmith_daily_routine
       */
      behaviorName?: string | null;
      /** @description The compiled behavior data including behavior tree and metadata */
      compiledBehavior?: components['schemas']['CompiledBehavior'];
      /** @description Time taken to compile the behavior in milliseconds */
      compilationTimeMs?: number;
      /** @description Asset service ID where the compiled bytecode is stored. Null only when caching is explicitly disabled. */
      assetId?: string | null;
      /** @description Bundle ID if the behavior was added to a bundle. Null if not bundled. */
      bundleId?: string | null;
      /** @description True if this replaced an existing behavior with the same content hash */
      isUpdate?: boolean;
      /** @description Non-fatal warnings during compilation */
      warnings?: string[] | null;
    };
    /** @description Compiled behavior containing behavior tree, context schema, and GOAP integration data */
    CompiledBehavior: {
      /** @description Compiled behavior tree data with bytecode or download reference */
      behaviorTree: components['schemas']['BehaviorTreeData'];
      /** @description Schema defining required context variables for execution */
      contextSchema: components['schemas']['ContextSchemaData'];
      /** @description List of required services for this behavior */
      serviceDependencies?: string[] | null;
      /** @description GOAP goals extracted from the behavior */
      goapGoals?: components['schemas']['GoapGoal'][] | null;
      /** @description Metadata for behavior execution including performance hints and resource requirements */
      executionMetadata?: components['schemas']['ExecutionMetadata'];
    };
    /** @description Request to complete a milestone */
    CompleteMilestoneRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Milestone to complete */
      milestoneCode: string;
      /** @description Client-only evidence data. No Bannou plugin reads specific keys from this field by convention. */
      evidence?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to complete a scenario */
    CompleteScenarioRequest: {
      /**
       * Format: uuid
       * @description Account completing the scenario
       */
      accountId: string;
      /**
       * Format: uuid
       * @description Scenario instance to complete
       */
      scenarioInstanceId: string;
    };
    /** @description Request to finalize an upload and trigger asset processing */
    CompleteUploadRequest: {
      /**
       * Format: uuid
       * @description Upload session ID from requestUpload
       */
      uploadId: string;
      /** @description For multipart uploads - ETags of completed parts (null for single-file uploads) */
      parts?: components['schemas']['CompletedPart'][] | null;
    };
    /** @description Information about a completed part in a multipart upload */
    CompletedPart: {
      /** @description Part number (1-based) */
      partNumber: number;
      /** @description ETag returned from part upload */
      etag: string;
    };
    /** @description Completion statistics for a collection */
    CompletionStatsResponse: {
      /** @description Type of collection */
      collectionType: components['schemas']['CollectionType'];
      /** @description Total number of entry templates available */
      totalEntries: number;
      /** @description Number of entries unlocked by this owner */
      unlockedEntries: number;
      /**
       * Format: double
       * @description Completion percentage (0.0 to 100.0)
       */
      completionPercentage: number;
      /** @description Completion breakdown by category */
      byCategory?: {
        [key: string]: components['schemas']['CategoryStats'];
      } | null;
    };
    /** @description Constraints on storyline composition */
    ComposeConstraints: {
      /**
       * Format: uuid
       * @description Realm to anchor the storyline in
       */
      realmId?: string | null;
      /**
       * Format: uuid
       * @description Optional starting location
       */
      locationId?: string | null;
      /** @description Maximum entities the plan can require (default from config) */
      maxEntities?: number | null;
      /** @description Maximum phases in the plan (default unlimited) */
      maxPhases?: number | null;
    };
    /** @description Request to compose a storyline plan */
    ComposeRequest: {
      /**
       * @description Archive or snapshot sources to seed the storyline.
       *     At least one source is required. Mix of archives and snapshots allowed.
       */
      seedSources: components['schemas']['SeedSource'][];
      /** @description The high-level goal driving arc selection */
      goal: components['schemas']['StorylineGoal'];
      /** @description Optional constraints on composition */
      constraints?: components['schemas']['ComposeConstraints'];
      /**
       * @description Genre filter (e.g., "crime", "action", "romance").
       *     If omitted, inferred from archive data.
       */
      genre?: string | null;
      /** @description Specific arc type to use. If omitted, selected based on goal. */
      arcType?: components['schemas']['ArcType'];
      /** @description Planning urgency level. Defaults to configuration value. */
      urgency?: components['schemas']['PlanningUrgency'];
      /** @description Random seed for deterministic output (enables caching) */
      seed?: number | null;
    };
    /** @description Composed storyline plan */
    ComposeResponse: {
      /**
       * Format: uuid
       * @description Unique plan identifier
       */
      planId: string;
      /**
       * Format: double
       * @description Plan viability score (0-1)
       */
      confidence: number;
      /** @description The goal that was used */
      goal: components['schemas']['StorylineGoal'];
      /** @description Inferred or specified genre */
      genre?: string | null;
      /** @description Emotional arc type used */
      arcType: components['schemas']['ArcType'];
      /** @description Primary Life Value spectrum */
      primarySpectrum: components['schemas']['SpectrumType'];
      /** @description Inferred thematic elements */
      themes?: string[] | null;
      /** @description Planned phases with actions */
      phases: components['schemas']['StorylinePlanPhase'][];
      /**
       * @description Entities required for this storyline (descriptions only).
       *     Callers decide whether to spawn them.
       */
      entitiesToSpawn?: components['schemas']['EntityRequirement'][] | null;
      /** @description Links between entities in the plan */
      links?: components['schemas']['StorylineLink'][] | null;
      /** @description Identified risks or weak points in the plan */
      risks?: components['schemas']['StorylineRisk'][] | null;
      /** @description Time taken to generate in milliseconds */
      generationTimeMs: number;
      /** @description Whether this was returned from cache */
      cached: boolean;
    };
    /** @description Metadata about a generated composition */
    CompositionMetadata: {
      /** @description Style used */
      styleId?: string | null;
      /** @description Key signature */
      key?: components['schemas']['KeySignature'];
      /** @description Tempo in BPM */
      tempo?: number | null;
      /** @description Number of bars */
      bars?: number | null;
      /** @description Tune type if applicable */
      tuneType?: string | null;
      /** @description Random seed used */
      seed?: number | null;
    };
    /** @description Result of a single compression callback */
    CompressCallbackResult: {
      /** @description Source type that provided data */
      sourceType: string;
      /** @description Service that was called */
      serviceName: string;
      /** @description Endpoint that was called */
      endpoint: string;
      /** @description Whether callback succeeded */
      success: boolean;
      /** @description HTTP status code from callback */
      statusCode?: number | null;
      /** @description Error message if callback failed */
      errorMessage?: string | null;
      /** @description Size of compressed data in bytes */
      dataSize?: number | null;
      /** @description Callback execution time in milliseconds */
      durationMs: number;
    };
    /** @description Summary of a registered compression callback */
    CompressCallbackSummary: {
      /** @description Type of resource this callback handles */
      resourceType: string;
      /** @description Type of data being compressed */
      sourceType: string;
      /** @description Target service for callback invocation */
      serviceName: string;
      /** @description Endpoint called during compression */
      compressEndpoint: string;
      /** @description Endpoint called during decompression */
      decompressEndpoint?: string | null;
      /** @description Execution order (lower = earlier) */
      priority: number;
      /**
       * Format: date-time
       * @description When this callback was registered
       */
      registeredAt: string;
      /** @description Human-readable description */
      description?: string | null;
    };
    /**
     * @description Policy for compression callback execution.
     *     BEST_EFFORT: Create archive even if some callbacks fail (partial archive)
     *     ALL_REQUIRED: Abort compression if any callback fails
     * @enum {string}
     */
    CompressionPolicy: 'BEST_EFFORT' | 'ALL_REQUIRED';
    /**
     * @description Compression algorithm for bundles
     * @enum {string}
     */
    CompressionType: 'lz4' | 'lzma' | 'none';
    /** @description Result of evaluating a single condition */
    ConditionResult: {
      /** @description Condition type */
      conditionType: components['schemas']['TriggerConditionType'];
      /** @description Whether condition was met */
      met: boolean;
      /** @description Actual value found */
      actualValue?: string | null;
      /** @description Expected value */
      expectedValue?: string | null;
      /** @description Additional details */
      details?: string | null;
    };
    /** @description Request to confirm a pending bond. */
    ConfirmBondRequest: {
      /**
       * Format: uuid
       * @description The bond to confirm.
       */
      bondId: string;
      /**
       * Format: uuid
       * @description The seed confirming the bond.
       */
      confirmingSeedId: string;
    };
    /** @description Request to confirm receipt of refunded assets */
    ConfirmRefundRequest: {
      /**
       * Format: uuid
       * @description The escrow being confirmed.
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description The party confirming receipt of refund.
       */
      partyId: string;
      /** @description Optional confirmation notes. */
      notes?: string | null;
    };
    /** @description Response from confirming refund receipt */
    ConfirmRefundResponse: {
      /**
       * Format: uuid
       * @description The escrow ID.
       */
      escrowId: string;
      /** @description Whether this party's confirmation was recorded. */
      confirmed: boolean;
      /** @description Whether all parties have now confirmed (triggers Refunded transition). */
      allPartiesConfirmed: boolean;
      /** @description Current escrow status after confirmation. */
      status?: components['schemas']['EscrowStatus'];
    };
    /** @description Request to confirm receipt of released assets */
    ConfirmReleaseRequest: {
      /**
       * Format: uuid
       * @description The escrow being confirmed.
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description The party confirming receipt.
       */
      partyId: string;
      /** @description The party's release token (received via confirmation shortcut). */
      releaseToken: string;
      /** @description Optional confirmation notes. */
      notes?: string | null;
    };
    /** @description Response from confirming release receipt */
    ConfirmReleaseResponse: {
      /**
       * Format: uuid
       * @description The escrow ID.
       */
      escrowId: string;
      /** @description Whether this party's confirmation was recorded. */
      confirmed: boolean;
      /** @description Whether all parties have now confirmed (triggers Released transition). */
      allPartiesConfirmed: boolean;
      /** @description Current escrow status after confirmation. */
      status?: components['schemas']['EscrowStatus'];
    };
    /** @description A bundle entry in an asset conflict */
    ConflictingBundleEntry: {
      /** @description Bundle containing this version */
      bundleId: string;
      /** @description Content hash of asset in this bundle */
      contentHash: string;
    };
    /**
     * @description How a scenario instance connects to the broader game world
     * @enum {string}
     */
    ConnectivityMode: 'Isolated' | 'WorldSlice' | 'Persistent';
    /** @description Request to record party consent for release or refund */
    ConsentRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Party giving consent
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Type of consent being given */
      consentType: components['schemas']['EscrowConsentType'];
      /** @description Release token (required for full_consent) */
      releaseToken?: string | null;
      /** @description Optional notes */
      notes?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from recording party consent */
    ConsentResponse: {
      /** @description Updated escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Whether consent was recorded */
      consentRecorded: boolean;
      /** @description Whether this consent triggered completion */
      triggered: boolean;
      /** @description New escrow status after consent */
      newStatus: components['schemas']['EscrowStatus'];
    };
    /**
     * @description Party's consent status
     * @enum {string}
     */
    ConsentStatus: 'pending' | 'consented' | 'declined' | 'implicit';
    /** @description Request to consent to a contract */
    ConsentToContractRequest: {
      /**
       * Format: uuid
       * @description Contract to consent to
       */
      contractId: string;
      /**
       * Format: uuid
       * @description Entity ID of consenting party
       */
      partyEntityId: string;
      /** @description Entity type of consenting party */
      partyEntityType: components['schemas']['EntityType'];
    };
    /**
     * @description Type of constraint to check
     * @enum {string}
     */
    ConstraintType: 'exclusivity' | 'non_compete' | 'time_commitment';
    /** @description User-submitted contact form data */
    ContactRequest: {
      /**
       * Format: email
       * @description Sender email address for replies
       */
      email: string;
      /** @description Name of the person submitting the form */
      name?: string | null;
      /** @description Subject line of the contact message */
      subject: string;
      /** @description Body content of the contact message */
      message: string;
      /**
       * @description Category to route the contact request
       * @default general
       * @enum {string}
       */
      category: 'general' | 'support' | 'bug' | 'feedback' | 'business';
    };
    /** @description Confirmation response after submitting a contact form */
    ContactResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the created support ticket
       */
      ticketId: string;
      /**
       * @description Confirmation message displayed to the user
       * @default Thank you for contacting us. We will respond within 24-48 hours.
       */
      message: string;
    };
    /**
     * @description Container capacity constraint type
     * @enum {string}
     */
    ContainerConstraintModel:
      | 'slot_only'
      | 'weight_only'
      | 'slot_and_weight'
      | 'grid'
      | 'volumetric'
      | 'unlimited';
    /** @description Item in a container */
    ContainerItem: {
      /**
       * Format: uuid
       * @description Item instance ID
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Item template ID
       */
      templateId: string;
      /**
       * Format: double
       * @description Item quantity
       */
      quantity: number;
      /** @description Slot position */
      slotIndex?: number | null;
      /** @description Grid X position */
      slotX?: number | null;
      /** @description Grid Y position */
      slotY?: number | null;
      /** @description Rotated in grid */
      rotated?: boolean | null;
    };
    /**
     * @description Type of entity that owns this container
     * @enum {string}
     */
    ContainerOwnerType:
      | 'character'
      | 'account'
      | 'location'
      | 'vehicle'
      | 'guild'
      | 'escrow'
      | 'mail'
      | 'other';
    /** @description Container details */
    ContainerResponse: {
      /**
       * Format: uuid
       * @description Container unique identifier
       */
      containerId: string;
      /**
       * Format: uuid
       * @description Owner entity ID
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['ContainerOwnerType'];
      /** @description Container type */
      containerType: string;
      /** @description Constraint model */
      constraintModel: components['schemas']['ContainerConstraintModel'];
      /** @description Whether this is an equipment slot */
      isEquipmentSlot: boolean;
      /** @description Equipment slot name */
      equipmentSlotName?: string | null;
      /** @description Maximum slots */
      maxSlots?: number | null;
      /** @description Current used slots */
      usedSlots?: number | null;
      /**
       * Format: double
       * @description Maximum weight
       */
      maxWeight?: number | null;
      /** @description Internal grid width */
      gridWidth?: number | null;
      /** @description Internal grid height */
      gridHeight?: number | null;
      /**
       * Format: double
       * @description Maximum volume
       */
      maxVolume?: number | null;
      /**
       * Format: double
       * @description Current volume used
       */
      currentVolume?: number | null;
      /**
       * Format: uuid
       * @description Parent container ID
       */
      parentContainerId?: string | null;
      /** @description Depth in container hierarchy */
      nestingDepth: number;
      /** @description Whether can hold containers */
      canContainContainers: boolean;
      /** @description Max nesting depth */
      maxNestingDepth?: number | null;
      /**
       * Format: double
       * @description Empty container weight
       */
      selfWeight: number;
      /** @description Weight propagation mode */
      weightContribution: components['schemas']['WeightContribution'];
      /** @description Slots used in parent */
      slotCost: number;
      /** @description Width in parent grid */
      parentGridWidth?: number | null;
      /** @description Height in parent grid */
      parentGridHeight?: number | null;
      /**
       * Format: double
       * @description Volume in parent
       */
      parentVolume?: number | null;
      /**
       * Format: double
       * @description Weight of direct contents
       */
      contentsWeight: number;
      /**
       * Format: double
       * @description Total weight including self
       */
      totalWeight: number;
      /** @description Allowed categories */
      allowedCategories?: string[] | null;
      /** @description Forbidden categories */
      forbiddenCategories?: string[] | null;
      /** @description Required tags */
      allowedTags?: string[] | null;
      /**
       * Format: uuid
       * @description Realm ID
       */
      realmId?: string | null;
      /** @description Container tags */
      tags?: string[] | null;
      /** @description Game-specific container data. Client-only metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last modification
       */
      modifiedAt?: string | null;
    };
    /** @description Container with item contents */
    ContainerWithContentsResponse: {
      /** @description Container details */
      container: components['schemas']['ContainerResponse'];
      /** @description Items in container */
      items: components['schemas']['ContainerItem'][];
    };
    /** @description Selected content entry for an area */
    ContentSelectionResponse: {
      /** @description Code of the selected entry */
      entryCode: string;
      /** @description Display name of the selected entry */
      displayName: string;
      /** @description Category of the selected entry */
      category?: string | null;
      /** @description Primary asset identifier for the entry */
      assetId?: string | null;
      /** @description Thumbnail asset identifier for the entry */
      thumbnailAssetId?: string | null;
      /** @description Theme tags of the selected entry */
      themes?: string[] | null;
      /** @description Themes that matched the area configuration */
      matchedThemes: string[];
    };
    /** @description Schema defining required context variables for behavior execution */
    ContextSchemaData: {
      [key: string]: unknown;
    };
    /**
     * @description Type of contract binding on an item instance.
     *     - none: No contract bound
     *     - session: Temporary binding for multi-step use (managed by Item service)
     *     - lifecycle: Persistent binding for status effects, licenses, etc. (managed by external orchestrators)
     * @enum {string}
     */
    ContractBindingType: 'none' | 'session' | 'lifecycle';
    /** @description An asset requirement within a clause definition */
    ContractClauseAsset: {
      /** @description Asset type (currency, item) */
      type: string;
      /** @description Asset code identifier */
      code: string;
      /** @description Required amount of the asset */
      amount: number;
    };
    /** @description A clause definition for contract execution specifying asset transfers, fees, or requirements */
    ContractClauseDefinition: {
      /** @description Unique identifier for this clause within the contract */
      id: string;
      /** @description Clause type code (fee, distribution, currency_transfer, item_transfer, asset_requirement) */
      type: string;
      /** @description Party role reference for this clause */
      party?: string | null;
      /** @description Amount value (numeric string for template substitution support) */
      amount?: string | null;
      /** @description How to interpret the amount (flat, percentage, remainder) */
      amountType?: string | null;
      /** @description Source wallet identifier or template variable reference */
      sourceWallet?: string | null;
      /** @description Destination wallet identifier or template variable reference */
      destinationWallet?: string | null;
      /** @description Recipient wallet for fee clauses or template variable reference */
      recipientWallet?: string | null;
      /** @description Currency code for currency-based clauses */
      currencyCode?: string | null;
      /** @description Source container identifier or template variable reference for item clauses */
      sourceContainer?: string | null;
      /** @description Destination container identifier or template variable reference for item clauses */
      destinationContainer?: string | null;
      /** @description Item code for item-based clauses */
      itemCode?: string | null;
      /** @description Location template variable reference for asset requirement checks */
      checkLocation?: string | null;
      /** @description Asset requirements for asset_requirement clause type */
      assets?: components['schemas']['ContractClauseAsset'][] | null;
    };
    /** @description Contract instance details */
    ContractInstanceResponse: {
      /**
       * Format: uuid
       * @description Unique contract identifier
       */
      contractId: string;
      /**
       * Format: uuid
       * @description Source template ID
       */
      templateId: string;
      /** @description Source template code */
      templateCode: string;
      /** @description Current contract status */
      status: components['schemas']['ContractStatus'];
      /** @description Contract parties */
      parties: components['schemas']['ContractPartyResponse'][];
      /** @description Contract terms */
      terms?: components['schemas']['ContractTerms'];
      /** @description Milestone progress */
      milestones?: components['schemas']['MilestoneInstanceResponse'][] | null;
      /** @description Index of current milestone */
      currentMilestoneIndex?: number | null;
      /** @description Related escrow IDs */
      escrowIds?: string[] | null;
      /**
       * Format: date-time
       * @description When contract was proposed
       */
      proposedAt?: string | null;
      /**
       * Format: date-time
       * @description When all parties consented
       */
      acceptedAt?: string | null;
      /**
       * Format: date-time
       * @description When contract became active
       */
      effectiveFrom?: string | null;
      /**
       * Format: date-time
       * @description When contract expires
       */
      effectiveUntil?: string | null;
      /**
       * Format: date-time
       * @description When contract was terminated
       */
      terminatedAt?: string | null;
      /** @description Client-only game metadata. No Bannou plugin reads specific keys from this field by convention. */
      gameMetadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last update timestamp
       */
      updatedAt?: string | null;
    };
    /** @description Contract status summary */
    ContractInstanceStatusResponse: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Current status */
      status: components['schemas']['ContractStatus'];
      /** @description Milestone progress summary */
      milestoneProgress: components['schemas']['MilestoneProgressSummary'][];
      /** @description Parties who haven't consented */
      pendingConsents?: components['schemas']['PendingConsentSummary'][] | null;
      /** @description Active breach records */
      activeBreaches?: components['schemas']['BreachSummary'][] | null;
      /** @description Days until natural expiration */
      daysUntilExpiration?: number | null;
    };
    /** @description Contract metadata */
    ContractMetadataResponse: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Client-only instance metadata. No Bannou plugin reads specific keys from this field by convention. */
      instanceData?: {
        [key: string]: unknown;
      } | null;
      /** @description Client-only runtime state. No Bannou plugin reads specific keys from this field by convention. */
      runtimeState?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Party input for contract creation */
    ContractPartyInput: {
      /**
       * Format: uuid
       * @description Entity ID
       */
      entityId: string;
      /** @description Entity type */
      entityType: components['schemas']['EntityType'];
      /** @description Role from template */
      role: string;
    };
    /** @description Contract party details */
    ContractPartyResponse: {
      /**
       * Format: uuid
       * @description Entity ID
       */
      entityId: string;
      /** @description Entity type */
      entityType: components['schemas']['EntityType'];
      /** @description Role in contract */
      role: string;
      /** @description Consent status */
      consentStatus: components['schemas']['ConsentStatus'];
      /**
       * Format: date-time
       * @description When consent was given
       */
      consentedAt?: string | null;
    };
    /**
     * @description Action to take on a contract-governed room when contract state changes
     * @enum {string}
     */
    ContractRoomAction: 'Continue' | 'Lock' | 'Archive' | 'Delete';
    /**
     * @description Current status of a contract instance
     * @enum {string}
     */
    ContractStatus:
      | 'draft'
      | 'proposed'
      | 'pending'
      | 'active'
      | 'fulfilled'
      | 'expired'
      | 'terminated'
      | 'breached'
      | 'suspended'
      | 'disputed'
      | 'declined';
    /** @description Brief contract information */
    ContractSummary: {
      /**
       * Format: uuid
       * @description Contract ID
       */
      contractId: string;
      /** @description Template code */
      templateCode: string;
      /** @description Template name */
      templateName?: string | null;
      /** @description Current status */
      status: components['schemas']['ContractStatus'];
      /** @description Entity's role in contract (null if party record not found due to data inconsistency) */
      role?: string | null;
      /**
       * Format: date-time
       * @description When contract expires
       */
      effectiveUntil?: string | null;
    };
    /** @description Contract template details */
    ContractTemplateResponse: {
      /**
       * Format: uuid
       * @description Unique template identifier
       */
      templateId: string;
      /** @description Unique template code */
      code: string;
      /** @description Human-readable name */
      name: string;
      /** @description Detailed description */
      description?: string | null;
      /**
       * Format: uuid
       * @description Realm ID if realm-specific
       */
      realmId?: string | null;
      /** @description Minimum parties required */
      minParties: number;
      /** @description Maximum parties allowed */
      maxParties: number;
      /** @description Party role definitions */
      partyRoles: components['schemas']['PartyRoleDefinition'][];
      /** @description Default contract terms */
      defaultTerms?: components['schemas']['ContractTerms'];
      /** @description Milestone definitions */
      milestones?: components['schemas']['MilestoneDefinition'][] | null;
      /** @description Default enforcement mode */
      defaultEnforcementMode: components['schemas']['EnforcementMode'];
      /** @description Whether contracts can be transferred */
      transferable: boolean;
      /** @description Client-only game metadata. No Bannou plugin reads specific keys from this field by convention. */
      gameMetadata?: {
        [key: string]: unknown;
      } | null;
      /** @description Whether template is active */
      isActive: boolean;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last update timestamp
       */
      updatedAt?: string | null;
    };
    /** @description Configurable contract terms */
    ContractTerms: {
      /** @description Contract duration (ISO 8601 duration, null for perpetual) */
      duration?: string | null;
      /** @description When payments occur */
      paymentSchedule?: components['schemas']['PaymentSchedule'];
      /** @description Recurring payment frequency (ISO 8601 duration) */
      paymentFrequency?: string | null;
      /** @description How contract can be terminated */
      terminationPolicy?: components['schemas']['TerminationPolicy'];
      /** @description Required notice for termination (ISO 8601 duration) */
      terminationNoticePeriod?: string | null;
      /** @description Breaches before auto-termination (0 for no auto) */
      breachThreshold?: number | null;
      /** @description Time to cure breach (ISO 8601 duration) */
      gracePeriodForCure?: string | null;
      /** @description Whether this contract has an exclusivity clause preventing the entity from entering similar contracts */
      exclusivity?: boolean | null;
      /** @description Whether this contract has a non-compete clause */
      nonCompete?: boolean | null;
      /** @description Whether this contract has a time commitment clause */
      timeCommitment?: boolean | null;
      /** @description Type of time commitment for scheduling constraints */
      timeCommitmentType?: components['schemas']['TimeCommitmentType'] | null;
      /** @description Clause definitions for contract execution (fees, distributions, asset requirements) */
      clauses?: components['schemas']['ContractClauseDefinition'][] | null;
      /** @description Client-only custom terms. No Bannou plugin reads specific keys from this field by convention. */
      customTerms?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description The faction controlling a location */
    ControllingFactionResponse: {
      /**
       * Format: uuid
       * @description Location that is controlled
       */
      locationId: string;
      /** @description The controlling faction */
      faction: components['schemas']['FactionResponse'];
      /**
       * Format: uuid
       * @description Territory claim record ID
       */
      claimId: string;
      /**
       * Format: date-time
       * @description When the territory was claimed
       */
      claimedAt: string;
    };
    /** @description A step in the conversion path */
    ConversionStep: {
      /** @description Source currency code */
      from: string;
      /** @description Target currency code */
      to: string;
      /**
       * Format: double
       * @description Rate applied in this step
       */
      rate: number;
    };
    /**
     * @description How this location's coordinate system relates to its parent
     * @enum {string}
     */
    CoordinateMode: 'inherit' | 'local' | 'portal';
    /** @description 3D spatial coordinates representing a position in the game world */
    Coordinates: {
      /** @description X coordinate position */
      x?: number;
      /** @description Y coordinate position */
      y?: number;
      /** @description Z coordinate position */
      z?: number;
    };
    /** @description Request to copy save data from one slot to another, optionally across different entities or games. */
    CopySaveRequest: {
      /** @description Game identifier of the source save */
      sourceGameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the source save
       */
      sourceOwnerId: string;
      /** @description Type of entity that owns the source save */
      sourceOwnerType: components['schemas']['EntityType'];
      /** @description Name of the source slot to copy from */
      sourceSlotName: string;
      /** @description Version to copy (latest if null) */
      sourceVersion?: number | null;
      /** @description Game identifier for the target save */
      targetGameId: string;
      /**
       * Format: uuid
       * @description Entity ID that will own the copied save
       */
      targetOwnerId: string;
      /** @description Type of entity that will own the copied save */
      targetOwnerType: components['schemas']['EntityType'];
      /** @description Name of the target slot to copy to */
      targetSlotName: string;
      /** @description Category for new slot if auto-created */
      targetCategory?: components['schemas']['SaveCategory'];
    };
    /** @description Request to count items */
    CountItemsRequest: {
      /**
       * Format: uuid
       * @description Owner to count for
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['ContainerOwnerType'];
      /**
       * Format: uuid
       * @description Template to count
       */
      templateId: string;
    };
    /** @description Count result */
    CountItemsResponse: {
      /**
       * Format: uuid
       * @description Counted template
       */
      templateId: string;
      /**
       * Format: double
       * @description Total quantity
       */
      totalQuantity: number;
      /** @description Number of stacks */
      stackCount: number;
    };
    /** @description Statistics about asset resolution coverage */
    CoverageAnalysis: {
      /** @description Total number of assets requested */
      totalRequested: number;
      /** @description Assets resolved through bundle downloads */
      resolvedViaBundles: number;
      /** @description Assets resolved as standalone downloads */
      resolvedStandalone: number;
      /** @description Assets that could not be found */
      unresolvedCount: number;
      /**
       * Format: float
       * @description Ratio of assets provided to bundle downloads (higher is better)
       */
      bundleEfficiency?: number | null;
    };
    /** @description Request to create a new achievement */
    CreateAchievementDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service owning this achievement
       */
      gameServiceId: string;
      /** @description Unique identifier for this achievement (lowercase, no spaces) */
      achievementId: string;
      /** @description Human-readable name */
      displayName: string;
      /** @description Description of how to earn this achievement */
      description: string;
      /** @description Description shown before achievement is earned (for hidden types) */
      hiddenDescription?: string | null;
      /**
       * @description Classification of the achievement (affects visibility and progress behavior)
       * @default standard
       */
      achievementType: components['schemas']['AchievementType'];
      /** @description Which entity types can earn this achievement */
      entityTypes?: components['schemas']['EntityType'][];
      /** @description Target value for progressive achievements */
      progressTarget?: number | null;
      /**
       * @description Point value of this achievement
       * @default 10
       */
      points: number;
      /** @description URL to achievement icon */
      iconUrl?: string | null;
      /** @description Platforms where this achievement exists */
      platforms?: components['schemas']['Platform'][];
      /** @description Platform-specific achievement IDs (e.g., {"steam": "ACH_001"}) */
      platformIds?: {
        [key: string]: string;
      } | null;
      /** @description Achievement IDs that must be unlocked first */
      prerequisites?: string[] | null;
      /**
       * @description Whether this achievement can be earned
       * @default true
       */
      isActive: boolean;
      /** @description Additional achievement-specific metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to create a new actor template definition */
    CreateActorTemplateRequest: {
      /** @description Category identifier (e.g., "npc-brain", "world-admin", "cron-cleanup") */
      category: string;
      /** @description Reference to behavior in lib-assets (e.g., "asset://behaviors/npc-brain-v1") */
      behaviorRef: string;
      /** @description Game-specific configuration passed to ABML behavior execution scope. No Bannou plugin reads specific keys from this field by convention. Different ABML behaviors define their own expected configuration structure. */
      configuration?: {
        [key: string]: unknown;
      } | null;
      /** @description Auto-spawn configuration for instantiate-on-access */
      autoSpawn?: components['schemas']['AutoSpawnConfig'];
      /**
       * @description Milliseconds between behavior loop iterations
       * @default 1000
       */
      tickIntervalMs: number;
      /**
       * @description Seconds between automatic state saves (0 to disable)
       * @default 60
       */
      autoSaveIntervalSeconds: number;
      /**
       * @description Maximum actors of this category per pool node
       * @default 100
       */
      maxInstancesPerNode: number;
      /**
       * @description Cognition template ID for this actor type. Primary source for cognition
       *     pipeline resolution. When null, falls back to ABML metadata, then category default.
       *     Examples: "humanoid-cognition-base", "creature-cognition-base", "object-cognition-base"
       */
      cognitionTemplateId?: string | null;
      /** @description Static template-level cognition overrides (polymorphic JSON). Deserialized internally to CognitionOverrides type with discriminated subtypes. Applied as the first layer in the three-layer override composition (template, instance, ABML metadata). Structure defined by ICognitionOverride interface hierarchy in bannou-service/Behavior/. No Bannou plugin reads specific keys from this field by convention. */
      cognitionOverrides?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to create a point-in-time snapshot of namespace documentation */
    CreateArchiveRequest: {
      /**
       * @description Owner of this archive. NOT a session ID.
       *     For user-initiated archives: the accountId (UUID format).
       *     For service-initiated archives: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Documentation namespace to archive */
      namespace: string;
      /** @description Optional description for the archive */
      description?: string;
    };
    /** @description Response containing the created archive details */
    CreateArchiveResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the created archive
       */
      archiveId: string;
      /** @description Namespace that was archived */
      namespace: string;
      /**
       * Format: uuid
       * @description Asset ID in Asset Service
       */
      bundleAssetId?: string;
      /** @description Number of documents in the archive */
      documentCount?: number;
      /** @description Total size of the archive in bytes */
      sizeBytes?: number;
      /**
       * Format: date-time
       * @description Timestamp when the archive was created
       */
      createdAt?: string;
      /** @description Git commit hash if namespace is bound */
      commitHash?: string | null;
    };
    /** @description Request to create a board instance for an owner entity */
    CreateBoardRequest: {
      /** @description Type of entity that owns this board (e.g., character, account, realm, guild) */
      ownerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the entity that owns this board
       */
      ownerId: string;
      /**
       * Format: uuid
       * @description Board template to instantiate
       */
      boardTemplateId: string;
      /**
       * Format: uuid
       * @description Game service context for validation
       */
      gameServiceId: string;
      /**
       * Format: uuid
       * @description Realm context for item creation. Required for character owners (validated against character realm). For realm owners, must equal ownerId. Null for realm-agnostic boards.
       */
      realmId?: string | null;
    };
    /** @description Request to create a new board template */
    CreateBoardTemplateRequest: {
      /**
       * Format: uuid
       * @description Game service this board template belongs to
       */
      gameServiceId: string;
      /** @description Display name for the board template */
      name: string;
      /** @description Human-readable description of this board template */
      description?: string | null;
      /** @description Width of the board grid (columns) */
      gridWidth: number;
      /** @description Height of the board grid (rows) */
      gridHeight: number;
      /** @description Grid positions where unlocking can begin without adjacency */
      startingNodes: components['schemas']['GridPosition'][];
      /**
       * Format: uuid
       * @description Contract template that controls unlock behavior (LP deduction, ability grants)
       */
      boardContractTemplateId: string;
      /** @description Grid traversal mode. Defaults to eight_way if not specified. */
      adjacencyMode?: components['schemas']['AdjacencyMode'] | null;
      /** @description Owner types allowed to create boards from this template. Each must map to a supported container owner type (e.g., character, account, location, guild). */
      allowedOwnerTypes: components['schemas']['EntityType'][];
    };
    /** @description Request to create a new asset bundle from multiple assets */
    CreateBundleRequest: {
      /**
       * @description Owner of this bundle. NOT a session ID.
       *     For user-initiated bundles: the accountId (UUID format).
       *     For service-initiated bundles: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Human-readable bundle identifier (e.g., "synty/polygon-adventure", "my-bundle-v1") */
      bundleId: string;
      /**
       * @description Bundle version string
       * @default 1.0.0
       */
      version: string;
      /**
       * @description Game realm this bundle belongs to.
       *     Defaults to 'shared' if not specified.
       */
      realm?: components['schemas']['GameRealm'] | null;
      /** @description List of asset IDs to include in the bundle */
      assetIds: string[];
      /** @description Compression algorithm to use for the bundle */
      compression?: components['schemas']['CompressionType'];
      /** @description Custom metadata for the bundle (null if none). No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response with bundle creation status and estimated size */
    CreateBundleResponse: {
      /** @description Human-readable bundle identifier (e.g., "synty/polygon-adventure", "my-bundle-v1") */
      bundleId: string;
      /**
       * @description Bundle creation status
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed';
      /**
       * Format: int64
       * @description Estimated bundle size in bytes
       */
      estimatedSize: number;
    };
    /** @description Request to create a collection for an owner */
    CreateCollectionRequest: {
      /**
       * Format: uuid
       * @description Entity that owns this collection
       */
      ownerId: string;
      /** @description Entity type discriminator */
      ownerType: components['schemas']['EntityType'];
      /** @description Type of collection to create */
      collectionType: components['schemas']['CollectionType'];
      /**
       * Format: uuid
       * @description Game service this collection is scoped to
       */
      gameServiceId: string;
    };
    /** @description Request to create a new container */
    CreateContainerRequest: {
      /**
       * Format: uuid
       * @description ID of the entity that owns this container
       */
      ownerId: string;
      /** @description Type of the owning entity */
      ownerType: components['schemas']['ContainerOwnerType'];
      /** @description Game-defined container type (e.g., inventory, bank, equipment_slot) */
      containerType: string;
      /** @description Capacity constraint model */
      constraintModel: components['schemas']['ContainerConstraintModel'];
      /**
       * @description Whether this container is an equipment slot
       * @default false
       */
      isEquipmentSlot: boolean;
      /** @description Equipment slot name if isEquipmentSlot is true */
      equipmentSlotName?: string | null;
      /** @description Maximum slots for slot-based containers */
      maxSlots?: number | null;
      /**
       * Format: double
       * @description Maximum weight capacity
       */
      maxWeight?: number | null;
      /** @description Internal grid width for grid containers */
      gridWidth?: number | null;
      /** @description Internal grid height for grid containers */
      gridHeight?: number | null;
      /**
       * Format: double
       * @description Maximum volume for volumetric containers
       */
      maxVolume?: number | null;
      /**
       * Format: uuid
       * @description Parent container ID for nested containers
       */
      parentContainerId?: string | null;
      /**
       * @description Whether this container can hold other containers
       * @default false
       */
      canContainContainers: boolean;
      /** @description Maximum nesting depth (null uses global default) */
      maxNestingDepth?: number | null;
      /**
       * Format: double
       * @description Empty container weight
       * @default 0
       */
      selfWeight: number;
      /** @description How weight propagates to parent */
      weightContribution?: components['schemas']['WeightContribution'];
      /**
       * @description Slots used in slot-based parent
       * @default 1
       */
      slotCost: number;
      /** @description Width footprint in grid-based parent */
      parentGridWidth?: number | null;
      /** @description Height footprint in grid-based parent */
      parentGridHeight?: number | null;
      /**
       * Format: double
       * @description Volume footprint in volumetric parent
       */
      parentVolume?: number | null;
      /** @description Allowed item categories (null allows all) */
      allowedCategories?: string[] | null;
      /** @description Forbidden item categories */
      forbiddenCategories?: string[] | null;
      /** @description Required item tags for placement */
      allowedTags?: string[] | null;
      /**
       * Format: uuid
       * @description Realm this container belongs to (null for account-level)
       */
      realmId?: string | null;
      /** @description Container tags for filtering */
      tags?: string[] | null;
      /** @description Game-specific container data. Client-only metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to create a contract instance */
    CreateContractInstanceRequest: {
      /**
       * Format: uuid
       * @description Template to create instance from
       */
      templateId: string;
      /** @description Parties to this contract */
      parties: components['schemas']['ContractPartyInput'][];
      /** @description Terms overriding template defaults */
      terms?: components['schemas']['ContractTerms'];
      /**
       * Format: date-time
       * @description When contract becomes active (null for immediate)
       */
      effectiveFrom?: string | null;
      /**
       * Format: date-time
       * @description When contract expires (null for perpetual)
       */
      effectiveUntil?: string | null;
      /** @description Related escrow IDs */
      escrowIds?: string[] | null;
      /** @description Client-only game metadata. No Bannou plugin reads specific keys from this field by convention. */
      gameMetadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to create a map definition */
    CreateDefinitionRequest: {
      /** @description Human-readable name */
      name: string;
      /** @description Description of the map template */
      description?: string | null;
      /** @description Layer configurations */
      layers?: components['schemas']['LayerDefinition'][] | null;
      /** @description Default bounds for regions using this definition */
      defaultBounds?: components['schemas']['Bounds'];
      /** @description Client-provided definition metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to create a new deity entity */
    CreateDeityRequest: {
      /**
       * Format: uuid
       * @description Game service this deity belongs to
       */
      gameServiceId: string;
      /** @description Unique code for this deity within the game service (e.g., mnemosyne, nexius) */
      code: string;
      /** @description Human-readable display name */
      displayName: string;
      /** @description Description of the deity's nature and role */
      description: string;
      /** @description Domain influences (at least one required) */
      domains: components['schemas']['DomainInfluence'][];
      /** @description Personality traits influencing behavior decisions */
      personalityTraits: components['schemas']['DeityPersonalityTraits'];
      /**
       * @description Maximum characters this deity can actively monitor simultaneously
       * @default 10
       */
      maxAttentionSlots: number;
      /**
       * Format: uuid
       * @description Home realm for this deity (null if not realm-bound)
       */
      realmId?: string | null;
    };
    /** @description Request to create a new entry template */
    CreateEntryTemplateRequest: {
      /** @description Unique code within this collection type and game service */
      code: string;
      /** @description Type of collection this entry belongs to */
      collectionType: components['schemas']['CollectionType'];
      /**
       * Format: uuid
       * @description Game service this entry template is scoped to
       */
      gameServiceId: string;
      /** @description Human-readable display name for this entry */
      displayName: string;
      /** @description Category within the collection type (e.g., boss, ambient, battle) */
      category?: string | null;
      /** @description Searchable tags for filtering entries */
      tags?: string[] | null;
      /** @description Primary asset identifier for this entry (audio, video, image) */
      assetId?: string | null;
      /** @description Thumbnail or preview asset identifier */
      thumbnailAssetId?: string | null;
      /** @description Hint text shown to users about how to unlock this entry */
      unlockHint?: string | null;
      /**
       * @description Whether this entry should be hidden from users until unlocked (spoiler protection)
       * @default false
       */
      hideWhenLocked: boolean;
      /**
       * Format: uuid
       * @description Item template used when granting this entry to a collection
       */
      itemTemplateId: string;
      /** @description Progressive discovery levels for bestiary-style entries */
      discoveryLevels?: components['schemas']['DiscoveryLevel'][] | null;
      /** @description Theme tags for content selection matching (e.g., battle, peaceful, forest) */
      themes?: string[] | null;
      /** @description Duration of the content (ISO 8601 duration or human-readable) */
      duration?: string | null;
      /** @description Loop point for seamless playback (ISO 8601 duration or timestamp) */
      loopPoint?: string | null;
      /** @description Composer or creator name */
      composer?: string | null;
    };
    /** @description Input for defining a party in escrow creation */
    CreateEscrowPartyInput: {
      /**
       * Format: uuid
       * @description Party entity ID
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Display name */
      displayName?: string | null;
      /** @description Role of this party in the escrow */
      role: components['schemas']['EscrowPartyRole'];
      /** @description Whether consent is required (defaults based on role) */
      consentRequired?: boolean | null;
      /**
       * Format: uuid
       * @description Party wallet for currency operations
       */
      walletId?: string | null;
      /**
       * Format: uuid
       * @description Party container for item operations
       */
      containerId?: string | null;
    };
    /** @description Request to create a new escrow agreement */
    CreateEscrowRequest: {
      /** @description Type of escrow agreement */
      escrowType: components['schemas']['EscrowType'];
      /** @description Trust mode for the escrow */
      trustMode: components['schemas']['EscrowTrustMode'];
      /**
       * Format: uuid
       * @description For single_party_trusted mode
       */
      trustedPartyId?: string | null;
      /** @description Type of the trusted party */
      trustedPartyType?: components['schemas']['EntityType'] | null;
      /** @description Parties in the escrow */
      parties: components['schemas']['CreateEscrowPartyInput'][];
      /** @description Expected deposits from parties */
      expectedDeposits: components['schemas']['ExpectedDepositInput'][];
      /** @description Optional explicit release allocations */
      releaseAllocations?: components['schemas']['ReleaseAllocationInput'][] | null;
      /**
       * Format: uuid
       * @description Contract governing this escrow
       */
      boundContractId?: string | null;
      /** @description Number of consents required (-1 for all) */
      requiredConsentsForRelease?: number | null;
      /**
       * Format: date-time
       * @description Optional expiration time
       */
      expiresAt?: string | null;
      /** @description Reference type (trade, auction, etc.) */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference entity ID
       */
      referenceId?: string | null;
      /** @description Human-readable description */
      description?: string | null;
      /** @description Client-provided application-specific metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * @description How release confirmation is handled. Defaults to service_only if not specified.
       *     Only applies to unbound escrows; contract-bound escrows follow contract fulfillment.
       */
      releaseMode?: components['schemas']['ReleaseMode'] | null;
      /** @description How refund confirmation is handled. Defaults to immediate if not specified. */
      refundMode?: components['schemas']['RefundMode'] | null;
      /** @description Idempotency key for this operation */
      idempotencyKey: string;
    };
    /** @description Response from creating an escrow agreement */
    CreateEscrowResponse: {
      /** @description Created escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Deposit tokens for each party (full_consent mode) */
      depositTokens: components['schemas']['PartyToken'][];
    };
    /** @description Request to create a new faction */
    CreateFactionRequest: {
      /**
       * Format: uuid
       * @description Game service to scope this faction to
       */
      gameServiceId: string;
      /** @description Display name for the faction */
      name: string;
      /** @description Unique code within the game service (e.g., "thieves_guild") */
      code: string;
      /** @description Human-readable description of the faction */
      description?: string | null;
      /**
       * Format: uuid
       * @description Realm this faction belongs to
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Parent faction for hierarchy (null for top-level)
       */
      parentFactionId?: string | null;
    };
    /** @description Request to create an authorization hold */
    CreateHoldRequest: {
      /**
       * Format: uuid
       * @description Wallet to hold funds in
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to hold
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to reserve
       */
      amount: number;
      /**
       * Format: date-time
       * @description When the hold auto-releases
       */
      expiresAt: string;
      /** @description Reference type (e.g. dining, hotel, gas) */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference entity ID
       */
      referenceId?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Request to create a new item instance */
    CreateItemInstanceRequest: {
      /**
       * Format: uuid
       * @description Template to instantiate
       */
      templateId: string;
      /**
       * Format: uuid
       * @description Container to place the item in
       */
      containerId: string;
      /**
       * Format: uuid
       * @description Realm this instance exists in
       */
      realmId: string;
      /**
       * Format: double
       * @description Item quantity (respects template's quantityModel)
       */
      quantity: number;
      /** @description Slot position in slot-based containers */
      slotIndex?: number | null;
      /** @description X position in grid-based containers */
      slotX?: number | null;
      /** @description Y position in grid-based containers */
      slotY?: number | null;
      /** @description Whether item is rotated in grid */
      rotated?: boolean | null;
      /** @description Initial durability (defaults to template's maxDurability) */
      currentDurability?: number | null;
      /** @description Instance-specific stat modifications. Opaque to Bannou; no plugin reads keys by convention. */
      customStats?: Record<string, never> | null;
      /** @description Player-assigned custom name */
      customName?: string | null;
      /** @description Additional instance-specific data. Opaque to Bannou; no plugin reads keys by convention. */
      instanceMetadata?: Record<string, never> | null;
      /** @description How this item instance was created */
      originType: components['schemas']['ItemOriginType'];
      /**
       * Format: uuid
       * @description Source entity ID (quest ID, creature ID, etc.)
       */
      originId?: string | null;
      /**
       * Format: uuid
       * @description Bound contract instance ID. For persistent item-contract bindings (status effects,
       *     licenses, memberships), this references the controlling contract. NULL for items
       *     without persistent contract relationships.
       */
      contractInstanceId?: string | null;
      /**
       * @description Type of contract binding. When contractInstanceId is provided, this indicates
       *     whether it's a lifecycle binding (managed externally) or session binding
       *     (managed by Item service). Defaults to 'lifecycle' when contractInstanceId is set.
       */
      contractBindingType?: components['schemas']['ContractBindingType'];
    };
    /** @description Request to create a new item template */
    CreateItemTemplateRequest: {
      /** @description Unique code within the game (immutable after creation) */
      code: string;
      /** @description Game service this template belongs to (immutable after creation) */
      gameId: string;
      /** @description Human-readable display name */
      name: string;
      /** @description Detailed description of this item */
      description?: string | null;
      /** @description Item classification category */
      category: components['schemas']['ItemCategory'];
      /** @description Game-defined subcategory (e.g., sword, helmet) */
      subcategory?: string | null;
      /** @description Flexible filtering tags */
      tags?: string[] | null;
      /** @description Item rarity tier (defaults to config when not specified) */
      rarity?: components['schemas']['ItemRarity'];
      /** @description How quantities are tracked for this item */
      quantityModel: components['schemas']['QuantityModel'];
      /** @description Maximum stack size (1 for unique items) */
      maxStackSize: number;
      /** @description Unit for continuous quantities (e.g., liters, kg) */
      unitOfMeasure?: string | null;
      /** @description Precision for weight values (defaults to config when not specified) */
      weightPrecision?: components['schemas']['WeightPrecision'];
      /**
       * Format: double
       * @description Weight value (interpreted per weightPrecision)
       */
      weight?: number | null;
      /**
       * Format: double
       * @description Volume for volumetric inventories
       */
      volume?: number | null;
      /** @description Width in grid-based inventories */
      gridWidth?: number | null;
      /** @description Height in grid-based inventories */
      gridHeight?: number | null;
      /** @description Whether item can be rotated in grid */
      canRotate?: boolean | null;
      /**
       * Format: double
       * @description Reference price for vendors/markets
       */
      baseValue?: number | null;
      /**
       * @description Whether item can be traded/auctioned
       * @default true
       */
      tradeable: boolean;
      /**
       * @description Whether item can be destroyed/discarded
       * @default true
       */
      destroyable: boolean;
      /** @description Binding behavior when item is acquired (defaults to config when not specified) */
      soulboundType?: components['schemas']['SoulboundType'];
      /**
       * @description Whether item has durability tracking
       * @default false
       */
      hasDurability: boolean;
      /** @description Maximum durability value */
      maxDurability?: number | null;
      /** @description Realm availability scope */
      scope: components['schemas']['ItemScope'];
      /** @description Realm IDs where this template is available (for realm_specific or multi_realm) */
      availableRealms?: string[] | null;
      /** @description Game-defined stats (e.g., attack, defense). Opaque to Bannou; no plugin reads keys by convention. */
      stats?: Record<string, never> | null;
      /** @description Game-defined effects (e.g., on_use, on_equip). Opaque to Bannou; no plugin reads keys by convention. */
      effects?: Record<string, never> | null;
      /** @description Game-defined requirements (e.g., level, strength). Opaque to Bannou; no plugin reads keys by convention. */
      requirements?: Record<string, never> | null;
      /** @description Display properties (e.g., iconId, modelId). Opaque to Bannou; no plugin reads keys by convention. */
      display?: Record<string, never> | null;
      /** @description Additional game-specific data. Opaque to Bannou; no plugin reads keys by convention. */
      metadata?: Record<string, never> | null;
      /**
       * Format: uuid
       * @description Contract template ID for executable item behavior. When set, the item can be "used" via /item/use, which creates a transient contract instance, completes its "use" milestone (triggering prebound APIs), and optionally consumes the item.
       */
      useBehaviorContractTemplateId?: string | null;
      /**
       * Format: uuid
       * @description Contract template for pre-use validation. When set, /item/use first executes
       *     this contract's "validate" milestone before proceeding. If validation fails,
       *     the item is NOT consumed and the main use behavior is NOT executed.
       */
      canUseBehaviorContractTemplateId?: string | null;
      /**
       * Format: uuid
       * @description Contract template executed when the main use behavior fails. Enables cleanup,
       *     partial rollback, or consequence application. Item is NOT consumed on failure
       *     regardless of this template's outcome.
       */
      onUseFailedBehaviorContractTemplateId?: string | null;
      /** @description How the item should behave when used (defaults to destroy_on_success) */
      itemUseBehavior?: components['schemas']['ItemUseBehavior'];
      /** @description How CanUse validation failures should be handled (defaults to block) */
      canUseBehavior?: components['schemas']['CanUseBehavior'];
    };
    /** @description Request to create a new leaderboard */
    CreateLeaderboardDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service owning this leaderboard
       */
      gameServiceId: string;
      /** @description Unique identifier for this leaderboard (lowercase, no spaces) */
      leaderboardId: string;
      /** @description Human-readable name for the leaderboard */
      displayName: string;
      /** @description Description of what this leaderboard tracks */
      description?: string | null;
      /** @description Which entity types can appear on this leaderboard */
      entityTypes?: components['schemas']['EntityType'][];
      /**
       * @description Sort order (descending for high scores, ascending for times)
       * @default descending
       */
      sortOrder: components['schemas']['SortOrder'];
      /**
       * @description How to handle score updates
       * @default replace
       */
      updateMode: components['schemas']['UpdateMode'];
      /**
       * @description Whether this leaderboard resets each season
       * @default false
       */
      isSeasonal: boolean;
      /**
       * @description Whether the leaderboard is publicly visible
       * @default true
       */
      isPublic: boolean;
      /** @description Client-provided leaderboard-specific metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Request to create a metabundle from source bundles and/or standalone assets.
     *     At least one of sourceBundleIds or standaloneAssetIds must be provided.
     *     This enables packaging behaviors/scripts with 3D assets as a complete unit.
     */
    CreateMetabundleRequest: {
      /** @description Human-readable identifier for the new metabundle (e.g., "game-assets-v1") */
      metabundleId: string;
      /**
       * @description Human-readable source bundle IDs (e.g., "synty/polygon-adventure") to pull assets from.
       *     Can cherry-pick specific assets using assetFilter, or include all if assetFilter is null.
       */
      sourceBundleIds?: string[] | null;
      /**
       * @description Individual asset IDs (not in bundles) to include directly.
       *     Useful for including behaviors, scripts, or metadata files
       *     alongside bundled 3D assets.
       */
      standaloneAssetIds?: string[] | null;
      /**
       * @description Metabundle version string
       * @default 1.0.0
       */
      version: string;
      /**
       * @description Owner of this metabundle. NOT a session ID.
       *     For user-initiated: the accountId (UUID format).
       *     For service-initiated: the service name.
       */
      owner: string;
      /** @description Game realm for this metabundle */
      realm: components['schemas']['GameRealm'];
      /** @description Human-readable description */
      description?: string | null;
      /**
       * @description Optional subset of asset IDs to include FROM SOURCE BUNDLES.
       *     If null, all assets from source bundles are included.
       *     Standalone assets are always included regardless of this filter.
       */
      assetFilter?: string[] | null;
      /** @description Custom metadata for the metabundle. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Response from metabundle creation.
     *     For synchronous creation (small jobs): status=ready with downloadUrl.
     *     For async creation (large jobs): status=queued with jobId for polling.
     */
    CreateMetabundleResponse: {
      /** @description Human-readable metabundle identifier */
      metabundleId: string;
      /**
       * Format: uuid
       * @description Job ID for async processing. Only present when status is 'queued' or 'processing'.
       *     Use /bundles/job/status to poll for completion, or wait for
       *     MetabundleCreationCompleteEvent via WebSocket.
       */
      jobId?: string | null;
      /**
       * @description Creation status.
       *     - queued: Job accepted for async processing (poll with jobId)
       *     - processing: Job is actively running
       *     - ready: Metabundle created and available for download
       *     - failed: Creation failed (see conflicts for details)
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed';
      /**
       * Format: uri
       * @description Pre-signed download URL (only present when status is 'ready')
       */
      downloadUrl?: string | null;
      /** @description Number of assets in the metabundle */
      assetCount: number;
      /** @description Number of standalone assets included directly (not from bundles) */
      standaloneAssetCount?: number | null;
      /**
       * Format: int64
       * @description Total size in bytes
       */
      sizeBytes: number;
      /** @description Provenance data for the metabundle */
      sourceBundles?: components['schemas']['SourceBundleReference'][];
      /** @description Present if creation failed due to asset conflicts */
      conflicts?: components['schemas']['AssetConflict'][] | null;
    };
    /** @description Request to create a new quest definition with objectives and rewards */
    CreateQuestDefinitionRequest: {
      /** @description Unique quest code (uppercase, underscores) */
      code: string;
      /** @description Display name of the quest */
      name: string;
      /** @description Quest description for players */
      description?: string | null;
      /** @description Quest category for organization */
      category?: components['schemas']['QuestCategory'];
      /** @description Difficulty rating of the quest */
      difficulty?: components['schemas']['QuestDifficulty'];
      /** @description Minimum character level required */
      levelRequirement?: number | null;
      /**
       * @description Whether quest can be repeated
       * @default false
       */
      repeatable: boolean;
      /** @description Cooldown in seconds for repeatable quests */
      cooldownSeconds?: number | null;
      /** @description Time limit in seconds (null for no deadline) */
      deadlineSeconds?: number | null;
      /**
       * @description Maximum party members (1 for solo)
       * @default 1
       */
      maxQuestors: number;
      /** @description List of quest objectives (ordered) */
      objectives: components['schemas']['ObjectiveDefinition'][];
      /** @description Requirements to accept the quest */
      prerequisites?: components['schemas']['PrerequisiteDefinition'][] | null;
      /** @description Rewards granted on completion */
      rewards?: components['schemas']['RewardDefinition'][] | null;
      /** @description Tags for filtering and organization */
      tags?: string[] | null;
      /**
       * Format: uuid
       * @description Character who offers this quest (null for any)
       */
      questGiverCharacterId?: string | null;
      /**
       * Format: uuid
       * @description Game service this quest belongs to
       */
      gameServiceId?: string;
    };
    /** @description Request to create a new chat room */
    CreateRoomRequest: {
      /** @description Room type code determining message format and validation */
      roomTypeCode: string;
      /**
       * Format: uuid
       * @description Connect session ID for companion rooms
       */
      sessionId?: string | null;
      /**
       * Format: uuid
       * @description Governing contract ID for lifecycle management
       */
      contractId?: string | null;
      /** @description Human-readable room name */
      displayName?: string | null;
      /** @description Participant limit override (null uses type default) */
      maxParticipants?: number | null;
      /** @description Action when governing contract is fulfilled (null uses service default) */
      contractFulfilledAction?: components['schemas']['ContractRoomAction'] | null;
      /** @description Action when governing contract is breached (null uses service default) */
      contractBreachAction?: components['schemas']['ContractRoomAction'] | null;
      /** @description Action when governing contract is terminated (null uses service default) */
      contractTerminatedAction?: components['schemas']['ContractRoomAction'] | null;
      /** @description Action when governing contract expires (null uses service default) */
      contractExpiredAction?: components['schemas']['ContractRoomAction'] | null;
      /** @description Client-only metadata stored as JSON string. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: string | null;
    };
    /** @description Request to create a scenario definition */
    CreateScenarioDefinitionRequest: {
      /** @description Human-readable scenario code (uppercase with underscores) */
      code: string;
      /** @description Display name for the scenario */
      name: string;
      /** @description Detailed scenario description */
      description?: string | null;
      /** @description Conditions that must ALL be met to trigger */
      triggerConditions: components['schemas']['TriggerCondition'][];
      /** @description Execution phases in order */
      phases: components['schemas']['ScenarioPhase'][];
      /** @description State mutations to apply on completion */
      mutations?: components['schemas']['ScenarioMutation'][] | null;
      /** @description Quests to spawn on completion */
      questHooks?: components['schemas']['ScenarioQuestHook'][] | null;
      /** @description Per-character cooldown in seconds */
      cooldownSeconds?: number | null;
      /** @description Tags for mutual exclusivity checking */
      exclusivityTags?: string[] | null;
      /**
       * @description Higher priority scenarios are checked first
       * @default 0
       */
      priority: number;
      /**
       * @description Whether scenario can be triggered
       * @default true
       */
      enabled: boolean;
      /**
       * Format: uuid
       * @description Realm scope (null means all realms)
       */
      realmId?: string | null;
      /**
       * Format: uuid
       * @description Game service scope (null means all games)
       */
      gameServiceId?: string | null;
      /** @description Classification tags for filtering */
      tags?: string[] | null;
    };
    /** @description Request to create a new scene */
    CreateSceneRequest: {
      /** @description The scene document to create */
      scene: components['schemas']['Scene'];
    };
    /** @description Request to create a new seed. */
    CreateSeedRequest: {
      /**
       * Format: uuid
       * @description The entity that owns this seed.
       */
      ownerId: string;
      /** @description Owner entity type discriminator. */
      ownerType: components['schemas']['EntityType'];
      /** @description Registered seed type code (e.g., "guardian", "dungeon_core"). */
      seedTypeCode: string;
      /**
       * Format: uuid
       * @description Game service this seed is scoped to. Null for cross-game seed types that are not scoped to any single game service.
       */
      gameServiceId?: string | null;
      /** @description Human-readable name. Auto-generated if omitted. */
      displayName?: string | null;
      /** @description Client-provided seed-type-specific initial data. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to create a new save slot for an entity. */
    CreateSlotRequest: {
      /** @description Game identifier for namespace isolation (e.g., "game-1", "game-2") */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Slot name (lowercase alphanumeric with hyphens, single char like "q" allowed) */
      slotName: string;
      /** @description Save category determining retention and cleanup behavior */
      category: components['schemas']['SaveCategory'];
      /** @description Override default max versions for this category (null = use category default) */
      maxVersions?: number | null;
      /** @description Days to retain versions (null = indefinite) */
      retentionDays?: number | null;
      /** @description Compression algorithm to use for save data (null = use category default) */
      compressionType?: components['schemas']['CompressionType'] | null;
      /** @description Searchable tags for slot categorization (e.g., "boss-fight", "chapter-3") */
      tags?: string[] | null;
      /** @description Custom key-value metadata for the slot */
      metadata?: {
        [key: string]: string;
      } | null;
    };
    /** @description Request to create a new status template */
    CreateStatusTemplateRequest: {
      /**
       * Format: uuid
       * @description Game service this template is scoped to
       */
      gameServiceId: string;
      /** @description Unique status code within this game service */
      code: string;
      /** @description Human-readable display name for this status effect */
      displayName: string;
      /** @description Detailed description of what this status effect does */
      description: string;
      /** @description Classification of this status effect */
      category: components['schemas']['StatusCategory'];
      /** @description Whether this status can stack (multiple applications) */
      stackable: boolean;
      /**
       * @description Maximum number of stacks when stackable is true
       * @default 1
       */
      maxStacks: number;
      /** @description How multiple applications interact (defaults to ignore) */
      stackBehavior?: components['schemas']['StackBehavior'];
      /**
       * Format: uuid
       * @description Contract template for lifecycle management (null for simple TTL statuses). When set, granting this status creates a contract instance with milestones matching the template's defined structure. The contract template should define milestones for status lifecycle phases (e.g., activation, expiration). Template values receive the grant request's metadata map, allowing callers to parameterize contract behavior per grant.
       */
      contractTemplateId?: string | null;
      /**
       * Format: uuid
       * @description Item template used when granting this status as an inventory item
       */
      itemTemplateId: string;
      /** @description Default duration in seconds for non-contract TTL management (null for permanent) */
      defaultDurationSeconds?: number | null;
      /**
       * Format: uuid
       * @description Asset identifier for this status effect's icon
       */
      iconAssetId?: string | null;
    };
    /** @description Request to create a scenario template */
    CreateTemplateRequest: {
      /** @description Unique template code for reference */
      code: string;
      /** @description Human-readable template name */
      displayName: string;
      /** @description Template description */
      description: string;
      /** @description Primary gameplay category */
      category: components['schemas']['ScenarioCategory'];
      /** @description Optional subcategory within the primary category */
      subcategory?: string | null;
      /** @description Growth domain weights awarded on completion */
      domainWeights: components['schemas']['DomainWeight'][];
      /** @description Minimum seed growth phase for soft-gating scenario availability */
      minGrowthPhase?: string | null;
      /**
       * @description How this scenario connects to the game world
       * @default Isolated
       */
      connectivityMode: components['schemas']['ConnectivityMode'];
      /** @description Deployment phases in which this template is available. Null or empty means available in all phases. */
      allowedPhases?: components['schemas']['DeploymentPhase'][] | null;
      /**
       * @description Maximum concurrent active instances of this template
       * @default 100
       */
      maxConcurrentInstances: number;
      /** @description Estimated scenario duration in minutes */
      estimatedDurationMinutes?: number | null;
      /** @description Requirements that must be met before entering */
      prerequisites?: components['schemas']['ScenarioPrerequisites'];
      /** @description Chaining configuration */
      chaining?: components['schemas']['ScenarioChaining'];
      /** @description Multiplayer support configuration */
      multiplayer?: components['schemas']['ScenarioMultiplayer'];
      /** @description Game content references */
      content?: components['schemas']['ScenarioContent'];
    };
    /** @description Request to create a new wallet */
    CreateWalletRequest: {
      /**
       * Format: uuid
       * @description Owner entity ID
       */
      ownerId: string;
      /** @description Type of owner entity */
      ownerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Realm ID for realm-scoped wallets (null for global)
       */
      realmId?: string | null;
    };
    /** @description Request to credit currency to a wallet */
    CreditCurrencyRequest: {
      /**
       * Format: uuid
       * @description Target wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to credit
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to credit (must be positive)
       */
      amount: number;
      /** @description Must be a faucet type (mint, quest_reward, loot_drop, etc.) */
      transactionType: components['schemas']['TransactionType'];
      /** @description What triggered this transaction (quest, admin, etc.) */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference entity ID
       */
      referenceId?: string | null;
      /** @description Unique key to prevent duplicate processing */
      idempotencyKey: string;
      /**
       * @description Skip earn cap enforcement (admin use)
       * @default false
       */
      bypassEarnCap: boolean;
      /** @description Free-form transaction metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Result of credit operation */
    CreditCurrencyResponse: {
      /** @description Created transaction record */
      transaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Balance after credit
       */
      newBalance: number;
      /** @description Whether earn cap limited the credit */
      earnCapApplied: boolean;
      /**
       * Format: double
       * @description Amount reduced by earn cap
       */
      earnCapAmountLimited?: number | null;
      /** @description Whether wallet cap limited the credit */
      walletCapApplied: boolean;
      /**
       * Format: double
       * @description Amount lost due to wallet cap (cap_and_lose behavior)
       */
      walletCapAmountLost?: number | null;
    };
    /** @description Request to credit divinity to a deity's wallet */
    CreditDivinityRequest: {
      /**
       * Format: uuid
       * @description Deity to credit
       */
      deityId: string;
      /**
       * Format: double
       * @description Amount of divinity to credit (must be positive)
       */
      amount: number;
      /** @description Source of the divinity gain (e.g., mortal_action, domain_event, manual) */
      source: string;
      /**
       * Format: uuid
       * @description Triggering event identifier if applicable
       */
      sourceEventId?: string | null;
      /** @description Human-readable description of the credit reason */
      description?: string | null;
    };
    /** @description Request to cure a breach */
    CureBreachRequest: {
      /**
       * Format: uuid
       * @description Breach to cure
       */
      breachId: string;
      /** @description Evidence of cure */
      cureEvidence?: string | null;
    };
    /** @description Currency definition details */
    CurrencyDefinitionResponse: {
      /**
       * Format: uuid
       * @description Unique definition identifier
       */
      definitionId: string;
      /** @description Unique currency code */
      code: string;
      /** @description Human-readable name */
      name: string;
      /** @description Detailed description */
      description?: string | null;
      /** @description Realm availability scope */
      scope: components['schemas']['CurrencyScope'];
      /** @description Available realm IDs */
      realmsAvailable?: string[] | null;
      /** @description Decimal precision */
      precision: components['schemas']['CurrencyPrecision'];
      /** @description Whether transferable between wallets */
      transferable: boolean;
      /** @description Whether usable in trades */
      tradeable: boolean;
      /** @description Whether negative balance allowed (null uses plugin default) */
      allowNegative?: boolean | null;
      /**
       * Format: double
       * @description Maximum per-wallet balance
       */
      perWalletCap?: number | null;
      /** @description Overflow behavior when cap exceeded */
      capOverflowBehavior?: components['schemas']['CapOverflowBehavior'];
      /**
       * Format: double
       * @description Global supply cap
       */
      globalSupplyCap?: number | null;
      /**
       * Format: double
       * @description Daily earn cap
       */
      dailyEarnCap?: number | null;
      /**
       * Format: double
       * @description Weekly earn cap
       */
      weeklyEarnCap?: number | null;
      /** @description Earn cap reset time */
      earnCapResetTime?: string | null;
      /** @description Whether autogain is enabled */
      autogainEnabled: boolean;
      /** @description Autogain calculation mode */
      autogainMode?: components['schemas']['AutogainMode'];
      /**
       * Format: double
       * @description Autogain amount per interval
       */
      autogainAmount?: number | null;
      /** @description Autogain interval duration */
      autogainInterval?: string | null;
      /**
       * Format: double
       * @description Autogain balance cap
       */
      autogainCap?: number | null;
      /** @description Whether currency can expire */
      expires: boolean;
      /** @description Expiration policy */
      expirationPolicy?: components['schemas']['ExpirationPolicy'];
      /**
       * Format: date-time
       * @description Fixed expiration date
       */
      expirationDate?: string | null;
      /** @description Expiration duration */
      expirationDuration?: string | null;
      /**
       * Format: uuid
       * @description Season ID for expiration
       */
      seasonId?: string | null;
      /** @description Whether linked to inventory item */
      linkedToItem: boolean;
      /**
       * Format: uuid
       * @description Linked item template ID
       */
      linkedItemTemplateId?: string | null;
      /** @description Item linkage mode */
      linkageMode?: components['schemas']['ItemLinkageMode'];
      /** @description Whether this is the base currency */
      isBaseCurrency: boolean;
      /**
       * Format: double
       * @description Exchange rate to base currency
       */
      exchangeRateToBase?: number | null;
      /**
       * Format: date-time
       * @description When exchange rate was last updated
       */
      exchangeRateUpdatedAt?: string | null;
      /**
       * Format: uuid
       * @description Icon asset ID
       */
      iconAssetId?: string | null;
      /** @description Display format string */
      displayFormat?: string | null;
      /** @description Whether definition is active */
      isActive: boolean;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last modification timestamp
       */
      modifiedAt?: string | null;
    };
    /**
     * @description How the currency handles decimal values (immutable after creation)
     * @enum {string}
     */
    CurrencyPrecision:
      | 'integer'
      | 'decimal_2'
      | 'decimal_4'
      | 'decimal_8'
      | 'decimal_full'
      | 'big_integer';
    /**
     * @description Scope of currency availability across realms
     * @enum {string}
     */
    CurrencyScope: 'global' | 'realm_specific' | 'multi_realm';
    /** @description Immutable record of a currency transaction */
    CurrencyTransactionRecord: {
      /**
       * Format: uuid
       * @description Unique transaction identifier
       */
      transactionId: string;
      /**
       * Format: uuid
       * @description Source wallet (null for faucets)
       */
      sourceWalletId?: string | null;
      /**
       * Format: uuid
       * @description Target wallet (null for sinks)
       */
      targetWalletId?: string | null;
      /**
       * Format: uuid
       * @description Currency definition ID
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Transaction amount (always positive)
       */
      amount: number;
      /** @description Transaction classification */
      transactionType: components['schemas']['TransactionType'];
      /** @description What triggered this transaction */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference entity ID
       */
      referenceId?: string | null;
      /**
       * Format: uuid
       * @description Associated escrow ID
       */
      escrowId?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
      /**
       * Format: date-time
       * @description When transaction occurred
       */
      timestamp: string;
      /**
       * Format: double
       * @description Source balance before transaction
       */
      sourceBalanceBefore?: number | null;
      /**
       * Format: double
       * @description Source balance after transaction
       */
      sourceBalanceAfter?: number | null;
      /**
       * Format: double
       * @description Target balance before transaction
       */
      targetBalanceBefore?: number | null;
      /**
       * Format: double
       * @description Target balance after transaction
       */
      targetBalanceAfter?: number | null;
      /** @description Number of autogain periods applied */
      autogainPeriodsApplied?: number | null;
      /**
       * Format: double
       * @description Amount lost to cap overflow
       */
      overflowAmountLost?: number | null;
      /**
       * Format: double
       * @description Amount limited by earn cap
       */
      earnCapAmountLimited?: number | null;
      /** @description Free-form metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Custom affordance definition for novel scenarios */
    CustomAffordance: {
      /** @description Human-readable description of this affordance */
      description?: string | null;
      /** @description Game-specific required criteria for affordance matching. No Bannou plugin reads specific keys from this field by convention. */
      requires?: {
        [key: string]: unknown;
      } | null;
      /** @description Game-specific preferred criteria (boost score but not required). No Bannou plugin reads specific keys from this field by convention. */
      prefers?: {
        [key: string]: unknown;
      } | null;
      /** @description Game-specific exclusion criteria for affordance matching. No Bannou plugin reads specific keys from this field by convention. */
      excludes?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Custom script injection configuration for adding JavaScript to pages */
    CustomScripts: {
      /** @description Custom scripts to inject in the HTML head */
      head?: string | null;
      /** @description Custom scripts to inject at the start of the body */
      bodyStart?: string | null;
      /** @description Custom scripts to inject at the end of the body */
      bodyEnd?: string | null;
    };
    /** @description A named time-of-day period within a calendar template */
    DayPeriodDefinition: {
      /** @description Period identifier code (e.g., "dawn", "morning", "night") */
      code: string;
      /** @description Game hour this period begins (0 to gameHoursPerDay-1) */
      startHour: number;
      /** @description Game hour this period ends (exclusive, max = gameHoursPerDay) */
      endHour: number;
      /** @description True if this period has sunlight, used by ${world.time.is_day} and ${world.time.is_night} */
      isDaylight: boolean;
    };
    /** @description Request to deactivate an active deity */
    DeactivateDeityRequest: {
      /**
       * Format: uuid
       * @description Deity to deactivate
       */
      deityId: string;
    };
    /** @description Request to debit currency from a wallet */
    DebitCurrencyRequest: {
      /**
       * Format: uuid
       * @description Source wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to debit
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to debit (must be positive)
       */
      amount: number;
      /** @description Must be a sink type (burn, vendor_purchase, fee, etc.) */
      transactionType: components['schemas']['TransactionType'];
      /** @description What triggered this transaction */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference entity ID
       */
      referenceId?: string | null;
      /** @description Unique key to prevent duplicate processing */
      idempotencyKey: string;
      /** @description Override negative balance allowance for this transaction */
      allowNegative?: boolean | null;
      /** @description Free-form transaction metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Result of debit operation */
    DebitCurrencyResponse: {
      /** @description Created transaction record */
      transaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Balance after debit
       */
      newBalance: number;
    };
    /** @description Request to debit divinity from a deity's wallet */
    DebitDivinityRequest: {
      /**
       * Format: uuid
       * @description Deity to debit
       */
      deityId: string;
      /**
       * Format: double
       * @description Amount of divinity to debit (must be positive)
       */
      amount: number;
      /** @description Purpose of the expenditure (e.g., blessing_grant, miracle, intervention) */
      purpose: string;
      /**
       * Format: uuid
       * @description Target character if the expenditure is blessing-related
       */
      targetCharacterId?: string | null;
      /** @description Human-readable description of the debit reason */
      description?: string | null;
    };
    /** @description Request to decline a formed match */
    DeclineMatchRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the match to decline
       */
      matchId: string;
    };
    /** @description Request to decline a POI */
    DeclinePoiRequest: {
      /**
       * Format: uuid
       * @description Account declining the POI
       */
      accountId: string;
      /**
       * Format: uuid
       * @description POI to decline
       */
      poiId: string;
    };
    /** @description Response after declining a POI */
    DeclinePoiResponse: {
      /**
       * Format: uuid
       * @description POI that was declined
       */
      poiId: string;
      /** @description Whether the decline was processed */
      acknowledged: boolean;
    };
    /** @description Request to define a behavioral norm for a faction */
    DefineNormRequest: {
      /**
       * Format: uuid
       * @description Faction to define the norm for
       */
      factionId: string;
      /** @description Violation type code (e.g., "theft", "deception", "violence") */
      violationType: string;
      /**
       * Format: float
       * @description Base GOAP cost penalty for violating this norm
       */
      basePenalty: number;
      /** @description Enforcement intensity level */
      severity: components['schemas']['NormSeverity'];
      /** @description Whether norm applies to member-only or all interactions */
      scope: components['schemas']['NormScope'];
      /** @description Human-readable description of the norm */
      description?: string | null;
    };
    /** @description Machine-readable personality traits influencing deity behavior decisions */
    DeityPersonalityTraits: {
      /** @description Primary temperament descriptor (e.g., wrathful, benevolent, capricious) */
      temperament: string;
      /** @description What type of mortal actions draw this deity's attention (e.g., combat, devotion, craft) */
      attentionBias: string;
      /**
       * Format: double
       * @description How freely the deity grants blessings (0.0 miserly, 1.0 lavish)
       */
      generosity: number;
      /**
       * Format: double
       * @description How possessive the deity is of followers (0.0 tolerant, 1.0 vengeful)
       */
      jealousy: number;
    };
    /** @description Full deity entity response */
    DeityResponse: {
      /**
       * Format: uuid
       * @description Unique deity identifier
       */
      deityId: string;
      /**
       * Format: uuid
       * @description Game service this deity belongs to
       */
      gameServiceId: string;
      /** @description Unique code within the game service */
      code: string;
      /** @description Human-readable display name */
      displayName: string;
      /** @description Description of the deity */
      description: string;
      /** @description Domain influences */
      domains: components['schemas']['DomainInfluence'][];
      /** @description Personality traits */
      personalityTraits: components['schemas']['DeityPersonalityTraits'];
      /** @description Maximum characters the deity can actively monitor */
      maxAttentionSlots: number;
      /**
       * Format: uuid
       * @description Associated actor ID for the deity watcher brain (null if no watcher started)
       */
      actorId?: string | null;
      /**
       * Format: uuid
       * @description Domain power seed ID (null if seed creation failed or pending)
       */
      seedId?: string | null;
      /**
       * Format: uuid
       * @description Divinity currency wallet ID (null if wallet creation failed or pending)
       */
      currencyWalletId?: string | null;
      /**
       * Format: uuid
       * @description Home realm for this deity (null if not realm-bound)
       */
      realmId?: string | null;
      /** @description Current lifecycle status */
      status: components['schemas']['DeityStatus'];
      /** @description Number of active followers */
      followerCount: number;
      /**
       * Format: date-time
       * @description When the deity was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the deity was last updated
       */
      updatedAt: string;
    };
    /**
     * @description Lifecycle status of a deity entity
     * @enum {string}
     */
    DeityStatus: 'active' | 'dormant' | 'archived';
    /** @description Request to delete an achievement */
    DeleteAchievementDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the achievement to delete */
      achievementId: string;
    };
    /** @description Request to delete an action tag mapping */
    DeleteActionMappingRequest: {
      /** @description The GOAP action tag whose mapping should be deleted */
      tag: string;
    };
    /** @description Request to delete an actor template */
    DeleteActorTemplateRequest: {
      /**
       * Format: uuid
       * @description ID of the template to delete
       */
      templateId: string;
      /**
       * @description If true, stops all running actors using this template
       * @default false
       */
      forceStopActors: boolean;
    };
    /** @description Response confirming template deletion */
    DeleteActorTemplateResponse: {
      /** @description Number of running actors that were stopped */
      stoppedActorCount: number;
    };
    /** @description Request to delete a board instance */
    DeleteBoardRequest: {
      /**
       * Format: uuid
       * @description Board instance to delete
       */
      boardId: string;
    };
    /** @description Request to delete a board template */
    DeleteBoardTemplateRequest: {
      /**
       * Format: uuid
       * @description Board template to delete
       */
      boardTemplateId: string;
    };
    /** @description Request to delete a bundle */
    DeleteBundleRequest: {
      /** @description Human-readable bundle identifier to delete */
      bundleId: string;
      /**
       * @description If true, permanently delete (admin only). If false, soft-delete.
       * @default false
       */
      permanent: boolean;
      /** @description Optional reason for deletion (recorded in version history) */
      reason?: string | null;
    };
    /** @description Result of bundle deletion */
    DeleteBundleResponse: {
      /** @description Human-readable bundle identifier that was deleted */
      bundleId: string;
      /**
       * @description Deletion status
       * @enum {string}
       */
      status: 'deleted' | 'permanently_deleted';
      /**
       * Format: date-time
       * @description When the bundle was deleted
       */
      deletedAt: string;
      /**
       * Format: date-time
       * @description When soft-deleted bundle will be permanently removed (null for permanent deletes)
       */
      retentionUntil?: string | null;
    };
    /** @description Request to delete a calendar template */
    DeleteCalendarRequest: {
      /**
       * Format: uuid
       * @description Game service the calendar belongs to
       */
      gameServiceId: string;
      /** @description Calendar template code to delete */
      templateCode: string;
    };
    /** @description Confirmation of calendar template deletion */
    DeleteCalendarResponse: {
      /** @description Whether the calendar template was deleted */
      deleted: boolean;
    };
    /** @description Request to delete a collection */
    DeleteCollectionRequest: {
      /**
       * Format: uuid
       * @description Collection instance to delete
       */
      collectionId: string;
    };
    /** @description Request to permanently delete a deity and all dependent data */
    DeleteDeityRequest: {
      /**
       * Format: uuid
       * @description Deity to delete
       */
      deityId: string;
    };
    /** @description Request to delete an entry template */
    DeleteEntryTemplateRequest: {
      /**
       * Format: uuid
       * @description Entry template to delete
       */
      entryTemplateId: string;
    };
    /** @description Request to delete a leaderboard */
    DeleteLeaderboardDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard to delete */
      leaderboardId: string;
    };
    /** @description Request to delete a message from a room */
    DeleteMessageRequest: {
      /**
       * Format: uuid
       * @description Room the message belongs to
       */
      roomId: string;
      /**
       * Format: uuid
       * @description Message ID to delete
       */
      messageId: string;
    };
    /** @description Request to delete a norm definition */
    DeleteNormRequest: {
      /**
       * Format: uuid
       * @description ID of the norm to delete
       */
      normId: string;
    };
    /** @description Request to permanently delete a room and all its messages */
    DeleteRoomRequest: {
      /**
       * Format: uuid
       * @description Room ID to delete
       */
      roomId: string;
    };
    /** @description Request to delete a scene */
    DeleteSceneRequest: {
      /**
       * Format: uuid
       * @description ID of the scene to delete
       */
      sceneId: string;
      /** @description Optional reason for deletion (included in event) */
      reason?: string | null;
    };
    /** @description Response confirming scene deletion */
    DeleteSceneResponse: {
      /** @description Whether the scene was successfully deleted */
      deleted: boolean;
      /**
       * Format: uuid
       * @description ID of the deleted scene
       */
      sceneId?: string;
      /** @description If deletion failed, IDs of scenes that reference this one */
      referencingScenes?: string[] | null;
    };
    /** @description Request to hard-delete a deprecated seed type with no remaining non-archived seeds. */
    DeleteSeedTypeRequest: {
      /** @description The seed type to delete. */
      seedTypeCode: string;
      /**
       * Format: uuid
       * @description The game service scope. Null for cross-game seed types.
       */
      gameServiceId?: string | null;
    };
    /** @description Request to permanently delete a save slot and all its versions */
    DeleteSlotRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Slot name */
      slotName: string;
    };
    /** @description Result of a slot deletion operation with cleanup statistics */
    DeleteSlotResponse: {
      /** @description Whether slot was deleted */
      deleted: boolean;
      /** @description Number of versions deleted */
      versionsDeleted: number;
      /**
       * Format: int64
       * @description Storage freed in bytes
       */
      bytesFreed: number;
    };
    /** @description Request to permanently delete a deprecated template */
    DeleteTemplateRequest: {
      /**
       * Format: uuid
       * @description Template ID to delete
       */
      scenarioTemplateId: string;
    };
    /** @description Request to permanently delete a specific save version */
    DeleteVersionRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Slot name */
      slotName: string;
      /** @description Version to delete */
      versionNumber: number;
    };
    /** @description Result of a version deletion operation with storage freed */
    DeleteVersionResponse: {
      /** @description Whether version was deleted */
      deleted: boolean;
      /**
       * Format: int64
       * @description Storage freed in bytes
       */
      bytesFreed: number;
    };
    /**
     * @description Algorithm used for delta computation.
     *     JSON_PATCH: RFC 6902, best for structured JSON data
     *     BSDIFF: Binary diff, good for general binary data
     *     XDELTA: RFC 3284 VCDIFF, efficient for large binary files
     * @default JSON_PATCH
     * @enum {string}
     */
    DeltaAlgorithm: 'JSON_PATCH' | 'BSDIFF' | 'XDELTA';
    /**
     * @description Current deployment phase for scenario availability gating
     * @enum {string}
     */
    DeploymentPhase: 'Alpha' | 'Beta' | 'Release';
    /** @description Request to deposit assets into an escrow */
    DepositRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Party depositing
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Assets to deposit */
      assets: components['schemas']['EscrowAssetBundleInput'];
      /** @description Deposit token (required for full_consent) */
      depositToken?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from depositing assets into an escrow */
    DepositResponse: {
      /** @description Updated escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Deposit record */
      deposit: components['schemas']['EscrowDeposit'];
      /** @description Whether escrow is now fully funded */
      fullyFunded: boolean;
      /** @description Release tokens (issued when fully funded) */
      releaseTokens: components['schemas']['PartyToken'][];
    };
    /** @description Request to deprecate a faction */
    DeprecateFactionRequest: {
      /**
       * Format: uuid
       * @description ID of the faction to deprecate
       */
      factionId: string;
    };
    /** @description Request to mark a quest definition as deprecated */
    DeprecateQuestDefinitionRequest: {
      /**
       * Format: uuid
       * @description Definition to deprecate
       */
      definitionId: string;
      /** @description Reason for deprecation */
      reason?: string | null;
    };
    /** @description Request to deprecate a room type (prevents new room creation) */
    DeprecateRoomTypeRequest: {
      /** @description Room type code to deprecate */
      code: string;
      /**
       * Format: uuid
       * @description Game service scope for the type
       */
      gameServiceId?: string | null;
    };
    /** @description Request to deprecate a scenario definition */
    DeprecateScenarioDefinitionRequest: {
      /**
       * Format: uuid
       * @description Scenario to deprecate
       */
      scenarioId: string;
      /** @description Reason for deprecation */
      reason?: string | null;
    };
    /** @description Request to deprecate a seed type, preventing new seed creation. */
    DeprecateSeedTypeRequest: {
      /** @description The seed type to deprecate. */
      seedTypeCode: string;
      /**
       * Format: uuid
       * @description The game service scope. Null for cross-game seed types.
       */
      gameServiceId?: string | null;
      /** @description Optional reason for deprecation (for audit purposes). */
      reason?: string | null;
    };
    /** @description Request to deprecate a template */
    DeprecateTemplateRequest: {
      /**
       * Format: uuid
       * @description Template ID to deprecate
       */
      scenarioTemplateId: string;
    };
    /** @description Request to designate a faction as the realm baseline */
    DesignateRealmBaselineRequest: {
      /**
       * Format: uuid
       * @description ID of the faction to designate as realm baseline
       */
      factionId: string;
    };
    /** @description Request to destroy an item instance */
    DestroyItemInstanceRequest: {
      /**
       * Format: uuid
       * @description Instance ID to destroy
       */
      instanceId: string;
      /** @description Reason for destruction */
      reason: components['schemas']['DestroyReason'];
    };
    /** @description Response after destroying an item instance */
    DestroyItemInstanceResponse: {
      /**
       * Format: uuid
       * @description Template of the destroyed instance
       */
      templateId: string;
    };
    /**
     * @description Reason for destroying an item instance
     * @enum {string}
     */
    DestroyReason: 'consumed' | 'destroyed' | 'expired' | 'admin';
    /** @description Information about the client device used for authentication or session tracking */
    DeviceInfo: {
      /** @description Category of the device */
      deviceType?: components['schemas']['DeviceType'] | null;
      /** @description Operating system or platform name */
      platform?: string | null;
      /** @description Browser name and version if applicable */
      browser?: string | null;
      /** @description Version of the client application */
      appVersion?: string | null;
    };
    /**
     * @description Category of client device used for authentication or session tracking
     * @enum {string}
     */
    DeviceType: 'desktop' | 'mobile' | 'tablet' | 'console';
    /** @description Request to discard checkout */
    DiscardRequest: {
      /**
       * Format: uuid
       * @description Scene to discard changes for
       */
      sceneId: string;
      /** @description Checkout token */
      checkoutToken: string;
    };
    /** @description Response confirming discard */
    DiscardResponse: {
      /** @description Whether discard was successful */
      discarded: boolean;
    };
    /** @description A discovery level defining what information is revealed at this level */
    DiscoveryLevel: {
      /** @description Discovery level number (zero-indexed) */
      level: number;
      /** @description List of field or information keys revealed at this level */
      reveals: string[];
    };
    /** @description Request to raise a dispute on a funded escrow */
    DisputeRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Party raising dispute
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Reason for dispute */
      reason: string;
      /** @description Release token (proves party identity) */
      releaseToken?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from raising a dispute on an escrow */
    DisputeResponse: {
      /** @description Disputed escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
    };
    /** @description Current divinity balance for a deity */
    DivinityBalanceResponse: {
      /**
       * Format: uuid
       * @description Deity this balance belongs to
       */
      deityId: string;
      /**
       * Format: double
       * @description Current divinity balance
       */
      balance: number;
      /** @description Currency code for the divinity type */
      currencyCode: string;
      /**
       * Format: uuid
       * @description Currency wallet ID
       */
      walletId: string;
    };
    /** @description Paginated divinity transaction history */
    DivinityHistoryResponse: {
      /** @description Transactions in the current page */
      transactions: components['schemas']['DivinityTransaction'][];
      /** @description Total number of transactions */
      totalCount: number;
      /** @description Current page number */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
    };
    /** @description A single divinity transaction record from the currency wallet history */
    DivinityTransaction: {
      /**
       * Format: uuid
       * @description Unique transaction identifier
       */
      transactionId: string;
      /**
       * Format: uuid
       * @description Wallet the transaction belongs to
       */
      walletId: string;
      /**
       * Format: double
       * @description Transaction amount (positive for credits, negative for debits)
       */
      amount: number;
      /** @description Type of transaction (e.g., mortal_action, blessing_grant, manual_credit) */
      transactionType: string;
      /** @description Type of entity involved in this transaction (e.g., character, deity) */
      targetType?: string | null;
      /**
       * Format: uuid
       * @description Entity ID involved in this transaction (e.g., the blessed character, the rival deity)
       */
      targetId?: string | null;
      /**
       * Format: date-time
       * @description When the transaction was recorded
       */
      createdAt: string;
    };
    /** @description Complete document with all metadata and content */
    Document: {
      /**
       * Format: uuid
       * @description Unique identifier of the document
       */
      documentId: string;
      /** @description Namespace the document belongs to */
      namespace: string;
      /** @description URL-friendly unique identifier */
      slug: string;
      /** @description Display title of the document */
      title: string;
      /** @description Category for organizing the document */
      category: components['schemas']['DocumentCategory'];
      /** @description Full markdown content of the document */
      content?: string;
      /** @description Brief text summary of the document */
      summary?: string | null;
      /** @description Concise summary optimized for voice AI */
      voiceSummary?: string | null;
      /** @description Tags for filtering and search */
      tags?: string[];
      /** @description IDs of related documents */
      relatedDocuments?: string[];
      /** @description Client-provided custom metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      };
      /**
       * Format: date-time
       * @description Timestamp when the document was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the document was last updated
       */
      updatedAt: string;
    };
    /**
     * @description Fixed categories for type-safe filtering
     * @enum {string}
     */
    DocumentCategory:
      | 'getting-started'
      | 'api-reference'
      | 'architecture'
      | 'deployment'
      | 'troubleshooting'
      | 'tutorials'
      | 'game-systems'
      | 'world-lore'
      | 'npc-ai'
      | 'other';
    /** @description Search result with relevance scoring and match highlights */
    DocumentResult: {
      /**
       * Format: uuid
       * @description Unique identifier of the document
       */
      documentId: string;
      /** @description URL-friendly unique identifier */
      slug: string;
      /** @description Display title of the document */
      title: string;
      /** @description Category of the document */
      category?: components['schemas']['DocumentCategory'];
      /** @description Brief text summary of the document */
      summary?: string | null;
      /** @description Concise summary optimized for voice AI */
      voiceSummary?: string | null;
      /** @description Full document content if requested */
      content?: string | null;
      /**
       * Format: float
       * @description Relevance score from 0.0 to 1.0
       */
      relevanceScore: number;
      /** @description Text snippets showing where matches occurred */
      matchHighlights?: string[];
    };
    /** @description Lightweight document representation for listings and references */
    DocumentSummary: {
      /**
       * Format: uuid
       * @description Unique identifier of the document
       */
      documentId: string;
      /** @description URL-friendly unique identifier */
      slug: string;
      /** @description Display title of the document */
      title: string;
      /** @description Category of the document */
      category: components['schemas']['DocumentCategory'];
      /** @description Brief text summary of the document */
      summary?: string | null;
      /** @description Concise summary optimized for voice AI */
      voiceSummary?: string | null;
      /** @description Tags associated with the document */
      tags?: string[];
    };
    /** @description A deity's influence in a specific domain with a weight representing strength */
    DomainInfluence: {
      /** @description Opaque domain code (e.g., war, knowledge, nature). Game-defined, not an enum. */
      domain: string;
      /**
       * Format: double
       * @description Strength of influence in this domain (0.0-1.0)
       */
      weight: number;
    };
    /** @description Domain name and weight pair for scenario template growth weighting */
    DomainWeight: {
      /** @description Growth domain path (e.g. combat.melee, exploration.caves) */
      domain: string;
      /**
       * Format: float
       * @description Weight applied to this domain on scenario completion
       */
      weight: number;
    };
    /** @description Download details for a specific game client version and platform */
    DownloadInfo: {
      /** @description Target platform for this download */
      platform: components['schemas']['Platform'];
      /** @description Version number of the game client */
      version: string;
      /**
       * Format: uri
       * @description Download URL for the game client
       */
      url: string;
      /** @description File size in bytes */
      size: number;
      /** @description SHA256 checksum */
      checksum: string;
      /** @description Release notes or changelog for this version */
      releaseNotes?: string | null;
      /** @description Minimum system requirements for the client. No Bannou plugin reads specific keys from this field by convention. */
      minimumRequirements?: {
        [key: string]: unknown;
      };
    };
    /** @description Collection of available game client downloads by platform */
    DownloadsResponse: {
      /** @description Available game client downloads */
      clients: components['schemas']['DownloadInfo'][];
    };
    /**
     * @description How to handle clock gaps after service downtime
     * @enum {string}
     */
    DowntimePolicy: 'Advance' | 'Pause';
    /** @description Request to duplicate a scene */
    DuplicateSceneRequest: {
      /**
       * Format: uuid
       * @description Scene to duplicate
       */
      sourceSceneId: string;
      /** @description Name for the duplicate */
      newName: string;
      /** @description Optional different game ID */
      newGameId?: string | null;
      /** @description Optional different scene type */
      newSceneType?: components['schemas']['SceneType'];
    };
    /** @description Current earn cap status for a balance */
    EarnCapInfo: {
      /**
       * Format: double
       * @description Amount earned today
       */
      dailyEarned: number;
      /**
       * Format: double
       * @description Remaining daily earn allowance
       */
      dailyRemaining: number;
      /**
       * Format: date-time
       * @description When daily counter resets
       */
      dailyResetsAt: string;
      /**
       * Format: double
       * @description Amount earned this week
       */
      weeklyEarned: number;
      /**
       * Format: double
       * @description Remaining weekly earn allowance
       */
      weeklyRemaining: number;
      /**
       * Format: date-time
       * @description When weekly counter resets
       */
      weeklyResetsAt: string;
    };
    /**
     * @description Cardinality for effect application.
     *     Exclusive: Replaces existing value at key
     *     Additive: Adds to collection at key
     * @enum {string}
     */
    EffectCardinality: 'Exclusive' | 'Additive';
    /**
     * @description Whether an effect comes from a status item or a seed capability.
     *     - item_based: temporary effect stored as an item in a status container
     *     - seed_derived: passive capability computed from seed growth state
     * @enum {string}
     */
    EffectSource: 'item_based' | 'seed_derived';
    /**
     * @description How the encounter emotionally affected the character
     * @enum {string}
     */
    EmotionalImpact:
      | 'GRATITUDE'
      | 'ANGER'
      | 'FEAR'
      | 'RESPECT'
      | 'CONTEMPT'
      | 'AFFECTION'
      | 'RIVALRY'
      | 'INDIFFERENCE'
      | 'GUILT'
      | 'PRIDE';
    /** @description 6-dimensional emotional state input (all values 0-1) */
    EmotionalStateInput: {
      /** @description Tension level (0=resolved, 1=maximum tension) */
      tension?: number | null;
      /** @description Brightness level (0=dark, 1=bright) */
      brightness?: number | null;
      /** @description Energy level (0=calm, 1=energetic) */
      energy?: number | null;
      /** @description Warmth level (0=distant, 1=intimate) */
      warmth?: number | null;
      /** @description Stability level (0=unstable, 1=grounded) */
      stability?: number | null;
      /** @description Valence level (0=negative, 1=positive) */
      valence?: number | null;
    };
    /** @description Snapshot of emotional state at a specific point in the composition */
    EmotionalStateSnapshot: {
      /** @description Bar number where this snapshot was taken */
      bar: number;
      /** @description Name of the narrative phase at this point */
      phaseName?: string | null;
      /** @description Tension level (0-1) */
      tension: number;
      /** @description Brightness level (0-1) */
      brightness: number;
      /** @description Energy level (0-1) */
      energy: number;
      /** @description Warmth level (0-1) */
      warmth?: number;
      /** @description Stability level (0-1) */
      stability?: number;
      /** @description Valence level (0-1) */
      valence?: number;
    };
    /** @description Paginated list of encounters */
    EncounterListResponse: {
      /** @description List of encounters with perspectives */
      encounters: components['schemas']['EncounterResponse'][];
      /** @description Total matching encounters */
      totalCount: number;
      /** @description Current page (1-based) */
      page: number;
      /** @description Results per page */
      pageSize: number;
      /** @description Whether more results exist */
      hasNextPage?: boolean;
      /** @description Whether previous results exist */
      hasPreviousPage?: boolean;
    };
    /** @description Core encounter record representing a memorable interaction */
    EncounterModel: {
      /**
       * Format: uuid
       * @description Unique identifier for this encounter
       */
      encounterId: string;
      /**
       * Format: date-time
       * @description In-game time when the encounter occurred
       */
      timestamp: string;
      /**
       * Format: uuid
       * @description Realm where the encounter took place
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Specific location within the realm (optional)
       */
      locationId?: string | null;
      /** @description Type code for this encounter (e.g., COMBAT, TRADE) */
      encounterTypeCode: string;
      /** @description What triggered or contextualized the encounter */
      context?: string | null;
      /** @description Outcome of the encounter (POSITIVE, NEGATIVE, NEUTRAL, MEMORABLE, TRANSFORMATIVE) */
      outcome: components['schemas']['EncounterOutcome'];
      /** @description All character IDs involved in the encounter */
      participantIds: string[];
      /** @description Client-provided encounter-specific data. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description System timestamp when record was created
       */
      createdAt: string;
    };
    /**
     * @description Overall outcome of an encounter
     * @enum {string}
     */
    EncounterOutcome: 'POSITIVE' | 'NEGATIVE' | 'NEUTRAL' | 'MEMORABLE' | 'TRANSFORMATIVE';
    /** @description A character's individual perspective on an encounter */
    EncounterPerspectiveModel: {
      /**
       * Format: uuid
       * @description Unique identifier for this perspective
       */
      perspectiveId: string;
      /**
       * Format: uuid
       * @description Reference to the shared encounter record
       */
      encounterId: string;
      /**
       * Format: uuid
       * @description Character holding this perspective
       */
      characterId: string;
      /** @description Primary emotional response to the encounter */
      emotionalImpact: components['schemas']['EmotionalImpact'];
      /**
       * Format: float
       * @description Intensity of emotional impact (0.0-1.0). Used for kernel extraction threshold (>0.7 indicates high-impact encounter).
       */
      impactIntensity?: number;
      /**
       * Format: float
       * @description Opinion change toward other participants (-1.0 to +1.0)
       */
      sentimentShift?: number | null;
      /**
       * Format: float
       * @description How strongly remembered (0.0-1.0, decays over time)
       */
      memoryStrength: number;
      /** @description Short description from this character's POV */
      rememberedAs?: string | null;
      /**
       * Format: date-time
       * @description When memory decay was last applied
       */
      lastDecayedAt?: string | null;
      /**
       * Format: date-time
       * @description System timestamp when record was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last modification timestamp
       */
      updatedAt?: string | null;
    };
    /** @description Response containing an encounter with perspectives */
    EncounterResponse: {
      /** @description The shared encounter record */
      encounter: components['schemas']['EncounterModel'];
      /** @description All perspectives on this encounter */
      perspectives: components['schemas']['EncounterPerspectiveModel'][];
    };
    /** @description Response containing a list of encounter types */
    EncounterTypeListResponse: {
      /** @description List of encounter types */
      types: components['schemas']['EncounterTypeResponse'][];
      /** @description Total number of types */
      totalCount: number;
    };
    /** @description Response containing an encounter type */
    EncounterTypeResponse: {
      /**
       * Format: uuid
       * @description Unique identifier
       */
      typeId: string;
      /** @description Unique code */
      code: string;
      /** @description Display name */
      name: string;
      /** @description Description */
      description?: string | null;
      /** @description Whether this is a built-in type */
      isBuiltIn: boolean;
      /** @description Suggested emotional response */
      defaultEmotionalImpact?: components['schemas']['EmotionalImpact'];
      /** @description Display ordering */
      sortOrder: number;
      /** @description Whether the type is active */
      isActive: boolean;
      /**
       * Format: date-time
       * @description When the type was created
       */
      createdAt: string;
    };
    /** @description Request to end an active encounter */
    EndEncounterRequest: {
      /** @description ID of the Event Brain actor managing the encounter */
      actorId: string;
    };
    /** @description Response after ending an encounter */
    EndEncounterResponse: {
      /** @description ID of the actor */
      actorId: string;
      /**
       * Format: uuid
       * @description ID of the ended encounter
       */
      encounterId: string;
      /** @description Duration of the encounter in milliseconds */
      durationMs?: number | null;
    };
    /**
     * @description How contract breaches are handled
     * @enum {string}
     */
    EnforcementMode: 'advisory' | 'event_only' | 'consequence_based' | 'community';
    /**
     * @description Character data with optional enriched fields.
     *     Fields are only populated if the corresponding include flag was set in the request.
     */
    EnrichedCharacterResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the character
       */
      characterId: string;
      /** @description Display name of the character */
      name: string;
      /**
       * Format: uuid
       * @description Realm ID (partition key)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Species ID (foreign key to Species service)
       */
      speciesId: string;
      /**
       * Format: date-time
       * @description In-game birth timestamp
       */
      birthDate: string;
      /**
       * Format: date-time
       * @description In-game death timestamp
       */
      deathDate?: string | null;
      /** @description Current lifecycle status of the character */
      status: components['schemas']['CharacterStatus'];
      /**
       * Format: date-time
       * @description Real-world creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Real-world last update timestamp
       */
      updatedAt?: string | null;
      /** @description Family relationships (included if includeFamilyTree=true) */
      familyTree?: components['schemas']['FamilyTreeResponse'];
    };
    /** @description Request to enter the garden */
    EnterGardenRequest: {
      /**
       * Format: uuid
       * @description Account entering the garden
       */
      accountId: string;
      /**
       * Format: uuid
       * @description Current WebSocket session ID
       */
      sessionId: string;
    };
    /** @description Request to enter a scenario */
    EnterScenarioRequest: {
      /**
       * Format: uuid
       * @description Account entering the scenario
       */
      accountId: string;
      /**
       * Format: uuid
       * @description Template to instantiate
       */
      scenarioTemplateId: string;
      /**
       * Format: uuid
       * @description POI that triggered this scenario entry, if any
       */
      poiId?: string | null;
      /** @description Selected prompt choice for prompted POIs */
      promptChoice?: string | null;
    };
    /** @description Request for bonded players to enter a scenario together */
    EnterTogetherRequest: {
      /**
       * Format: uuid
       * @description Bond ID linking the participants
       */
      bondId: string;
      /**
       * Format: uuid
       * @description Template to instantiate for the bond
       */
      scenarioTemplateId: string;
    };
    /** @description An entity currently present at a location */
    EntityPresenceEntry: {
      /** @description Type of entity (opaque string) */
      entityType: string;
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /**
       * Format: date-time
       * @description When the presence was last reported
       */
      reportedAt?: string | null;
      /** @description Identifier of the last reporter */
      reportedBy?: string | null;
    };
    /** @description Entity's rank on a leaderboard */
    EntityRankResponse: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type for the ranked entity */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: double
       * @description Entity's current score
       */
      score: number;
      /**
       * Format: int64
       * @description Entity's current rank (1-based)
       */
      rank: number;
      /**
       * Format: int64
       * @description Total entries on the leaderboard
       */
      totalEntries: number;
      /**
       * Format: double
       * @description Percentile ranking (0-100)
       */
      percentile?: number;
    };
    /** @description An entity required for the storyline */
    EntityRequirement: {
      /** @description Role in the story (e.g., "witness", "informant", "target") */
      role: string;
      /** @description Type of entity needed (e.g., "character", "location", "item") */
      entityType: string;
      /** @description Description of what's needed */
      description: string;
      /** @description Constraints on entity selection/creation */
      constraints?: {
        [key: string]: string;
      } | null;
      /**
       * Format: uuid
       * @description If derived from an archive, that archive's ID
       */
      sourceArchiveId?: string | null;
    };
    /**
     * @description Universal entity type identifier for first-class Bannou entities.
     *     Used for polymorphic entity references (ownerType, entityType, partyType).
     *
     *     NOT for game-configurable content type codes (use opaque strings) or
     *     service-specific roles that include non-entity values (use service-specific enums).
     *     See IMPLEMENTATION TENETS polymorphic type field classification for guidance.
     * @enum {string}
     */
    EntityType:
      | 'system'
      | 'account'
      | 'character'
      | 'actor'
      | 'guild'
      | 'organization'
      | 'government'
      | 'faction'
      | 'location'
      | 'realm'
      | 'item'
      | 'monster'
      | 'relationship'
      | 'session'
      | 'deity'
      | 'dungeon'
      | 'custom'
      | 'other';
    /** @description Metadata for an unlocked entry instance tracking usage and discovery state */
    EntryMetadata: {
      /** @description Context where the entry was unlocked (e.g., location code) */
      unlockedIn?: string | null;
      /** @description Event or activity during which the entry was unlocked */
      unlockedDuring?: string | null;
      /**
       * @description Number of times this entry has been played or viewed
       * @default 0
       */
      playCount: number;
      /**
       * Format: date-time
       * @description When this entry was last accessed or played
       */
      lastAccessedAt?: string | null;
      /**
       * @description Whether this entry has been favorited by the owner
       * @default false
       */
      favorited: boolean;
      /**
       * @description Current discovery level for progressive reveal entries
       * @default 0
       */
      discoveryLevel: number;
      /**
       * @description Kill count for bestiary entries
       * @default 0
       */
      killCount: number;
      /** @description Arbitrary custom data for game-specific metadata. No Bannou plugin reads specific keys from this field by convention. */
      customData?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Entry template with all fields */
    EntryTemplateResponse: {
      /**
       * Format: uuid
       * @description Unique entry template identifier
       */
      entryTemplateId: string;
      /** @description Unique code within this collection type and game service */
      code: string;
      /** @description Type of collection this entry belongs to */
      collectionType: components['schemas']['CollectionType'];
      /**
       * Format: uuid
       * @description Game service this entry template is scoped to
       */
      gameServiceId: string;
      /** @description Human-readable display name */
      displayName: string;
      /** @description Category within the collection type */
      category?: string | null;
      /** @description Searchable tags */
      tags?: string[] | null;
      /** @description Primary asset identifier */
      assetId?: string | null;
      /** @description Thumbnail or preview asset identifier */
      thumbnailAssetId?: string | null;
      /** @description Hint text about how to unlock this entry */
      unlockHint?: string | null;
      /** @description Whether this entry is hidden until unlocked */
      hideWhenLocked: boolean;
      /**
       * Format: uuid
       * @description Item template used when granting this entry
       */
      itemTemplateId: string;
      /** @description Progressive discovery levels */
      discoveryLevels?: components['schemas']['DiscoveryLevel'][] | null;
      /** @description Theme tags for music entries */
      themes?: string[] | null;
      /** @description Duration of the content */
      duration?: string | null;
      /** @description Loop point for music entries */
      loopPoint?: string | null;
      /** @description Composer or creator name */
      composer?: string | null;
      /**
       * Format: date-time
       * @description When this entry template was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When this entry template was last updated
       */
      updatedAt?: string | null;
    };
    /** @description A named time span in the calendar for display purposes */
    EraLabel: {
      /** @description Era identifier code (e.g., "first_age", "era_of_strife") */
      code: string;
      /** @description Game year when this era begins (0-based) */
      startYear: number;
      /** @description Game year when this era ends (null = ongoing) */
      endYear?: number | null;
    };
    /** @description Main escrow agreement record */
    EscrowAgreement: {
      /**
       * Format: uuid
       * @description Unique escrow agreement identifier
       */
      id: string;
      /** @description Type of escrow agreement */
      escrowType: components['schemas']['EscrowType'];
      /** @description Trust mode for the escrow */
      trustMode: components['schemas']['EscrowTrustMode'];
      /**
       * Format: uuid
       * @description For single_party_trusted - which party has authority
       */
      trustedPartyId?: string | null;
      /** @description Type of the trusted party */
      trustedPartyType?: components['schemas']['EntityType'] | null;
      /** @description For initiator_trusted - which service created this */
      initiatorServiceId?: string | null;
      /** @description All parties involved in the escrow */
      parties: components['schemas']['EscrowParty'][];
      /** @description What deposits are expected from each party */
      expectedDeposits: components['schemas']['ExpectedDeposit'][];
      /** @description Actual deposits received */
      deposits: components['schemas']['EscrowDeposit'][];
      /** @description How assets should be distributed on release */
      releaseAllocations?: components['schemas']['ReleaseAllocation'][] | null;
      /**
       * Format: uuid
       * @description Contract governing conditions for this escrow
       */
      boundContractId?: string | null;
      /** @description Consent decisions from parties */
      consents: components['schemas']['EscrowConsent'][];
      /** @description Current escrow status */
      status: components['schemas']['EscrowStatus'];
      /** @description How many parties must consent for release (-1 = all required) */
      requiredConsentsForRelease: number;
      /**
       * Format: date-time
       * @description When the escrow was last validated
       */
      lastValidatedAt?: string | null;
      /** @description Any validation failures detected */
      validationFailures?: components['schemas']['ValidationFailure'][] | null;
      /**
       * Format: date-time
       * @description When the escrow was created
       */
      createdAt: string;
      /**
       * Format: uuid
       * @description Who created the escrow
       */
      createdBy: string;
      /** @description Type of the creator entity */
      createdByType: components['schemas']['EntityType'];
      /**
       * Format: date-time
       * @description When all expected deposits were received
       */
      fundedAt?: string | null;
      /**
       * Format: date-time
       * @description Auto-refund if not completed by this time
       */
      expiresAt: string;
      /**
       * Format: date-time
       * @description When the escrow reached terminal state
       */
      completedAt?: string | null;
      /** @description What this escrow is for (e.g., trade, auction, contract) */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description ID of the referenced entity
       */
      referenceId?: string | null;
      /** @description Human-readable description */
      description?: string | null;
      /** @description Client-provided application-specific metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /** @description How the escrow was resolved */
      resolution?: components['schemas']['EscrowResolution'];
      /** @description Notes about the resolution */
      resolutionNotes?: string | null;
      /** @description How release confirmation is handled for this escrow. */
      releaseMode?: components['schemas']['ReleaseMode'];
      /** @description How refund confirmation is handled for this escrow. */
      refundMode?: components['schemas']['RefundMode'];
      /**
       * Format: date-time
       * @description Deadline for party confirmations when in Releasing/Refunding state.
       */
      confirmationDeadline?: string | null;
    };
    /** @description An asset held in escrow */
    EscrowAsset: {
      /** @description Type of asset held in escrow */
      assetType: components['schemas']['AssetType'];
      /**
       * Format: uuid
       * @description For assetType=currency - currency definition ID
       */
      currencyDefinitionId?: string | null;
      /** @description Denormalized currency code for display */
      currencyCode?: string | null;
      /** @description Amount of currency */
      currencyAmount?: number | null;
      /**
       * Format: uuid
       * @description For assetType=item - unique item instance ID
       */
      itemInstanceId?: string | null;
      /** @description Denormalized item name for display */
      itemName?: string | null;
      /**
       * Format: uuid
       * @description For assetType=item_stack - stackable item template
       */
      itemTemplateId?: string | null;
      /** @description Denormalized template name for display */
      itemTemplateName?: string | null;
      /** @description For assetType=item_stack - quantity */
      itemQuantity?: number | null;
      /**
       * Format: uuid
       * @description For assetType=contract - contract instance ID
       */
      contractInstanceId?: string | null;
      /** @description Denormalized contract template code */
      contractTemplateCode?: string | null;
      /** @description Description of the contract */
      contractDescription?: string | null;
      /** @description Which party role in the contract is being escrowed */
      contractPartyRole?: string | null;
      /** @description For assetType=custom - registered handler type */
      customAssetType?: string | null;
      /** @description Custom asset identifier */
      customAssetId?: string | null;
      /** @description Custom asset handler-specific data. No Bannou plugin reads specific keys from this field by convention. */
      customAssetData?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: uuid
       * @description Where this asset came from (for refunds)
       */
      sourceOwnerId: string;
      /** @description Type of the source owner */
      sourceOwnerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Source wallet/container ID
       */
      sourceContainerId?: string | null;
    };
    /** @description Groups multiple assets for a single deposit or release */
    EscrowAssetBundle: {
      /**
       * Format: uuid
       * @description Bundle identifier
       */
      bundleId: string;
      /** @description Assets in this bundle */
      assets: components['schemas']['EscrowAsset'][];
      /** @description Summary for display */
      description?: string | null;
      /** @description Optional valuation for UI display */
      estimatedValue?: number | null;
    };
    /** @description Input for specifying a bundle of assets */
    EscrowAssetBundleInput: {
      /** @description Assets to deposit */
      assets: components['schemas']['EscrowAssetInput'][];
      /** @description Bundle description */
      description?: string | null;
      /** @description Estimated value */
      estimatedValue?: number | null;
    };
    /** @description Input for specifying an asset in escrow operations */
    EscrowAssetInput: {
      /** @description Type of asset to deposit */
      assetType: components['schemas']['AssetType'];
      /**
       * Format: uuid
       * @description Currency definition ID
       */
      currencyDefinitionId?: string | null;
      /** @description Currency code */
      currencyCode?: string | null;
      /** @description Currency amount */
      currencyAmount?: number | null;
      /**
       * Format: uuid
       * @description Item instance ID
       */
      itemInstanceId?: string | null;
      /** @description Item name */
      itemName?: string | null;
      /**
       * Format: uuid
       * @description Item template ID (for stacks)
       */
      itemTemplateId?: string | null;
      /** @description Item template name */
      itemTemplateName?: string | null;
      /** @description Item quantity (for stacks) */
      itemQuantity?: number | null;
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractInstanceId?: string | null;
      /** @description Contract template code */
      contractTemplateCode?: string | null;
      /** @description Contract description */
      contractDescription?: string | null;
      /** @description Contract party role being escrowed */
      contractPartyRole?: string | null;
      /** @description Custom asset type */
      customAssetType?: string | null;
      /** @description Custom asset ID */
      customAssetId?: string | null;
      /** @description Custom asset handler-specific data. No Bannou plugin reads specific keys from this field by convention. */
      customAssetData?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Records a party consent decision */
    EscrowConsent: {
      /**
       * Format: uuid
       * @description Party giving consent
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Type of consent given */
      consentType: components['schemas']['EscrowConsentType'];
      /**
       * Format: date-time
       * @description When consent was given
       */
      consentedAt: string;
      /** @description Token used (for audit) */
      releaseTokenUsed?: string | null;
      /** @description Optional notes */
      notes?: string | null;
    };
    /**
     * @description Type of consent being given.
     *     - release: Agrees to release assets to recipients
     *     - refund: Agrees to refund assets to depositors
     *     - dispute: Raises a dispute
     *     - reaffirm: Re-affirms after validation failure
     * @enum {string}
     */
    EscrowConsentType: 'release' | 'refund' | 'dispute' | 'reaffirm';
    /** @description Records an actual deposit */
    EscrowDeposit: {
      /**
       * Format: uuid
       * @description Deposit record identifier
       */
      id: string;
      /**
       * Format: uuid
       * @description Escrow this deposit belongs to
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Party who deposited
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Assets deposited */
      assets: components['schemas']['EscrowAssetBundle'];
      /**
       * Format: date-time
       * @description When the deposit was made
       */
      depositedAt: string;
      /** @description Token used (for audit) */
      depositTokenUsed?: string | null;
      /** @description Idempotency key for this deposit */
      idempotencyKey: string;
    };
    /** @description Request from lib-escrow to debit wallet for deposit */
    EscrowDepositRequest: {
      /**
       * Format: uuid
       * @description Wallet to debit
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to debit
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to debit for escrow
       */
      amount: number;
      /**
       * Format: uuid
       * @description Associated escrow agreement ID
       */
      escrowId: string;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Result of escrow deposit (wallet debit) */
    EscrowDepositResponse: {
      /** @description Debit transaction record */
      transaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Wallet balance after debit
       */
      newBalance: number;
    };
    /** @description A party in the escrow agreement */
    EscrowParty: {
      /**
       * Format: uuid
       * @description Party entity identifier
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Display name for UI/logging */
      displayName?: string | null;
      /** @description Role of this party in the escrow */
      role: components['schemas']['EscrowPartyRole'];
      /** @description Whether this party consent is required for release */
      consentRequired: boolean;
      /**
       * Format: uuid
       * @description Party own wallet (where currency comes from/returns to)
       */
      walletId?: string | null;
      /**
       * Format: uuid
       * @description Party own container (where items come from/return to)
       */
      containerId?: string | null;
      /**
       * Format: uuid
       * @description Escrow wallet for THIS party deposits (owned by escrow)
       */
      escrowWalletId?: string | null;
      /**
       * Format: uuid
       * @description Escrow container for THIS party deposits (owned by escrow)
       */
      escrowContainerId?: string | null;
      /** @description Token for depositing (full_consent mode) */
      depositToken?: string | null;
      /** @description Whether the deposit token has been used */
      depositTokenUsed: boolean;
      /**
       * Format: date-time
       * @description When the deposit token was used
       */
      depositTokenUsedAt?: string | null;
      /** @description Token for consenting to release */
      releaseToken?: string | null;
      /** @description Whether the release token has been used */
      releaseTokenUsed: boolean;
      /**
       * Format: date-time
       * @description When the release token was used
       */
      releaseTokenUsedAt?: string | null;
    };
    /**
     * @description Role of a party in the escrow.
     *     - depositor: Deposits assets into escrow
     *     - recipient: Receives assets when released
     *     - depositor_recipient: Both deposits and can receive (typical for trades)
     *     - arbiter: Can resolve disputes, does not deposit or receive
     *     - observer: Can view status but cannot act
     * @enum {string}
     */
    EscrowPartyRole: 'depositor' | 'recipient' | 'depositor_recipient' | 'arbiter' | 'observer';
    /** @description Request from lib-escrow to credit depositor on refund */
    EscrowRefundRequest: {
      /**
       * Format: uuid
       * @description Depositor wallet to credit
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to credit
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to refund
       */
      amount: number;
      /**
       * Format: uuid
       * @description Associated escrow agreement ID
       */
      escrowId: string;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Result of escrow refund (depositor credit) */
    EscrowRefundResponse: {
      /** @description Credit transaction record */
      transaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Depositor balance after credit
       */
      newBalance: number;
    };
    /** @description Request from lib-escrow to credit recipient on completion */
    EscrowReleaseRequest: {
      /**
       * Format: uuid
       * @description Recipient wallet to credit
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to credit
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to credit
       */
      amount: number;
      /**
       * Format: uuid
       * @description Associated escrow agreement ID
       */
      escrowId: string;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Result of escrow release (recipient credit) */
    EscrowReleaseResponse: {
      /** @description Credit transaction record */
      transaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Recipient balance after credit
       */
      newBalance: number;
    };
    /**
     * @description How the escrow was resolved.
     *     - released: Assets went to designated recipients
     *     - refunded: Assets returned to depositors
     *     - split: Arbiter split assets between parties
     *     - expired_refunded: Timed out, auto-refunded
     *     - cancelled_refunded: Cancelled, deposits refunded
     *     - violation_refunded: Validation failure caused refund
     * @enum {string}
     */
    EscrowResolution:
      | 'released'
      | 'refunded'
      | 'split'
      | 'expired_refunded'
      | 'cancelled_refunded'
      | 'violation_refunded';
    /**
     * @description Current status of the escrow agreement.
     *     - pending_deposits: Waiting for parties to deposit
     *     - partially_funded: Some but not all deposits received
     *     - funded: All deposits received, awaiting consent/condition
     *     - pending_consent: Some consents received, waiting for more
     *     - pending_condition: Waiting for contract fulfillment or external verification
     *     - finalizing: Running contract finalizer prebound APIs (transient)
     *     - releasing: Release in progress (transient)
     *     - released: Assets transferred to recipients
     *     - refunding: Refund in progress (transient)
     *     - refunded: Assets returned to depositors
     *     - disputed: In dispute, arbiter must resolve
     *     - expired: Timed out without completion
     *     - cancelled: Cancelled before funding complete
     *     - validation_failed: Held assets changed, awaiting re-affirmation
     * @enum {string}
     */
    EscrowStatus:
      | 'pending_deposits'
      | 'partially_funded'
      | 'funded'
      | 'pending_consent'
      | 'pending_condition'
      | 'finalizing'
      | 'releasing'
      | 'released'
      | 'refunding'
      | 'refunded'
      | 'disputed'
      | 'expired'
      | 'cancelled'
      | 'validation_failed';
    /**
     * @description Trust model for the escrow agreement.
     *     - full_consent: All parties must explicitly consent using tokens
     *     - initiator_trusted: The service that created the escrow can complete unilaterally
     *     - single_party_trusted: A designated party can complete unilaterally
     * @enum {string}
     */
    EscrowTrustMode: 'full_consent' | 'initiator_trusted' | 'single_party_trusted';
    /**
     * @description Type of escrow agreement.
     *     - two_party: Simple trade escrow between Party A and Party B
     *     - multi_party: N parties with complex deposit/receive rules
     *     - conditional: Release based on external condition or contract fulfillment
     *     - auction: Winner-takes-all with refunds to losers
     * @enum {string}
     */
    EscrowType: 'two_party' | 'multi_party' | 'conditional' | 'auction';
    /**
     * @description Categories of historical events that characters can participate in
     * @enum {string}
     */
    EventCategory:
      | 'WAR'
      | 'NATURAL_DISASTER'
      | 'POLITICAL'
      | 'ECONOMIC'
      | 'RELIGIOUS'
      | 'CULTURAL'
      | 'PERSONAL';
    /** @description Request to execute cleanup for a resource */
    ExecuteCleanupRequest: {
      /** @description Type of resource to clean up (opaque identifier) */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource to clean up
       */
      resourceId: string;
      /** @description Override grace period in seconds (uses default if not specified, 0 to skip) */
      gracePeriodSeconds?: number | null;
      /** @description Override cleanup policy (uses resource default if not specified) */
      cleanupPolicy?: components['schemas']['CleanupPolicy'];
      /**
       * @description If true, returns what callbacks WOULD execute without actually
       *     executing them. Useful for pre-deletion validation and debugging.
       *     Defaults to false.
       */
      dryRun?: boolean | null;
    };
    /** @description Response after attempting to execute cleanup */
    ExecuteCleanupResponse: {
      /** @description Type of resource cleaned up */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource cleaned up
       */
      resourceId: string;
      /** @description True if cleanup completed (per cleanup policy) */
      success: boolean;
      /** @description Why cleanup was aborted (refcount changed, callback failed with ALL_REQUIRED, etc.) */
      abortReason?: string | null;
      /** @description Results of each cleanup callback */
      callbackResults: components['schemas']['CleanupCallbackResult'][];
      /** @description Total cleanup execution time in milliseconds */
      cleanupDurationMs?: number;
      /** @description True if this was a preview (no callbacks were actually executed) */
      dryRun: boolean;
    };
    /** @description Request to compress a resource */
    ExecuteCompressRequest: {
      /** @description Type of resource to compress */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource to compress
       */
      resourceId: string;
      /**
       * @description If true, invoke cleanup callbacks after successful archival
       * @default false
       */
      deleteSourceData: boolean;
      /**
       * @description Cleanup policy for source data deletion after archival.
       *     Only applies when deleteSourceData is true.
       *     If not specified, uses the configured DefaultCleanupPolicy.
       */
      deleteSourceDataPolicy?: components['schemas']['CleanupPolicy'];
      /** @description Override policy (uses default from config if not specified) */
      compressionPolicy?: components['schemas']['CompressionPolicy'];
      /**
       * @description If true, return what would be compressed without executing
       * @default false
       */
      dryRun: boolean;
    };
    /** @description Compression execution result */
    ExecuteCompressResponse: {
      /** @description Type of resource compressed */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource compressed
       */
      resourceId: string;
      /** @description True if compression completed successfully */
      success: boolean;
      /**
       * Format: uuid
       * @description ID of created archive (null if failed or dryRun)
       */
      archiveId?: string | null;
      /** @description Why compression was aborted */
      abortReason?: string | null;
      /** @description Results of each compression callback */
      callbackResults: components['schemas']['CompressCallbackResult'][];
      /** @description Whether cleanup callbacks were executed after archival */
      sourceDataDeleted?: boolean;
      /** @description True if this was a preview (no callbacks actually executed) */
      dryRun: boolean;
      /** @description Total compression execution time in milliseconds */
      compressionDurationMs: number;
    };
    /** @description Request to execute contract clauses */
    ExecuteContractRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractInstanceId: string;
      /** @description Idempotency key for the execution */
      idempotencyKey?: string | null;
    };
    /** @description Response from executing a contract. HTTP 200 confirms execution completed. */
    ExecuteContractResponse: {
      /** @description True if this was a repeat call (idempotency). When false, this is a fresh execution. */
      alreadyExecuted: boolean;
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Per-clause distribution outcomes with success/failure details */
      distributions?: components['schemas']['ClauseDistributionResult'][] | null;
    };
    /** @description Request to execute a currency conversion */
    ExecuteConversionRequest: {
      /**
       * Format: uuid
       * @description Wallet to perform conversion in
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to debit
       */
      fromCurrencyId: string;
      /**
       * Format: uuid
       * @description Currency to credit
       */
      toCurrencyId: string;
      /**
       * Format: double
       * @description Amount to convert (must be positive)
       */
      fromAmount: number;
      /** @description Unique key for idempotency */
      idempotencyKey: string;
    };
    /** @description Result of conversion execution */
    ExecuteConversionResponse: {
      /** @description Debit transaction (conversion_debit) */
      debitTransaction: components['schemas']['CurrencyTransactionRecord'];
      /** @description Credit transaction (conversion_credit) */
      creditTransaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Amount debited
       */
      fromDebited: number;
      /**
       * Format: double
       * @description Amount credited
       */
      toCredited: number;
      /**
       * Format: double
       * @description Rate applied
       */
      effectiveRate: number;
    };
    /** @description Request to create an ephemeral snapshot of a living resource */
    ExecuteSnapshotRequest: {
      /**
       * @description Type of resource to snapshot (opaque identifier).
       *     Must match compression callback registrations.
       */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource to snapshot
       */
      resourceId: string;
      /**
       * @description Optional label for the snapshot purpose (e.g., "storyline_seed", "analytics").
       *     Stored in metadata for filtering/debugging.
       */
      snapshotType?: string;
      /**
       * @description Time-to-live in seconds for the snapshot.
       *     If not specified, uses the configured default (RESOURCE_SNAPSHOT_DEFAULT_TTL_SECONDS).
       *     Value is clamped to configured min/max range.
       *     Snapshot is automatically deleted by Redis after TTL expires.
       */
      ttlSeconds?: number | null;
      /**
       * @description Policy for callback execution.
       *     If not specified, uses the configured default (RESOURCE_DEFAULT_COMPRESSION_POLICY).
       */
      compressionPolicy?: components['schemas']['CompressionPolicy'];
      /**
       * @description If true, return what would be captured without storing
       * @default false
       */
      dryRun: boolean;
      /**
       * @description Optional list of source types to include in the snapshot.
       *     Only compression callbacks matching these source types will be executed.
       *     If omitted or empty, all registered compression callbacks are executed.
       *     Example: ["character-personality", "character-history"]
       */
      filterSourceTypes?: string[] | null;
    };
    /** @description Result of snapshot execution */
    ExecuteSnapshotResponse: {
      /** @description Type of resource snapshotted */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource snapshotted
       */
      resourceId: string;
      /** @description True if snapshot completed successfully */
      success: boolean;
      /** @description True if this was a dry run */
      dryRun: boolean;
      /**
       * Format: uuid
       * @description Unique ID for this snapshot (null on failure or dry run)
       */
      snapshotId?: string | null;
      /**
       * Format: date-time
       * @description When this snapshot will expire (null on failure or dry run)
       */
      expiresAt?: string | null;
      /** @description Why snapshot was aborted */
      abortReason?: string | null;
      /** @description Results of each compression callback */
      callbackResults?: components['schemas']['CompressCallbackResult'][];
      /** @description Total snapshot execution time in milliseconds */
      snapshotDurationMs: number;
    };
    /** @description Metadata about behavior execution requirements including timing, resources, and interrupt conditions */
    ExecutionMetadata: {
      /** @description Estimated execution time in seconds */
      estimatedDuration?: number;
      /** @description Resource requirements for behavior execution */
      resourceRequirements?: {
        [key: string]: number;
      } | null;
      /** @description Conditions that can interrupt behavior execution */
      interruptConditions?: string[] | null;
    };
    /** @description Defines what a party should deposit */
    ExpectedDeposit: {
      /**
       * Format: uuid
       * @description Party who should deposit
       */
      partyId: string;
      /** @description Type of depositing party */
      partyType: components['schemas']['EntityType'];
      /** @description Expected assets from this party */
      expectedAssets: components['schemas']['EscrowAsset'][];
      /** @description Is this deposit optional */
      optional: boolean;
      /**
       * Format: date-time
       * @description Deadline for this specific deposit
       */
      depositDeadline?: string | null;
      /** @description Has this party fulfilled their deposit requirement */
      fulfilled: boolean;
    };
    /** @description Input for defining expected deposits from a party */
    ExpectedDepositInput: {
      /**
       * Format: uuid
       * @description Party who should deposit
       */
      partyId: string;
      /** @description Type of depositing party */
      partyType: components['schemas']['EntityType'];
      /** @description Expected assets */
      expectedAssets: components['schemas']['EscrowAssetInput'][];
      /** @description Is this deposit optional */
      optional?: boolean | null;
      /**
       * Format: date-time
       * @description Specific deadline for this deposit
       */
      depositDeadline?: string | null;
    };
    /**
     * @description How currency expiration is determined
     * @enum {string}
     */
    ExpirationPolicy: 'fixed_date' | 'duration_from_earn' | 'end_of_season';
    /** @description Request to export all saves for an owner to a downloadable archive */
    ExportSavesRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the saves to export
       */
      ownerId: string;
      /** @description Type of entity that owns the saves to export */
      ownerType: components['schemas']['EntityType'];
      /** @description Specific slots to export (all if null) */
      slotNames?: string[];
    };
    /** @description Response with pre-signed URL for downloading exported save archive */
    ExportSavesResponse: {
      /** @description Pre-signed URL to download export archive */
      downloadUrl: string;
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Archive size
       */
      sizeBytes: number;
    };
    /**
     * @description Complete faction membership data for archive storage and storyline SDK consumption.
     *     Inherits base archive properties from ResourceArchiveBase.
     *     The characterId field equals resourceId for convenience.
     */
    FactionArchive: {
      /**
       * Format: uuid
       * @description Character this data belongs to (equals resourceId)
       */
      characterId: string;
      /** @description Whether any faction memberships exist */
      hasMemberships: boolean;
      /** @description Number of membership records in archive */
      membershipCount: number;
      /** @description Faction membership records (null if hasMemberships is false) */
      memberships?: components['schemas']['FactionMemberResponse'][] | null;
    } & components['schemas']['ResourceArchiveBase'];
    /** @description Faction membership record linking a character to a faction with a role */
    FactionMemberResponse: {
      /**
       * Format: uuid
       * @description Faction the character belongs to
       */
      factionId: string;
      /**
       * Format: uuid
       * @description Character who is a member
       */
      characterId: string;
      /** @description Member's role in the faction */
      role: components['schemas']['FactionMemberRole'];
      /**
       * Format: date-time
       * @description When the character joined the faction
       */
      joinedAt: string;
      /**
       * Format: date-time
       * @description When the membership was last updated (role change)
       */
      updatedAt?: string | null;
    };
    /**
     * @description Role hierarchy for faction membership
     * @enum {string}
     */
    FactionMemberRole: 'Leader' | 'Officer' | 'Member' | 'Recruit';
    /** @description Complete faction entity with seed growth status */
    FactionResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the faction
       */
      factionId: string;
      /**
       * Format: uuid
       * @description Game service this faction belongs to
       */
      gameServiceId: string;
      /** @description Display name of the faction */
      name: string;
      /** @description Unique code within the game service (e.g., "thieves_guild") */
      code: string;
      /** @description Human-readable description of the faction */
      description?: string | null;
      /**
       * Format: uuid
       * @description Realm this faction belongs to
       */
      realmId: string;
      /** @description Whether this faction is the realm's baseline cultural faction */
      isRealmBaseline: boolean;
      /**
       * Format: uuid
       * @description Parent faction in hierarchy (null for top-level factions)
       */
      parentFactionId?: string | null;
      /**
       * Format: uuid
       * @description Associated seed for growth tracking (null if seed creation failed)
       */
      seedId?: string | null;
      /** @description Current lifecycle status */
      status: components['schemas']['FactionStatus'];
      /** @description Current seed growth phase (denormalized from lib-seed for convenience) */
      currentPhase?: string | null;
      /** @description Current number of members in this faction */
      memberCount: number;
      /**
       * Format: date-time
       * @description When this faction was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When this faction was last updated
       */
      updatedAt: string;
    };
    /**
     * @description Lifecycle status of a faction entity
     * @enum {string}
     */
    FactionStatus: 'Active' | 'Deprecated' | 'Dissolved';
    /** @description Request to fail a milestone */
    FailMilestoneRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Milestone that failed */
      milestoneCode: string;
      /** @description Reason for failure */
      reason?: string | null;
    };
    /** @description Reference to a family member */
    FamilyMember: {
      /**
       * Format: uuid
       * @description ID of the related character
       */
      characterId: string;
      /** @description Display name (if available) */
      name?: string | null;
      /** @description Specific relationship type (MOTHER, FATHER, SON, DAUGHTER, etc.) */
      relationshipType: string;
      /** @description Whether the related character is alive */
      isAlive: boolean;
    };
    /** @description Family relationships for a character */
    FamilyTreeResponse: {
      /** @description Parent relationships (biological and adoptive) */
      parents: components['schemas']['FamilyMember'][];
      /** @description Child relationships */
      children: components['schemas']['FamilyMember'][];
      /** @description Sibling relationships (including half-siblings) */
      siblings: components['schemas']['FamilyMember'][];
      /** @description Spousal relationships (spouse, husband, wife) */
      spouses: components['schemas']['FamilyMember'][];
      /** @description Previous incarnations (if reincarnation tracked) */
      pastLives: components['schemas']['PastLifeReference'][];
    };
    /** @description Result from a contract finalizer API call */
    FinalizerResult: {
      /** @description Finalizer endpoint */
      endpoint: string;
      /** @description Whether it succeeded */
      success: boolean;
      /** @description Error message if failed */
      error?: string | null;
    };
    /** @description Request to find asset usage */
    FindAssetUsageRequest: {
      /**
       * Format: uuid
       * @description Asset ID to find usage of
       */
      assetId: string;
      /** @description Optional game filter */
      gameId?: string | null;
    };
    /** @description Scenes using the asset */
    FindAssetUsageResponse: {
      /** @description Asset usage instances */
      usages: components['schemas']['AssetUsageInfo'][];
    };
    /** @description Request to find referencing scenes */
    FindReferencesRequest: {
      /**
       * Format: uuid
       * @description Scene ID to find references to
       */
      sceneId: string;
    };
    /** @description Scenes that reference the target */
    FindReferencesResponse: {
      /** @description Scenes containing references */
      referencingScenes: components['schemas']['ReferenceInfo'][];
    };
    /** @description Request to find space for item */
    FindSpaceRequest: {
      /**
       * Format: uuid
       * @description Owner to search
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['ContainerOwnerType'];
      /**
       * Format: uuid
       * @description Item template
       */
      templateId: string;
      /**
       * Format: double
       * @description Quantity to place
       * @default 1
       */
      quantity: number;
      /**
       * @description Prefer existing stacks
       * @default true
       */
      preferStackable: boolean;
    };
    /** @description Find space result */
    FindSpaceResponse: {
      /** @description Whether space found */
      hasSpace: boolean;
      /** @description Potential placements */
      candidates: components['schemas']['SpaceCandidate'][];
    };
    /** @description Follower record linking a character to a deity */
    FollowerResponse: {
      /**
       * Format: uuid
       * @description Follower character ID
       */
      characterId: string;
      /**
       * Format: uuid
       * @description Deity being followed
       */
      deityId: string;
      /**
       * Format: date-time
       * @description When the follower relationship was created
       */
      registeredAt: string;
      /**
       * Format: uuid
       * @description Underlying relationship record ID from lib-relationship
       */
      relationshipId: string;
    };
    /** @description A musical form structure template */
    FormTemplate: {
      /** @description Form name (e.g., "AABB", "verse-chorus") */
      name: string;
      /** @description Section sequence (e.g., ["A", "A", "B", "B"]) */
      sections: string[];
      /**
       * @description Default bars per section
       * @default 8
       */
      barsPerSection: number;
    };
    /** @description Request to perform a game action such as movement or combat */
    GameActionRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the client. Provided by shortcut system.
       */
      sessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player. Provided by shortcut system.
       */
      accountId: string;
      /** @description Game type for the action. Determines which lobby to apply the action. Provided by shortcut system. */
      gameType: components['schemas']['GameType'];
      /** @description Type of game action to perform */
      actionType: components['schemas']['GameActionType'];
      /** @description Game-specific action data. No Bannou plugin reads specific keys from this field by convention. */
      actionData?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: uuid
       * @description Target of the action (if applicable)
       */
      targetId?: string | null;
    };
    /** @description Response indicating the result of a game action with any state changes */
    GameActionResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for this action instance
       */
      actionId: string;
      /** @description Game-specific action result data. No Bannou plugin reads specific keys from this field by convention. */
      result?: {
        [key: string]: unknown;
      } | null;
      /** @description Updated game state (if applicable). No Bannou plugin reads specific keys from this field by convention. */
      newGameState?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Type of game action
     * @enum {string}
     */
    GameActionType: 'move' | 'interact' | 'attack' | 'cast_spell' | 'use_item';
    /** @description Information about a player currently participating in a game session */
    GamePlayer: {
      /**
       * Format: uuid
       * @description Unique identifier for the player's account
       */
      accountId: string;
      /**
       * Format: uuid
       * @description WebSocket session ID that joined the game. Chat and events are delivered to this specific session only.
       */
      sessionId: string;
      /** @description Display name shown to other players */
      displayName?: string | null;
      /** @description Role of the player in the game session */
      role: components['schemas']['PlayerRole'];
      /**
       * Format: date-time
       * @description Timestamp when the player joined the session
       */
      joinedAt: string;
      /** @description Game-specific character data for this player. No Bannou plugin reads specific keys from this field by convention. */
      characterData?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Realm stub name (lowercase string identifier) that this asset belongs to.
     *     Use the realm's stub_name property (e.g., "realm-1", "realm-2") from the Realm service.
     *     Use "shared" for assets that are available across all realms.
     */
    GameRealm: string;
    /** @description Complete details of a game session including players and settings */
    GameSessionResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the game session
       */
      sessionId: string;
      /** @description Type of game for this session */
      gameType: components['schemas']['GameType'];
      /** @description Type of session - lobby or matchmade */
      sessionType: components['schemas']['SessionType'];
      /** @description Display name for the session */
      sessionName?: string | null;
      /** @description Current status of the game session */
      status: components['schemas']['SessionStatus'];
      /** @description Maximum number of players allowed in the session */
      maxPlayers?: number;
      /** @description Current number of players in the session */
      currentPlayers?: number;
      /** @description Whether the session requires a password to join */
      isPrivate?: boolean;
      /**
       * Format: uuid
       * @description Account ID of the session owner (null for system-owned lobby sessions)
       */
      owner?: string | null;
      /** @description List of players currently in the session */
      players?: components['schemas']['GamePlayer'][];
      /**
       * Format: date-time
       * @description Timestamp when the session was created
       */
      createdAt: string;
      /** @description Game-specific configuration settings. No Bannou plugin reads specific keys from this field by convention. */
      gameSettings?: {
        [key: string]: unknown;
      } | null;
      /** @description For matchmade sessions - reservation tokens for expected players */
      reservations?: components['schemas']['ReservationInfo'][] | null;
      /**
       * Format: date-time
       * @description For matchmade sessions - when reservations expire
       */
      reservationExpiresAt?: string | null;
    };
    /** @description Complete point-in-time game time state for a realm, used in responses and boundary events */
    GameTimeSnapshot: {
      /**
       * Format: uuid
       * @description Realm this snapshot belongs to
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Game service the realm belongs to
       */
      gameServiceId: string;
      /** @description Current game year (0-based from realm epoch) */
      year: number;
      /** @description 0-based index into calendar months */
      monthIndex: number;
      /** @description Month code from calendar template (e.g., "greenleaf") */
      monthCode: string;
      /** @description 1-based day within current month */
      dayOfMonth: number;
      /** @description 1-based day within current year */
      dayOfYear: number;
      /** @description Current game hour (0 to gameHoursPerDay-1) */
      hour: number;
      /** @description Current game minute (0-59) */
      minute: number;
      /** @description Current day period code from calendar (e.g., "dawn", "morning") */
      period: string;
      /** @description True if current period's isDaylight flag is set in the calendar template */
      isDaylight: boolean;
      /** @description Current season code from calendar (e.g., "spring") */
      season: string;
      /** @description Current season ordinal (0-based) */
      seasonIndex: number;
      /**
       * Format: float
       * @description 0.0-1.0 progress through the current season, computed from day-of-season / days-in-season
       */
      seasonProgress: number;
      /**
       * Format: int64
       * @description Absolute game-seconds since realm epoch
       */
      totalGameSecondsSinceEpoch: number;
      /**
       * Format: float
       * @description Current game-seconds per real-second
       */
      timeRatio: number;
      /**
       * Format: date-time
       * @description Real-world UTC timestamp of this snapshot
       */
      timestamp: string;
    };
    /** @description Game service stub name for this session. Use the game service's stubName property (e.g., "my-game"). Use "generic" for non-game-specific sessions. */
    GameType: string;
    /** @description Current garden instance state for a player */
    GardenStateResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for this garden instance
       */
      gardenInstanceId: string;
      /**
       * Format: uuid
       * @description Active seed for this garden session
       */
      seedId: string;
      /**
       * Format: uuid
       * @description Account in the garden
       */
      accountId: string;
      /** @description Current player position */
      position: components['schemas']['Vec3'];
      /** @description Currently active POIs in this garden instance */
      activePois: components['schemas']['PoiSummary'][];
    };
    /** @description Request to generate a complete musical composition */
    GenerateCompositionRequest: {
      /**
       * @description ID of the style to use for generation
       * @example celtic
       */
      styleId: string;
      /**
       * @description Target duration in bars
       * @default 32
       */
      durationBars: number;
      /** @description Key signature (random if not specified) */
      key?: components['schemas']['KeySignature'];
      /** @description Tempo in BPM (uses style default if not specified) */
      tempo?: number;
      /**
       * @description Mood constraint for generation
       * @enum {string|null}
       */
      mood?: 'bright' | 'dark' | 'neutral' | 'melancholic' | 'triumphant' | null;
      /**
       * @description Style-specific tune type (e.g., "reel", "jig" for Celtic)
       * @example reel
       */
      tuneType?: string | null;
      /** @description Random seed for reproducible generation */
      seed?: number | null;
      /**
       * @description Narrative/emotional arc options for storyteller-driven composition.
       *     If omitted, narrative is inferred from mood. When provided, enables
       *     fine-grained control over emotional journey and tension curves.
       */
      narrative?: components['schemas']['NarrativeOptions'];
    };
    /** @description Response containing the generated composition */
    GenerateCompositionResponse: {
      /** @description Unique identifier for the composition */
      compositionId: string;
      /** @description Generated MIDI-JSON output */
      midiJson: components['schemas']['MidiJson'];
      /** @description Metadata about the generation */
      metadata?: components['schemas']['CompositionMetadata'];
      /** @description Time taken to generate in milliseconds */
      generationTimeMs?: number;
      /** @description ID of the narrative template used for composition */
      narrativeUsed?: string | null;
      /** @description Emotional state at each section boundary */
      emotionalJourney?: components['schemas']['EmotionalStateSnapshot'][] | null;
      /** @description Tension values at bar boundaries (0-1 scale) */
      tensionCurve?: number[] | null;
    };
    /** @description Request to generate a melody over harmony */
    GenerateMelodyRequest: {
      /** @description Chord progression to generate melody over */
      harmony: components['schemas']['ChordEvent'][];
      /** @description Style for melodic preferences */
      styleId?: string | null;
      /** @description Pitch range for the melody */
      range?: components['schemas']['PitchRange'];
      /**
       * @description Overall melodic contour
       * @enum {string|null}
       */
      contour?: 'arch' | 'wave' | 'ascending' | 'descending' | 'static' | null;
      /**
       * Format: float
       * @description Note density (0=sparse, 1=dense)
       */
      rhythmDensity?: number | null;
      /**
       * Format: float
       * @description Amount of syncopation
       */
      syncopation?: number | null;
      /** @description Random seed for reproducibility */
      seed?: number | null;
    };
    /** @description Response containing a generated melody */
    GenerateMelodyResponse: {
      /** @description Generated note events */
      notes: components['schemas']['NoteEvent'][];
      /** @description Analysis of the melody */
      analysis?: components['schemas']['MelodyAnalysis'];
    };
    /** @description Request to generate a chord progression */
    GenerateProgressionRequest: {
      /** @description Key for the progression */
      key: components['schemas']['KeySignature'];
      /** @description Number of chords in the progression */
      length: number;
      /** @description Style to use for harmonic preferences */
      styleId?: string | null;
      /** @description Starting chord (roman numeral, e.g., "I") */
      startChord?: string | null;
      /** @description Ending chord (roman numeral, e.g., "I") */
      endChord?: string | null;
      /**
       * @description Cadence type for ending
       * @enum {string|null}
       */
      cadenceType?: 'authentic' | 'half' | 'plagal' | 'deceptive' | null;
      /**
       * @description Allow secondary dominant chords
       * @default true
       */
      allowSecondaryDominants: boolean;
      /**
       * @description Allow borrowed chords from parallel modes
       * @default false
       */
      allowModalInterchange: boolean;
      /** @description Random seed for reproducibility */
      seed?: number | null;
    };
    /** @description Response containing a generated chord progression */
    GenerateProgressionResponse: {
      /** @description Generated chord events */
      chords: components['schemas']['ChordEvent'][];
      /** @description Analysis of the progression */
      analysis?: components['schemas']['ProgressionAnalysis'];
    };
    /** @description Request to get subscriptions for an account */
    GetAccountSubscriptionsRequest: {
      /**
       * Format: uuid
       * @description ID of the account to get subscriptions for
       */
      accountId: string;
      /**
       * @description If true, include cancelled subscriptions
       * @default false
       */
      includeInactive: boolean;
      /**
       * @description If true, include expired subscriptions
       * @default false
       */
      includeExpired: boolean;
    };
    /** @description Request to get achievement progress */
    GetAchievementProgressRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type whose progress is requested */
      entityType: components['schemas']['EntityType'];
      /** @description Specific achievement ID (null for all) */
      achievementId?: string | null;
    };
    /** @description Request for active scenarios */
    GetActiveScenariosRequest: {
      /**
       * Format: uuid
       * @description Character to query
       */
      characterId: string;
    };
    /** @description Active scenario executions */
    GetActiveScenariosResponse: {
      /** @description Active scenario executions */
      executions: components['schemas']['ScenarioExecution'][];
    };
    /** @description Request to retrieve all ancestor types in the hierarchy chain from a relationship type up to the root */
    GetAncestorsRequest: {
      /**
       * Format: uuid
       * @description The relationship type to get ancestors for
       */
      typeId: string;
    };
    /** @description Request to retrieve a compressed archive */
    GetArchiveRequest: {
      /** @description Type of resource */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource
       */
      resourceId: string;
      /**
       * Format: uuid
       * @description Specific version (latest if not specified)
       */
      archiveId?: string | null;
    };
    /** @description Response containing archive data */
    GetArchiveResponse: {
      /** @description Type of resource */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource
       */
      resourceId: string;
      /** @description True if archive exists */
      found: boolean;
      /** @description The archive data (null if not found) */
      archive?: components['schemas']['ResourceArchive'];
    };
    /** @description Request to get an area content config */
    GetAreaContentConfigRequest: {
      /** @description Area code to look up */
      areaCode: string;
      /**
       * Format: uuid
       * @description Game service scope
       */
      gameServiceId: string;
      /** @description Type of collection */
      collectionType: components['schemas']['CollectionType'];
    };
    /** @description Request to retrieve asset metadata and download URL */
    GetAssetRequest: {
      /** @description Asset identifier */
      assetId: string;
      /**
       * @description Version ID or 'latest'
       * @default latest
       */
      version: string;
    };
    /** @description Request payload for getting a character's backstory */
    GetBackstoryRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get backstory for
       */
      characterId: string;
      /** @description Filter by element types (null for all) */
      elementTypes?: components['schemas']['BackstoryElementType'][] | null;
      /**
       * Format: float
       * @description Filter by minimum strength
       */
      minimumStrength?: number | null;
    };
    /** @description Request to get a specific currency balance */
    GetBalanceRequest: {
      /**
       * Format: uuid
       * @description Wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency definition ID
       */
      currencyDefinitionId: string;
    };
    /** @description Detailed balance information */
    GetBalanceResponse: {
      /**
       * Format: uuid
       * @description Wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency definition ID
       */
      currencyDefinitionId: string;
      /** @description Currency code */
      currencyCode: string;
      /**
       * Format: double
       * @description Total balance
       */
      amount: number;
      /**
       * Format: double
       * @description Amount in authorization holds
       */
      lockedAmount: number;
      /**
       * Format: double
       * @description Available balance (amount - lockedAmount)
       */
      effectiveAmount: number;
      /** @description Earn cap status (null if no caps configured) */
      earnCapInfo?: components['schemas']['EarnCapInfo'];
      /** @description Autogain status (null if autogain not enabled) */
      autogainInfo?: components['schemas']['AutogainInfo'];
    };
    /** @description Request to get a blessing by ID */
    GetBlessingRequest: {
      /**
       * Format: uuid
       * @description Blessing to retrieve
       */
      blessingId: string;
    };
    /** @description Request to get a board instance by ID */
    GetBoardRequest: {
      /**
       * Format: uuid
       * @description Board instance identifier
       */
      boardId: string;
    };
    /** @description Request to get a board template by ID */
    GetBoardTemplateRequest: {
      /**
       * Format: uuid
       * @description Board template identifier
       */
      boardTemplateId: string;
    };
    /** @description Request to get the bond for a specific seed. */
    GetBondForSeedRequest: {
      /**
       * Format: uuid
       * @description The seed whose bond to retrieve.
       */
      seedId: string;
    };
    /** @description Request to get partner seed information. */
    GetBondPartnersRequest: {
      /**
       * Format: uuid
       * @description The requesting seed (returns partner info).
       */
      seedId: string;
    };
    /** @description Request to get a bond by ID. */
    GetBondRequest: {
      /**
       * Format: uuid
       * @description The bond to retrieve.
       */
      bondId: string;
    };
    /** @description Request to get breach details */
    GetBreachRequest: {
      /**
       * Format: uuid
       * @description Breach ID
       */
      breachId: string;
    };
    /** @description Request to retrieve bundle metadata and download URL */
    GetBundleRequest: {
      /** @description Human-readable bundle identifier to retrieve */
      bundleId: string;
      /** @description Desired download format (bannou or zip) */
      format?: components['schemas']['BundleFormat'];
    };
    /** @description Request to get a cached compiled behavior */
    GetCachedBehaviorRequest: {
      /** @description Unique identifier for the cached behavior */
      behaviorId: string;
    };
    /** @description Request to get a calendar template by game service and template code */
    GetCalendarRequest: {
      /**
       * Format: uuid
       * @description Game service the calendar belongs to
       */
      gameServiceId: string;
      /** @description Calendar template code */
      templateCode: string;
    };
    /** @description Request to get the capability manifest. */
    GetCapabilityManifestRequest: {
      /**
       * Format: uuid
       * @description The seed whose manifest to retrieve.
       */
      seedId: string;
    };
    /** @description Request to retrieve a character's compressed archive */
    GetCharacterArchiveRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get archive for
       */
      characterId: string;
    };
    /** @description Request payload for retrieving a single character by ID */
    GetCharacterRequest: {
      /**
       * Format: uuid
       * @description ID of the character to retrieve
       */
      characterId: string;
    };
    /** @description Request payload for retrieving all characters within a specific realm */
    GetCharactersByRealmRequest: {
      /**
       * Format: uuid
       * @description Realm ID to query (uses partition key for efficiency)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Filter by species
       */
      speciesId?: string | null;
      /** @description Optional status filter */
      status?: components['schemas']['CharacterStatus'] | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to retrieve all child relationship types for a given parent type */
    GetChildRelationshipTypesRequest: {
      /**
       * Format: uuid
       * @description ID of the parent relationship type
       */
      parentTypeId: string;
      /**
       * @description Include all descendants, not just direct children
       * @default false
       */
      recursive: boolean;
    };
    /** @description Request to get capability manifest for a connected session (debugging endpoint) */
    GetClientCapabilitiesRequest: {
      /**
       * Format: uuid
       * @description Session ID to retrieve capabilities for (must have active WebSocket connection)
       */
      sessionId: string;
      /** @description Optional filter by service name prefix */
      serviceFilter?: string | null;
      /**
       * @description Include additional metadata about each capability
       * @default false
       */
      includeMetadata: boolean;
    };
    /** @description Request to get a collection by ID */
    GetCollectionRequest: {
      /**
       * Format: uuid
       * @description Collection instance identifier
       */
      collectionId: string;
    };
    /** @description Request payload for retrieving combat preferences */
    GetCombatPreferencesRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get combat preferences for
       */
      characterId: string;
    };
    /** @description Request to get completion statistics */
    GetCompletionStatsRequest: {
      /**
       * Format: uuid
       * @description Entity that owns the collection
       */
      ownerId: string;
      /** @description Entity type discriminator */
      ownerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Game service scope
       */
      gameServiceId: string;
      /** @description Type of collection to get stats for */
      collectionType: components['schemas']['CollectionType'];
    };
    /** @description Request to get character data for compression */
    GetCompressDataRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get compress data for
       */
      characterId: string;
    };
    /** @description Request to get consent status for all parties */
    GetConsentStatusRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
    };
    /** @description Response containing consent status for all parties */
    GetConsentStatusResponse: {
      /** @description Consent status per party */
      partiesRequiringConsent: components['schemas']['PartyConsentStatus'][];
      /** @description Number of consents received */
      consentsReceived: number;
      /** @description Number of consents required */
      consentsRequired: number;
      /** @description Whether release can proceed */
      canRelease: boolean;
      /** @description Whether refund can proceed */
      canRefund: boolean;
    };
    /** @description Request to get a container */
    GetContainerRequest: {
      /**
       * Format: uuid
       * @description Container ID to retrieve
       */
      containerId: string;
      /**
       * @description Whether to include item contents
       * @default true
       */
      includeContents: boolean;
    };
    /** @description Request to get a contract instance */
    GetContractInstanceRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
    };
    /** @description Request to get contract status */
    GetContractInstanceStatusRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
    };
    /** @description Request to get contract metadata */
    GetContractMetadataRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
    };
    /** @description Request to get a contract template */
    GetContractTemplateRequest: {
      /**
       * Format: uuid
       * @description Template ID (provide this or code)
       */
      templateId?: string | null;
      /** @description Template code (provide this or templateId) */
      code?: string | null;
    };
    /** @description Request to get the controlling faction for a location */
    GetControllingFactionRequest: {
      /**
       * Format: uuid
       * @description Location to find the controlling faction for
       */
      locationId: string;
    };
    /** @description Request to get a currency definition */
    GetCurrencyDefinitionRequest: {
      /**
       * Format: uuid
       * @description Definition ID (provide this or code)
       */
      definitionId?: string | null;
      /** @description Currency code (provide this or definitionId) */
      code?: string | null;
    };
    /** @description Request to get a map definition */
    GetDefinitionRequest: {
      /**
       * Format: uuid
       * @description Definition ID to retrieve
       */
      definitionId: string;
    };
    /** @description Request to retrieve a deity by code within a game service */
    GetDeityByCodeRequest: {
      /**
       * Format: uuid
       * @description Game service to search within
       */
      gameServiceId: string;
      /** @description Deity code to look up */
      code: string;
    };
    /** @description Request to retrieve a deity by ID */
    GetDeityRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the deity to retrieve
       */
      deityId: string;
    };
    /** @description Request to get deposit status for a party */
    GetDepositStatusRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Party ID
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
    };
    /** @description Response containing party deposit status */
    GetDepositStatusResponse: {
      /** @description Expected assets from this party */
      expectedAssets: components['schemas']['EscrowAsset'][];
      /** @description Actually deposited assets */
      depositedAssets: components['schemas']['EscrowAsset'][];
      /** @description Whether deposit requirement is fulfilled */
      fulfilled: boolean;
      /** @description Deposit token (if not yet used) */
      depositToken?: string | null;
      /**
       * Format: date-time
       * @description Deposit deadline
       */
      depositDeadline?: string | null;
    };
    /** @description Request to get a deity's divinity balance */
    GetDivinityBalanceRequest: {
      /**
       * Format: uuid
       * @description Deity whose balance to retrieve
       */
      deityId: string;
    };
    /** @description Request to get divinity transaction history */
    GetDivinityHistoryRequest: {
      /**
       * Format: uuid
       * @description Deity whose history to retrieve
       */
      deityId: string;
      /**
       * @description Page number for pagination
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 50
       */
      pageSize: number;
    };
    /** @description Request to retrieve a specific document by ID or slug */
    GetDocumentRequest: {
      /** @description Documentation namespace containing the document */
      namespace: string;
      /**
       * Format: uuid
       * @description Unique identifier of the document to retrieve (null if using slug)
       */
      documentId?: string | null;
      /** @description URL-friendly slug of the document to retrieve (null if using documentId) */
      slug?: string | null;
      /**
       * Format: uuid
       * @description Optional session ID for tracking document views (null if not tracking)
       */
      sessionId?: string | null;
      /** @description How deep to fetch related documents (null for no related documents) */
      includeRelated?: components['schemas']['RelatedDepth'];
      /**
       * @description Whether to include full document content
       * @default false
       */
      includeContent: boolean;
      /**
       * @description Whether to render markdown content as HTML
       * @default false
       */
      renderHtml: boolean;
    };
    /** @description Response containing the requested document and optional related documents */
    GetDocumentResponse: {
      /** @description The requested document */
      document: components['schemas']['Document'];
      /** @description List of related documents based on includeRelated depth */
      relatedDocuments?: components['schemas']['DocumentSummary'][];
      /**
       * @description Format of the content field in the response
       * @enum {string}
       */
      contentFormat?: 'markdown' | 'html' | 'none';
    };
    /** @description Request to get unified effects for an entity */
    GetEffectsRequest: {
      /**
       * Format: uuid
       * @description Entity to get effects for
       */
      entityId: string;
      /** @description Entity type discriminator */
      entityType: components['schemas']['EntityType'];
      /**
       * @description Whether to include seed-derived passive effects. Defaults to true because GetEffects is the unified query endpoint designed to return all active effects. Set to false to retrieve only item-based statuses from this endpoint.
       * @default true
       */
      includePassive: boolean;
    };
    /** @description Unified view of all active effects for an entity */
    GetEffectsResponse: {
      /**
       * Format: uuid
       * @description Entity these effects belong to
       */
      entityId: string;
      /** @description Entity type discriminator */
      entityType: components['schemas']['EntityType'];
      /** @description Number of item-based status effects */
      itemBasedCount: number;
      /** @description Number of seed-derived passive effects */
      seedDerivedCount: number;
      /** @description All active effects with source attribution */
      effects: components['schemas']['StatusEffectSummary'][];
    };
    /** @description Request to compute elapsed game-time between two real timestamps */
    GetElapsedGameTimeRequest: {
      /**
       * Format: uuid
       * @description Realm to compute elapsed time for
       */
      realmId: string;
      /**
       * Format: date-time
       * @description Start real-world UTC timestamp
       */
      fromRealTime: string;
      /**
       * Format: date-time
       * @description End real-world UTC timestamp
       */
      toRealTime: string;
    };
    /** @description Elapsed game-time as raw seconds and decomposed calendar units */
    GetElapsedGameTimeResponse: {
      /**
       * Format: int64
       * @description Total game-seconds elapsed between the two real timestamps
       */
      totalGameSeconds: number;
      /** @description Decomposed game days component */
      gameDays: number;
      /** @description Decomposed game hours component (remainder after days) */
      gameHours: number;
      /** @description Decomposed game minutes component (remainder after hours) */
      gameMinutes: number;
    };
    /** @description Request to retrieve an encounter type by code */
    GetEncounterTypeRequest: {
      /** @description Unique code of the encounter type */
      code: string;
    };
    /**
     * @description Request payload for retrieving a character with optional related data.
     *     Each include flag fetches data from its respective service (zero overhead if not requested).
     */
    GetEnrichedCharacterRequest: {
      /**
       * Format: uuid
       * @description ID of the character to retrieve
       */
      characterId: string;
      /**
       * @description Include family relationships from relationship service
       * @default false
       */
      includeFamilyTree: boolean;
    };
    /** @description Request to query an entity's current location */
    GetEntityLocationRequest: {
      /** @description Type of entity (opaque string - character, actor, npc, player, etc.) */
      entityType: string;
      /**
       * Format: uuid
       * @description ID of the entity to look up
       */
      entityId: string;
    };
    /** @description Result of querying an entity's current location. All fields are null if no active presence exists. */
    GetEntityLocationResponse: {
      /**
       * Format: uuid
       * @description ID of the location the entity is currently at (null if no active presence)
       */
      locationId?: string | null;
      /**
       * Format: uuid
       * @description ID of the realm the location belongs to
       */
      realmId?: string | null;
      /**
       * Format: date-time
       * @description When the presence was last reported
       */
      reportedAt?: string | null;
      /** @description Identifier of the last reporter */
      reportedBy?: string | null;
    };
    /** @description Request to get an entity's rank */
    GetEntityRankRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type whose rank is requested */
      entityType: components['schemas']['EntityType'];
    };
    /** @description Request to get an entry template by ID */
    GetEntryTemplateRequest: {
      /**
       * Format: uuid
       * @description Entry template identifier
       */
      entryTemplateId: string;
    };
    /** @description Request to retrieve an escrow agreement by ID */
    GetEscrowRequest: {
      /**
       * Format: uuid
       * @description Escrow ID to retrieve
       */
      escrowId: string;
    };
    /** @description Response containing escrow agreement details */
    GetEscrowResponse: {
      /** @description Escrow agreement details */
      escrow: components['schemas']['EscrowAgreement'];
    };
    /** @description Request payload for getting participants of an event */
    GetEventParticipantsRequest: {
      /**
       * Format: uuid
       * @description ID of the historical event
       */
      eventId: string;
      /** @description Filter by participation role */
      role?: components['schemas']['ParticipationRole'];
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to get exchange rate between currencies */
    GetExchangeRateRequest: {
      /**
       * Format: uuid
       * @description Source currency ID
       */
      fromCurrencyId: string;
      /**
       * Format: uuid
       * @description Target currency ID
       */
      toCurrencyId: string;
    };
    /** @description Exchange rate information */
    GetExchangeRateResponse: {
      /**
       * Format: double
       * @description Conversion rate (from -> to)
       */
      rate: number;
      /**
       * Format: double
       * @description Inverse rate (to -> from)
       */
      inverseRate: number;
      /** @description Base currency code */
      baseCurrency: string;
      /**
       * Format: double
       * @description Source currency rate to base
       */
      fromCurrencyRateToBase: number;
      /**
       * Format: double
       * @description Target currency rate to base
       */
      toCurrencyRateToBase: number;
    };
    /** @description Request to get a faction by code within a game service */
    GetFactionByCodeRequest: {
      /**
       * Format: uuid
       * @description Game service scope for code lookup
       */
      gameServiceId: string;
      /** @description Faction code to look up */
      code: string;
    };
    /** @description Request to get a faction by ID */
    GetFactionRequest: {
      /**
       * Format: uuid
       * @description ID of the faction to retrieve
       */
      factionId: string;
    };
    /** @description Request to get followers of a deity */
    GetFollowersRequest: {
      /**
       * Format: uuid
       * @description Deity whose followers to list
       */
      deityId: string;
      /**
       * @description Page number for pagination
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 50
       */
      pageSize: number;
    };
    /** @description Request to get a specific game session */
    GetGameSessionRequest: {
      /**
       * Format: uuid
       * @description ID of the game session to retrieve
       */
      sessionId: string;
    };
    /** @description Request to get current garden state */
    GetGardenStateRequest: {
      /**
       * Format: uuid
       * @description Account whose garden state to retrieve
       */
      accountId: string;
    };
    /** @description Request to get global supply stats */
    GetGlobalSupplyRequest: {
      /**
       * Format: uuid
       * @description Currency to query
       */
      currencyDefinitionId: string;
    };
    /** @description Global supply statistics */
    GetGlobalSupplyResponse: {
      /**
       * Format: double
       * @description Sum of all positive balances
       */
      totalSupply: number;
      /**
       * Format: double
       * @description Total in wallets
       */
      inCirculation: number;
      /**
       * Format: double
       * @description Locked in escrow
       */
      inEscrow: number;
      /**
       * Format: double
       * @description All-time faucet total
       */
      totalMinted: number;
      /**
       * Format: double
       * @description All-time sink total
       */
      totalBurned: number;
      /**
       * Format: double
       * @description Global supply cap (null if none)
       */
      supplyCap?: number | null;
      /**
       * Format: double
       * @description Remaining supply before cap
       */
      supplyCapRemaining?: number | null;
    };
    /** @description Request to get the current growth phase. */
    GetGrowthPhaseRequest: {
      /**
       * Format: uuid
       * @description The seed whose phase to retrieve.
       */
      seedId: string;
    };
    /** @description Request to get growth data for a seed. */
    GetGrowthRequest: {
      /**
       * Format: uuid
       * @description The seed whose growth to retrieve.
       */
      seedId: string;
    };
    /** @description Request to get hold details */
    GetHoldRequest: {
      /**
       * Format: uuid
       * @description Hold ID
       */
      holdId: string;
    };
    /** @description Request to get an item instance */
    GetItemInstanceRequest: {
      /**
       * Format: uuid
       * @description Instance ID to retrieve
       */
      instanceId: string;
    };
    /** @description Request to get an item template */
    GetItemTemplateRequest: {
      /**
       * Format: uuid
       * @description Template ID (provide this or code+gameId)
       */
      templateId?: string | null;
      /** @description Item code (provide with gameId) */
      code?: string | null;
      /** @description Game service ID (provide with code) */
      gameId?: string | null;
    };
    /** @description Request to get the status of an async metabundle creation job */
    GetJobStatusRequest: {
      /**
       * Format: uuid
       * @description Job ID from the createMetabundle response
       */
      jobId: string;
    };
    /**
     * @description Status of an async metabundle creation job.
     *     When status is 'ready', the response includes the full metabundle details.
     */
    GetJobStatusResponse: {
      /**
       * Format: uuid
       * @description Job identifier
       */
      jobId: string;
      /** @description Human-readable metabundle identifier being created */
      metabundleId: string;
      /**
       * @description Current job status.
       *     - queued: Waiting for processing resources
       *     - processing: Actively being processed
       *     - ready: Completed successfully
       *     - failed: Creation failed
       *     - cancelled: Job was cancelled
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed' | 'cancelled';
      /** @description Progress percentage (0-100) when status is 'processing' */
      progress?: number | null;
      /**
       * Format: uri
       * @description Pre-signed download URL (only when status is 'ready')
       */
      downloadUrl?: string | null;
      /** @description Number of assets in metabundle (when ready) */
      assetCount?: number | null;
      /** @description Number of standalone assets included (when ready) */
      standaloneAssetCount?: number | null;
      /**
       * Format: int64
       * @description Total size in bytes (when ready)
       */
      sizeBytes?: number | null;
      /** @description Provenance data (when ready) */
      sourceBundles?: components['schemas']['SourceBundleReference'][] | null;
      /** @description Error code (when status is 'failed') */
      errorCode?: string | null;
      /** @description Human-readable error description (when status is 'failed') */
      errorMessage?: string | null;
      /**
       * Format: date-time
       * @description When the job was created
       */
      createdAt?: string | null;
      /**
       * Format: date-time
       * @description When the job was last updated
       */
      updatedAt?: string | null;
      /**
       * Format: int64
       * @description Total processing time in milliseconds (when complete)
       */
      processingTimeMs?: number | null;
    };
    /** @description Request to get a license definition by board template ID and code */
    GetLicenseDefinitionRequest: {
      /**
       * Format: uuid
       * @description Board template containing the definition
       */
      boardTemplateId: string;
      /** @description License code to look up */
      code: string;
    };
    /** @description Request to retrieve the full ancestry chain of a location up to the root */
    GetLocationAncestorsRequest: {
      /**
       * Format: uuid
       * @description The location to get ancestors for
       */
      locationId: string;
    };
    /** @description Request to retrieve a location by its code within a specific realm */
    GetLocationByCodeRequest: {
      /** @description Unique code for the location within the realm */
      code: string;
      /**
       * Format: uuid
       * @description Realm ID to scope the code lookup
       */
      realmId: string;
    };
    /** @description Request to retrieve all descendants of a location (children, grandchildren, etc.) */
    GetLocationDescendantsRequest: {
      /**
       * Format: uuid
       * @description The location to get descendants for
       */
      locationId: string;
      /** @description Optional filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /** @description Maximum depth of descendants to return (null = all) */
      maxDepth?: number | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to retrieve a location by its unique identifier */
    GetLocationRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the location
       */
      locationId: string;
    };
    /** @description Request to get matchmaking statistics */
    GetMatchmakingStatsRequest: {
      /** @description Filter by specific queue (null for all queues) */
      queueId?: string | null;
      /** @description Filter by game ID */
      gameId?: string | null;
    };
    /** @description Request to get matchmaking status */
    GetMatchmakingStatusRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the ticket to query
       */
      ticketId: string;
    };
    /** @description Request to get milestone details */
    GetMilestoneRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Milestone code */
      milestoneCode: string;
    };
    /** @description Request to get detailed progress for a specific objective */
    GetObjectiveProgressRequest: {
      /**
       * Format: uuid
       * @description Quest instance
       */
      questInstanceId: string;
      /** @description Objective code */
      objectiveCode: string;
    };
    /** @description Request to get or create a container */
    GetOrCreateContainerRequest: {
      /**
       * Format: uuid
       * @description Owner entity ID
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['ContainerOwnerType'];
      /** @description Container type to find or create */
      containerType: string;
      /** @description Constraint model for new container */
      constraintModel: components['schemas']['ContainerConstraintModel'];
      /** @description Default max slots if creating */
      maxSlots?: number | null;
      /**
       * Format: double
       * @description Default max weight if creating
       */
      maxWeight?: number | null;
      /** @description Default grid width if creating */
      gridWidth?: number | null;
      /** @description Default grid height if creating */
      gridHeight?: number | null;
      /**
       * Format: uuid
       * @description Realm for new container
       */
      realmId?: string | null;
    };
    /** @description Request to get or create a wallet */
    GetOrCreateWalletRequest: {
      /**
       * Format: uuid
       * @description Owner entity ID
       */
      ownerId: string;
      /** @description Type of owner entity */
      ownerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Realm ID for realm-scoped wallets
       */
      realmId?: string | null;
    };
    /** @description Result of get-or-create operation */
    GetOrCreateWalletResponse: {
      /** @description Wallet details */
      wallet: components['schemas']['WalletResponse'];
      /** @description All non-zero balances */
      balances: components['schemas']['BalanceSummary'][];
      /** @description Whether a new wallet was created */
      created: boolean;
    };
    /** @description Request payload for getting a character's event participation */
    GetParticipationRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get participation for
       */
      characterId: string;
      /** @description Filter by event category */
      eventCategory?: components['schemas']['EventCategory'];
      /**
       * Format: float
       * @description Filter by minimum significance
       */
      minimumSignificance?: number | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request payload for retrieving a character's personality */
    GetPersonalityRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get personality for
       */
      characterId: string;
    };
    /** @description Request to get a character's perspective on an encounter */
    GetPerspectiveRequest: {
      /**
       * Format: uuid
       * @description Encounter to get perspective for
       */
      encounterId: string;
      /**
       * Format: uuid
       * @description Character whose perspective to retrieve
       */
      characterId: string;
    };
    /** @description Request to get deployment phase configuration */
    GetPhaseConfigRequest: Record<string, never>;
    /** @description Request to get phase metrics */
    GetPhaseMetricsRequest: Record<string, never>;
    /** @description Request to retrieve a cached plan */
    GetPlanRequest: {
      /**
       * Format: uuid
       * @description ID of the plan to retrieve
       */
      planId: string;
    };
    /** @description Retrieved plan */
    GetPlanResponse: {
      /** @description Whether the plan was found */
      found: boolean;
      /** @description The plan (null if not found) */
      plan?: components['schemas']['ComposeResponse'];
    };
    /** @description Request to retrieve a quest definition by ID or code */
    GetQuestDefinitionRequest: {
      /**
       * Format: uuid
       * @description Definition ID (provide either this or code)
       */
      definitionId?: string | null;
      /** @description Quest code (provide either this or definitionId) */
      code?: string | null;
    };
    /** @description Request to get a player-facing quest log summary */
    GetQuestLogRequest: {
      /**
       * Format: uuid
       * @description Character to get log for
       */
      characterId: string;
    };
    /** @description Request to get details of a quest instance */
    GetQuestRequest: {
      /**
       * Format: uuid
       * @description Quest instance ID
       */
      questInstanceId: string;
    };
    /** @description Request to get details of a specific queue */
    GetQueueRequest: {
      /** @description ID of the queue to retrieve */
      queueId: string;
    };
    /** @description Request to get entries around an entity */
    GetRanksAroundRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /**
       * Format: uuid
       * @description ID of the entity to center on
       */
      entityId: string;
      /** @description Entity type of the anchor entry */
      entityType: components['schemas']['EntityType'];
      /**
       * @description Entries to show before the entity
       * @default 5
       */
      countBefore: number;
      /**
       * @description Entries to show after the entity
       * @default 5
       */
      countAfter: number;
    };
    /** @description Request to get the realm baseline faction */
    GetRealmBaselineRequest: {
      /**
       * Format: uuid
       * @description ID of the realm to get the baseline faction for
       */
      realmId: string;
    };
    /** @description Request to retrieve a realm by its unique code identifier */
    GetRealmByCodeRequest: {
      /** @description Unique code for the realm (e.g., "REALM_1", "REALM_2") */
      code: string;
    };
    /** @description Request to get realm worldstate configuration */
    GetRealmConfigRequest: {
      /**
       * Format: uuid
       * @description Realm to get configuration for
       */
      realmId: string;
    };
    /** @description Request payload for getting participants of an event */
    GetRealmEventParticipantsRequest: {
      /**
       * Format: uuid
       * @description ID of the historical event
       */
      eventId: string;
      /** @description Filter by participation role */
      role?: components['schemas']['RealmEventRole'];
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request payload for getting a realm's lore */
    GetRealmLoreRequest: {
      /**
       * Format: uuid
       * @description ID of the realm to get lore for
       */
      realmId: string;
      /** @description Filter by element types (null for all) */
      elementTypes?: components['schemas']['RealmLoreElementType'][] | null;
      /**
       * Format: float
       * @description Filter by minimum strength
       */
      minimumStrength?: number | null;
    };
    /** @description Request payload for getting a realm's event participation */
    GetRealmParticipationRequest: {
      /**
       * Format: uuid
       * @description ID of the realm to get participation for
       */
      realmId: string;
      /** @description Filter by event category */
      eventCategory?: components['schemas']['RealmEventCategory'];
      /**
       * Format: float
       * @description Filter by minimum impact
       */
      minimumImpact?: number | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to retrieve a specific realm by its unique identifier */
    GetRealmRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the realm
       */
      realmId: string;
    };
    /** @description Request to get the current game time for a realm by its code string */
    GetRealmTimeByCodeRequest: {
      /** @description Realm code string (resolved to realm ID via IRealmClient) */
      realmCode: string;
    };
    /** @description Request to get the current game time for a realm */
    GetRealmTimeRequest: {
      /**
       * Format: uuid
       * @description Realm to get the current game time for
       */
      realmId: string;
    };
    /** @description Request to retrieve a specific relationship by its ID */
    GetRelationshipRequest: {
      /**
       * Format: uuid
       * @description ID of the relationship to retrieve
       */
      relationshipId: string;
    };
    /** @description Request to retrieve a relationship type by its unique code string */
    GetRelationshipTypeByCodeRequest: {
      /** @description Unique code for the relationship type (e.g., "SON", "MOTHER", "FRIEND") */
      code: string;
    };
    /** @description Request to retrieve a relationship type by its unique identifier */
    GetRelationshipTypeRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the relationship type
       */
      relationshipTypeId: string;
    };
    /** @description Request to get all relationships between two specific entities */
    GetRelationshipsBetweenRequest: {
      /**
       * Format: uuid
       * @description ID of the first entity to check relationships for
       */
      entity1Id: string;
      /** @description Type of the first entity */
      entity1Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the second entity to check relationships for
       */
      entity2Id: string;
      /** @description Type of the second entity */
      entity2Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Optional filter by relationship type
       */
      relationshipTypeId?: string | null;
      /**
       * @description Include relationships that have ended
       * @default false
       */
      includeEnded: boolean;
      /**
       * @description Page number for paginated results (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page (max 100)
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to retrieve a room by ID */
    GetRoomRequest: {
      /**
       * Format: uuid
       * @description Room ID to look up
       */
      roomId: string;
    };
    /** @description Request to retrieve a room type by code */
    GetRoomTypeRequest: {
      /** @description Room type code to look up */
      code: string;
      /**
       * Format: uuid
       * @description Game service scope (null for global types)
       */
      gameServiceId?: string | null;
    };
    /** @description Request to retrieve a scenario definition */
    GetScenarioDefinitionRequest: {
      /**
       * Format: uuid
       * @description Scenario ID to retrieve
       */
      scenarioId?: string | null;
      /** @description Scenario code to retrieve (if ID not provided) */
      code?: string | null;
    };
    /** @description Response with scenario definition */
    GetScenarioDefinitionResponse: {
      /** @description Whether the scenario was found */
      found: boolean;
      /** @description The scenario definition (null if not found) */
      scenario?: components['schemas']['ScenarioDefinition'];
    };
    /** @description Request for scenario execution history */
    GetScenarioHistoryRequest: {
      /**
       * Format: uuid
       * @description Character to query
       */
      characterId: string;
      /**
       * @description Max results
       * @default 20
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description Scenario execution history */
    GetScenarioHistoryResponse: {
      /** @description Historical executions */
      executions: components['schemas']['ScenarioExecution'][];
      /** @description Total count for pagination */
      totalCount: number;
    };
    /** @description Request to get current scenario state */
    GetScenarioStateRequest: {
      /**
       * Format: uuid
       * @description Account whose scenario state to retrieve
       */
      accountId: string;
    };
    /** @description Request to retrieve a scene */
    GetSceneRequest: {
      /**
       * Format: uuid
       * @description ID of the scene to retrieve
       */
      sceneId: string;
      /** @description Specific version to retrieve (null = latest) */
      version?: string | null;
      /**
       * @description Whether to resolve and embed referenced scenes
       * @default false
       */
      resolveReferences: boolean;
      /**
       * @description Maximum depth for reference resolution (prevents infinite recursion)
       * @default 3
       */
      maxReferenceDepth: number;
    };
    /** @description Response containing a scene and resolution metadata */
    GetSceneResponse: {
      /** @description The retrieved scene */
      scene: components['schemas']['Scene'];
      /** @description List of resolved references (if resolveReferences was true) */
      resolvedReferences?: components['schemas']['ResolvedReference'][] | null;
      /** @description References that could not be resolved (circular, missing, depth exceeded) */
      unresolvedReferences?: components['schemas']['UnresolvedReference'][] | null;
      /** @description Error messages for reference resolution issues */
      resolutionErrors?: string[] | null;
    };
    /** @description Request to get season information */
    GetSeasonRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /** @description Specific season number (null for current) */
      seasonNumber?: number | null;
    };
    /** @description Request to get seed-derived passive effects for an entity */
    GetSeedEffectsRequest: {
      /**
       * Format: uuid
       * @description Entity to get seed effects for
       */
      entityId: string;
      /** @description Entity type discriminator */
      entityType: components['schemas']['EntityType'];
    };
    /** @description Request to get a seed by ID. */
    GetSeedRequest: {
      /**
       * Format: uuid
       * @description The seed to retrieve.
       */
      seedId: string;
    };
    /** @description Request to get a seed type definition. */
    GetSeedTypeRequest: {
      /** @description The seed type code. */
      seedTypeCode: string;
      /**
       * Format: uuid
       * @description The game service scope. Null for cross-game seed types.
       */
      gameServiceId?: string | null;
    };
    /** @description Request to get seeds by owner. */
    GetSeedsByOwnerRequest: {
      /**
       * Format: uuid
       * @description The owner entity ID.
       */
      ownerId: string;
      /** @description The owner entity type. */
      ownerType: components['schemas']['EntityType'];
      /** @description Filter by seed type. */
      seedTypeCode?: string | null;
      /**
       * @description Whether to include archived seeds.
       * @default false
       */
      includeArchived: boolean;
    };
    /** @description Request to get aggregate sentiment toward another character */
    GetSentimentRequest: {
      /**
       * Format: uuid
       * @description Character whose sentiment to query
       */
      characterId: string;
      /**
       * Format: uuid
       * @description Target character to measure sentiment toward
       */
      targetCharacterId: string;
    };
    /** @description Request to get a service by ID or stub name (provide either one) */
    GetServiceRequest: {
      /**
       * Format: uuid
       * @description ID of the service to retrieve (null if using stubName)
       */
      serviceId?: string | null;
      /** @description Stub name of the service to retrieve (null if using serviceId) */
      stubName?: string | null;
    };
    /** @description Request to get shared garden state for bonded players */
    GetSharedGardenRequest: {
      /**
       * Format: uuid
       * @description Bond ID to look up shared garden state
       */
      bondId: string;
    };
    /** @description Request to retrieve metadata for a specific save slot */
    GetSlotRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Slot name */
      slotName: string;
    };
    /** @description Request to retrieve a snapshot */
    GetSnapshotRequest: {
      /**
       * Format: uuid
       * @description ID of the snapshot to retrieve
       */
      snapshotId: string;
      /**
       * @description Optional filter for which entries to return from the snapshot.
       *     Only entries with matching source types are returned.
       *     If omitted or empty, all entries are returned.
       */
      filterSourceTypes?: string[] | null;
    };
    /** @description Response containing snapshot data */
    GetSnapshotResponse: {
      /**
       * Format: uuid
       * @description ID of the snapshot
       */
      snapshotId: string;
      /** @description True if snapshot exists (hasn't expired) */
      found: boolean;
      /** @description The snapshot data (null if not found/expired) */
      snapshot?: components['schemas']['ResourceSnapshot'];
    };
    /** @description Request to retrieve a species by its unique code identifier */
    GetSpeciesByCodeRequest: {
      /** @description Unique code for the species (e.g., "HUMAN", "ELF", "DWARF") */
      code: string;
    };
    /** @description Request to retrieve a single species by its unique identifier */
    GetSpeciesRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the species
       */
      speciesId: string;
    };
    /** @description Request for service status (currently empty, reserved for future filters) */
    GetStatusRequest: Record<string, never>;
    /** @description Request to get a status template by game service and code */
    GetStatusTemplateByCodeRequest: {
      /**
       * Format: uuid
       * @description Game service the template is scoped to
       */
      gameServiceId: string;
      /** @description Unique status code within this game service */
      code: string;
    };
    /** @description Request to get a status template by ID */
    GetStatusTemplateRequest: {
      /**
       * Format: uuid
       * @description Status template identifier
       */
      statusTemplateId: string;
    };
    /** @description Request to get a style definition */
    GetStyleRequest: {
      /** @description Style ID to retrieve */
      styleId?: string | null;
      /** @description Style name to retrieve (alternative to ID) */
      styleName?: string | null;
    };
    /** @description Request to get a specific subscription */
    GetSubscriptionRequest: {
      /**
       * Format: uuid
       * @description ID of the subscription to retrieve
       */
      subscriptionId: string;
    };
    /** @description Request to get a template by code */
    GetTemplateByCodeRequest: {
      /** @description Template code to look up */
      code: string;
    };
    /** @description Request to get a template by ID */
    GetTemplateRequest: {
      /**
       * Format: uuid
       * @description Template ID to retrieve
       */
      scenarioTemplateId: string;
    };
    /** @description Request to get top leaderboard entries */
    GetTopRanksRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /**
       * @description Number of entries to return
       * @default 100
       */
      count: number;
      /**
       * @description Number of entries to skip
       * @default 0
       */
      offset: number;
    };
    /** @description Request to get transaction history */
    GetTransactionHistoryRequest: {
      /**
       * Format: uuid
       * @description Wallet to query
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Filter by currency
       */
      currencyDefinitionId?: string | null;
      /** @description Filter by transaction types */
      transactionTypes?: components['schemas']['TransactionType'][] | null;
      /**
       * Format: date-time
       * @description Start of date range
       */
      fromDate?: string | null;
      /**
       * Format: date-time
       * @description End of date range
       */
      toDate?: string | null;
      /**
       * @description Results per page
       * @default 50
       */
      limit: number;
      /**
       * @description Result offset
       * @default 0
       */
      offset: number;
    };
    /** @description Paginated transaction history */
    GetTransactionHistoryResponse: {
      /** @description Transaction records */
      transactions: components['schemas']['CurrencyTransactionRecord'][];
      /** @description Total matching transactions */
      totalCount: number;
    };
    /** @description Request to get a transaction by ID */
    GetTransactionRequest: {
      /**
       * Format: uuid
       * @description Transaction ID
       */
      transactionId: string;
    };
    /** @description Request to get transactions by reference */
    GetTransactionsByReferenceRequest: {
      /** @description Reference type */
      referenceType: string;
      /**
       * Format: uuid
       * @description Reference ID
       */
      referenceId: string;
    };
    /** @description Transactions for a reference */
    GetTransactionsByReferenceResponse: {
      /** @description Matching transactions */
      transactions: components['schemas']['CurrencyTransactionRecord'][];
    };
    /** @description Request to get validation rules */
    GetValidationRulesRequest: {
      /** @description Game ID */
      gameId: string;
      /** @description Scene type */
      sceneType: components['schemas']['SceneType'];
    };
    /** @description Response containing validation rules */
    GetValidationRulesResponse: {
      /** @description Game ID */
      gameId: string;
      /** @description Scene type */
      sceneType: components['schemas']['SceneType'];
      /** @description Registered rules (empty if none) */
      rules?: components['schemas']['ValidationRule'][];
    };
    /** @description Request to get a wallet */
    GetWalletRequest: {
      /**
       * Format: uuid
       * @description Wallet ID (provide this or ownerId+ownerType)
       */
      walletId?: string | null;
      /**
       * Format: uuid
       * @description Owner ID (requires ownerType)
       */
      ownerId?: string | null;
      /** @description Owner type (requires ownerId) */
      ownerType?: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Realm ID (required if using ownerId lookup)
       */
      realmId?: string | null;
    };
    /** @description Goal definition for GOAP planning with conditions and priority */
    GoapGoal: {
      /**
       * @description Name of the goal
       * @example satisfy_hunger
       */
      name: string;
      /** @description Human-readable description of the goal */
      description?: string | null;
      /**
       * @description World state conditions that satisfy this goal (literal conditions)
       * @example {
       *       "hunger": "<= 0.3",
       *       "gold": ">= 50"
       *     }
       */
      conditions: {
        [key: string]: string;
      };
      /** @description Priority of this goal relative to others */
      priority: number;
      /** @description World state conditions required to pursue this goal */
      preconditions?: {
        [key: string]: string;
      } | null;
    };
    /** @description Request to generate a GOAP plan to achieve a goal from current world state */
    GoapPlanRequest: {
      /** @description Unique identifier for the agent requesting the plan */
      agentId?: string | null;
      /** @description The goal to achieve through planning */
      goal: components['schemas']['GoapGoal'];
      /**
       * @description Current world state as key-value pairs
       * @example {
       *       "hunger": 0.8,
       *       "gold": 50,
       *       "location": "home"
       *     }
       */
      worldState: {
        [key: string]: unknown;
      };
      /** @description ID of compiled behavior containing GOAP actions */
      behaviorId: string;
      /** @description Options controlling the planning process */
      options?: components['schemas']['GoapPlanningOptions'];
    };
    /** @description Response containing the generated GOAP plan. If no plan could be found, plan is null and failureReason explains why. */
    GoapPlanResponse: {
      /** @description The generated plan if successful */
      plan?: components['schemas']['GoapPlanResult'];
      /** @description Time spent planning in milliseconds */
      planningTimeMs?: number;
      /** @description Number of nodes expanded during A* search */
      nodesExpanded?: number;
      /**
       * @description Reason for planning failure if unsuccessful
       * @example No plan found - goal unreachable
       */
      failureReason?: string | null;
    };
    /** @description Result of GOAP planning containing the ordered sequence of actions to achieve a goal */
    GoapPlanResult: {
      /** @description ID of the goal this plan achieves */
      goalId: string;
      /** @description Ordered sequence of actions to execute */
      actions: components['schemas']['PlannedActionResponse'][];
      /**
       * Format: float
       * @description Total cost of all actions in the plan
       */
      totalCost: number;
    };
    /** @description Options controlling the GOAP planning process including depth and timeout limits */
    GoapPlanningOptions: {
      /**
       * @description Maximum plan depth (number of actions)
       * @default 10
       */
      maxDepth: number;
      /**
       * @description Maximum nodes to expand during search
       * @default 1000
       */
      maxNodes: number;
      /**
       * @description Planning timeout in milliseconds
       * @default 100
       */
      timeoutMs: number;
    };
    /** @description Request to grant a blessing from a deity to an entity */
    GrantBlessingRequest: {
      /**
       * Format: uuid
       * @description Deity granting the blessing
       */
      deityId: string;
      /**
       * Format: uuid
       * @description Entity receiving the blessing
       */
      entityId: string;
      /** @description Type of entity receiving the blessing (e.g., character, account, deity) */
      entityType: components['schemas']['EntityType'];
      /** @description Tier of the blessing (determines cost and storage mechanism) */
      tier: components['schemas']['BlessingTier'];
      /** @description Item template code for the blessing effect */
      itemTemplateCode: string;
      /** @description Why the deity is granting this blessing */
      reason: string;
    };
    /** @description Request to grant/unlock an entry in a collection */
    GrantEntryRequest: {
      /**
       * Format: uuid
       * @description Entity that owns the collection
       */
      ownerId: string;
      /** @description Entity type discriminator */
      ownerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Game service scope
       */
      gameServiceId: string;
      /** @description Entry template code to grant */
      entryCode: string;
      /** @description Type of collection to grant into */
      collectionType: components['schemas']['CollectionType'];
      /** @description Optional initial metadata for the unlocked entry */
      metadata?: components['schemas']['EntryMetadata'] | null;
    };
    /** @description Result of a grant operation */
    GrantEntryResponse: {
      /**
       * Format: uuid
       * @description Entry template that was granted
       */
      entryTemplateId: string;
      /** @description Entry code that was granted */
      code: string;
      /**
       * Format: uuid
       * @description Collection the entry was granted to
       */
      collectionId: string;
      /**
       * Format: uuid
       * @description Item instance created for this entry
       */
      itemInstanceId: string;
      /** @description Whether this entry was already unlocked (idempotent return) */
      alreadyUnlocked: boolean;
      /**
       * Format: date-time
       * @description When the entry was unlocked
       */
      unlockedAt: string;
    };
    /**
     * @description How a successful status grant was resolved.
     *     - granted: new status applied (no prior instance)
     *     - stacked: stack count increased on existing instance
     *     - refreshed: timer reset on existing instance
     *     - replaced: existing instance removed and new one created
     * @enum {string}
     */
    GrantResult: 'granted' | 'stacked' | 'refreshed' | 'replaced';
    /** @description Request to grant a status effect to an entity */
    GrantStatusRequest: {
      /**
       * Format: uuid
       * @description Entity to receive the status effect
       */
      entityId: string;
      /** @description Entity type discriminator (e.g., character, account) */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Game service scope for template lookup
       */
      gameServiceId: string;
      /** @description Status template code to grant */
      statusTemplateCode: string;
      /**
       * Format: uuid
       * @description What granted this status (for cascading removal via remove-by-source)
       */
      sourceId?: string | null;
      /** @description Override the template's default duration in seconds */
      durationOverrideSeconds?: number | null;
      /** @description Arbitrary key-value data passed to contract template values and stored on the status instance. Convention for Divine integration - set metadata.blessingTier to the blessing tier string (e.g., minor, standard, greater, supreme) so the Divine service can query active blessings by tier. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Result of a successful status grant operation */
    GrantStatusResponse: {
      /**
       * Format: uuid
       * @description Status instance that was created or updated
       */
      statusInstanceId: string;
      /** @description Status template code that was granted */
      statusTemplateCode: string;
      /** @description Current stack count after grant */
      stackCount: number;
      /**
       * Format: uuid
       * @description Contract instance managing this status lifecycle (null if not contract-managed)
       */
      contractInstanceId?: string | null;
      /**
       * Format: uuid
       * @description Item instance created in the status container
       */
      itemInstanceId: string;
      /**
       * Format: date-time
       * @description When this status was granted
       */
      grantedAt: string;
      /**
       * Format: date-time
       * @description When this status expires (null for permanent statuses)
       */
      expiresAt?: string | null;
      /** @description How the grant was resolved (granted, stacked, refreshed, replaced) */
      grantResult: components['schemas']['GrantResult'];
    };
    /** @description A position on the board grid (zero-indexed) */
    GridPosition: {
      /** @description Horizontal grid coordinate (zero-indexed) */
      x: number;
      /** @description Vertical grid coordinate (zero-indexed) */
      y: number;
    };
    /**
     * @description Preferred role when fighting in groups. Affects positioning,
     *     target priority, and coordination behavior.
     * @enum {string}
     */
    GroupRole: 'FRONTLINE' | 'SUPPORT' | 'FLANKER' | 'LEADER' | 'SOLO';
    /** @description A single domain-amount pair for batch growth recording. */
    GrowthEntry: {
      /** @description Dot-separated domain path. */
      domain: string;
      /**
       * Format: float
       * @description Growth amount to add.
       */
      amount: number;
    };
    /** @description Defines a growth phase with its threshold. */
    GrowthPhaseDefinition: {
      /** @description Machine-readable phase identifier (e.g., "nascent", "awakening"). */
      phaseCode: string;
      /** @description Human-readable phase label. */
      displayName: string;
      /**
       * Format: float
       * @description Minimum total growth to enter this phase.
       */
      minTotalGrowth: number;
    };
    /** @description Current growth phase information for a seed. */
    GrowthPhaseResponse: {
      /**
       * Format: uuid
       * @description The seed.
       */
      seedId: string;
      /** @description Current phase code. */
      phaseCode: string;
      /** @description Current phase display name. */
      displayName: string;
      /**
       * Format: float
       * @description Current total growth.
       */
      totalGrowth: number;
      /** @description Next phase code, null if at maximum. */
      nextPhaseCode?: string | null;
      /**
       * Format: float
       * @description Growth needed for next phase, null if at maximum.
       */
      nextPhaseThreshold?: number | null;
    };
    /** @description Growth domain data for a seed. */
    GrowthResponse: {
      /**
       * Format: uuid
       * @description The seed this growth belongs to.
       */
      seedId: string;
      /**
       * Format: float
       * @description Aggregate growth across all domains.
       */
      totalGrowth: number;
      /** @description Map of domain path to depth value. Keys are dot-separated (e.g., "combat.melee.sword"). Values are floating-point depth scores. */
      domains: {
        [key: string]: number;
      };
    };
    /** @description Harmonic progression style preferences */
    HarmonyStyle: {
      /**
       * @description Most common cadence type
       * @default authentic
       * @enum {string}
       */
      primaryCadence: 'authentic' | 'plagal' | 'half' | 'deceptive';
      /**
       * Format: float
       * @description Probability of pre-dominant before dominant
       * @default 0.6
       */
      dominantPrepProbability: number;
      /**
       * Format: float
       * @description Probability of secondary dominants
       * @default 0.3
       */
      secondaryDominantProbability: number;
      /**
       * Format: float
       * @description Probability of borrowed chords
       * @default 0.1
       */
      modalInterchangeProbability: number;
      /** @description Common chord progressions as roman numeral strings */
      commonProgressions?: string[] | null;
    };
    /** @description Request to check if an entry is unlocked */
    HasEntryRequest: {
      /**
       * Format: uuid
       * @description Entity that owns the collection
       */
      ownerId: string;
      /** @description Entity type discriminator */
      ownerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Game service scope
       */
      gameServiceId: string;
      /** @description Entry template code to check */
      entryCode: string;
      /** @description Type of collection to check */
      collectionType: components['schemas']['CollectionType'];
    };
    /** @description Result of entry ownership check */
    HasEntryResponse: {
      /** @description Whether the owner has this entry unlocked */
      hasEntry: boolean;
      /**
       * Format: date-time
       * @description When the entry was unlocked (null if not unlocked)
       */
      unlockedAt?: string | null;
    };
    /** @description Individual item check result */
    HasItemResult: {
      /**
       * Format: uuid
       * @description Template checked
       */
      templateId: string;
      /**
       * Format: double
       * @description Required quantity
       */
      required: number;
      /**
       * Format: double
       * @description Available quantity
       */
      available: number;
      /** @description Whether requirement met */
      satisfied: boolean;
    };
    /** @description Request to check for items */
    HasItemsRequest: {
      /**
       * Format: uuid
       * @description Owner to check
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['ContainerOwnerType'];
      /** @description Required items */
      requirements: components['schemas']['ItemRequirement'][];
    };
    /** @description Has items result */
    HasItemsResponse: {
      /** @description Whether all requirements met */
      hasAll: boolean;
      /** @description Per-item results */
      results: components['schemas']['HasItemResult'][];
    };
    /** @description Request to check if two characters have met */
    HasMetRequest: {
      /**
       * Format: uuid
       * @description First character
       */
      characterIdA: string;
      /**
       * Format: uuid
       * @description Second character
       */
      characterIdB: string;
    };
    /** @description Response for has-met check */
    HasMetResponse: {
      /** @description Whether the characters have any recorded encounters */
      hasMet: boolean;
      /** @description Total number of encounters between them */
      encounterCount: number;
    };
    /** @description Request to check if an entity has a specific status */
    HasStatusRequest: {
      /**
       * Format: uuid
       * @description Entity to check
       */
      entityId: string;
      /** @description Entity type discriminator */
      entityType: components['schemas']['EntityType'];
      /** @description Status template code to check for */
      statusCode: string;
    };
    /** @description Result of a status existence check */
    HasStatusResponse: {
      /** @description Whether the entity has this status active */
      hasStatus: boolean;
      /**
       * Format: uuid
       * @description Status instance ID if found (null if not present)
       */
      statusInstanceId?: string | null;
      /** @description Current stack count if found (null if not present) */
      stackCount?: number | null;
    };
    /** @description Information about a hazard in range. Core properties are schema-defined; additionalProperties allows game-specific hazard data. No Bannou plugin reads specific extension keys by convention. */
    HazardInfo: {
      /** @description Type of hazard (fire, poison, radiation, deep_water, etc.) */
      hazardType: string;
      /**
       * Format: float
       * @description Distance to hazard edge
       */
      distance: number;
      /**
       * Format: float
       * @description Hazard severity (0-1)
       */
      severity: number;
      /** @description Direction to hazard center */
      direction?: string | null;
    } & {
      [key: string]: unknown;
    };
    /** @description Request to extend checkout lock */
    HeartbeatRequest: {
      /**
       * Format: uuid
       * @description Scene being edited
       */
      sceneId: string;
      /** @description Checkout token */
      checkoutToken: string;
    };
    /** @description Response confirming lock extension */
    HeartbeatResponse: {
      /** @description Whether extension was successful */
      extended: boolean;
      /**
       * Format: date-time
       * @description New expiration time
       */
      newExpiresAt: string;
      /** @description Number of extensions remaining */
      extensionsRemaining?: number;
    };
    /** @description Record of a character's participation in a historical event */
    HistoricalParticipation: {
      /**
       * Format: uuid
       * @description Unique ID for this participation record
       */
      participationId: string;
      /**
       * Format: uuid
       * @description ID of the character who participated
       */
      characterId: string;
      /**
       * Format: uuid
       * @description ID of the historical event
       */
      eventId: string;
      /** @description Name of the event (for display and summarization) */
      eventName: string;
      /** @description Category of the historical event */
      eventCategory: components['schemas']['EventCategory'];
      /** @description How the character participated */
      role: components['schemas']['ParticipationRole'];
      /**
       * Format: date-time
       * @description In-game date when the event occurred
       */
      eventDate: string;
      /**
       * Format: float
       * @description How significant this event was for the character (0.0 to 1.0).
       *     Affects behavior system weighting of this memory.
       * @default 0.5
       */
      significance: number;
      /** @description Client-provided event-specific details. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When this record was created
       */
      createdAt: string;
    };
    /** @description Request for scene version history */
    HistoryRequest: {
      /**
       * Format: uuid
       * @description Scene to get history for
       */
      sceneId: string;
      /**
       * @description Maximum versions to return
       * @default 10
       */
      limit: number;
    };
    /** @description Scene version history */
    HistoryResponse: {
      /**
       * Format: uuid
       * @description Scene ID
       */
      sceneId: string;
      /** @description Current active version */
      currentVersion?: string;
      /** @description Version history entries */
      versions: components['schemas']['VersionInfo'][];
    };
    /** @description Generated text summaries for character compression */
    HistorySummaryResponse: {
      /**
       * Format: uuid
       * @description ID of the character summarized
       */
      characterId: string;
      /**
       * @description Key backstory elements as text summaries.
       *     e.g., ["Trained by Knights Guild", "Born in the Northlands"]
       */
      keyBackstoryPoints: string[];
      /**
       * @description Major historical events as text summaries.
       *     e.g., ["Fought in the Battle of Stormgate (Hero)", "Survived the Great Flood"]
       */
      majorLifeEvents: string[];
    };
    /** @description Authorization hold record */
    HoldRecord: {
      /**
       * Format: uuid
       * @description Unique hold identifier
       */
      holdId: string;
      /**
       * Format: uuid
       * @description Wallet with held funds
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency held
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount reserved
       */
      amount: number;
      /** @description Current hold status */
      status: components['schemas']['HoldStatus'];
      /**
       * Format: date-time
       * @description When hold was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When hold auto-releases
       */
      expiresAt: string;
      /** @description Reference type */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference ID
       */
      referenceId?: string | null;
      /**
       * Format: double
       * @description Amount actually captured (may differ from held amount)
       */
      capturedAmount?: number | null;
      /**
       * Format: date-time
       * @description When hold was captured/released/expired
       */
      completedAt?: string | null;
    };
    /** @description Hold details */
    HoldResponse: {
      /** @description Hold record */
      hold: components['schemas']['HoldRecord'];
    };
    /**
     * @description Current status of an authorization hold
     * @enum {string}
     */
    HoldStatus: 'active' | 'captured' | 'released' | 'expired';
    /**
     * @description HTTP method for endpoint invocation
     * @enum {string}
     */
    HttpMethodType: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
    /** @description Request to initialize a clock for a realm */
    InitializeRealmClockRequest: {
      /**
       * Format: uuid
       * @description Realm to initialize a clock for
       */
      realmId: string;
      /** @description Calendar template code to use (falls back to DefaultCalendarTemplateCode config if null; BadRequest if both are null) */
      calendarTemplateCode?: string | null;
      /**
       * Format: date-time
       * @description Real-world timestamp to use as the realm epoch (defaults to current time)
       */
      epoch?: string | null;
      /** @description Game year to start at (defaults to 0) */
      startingYear?: number | null;
      /**
       * Format: float
       * @description Initial game-seconds per real-second (falls back to DefaultTimeRatio config)
       */
      timeRatio?: number | null;
      /** @description Initial downtime handling policy (falls back to DefaultDowntimePolicy config) */
      downtimePolicy?: components['schemas']['DowntimePolicy'] | null;
    };
    /** @description Confirmation of realm clock initialization with resolved values */
    InitializeRealmClockResponse: {
      /**
       * Format: uuid
       * @description Realm the clock was initialized for
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Game service the realm belongs to
       */
      gameServiceId: string;
      /** @description Calendar template code in use (resolved from request or config) */
      calendarTemplateCode: string;
      /**
       * Format: float
       * @description Initial game-seconds per real-second (resolved from request or config)
       */
      timeRatio: number;
      /** @description Downtime handling policy (resolved from request or config) */
      downtimePolicy: components['schemas']['DowntimePolicy'];
      /**
       * Format: date-time
       * @description Real-world timestamp of the realm epoch
       */
      epoch: string;
      /** @description Game year the clock started at */
      startingYear: number;
    };
    /** @description Request to initiate a bond between seeds. */
    InitiateBondRequest: {
      /**
       * Format: uuid
       * @description The seed initiating the bond.
       */
      initiatorSeedId: string;
      /**
       * Format: uuid
       * @description The seed being invited to bond.
       */
      targetSeedId: string;
    };
    /** @description Request to inject a perception event into an actor's queue */
    InjectPerceptionRequest: {
      /** @description Target actor to inject perception into */
      actorId: string;
      /** @description Perception data to inject */
      perception: components['schemas']['PerceptionData'];
    };
    /** @description Response confirming perception injection */
    InjectPerceptionResponse: {
      /** @description Current depth of the perception queue */
      queueDepth: number;
    };
    /** @description Request to interact with a POI */
    InteractWithPoiRequest: {
      /**
       * Format: uuid
       * @description Account interacting with the POI
       */
      accountId: string;
      /**
       * Format: uuid
       * @description POI to interact with
       */
      poiId: string;
    };
    /** @description Melodic interval preference weights */
    IntervalPreferences: {
      /**
       * Format: float
       * @description Weight for stepwise motion (M2, m2)
       * @default 0.5
       */
      stepWeight: number;
      /**
       * Format: float
       * @description Weight for thirds (M3, m3)
       * @default 0.25
       */
      thirdWeight: number;
      /**
       * Format: float
       * @description Weight for larger leaps (P4, P5)
       * @default 0.15
       */
      leapWeight: number;
      /**
       * Format: float
       * @description Weight for leaps larger than P5
       * @default 0.1
       */
      largeLeapWeight: number;
    };
    /** @description Request to invalidate a cached behavior */
    InvalidateCacheRequest: {
      /** @description Unique identifier for the cached behavior to invalidate */
      behaviorId: string;
    };
    /** @description Result of cache invalidation and rebuild */
    InvalidateCacheResponse: {
      /**
       * Format: uuid
       * @description Character whose cache was rebuilt
       */
      characterId: string;
      /** @description Number of obligations found and cached */
      obligationsRefreshed: number;
      /** @description Whether the cache rebuild completed successfully */
      success: boolean;
    };
    /**
     * @description Item classification category
     * @enum {string}
     */
    ItemCategory:
      | 'weapon'
      | 'armor'
      | 'accessory'
      | 'consumable'
      | 'material'
      | 'container'
      | 'quest'
      | 'currency_like'
      | 'misc'
      | 'custom';
    /** @description Item instance details */
    ItemInstanceResponse: {
      /**
       * Format: uuid
       * @description Unique instance identifier
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Reference to the item template
       */
      templateId: string;
      /**
       * Format: uuid
       * @description Container holding this item
       */
      containerId: string;
      /**
       * Format: uuid
       * @description Realm this instance exists in
       */
      realmId: string;
      /**
       * Format: double
       * @description Item quantity
       */
      quantity: number;
      /** @description Slot position in slot-based containers */
      slotIndex?: number | null;
      /** @description X position in grid-based containers */
      slotX?: number | null;
      /** @description Y position in grid-based containers */
      slotY?: number | null;
      /** @description Whether item is rotated in grid */
      rotated?: boolean | null;
      /** @description Current durability */
      currentDurability?: number | null;
      /**
       * Format: uuid
       * @description Character ID this item is bound to
       */
      boundToId?: string | null;
      /**
       * Format: date-time
       * @description When item was bound
       */
      boundAt?: string | null;
      /** @description Instance-specific stat modifications. Opaque to Bannou; no plugin reads keys by convention. */
      customStats?: Record<string, never> | null;
      /** @description Player-assigned custom name */
      customName?: string | null;
      /** @description Additional instance-specific data. Opaque to Bannou; no plugin reads keys by convention. */
      instanceMetadata?: Record<string, never> | null;
      /** @description How this item instance was created */
      originType: components['schemas']['ItemOriginType'];
      /**
       * Format: uuid
       * @description Source entity ID
       */
      originId?: string | null;
      /**
       * Format: uuid
       * @description Bound contract instance ID. For persistent item-contract bindings or active
       *     multi-step use sessions, this references the controlling contract.
       */
      contractInstanceId?: string | null;
      /**
       * @description Type of contract binding. 'session' for multi-step use in progress,
       *     'lifecycle' for external orchestrator-managed bindings, null/none otherwise.
       */
      contractBindingType?: components['schemas']['ContractBindingType'];
      /**
       * Format: date-time
       * @description Instance creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last modification timestamp
       */
      modifiedAt?: string | null;
    };
    /**
     * @description How currency is linked to inventory items
     * @enum {string}
     */
    ItemLinkageMode: 'none' | 'visual_only' | 'reference_only';
    /**
     * @description How an item instance was created
     * @enum {string}
     */
    ItemOriginType: 'loot' | 'quest' | 'craft' | 'trade' | 'purchase' | 'spawn' | 'other';
    /**
     * @description Item rarity tier
     * @enum {string}
     */
    ItemRarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary' | 'custom';
    /** @description Required item and quantity */
    ItemRequirement: {
      /**
       * Format: uuid
       * @description Required template
       */
      templateId: string;
      /**
       * Format: double
       * @description Required quantity
       */
      quantity: number;
    };
    /**
     * @description Realm availability scope (consistent with CurrencyScope)
     * @enum {string}
     */
    ItemScope: 'global' | 'realm_specific' | 'multi_realm';
    /** @description Item template details */
    ItemTemplateResponse: {
      /**
       * Format: uuid
       * @description Unique template identifier
       */
      templateId: string;
      /** @description Unique code within the game */
      code: string;
      /** @description Game service this template belongs to */
      gameId: string;
      /** @description Human-readable display name */
      name: string;
      /** @description Detailed description */
      description?: string | null;
      /** @description Item classification category */
      category: components['schemas']['ItemCategory'];
      /** @description Game-defined subcategory */
      subcategory?: string | null;
      /** @description Filtering tags */
      tags: string[];
      /** @description Item rarity tier */
      rarity: components['schemas']['ItemRarity'];
      /** @description How quantities are tracked */
      quantityModel: components['schemas']['QuantityModel'];
      /** @description Maximum stack size */
      maxStackSize: number;
      /** @description Unit for continuous quantities */
      unitOfMeasure?: string | null;
      /** @description Precision for weight values */
      weightPrecision: components['schemas']['WeightPrecision'];
      /**
       * Format: double
       * @description Weight value
       */
      weight?: number | null;
      /**
       * Format: double
       * @description Volume for volumetric inventories
       */
      volume?: number | null;
      /** @description Width in grid-based inventories */
      gridWidth?: number | null;
      /** @description Height in grid-based inventories */
      gridHeight?: number | null;
      /** @description Whether item can be rotated in grid */
      canRotate?: boolean | null;
      /**
       * Format: double
       * @description Reference price
       */
      baseValue?: number | null;
      /** @description Whether item can be traded */
      tradeable: boolean;
      /** @description Whether item can be destroyed */
      destroyable: boolean;
      /** @description Binding behavior type */
      soulboundType: components['schemas']['SoulboundType'];
      /** @description Whether item has durability */
      hasDurability: boolean;
      /** @description Maximum durability value */
      maxDurability?: number | null;
      /** @description Realm availability scope */
      scope: components['schemas']['ItemScope'];
      /** @description Available realms */
      availableRealms?: string[] | null;
      /** @description Game-defined stats. Opaque to Bannou; no plugin reads keys by convention. */
      stats?: Record<string, never> | null;
      /** @description Game-defined effects. Opaque to Bannou; no plugin reads keys by convention. */
      effects?: Record<string, never> | null;
      /** @description Game-defined requirements. Opaque to Bannou; no plugin reads keys by convention. */
      requirements?: Record<string, never> | null;
      /** @description Display properties. Opaque to Bannou; no plugin reads keys by convention. */
      display?: Record<string, never> | null;
      /** @description Additional game-specific data. Opaque to Bannou; no plugin reads keys by convention. */
      metadata?: Record<string, never> | null;
      /**
       * Format: uuid
       * @description Contract template ID for executable item behavior (null if not usable)
       */
      useBehaviorContractTemplateId?: string | null;
      /**
       * Format: uuid
       * @description Contract template for pre-use validation (null if not configured)
       */
      canUseBehaviorContractTemplateId?: string | null;
      /**
       * Format: uuid
       * @description Contract template for use failure handling (null if not configured)
       */
      onUseFailedBehaviorContractTemplateId?: string | null;
      /** @description How the item behaves when used (null defaults to destroy_on_success) */
      itemUseBehavior?: components['schemas']['ItemUseBehavior'];
      /** @description How CanUse validation failures are handled (null defaults to block) */
      canUseBehavior?: components['schemas']['CanUseBehavior'];
      /** @description Whether template is active */
      isActive: boolean;
      /** @description Whether template is deprecated */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description When template was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Reason for deprecation */
      deprecationReason?: string | null;
      /**
       * Format: uuid
       * @description Migration target template
       */
      migrationTargetId?: string | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last update timestamp
       */
      updatedAt: string;
    };
    /**
     * @description Controls item consumption on use.
     *     - disabled: Item cannot be used (/item/use returns 400)
     *     - destroy_on_success: Item consumed only if use behavior succeeds (default)
     *     - destroy_always: Item consumed regardless of success/failure
     * @enum {string}
     */
    ItemUseBehavior: 'disabled' | 'destroy_on_success' | 'destroy_always';
    /** @description Request to join a matchmaking queue */
    JoinMatchmakingRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID for event delivery
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player joining
       */
      accountId: string;
      /** @description ID of the queue to join */
      queueId: string;
      /**
       * Format: uuid
       * @description Party ID if joining as part of a party
       */
      partyId?: string | null;
      /** @description Party member information (required if partyId provided) */
      partyMembers?: components['schemas']['PartyMemberInfo'][] | null;
      /** @description String properties for query matching */
      stringProperties?: {
        [key: string]: string;
      } | null;
      /** @description Numeric properties for query matching */
      numericProperties?: {
        [key: string]: number;
      } | null;
      /** @description Lucene-like query for opponent matching */
      query?: string | null;
      /**
       * Format: uuid
       * @description Tournament ID if joining tournament queue
       */
      tournamentId?: string | null;
    };
    /** @description Response after joining a matchmaking queue */
    JoinMatchmakingResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for this matchmaking ticket
       */
      ticketId: string;
      /** @description Queue that was joined */
      queueId: string;
      /** @description Estimated wait time based on current queue (null if unknown) */
      estimatedWaitSeconds: number | null;
      /** @description Approximate position in queue (null if not tracked) */
      position?: number | null;
    };
    /** @description Request to join a chat room as a participant */
    JoinRoomRequest: {
      /**
       * Format: uuid
       * @description Room ID to join
       */
      roomId: string;
      /** @description Opaque sender type identifier (e.g., "session", "character", "system") */
      senderType?: string | null;
      /**
       * Format: uuid
       * @description Sender entity ID (nullable for anonymous)
       */
      senderId?: string | null;
      /** @description Human-readable display name */
      displayName?: string | null;
      /** @description Requested role (defaults to Member if not specified) */
      role?: components['schemas']['ChatParticipantRole'] | null;
    };
    /**
     * @description JSON Patch operation per RFC 6902.
     *     Uses JsonPatch.Net library (MIT licensed).
     */
    JsonPatchOperation: {
      /**
       * @description Operation type
       * @enum {string}
       */
      op: 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';
      /** @description JSON Pointer to target location */
      path: string;
      /** @description Source path (for move/copy operations) */
      from?: string | null;
      /** @description Value to use (for add/replace/test operations) */
      value?: unknown;
    };
    /** @description A key signature with tonic and mode */
    KeySignature: {
      /** @description Tonic pitch class */
      tonic: components['schemas']['PitchClass'];
      /**
       * @description Mode/scale type
       * @enum {string}
       */
      mode:
        | 'major'
        | 'minor'
        | 'dorian'
        | 'phrygian'
        | 'lydian'
        | 'mixolydian'
        | 'aeolian'
        | 'locrian';
    };
    /** @description A key signature change event */
    KeySignatureEvent: {
      /** @description Tick position */
      tick: number;
      /** @description Tonic pitch class */
      tonic: components['schemas']['PitchClass'];
      /** @description Mode/scale type */
      mode: components['schemas']['ModeType'];
    };
    /** @description Request to remove a participant from a room */
    KickParticipantRequest: {
      /**
       * Format: uuid
       * @description Room ID
       */
      roomId: string;
      /**
       * Format: uuid
       * @description Session ID of participant to kick
       */
      targetSessionId: string;
      /** @description Optional reason for the kick */
      reason?: string | null;
    };
    /** @description Configuration for a specific layer within a map definition */
    LayerDefinition: {
      /** @description The layer kind */
      kind: components['schemas']['MapKind'];
      /**
       * @description How this layer's data should be stored
       * @default cached
       * @enum {string}
       */
      storageMode: 'durable' | 'cached' | 'ephemeral';
      /** @description TTL for cached/ephemeral data (0 = no TTL) */
      ttlSeconds?: number | null;
      /** @description Default non-authority handling for channels using this layer */
      defaultNonAuthorityHandling?: components['schemas']['NonAuthorityHandlingMode'];
      /**
       * Format: double
       * @description Spatial cell size for indexing (default from config if not set)
       */
      cellSize?: number | null;
    };
    /** @description Leaderboard definition details */
    LeaderboardDefinitionResponse: {
      /**
       * Format: uuid
       * @description ID of the owning game service
       */
      gameServiceId: string;
      /** @description Unique identifier for this leaderboard */
      leaderboardId: string;
      /** @description Human-readable name */
      displayName: string;
      /** @description Description of the leaderboard */
      description?: string | null;
      /** @description Allowed entity types */
      entityTypes?: components['schemas']['EntityType'][];
      /** @description Ordering used when ranking scores (descending for high scores, ascending for low) */
      sortOrder: components['schemas']['SortOrder'];
      /** @description Rule applied when new scores are submitted (replace/increment/max/min) */
      updateMode: components['schemas']['UpdateMode'];
      /** @description Whether the leaderboard is seasonal */
      isSeasonal: boolean;
      /** @description Whether the leaderboard is publicly visible */
      isPublic: boolean;
      /** @description Current season number (if seasonal) */
      currentSeason?: number | null;
      /**
       * Format: int64
       * @description Number of entries on the leaderboard
       */
      entryCount?: number;
      /**
       * Format: date-time
       * @description When the leaderboard was created
       */
      createdAt: string;
      /** @description Client-provided leaderboard-specific metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response containing leaderboard entries */
    LeaderboardEntriesResponse: {
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /** @description List of leaderboard entries */
      entries: components['schemas']['LeaderboardEntry'][];
      /**
       * Format: int64
       * @description Total entries on the leaderboard
       */
      totalEntries: number;
    };
    /** @description A single entry on a leaderboard */
    LeaderboardEntry: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type for this leaderboard entry */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: double
       * @description Entity's score
       */
      score: number;
      /**
       * Format: int64
       * @description Entity's rank (1-based)
       */
      rank: number;
      /** @description Cached display name for the entity */
      displayName?: string | null;
      /** @description Client-provided entry metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to leave a specific game session by ID */
    LeaveGameSessionByIdRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the client leaving. Null for server-side cleanup operations (e.g., scenario lifecycle worker) where no real WebSocket session exists.
       */
      webSocketSessionId?: string | null;
      /**
       * Format: uuid
       * @description Account ID of the player leaving.
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the game session to leave.
       */
      gameSessionId: string;
    };
    /** @description Request to leave a game session */
    LeaveGameSessionRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the client leaving. Provided by shortcut system.
       */
      sessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player leaving. Provided by shortcut system.
       */
      accountId: string;
      /** @description Game type being left. Determines which lobby to leave. Provided by shortcut system. */
      gameType: components['schemas']['GameType'];
    };
    /** @description Request to leave the garden */
    LeaveGardenRequest: {
      /**
       * Format: uuid
       * @description Account leaving the garden
       */
      accountId: string;
    };
    /** @description Response after leaving the garden */
    LeaveGardenResponse: {
      /**
       * Format: uuid
       * @description Account that left the garden
       */
      accountId: string;
      /**
       * Format: float
       * @description Total duration of the garden session in seconds
       */
      sessionDurationSeconds: number;
    };
    /** @description Request to leave a matchmaking queue */
    LeaveMatchmakingRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the ticket to cancel
       */
      ticketId: string;
    };
    /** @description Request to leave a chat room */
    LeaveRoomRequest: {
      /**
       * Format: uuid
       * @description Room ID to leave
       */
      roomId: string;
    };
    /** @description License definition with all fields */
    LicenseDefinitionResponse: {
      /**
       * Format: uuid
       * @description Unique license definition identifier
       */
      licenseDefinitionId: string;
      /**
       * Format: uuid
       * @description Board template this definition belongs to
       */
      boardTemplateId: string;
      /** @description Unique license code within this board template */
      code: string;
      /** @description Grid position of this license node */
      position: components['schemas']['GridPosition'];
      /** @description License Point cost to unlock this node */
      lpCost: number;
      /**
       * Format: uuid
       * @description Item template created when this license is unlocked
       */
      itemTemplateId: string;
      /** @description License codes that must be unlocked before this one */
      prerequisites?: string[] | null;
      /** @description Human-readable description of what this license grants */
      description?: string | null;
      /** @description Game-specific metadata for this license node. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When this definition was created
       */
      createdAt: string;
    };
    /**
     * @description Unlock status of a license node on a board.
     *     - locked: Not adjacent to any unlocked node (cannot be unlocked)
     *     - unlockable: Adjacent to an unlocked node or is a starting node (can be unlocked)
     *     - unlocked: Already unlocked (item placed at this position)
     * @enum {string}
     */
    LicenseStatus: 'locked' | 'unlockable' | 'unlocked';
    /** @description Request to list achievement definitions */
    ListAchievementDefinitionsRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description Filter by platform */
      platform?: components['schemas']['Platform'];
      /** @description Filter by achievement classification */
      achievementType?: components['schemas']['AchievementType'];
      /** @description Filter by active status */
      isActive?: boolean | null;
      /**
       * @description Include hidden achievements in response
       * @default false
       */
      includeHidden: boolean;
    };
    /** @description Response containing achievement definitions */
    ListAchievementDefinitionsResponse: {
      /** @description List of achievement definitions */
      achievements: components['schemas']['AchievementDefinitionResponse'][];
    };
    /** @description Request to list action tag mappings with pagination */
    ListActionMappingsRequest: {
      /** @description Optional text search across tag names and descriptions */
      searchTerm?: string | null;
      /** @description Pagination cursor from a previous response */
      cursor?: string | null;
      /**
       * @description Number of mappings to return per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Paginated list of action tag mappings */
    ListActionMappingsResponse: {
      /** @description Action tag mappings for this page */
      mappings: components['schemas']['ActionMappingResponse'][];
      /** @description Cursor for the next page (null if no more pages) */
      nextCursor?: string | null;
      /** @description Whether more pages are available */
      hasMore: boolean;
    };
    /** @description Request to list available archives for a namespace */
    ListArchivesRequest: {
      /** @description Documentation namespace to list archives for */
      namespace: string;
      /**
       * @description Maximum number of archives to return
       * @default 20
       */
      limit: number;
      /**
       * @description Number of archives to skip
       * @default 0
       */
      offset: number;
    };
    /** @description Response containing a paginated list of archives */
    ListArchivesResponse: {
      /** @description List of archives for the namespace */
      archives: components['schemas']['ArchiveInfo'][];
      /** @description Total number of archives */
      total: number;
    };
    /** @description Request to list area content configs for a game service */
    ListAreaContentConfigsRequest: {
      /**
       * Format: uuid
       * @description Game service to list area configs for
       */
      gameServiceId: string;
      /** @description Type of collection to list configs for */
      collectionType: components['schemas']['CollectionType'];
    };
    /** @description List of area content configurations */
    ListAreaContentConfigsResponse: {
      /** @description Area content configurations for this game service */
      configs: components['schemas']['AreaContentConfigResponse'][];
    };
    /** @description Request to list quests available for a character to accept */
    ListAvailableQuestsRequest: {
      /**
       * Format: uuid
       * @description Character to check availability for
       */
      characterId: string;
      /**
       * Format: uuid
       * @description Filter by quest giver
       */
      questGiverCharacterId?: string | null;
      /**
       * Format: uuid
       * @description Filter by game service
       */
      gameServiceId?: string | null;
    };
    /** @description List of quest definitions available for acceptance */
    ListAvailableQuestsResponse: {
      /** @description Available quest definitions */
      available: components['schemas']['QuestDefinitionResponse'][];
    };
    /** @description Request to list blessings granted by a deity */
    ListBlessingsByDeityRequest: {
      /**
       * Format: uuid
       * @description Deity whose granted blessings to list
       */
      deityId: string;
      /** @description Optional tier filter */
      tier?: components['schemas']['BlessingTier'];
      /**
       * @description Page number for pagination
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 50
       */
      pageSize: number;
    };
    /** @description Request to list blessings for an entity */
    ListBlessingsByEntityRequest: {
      /**
       * Format: uuid
       * @description Entity whose blessings to list
       */
      entityId: string;
      /** @description Type of entity (e.g., character, account, deity) */
      entityType: components['schemas']['EntityType'];
      /**
       * @description Page number for pagination
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 50
       */
      pageSize: number;
    };
    /** @description Paginated list of blessings */
    ListBlessingsResponse: {
      /** @description Blessings in the current page */
      blessings: components['schemas']['BlessingSummary'][];
      /** @description Total number of matching blessings */
      totalCount: number;
      /** @description Current page number */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
    };
    /** @description Request to list board templates with cursor-based pagination */
    ListBoardTemplatesRequest: {
      /**
       * Format: uuid
       * @description Filter by game service
       */
      gameServiceId: string;
      /** @description Opaque cursor from previous response. Null for first page. */
      cursor?: string | null;
      /** @description Number of items per page. Uses service default if not specified. */
      pageSize?: number | null;
    };
    /** @description Paginated list of board templates */
    ListBoardTemplatesResponse: {
      /** @description Board templates in this page */
      templates: components['schemas']['BoardTemplateResponse'][];
      /** @description Cursor for next page. Null if no more results. */
      nextCursor?: string | null;
      /** @description Whether more results exist beyond this page */
      hasMore: boolean;
    };
    /** @description Request to list board instances for an owner entity */
    ListBoardsByOwnerRequest: {
      /** @description Type of entity that owns the boards */
      ownerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Entity to list boards for
       */
      ownerId: string;
      /**
       * Format: uuid
       * @description Optional filter by game service
       */
      gameServiceId?: string | null;
    };
    /** @description List of board instances for an owner entity */
    ListBoardsByOwnerResponse: {
      /** @description Board instances for this owner */
      boards: components['schemas']['BoardResponse'][];
    };
    /** @description Request to list bundle version history */
    ListBundleVersionsRequest: {
      /** @description Human-readable bundle identifier to get history for */
      bundleId: string;
      /**
       * @description Maximum versions to return
       * @default 50
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description Bundle version history */
    ListBundleVersionsResponse: {
      /** @description Human-readable bundle identifier */
      bundleId: string;
      /** @description Current version number */
      currentVersion: number;
      /** @description Version history records (newest first) */
      versions: components['schemas']['BundleVersionRecord'][];
      /** @description Total number of versions */
      totalCount: number;
    };
    /** @description Request to list all calendar templates for a game service */
    ListCalendarsRequest: {
      /**
       * Format: uuid
       * @description Game service to list calendars for
       */
      gameServiceId: string;
    };
    /** @description List of calendar templates for a game service */
    ListCalendarsResponse: {
      /** @description Calendar templates for the game service */
      templates: components['schemas']['CalendarTemplateResponse'][];
    };
    /** @description Request payload for listing characters with filtering and pagination */
    ListCharactersRequest: {
      /**
       * Format: uuid
       * @description Realm to list characters from (required for efficiency)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Filter by species
       */
      speciesId?: string | null;
      /** @description Filter by status */
      status?: components['schemas']['CharacterStatus'] | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list clause types */
    ListClauseTypesRequest: {
      /** @description Filter by category */
      category?: components['schemas']['ClauseCategory'];
      /**
       * @description Include built-in types in response
       * @default true
       */
      includeBuiltIn: boolean;
    };
    /** @description Response containing list of clause types */
    ListClauseTypesResponse: {
      /** @description List of registered clause types */
      clauseTypes: components['schemas']['ClauseTypeSummary'][];
    };
    /** @description Request to list registered cleanup callbacks */
    ListCleanupCallbacksRequest: {
      /** @description Filter by resource type (list all if not specified) */
      resourceType?: string | null;
      /** @description Filter by source type (requires resourceType) */
      sourceType?: string | null;
    };
    /** @description List of registered cleanup callbacks */
    ListCleanupCallbacksResponse: {
      /** @description Registered callbacks matching filter */
      callbacks: components['schemas']['CleanupCallbackSummary'][];
      /** @description Total number of callbacks returned */
      totalCount: number;
    };
    /** @description Request to list collections for an owner */
    ListCollectionsRequest: {
      /**
       * Format: uuid
       * @description Entity to list collections for
       */
      ownerId: string;
      /** @description Entity type discriminator */
      ownerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Optional filter by game service
       */
      gameServiceId?: string | null;
    };
    /** @description List of collections for an owner */
    ListCollectionsResponse: {
      /** @description Collection instances for this owner */
      collections: components['schemas']['CollectionResponse'][];
    };
    /** @description Request to list registered compression callbacks */
    ListCompressCallbacksRequest: {
      /** @description Filter by resource type (list all if not specified) */
      resourceType?: string | null;
      /** @description Filter by source type (requires resourceType) */
      sourceType?: string | null;
    };
    /** @description List of registered compression callbacks */
    ListCompressCallbacksResponse: {
      /** @description Registered callbacks matching filter */
      callbacks: components['schemas']['CompressCallbackSummary'][];
      /** @description Total number of callbacks returned */
      totalCount: number;
    };
    /** @description Request to list containers for an owner */
    ListContainersRequest: {
      /**
       * Format: uuid
       * @description Owner entity ID
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['ContainerOwnerType'];
      /** @description Filter by container type */
      containerType?: string | null;
      /**
       * @description Include equipment slot containers
       * @default true
       */
      includeEquipmentSlots: boolean;
      /**
       * Format: uuid
       * @description Filter by realm
       */
      realmId?: string | null;
    };
    /** @description List of containers */
    ListContainersResponse: {
      /** @description List of containers */
      containers: components['schemas']['ContainerResponse'][];
      /** @description Total count */
      totalCount: number;
    };
    /** @description Request to list contract templates with cursor-based pagination. */
    ListContractTemplatesRequest: {
      /**
       * Format: uuid
       * @description Filter by realm (null includes cross-realm templates).
       */
      realmId?: string | null;
      /** @description Filter by active status. */
      isActive?: boolean | null;
      /** @description Search in name and description. */
      searchTerm?: string | null;
      /** @description Opaque cursor from previous response. Null for first page. */
      cursor?: string | null;
      /** @description Number of items per page. Uses service default if not specified. */
      pageSize?: number | null;
    };
    /** @description Paginated list of contract templates. */
    ListContractTemplatesResponse: {
      /** @description Templates in this page. */
      templates: components['schemas']['ContractTemplateResponse'][];
      /** @description Cursor for next page. Null if no more results. */
      nextCursor?: string | null;
      /** @description Whether more results exist beyond this page. */
      hasMore: boolean;
    };
    /** @description Request to list currency definitions */
    ListCurrencyDefinitionsRequest: {
      /**
       * Format: uuid
       * @description Filter by realm availability
       */
      realmId?: string | null;
      /** @description Filter by scope */
      scope?: components['schemas']['CurrencyScope'];
      /**
       * @description Include inactive definitions
       * @default false
       */
      includeInactive: boolean;
      /** @description Filter by base currency flag */
      isBaseCurrency?: boolean | null;
    };
    /** @description List of currency definitions */
    ListCurrencyDefinitionsResponse: {
      /** @description Currency definitions matching filter */
      definitions: components['schemas']['CurrencyDefinitionResponse'][];
    };
    /** @description Request to list map definitions */
    ListDefinitionsRequest: {
      /** @description Filter by name (partial match) */
      nameFilter?: string | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Max results to return
       * @default 50
       */
      limit: number;
    };
    /** @description Response containing list of map definitions */
    ListDefinitionsResponse: {
      /** @description List of definitions */
      definitions?: components['schemas']['MapDefinition'][];
      /** @description Total count matching filter */
      total?: number;
      /** @description Current offset */
      offset?: number;
      /** @description Results limit used */
      limit?: number;
    };
    /** @description Request to list deities with optional filters */
    ListDeitiesRequest: {
      /**
       * Format: uuid
       * @description Game service to list deities for
       */
      gameServiceId: string;
      /** @description Filter by domain code (returns deities with this domain in their influences) */
      domainCode?: string | null;
      /** @description Filter by deity status */
      status?: components['schemas']['DeityStatus'];
      /**
       * @description Page number for pagination
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 50
       */
      pageSize: number;
    };
    /** @description Paginated list of deities */
    ListDeitiesResponse: {
      /** @description Deities in the current page */
      deities: components['schemas']['DeityResponse'][];
      /** @description Total number of matching deities */
      totalCount: number;
      /** @description Current page number */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
    };
    /** @description Request to list documents with optional filtering and pagination */
    ListDocumentsRequest: {
      /** @description Documentation namespace to list documents from */
      namespace: string;
      /** @description Filter to a specific category */
      category?: components['schemas']['DocumentCategory'];
      /** @description Filter by tags (null to skip tag filtering) */
      tags?: string[] | null;
      /**
       * @description Whether documents must match all tags or any tag
       * @default all
       * @enum {string}
       */
      tagsMatch: 'all' | 'any';
      /**
       * Format: date-time
       * @description Filter to documents created after this timestamp
       */
      createdAfter?: string;
      /**
       * Format: date-time
       * @description Filter to documents created before this timestamp
       */
      createdBefore?: string;
      /**
       * Format: date-time
       * @description Filter to documents updated after this timestamp
       */
      updatedAfter?: string;
      /**
       * Format: date-time
       * @description Filter to documents updated before this timestamp
       */
      updatedBefore?: string;
      /**
       * @description Return only document titles without summaries
       * @default false
       */
      titlesOnly: boolean;
      /**
       * @description Page number for pagination
       * @default 1
       */
      page: number;
      /**
       * @description Number of documents per page
       * @default 20
       */
      pageSize: number;
      /** @description Field to sort results by */
      sortBy?: components['schemas']['ListSortField'];
      /**
       * @description Sort order direction
       * @default desc
       * @enum {string}
       */
      sortOrder: 'asc' | 'desc';
    };
    /** @description Response containing a paginated list of documents */
    ListDocumentsResponse: {
      /** @description The namespace that was listed */
      namespace: string;
      /** @description List of documents in the namespace */
      documents: components['schemas']['DocumentSummary'][];
      /** @description Total number of documents matching filters */
      totalCount?: number;
      /** @description Current page number */
      page?: number;
      /** @description Number of documents per page */
      pageSize?: number;
      /** @description Total number of pages available */
      totalPages?: number;
    };
    /** @description Request to list encounter types with optional filtering */
    ListEncounterTypesRequest: {
      /**
       * @description Include soft-deleted types
       * @default false
       */
      includeInactive: boolean;
      /**
       * @description Only return built-in types
       * @default false
       */
      builtInOnly: boolean;
      /**
       * @description Only return custom types
       * @default false
       */
      customOnly: boolean;
    };
    /** @description Request to list entities at a specific location */
    ListEntitiesAtLocationRequest: {
      /**
       * Format: uuid
       * @description ID of the location to query
       */
      locationId: string;
      /** @description Optional filter by entity type (opaque string) */
      entityType?: string | null;
      /**
       * @description Page number (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of entities per page
       * @default 50
       */
      pageSize: number;
    };
    /** @description Result of listing entities at a location */
    ListEntitiesAtLocationResponse: {
      /** @description Entities currently present at the location */
      entities: components['schemas']['EntityPresenceEntry'][];
      /** @description Total number of entities matching the query */
      totalCount: number;
      /**
       * Format: uuid
       * @description ID of the queried location
       */
      locationId: string;
    };
    /** @description Request to list entry templates with filtering and pagination */
    ListEntryTemplatesRequest: {
      /** @description Filter by collection type */
      collectionType: components['schemas']['CollectionType'];
      /**
       * Format: uuid
       * @description Filter by game service
       */
      gameServiceId: string;
      /** @description Optional filter by category */
      category?: string | null;
      /** @description Opaque cursor from previous response for pagination */
      cursor?: string | null;
      /** @description Number of items per page (uses service default if not specified) */
      pageSize?: number | null;
    };
    /** @description Paginated list of entry templates */
    ListEntryTemplatesResponse: {
      /** @description Entry templates in this page */
      templates: components['schemas']['EntryTemplateResponse'][];
      /** @description Cursor for next page (null if no more results) */
      nextCursor?: string | null;
      /** @description Whether more results exist beyond this page */
      hasMore: boolean;
    };
    /** @description Request to list escrow agreements with optional filters */
    ListEscrowsRequest: {
      /**
       * Format: uuid
       * @description Filter by party
       */
      partyId?: string | null;
      /** @description Party type filter */
      partyType?: components['schemas']['EntityType'] | null;
      /** @description Filter by status */
      status?: components['schemas']['EscrowStatus'][] | null;
      /** @description Filter by reference type */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Filter by reference ID
       */
      referenceId?: string | null;
      /**
       * Format: date-time
       * @description Filter from date
       */
      fromDate?: string | null;
      /**
       * Format: date-time
       * @description Filter to date
       */
      toDate?: string | null;
      /** @description Limit results */
      limit?: number | null;
      /** @description Offset for pagination */
      offset?: number | null;
    };
    /** @description Response containing list of escrow agreements */
    ListEscrowsResponse: {
      /** @description List of escrow agreements matching the query */
      escrows: components['schemas']['EscrowAgreement'][];
      /** @description Total count for pagination */
      totalCount: number;
    };
    /** @description Request to list factions with filters */
    ListFactionsRequest: {
      /**
       * Format: uuid
       * @description Filter by game service
       */
      gameServiceId?: string | null;
      /**
       * Format: uuid
       * @description Filter by realm
       */
      realmId?: string | null;
      /** @description Filter by lifecycle status */
      status?: components['schemas']['FactionStatus'];
      /**
       * Format: uuid
       * @description Filter by parent faction (null returns top-level factions only when isTopLevelOnly is true)
       */
      parentFactionId?: string | null;
      /**
       * @description When true, returns only factions with no parent
       * @default false
       */
      isTopLevelOnly: boolean;
      /** @description Filter by realm baseline status */
      isRealmBaseline?: boolean | null;
      /** @description Pagination cursor from a previous response */
      cursor?: string | null;
      /**
       * @description Number of factions to return per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Paginated list of factions */
    ListFactionsResponse: {
      /** @description Factions for this page */
      factions: components['schemas']['FactionResponse'][];
      /** @description Cursor for the next page (null if no more pages) */
      nextCursor?: string | null;
      /** @description Whether more pages are available */
      hasMore: boolean;
    };
    /** @description Paginated list of deity followers */
    ListFollowersResponse: {
      /** @description Followers in the current page */
      followers: components['schemas']['FollowerResponse'][];
      /** @description Total number of followers */
      totalCount: number;
      /** @description Current page number */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
    };
    /** @description Request to list item templates */
    ListItemTemplatesRequest: {
      /** @description Filter by game service */
      gameId?: string | null;
      /** @description Filter by item category */
      category?: components['schemas']['ItemCategory'];
      /** @description Filter by subcategory */
      subcategory?: string | null;
      /** @description Filter by tags (items must have all specified tags) */
      tags?: string[] | null;
      /** @description Filter by rarity tier */
      rarity?: components['schemas']['ItemRarity'];
      /** @description Filter by realm scope */
      scope?: components['schemas']['ItemScope'];
      /**
       * Format: uuid
       * @description Filter by realm availability
       */
      realmId?: string | null;
      /**
       * @description Include inactive templates
       * @default false
       */
      includeInactive: boolean;
      /**
       * @description Include deprecated templates
       * @default false
       */
      includeDeprecated: boolean;
      /** @description Search in name and description */
      search?: string | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results to return
       * @default 50
       */
      limit: number;
    };
    /** @description Paginated list of item templates */
    ListItemTemplatesResponse: {
      /** @description List of templates */
      templates: components['schemas']['ItemTemplateResponse'][];
      /** @description Total number of matching templates */
      totalCount: number;
    };
    /** @description Request to list items in a container */
    ListItemsByContainerRequest: {
      /**
       * Format: uuid
       * @description Container to list items from
       */
      containerId: string;
    };
    /** @description List of item instances */
    ListItemsResponse: {
      /** @description List of items */
      items: components['schemas']['ItemInstanceResponse'][];
      /** @description Total number of matching items (actual count, may exceed items returned) */
      totalCount: number;
      /**
       * @description True if the result was truncated due to MaxInstancesPerQuery limit
       * @default false
       */
      wasTruncated: boolean;
    };
    /** @description Request to list all license definitions for a board template */
    ListLicenseDefinitionsRequest: {
      /**
       * Format: uuid
       * @description Board template to list definitions for
       */
      boardTemplateId: string;
    };
    /** @description All license definitions for a board template */
    ListLicenseDefinitionsResponse: {
      /**
       * Format: uuid
       * @description Board template these definitions belong to
       */
      boardTemplateId: string;
      /** @description All license definitions for this board template */
      definitions: components['schemas']['LicenseDefinitionResponse'][];
    };
    /** @description Request to list all child locations of a specified parent location */
    ListLocationsByParentRequest: {
      /**
       * Format: uuid
       * @description ID of the parent location
       */
      parentLocationId: string;
      /** @description Optional filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list all locations within a specific realm with optional filtering */
    ListLocationsByRealmRequest: {
      /**
       * Format: uuid
       * @description Realm ID to query
       */
      realmId: string;
      /** @description Optional type filter */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list locations within a realm with optional type and deprecation filtering */
    ListLocationsRequest: {
      /**
       * Format: uuid
       * @description Realm ID to query (required - locations are partitioned by realm)
       */
      realmId: string;
      /** @description Filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list members of a faction */
    ListMembersRequest: {
      /**
       * Format: uuid
       * @description Faction to list members for
       */
      factionId: string;
      /** @description Filter by role */
      role?: components['schemas']['FactionMemberRole'];
      /** @description Pagination cursor from a previous response */
      cursor?: string | null;
      /**
       * @description Number of members to return per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Paginated list of faction members */
    ListMembersResponse: {
      /** @description Members for this page */
      members: components['schemas']['FactionMemberResponse'][];
      /** @description Cursor for the next page (null if no more pages) */
      nextCursor?: string | null;
      /** @description Whether more pages are available */
      hasMore: boolean;
    };
    /** @description Request to list a character's faction memberships */
    ListMembershipsByCharacterRequest: {
      /**
       * Format: uuid
       * @description Character to list memberships for
       */
      characterId: string;
      /**
       * Format: uuid
       * @description Filter by game service
       */
      gameServiceId?: string | null;
    };
    /** @description All faction memberships for a character */
    ListMembershipsByCharacterResponse: {
      /**
       * Format: uuid
       * @description Character these memberships belong to
       */
      characterId: string;
      /** @description All faction memberships for the character */
      memberships: components['schemas']['CharacterMembershipEntry'][];
    };
    /** @description Request to list norms defined by a faction */
    ListNormsRequest: {
      /**
       * Format: uuid
       * @description Faction to list norms for
       */
      factionId: string;
      /** @description Filter by severity level */
      severity?: components['schemas']['NormSeverity'];
      /** @description Filter by scope */
      scope?: components['schemas']['NormScope'];
    };
    /** @description List of norm definitions for a faction */
    ListNormsResponse: {
      /**
       * Format: uuid
       * @description Faction these norms belong to
       */
      factionId: string;
      /** @description All matching norm definitions */
      norms: components['schemas']['NormDefinitionResponse'][];
    };
    /** @description Request to list participants in a room */
    ListParticipantsRequest: {
      /**
       * Format: uuid
       * @description Room ID to list participants for
       */
      roomId: string;
    };
    /** @description Request to list cached plans */
    ListPlansRequest: {
      /**
       * Format: uuid
       * @description Filter by realm (optional)
       */
      realmId?: string | null;
      /**
       * @description Maximum plans to return
       * @default 20
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description List of plans */
    ListPlansResponse: {
      /** @description Plan summaries */
      plans: components['schemas']['PlanSummary'][];
      /** @description Total matching plans */
      totalCount: number;
    };
    /** @description Request to list active POIs */
    ListPoisRequest: {
      /**
       * Format: uuid
       * @description Account whose POIs to list
       */
      accountId: string;
    };
    /** @description List of active POIs in a garden instance */
    ListPoisResponse: {
      /**
       * Format: uuid
       * @description Garden instance these POIs belong to
       */
      gardenInstanceId: string;
      /** @description Active POIs */
      pois: components['schemas']['PoiSummary'][];
    };
    /** @description Request to list quest definitions with optional filtering */
    ListQuestDefinitionsRequest: {
      /**
       * Format: uuid
       * @description Filter by game service
       */
      gameServiceId?: string | null;
      /** @description Filter by quest category */
      category?: components['schemas']['QuestCategory'] | null;
      /** @description Filter by difficulty rating */
      difficulty?: components['schemas']['QuestDifficulty'] | null;
      /** @description Filter by tags (any match) */
      tags?: string[] | null;
      /**
       * @description Include deprecated definitions
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Max results
       * @default 50
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description Paginated list of quest definitions */
    ListQuestDefinitionsResponse: {
      /** @description List of definitions */
      definitions: components['schemas']['QuestDefinitionResponse'][];
      /** @description Total count for pagination */
      total: number;
    };
    /** @description Request to list quests for a character with optional status filtering */
    ListQuestsRequest: {
      /**
       * Format: uuid
       * @description Character to list quests for
       */
      characterId: string;
      /** @description Filter by statuses (null for all) */
      statuses?: components['schemas']['QuestStatus'][] | null;
      /**
       * @description Max results
       * @default 50
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description Paginated list of quest instances */
    ListQuestsResponse: {
      /** @description Quest instances */
      quests: components['schemas']['QuestInstanceResponse'][];
      /** @description Total count */
      total: number;
    };
    /** @description Request to list available matchmaking queues */
    ListQueuesRequest: {
      /** @description Filter by game ID (null for all games) */
      gameId?: string | null;
      /**
       * @description Include disabled queues in the list (admin only)
       * @default false
       */
      includeDisabled: boolean;
    };
    /** @description Response containing available matchmaking queues */
    ListQueuesResponse: {
      /** @description List of available queues */
      queues: components['schemas']['QueueSummary'][];
    };
    /** @description Request to list active realm clocks with optional filtering */
    ListRealmClocksRequest: {
      /**
       * Format: uuid
       * @description Filter by game service ID (null returns all)
       */
      gameServiceId?: string | null;
      /**
       * @description Page number (0-indexed)
       * @default 0
       */
      page: number;
      /**
       * @description Items per page
       * @default 100
       */
      pageSize: number;
    };
    /** @description Paginated list of active realm clocks */
    ListRealmClocksResponse: {
      /** @description Realm clock summaries for the current page */
      items: components['schemas']['RealmClockSummary'][];
      /** @description Total matching realm clocks */
      totalCount: number;
      /** @description Current page number */
      page: number;
      /** @description Items per page */
      pageSize: number;
    };
    /** @description Request to list realms with optional filtering and pagination */
    ListRealmsRequest: {
      /** @description Filter by category (e.g., "MAIN", "SPECIAL", "TEST") */
      category?: string | null;
      /** @description Filter by active status */
      isActive?: boolean | null;
      /**
       * @description Whether to include deprecated realms in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of realms to return per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list all references to a resource */
    ListReferencesRequest: {
      /** @description Type of resource to list references for (opaque identifier) */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource to list references for
       */
      resourceId: string;
      /** @description Optional filter by source type (opaque identifier) */
      filterSourceType?: string | null;
      /**
       * @description Maximum references to return
       * @default 100
       */
      limit: number;
    };
    /** @description Response containing list of references to a resource */
    ListReferencesResponse: {
      /** @description Type of resource listed */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource listed
       */
      resourceId: string;
      /** @description List of references */
      references: components['schemas']['ResourceReference'][];
      /** @description Total reference count (may exceed returned list if limit applied) */
      totalCount: number;
    };
    /** @description Request to list relationship types with optional filtering by category, hierarchy, and deprecation status */
    ListRelationshipTypesRequest: {
      /** @description Filter by category (e.g., "FAMILY", "SOCIAL", "ECONOMIC") (null to include all) */
      category?: string | null;
      /**
       * @description Only return types with no parent (root types)
       * @default false
       */
      rootsOnly: boolean;
      /**
       * @description Whether to include deprecated types in the response
       * @default false
       */
      includeDeprecated: boolean;
    };
    /** @description Request to list all relationships for a specific entity with optional filters */
    ListRelationshipsByEntityRequest: {
      /**
       * Format: uuid
       * @description ID of the entity to get relationships for
       */
      entityId: string;
      /** @description Type of the entity to get relationships for */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Optional filter by relationship type
       */
      relationshipTypeId?: string | null;
      /** @description Optional filter by the other entity's type */
      otherEntityType?: components['schemas']['EntityType'];
      /**
       * @description Include relationships that have ended
       * @default false
       */
      includeEnded: boolean;
      /**
       * @description Page number for paginated results (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page (max 100)
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list all relationships of a specific relationship type */
    ListRelationshipsByTypeRequest: {
      /**
       * Format: uuid
       * @description Relationship type to filter by
       */
      relationshipTypeId: string;
      /** @description Optional filter by entity1 type */
      entity1Type?: components['schemas']['EntityType'];
      /** @description Optional filter by entity2 type */
      entity2Type?: components['schemas']['EntityType'];
      /**
       * @description Include relationships that have ended
       * @default false
       */
      includeEnded: boolean;
      /**
       * @description Page number for paginated results (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page (max 100)
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list all repository bindings with optional filtering */
    ListRepositoryBindingsRequest: {
      /** @description Filter by binding status */
      status?: components['schemas']['BindingStatus'];
      /**
       * @description Maximum number of bindings to return
       * @default 50
       */
      limit: number;
      /**
       * @description Number of bindings to skip
       * @default 0
       */
      offset: number;
    };
    /** @description Response containing a list of repository bindings */
    ListRepositoryBindingsResponse: {
      /** @description List of repository bindings */
      bindings: components['schemas']['RepositoryBindingInfo'][];
      /** @description Total number of bindings matching filter */
      total: number;
    };
    /** @description Request to list room types with optional filters and pagination */
    ListRoomTypesRequest: {
      /**
       * Format: uuid
       * @description Filter by game service scope
       */
      gameServiceId?: string | null;
      /** @description Filter by message format */
      messageFormat?: components['schemas']['MessageFormat'] | null;
      /** @description Filter by status */
      status?: components['schemas']['RoomTypeStatus'] | null;
      /**
       * @description Page number (zero-based)
       * @default 0
       */
      page: number;
      /**
       * @description Number of items per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Paginated list of room type definitions */
    ListRoomTypesResponse: {
      /** @description Room type definitions matching the filter */
      items: components['schemas']['RoomTypeResponse'][];
      /** @description Total number of matching room types */
      totalCount: number;
      /** @description Current page number */
      page: number;
      /** @description Items per page */
      pageSize: number;
    };
    /** @description Request to list rooms with optional filters and pagination */
    ListRoomsRequest: {
      /** @description Filter by room type code */
      roomTypeCode?: string | null;
      /**
       * Format: uuid
       * @description Filter by Connect session ID
       */
      sessionId?: string | null;
      /** @description Filter by room status */
      status?: components['schemas']['ChatRoomStatus'] | null;
      /**
       * @description Page number (zero-based)
       * @default 0
       */
      page: number;
      /**
       * @description Number of items per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Paginated list of chat rooms */
    ListRoomsResponse: {
      /** @description Rooms matching the filter */
      items: components['schemas']['ChatRoomResponse'][];
      /** @description Total number of matching rooms */
      totalCount: number;
      /** @description Current page number */
      page: number;
      /** @description Items per page */
      pageSize: number;
    };
    /** @description Request to list all top-level locations (without parents) in a realm */
    ListRootLocationsRequest: {
      /**
       * Format: uuid
       * @description Realm ID to get root locations for
       */
      realmId: string;
      /** @description Optional filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list scenario definitions */
    ListScenarioDefinitionsRequest: {
      /**
       * Format: uuid
       * @description Filter by realm
       */
      realmId?: string | null;
      /**
       * Format: uuid
       * @description Filter by game service
       */
      gameServiceId?: string | null;
      /** @description Filter by tags (OR logic) */
      tags?: string[] | null;
      /**
       * @description Include deprecated scenarios
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Maximum scenarios to return
       * @default 20
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description List of scenario definitions */
    ListScenarioDefinitionsResponse: {
      /** @description Scenario definition summaries */
      scenarios: components['schemas']['ScenarioDefinitionSummary'][];
      /** @description Total matching scenarios */
      totalCount: number;
    };
    /** @description Request to list scenes with optional filters */
    ListScenesRequest: {
      /** @description Filter by game ID */
      gameId?: string | null;
      /** @description Filter by single scene type */
      sceneType?: components['schemas']['SceneType'];
      /** @description Filter by multiple scene types (OR) */
      sceneTypes?: components['schemas']['SceneType'][] | null;
      /** @description Filter by tags (scenes must have ALL specified tags) */
      tags?: string[] | null;
      /** @description Filter by name containing this substring (case-insensitive) */
      nameContains?: string | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results to return
       * @default 50
       */
      limit: number;
    };
    /** @description Response containing scene list and pagination info */
    ListScenesResponse: {
      /** @description List of scene summaries (not full documents) */
      scenes: components['schemas']['SceneSummary'][];
      /** @description Total number of matching scenes */
      total: number;
      /** @description Current offset */
      offset?: number;
      /** @description Applied limit */
      limit?: number;
    };
    /** @description Request to list all registered schemas for a namespace */
    ListSchemasRequest: {
      /** @description Schema namespace to list */
      namespace: string;
    };
    /** @description List of registered schemas with latest version indicator */
    ListSchemasResponse: {
      /** @description Registered schemas */
      schemas: components['schemas']['SchemaResponse'][];
      /** @description Latest schema version */
      latestVersion?: string | null;
    };
    /** @description Request to list seed types, optionally filtered by game service. */
    ListSeedTypesRequest: {
      /**
       * Format: uuid
       * @description Game service to filter seed types for. Null returns cross-game types.
       */
      gameServiceId?: string | null;
      /**
       * @description Whether to include deprecated seed types in the response.
       * @default false
       */
      includeDeprecated: boolean;
    };
    /** @description List of registered seed types. */
    ListSeedTypesResponse: {
      /** @description Registered seed types. */
      seedTypes: components['schemas']['SeedTypeResponse'][];
    };
    /** @description Request to list seeds with optional filters. */
    ListSeedsRequest: {
      /** @description Filter by seed type. */
      seedTypeCode?: string | null;
      /** @description Filter by owner type. */
      ownerType?: components['schemas']['EntityType'] | null;
      /**
       * Format: uuid
       * @description Filter by game service.
       */
      gameServiceId?: string | null;
      /** @description Filter by current growth phase code. */
      growthPhase?: string | null;
      /** @description Filter by seed status. */
      status?: components['schemas']['SeedStatus'];
      /**
       * @description Page number (1-based).
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page.
       * @default 50
       */
      pageSize: number;
    };
    /** @description Paginated list of seeds. */
    ListSeedsResponse: {
      /** @description Seeds matching the query. */
      seeds: components['schemas']['SeedResponse'][];
      /** @description Total matching seeds across all pages. */
      totalCount: number;
    };
    /** @description Request to list all game services with optional pagination */
    ListServicesRequest: {
      /**
       * @description If true, only return active services
       * @default false
       */
      activeOnly: boolean;
      /**
       * @description Number of services to skip for pagination (offset)
       * @default 0
       */
      skip: number;
      /**
       * @description Maximum number of services to return (limit)
       * @default 50
       */
      take: number;
    };
    /** @description Response containing list of game services */
    ListServicesResponse: {
      /** @description List of game services matching the request criteria */
      services: components['schemas']['ServiceInfo'][];
      /** @description Total number of services matching the filter */
      totalCount: number;
    };
    /** @description Request to list all save slots belonging to a specific owner */
    ListSlotsRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns the save slots to list */
      ownerType: components['schemas']['EntityType'];
      /** @description Optional filter by save category */
      category?: components['schemas']['SaveCategory'] | null;
      /**
       * @description Include version count in response
       * @default true
       */
      includeVersionCount: boolean;
    };
    /** @description Response containing a list of save slots for an owner */
    ListSlotsResponse: {
      /** @description List of slots */
      slots: components['schemas']['SlotResponse'][];
      /** @description Total number of slots for owner */
      totalCount?: number;
    };
    /**
     * @description Fields available for sorting document lists
     * @default updated_at
     * @enum {string}
     */
    ListSortField: 'created_at' | 'updated_at' | 'title';
    /** @description Request to list species available within a specific realm */
    ListSpeciesByRealmRequest: {
      /**
       * Format: uuid
       * @description ID of the realm to filter by
       */
      realmId: string;
      /** @description Filter by playable status */
      isPlayable?: boolean | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of items per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list species with optional filtering and pagination */
    ListSpeciesRequest: {
      /** @description Filter by category (e.g., "HUMANOID", "BEAST", "MAGICAL") */
      category?: string | null;
      /** @description Filter by playable status */
      isPlayable?: boolean | null;
      /**
       * @description Whether to include deprecated species in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of items per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list status templates with filtering and pagination */
    ListStatusTemplatesRequest: {
      /**
       * Format: uuid
       * @description Filter by game service
       */
      gameServiceId: string;
      /** @description Optional filter by status category */
      category?: components['schemas']['StatusCategory'] | null;
      /**
       * @description Page number (one-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of items per page
       * @default 50
       */
      pageSize: number;
    };
    /** @description Paginated list of status templates */
    ListStatusTemplatesResponse: {
      /** @description Status templates in this page */
      templates: components['schemas']['StatusTemplateResponse'][];
      /** @description Total number of templates matching the filter */
      totalCount: number;
      /** @description Current page number */
      page: number;
      /** @description Number of items per page */
      pageSize: number;
    };
    /** @description Request to list active statuses for an entity */
    ListStatusesRequest: {
      /**
       * Format: uuid
       * @description Entity to list statuses for
       */
      entityId: string;
      /** @description Entity type discriminator */
      entityType: components['schemas']['EntityType'];
      /** @description Optional filter by status category */
      category?: components['schemas']['StatusCategory'] | null;
      /**
       * @description Whether to include seed-derived passive effects in results. Defaults to false because ListStatuses is typically used for UI display of item-based status effects only. Use GetEffects for unified queries that include seed-derived capabilities.
       * @default false
       */
      includePassive: boolean;
      /**
       * @description Page number (one-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of items per page
       * @default 50
       */
      pageSize: number;
    };
    /** @description Paginated list of active status effects */
    ListStatusesResponse: {
      /** @description Active status effects (item-based and optionally seed-derived) */
      statuses: components['schemas']['StatusEffectSummary'][];
      /** @description Total number of effects matching the filter */
      totalCount: number;
      /** @description Current page number */
      page: number;
      /** @description Number of items per page */
      pageSize: number;
    };
    /** @description Request to list available styles */
    ListStylesRequest: {
      /** @description Filter by category (e.g., "folk", "classical", "jazz") */
      category?: string | null;
      /**
       * @description Maximum number of styles to return
       * @default 50
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description Response containing a list of styles */
    ListStylesResponse: {
      /** @description Style summaries */
      styles: components['schemas']['StyleSummary'][];
      /** @description Total number of styles matching filter */
      total: number;
    };
    /** @description Request to list templates with optional filters */
    ListTemplatesRequest: {
      /** @description Filter by category */
      category?: components['schemas']['ScenarioCategory'];
      /** @description Filter by connectivity mode */
      connectivityMode?: components['schemas']['ConnectivityMode'];
      /** @description Filter by deployment phase availability */
      deploymentPhase?: components['schemas']['DeploymentPhase'];
      /** @description Filter by template status */
      status?: components['schemas']['TemplateStatus'];
      /**
       * @description Page number (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Items per page
       * @default 50
       */
      pageSize: number;
    };
    /** @description Paginated list of scenario templates */
    ListTemplatesResponse: {
      /** @description Templates on this page */
      templates: components['schemas']['ScenarioTemplateResponse'][];
      /** @description Total number of matching templates */
      totalCount: number;
      /** @description Current page number */
      page: number;
      /** @description Items per page */
      pageSize: number;
    };
    /** @description Request to list territory claims for a faction */
    ListTerritoryClaimsRequest: {
      /**
       * Format: uuid
       * @description Faction to list claims for
       */
      factionId: string;
      /** @description Filter by claim status */
      status?: components['schemas']['TerritoryClaimStatus'];
      /** @description Pagination cursor from a previous response */
      cursor?: string | null;
      /**
       * @description Number of claims to return per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Paginated list of territory claims */
    ListTerritoryClaimsResponse: {
      /** @description Territory claims for this page */
      claims: components['schemas']['TerritoryClaimResponse'][];
      /** @description Cursor for the next page (null if no more pages) */
      nextCursor?: string | null;
      /** @description Whether more pages are available */
      hasMore: boolean;
    };
    /** @description Request to list unlocked achievements */
    ListUnlockedAchievementsRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type whose unlocked achievements are listed */
      entityType: components['schemas']['EntityType'];
      /** @description Filter by platform */
      platform?: components['schemas']['Platform'];
    };
    /** @description Response containing unlocked achievements */
    ListUnlockedAchievementsResponse: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type for the returned unlocked achievements */
      entityType: components['schemas']['EntityType'];
      /** @description List of unlocked achievements */
      achievements: components['schemas']['UnlockedAchievement'][];
      /** @description Total points earned */
      totalPoints: number;
    };
    /** @description Request to list all versions of an asset with pagination */
    ListVersionsRequest: {
      /** @description Asset identifier to list versions for */
      assetId: string;
      /**
       * @description Maximum number of versions to return
       * @default 50
       */
      limit: number;
      /**
       * @description Number of versions to skip for pagination
       * @default 0
       */
      offset: number;
    };
    /** @description Paginated list of save versions within a slot */
    ListVersionsResponse: {
      /** @description List of versions */
      versions: components['schemas']['VersionResponse'][];
      /** @description Total version count in slot */
      totalCount: number;
    };
    /** @description Request to load save data from a specific slot and version */
    LoadRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Slot name */
      slotName: string;
      /** @description Specific version to load (defaults to latest) */
      versionNumber?: number | null;
      /** @description Load by checkpoint name instead of version number */
      checkpointName?: string | null;
      /**
       * @description Include version metadata in response
       * @default true
       */
      includeMetadata: boolean;
    };
    /** @description Response containing loaded save data with integrity verification */
    LoadResponse: {
      /**
       * Format: uuid
       * @description Slot identifier
       */
      slotId: string;
      /** @description Version number loaded */
      versionNumber: number;
      /**
       * Format: byte
       * @description Base64-encoded save data (decompressed)
       */
      data: string;
      /** @description SHA-256 hash for integrity verification */
      contentHash: string;
      /** @description Schema version of this save */
      schemaVersion?: string | null;
      /** @description Human-readable name */
      displayName?: string | null;
      /** @description Whether this version is pinned */
      pinned?: boolean;
      /** @description Checkpoint name if pinned */
      checkpointName?: string | null;
      /**
       * Format: date-time
       * @description Save timestamp
       */
      createdAt?: string;
      /** @description Custom metadata */
      metadata?: {
        [key: string]: string;
      };
    };
    /** @description Character location information including current position, region, and 3D coordinates */
    Location: {
      /** @description Current location name or identifier */
      current?: string | null;
      /** @description Region or zone the character is in */
      region?: string | null;
      /** @description 3D spatial coordinates of the character's position in the game world */
      coordinates?: components['schemas']['Coordinates'];
    };
    /** @description Request to check if a location exists and is active */
    LocationExistsRequest: {
      /**
       * Format: uuid
       * @description ID of the location to validate
       */
      locationId: string;
    };
    /** @description Response indicating whether a location exists and its active status */
    LocationExistsResponse: {
      /** @description Whether the location exists */
      exists: boolean;
      /** @description Whether the location is active (false if deprecated or not found) */
      isActive: boolean;
      /**
       * Format: uuid
       * @description The realm ID if location found
       */
      realmId?: string | null;
    };
    /** @description Paginated list of locations with metadata for navigation */
    LocationListResponse: {
      /** @description List of locations matching the query */
      locations: components['schemas']['LocationResponse'][];
      /** @description Total number of locations matching the query (across all pages) */
      totalCount: number;
      /** @description Current page number (1-indexed) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more pages after the current page */
      hasNextPage: boolean;
      /** @description Whether there are pages before the current page */
      hasPreviousPage: boolean;
    };
    /** @description Complete location data returned from API operations */
    LocationResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the location
       */
      locationId: string;
      /**
       * Format: uuid
       * @description Realm this location belongs to
       */
      realmId: string;
      /** @description Unique code for the location within its realm */
      code: string;
      /** @description Display name of the location */
      name: string;
      /** @description Optional description of the location */
      description?: string | null;
      /** @description Type classification of the location */
      locationType: components['schemas']['LocationType'];
      /**
       * Format: uuid
       * @description Parent location ID (null for root locations)
       */
      parentLocationId?: string | null;
      /** @description Depth in hierarchy (0 for root locations) */
      depth: number;
      /** @description Whether this location is deprecated and cannot be used */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this location was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation */
      deprecationReason?: string | null;
      /** @description Optional spatial extent in world coordinates */
      bounds?: components['schemas']['BoundingBox3D'] | null;
      /** @description Precision level of spatial bounds */
      boundsPrecision: components['schemas']['BoundsPrecision'];
      /** @description How this location's coordinate system relates to its parent */
      coordinateMode: components['schemas']['CoordinateMode'];
      /** @description Origin point for local or inherited coordinate systems */
      localOrigin?: components['schemas']['Position3D'] | null;
      /** @description Client-provided location metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Timestamp when the location was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the location was last updated
       */
      updatedAt: string;
    };
    /**
     * @description Type classification for locations
     * @enum {string}
     */
    LocationType:
      | 'CONTINENT'
      | 'REGION'
      | 'CITY'
      | 'DISTRICT'
      | 'BUILDING'
      | 'ROOM'
      | 'LANDMARK'
      | 'WILDERNESS'
      | 'DUNGEON'
      | 'OTHER';
    /** @description Request to lock a contract under guardian custody */
    LockContractRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID to lock
       */
      contractInstanceId: string;
      /**
       * Format: uuid
       * @description Guardian entity ID (e.g., escrow agreement ID)
       */
      guardianId: string;
      /** @description Guardian entity type (e.g., "escrow") */
      guardianType: string;
      /** @description Optional idempotency key for the operation */
      idempotencyKey?: string | null;
    };
    /** @description Response from locking a contract. HTTP 200 confirms the lock was acquired. */
    LockContractResponse: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /**
       * Format: uuid
       * @description Guardian entity ID
       */
      guardianId: string;
    };
    /** @description Request to authenticate a user with email and password credentials */
    LoginRequest: {
      /**
       * Format: email
       * @description Email address for authentication
       */
      email: string;
      /**
       * Format: password
       * @description User password for authentication
       */
      password: string;
      /**
       * @description Whether to extend the session duration for persistent login
       * @default false
       */
      rememberMe: boolean;
      /** @description Information about the client device (optional) */
      deviceInfo?: components['schemas']['DeviceInfo'];
    };
    /** @description Response from email/password login. May contain full tokens (no MFA) or a challenge token (MFA required). */
    LoginResponse: {
      /**
       * Format: uuid
       * @description Account ID (always present regardless of MFA status)
       */
      accountId: string;
      /** @description If true, client must complete MFA via /auth/mfa/verify before receiving tokens */
      requiresMfa: boolean;
      /** @description Short-lived challenge token for /auth/mfa/verify (only present when requiresMfa is true) */
      mfaChallengeToken?: string | null;
      /** @description JWT access token (only present when requiresMfa is false) */
      accessToken?: string | null;
      /** @description Refresh token (only present when requiresMfa is false) */
      refreshToken?: string | null;
      /** @description Seconds until access token expires (only present when requiresMfa is false) */
      expiresIn?: number | null;
      /**
       * Format: uri
       * @description WebSocket connect URL (only present when requiresMfa is false)
       */
      connectUrl?: string | null;
      /** @description Account roles (only present when requiresMfa is false) */
      roles?: string[] | null;
    };
    /** @description Site logo configuration including image URL and accessibility text */
    Logo: {
      /**
       * Format: uri
       * @description URL of the site logo image
       */
      url?: string;
      /** @description Alt text for the logo image */
      alt?: string;
    };
    /** @description Request to logout and invalidate authentication tokens */
    LogoutRequest: {
      /**
       * @description Logout from all sessions/devices
       * @default false
       */
      allSessions: boolean;
    };
    /** @description A map definition template that describes the structure of a region */
    MapDefinition: {
      /**
       * Format: uuid
       * @description Unique identifier for this definition
       */
      definitionId: string;
      /** @description Human-readable name */
      name: string;
      /** @description Description of the map template */
      description?: string | null;
      /** @description Layer configurations for this map */
      layers?: components['schemas']['LayerDefinition'][] | null;
      /** @description Default bounds for regions using this definition */
      defaultBounds?: components['schemas']['Bounds'];
      /** @description Client-provided definition metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When the definition was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the definition was last updated
       */
      updatedAt?: string | null;
    };
    /**
     * @description The category of spatial data this map contains.
     *     Different kinds have different update frequencies, storage models, and TTLs.
     * @enum {string}
     */
    MapKind:
      | 'terrain'
      | 'static_geometry'
      | 'navigation'
      | 'resources'
      | 'spawn_points'
      | 'points_of_interest'
      | 'dynamic_objects'
      | 'hazards'
      | 'weather_effects'
      | 'ownership'
      | 'combat_effects'
      | 'visual_effects';
    /** @description A stored map object with full metadata */
    MapObject: {
      /**
       * Format: uuid
       * @description Unique identifier for this object
       */
      objectId: string;
      /**
       * Format: uuid
       * @description Region this object belongs to
       */
      regionId: string;
      /** @description Map kind this object is stored under */
      kind: components['schemas']['MapKind'];
      /** @description Publisher-defined type */
      objectType: string;
      /** @description Position for point objects */
      position?: components['schemas']['Position3D'];
      /** @description Bounding box for area objects */
      bounds?: components['schemas']['Bounds'];
      /** @description Game-specific spatial object data. No Bannou plugin reads specific keys from this field by convention. */
      data?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: int64
       * @description Monotonic version for ordering
       */
      version?: number;
      /**
       * Format: date-time
       * @description When the object was first created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the object was last updated
       */
      updatedAt: string;
    };
    /**
     * @description Types of marker nodes for spawn points, waypoints, and other positional markers.
     * @enum {string}
     */
    MarkerType:
      | 'generic'
      | 'spawn_point'
      | 'npc_spawn'
      | 'waypoint'
      | 'camera_point'
      | 'light_point'
      | 'audio_point'
      | 'trigger_point';
    /** @description Request to check if a relationship type matches or descends from an ancestor type in the hierarchy */
    MatchesHierarchyRequest: {
      /**
       * Format: uuid
       * @description The relationship type to check
       */
      typeId: string;
      /**
       * Format: uuid
       * @description The potential ancestor type
       */
      ancestorTypeId: string;
    };
    /** @description Response indicating whether a type matches an ancestor in the hierarchy and the depth between them */
    MatchesHierarchyResponse: {
      /** @description True if typeId equals or descends from ancestorTypeId */
      matches: boolean;
      /** @description Number of levels between the types (0 if same, -1 if no match) */
      depth?: number;
    };
    /** @description Matchmaking operational statistics */
    MatchmakingStatsResponse: {
      /**
       * Format: date-time
       * @description When these stats were collected
       */
      timestamp: string;
      /** @description Statistics per queue */
      queueStats: components['schemas']['QueueStats'][];
    };
    /** @description Current matchmaking status for a ticket */
    MatchmakingStatusResponse: {
      /**
       * Format: uuid
       * @description Ticket identifier
       */
      ticketId: string;
      /** @description Queue the ticket is in */
      queueId: string;
      /** @description Current ticket status */
      status: components['schemas']['TicketStatus'];
      /** @description Number of processing intervals elapsed */
      intervalsElapsed: number;
      /** @description Current skill matching range (null if skill not used) */
      currentSkillRange?: number | null;
      /** @description Updated estimated wait time */
      estimatedWaitSeconds?: number | null;
      /**
       * Format: date-time
       * @description When the ticket was created
       */
      createdAt: string;
      /**
       * Format: uuid
       * @description Match ID if a match has been found
       */
      matchId?: string | null;
    };
    /** @description Analysis of a melody */
    MelodyAnalysis: {
      /** @description Pitch range used */
      range?: components['schemas']['PitchRange'];
      /** @description Distribution of interval sizes */
      intervalDistribution?: {
        [key: string]: number;
      } | null;
      /** @description Detected contour shape */
      contour?: string | null;
      /** @description Total number of notes */
      noteCount?: number;
      /**
       * Format: float
       * @description Average note duration in ticks
       */
      averageNoteDuration?: number | null;
    };
    /** @description Request to merge stacks */
    MergeStacksRequest: {
      /**
       * Format: uuid
       * @description Stack to merge from (destroyed)
       */
      sourceInstanceId: string;
      /**
       * Format: uuid
       * @description Stack to merge into
       */
      targetInstanceId: string;
    };
    /** @description Response after merging. HTTP 200 confirms merge. */
    MergeStacksResponse: {
      /**
       * Format: double
       * @description New quantity
       */
      newQuantity: number;
      /** @description Whether source was destroyed */
      sourceDestroyed: boolean;
      /**
       * Format: double
       * @description Quantity that didn't fit
       */
      overflowQuantity?: number | null;
    };
    /**
     * @description Determines what kind of content a room accepts
     * @enum {string}
     */
    MessageFormat: 'Text' | 'Sentiment' | 'Emoji' | 'Custom';
    /** @description Request to retrieve message history for a room with cursor pagination */
    MessageHistoryRequest: {
      /**
       * Format: uuid
       * @description Room ID to get history for
       */
      roomId: string;
      /** @description Cursor for pagination (message ID to fetch before) */
      before?: string | null;
      /**
       * @description Maximum number of messages to return
       * @default 50
       */
      limit: number;
    };
    /** @description Paginated message history with cursor for next page */
    MessageHistoryResponse: {
      /** @description Messages in reverse chronological order */
      messages: components['schemas']['ChatMessageResponse'][];
      /** @description Whether more messages exist before the returned set */
      hasMore: boolean;
      /** @description Cursor for fetching the next page */
      nextCursor?: string | null;
    };
    /**
     * @description Type of metadata to update
     * @enum {string}
     */
    MetadataType: 'instance_data' | 'runtime_state';
    /** @description Request to disable MFA. Exactly one of totpCode or recoveryCode must be provided. */
    MfaDisableRequest: {
      /** @description Current 6-digit TOTP code from authenticator app */
      totpCode?: string | null;
      /** @description Single-use recovery code (format xxxx-xxxx) */
      recoveryCode?: string | null;
    };
    /** @description Request to confirm MFA setup with a valid TOTP code proving authenticator is configured */
    MfaEnableRequest: {
      /** @description Setup token from /auth/mfa/setup response */
      setupToken: string;
      /** @description 6-digit TOTP code from authenticator app */
      totpCode: string;
    };
    /** @description MFA setup data containing TOTP URI for QR code and recovery codes */
    MfaSetupResponse: {
      /** @description Token to pass to /auth/mfa/enable to confirm setup */
      setupToken: string;
      /** @description otpauth:// URI for authenticator app QR code scanning */
      totpUri: string;
      /** @description 10 single-use recovery codes (shown only once, user must save them) */
      recoveryCodes: string[];
    };
    /** @description Request to verify MFA during login. Exactly one of totpCode or recoveryCode must be provided. */
    MfaVerifyRequest: {
      /** @description Challenge token from LoginResponse when requiresMfa was true */
      challengeToken: string;
      /** @description 6-digit TOTP code from authenticator app */
      totpCode?: string | null;
      /** @description Single-use recovery code (format xxxx-xxxx) */
      recoveryCode?: string | null;
    };
    /** @description A single MIDI event */
    MidiEvent: {
      /** @description Absolute tick position */
      tick: number;
      /** @description Event type */
      type: components['schemas']['MidiEventType'];
      /** @description MIDI note number (for note events) */
      note?: number | null;
      /** @description Note velocity (for note events) */
      velocity?: number | null;
      /** @description Note duration in ticks (for noteOn with implicit noteOff) */
      duration?: number | null;
      /** @description Program number (for programChange) */
      program?: number | null;
      /** @description Controller number (for controlChange) */
      controller?: number | null;
      /** @description Controller value (for controlChange) */
      value?: number | null;
    };
    /**
     * @description MIDI event type
     * @enum {string}
     */
    MidiEventType: 'NoteOn' | 'NoteOff' | 'ProgramChange' | 'ControlChange';
    /** @description MIDI file header information */
    MidiHeader: {
      /**
       * @description MIDI format type (0, 1, or 2)
       * @default 1
       */
      format: number;
      /** @description Composition name */
      name?: string | null;
      /** @description Tempo changes */
      tempos?: components['schemas']['TempoEvent'][] | null;
      /** @description Time signature changes */
      timeSignatures?: components['schemas']['TimeSignatureEvent'][] | null;
      /** @description Key signature changes */
      keySignatures?: components['schemas']['KeySignatureEvent'][] | null;
    };
    /** @description MIDI-JSON format representation of a musical piece */
    MidiJson: {
      /** @description MIDI header information */
      header?: components['schemas']['MidiHeader'];
      /**
       * @description Ticks per beat (PPQN)
       * @default 480
       */
      ticksPerBeat: number;
      /** @description MIDI tracks */
      tracks: components['schemas']['MidiTrack'][];
    };
    /** @description A single MIDI track containing events */
    MidiTrack: {
      /** @description Track name */
      name?: string | null;
      /**
       * @description MIDI channel
       * @default 0
       */
      channel: number;
      /** @description GM instrument number */
      instrument?: number | null;
      /** @description Track events */
      events: components['schemas']['MidiEvent'][];
    };
    /** @description Request to migrate a save to a newer schema version */
    MigrateSaveRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Slot name */
      slotName: string;
      /** @description Specific version to migrate (defaults to latest) */
      versionNumber?: number;
      /** @description Target schema version to migrate to */
      targetSchemaVersion: string;
      /**
       * @description Validate migration without saving
       * @default false
       */
      dryRun: boolean;
    };
    /** @description Result of a schema migration operation with version path details */
    MigrateSaveResponse: {
      /** @description Whether migration succeeded */
      success: boolean;
      /** @description Original schema version */
      fromSchemaVersion: string;
      /** @description Target schema version */
      toSchemaVersion: string;
      /** @description New version number (null if dry run) */
      newVersionNumber?: number | null;
      /** @description Migration path applied (list of versions) */
      migrationPath?: string[];
      /** @description Non-fatal migration warnings */
      warnings?: string[];
    };
    /**
     * @description Behavior when optional milestone deadline passes
     * @enum {string}
     */
    MilestoneDeadlineBehavior: 'skip' | 'warn' | 'breach';
    /** @description Milestone definition in a template */
    MilestoneDefinition: {
      /** @description Unique milestone code within template */
      code: string;
      /** @description Human-readable name */
      name: string;
      /** @description What this milestone represents */
      description?: string | null;
      /** @description Order in the contract flow */
      sequence: number;
      /** @description Whether milestone must be completed */
      required: boolean;
      /** @description Relative deadline (ISO 8601 duration) */
      deadline?: string | null;
      /** @description Behavior when deadline passes for optional milestones (default skip). Required milestones always trigger breach. */
      deadlineBehavior?: components['schemas']['MilestoneDeadlineBehavior'];
      /** @description APIs to call on completion */
      onComplete?: components['schemas']['PreboundApi'][] | null;
      /** @description APIs to call if deadline passes */
      onExpire?: components['schemas']['PreboundApi'][] | null;
    };
    /** @description Milestone instance status */
    MilestoneInstanceResponse: {
      /** @description Milestone code */
      code: string;
      /** @description Milestone name */
      name: string;
      /** @description Order in flow */
      sequence: number;
      /** @description Whether required */
      required: boolean;
      /** @description Current status */
      status: components['schemas']['MilestoneStatus'];
      /**
       * Format: date-time
       * @description When completed
       */
      completedAt?: string | null;
      /**
       * Format: date-time
       * @description When failed
       */
      failedAt?: string | null;
      /**
       * Format: date-time
       * @description When this milestone became active
       */
      activatedAt?: string | null;
      /**
       * Format: date-time
       * @description Absolute deadline (computed from activatedAt + duration)
       */
      deadline?: string | null;
      /** @description Behavior when deadline passes for optional milestones */
      deadlineBehavior?: components['schemas']['MilestoneDeadlineBehavior'];
    };
    /** @description Brief milestone progress */
    MilestoneProgressSummary: {
      /** @description Milestone code */
      code: string;
      /** @description Current status */
      status: components['schemas']['MilestoneStatus'];
    };
    /** @description Milestone details */
    MilestoneResponse: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Milestone details */
      milestone: components['schemas']['MilestoneInstanceResponse'];
    };
    /**
     * @description Current status of a milestone
     * @enum {string}
     */
    MilestoneStatus: 'pending' | 'active' | 'completed' | 'failed' | 'skipped';
    /** @description Probability distribution over musical modes */
    ModeDistribution: {
      /**
       * Format: float
       * @description Probability of major mode
       * @default 0
       */
      major: number;
      /**
       * Format: float
       * @description Probability of natural minor
       * @default 0
       */
      minor: number;
      /**
       * Format: float
       * @description Probability of dorian mode
       * @default 0
       */
      dorian: number;
      /**
       * Format: float
       * @description Probability of phrygian mode
       * @default 0
       */
      phrygian: number;
      /**
       * Format: float
       * @description Probability of lydian mode
       * @default 0
       */
      lydian: number;
      /**
       * Format: float
       * @description Probability of mixolydian mode
       * @default 0
       */
      mixolydian: number;
      /**
       * Format: float
       * @description Probability of aeolian mode
       * @default 0
       */
      aeolian: number;
      /**
       * Format: float
       * @description Probability of locrian mode
       * @default 0
       */
      locrian: number;
    };
    /**
     * @description Musical mode/scale type
     * @enum {string}
     */
    ModeType:
      | 'Major'
      | 'Minor'
      | 'Dorian'
      | 'Phrygian'
      | 'Lydian'
      | 'Mixolydian'
      | 'Aeolian'
      | 'Locrian'
      | 'HarmonicMinor'
      | 'MelodicMinor'
      | 'MajorPentatonic'
      | 'MinorPentatonic'
      | 'Blues'
      | 'WholeTone'
      | 'Chromatic';
    /** @description Request to modify item instance state */
    ModifyItemInstanceRequest: {
      /**
       * Format: uuid
       * @description Instance ID to modify
       */
      instanceId: string;
      /** @description Change to durability (positive to repair, negative for damage) */
      durabilityDelta?: number | null;
      /** @description New custom stats (merges with existing). Opaque to Bannou; no plugin reads keys by convention. */
      customStats?: Record<string, never> | null;
      /** @description New custom name */
      customName?: string | null;
      /**
       * Format: double
       * @description Change to quantity (positive to add, negative to subtract). Only valid for stackable items.
       */
      quantityDelta?: number | null;
      /** @description New instance metadata (merges with existing). Opaque to Bannou; no plugin reads keys by convention. */
      instanceMetadata?: Record<string, never> | null;
      /**
       * Format: uuid
       * @description Move item to a different container. Used by inventory service for item movement.
       */
      newContainerId?: string | null;
      /** @description New slot index within the container */
      newSlotIndex?: number | null;
      /** @description New X position for grid-based containers */
      newSlotX?: number | null;
      /** @description New Y position for grid-based containers */
      newSlotY?: number | null;
    };
    /** @description A month within a calendar template year */
    MonthDefinition: {
      /** @description Month identifier code (e.g., "frostmere", "greenleaf") */
      code: string;
      /** @description Display name for the month */
      name: string;
      /** @description Number of game days in this month */
      daysInMonth: number;
      /** @description Season code this month belongs to (must reference a defined season) */
      seasonCode: string;
    };
    /** @description Request to move item */
    MoveItemRequest: {
      /**
       * Format: uuid
       * @description Item instance ID to move
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Target container ID
       */
      targetContainerId: string;
      /** @description Target slot */
      targetSlotIndex?: number | null;
      /** @description Target grid X */
      targetSlotX?: number | null;
      /** @description Target grid Y */
      targetSlotY?: number | null;
      /** @description Rotate in target */
      rotated?: boolean | null;
    };
    /** @description Response after moving item. HTTP 200 confirms move. */
    MoveItemResponse: {
      /**
       * Format: uuid
       * @description Container the item was moved from
       */
      sourceContainerId: string;
      /** @description New slot */
      slotIndex?: number | null;
      /** @description New grid X */
      slotX?: number | null;
      /** @description New grid Y */
      slotY?: number | null;
    };
    /** @description Configuration for multipart uploads of large files */
    MultipartConfig: {
      /** @description Whether multipart upload is required for this file size */
      required?: boolean;
      /** @description Size of each part in bytes */
      partSize?: number;
      /** @description Maximum number of parts */
      maxParts?: number;
      /** @description Pre-signed URLs for each part of the multipart upload */
      uploadUrls?: components['schemas']['PartUploadInfo'][] | null;
    };
    /**
     * @description Types of state mutations a scenario can apply.
     *     PersonalityEvolve: Apply experience to evolve personality traits
     *     BackstoryAdd: Add backstory element to character history
     *     RelationshipCreate: Create relationship between entities
     *     RelationshipEnd: End existing relationship
     *     Custom: Custom mutation (not executed server-side)
     * @enum {string}
     */
    MutationType:
      | 'PersonalityEvolve'
      | 'BackstoryAdd'
      | 'RelationshipCreate'
      | 'RelationshipEnd'
      | 'Custom';
    /** @description Request to mute a participant in a room */
    MuteParticipantRequest: {
      /**
       * Format: uuid
       * @description Room ID
       */
      roomId: string;
      /**
       * Format: uuid
       * @description Session ID of participant to mute
       */
      targetSessionId: string;
      /** @description Mute duration in minutes (null for permanent) */
      durationMinutes?: number | null;
    };
    /** @description Narrative effect on the emotional arc */
    NarrativeEffect: {
      /**
       * Format: double
       * @description Delta to apply to the primary spectrum
       */
      primarySpectrumDelta?: number | null;
      /**
       * Format: double
       * @description Delta to apply to the secondary spectrum
       */
      secondarySpectrumDelta?: number | null;
      /** @description Position advance type (micro, standard, macro) */
      positionAdvance?: string | null;
    };
    /** @description Options for narrative-driven composition using the Storyteller engine */
    NarrativeOptions: {
      /**
       * @description Specific narrative template ID (e.g., 'journey_and_return', 'tension_and_release', 'simple_arc').
       *     If not specified, template is inferred from mood or defaults to 'simple_arc'.
       */
      templateId?: string | null;
      /** @description Starting emotional state for the composition */
      initialEmotion?: components['schemas']['EmotionalStateInput'];
      /** @description Target emotional state for the ending */
      targetEmotion?: components['schemas']['EmotionalStateInput'];
      /**
       * @description Preferred tension curve shape throughout the composition
       * @enum {string|null}
       */
      tensionProfile?:
        | 'gradual_build'
        | 'early_climax'
        | 'late_climax'
        | 'sustained'
        | 'wave'
        | null;
    };
    /** @description A navigation menu entry with optional nested children for dropdowns */
    NavigationItem: {
      /** @description Display text for the navigation link */
      label: string;
      /** @description Target URL or path for the navigation link */
      url: string;
      /** @description Sort order for the navigation item */
      order: number;
      /**
       * @description Link target attribute for opening behavior
       * @default _self
       * @enum {string}
       */
      target: '_self' | '_blank';
      /** @description Nested child navigation items for dropdowns */
      children?: components['schemas']['NavigationItem'][];
    };
    /** @description Information about a nearby object perceived by the character. Core properties are schema-defined; additionalProperties allows game-specific object data. No Bannou plugin reads specific extension keys by convention. */
    NearbyObject: {
      /**
       * Format: uuid
       * @description Unique identifier of the object
       */
      objectId: string;
      /** @description Type of object (boulder_cluster, tree, building, etc.) */
      objectType: string;
      /**
       * Format: float
       * @description Distance from character in game units
       */
      distance: number;
      /** @description Relative direction (north, south, east, west, above, below, etc.) */
      direction: string;
      /** @description Optional absolute position */
      position?: components['schemas']['Position3D'] | null;
    } & {
      [key: string]: unknown;
    };
    /** @description A single news article or announcement entry */
    NewsItem: {
      /**
       * Format: uuid
       * @description Unique identifier for the news item
       */
      id: string;
      /** @description Headline of the news item */
      title: string;
      /** @description Brief summary or excerpt of the news content */
      summary: string;
      /** @description Full content body of the news item */
      content?: string | null;
      /** @description Name of the news item author */
      author?: string;
      /**
       * Format: date-time
       * @description Date and time when the news was published
       */
      publishedAt: string;
      /** @description Category tags associated with the news item */
      tags?: string[];
      /**
       * Format: uri
       * @description URL of the featured image for the news item
       */
      imageUrl?: string | null;
    };
    /** @description Paginated list of news items with total count */
    NewsResponse: {
      /** @description List of news items for the current page */
      items: components['schemas']['NewsItem'][];
      /** @description Total number of news items available */
      total: number;
      /** @description Whether more news items are available beyond this page */
      hasMore?: boolean;
    };
    /**
     * @description Structural node type. Indicates what kind of data the node contains,
     *     not how it will be used at runtime. Consumers interpret nodes according
     *     to their own needs via tags and annotations.
     * @enum {string}
     */
    NodeType: 'group' | 'mesh' | 'marker' | 'volume' | 'emitter' | 'reference' | 'custom';
    /**
     * @description How to handle publish attempts from non-authority sources
     * @default reject_and_alert
     * @enum {string}
     */
    NonAuthorityHandlingMode: 'reject_and_alert' | 'accept_and_alert' | 'reject_silent';
    /** @description A behavioral norm definition stored in a faction */
    NormDefinitionResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for this norm definition
       */
      normId: string;
      /**
       * Format: uuid
       * @description Faction that owns this norm
       */
      factionId: string;
      /** @description Violation type code mapping to lib-obligation vocabulary (e.g., "theft", "deception") */
      violationType: string;
      /**
       * Format: float
       * @description Base GOAP cost penalty for violating this norm
       */
      basePenalty: number;
      /** @description Enforcement intensity level */
      severity: components['schemas']['NormSeverity'];
      /** @description Whether norm applies to member-only or all interactions */
      scope: components['schemas']['NormScope'];
      /** @description Human-readable description of the norm */
      description?: string | null;
      /**
       * Format: date-time
       * @description When this norm was defined
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When this norm was last updated
       */
      updatedAt?: string | null;
    };
    /**
     * @description Applicability scope for a behavioral norm
     * @enum {string}
     */
    NormScope: 'Internal' | 'External';
    /**
     * @description Enforcement intensity level for a behavioral norm
     * @enum {string}
     */
    NormSeverity: 'Advisory' | 'Standard' | 'Strict';
    /** @description A musical note event with timing and pitch */
    NoteEvent: {
      /** @description Note pitch */
      pitch: components['schemas']['Pitch'];
      /** @description Start position in ticks */
      startTick: number;
      /** @description Duration in ticks */
      durationTicks: number;
      /**
       * @description Note velocity
       * @default 80
       */
      velocity: number;
    };
    /** @description Request containing OAuth provider callback data to complete authentication */
    OAuthCallbackRequest: {
      /** @description Authorization code returned by the OAuth provider */
      code: string;
      /** @description State parameter for CSRF protection, must match the value sent in the init request */
      state?: string | null;
      /** @description Information about the client device (optional) */
      deviceInfo?: components['schemas']['DeviceInfo'];
    };
    /** @description Definition of a single quest objective with tracking parameters */
    ObjectiveDefinition: {
      /** @description Unique objective code within quest */
      code: string;
      /** @description Display name of the objective */
      name: string;
      /** @description Objective description */
      description?: string | null;
      /** @description Type of objective determining progress tracking logic */
      objectiveType: components['schemas']['ObjectiveType'];
      /** @description Count needed to complete */
      requiredCount: number;
      /** @description Entity type for kill/collect objectives */
      targetEntityType?: string | null;
      /** @description Subtype filter (e.g., species:wolf) */
      targetEntitySubtype?: string | null;
      /**
       * Format: uuid
       * @description Location for travel/deliver objectives
       */
      targetLocationId?: string | null;
      /**
       * @description Whether objective is hidden initially
       * @default false
       */
      hidden: boolean;
      /** @description When a hidden objective is revealed in the quest log */
      revealBehavior?: components['schemas']['ObjectiveRevealBehavior'];
      /**
       * @description Whether objective is optional for completion
       * @default false
       */
      optional: boolean;
    };
    /** @description Current progress state of a quest objective */
    ObjectiveProgress: {
      /** @description Objective code */
      code: string;
      /** @description Objective name */
      name: string;
      /** @description Objective description */
      description?: string | null;
      /** @description Type of objective determining progress tracking logic */
      objectiveType: components['schemas']['ObjectiveType'];
      /** @description Current progress count */
      currentCount: number;
      /** @description Required count */
      requiredCount: number;
      /** @description Whether complete */
      isComplete: boolean;
      /**
       * Format: float
       * @description Progress percentage (0-100)
       */
      progressPercent: number;
      /** @description Whether currently hidden */
      hidden: boolean;
      /** @description Whether optional */
      optional: boolean;
    };
    /** @description Response with objective progress and milestone completion status */
    ObjectiveProgressResponse: {
      /**
       * Format: uuid
       * @description Quest instance ID
       */
      questInstanceId: string;
      /** @description Current progress state of the objective */
      objective: components['schemas']['ObjectiveProgress'];
      /** @description Whether this progress completed the milestone */
      milestoneCompleted: boolean;
    };
    /**
     * @description When a hidden objective is revealed in the quest log
     * @enum {string}
     */
    ObjectiveRevealBehavior: 'ALWAYS' | 'ON_PROGRESS' | 'ON_COMPLETE' | 'NEVER';
    /**
     * @description Type of objective determining progress tracking logic
     * @enum {string}
     */
    ObjectiveType:
      | 'KILL'
      | 'COLLECT'
      | 'DELIVER'
      | 'TRAVEL'
      | 'DISCOVER'
      | 'TALK'
      | 'CRAFT'
      | 'ESCORT'
      | 'DEFEND'
      | 'CUSTOM';
    /**
     * @description Complete obligation data for archive storage and storyline SDK consumption.
     *     Inherits base archive properties from ResourceArchiveBase.
     *     The characterId field equals resourceId for convenience.
     */
    ObligationArchive: {
      /**
       * Format: uuid
       * @description Character this data belongs to (equals resourceId)
       */
      characterId: string;
      /** @description Whether any violation records exist */
      hasViolations: boolean;
      /** @description Number of violation records in archive */
      violationCount: number;
      /** @description Violation history records (null if hasViolations=false) */
      violations?: components['schemas']['ViolationRecord'][] | null;
    } & components['schemas']['ResourceArchiveBase'];
    /**
     * @description Action to take when the referenced resource is deleted.
     *     CASCADE: Delete dependent entities when resource is deleted
     *     RESTRICT: Block resource deletion if references exist
     *     DETACH: Set reference to null when resource is deleted
     * @enum {string}
     */
    OnDeleteAction: 'CASCADE' | 'RESTRICT' | 'DETACH';
    /** @description Full content and metadata for a CMS-managed page */
    PageContent: {
      /** @description URL-friendly identifier for the page */
      slug: string;
      /** @description Display title of the page */
      title: string;
      /** @description HTML, Markdown, or custom template content */
      content: string;
      /**
       * @description Format of the page content
       * @enum {string}
       */
      contentType: 'html' | 'markdown' | 'blazor';
      /** @description Template name for custom layouts */
      template?: string | null;
      /** @description Whether the page is publicly visible */
      published: boolean;
      /**
       * Format: date-time
       * @description Date and time when the page was published
       */
      publishedAt?: string | null;
      /**
       * Format: date-time
       * @description Date and time of the last modification
       */
      lastModified: string;
      /** @description Name or identifier of the page author */
      author?: string | null;
      /** @description Custom metadata for the page. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      };
      /** @description Search engine optimization settings for the page */
      seo?: components['schemas']['SEOMetadata'];
    };
    /** @description Summary metadata for a CMS page without full content */
    PageMetadata: {
      /** @description URL-friendly identifier for the page */
      slug: string;
      /** @description Display title of the page */
      title: string;
      /** @description Whether the page is publicly visible */
      published: boolean;
      /**
       * Format: date-time
       * @description Date and time when the page was published
       */
      publishedAt?: string | null;
      /**
       * Format: date-time
       * @description Date and time of the last modification
       */
      lastModified: string;
      /** @description Name or identifier of the page author */
      author?: string | null;
    };
    /** @description Upload information for a single part in a multipart upload */
    PartUploadInfo: {
      /** @description Part number (1-based) */
      partNumber: number;
      /**
       * Format: uri
       * @description Pre-signed URL for uploading this part
       */
      uploadUrl: string;
      /**
       * Format: int64
       * @description Minimum size for this part
       */
      minSize?: number;
      /**
       * Format: int64
       * @description Maximum size for this part
       */
      maxSize?: number;
    };
    /** @description Details about a chat room participant */
    ParticipantInfo: {
      /**
       * Format: uuid
       * @description Participant Connect session ID
       */
      sessionId: string;
      /** @description Opaque sender type */
      senderType?: string | null;
      /**
       * Format: uuid
       * @description Sender entity ID
       */
      senderId?: string | null;
      /** @description Display name */
      displayName?: string | null;
      /** @description Participant role in the room */
      role: components['schemas']['ChatParticipantRole'];
      /**
       * Format: date-time
       * @description When the participant joined
       */
      joinedAt: string;
      /** @description Whether the participant is currently muted */
      isMuted: boolean;
    };
    /** @description List of participants in a room */
    ParticipantsResponse: {
      /**
       * Format: uuid
       * @description Room ID
       */
      roomId: string;
      /** @description Current room participants */
      participants: components['schemas']['ParticipantInfo'][];
    };
    /** @description Paginated list of participation records */
    ParticipationListResponse: {
      /** @description List of participation records */
      participations: components['schemas']['HistoricalParticipation'][];
      /** @description Total number of matching records */
      totalCount: number;
      /** @description Current page number (1-based) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more results after this page */
      hasNextPage?: boolean;
      /** @description Whether there are results before this page */
      hasPreviousPage?: boolean;
    };
    /**
     * @description How the character participated in the historical event
     * @enum {string}
     */
    ParticipationRole:
      | 'LEADER'
      | 'COMBATANT'
      | 'VICTIM'
      | 'WITNESS'
      | 'BENEFICIARY'
      | 'CONSPIRATOR'
      | 'HERO'
      | 'SURVIVOR';
    /** @description Public summary of a bond partner's seed. */
    PartnerSummary: {
      /**
       * Format: uuid
       * @description Partner seed ID.
       */
      seedId: string;
      /**
       * Format: uuid
       * @description Partner's owner entity ID.
       */
      ownerId: string;
      /** @description Partner's owner entity type. */
      ownerType: components['schemas']['EntityType'];
      /** @description Partner's current growth phase. */
      growthPhase: string;
      /** @description Partner's seed status. */
      status: components['schemas']['SeedStatus'];
    };
    /** @description Asset requirement status for a single party */
    PartyAssetRequirementStatus: {
      /** @description Party role (e.g., party_a, party_b) */
      partyRole: string;
      /** @description Whether all party's requirements are satisfied */
      satisfied: boolean;
      /** @description Status of each clause for this party */
      clauses: components['schemas']['ClauseAssetStatus'][];
    };
    /** @description Consent status for a single party */
    PartyConsentStatus: {
      /**
       * Format: uuid
       * @description Party ID
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Party display name */
      displayName?: string | null;
      /** @description Whether consent was given */
      consentGiven: boolean;
      /** @description Type of consent given (if any) */
      consentType?: components['schemas']['EscrowConsentType'];
      /**
       * Format: date-time
       * @description When consent was given
       */
      consentedAt?: string | null;
    };
    /** @description Information about a party member for matchmaking */
    PartyMemberInfo: {
      /**
       * Format: uuid
       * @description Account ID of the party member
       */
      accountId: string;
      /**
       * Format: uuid
       * @description WebSocket session ID for event delivery
       */
      webSocketSessionId: string;
      /** @description Pre-fetched skill rating (optional, will be looked up if not provided) */
      skillRating?: number | null;
    };
    /** @description Definition of a party role in a contract template */
    PartyRoleDefinition: {
      /** @description Role identifier (employer, employee, buyer, seller, etc.) */
      role: string;
      /** @description Minimum entities required in this role */
      minCount: number;
      /** @description Maximum entities allowed in this role */
      maxCount: number;
      /** @description Which entity types can fill this role (null for any) */
      allowedEntityTypes?: components['schemas']['EntityType'][] | null;
    };
    /**
     * @description Method for aggregating party member skills
     * @enum {string}
     */
    PartySkillAggregation: 'highest' | 'average' | 'weighted';
    /** @description Token issued to a party for deposit or release operations */
    PartyToken: {
      /**
       * Format: uuid
       * @description Party ID
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description The token */
      token: string;
    };
    /** @description Request to confirm a password reset using the emailed token and new password */
    PasswordResetConfirmRequest: {
      /** @description Password reset token received via email */
      token: string;
      /**
       * Format: password
       * @description New password to set for the account
       */
      newPassword: string;
    };
    /** @description Request to initiate a password reset by sending a reset link to the email */
    PasswordResetRequest: {
      /**
       * Format: email
       * @description Email address associated with the account to reset
       */
      email: string;
    };
    /** @description Reference to a past incarnation */
    PastLifeReference: {
      /**
       * Format: uuid
       * @description ID of the previous incarnation
       */
      characterId: string;
      /** @description Display name of the past life */
      name?: string | null;
      /**
       * Format: date-time
       * @description When the past life ended
       */
      deathDate?: string | null;
    };
    /**
     * @description When payments occur
     * @enum {string}
     */
    PaymentSchedule: 'one_time' | 'recurring' | 'milestone_based';
    /** @description Summary of pending consent */
    PendingConsentSummary: {
      /**
       * Format: uuid
       * @description Entity ID
       */
      entityId: string;
      /** @description Entity type */
      entityType: components['schemas']['EntityType'];
      /** @description Role in contract */
      role: string;
    };
    /**
     * @description Data representing a perception event for an actor.
     *
     *     Spatial context can be provided in two ways (hybrid approach):
     *     1. Typed: Use the optional spatialContext field for structured spatial data
     *     2. Schema-less: Use perceptionType="spatial" with data containing spatial info
     *
     *     The typed approach is recommended when game server has structured spatial data.
     *     The schema-less approach allows flexibility for game-specific spatial formats.
     */
    PerceptionData: {
      /**
       * @description Perception type. Common values: visual, auditory, tactile, olfactory,
       *     proprioceptive, spatial. Use "spatial" for schema-less spatial data in 'data' field.
       */
      perceptionType: string;
      /** @description ID of the entity causing this perception */
      sourceId: string;
      /** @description Type of source (character, npc, object, environment, coordinator, scheduled, message) */
      sourceType?: components['schemas']['PerceptionSourceType'] | null;
      /** @description Game-specific perception payload passed to ABML behavior execution scope. No Bannou plugin reads specific keys from this field by convention. Different perception types carry different data structures defined by the game. */
      data?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: float
       * @description How urgent this perception is (0-1)
       * @default 0.5
       */
      urgency: number;
      /**
       * Format: uuid
       * @description Current location ID of the entity sending this perception. Used by ActorRunner to track the actor's current location for location-aware variable providers. Updated on each perception event that carries this field.
       */
      locationId?: string | null;
      /**
       * @description Optional typed spatial context from game server's local spatial state.
       *     Provides structured information about terrain, nearby objects, hazards, etc.
       *     Alternative to using perceptionType="spatial" with schema-less data.
       */
      spatialContext?: components['schemas']['SpatialContext'] | null;
    };
    /**
     * @description Type of source generating a perception event
     * @enum {string}
     */
    PerceptionSourceType:
      | 'character'
      | 'npc'
      | 'object'
      | 'environment'
      | 'coordinator'
      | 'scheduled'
      | 'message'
      | 'service'
      | 'system';
    /**
     * @description Whether room messages are stored in Redis (TTL) or MySQL (durable)
     * @enum {string}
     */
    PersistenceMode: 'Ephemeral' | 'Persistent';
    /** @description Complete personality profile for behavior system consumption */
    PersonalityResponse: {
      /**
       * Format: uuid
       * @description Character this personality belongs to
       */
      characterId: string;
      /** @description All trait axis values for this character */
      traits: components['schemas']['TraitValue'][];
      /** @description Personality version number (increments on each evolution) */
      version: number;
      /**
       * @description Optional archetype code for behavior optimization (e.g., "guardian",
       *     "merchant", "scholar", "trickster"). Allows behavior system to use
       *     pre-compiled behavior variants for common personality patterns.
       */
      archetypeHint?: string | null;
      /**
       * Format: date-time
       * @description When this personality was first created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When this personality was last modified
       */
      updatedAt?: string | null;
    };
    /** @description Response containing a perspective */
    PerspectiveResponse: {
      /** @description The character's perspective on the encounter */
      perspective: components['schemas']['EncounterPerspectiveModel'];
    };
    /** @description Current deployment phase configuration */
    PhaseConfigResponse: {
      /** @description Current deployment phase */
      currentPhase: components['schemas']['DeploymentPhase'];
      /** @description Maximum total active scenario instances */
      maxConcurrentScenariosGlobal: number;
      /** @description Whether persistent world entry is enabled */
      persistentEntryEnabled: boolean;
      /** @description Whether garden minigames are enabled */
      gardenMinigamesEnabled: boolean;
    };
    /** @description Current deployment phase metrics */
    PhaseMetricsResponse: {
      /** @description Current deployment phase */
      currentPhase: components['schemas']['DeploymentPhase'];
      /** @description Number of currently active garden instances */
      activeGardenInstances: number;
      /** @description Number of currently active scenario instances */
      activeScenarioInstances: number;
      /**
       * Format: float
       * @description Ratio of active scenarios to global capacity (0.0-1.0)
       */
      scenarioCapacityUtilization: number;
    };
    /** @description Phase position constraints from Save the Cat beat timing */
    PhasePosition: {
      /**
       * Format: double
       * @description Target position from STC beat timing
       */
      stcCenter: number;
      /**
       * Format: double
       * @description Earliest advancement position (prevents speed-running)
       */
      floor: number;
      /**
       * Format: double
       * @description Forced advancement position (prevents deadlock)
       */
      ceiling: number;
      /**
       * Format: double
       * @description Validation tolerance ()
       */
      validationBand: number;
    };
    /** @description Target state for phase completion */
    PhaseTargetState: {
      /**
       * Format: double
       * @description Minimum primary spectrum value for this phase
       */
      minPrimarySpectrum: number;
      /**
       * Format: double
       * @description Maximum primary spectrum value for this phase
       */
      maxPrimarySpectrum: number;
      /** @description Human-readable description of this state range */
      rangeDescription?: string | null;
    };
    /** @description Request to pin a message in a room */
    PinMessageRequest: {
      /**
       * Format: uuid
       * @description Room the message belongs to
       */
      roomId: string;
      /**
       * Format: uuid
       * @description Message ID to pin
       */
      messageId: string;
    };
    /** @description Request to pin a save version as a checkpoint to prevent cleanup */
    PinVersionRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Slot name */
      slotName: string;
      /** @description Version to pin */
      versionNumber: number;
      /** @description Optional checkpoint name for easy retrieval */
      checkpointName?: string;
    };
    /** @description A specific pitch with pitch class and octave */
    Pitch: {
      /** @description Pitch class (note name) */
      pitchClass: components['schemas']['PitchClass'];
      /** @description Octave number (middle C = C4) */
      octave: number;
      /** @description MIDI note number (computed if not provided) */
      midiNumber?: number;
    };
    /**
     * @description A pitch class (note name without octave)
     * @enum {string}
     */
    PitchClass: 'C' | 'Cs' | 'D' | 'Ds' | 'E' | 'F' | 'Fs' | 'G' | 'Gs' | 'A' | 'As' | 'B';
    /** @description A pitch range from low to high */
    PitchRange: {
      /** @description Lowest pitch (inclusive) */
      low: components['schemas']['Pitch'];
      /** @description Highest pitch (inclusive) */
      high: components['schemas']['Pitch'];
    };
    /** @description Summary of a cached plan */
    PlanSummary: {
      /**
       * Format: uuid
       * @description Plan identifier
       */
      planId: string;
      /** @description Story goal */
      goal: components['schemas']['StorylineGoal'];
      /** @description Arc type */
      arcType: components['schemas']['ArcType'];
      /**
       * Format: double
       * @description Viability score
       */
      confidence: number;
      /**
       * Format: uuid
       * @description Anchored realm (if any)
       */
      realmId?: string | null;
      /**
       * Format: date-time
       * @description When plan was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When plan expires from cache
       */
      expiresAt?: string | null;
    };
    /** @description Single action within a GOAP plan with position and cost information */
    PlannedActionResponse: {
      /** @description ID of the action (flow name) */
      actionId: string;
      /** @description Position in the plan sequence */
      index: number;
      /**
       * Format: float
       * @description Cost of this action
       */
      cost: number;
    };
    /**
     * @description GOAP planning urgency level affecting search parameters.
     *     Low: More iterations, wider beam (1000/20)
     *     Medium: Balanced (500/15)
     *     High: Fewer iterations, narrower beam (200/10)
     * @enum {string}
     */
    PlanningUrgency: 'Low' | 'Medium' | 'High';
    /**
     * @description External platform for achievement sync
     * @enum {string}
     */
    Platform: 'steam' | 'xbox' | 'playstation' | 'internal';
    /**
     * @description Role of the player in the game session
     * @enum {string}
     */
    PlayerRole: 'player' | 'spectator' | 'moderator';
    /** @description Result of interacting with a POI */
    PoiInteractionResponse: {
      /**
       * Format: uuid
       * @description POI that was interacted with
       */
      poiId: string;
      /** @description Interaction outcome */
      result: components['schemas']['PoiInteractionResult'];
      /**
       * Format: uuid
       * @description Associated template ID if result involves a scenario
       */
      scenarioTemplateId?: string | null;
      /** @description Prompt text for prompted POIs */
      promptText?: string | null;
      /** @description Available choices for prompted POIs */
      promptChoices?: string[] | null;
    };
    /**
     * @description Outcome of interacting with a POI
     * @enum {string}
     */
    PoiInteractionResult: 'ScenarioPrompt' | 'ScenarioEnter' | 'PoiUpdate' | 'ChainOffer';
    /**
     * @description Current lifecycle status of a POI
     * @enum {string}
     */
    PoiStatus: 'Active' | 'Entered' | 'Declined' | 'Expired';
    /** @description POI state summary for client display */
    PoiSummary: {
      /**
       * Format: uuid
       * @description Unique identifier for this POI
       */
      poiId: string;
      /** @description POI position in garden space */
      position: components['schemas']['Vec3'];
      /** @description Sensory presentation type */
      poiType: components['schemas']['PoiType'];
      /** @description Scenario category hint for client rendering */
      visualHint?: components['schemas']['ScenarioCategory'];
      /** @description Audio hint identifier for client rendering */
      audioHint?: string | null;
      /**
       * Format: float
       * @description Current intensity ramp value (0.0-1.0)
       * @default 0
       */
      intensityRamp: number;
      /** @description How this POI is triggered */
      triggerMode: components['schemas']['TriggerMode'];
      /**
       * Format: float
       * @description Trigger radius in garden space units
       */
      triggerRadius: number;
      /**
       * Format: uuid
       * @description Associated scenario template if this POI leads to a scenario
       */
      scenarioTemplateId?: string | null;
      /** @description Current lifecycle status */
      status: components['schemas']['PoiStatus'];
    };
    /**
     * @description Sensory presentation type for a point of interest in the garden
     * @enum {string}
     */
    PoiType: 'Visual' | 'Auditory' | 'Environmental' | 'Portal' | 'Social';
    /** @description Position in world coordinates (meters, Y-up, right-handed) */
    Position3D: {
      /**
       * Format: float
       * @description X coordinate in world space (meters)
       */
      x: number;
      /**
       * Format: float
       * @description Y coordinate (up axis) in world space (meters)
       */
      y: number;
      /**
       * Format: float
       * @description Z coordinate in world space (meters)
       */
      z: number;
    };
    /** @description Response to a position update */
    PositionUpdateResponse: {
      /** @description Whether the position update was processed */
      acknowledged: boolean;
      /** @description POIs triggered by proximity to the new position */
      triggeredPois?: components['schemas']['PoiSummary'][] | null;
    };
    /** @description Pre-configured API call to execute on contract events */
    PreboundApi: {
      /** @description Target service name */
      serviceName: string;
      /** @description Target endpoint path */
      endpoint: string;
      /** @description JSON payload with variable placeholders */
      payloadTemplate: string;
      /** @description Human-readable description */
      description?: string | null;
      /**
       * @description How to execute the API call
       * @default sync
       */
      executionMode: components['schemas']['PreboundApiExecutionMode'];
      /** @description Optional validation rules for the response */
      responseValidation?: components['schemas']['ResponseValidation'];
    };
    /**
     * @description How to execute a prebound API call
     * @enum {string}
     */
    PreboundApiExecutionMode: 'sync' | 'async' | 'fire_and_forget';
    /** @description Mutation that would be applied */
    PredictedMutation: {
      /** @description Type of mutation */
      mutationType: components['schemas']['MutationType'];
      /** @description Human-readable description */
      description: string;
    };
    /**
     * @description Preferred engagement distance. Influences positioning and
     *     ability selection in combat.
     * @enum {string}
     */
    PreferredRange: 'MELEE' | 'CLOSE' | 'MEDIUM' | 'RANGED';
    /** @description Requirement that must be met before a quest can be accepted */
    PrerequisiteDefinition: {
      /** @description Type of prerequisite check */
      type: components['schemas']['PrerequisiteType'];
      /** @description Quest code for QUEST_COMPLETED type */
      questCode?: string | null;
      /** @description Minimum level for CHARACTER_LEVEL type */
      minLevel?: number | null;
      /** @description Faction code for REPUTATION type */
      factionCode?: string | null;
      /** @description Minimum reputation for REPUTATION type */
      minReputation?: number | null;
      /** @description Item code for ITEM_OWNED type */
      itemCode?: string | null;
      /** @description Currency code for CURRENCY_AMOUNT type */
      currencyCode?: string | null;
      /** @description Minimum amount for CURRENCY_AMOUNT type */
      minAmount?: number | null;
    };
    /**
     * @description Type of prerequisite check
     * @enum {string}
     */
    PrerequisiteType:
      | 'QUEST_COMPLETED'
      | 'CHARACTER_LEVEL'
      | 'REPUTATION'
      | 'ITEM_OWNED'
      | 'CURRENCY_AMOUNT';
    /**
     * @description Asset processing pipeline status
     * @enum {string}
     */
    ProcessingStatus: 'pending' | 'processing' | 'complete' | 'failed';
    /** @description Analysis of a chord progression */
    ProgressionAnalysis: {
      /** @description Roman numeral analysis */
      romanNumerals?: string[] | null;
      /** @description Detected cadences */
      cadences?: components['schemas']['CadenceInfo'][] | null;
      /** @description Functional analysis per chord */
      functionalAnalysis?: ('tonic' | 'subdominant' | 'dominant' | 'predominant')[] | null;
    };
    /** @description Request to promote an older save version to be the latest */
    PromoteVersionRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Name of the slot containing the version to promote */
      slotName: string;
      /** @description Old version to promote to latest */
      versionNumber: number;
      /** @description Display name for promoted version */
      displayName?: string | null;
    };
    /** @description Request to propose a contract to parties */
    ProposeContractInstanceRequest: {
      /**
       * Format: uuid
       * @description Contract instance to propose
       */
      contractId: string;
    };
    /**
     * @description Authentication provider type
     * @enum {string}
     */
    Provider: 'google' | 'discord' | 'twitch' | 'steam';
    /** @description Information about an available authentication provider */
    ProviderInfo: {
      /**
       * @description Internal identifier for the provider (matches Provider enum for OAuth)
       * @example discord
       */
      name: string;
      /**
       * @description Human-readable name for the provider
       * @example Discord
       */
      displayName: string;
      /** @description Authentication mechanism (oauth = browser redirect, ticket = game client token) */
      authType: components['schemas']['AuthType'];
      /**
       * Format: uri
       * @description URL to initiate OAuth authentication (null for ticket-based auth like Steam)
       * @example https://discord.com/oauth2/authorize
       */
      authUrl?: string | null;
    };
    /** @description List of available authentication providers */
    ProvidersResponse: {
      /** @description Available authentication providers */
      providers: components['schemas']['ProviderInfo'][];
    };
    /**
     * @description How quantities are tracked for this item type
     * @enum {string}
     */
    QuantityModel: 'discrete' | 'continuous' | 'unique';
    /** @description Rotation represented as a quaternion */
    Quaternion: {
      /**
       * Format: double
       * @description X component
       */
      x: number;
      /**
       * Format: double
       * @description Y component
       */
      y: number;
      /**
       * Format: double
       * @description Z component
       */
      z: number;
      /**
       * Format: double
       * @description W component (scalar)
       */
      w: number;
    };
    /** @description Request to query active contracts */
    QueryActiveContractsRequest: {
      /**
       * Format: uuid
       * @description Entity to query
       */
      entityId: string;
      /** @description Entity type */
      entityType: components['schemas']['EntityType'];
      /** @description Filter by template codes */
      templateCodes?: string[] | null;
    };
    /** @description Active contracts for entity */
    QueryActiveContractsResponse: {
      /** @description Active contracts */
      contracts: components['schemas']['ContractSummary'][];
    };
    /** @description Request to query encounters between two characters */
    QueryBetweenRequest: {
      /**
       * Format: uuid
       * @description First character
       */
      characterIdA: string;
      /**
       * Format: uuid
       * @description Second character
       */
      characterIdB: string;
      /** @description Filter by encounter type */
      encounterTypeCode?: string | null;
      /**
       * Format: float
       * @description Filter by minimum memory strength (for either character)
       */
      minimumMemoryStrength?: number | null;
      /**
       * @description Page number (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Query map data within bounds */
    QueryBoundsRequest: {
      /**
       * Format: uuid
       * @description Region to query
       */
      regionId: string;
      /** @description Bounding box to query */
      bounds: components['schemas']['Bounds'];
      /** @description Kinds to query (default all) */
      kinds?: components['schemas']['MapKind'][] | null;
      /**
       * @description Maximum objects to return
       * @default 500
       */
      maxObjects: number;
    };
    /** @description Bounds query results */
    QueryBoundsResponse: {
      /** @description Objects within bounds */
      objects?: components['schemas']['MapObject'][];
      /** @description Queried bounds */
      bounds?: components['schemas']['Bounds'];
      /** @description Whether results were truncated */
      truncated?: boolean;
    };
    /** @description Request to find bundles containing a specific asset */
    QueryBundlesByAssetRequest: {
      /** @description Platform asset ID to search for */
      assetId: string;
      /** @description Game realm to search within */
      realm: components['schemas']['GameRealm'];
      /** @description Filter by bundle type (optional, null for all types) */
      bundleType?: components['schemas']['BundleType'] | null;
      /**
       * @description Maximum results to return
       * @default 50
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description Bundles containing the requested asset */
    QueryBundlesByAssetResponse: {
      /** @description The queried asset ID */
      assetId: string;
      /** @description Bundles containing this asset */
      bundles: components['schemas']['BundleSummary'][];
      /** @description Total matching bundles */
      total: number;
      /** @description Page size */
      limit: number;
      /** @description Page offset */
      offset: number;
    };
    /** @description Advanced bundle query with filters */
    QueryBundlesRequest: {
      /** @description Filter by exact tag key-value matches */
      tags?: {
        [key: string]: string;
      } | null;
      /** @description Filter bundles that have these tag keys (any value) */
      tagExists?: string[] | null;
      /** @description Filter bundles that do NOT have these tag keys */
      tagNotExists?: string[] | null;
      /** @description Filter by lifecycle status (null for active only by default) */
      status?: components['schemas']['BundleLifecycle'] | null;
      /**
       * Format: date-time
       * @description Filter bundles created after this time
       */
      createdAfter?: string | null;
      /**
       * Format: date-time
       * @description Filter bundles created before this time
       */
      createdBefore?: string | null;
      /** @description Filter bundles with name containing this string (case-insensitive) */
      nameContains?: string | null;
      /** @description Filter by bundle owner account ID */
      owner?: string | null;
      /** @description Filter by realm */
      realm?: components['schemas']['GameRealm'] | null;
      /** @description Filter by bundle type (source or metabundle) */
      bundleType?: components['schemas']['BundleType'] | null;
      /**
       * @description Field to sort by (default created_at)
       * @enum {string|null}
       */
      sortField?: 'created_at' | 'updated_at' | 'name' | 'size' | null;
      /**
       * @description Sort order (default desc)
       * @enum {string|null}
       */
      sortOrder?: 'asc' | 'desc' | null;
      /**
       * @description Maximum results to return (max 1000)
       * @default 100
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Include soft-deleted bundles in results
       * @default false
       */
      includeDeleted: boolean;
    };
    /** @description Bundle query results */
    QueryBundlesResponse: {
      /** @description Matching bundles */
      bundles: components['schemas']['BundleInfo'][];
      /** @description Total number of matching bundles (for pagination) */
      totalCount: number;
      /** @description Page size used */
      limit: number;
      /** @description Page offset used */
      offset: number;
    };
    /** @description Request to query encounters by character */
    QueryByCharacterRequest: {
      /**
       * Format: uuid
       * @description Character to query encounters for
       */
      characterId: string;
      /** @description Filter by encounter type */
      encounterTypeCode?: string | null;
      /** @description Filter by outcome */
      outcome?: components['schemas']['EncounterOutcome'];
      /**
       * Format: float
       * @description Filter by minimum memory strength
       */
      minimumMemoryStrength?: number | null;
      /**
       * Format: date-time
       * @description Filter encounters after this time
       */
      fromTimestamp?: string | null;
      /**
       * Format: date-time
       * @description Filter encounters before this time
       */
      toTimestamp?: string | null;
      /**
       * @description Page number (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to query recent encounters at a location */
    QueryByLocationRequest: {
      /**
       * Format: uuid
       * @description Location to query
       */
      locationId: string;
      /** @description Filter by encounter type */
      encounterTypeCode?: string | null;
      /**
       * Format: date-time
       * @description Filter encounters after this time
       */
      fromTimestamp?: string | null;
      /**
       * @description Page number (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to query contract instances with cursor-based pagination. */
    QueryContractInstancesRequest: {
      /**
       * Format: uuid
       * @description Filter by party entity ID.
       */
      partyEntityId?: string | null;
      /** @description Filter by party entity type. */
      partyEntityType?: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Filter by template.
       */
      templateId?: string | null;
      /** @description Filter by statuses. */
      statuses?: components['schemas']['ContractStatus'][] | null;
      /** @description Opaque cursor from previous response. Null for first page. */
      cursor?: string | null;
      /** @description Number of items per page. Uses service default if not specified. */
      pageSize?: number | null;
    };
    /** @description Paginated list of contract instances. */
    QueryContractInstancesResponse: {
      /** @description Contracts in this page. */
      contracts: components['schemas']['ContractInstanceResponse'][];
      /** @description Cursor for next page. Null if no more results. */
      nextCursor?: string | null;
      /** @description Whether more results exist beyond this page. */
      hasMore: boolean;
    };
    /** @description Request to search documentation using natural language queries */
    QueryDocumentationRequest: {
      /** @description Documentation namespace to search within */
      namespace: string;
      /** @description Natural language query to search for */
      query: string;
      /**
       * Format: uuid
       * @description Optional session ID for conversational context
       */
      sessionId?: string;
      /** @description Filter results to a specific category */
      category?: components['schemas']['DocumentCategory'];
      /**
       * @description Maximum number of results to return
       * @default 5
       */
      maxResults: number;
      /**
       * @description Whether to include full document content in results
       * @default false
       */
      includeContent: boolean;
      /**
       * @description Maximum length of summaries in characters
       * @default 300
       */
      maxSummaryLength: number;
      /**
       * Format: float
       * @description Minimum relevance score threshold for results
       * @default 0.3
       */
      minRelevanceScore: number;
    };
    /** @description Response containing search results and voice-friendly summaries */
    QueryDocumentationResponse: {
      /** @description The namespace that was searched */
      namespace: string;
      /** @description The original query string */
      query: string;
      /** @description List of matching documents */
      results: components['schemas']['DocumentResult'][];
      /** @description Total number of matching documents */
      totalResults?: number;
      /** @description Concise spoken summary for voice AI */
      voiceSummary?: string;
      /** @description Suggested follow-up queries */
      suggestedFollowups?: string[];
      /** @description User-friendly message when no results found */
      noResultsMessage?: string;
    };
    /** @description Request to query unlocked entries */
    QueryEntriesRequest: {
      /**
       * Format: uuid
       * @description Collection to query entries from
       */
      collectionId: string;
      /** @description Filter by category */
      category?: string | null;
      /** @description Filter by tags (entries matching any tag are included) */
      tags?: string[] | null;
      /** @description Opaque cursor from previous response for pagination */
      cursor?: string | null;
      /** @description Number of items per page */
      pageSize?: number | null;
    };
    /** @description Paginated list of unlocked entries */
    QueryEntriesResponse: {
      /** @description Unlocked entries matching the query */
      entries: components['schemas']['UnlockedEntryResponse'][];
      /** @description Cursor for next page */
      nextCursor?: string | null;
      /** @description Whether more results exist */
      hasMore: boolean;
    };
    /** @description Request to query items */
    QueryItemsRequest: {
      /**
       * Format: uuid
       * @description Owner to search
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['ContainerOwnerType'];
      /**
       * Format: uuid
       * @description Filter by template
       */
      templateId?: string | null;
      /** @description Filter by category */
      category?: string | null;
      /** @description Filter by tags */
      tags?: string[] | null;
      /** @description Filter by container type */
      containerType?: string | null;
      /**
       * @description Exclude equipment slots
       * @default false
       */
      excludeEquipmentSlots: boolean;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Max results
       * @default 50
       */
      limit: number;
    };
    /** @description Query results */
    QueryItemsResponse: {
      /** @description Found items */
      items: components['schemas']['QueryResultItem'][];
      /** @description Total matching */
      totalCount: number;
    };
    /** @description Request to find all locations containing a spatial position */
    QueryLocationsByPositionRequest: {
      /** @description Position to query in world coordinates */
      position: components['schemas']['Position3D'];
      /**
       * Format: uuid
       * @description Realm to search within
       */
      realmId: string;
      /** @description Maximum hierarchy depth to search (null for all depths) */
      maxDepth?: number | null;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Query objects by type */
    QueryObjectsByTypeRequest: {
      /**
       * Format: uuid
       * @description Region to query
       */
      regionId: string;
      /** @description Object type to filter by */
      objectType: string;
      /** @description Optional bounds filter */
      bounds?: components['schemas']['Bounds'];
      /**
       * @description Maximum objects to return
       * @default 500
       */
      maxObjects: number;
    };
    /** @description Object type query results */
    QueryObjectsByTypeResponse: {
      /** @description Matching objects */
      objects?: components['schemas']['MapObject'][];
      /** @description Queried object type */
      objectType?: string;
      /** @description Whether results were truncated */
      truncated?: boolean;
    };
    /** @description Query map data at a point */
    QueryPointRequest: {
      /**
       * Format: uuid
       * @description Region to query
       */
      regionId: string;
      /** @description Point to query at */
      position: components['schemas']['Position3D'];
      /** @description Kinds to query (default all) */
      kinds?: components['schemas']['MapKind'][] | null;
      /** @description Include objects within this radius */
      radius?: number | null;
    };
    /** @description Point query results */
    QueryPointResponse: {
      /** @description Objects at/near the point */
      objects?: components['schemas']['MapObject'][];
      /** @description Queried position */
      position?: components['schemas']['Position3D'];
      /** @description Applied radius filter */
      radius?: number | null;
    };
    /** @description Item in query results */
    QueryResultItem: {
      /**
       * Format: uuid
       * @description Item instance ID
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Template ID
       */
      templateId: string;
      /**
       * Format: uuid
       * @description Container ID
       */
      containerId: string;
      /** @description Container type */
      containerType?: string;
      /**
       * Format: double
       * @description Quantity
       */
      quantity: number;
      /** @description Slot position */
      slotIndex?: number | null;
    };
    /** @description Advanced query for saves across multiple owners with filtering and sorting */
    QuerySavesRequest: {
      /**
       * Format: uuid
       * @description Filter by owner ID
       */
      ownerId?: string | null;
      /** @description Filter by owner type */
      ownerType?: components['schemas']['EntityType'] | null;
      /** @description Filter by save category */
      category?: components['schemas']['SaveCategory'] | null;
      /**
       * Format: date-time
       * @description Filter by creation date
       */
      createdAfter?: string | null;
      /**
       * Format: date-time
       * @description Filter by creation date
       */
      createdBefore?: string | null;
      /** @description Only return pinned versions */
      pinnedOnly?: boolean | null;
      /** @description Filter by schema version */
      schemaVersion?: string | null;
      /** @description Filter by metadata key-value pairs */
      metadataFilter?: {
        [key: string]: string;
      } | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results
       * @default 20
       */
      limit: number;
      /**
       * @description Sort field
       * @default created_at
       * @enum {string}
       */
      sortBy: 'created_at' | 'size' | 'version_number';
      /**
       * @description Sort order
       * @default desc
       * @enum {string}
       */
      sortOrder: 'asc' | 'desc';
    };
    /** @description Paginated results from a save query operation */
    QuerySavesResponse: {
      /** @description Query results */
      results: components['schemas']['QueryResultItem'][];
      /** @description Total matching results */
      totalCount: number;
    };
    /** @description Request to query violation history for a character */
    QueryViolationsRequest: {
      /**
       * Format: uuid
       * @description ID of the character to query violations for
       */
      characterId: string;
      /**
       * Format: uuid
       * @description Filter by specific contract
       */
      contractId?: string | null;
      /** @description Filter by violation type code */
      violationType?: string | null;
      /**
       * Format: date-time
       * @description Only return violations after this timestamp
       */
      since?: string | null;
      /** @description Pagination cursor from a previous response */
      cursor?: string | null;
      /**
       * @description Number of violations to return per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Paginated violation history for a character */
    QueryViolationsResponse: {
      /** @description Violation records for this page */
      violations: components['schemas']['ViolationRecord'][];
      /** @description Cursor for the next page (null if no more pages) */
      nextCursor?: string | null;
      /** @description Whether more pages are available */
      hasMore: boolean;
    };
    /**
     * @description Complete quest data for archive storage and storyline SDK consumption.
     *     Inherits base archive properties from ResourceArchiveBase.
     *     The characterId field equals resourceId for convenience.
     */
    QuestArchive: {
      /**
       * Format: uuid
       * @description Character this data belongs to (equals resourceId)
       */
      characterId: string;
      /** @description Summary of currently active quests */
      activeQuests: components['schemas']['ActiveQuestSummary'][];
      /** @description Total count of completed quests */
      completedQuests: number;
      /** @description Breakdown of completed quests by category (main, side, bounty, etc.) */
      questCategories: {
        [key: string]: number;
      };
    } & components['schemas']['ResourceArchiveBase'];
    /**
     * @description Category of quest for organization
     * @enum {string}
     */
    QuestCategory: 'MAIN' | 'SIDE' | 'BOUNTY' | 'DAILY' | 'WEEKLY' | 'EVENT' | 'TUTORIAL';
    /** @description Complete quest definition including objectives, prerequisites, and rewards */
    QuestDefinitionResponse: {
      /**
       * Format: uuid
       * @description Unique quest definition ID
       */
      definitionId: string;
      /**
       * Format: uuid
       * @description Underlying contract template ID
       */
      contractTemplateId: string;
      /** @description Quest code */
      code: string;
      /** @description Quest name */
      name: string;
      /** @description Quest description */
      description?: string | null;
      /** @description Quest category for organization */
      category: components['schemas']['QuestCategory'];
      /** @description Difficulty rating of the quest */
      difficulty: components['schemas']['QuestDifficulty'];
      /** @description Minimum level required */
      levelRequirement?: number | null;
      /** @description Whether repeatable */
      repeatable: boolean;
      /** @description Cooldown for repeatable quests */
      cooldownSeconds?: number | null;
      /** @description Time limit */
      deadlineSeconds?: number | null;
      /** @description Max party size */
      maxQuestors: number;
      /** @description Quest objectives */
      objectives: components['schemas']['ObjectiveDefinition'][];
      /** @description Prerequisites */
      prerequisites?: components['schemas']['PrerequisiteDefinition'][] | null;
      /** @description Rewards */
      rewards?: components['schemas']['RewardDefinition'][] | null;
      /** @description Tags */
      tags?: string[] | null;
      /** @description Whether this quest definition is deprecated */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description When the quest definition was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Reason for deprecation */
      deprecationReason?: string | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /**
       * Format: uuid
       * @description Game service ID
       */
      gameServiceId: string;
    };
    /**
     * @description Difficulty rating of the quest
     * @enum {string}
     */
    QuestDifficulty: 'TRIVIAL' | 'EASY' | 'NORMAL' | 'HARD' | 'HEROIC' | 'LEGENDARY';
    /** @description Active or completed quest instance with progress information */
    QuestInstanceResponse: {
      /**
       * Format: uuid
       * @description Unique instance ID
       */
      questInstanceId: string;
      /**
       * Format: uuid
       * @description Quest definition ID
       */
      definitionId: string;
      /**
       * Format: uuid
       * @description Underlying contract instance ID
       */
      contractInstanceId: string;
      /** @description Quest code */
      code: string;
      /** @description Quest name */
      name: string;
      /** @description Current status of the quest */
      status: components['schemas']['QuestStatus'];
      /** @description Characters on the quest */
      questorCharacterIds: string[];
      /**
       * Format: uuid
       * @description Quest giver NPC
       */
      questGiverCharacterId?: string | null;
      /** @description Objective progress */
      objectives: components['schemas']['ObjectiveProgress'][];
      /**
       * Format: date-time
       * @description When quest was accepted
       */
      acceptedAt: string;
      /**
       * Format: date-time
       * @description Quest deadline (null if none)
       */
      deadline?: string | null;
      /**
       * Format: date-time
       * @description When completed
       */
      completedAt?: string | null;
    };
    /** @description Single entry in the quest log with progress summary */
    QuestLogEntry: {
      /**
       * Format: uuid
       * @description Quest instance ID
       */
      questInstanceId: string;
      /** @description Quest code */
      code: string;
      /** @description Quest name */
      name: string;
      /** @description Quest category for organization */
      category: components['schemas']['QuestCategory'];
      /** @description Current status of the quest */
      status: components['schemas']['QuestStatus'];
      /**
       * Format: float
       * @description Overall progress percentage
       */
      overallProgress: number;
      /** @description Visible objectives (hidden ones excluded until revealed) */
      visibleObjectives: components['schemas']['ObjectiveProgress'][];
      /**
       * Format: date-time
       * @description Deadline if any
       */
      deadline?: string | null;
      /**
       * Format: date-time
       * @description When accepted
       */
      acceptedAt: string;
    };
    /** @description Player-facing quest log with active quests and completion counts */
    QuestLogResponse: {
      /** @description Active quests with progress */
      activeQuests: components['schemas']['QuestLogEntry'][];
      /** @description Total completed quests */
      completedCount: number;
      /** @description Total failed quests */
      failedCount: number;
    };
    /**
     * @description Current status of a quest instance
     * @enum {string}
     */
    QuestStatus: 'ACTIVE' | 'COMPLETED' | 'FAILED' | 'ABANDONED' | 'EXPIRED';
    /** @description Full configuration details of a matchmaking queue */
    QueueResponse: {
      /** @description Unique identifier for the queue */
      queueId: string;
      /** @description Game this queue is for */
      gameId: string;
      /** @description Game type for created sessions (maps to game-session service) */
      sessionGameType?: components['schemas']['SessionGameType'];
      /** @description Human-readable queue name */
      displayName: string;
      /** @description Detailed description of the queue */
      description?: string | null;
      /** @description Whether the queue is currently accepting tickets */
      enabled: boolean;
      /** @description Minimum players required for a match */
      minCount: number;
      /** @description Maximum players in a match */
      maxCount: number;
      /** @description Player count must be divisible by this (e.g., 2 for pairs) */
      countMultiple: number;
      /** @description Seconds between match processing intervals */
      intervalSeconds: number;
      /** @description Maximum intervals before relaxing to minCount */
      maxIntervals: number;
      /** @description Skill window expansion steps */
      skillExpansion?: components['schemas']['SkillExpansionStep'][] | null;
      /** @description How to calculate party skill rating */
      partySkillAggregation?: components['schemas']['PartySkillAggregation'];
      /** @description Weights for weighted party skill aggregation */
      partySkillWeights?: number[] | null;
      /** @description Maximum party size for this queue */
      partyMaxSize?: number | null;
      /**
       * @description Whether players can be in multiple queues
       * @default true
       */
      allowConcurrent: boolean;
      /** @description Exclusive group name (player can only be in one queue of the group) */
      exclusiveGroup?: string | null;
      /**
       * @description Whether to use lib-analytics skill rating for matching
       * @default true
       */
      useSkillRating: boolean;
      /** @description lib-analytics rating category to use */
      ratingCategory?: string | null;
      /**
       * @description Start match with minCount after maxIntervals (for large lobbies)
       * @default false
       */
      startWhenMinimumReached: boolean;
      /**
       * @description Whether players must be registered for a tournament
       * @default false
       */
      requiresRegistration: boolean;
      /**
       * @description Whether a tournament ID is required to join
       * @default false
       */
      tournamentIdRequired: boolean;
      /**
       * @description Seconds players have to accept/decline a formed match
       * @default 30
       */
      matchAcceptTimeoutSeconds: number;
      /**
       * Format: date-time
       * @description When the queue was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the queue was last updated
       */
      updatedAt?: string | null;
    };
    /** @description Statistics for a single matchmaking queue */
    QueueStats: {
      /** @description Queue identifier */
      queueId: string;
      /** @description Number of active tickets */
      currentTickets: number;
      /** @description Matches formed in the last hour */
      matchesFormedLastHour: number;
      /** @description Average wait time in seconds */
      averageWaitSeconds: number;
      /** @description Median wait time in seconds */
      medianWaitSeconds?: number | null;
      /** @description Percentage of tickets that timed out */
      timeoutRatePercent?: number | null;
      /** @description Percentage of tickets cancelled by user */
      cancelRatePercent?: number | null;
    };
    /** @description Summary information about a matchmaking queue */
    QueueSummary: {
      /** @description Unique identifier for the queue */
      queueId: string;
      /** @description Game this queue is for */
      gameId: string;
      /** @description Human-readable queue name */
      displayName: string;
      /** @description Whether the queue is currently accepting tickets */
      enabled: boolean;
      /** @description Minimum players required for a match */
      minCount: number;
      /** @description Maximum players in a match */
      maxCount: number;
      /** @description Current number of tickets in queue (if available) */
      currentTickets?: number | null;
      /** @description Average wait time in seconds (if available) */
      averageWaitSeconds?: number | null;
    };
    /** @description Request to re-affirm after validation failure */
    ReaffirmRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Party reaffirming
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Release token */
      releaseToken?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from party re-affirming after validation failure */
    ReaffirmResponse: {
      /** @description Reaffirmed escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Whether all parties have reaffirmed */
      allReaffirmed: boolean;
    };
    /** @description Summary information for an active realm clock */
    RealmClockSummary: {
      /**
       * Format: uuid
       * @description Realm identifier
       */
      realmId: string;
      /** @description Calendar template code in use */
      calendarTemplateCode: string;
      /**
       * Format: float
       * @description Current game-seconds per real-second
       */
      currentTimeRatio: number;
      /** @description Current season code */
      currentSeason: string;
      /** @description Current game year */
      currentYear: number;
      /**
       * Format: date-time
       * @description Real-world UTC timestamp of last clock advancement
       */
      lastAdvancedAt: string;
    };
    /** @description Realm worldstate configuration */
    RealmConfigResponse: {
      /**
       * Format: uuid
       * @description Realm identifier
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Game service the realm belongs to
       */
      gameServiceId: string;
      /** @description Calendar template code in use */
      calendarTemplateCode: string;
      /**
       * Format: float
       * @description Current game-seconds per real-second
       */
      currentTimeRatio: number;
      /** @description How clock gaps are handled after service downtime */
      downtimePolicy: components['schemas']['DowntimePolicy'];
      /**
       * Format: date-time
       * @description Real-world timestamp when the realm's clock started
       */
      realmEpoch: string;
      /** @description Whether the realm clock is initialized and active */
      isActive: boolean;
    };
    /**
     * @description Categories of historical events that realms can participate in
     * @enum {string}
     */
    RealmEventCategory:
      | 'FOUNDING'
      | 'WAR'
      | 'TREATY'
      | 'CATACLYSM'
      | 'DISCOVERY'
      | 'MIGRATION'
      | 'CULTURAL_SHIFT'
      | 'ECONOMIC_CHANGE'
      | 'POLITICAL_UPHEAVAL';
    /**
     * @description How the realm participated in the historical event
     * @enum {string}
     */
    RealmEventRole:
      | 'ORIGIN'
      | 'AGGRESSOR'
      | 'DEFENDER'
      | 'MEDIATOR'
      | 'AFFECTED'
      | 'BENEFICIARY'
      | 'INSTIGATOR'
      | 'NEUTRAL_PARTY';
    /** @description Request to check if a realm exists and is available for use */
    RealmExistsRequest: {
      /**
       * Format: uuid
       * @description ID of the realm to validate
       */
      realmId: string;
    };
    /** @description Response indicating whether a realm exists and its active status */
    RealmExistsResponse: {
      /** @description Whether the realm exists */
      exists: boolean;
      /** @description Whether the realm is active (false if deprecated or not found) */
      isActive: boolean;
      /**
       * Format: uuid
       * @description The realm ID if found
       */
      realmId?: string | null;
    };
    /** @description Record of a realm's participation in a historical event */
    RealmHistoricalParticipation: {
      /**
       * Format: uuid
       * @description Unique ID for this participation record
       */
      participationId: string;
      /**
       * Format: uuid
       * @description ID of the realm that participated
       */
      realmId: string;
      /**
       * Format: uuid
       * @description ID of the historical event
       */
      eventId: string;
      /** @description Name of the event (for display and summarization) */
      eventName: string;
      /** @description Category of the historical event */
      eventCategory: components['schemas']['RealmEventCategory'];
      /** @description How the realm participated */
      role: components['schemas']['RealmEventRole'];
      /**
       * Format: date-time
       * @description In-game date when the event occurred
       */
      eventDate: string;
      /**
       * Format: float
       * @description How significant this event was for the realm (0.0 to 1.0).
       *     Affects behavior system weighting.
       * @default 0.5
       */
      impact: number;
      /** @description Client-provided event-specific details. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When this record was created
       */
      createdAt: string;
    };
    /** @description Paginated list of realms with metadata for navigation */
    RealmListResponse: {
      /** @description List of realms matching the query criteria */
      realms: components['schemas']['RealmResponse'][];
      /** @description Total number of realms matching the query (before pagination) */
      totalCount: number;
      /** @description Current page number (1-indexed) */
      page: number;
      /** @description Number of realms per page */
      pageSize: number;
      /** @description Whether there are more realms available on the next page */
      hasNextPage?: boolean;
      /** @description Whether there are realms available on the previous page */
      hasPreviousPage?: boolean;
    };
    /** @description A machine-readable lore element for behavior system consumption */
    RealmLoreElement: {
      /** @description Category of this lore element */
      elementType: components['schemas']['RealmLoreElementType'];
      /**
       * @description Machine-readable key (e.g., "founding_year", "primary_export", "capital_city").
       *     Used by behavior system to query specific aspects.
       */
      key: string;
      /**
       * @description Machine-readable value (e.g., "year_of_the_dragon", "iron_ore", "stormgate").
       *     Referenced in behavior rules.
       */
      value: string;
      /**
       * Format: float
       * @description How strongly this element affects behavior (0.0 to 1.0).
       *     Higher strength = greater influence on decisions.
       * @default 0.5
       */
      strength: number;
      /**
       * Format: uuid
       * @description Optional related entity (location, organization, character)
       */
      relatedEntityId?: string | null;
      /** @description Type of the related entity (if any) */
      relatedEntityType?: string | null;
    };
    /**
     * @description Types of lore elements. Each type represents a different aspect
     *     of the realm's background that influences behavior.
     * @enum {string}
     */
    RealmLoreElementType:
      | 'ORIGIN_MYTH'
      | 'CULTURAL_PRACTICE'
      | 'POLITICAL_SYSTEM'
      | 'ECONOMIC_BASE'
      | 'RELIGIOUS_TRADITION'
      | 'GEOGRAPHIC_FEATURE'
      | 'FAMOUS_FIGURE'
      | 'TECHNOLOGICAL_LEVEL';
    /** @description Complete lore data for a realm */
    RealmLoreResponse: {
      /**
       * Format: uuid
       * @description ID of the realm this lore belongs to
       */
      realmId: string;
      /** @description All lore elements for this realm */
      elements: components['schemas']['RealmLoreElement'][];
      /**
       * Format: date-time
       * @description When this lore was first created
       */
      createdAt?: string | null;
      /**
       * Format: date-time
       * @description When this lore was last modified
       */
      updatedAt?: string | null;
    };
    /** @description Paginated list of participation records */
    RealmParticipationListResponse: {
      /** @description List of participation records */
      participations: components['schemas']['RealmHistoricalParticipation'][];
      /** @description Total number of matching records */
      totalCount: number;
      /** @description Current page number (1-based) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more results after this page */
      hasNextPage?: boolean;
      /** @description Whether there are results before this page */
      hasPreviousPage?: boolean;
    };
    /** @description Complete realm information returned from API operations */
    RealmResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the realm
       */
      realmId: string;
      /** @description Unique code for the realm (e.g., "REALM_1", "REALM_2") */
      code: string;
      /** @description Display name for the realm */
      name: string;
      /**
       * Format: uuid
       * @description ID of the game service this realm belongs to
       */
      gameServiceId: string;
      /** @description Detailed description of the realm */
      description?: string | null;
      /** @description Category for grouping realms */
      category?: string | null;
      /** @description Whether the realm is currently active for gameplay */
      isActive: boolean;
      /** @description Whether this realm is a system infrastructure realm (e.g., VOID). System realms cannot be merged as source. */
      isSystemType: boolean;
      /** @description Whether this realm is deprecated and cannot be used for new entities */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this realm was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation */
      deprecationReason?: string | null;
      /** @description Client-only metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Timestamp when the realm was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the realm was last updated
       */
      updatedAt: string;
    };
    /** @description Request to check if multiple realms exist and are available for use */
    RealmsExistBatchRequest: {
      /** @description List of realm IDs to validate (max 100) */
      realmIds: string[];
    };
    /** @description Batch validation results for multiple realms */
    RealmsExistBatchResponse: {
      /** @description Validation result for each requested realm ID (in same order as request) */
      results: components['schemas']['RealmExistsResponse'][];
      /** @description True if all requested realms exist */
      allExist: boolean;
      /** @description True if all requested realms exist AND are active (not deprecated) */
      allActive: boolean;
      /** @description List of realm IDs that do not exist (empty if all exist) */
      invalidRealmIds?: string[];
      /** @description List of realm IDs that exist but are deprecated (empty if none deprecated) */
      deprecatedRealmIds?: string[];
    };
    /** @description Request to record growth across multiple domains atomically. */
    RecordGrowthBatchRequest: {
      /**
       * Format: uuid
       * @description The seed to record growth for.
       */
      seedId: string;
      /** @description Domain-amount pairs to record. */
      entries: components['schemas']['GrowthEntry'][];
      /** @description Identifier of the contributing service. */
      source: string;
    };
    /** @description Request to record growth in a specific domain. */
    RecordGrowthRequest: {
      /**
       * Format: uuid
       * @description The seed to record growth for.
       */
      seedId: string;
      /** @description Dot-separated domain path (e.g., "combat.melee.sword"). New domains are created automatically on first contribution. */
      domain: string;
      /**
       * Format: float
       * @description Amount of growth to add.
       */
      amount: number;
      /** @description Identifier of the contributing service (e.g., "character-encounter"). */
      source: string;
      /**
       * Format: uuid
       * @description Optional reference to the originating event.
       */
      sourceEventId?: string | null;
    };
    /** @description Information about a reference */
    ReferenceInfo: {
      /**
       * Format: uuid
       * @description Scene containing the reference
       */
      sceneId: string;
      /** @description Name of the referencing scene */
      sceneName: string;
      /**
       * Format: uuid
       * @description Node containing the reference
       */
      nodeId: string;
      /** @description refId of the referencing node */
      nodeRefId: string;
      /** @description Name of the referencing node */
      nodeName?: string;
    };
    /** @description Request to obtain a new access token using a valid refresh token */
    RefreshRequest: {
      /** @description Refresh token issued during authentication to obtain a new access token */
      refreshToken: string;
    };
    /**
     * @description Controls how refund confirmation is handled. Same semantics as ReleaseMode.
     *     Refunds typically use 'immediate' since parties get their own assets back.
     * @enum {string}
     */
    RefundMode: 'immediate' | 'service_only' | 'party_required';
    /** @description Request to trigger escrow refund to depositors */
    RefundRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /** @description For initiator_trusted mode */
      initiatorServiceId?: string | null;
      /** @description Reason for refund */
      reason?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from refunding escrow assets to depositors */
    RefundResponse: {
      /** @description Refunded escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Refund results per depositor */
      refunds: components['schemas']['RefundResult'][];
    };
    /** @description Result of refunding assets to a single depositor */
    RefundResult: {
      /**
       * Format: uuid
       * @description Depositor party ID
       */
      depositorPartyId: string;
      /** @description Assets refunded (null if failed) */
      assets?: components['schemas']['EscrowAssetBundle'];
      /** @description Whether refund succeeded */
      success: boolean;
      /** @description Error message if failed */
      error?: string | null;
    };
    /** @description Request to register a character as a deity follower */
    RegisterFollowerRequest: {
      /**
       * Format: uuid
       * @description Deity to follow
       */
      deityId: string;
      /**
       * Format: uuid
       * @description Character becoming a follower
       */
      characterId: string;
    };
    /** @description Request to register a reference to a resource */
    RegisterReferenceRequest: {
      /** @description Type of resource being referenced (opaque identifier, e.g., "character", "realm") */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource being referenced
       */
      resourceId: string;
      /** @description Type of entity holding the reference (opaque identifier, e.g., "actor", "scene") */
      sourceType: string;
      /** @description ID of the entity holding the reference (opaque string, supports non-Guid IDs) */
      sourceId: string;
    };
    /** @description Response after registering a reference */
    RegisterReferenceResponse: {
      /** @description Type of resource referenced */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource referenced
       */
      resourceId: string;
      /** @description Reference count after registration */
      newRefCount: number;
      /** @description True if this exact reference was already registered */
      alreadyRegistered: boolean;
    };
    /** @description Request to register a new user account */
    RegisterRequest: {
      /**
       * @description Unique username for the account
       * @example gameuser123
       */
      username: string;
      /**
       * Format: password
       * @description Password for the account (will be hashed)
       * @example SecurePassword123!
       */
      password: string;
      /**
       * Format: email
       * @description Email address for account recovery and notifications
       * @example user@example.com
       */
      email: string;
    };
    /** @description Response from successful user registration */
    RegisterResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the newly created account
       */
      accountId: string;
      /**
       * @description JWT access token for immediate authentication
       * @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJnYW1ldXNlcjEyMyIsImlhdCI6MTY0MDk5NTIwMCwiZXhwIjoxNjQwOTk4ODAwfQ.signature
       */
      accessToken: string;
      /**
       * @description Refresh token for obtaining new access tokens
       * @example refresh_token_abc123xyz789
       */
      refreshToken?: string | null;
      /**
       * Format: uri
       * @description WebSocket endpoint for Connect service
       */
      connectUrl: string;
    };
    /** @description Request to register a new room type definition */
    RegisterRoomTypeRequest: {
      /** @description Unique room type code (e.g., "text", "guild_board", "trade_posting") */
      code: string;
      /** @description Human-readable name for the room type */
      displayName: string;
      /** @description Optional description of the room type */
      description?: string | null;
      /**
       * Format: uuid
       * @description Game service scope (null for global types)
       */
      gameServiceId?: string | null;
      /** @description Content format this room type accepts */
      messageFormat: components['schemas']['MessageFormat'];
      /** @description Validation rules for messages (null uses format defaults) */
      validatorConfig?: components['schemas']['ValidatorConfig'] | null;
      /** @description Message storage mode (ephemeral or persistent) */
      persistenceMode: components['schemas']['PersistenceMode'];
      /** @description Default participant limit (null uses service default) */
      defaultMaxParticipants?: number | null;
      /** @description Message retention in days (null uses service default) */
      retentionDays?: number | null;
      /**
       * Format: uuid
       * @description Default contract template for rooms of this type
       */
      defaultContractTemplateId?: string | null;
      /** @description Whether null senderId is allowed in messages */
      allowAnonymousSenders: boolean;
      /** @description Messages per minute per participant (null uses service default) */
      rateLimitPerMinute?: number | null;
      /** @description Client-only metadata stored as JSON string. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: string | null;
    };
    /** @description Request to register a new save data schema with optional migration rules */
    RegisterSchemaRequest: {
      /** @description Schema namespace (e.g., game identifier) */
      namespace: string;
      /** @description Schema version identifier */
      schemaVersion: string;
      /** @description JSON Schema definition for validation */
      schema: Record<string, never>;
      /** @description Previous version this migrates from */
      previousVersion?: string | null;
      /**
       * @description JSON Patch (RFC 6902) operations to migrate from previousVersion.
       *     Uses JsonPatch.Net library (MIT licensed).
       */
      migrationPatch?: components['schemas']['JsonPatchOperation'][] | null;
    };
    /** @description Request to register a new seed type definition. */
    RegisterSeedTypeRequest: {
      /** @description Unique code for this seed type (e.g., "guardian", "dungeon_core"). */
      seedTypeCode: string;
      /**
       * Format: uuid
       * @description Game service this type is scoped to. Null for cross-game seed types that are not scoped to any single game service.
       */
      gameServiceId?: string | null;
      /** @description Human-readable name. */
      displayName: string;
      /** @description Description of what this seed type represents. */
      description: string;
      /** @description Maximum seeds of this type per owner entity. */
      maxPerOwner: number;
      /** @description Entity types that can own seeds of this type. */
      allowedOwnerTypes: components['schemas']['EntityType'][];
      /** @description Ordered growth phase definitions with thresholds. */
      growthPhases: components['schemas']['GrowthPhaseDefinition'][];
      /** @description Max bond participants. 0 = no bonding, 1 = pair bonds, N = group bonds of up to N+1 participants. */
      bondCardinality: number;
      /**
       * @description Whether bonds of this type are permanent (cannot be dissolved). True for guardian spirit pair bonds, false for dungeon-master bonds that can end when the contract dissolves.
       * @default false
       */
      bondPermanent: boolean;
      /** @description Rules for computing capabilities from growth domains. */
      capabilityRules?: components['schemas']['CapabilityRule'][] | null;
      /** @description Whether unused growth domains decay over time for this seed type. Falls back to global config if null. */
      growthDecayEnabled?: boolean | null;
      /**
       * Format: float
       * @description Daily decay rate for unused domains of this seed type. Falls back to global config if null.
       */
      growthDecayRatePerDay?: number | null;
      /**
       * Format: float
       * @description Fraction of growth applied to other seeds of the same type owned by the same entity. 0.0 = no sharing (default), 1.0 = full mirror.
       * @default 0
       */
      sameOwnerGrowthMultiplier: number;
      /** @description Mappings from collection types to growth domains. When a collection entry is unlocked for an entity that owns seeds of this type, the entry's tags are matched against these mappings to determine growth contributions. Null means this seed type does not respond to collection unlocks. */
      collectionGrowthMappings?: components['schemas']['CollectionGrowthMapping'][] | null;
    };
    /**
     * @description How deep to traverse related document links:
     *     - none: No related documents included
     *     - direct: Only directly linked documents (depth 1)
     *     - extended: Related documents + their related documents (depth 2)
     * @default direct
     * @enum {string}
     */
    RelatedDepth: 'none' | 'direct' | 'extended';
    /** @description Paginated list of relationships with metadata for navigation */
    RelationshipListResponse: {
      /** @description List of relationships matching the query */
      relationships: components['schemas']['RelationshipResponse'][];
      /** @description Total number of relationships matching the query */
      totalCount: number;
      /** @description Current page number (1-based) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more results on the next page */
      hasNextPage?: boolean;
      /** @description Whether there are results on the previous page */
      hasPreviousPage?: boolean;
    };
    /** @description Complete details of a relationship between two entities */
    RelationshipResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the relationship
       */
      relationshipId: string;
      /**
       * Format: uuid
       * @description ID of the first entity in the relationship
       */
      entity1Id: string;
      /** @description Type of the first entity in the relationship */
      entity1Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the second entity in the relationship
       */
      entity2Id: string;
      /** @description Type of the second entity in the relationship */
      entity2Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Relationship type ID defining the kind of relationship
       */
      relationshipTypeId: string;
      /**
       * Format: date-time
       * @description In-game timestamp when relationship started
       */
      startedAt: string;
      /**
       * Format: date-time
       * @description In-game timestamp when relationship ended, null if still active
       */
      endedAt?: string | null;
      /** @description Client-provided relationship data. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description System timestamp when the relationship record was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description System timestamp when the relationship record was last updated
       */
      updatedAt?: string | null;
    };
    /** @description Snapshot of a relationship */
    RelationshipSnapshot: {
      /** @description Relationship type code */
      relationshipTypeCode: string;
      /**
       * Format: uuid
       * @description ID of other entity
       */
      otherEntityId: string;
      /** @description Type of other entity */
      otherEntityType: string;
    };
    /** @description Response containing a list of relationship types with total count */
    RelationshipTypeListResponse: {
      /** @description List of relationship types matching the query */
      types: components['schemas']['RelationshipTypeResponse'][];
      /** @description Total number of relationship types returned */
      totalCount: number;
    };
    /** @description Complete representation of a relationship type including hierarchy, inverse, and deprecation information */
    RelationshipTypeResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the relationship type
       */
      relationshipTypeId: string;
      /** @description Unique code for the relationship type (e.g., "SON", "MOTHER") */
      code: string;
      /** @description Human-readable display name for the relationship type */
      name: string;
      /** @description Detailed description of the relationship type */
      description?: string | null;
      /** @description Category for grouping relationship types (e.g., "FAMILY", "SOCIAL") */
      category?: string | null;
      /**
       * Format: uuid
       * @description ID of the parent type in the hierarchy (null for root types)
       */
      parentTypeId?: string | null;
      /** @description Code of the parent type (for convenience) */
      parentTypeCode?: string | null;
      /**
       * Format: uuid
       * @description ID of the inverse relationship type (e.g., PARENT is inverse of CHILD)
       */
      inverseTypeId?: string | null;
      /** @description Code of the inverse relationship type (for convenience) */
      inverseTypeCode?: string | null;
      /** @description Whether the relationship is the same in both directions (e.g., SIBLING) */
      isBidirectional: boolean;
      /** @description Whether this type is deprecated and cannot be used for new relationships */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this type was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation */
      deprecationReason?: string | null;
      /** @description Depth in the hierarchy (0 for root types) */
      depth: number;
      /** @description Client-provided relationship type metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Timestamp when the relationship type was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the relationship type was last updated
       */
      updatedAt: string;
    };
    /** @description Defines who gets what on release */
    ReleaseAllocation: {
      /**
       * Format: uuid
       * @description Party receiving assets
       */
      recipientPartyId: string;
      /** @description Type of the recipient party */
      recipientPartyType: components['schemas']['EntityType'];
      /** @description Assets this recipient should receive */
      assets: components['schemas']['EscrowAsset'][];
      /**
       * Format: uuid
       * @description Where to deliver currency
       */
      destinationWalletId?: string | null;
      /**
       * Format: uuid
       * @description Where to deliver items
       */
      destinationContainerId?: string | null;
    };
    /** @description Input for specifying how assets should be allocated on release */
    ReleaseAllocationInput: {
      /**
       * Format: uuid
       * @description Recipient party ID
       */
      recipientPartyId: string;
      /** @description Recipient party type */
      recipientPartyType: components['schemas']['EntityType'];
      /** @description Assets to allocate */
      assets: components['schemas']['EscrowAssetInput'][];
      /**
       * Format: uuid
       * @description Destination wallet
       */
      destinationWalletId?: string | null;
      /**
       * Format: uuid
       * @description Destination container
       */
      destinationContainerId?: string | null;
    };
    /** @description Request to release a hold */
    ReleaseHoldRequest: {
      /**
       * Format: uuid
       * @description Hold ID to release
       */
      holdId: string;
    };
    /**
     * @description Controls how release confirmation is handled:
     *     - immediate: Finalizing  Released (skip Releasing state entirely).
     *        WARNING: Use only for trusted/low-value scenarios (NPC vendors, system rewards).
     *       Assets are marked as released BEFORE downstream services confirm transfers.
     *       If downstream services fail, manual intervention may be required.
     *     - service_only: Wait for downstream services (currency, inventory) to confirm transfers complete.
     *     - party_required: Wait for all parties to call /confirm-release.
     *     - service_and_party: Wait for both service completion AND party confirmation.
     * @enum {string}
     */
    ReleaseMode: 'immediate' | 'service_only' | 'party_required' | 'service_and_party';
    /** @description Request to trigger escrow release to recipients */
    ReleaseRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /** @description For initiator_trusted mode */
      initiatorServiceId?: string | null;
      /** @description Optional notes */
      notes?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from releasing escrow assets to recipients */
    ReleaseResponse: {
      /** @description Released escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Results of contract finalizer APIs */
      finalizerResults: components['schemas']['FinalizerResult'][];
      /** @description Release results per recipient */
      releases: components['schemas']['ReleaseResult'][];
    };
    /** @description Result of releasing assets to a single recipient */
    ReleaseResult: {
      /**
       * Format: uuid
       * @description Recipient party ID
       */
      recipientPartyId: string;
      /** @description Assets released (null if failed) */
      assets?: components['schemas']['EscrowAssetBundle'];
      /** @description Whether release succeeded */
      success: boolean;
      /** @description Error message if failed */
      error?: string | null;
    };
    /** @description Request to release a territory claim */
    ReleaseTerritoryRequest: {
      /**
       * Format: uuid
       * @description ID of the territory claim to release
       */
      claimId: string;
    };
    /** @description Request to remove all statuses of a category for an entity (cleanse) */
    RemoveByCategoryRequest: {
      /**
       * Format: uuid
       * @description Entity to cleanse statuses from
       */
      entityId: string;
      /** @description Entity type discriminator */
      entityType: components['schemas']['EntityType'];
      /** @description Category of statuses to remove */
      category: components['schemas']['StatusCategory'];
      /** @description Why these statuses are being removed */
      reason: components['schemas']['StatusRemoveReason'];
    };
    /** @description Request to remove all statuses from a specific source for an entity */
    RemoveBySourceRequest: {
      /**
       * Format: uuid
       * @description Entity to remove statuses from
       */
      entityId: string;
      /** @description Entity type discriminator */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Source that originally granted the statuses
       */
      sourceId: string;
    };
    /** @description Request to remove item from container */
    RemoveItemRequest: {
      /**
       * Format: uuid
       * @description Item instance ID to remove
       */
      instanceId: string;
    };
    /** @description Response after removing item. HTTP 200 confirms removal. */
    RemoveItemResponse: {
      /**
       * Format: uuid
       * @description Container the item was removed from
       */
      previousContainerId: string;
    };
    /** @description Request to remove a license definition from a board template */
    RemoveLicenseDefinitionRequest: {
      /**
       * Format: uuid
       * @description Board template containing the definition
       */
      boardTemplateId: string;
      /** @description License code to remove */
      code: string;
    };
    /** @description Request to remove a character from a faction */
    RemoveMemberRequest: {
      /**
       * Format: uuid
       * @description Faction to remove the character from
       */
      factionId: string;
      /**
       * Format: uuid
       * @description Character to remove
       */
      characterId: string;
    };
    /** @description Request to remove a specific status instance */
    RemoveStatusRequest: {
      /**
       * Format: uuid
       * @description Status instance to remove
       */
      statusInstanceId: string;
      /** @description Why this status is being removed */
      reason: components['schemas']['StatusRemoveReason'];
    };
    /** @description Result of a bulk status removal operation */
    RemoveStatusesResponse: {
      /** @description Number of status instances removed */
      statusesRemoved: number;
    };
    /** @description Request to rename an existing save slot */
    RenameSlotRequest: {
      /** @description Game identifier */
      gameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the slot
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Current slot name */
      slotName: string;
      /** @description New slot name */
      newSlotName: string;
    };
    /** @description Request to report a breach */
    ReportBreachRequest: {
      /**
       * Format: uuid
       * @description Contract that was breached
       */
      contractId: string;
      /**
       * Format: uuid
       * @description Entity that breached
       */
      breachingEntityId: string;
      /** @description Type of breaching entity */
      breachingEntityType: components['schemas']['EntityType'];
      /** @description Type of breach */
      breachType: components['schemas']['BreachType'];
      /** @description Code of breached term or milestone */
      breachedTermOrMilestone?: string | null;
      /** @description Breach description */
      description?: string | null;
    };
    /** @description Request to report an entity's presence at a location */
    ReportEntityPositionRequest: {
      /** @description Type of entity (opaque string - character, actor, npc, player, etc.) */
      entityType: string;
      /**
       * Format: uuid
       * @description ID of the entity being reported
       */
      entityId: string;
      /**
       * Format: uuid
       * @description ID of the location the entity is at
       */
      locationId: string;
      /**
       * Format: uuid
       * @description Caller hint for the entity's previous location (optimization to skip GET on refresh)
       */
      previousLocationId?: string | null;
      /**
       * Format: uuid
       * @description ID of the realm the location belongs to (included in arrival events if provided)
       */
      realmId?: string | null;
      /** @description Identifier of the reporter (service name or session ID) */
      reportedBy?: string | null;
    };
    /** @description Result of reporting entity presence. HTTP 200 confirms the position was recorded. */
    ReportEntityPositionResponse: {
      /**
       * Format: uuid
       * @description Location ID the entity arrived at (only set when location changed)
       */
      arrivedAt?: string | null;
      /**
       * Format: uuid
       * @description Location ID the entity departed from (only set when location changed)
       */
      departedFrom?: string | null;
    };
    /** @description Request to report progress on a quest objective */
    ReportProgressRequest: {
      /**
       * Format: uuid
       * @description Quest instance
       */
      questInstanceId: string;
      /** @description Objective code */
      objectiveCode: string;
      /** @description Amount to increment progress */
      incrementBy: number;
      /**
       * Format: uuid
       * @description Entity that contributed to progress (for deduplication)
       */
      trackedEntityId?: string | null;
    };
    /** @description Detailed repository binding configuration and status */
    RepositoryBindingInfo: {
      /**
       * Format: uuid
       * @description Unique identifier of the repository binding
       */
      bindingId: string;
      /** @description Namespace the repository is bound to */
      namespace: string;
      /** @description URL of the bound repository */
      repositoryUrl: string;
      /** @description Branch being synced */
      branch?: string;
      /** @description Current status of the binding */
      status: components['schemas']['BindingStatus'];
      /** @description Whether automatic sync is enabled */
      syncEnabled?: boolean;
      /** @description Sync interval in minutes */
      syncIntervalMinutes?: number;
      /** @description Number of documents from this repository */
      documentCount?: number;
      /**
       * Format: date-time
       * @description Timestamp when the binding was created
       */
      createdAt?: string;
      /**
       * @description Owner of this binding. NOT a session ID.
       *     Contains either an accountId (UUID format) for user-initiated bindings
       *     or a service name for service-initiated bindings.
       */
      owner?: string;
    };
    /** @description Request to get current repository binding and sync status */
    RepositoryStatusRequest: {
      /** @description Documentation namespace to get status for */
      namespace: string;
    };
    /** @description Response containing binding configuration and recent sync information */
    RepositoryStatusResponse: {
      /** @description Current binding configuration and status */
      binding?: components['schemas']['RepositoryBindingInfo'];
      /** @description Information about the most recent sync */
      lastSync?: components['schemas']['SyncInfo'];
    };
    /** @description Request for full snapshot */
    RequestSnapshotRequest: {
      /**
       * Format: uuid
       * @description Region to snapshot
       */
      regionId: string;
      /** @description Which kinds to include (default all) */
      kinds?: components['schemas']['MapKind'][] | null;
      /** @description Optional bounds filter */
      bounds?: components['schemas']['Bounds'];
      /**
       * @description Optional authority token. If provided and valid, clears the
       *     RequiresConsumeBeforePublish flag for require_consume takeover mode.
       */
      authorityToken?: string | null;
    };
    /** @description Snapshot response */
    RequestSnapshotResponse: {
      /**
       * Format: uuid
       * @description Region ID
       */
      regionId?: string;
      /** @description All objects in snapshot */
      objects?: components['schemas']['MapObject'][];
      /** @description For large snapshots, lib-asset reference */
      payloadRef?: string | null;
      /**
       * Format: int64
       * @description Snapshot version
       */
      version?: number;
    };
    /** @description Reservation token returned when creating a matchmade session */
    ReservationInfo: {
      /**
       * Format: uuid
       * @description Account ID this reservation is for
       */
      accountId: string;
      /** @description Token to claim this reservation */
      token: string;
      /**
       * Format: date-time
       * @description When this reservation expires
       */
      expiresAt: string;
    };
    /** @description Request to resolve optimal bundle downloads for requested assets */
    ResolveBundlesRequest: {
      /** @description Platform asset IDs to resolve */
      assetIds: string[];
      /** @description Game realm to search within */
      realm: components['schemas']['GameRealm'];
      /**
       * @description Prefer metabundles when coverage is equal
       * @default true
       */
      preferMetabundles: boolean;
      /**
       * @description Include standalone assets not in any bundle
       * @default true
       */
      includeStandalone: boolean;
      /** @description Maximum number of bundles to return (optimization limit) */
      maxBundles?: number | null;
    };
    /** @description Optimal bundle set for requested assets */
    ResolveBundlesResponse: {
      /** @description Bundles to download */
      bundles: components['schemas']['ResolvedBundle'][];
      /** @description Individual assets to download */
      standaloneAssets: components['schemas']['ResolvedAsset'][];
      /** @description Coverage statistics */
      coverage: components['schemas']['CoverageAnalysis'];
      /** @description Asset IDs that couldn't be found (null if all resolved) */
      unresolved?: string[] | null;
    };
    /** @description Request for arbiter to resolve a disputed escrow */
    ResolveRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Arbiter ID
       */
      arbiterId: string;
      /** @description Arbiter type */
      arbiterType: components['schemas']['EntityType'];
      /** @description Resolution decision for the dispute */
      resolution: components['schemas']['EscrowResolution'];
      /** @description For split resolution */
      splitAllocations?: components['schemas']['SplitAllocation'][] | null;
      /** @description Resolution notes */
      notes?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from arbiter resolving a disputed escrow */
    ResolveResponse: {
      /** @description Resolved escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Transfer results */
      transfers: components['schemas']['TransferResult'][];
    };
    /** @description A standalone asset selected for download */
    ResolvedAsset: {
      /** @description Asset identifier */
      assetId: string;
      /**
       * Format: uri
       * @description Pre-signed download URL
       */
      downloadUrl: string;
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Asset file size in bytes
       */
      size: number;
      /** @description SHA256 hash of asset content */
      contentHash?: string | null;
    };
    /** @description A bundle selected for download in resolution */
    ResolvedBundle: {
      /** @description Human-readable bundle identifier */
      bundleId: string;
      /** @description Whether source or metabundle */
      bundleType: components['schemas']['BundleType'];
      /** @description Bundle version */
      version?: string | null;
      /**
       * Format: uri
       * @description Pre-signed download URL
       */
      downloadUrl: string;
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Bundle file size in bytes
       */
      size: number;
      /** @description Which of the requested assets this bundle provides */
      assetsProvided: string[];
    };
    /** @description A successfully resolved scene reference */
    ResolvedReference: {
      /**
       * Format: uuid
       * @description Node ID containing the reference
       */
      nodeId: string;
      /** @description refId of the referencing node */
      refId: string;
      /**
       * Format: uuid
       * @description ID of the referenced scene
       */
      referencedSceneId: string;
      /** @description Version that was resolved */
      referencedVersion?: string | null;
      /** @description The resolved scene content */
      scene: components['schemas']['Scene'];
      /** @description Depth level of this reference */
      depth?: number;
    };
    /** @description Bundled compressed archive */
    ResourceArchive: {
      /**
       * Format: uuid
       * @description Unique identifier for this archive
       */
      archiveId: string;
      /** @description Type of resource archived */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource archived
       */
      resourceId: string;
      /** @description Archive version (increments on re-compression) */
      version: number;
      /** @description Data entries from each compression callback */
      entries: components['schemas']['ArchiveBundleEntry'][];
      /**
       * Format: date-time
       * @description When this archive was created
       */
      createdAt: string;
      /** @description Whether original source data was deleted after archival */
      sourceDataDeleted: boolean;
    };
    /**
     * @description Base schema for all resource archives that can be stored in
     *     the resource service's archive bundles and consumed by the
     *     storyline SDK's ArchiveExtractor.
     *
     *     Archives implementing this base schema are marked with
     *     x-archive-type: true and are automatically collected by
     *     the archive generation script for SDK model generation.
     */
    ResourceArchiveBase: {
      /**
       * Format: uuid
       * @description Unique identifier of the archived resource
       */
      resourceId: string;
      /** @description Type identifier (e.g., "character", "character-personality", "realm-history") */
      resourceType: string;
      /**
       * Format: date-time
       * @description When this archive was created
       */
      archivedAt: string;
      /** @description Schema version for forward compatibility migration */
      schemaVersion: number;
      /** @description Child archives from dependent resources (populated by lib-resource compression) */
      nestedArchives?: components['schemas']['ResourceArchiveBase'][];
    };
    /** @description A reference from a source entity to a resource */
    ResourceReference: {
      /** @description Type of entity holding the reference (opaque identifier) */
      sourceType: string;
      /** @description ID of the entity holding the reference (opaque string, supports non-Guid IDs) */
      sourceId: string;
      /**
       * Format: date-time
       * @description When this reference was registered
       */
      registeredAt: string;
    };
    /** @description Ephemeral snapshot of a living resource */
    ResourceSnapshot: {
      /**
       * Format: uuid
       * @description Unique identifier for this snapshot
       */
      snapshotId: string;
      /** @description Type of resource snapshotted */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource snapshotted
       */
      resourceId: string;
      /** @description Label for snapshot purpose (e.g., "storyline_seed") */
      snapshotType: string;
      /** @description Data entries from each compression callback (same format as archives) */
      entries: components['schemas']['ArchiveBundleEntry'][];
      /**
       * Format: date-time
       * @description When this snapshot was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When this snapshot will expire
       */
      expiresAt: string;
    };
    /** @description Validation rules for API responses with three-outcome model (success, permanent failure, transient failure) */
    ResponseValidation: {
      /** @description Conditions that must ALL pass for success; if any fail, checks permanent failure conditions */
      successConditions?: components['schemas']['ValidationCondition'][];
      /** @description Conditions that indicate permanent failure (clause violated); checked when success conditions fail */
      permanentFailureConditions?: components['schemas']['ValidationCondition'][];
      /** @description HTTP status codes indicating transient failure for retry (default 408, 429, 502, 503, 504) */
      transientFailureStatusCodes?: number[];
    };
    /** @description Request to restore a soft-deleted bundle */
    RestoreBundleRequest: {
      /** @description Human-readable bundle identifier to restore */
      bundleId: string;
      /** @description Optional reason for restoration (recorded in version history) */
      reason?: string | null;
    };
    /** @description Result of bundle restoration */
    RestoreBundleResponse: {
      /** @description Human-readable bundle identifier that was restored */
      bundleId: string;
      /** @description Current bundle status (should be "active") */
      status: string;
      /**
       * Format: date-time
       * @description When the bundle was restored
       */
      restoredAt: string;
      /** @description Version number the bundle was restored from */
      restoredFromVersion: number;
    };
    /** @description Request to revoke an active blessing */
    RevokeBlessingRequest: {
      /**
       * Format: uuid
       * @description Blessing to revoke
       */
      blessingId: string;
      /** @description Why the blessing is being revoked */
      reason: string;
    };
    /** @description Reward granted when a quest is completed */
    RewardDefinition: {
      /**
       * @description Type of reward
       * @enum {string}
       */
      type: 'CURRENCY' | 'ITEM' | 'EXPERIENCE' | 'REPUTATION';
      /** @description Currency code for CURRENCY rewards */
      currencyCode?: string | null;
      /** @description Amount for CURRENCY/EXPERIENCE rewards */
      amount?: number | null;
      /** @description Item code for ITEM rewards */
      itemCode?: string | null;
      /** @description Quantity for ITEM rewards */
      quantity?: number | null;
      /** @description Faction code for REPUTATION rewards */
      factionCode?: string | null;
    };
    /** @description Room type definition with current configuration and status */
    RoomTypeResponse: {
      /** @description Unique room type code */
      code: string;
      /** @description Human-readable name */
      displayName: string;
      /** @description Room type description */
      description?: string | null;
      /**
       * Format: uuid
       * @description Game service scope (null for global)
       */
      gameServiceId?: string | null;
      /** @description Content format accepted by this room type */
      messageFormat: components['schemas']['MessageFormat'];
      /** @description Active validation rules */
      validatorConfig?: components['schemas']['ValidatorConfig'] | null;
      /** @description Message storage mode */
      persistenceMode: components['schemas']['PersistenceMode'];
      /** @description Default participant limit */
      defaultMaxParticipants?: number | null;
      /** @description Message retention in days */
      retentionDays?: number | null;
      /**
       * Format: uuid
       * @description Default contract template ID
       */
      defaultContractTemplateId?: string | null;
      /** @description Whether anonymous senders are allowed */
      allowAnonymousSenders: boolean;
      /** @description Messages per minute limit */
      rateLimitPerMinute?: number | null;
      /** @description Client-only metadata stored as JSON string. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: string | null;
      /** @description Current lifecycle status of the room type */
      status: components['schemas']['RoomTypeStatus'];
      /**
       * Format: date-time
       * @description When the room type was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the room type was last updated
       */
      updatedAt?: string | null;
    };
    /**
     * @description Lifecycle status of a room type definition
     * @enum {string}
     */
    RoomTypeStatus: 'Active' | 'Deprecated';
    /** @description Search engine optimization and social media sharing metadata */
    SEOMetadata: {
      /** @description Meta description for search engines */
      description?: string | null;
      /** @description Keywords for search engine indexing */
      keywords?: string[];
      /** @description Open Graph title for social media sharing */
      ogTitle?: string | null;
      /** @description Open Graph description for social media sharing */
      ogDescription?: string | null;
      /**
       * Format: uri
       * @description Open Graph image URL for social media sharing
       */
      ogImage?: string | null;
    };
    /**
     * @description Category of save with predefined behaviors.
     *     QUICK_SAVE: Single-slot fast save, overwritten frequently (max 1 version).
     *     AUTO_SAVE: System-triggered periodic saves (max 5 versions, rolling).
     *     MANUAL_SAVE: User-initiated named saves (max 10 versions, no auto-cleanup).
     *     CHECKPOINT: Progress markers (max 20 versions, rolling).
     *     STATE_SNAPSHOT: Full state captures for debugging (max 3 versions, rolling).
     * @enum {string}
     */
    SaveCategory: 'QUICK_SAVE' | 'AUTO_SAVE' | 'MANUAL_SAVE' | 'CHECKPOINT' | 'STATE_SNAPSHOT';
    /** @description Request to save incremental changes as a delta from a base version */
    SaveDeltaRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Name of the slot to save the delta to */
      slotName: string;
      /** @description Version number this delta is based on */
      baseVersion: number;
      /**
       * Format: byte
       * @description Base64-encoded delta/patch data.
       *     For JSON_PATCH: Array of RFC 6902 operations
       *     For BSDIFF/XDELTA: Binary patch data
       */
      delta: string;
      /** @description Delta computation algorithm to use (defaults to JSON_PATCH) */
      algorithm?: components['schemas']['DeltaAlgorithm'] | null;
      /** @description Schema version of this save for migration tracking */
      schemaVersion?: string | null;
      /** @description Human-readable name for this delta save */
      displayName?: string | null;
      /** @description Device identifier for cross-device sync conflict detection */
      deviceId?: string | null;
      /** @description Custom key-value metadata for this delta version */
      metadata?: {
        [key: string]: string;
      } | null;
    };
    /** @description Result of delta save operation with size and chain information */
    SaveDeltaResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the save slot
       */
      slotId: string;
      /** @description New version number */
      versionNumber: number;
      /** @description Base version this delta is relative to */
      baseVersion: number;
      /**
       * Format: int64
       * @description Size of stored delta
       */
      deltaSizeBytes: number;
      /**
       * Format: int64
       * @description Estimated size when reconstructed
       */
      estimatedFullSizeBytes: number;
      /** @description Number of deltas in chain to base snapshot */
      chainLength?: number;
      /**
       * Format: double
       * @description Storage savings vs full snapshot (0-1)
       */
      compressionSavings?: number;
      /**
       * Format: date-time
       * @description When the delta version was created
       */
      createdAt: string;
    };
    /** @description Request to save game state data to a slot with optional compression and metadata */
    SaveRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Slot name (auto-created if doesn't exist) */
      slotName: string;
      /** @description Category for auto-created slots (defaults to MANUAL_SAVE) */
      category?: components['schemas']['SaveCategory'] | null;
      /**
       * Format: byte
       * @description Base64-encoded save data
       */
      data: string;
      /** @description Schema version identifier for migration tracking */
      schemaVersion?: string | null;
      /** @description Human-readable name for this save */
      displayName?: string | null;
      /**
       * Format: byte
       * @description Optional preview image (JPEG/WebP). Max size configurable
       *     (default 256KB). Used for save slot previews in game UI.
       */
      thumbnail?: string | null;
      /**
       * @description Optional device identifier for cloud save conflict detection.
       *     When provided, saves are prefixed/tagged with device info,
       *     enabling opt-in cross-device sync with collision awareness.
       */
      deviceId?: string | null;
      /** @description Custom metadata (e.g., level, playtime, location) */
      metadata?: {
        [key: string]: string;
      } | null;
      /** @description If provided, pin this version with checkpoint name */
      pinAsCheckpoint?: string | null;
    };
    /** @description Result of a save operation including version info and conflict detection */
    SaveResponse: {
      /**
       * Format: uuid
       * @description Slot identifier
       */
      slotId: string;
      /** @description Assigned version number */
      versionNumber: number;
      /** @description SHA-256 hash of save data */
      contentHash: string;
      /**
       * Format: int64
       * @description Size of save data in bytes
       */
      sizeBytes: number;
      /**
       * Format: int64
       * @description Compressed size (if compression applied)
       */
      compressedSizeBytes?: number;
      /**
       * Format: double
       * @description Compression ratio (0-1)
       */
      compressionRatio?: number;
      /** @description Whether version was pinned */
      pinned?: boolean;
      /** @description Checkpoint name if pinned */
      checkpointName?: string | null;
      /** @description Pre-signed URL to retrieve thumbnail (if provided) */
      thumbnailUrl?: string | null;
      /**
       * @description True if this save overwrote a version from a different device.
       *     Only relevant when deviceId is used for cloud sync.
       */
      conflictDetected?: boolean;
      /** @description Device ID of the overwritten version (if conflict) */
      conflictingDeviceId?: string | null;
      /** @description Version number that was overwritten (if conflict) */
      conflictingVersion?: number | null;
      /**
       * Format: date-time
       * @description Save timestamp
       */
      createdAt: string;
      /** @description Number of old versions cleaned up by rolling policy */
      versionsCleanedUp?: number;
      /**
       * @description True if async upload is enabled and data is queued for MinIO upload.
       *     Save is immediately loadable from Redis cache, but not yet durable.
       */
      uploadPending?: boolean;
    };
    /**
     * @description Primary gameplay category for a scenario template
     * @enum {string}
     */
    ScenarioCategory:
      | 'Combat'
      | 'Crafting'
      | 'Social'
      | 'Trade'
      | 'Exploration'
      | 'Magic'
      | 'Survival'
      | 'Mixed'
      | 'Narrative'
      | 'Tutorial';
    /** @description Chaining configuration for linking scenarios together */
    ScenarioChaining: {
      /** @description Template codes this scenario can chain into */
      leadsTo?: string[] | null;
      /** @description Per-code probability weights for chain selection */
      chainProbabilities?: {
        [key: string]: number;
      } | null;
      /**
       * @description Maximum chain depth allowed from the initial scenario
       * @default 3
       */
      maxChainDepth: number;
    };
    /** @description Response after completing a scenario */
    ScenarioCompletionResponse: {
      /**
       * Format: uuid
       * @description Completed scenario instance ID
       */
      scenarioInstanceId: string;
      /** @description Growth awarded per domain */
      growthAwarded: {
        [key: string]: number;
      };
      /** @description Whether the player should return to the garden */
      returnToGarden: boolean;
    };
    /** @description Content references linking a scenario template to game assets */
    ScenarioContent: {
      /**
       * Format: uuid
       * @description ABML behavior document ID for NPC orchestration
       */
      behaviorDocumentId?: string | null;
      /**
       * Format: uuid
       * @description Scene document ID for environment composition
       */
      sceneDocumentId?: string | null;
      /**
       * Format: uuid
       * @description Realm ID where this scenario takes place
       */
      realmId?: string | null;
      /** @description Location code within the realm */
      locationCode?: string | null;
    };
    /** @description A scenario definition template that can be triggered when conditions are met */
    ScenarioDefinition: {
      /**
       * Format: uuid
       * @description Unique scenario definition identifier
       */
      scenarioId: string;
      /** @description Human-readable scenario code (uppercase with underscores) */
      code: string;
      /** @description Display name for the scenario */
      name: string;
      /** @description Detailed scenario description */
      description?: string | null;
      /** @description Conditions that must ALL be met to trigger (AND logic) */
      triggerConditions: components['schemas']['TriggerCondition'][];
      /** @description Execution phases in order */
      phases: components['schemas']['ScenarioPhase'][];
      /** @description State mutations to apply on completion */
      mutations?: components['schemas']['ScenarioMutation'][] | null;
      /** @description Quests to spawn on completion */
      questHooks?: components['schemas']['ScenarioQuestHook'][] | null;
      /** @description Per-character cooldown in seconds (null uses default from config) */
      cooldownSeconds?: number | null;
      /** @description Tags for mutual exclusivity checking */
      exclusivityTags?: string[] | null;
      /**
       * @description Higher priority scenarios are checked first
       * @default 0
       */
      priority: number;
      /**
       * @description Whether scenario can be triggered
       * @default true
       */
      enabled: boolean;
      /**
       * Format: uuid
       * @description Realm scope (null means all realms)
       */
      realmId?: string | null;
      /**
       * Format: uuid
       * @description Game service scope (null means all games)
       */
      gameServiceId?: string | null;
      /** @description Classification tags for filtering */
      tags?: string[] | null;
      /**
       * @description Whether scenario definition is deprecated
       * @default false
       */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description When the scenario definition was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Reason for deprecation */
      deprecationReason?: string | null;
      /**
       * Format: date-time
       * @description When definition was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When definition was last modified
       */
      updatedAt?: string | null;
      /** @description ETag for optimistic concurrency */
      etag?: string | null;
    };
    /** @description Summary of a scenario definition */
    ScenarioDefinitionSummary: {
      /**
       * Format: uuid
       * @description Scenario identifier
       */
      scenarioId: string;
      /** @description Scenario code */
      code: string;
      /** @description Scenario name */
      name: string;
      /** @description Scenario priority */
      priority: number;
      /** @description Whether enabled */
      enabled: boolean;
      /** @description Whether deprecated */
      isDeprecated?: boolean;
      /**
       * Format: date-time
       * @description When deprecated
       */
      deprecatedAt?: string | null;
      /** @description Reason for deprecation */
      deprecationReason?: string | null;
      /** @description Number of trigger conditions */
      conditionCount?: number;
      /** @description Number of phases */
      phaseCount?: number;
      /** @description Number of mutations */
      mutationCount?: number;
      /** @description Number of quest hooks */
      questHookCount?: number;
      /**
       * Format: uuid
       * @description Realm scope
       */
      realmId?: string | null;
      /**
       * Format: uuid
       * @description Game service scope
       */
      gameServiceId?: string | null;
      /** @description Classification tags */
      tags?: string[] | null;
      /**
       * Format: date-time
       * @description When created
       */
      createdAt: string;
    };
    /** @description A scenario execution instance */
    ScenarioExecution: {
      /**
       * Format: uuid
       * @description Execution instance ID
       */
      executionId: string;
      /**
       * Format: uuid
       * @description Scenario definition ID
       */
      scenarioId: string;
      /** @description Scenario code */
      code: string;
      /** @description Scenario name */
      name: string;
      /** @description Current status */
      status: components['schemas']['ScenarioStatus'];
      /** @description Current phase number */
      currentPhase: number;
      /** @description Total phases */
      totalPhases: number;
      /**
       * Format: date-time
       * @description When triggered
       */
      triggeredAt: string;
      /**
       * Format: date-time
       * @description When completed (if applicable)
       */
      completedAt?: string | null;
    };
    /** @description Multiplayer configuration for group scenarios */
    ScenarioMultiplayer: {
      /** @description Minimum number of players required */
      minPlayers: number;
      /** @description Maximum number of players allowed */
      maxPlayers: number;
      /** @description Matchmaking queue code for automatic grouping */
      matchmakingQueueCode?: string | null;
      /**
       * @description Whether bonded players receive a scoring boost for this scenario
       * @default false
       */
      bondPreferred: boolean;
    };
    /** @description A state mutation to apply during scenario execution */
    ScenarioMutation: {
      /** @description Type of mutation to apply */
      mutationType: components['schemas']['MutationType'];
      /** @description Experience type for PersonalityEvolve (e.g., TRAUMA, VICTORY) */
      experienceType?: string | null;
      /**
       * Format: float
       * @description Experience intensity for PersonalityEvolve (0.0-1.0)
       */
      experienceIntensity?: number | null;
      /** @description Backstory element type for BackstoryAdd (e.g., TRAUMA, GOAL) */
      backstoryElementType?: string | null;
      /** @description Backstory element key for BackstoryAdd */
      backstoryKey?: string | null;
      /** @description Backstory element value for BackstoryAdd */
      backstoryValue?: string | null;
      /**
       * Format: float
       * @description Backstory element strength for BackstoryAdd (0.0-1.0)
       */
      backstoryStrength?: number | null;
      /** @description Relationship type code for RelationshipCreate/End */
      relationshipTypeCode?: string | null;
      /** @description Role name for other participant in multi-character scenarios */
      otherParticipantRole?: string | null;
    };
    /** @description A phase in scenario execution */
    ScenarioPhase: {
      /** @description Phase sequence number (1-based) */
      phaseNumber: number;
      /** @description Phase name */
      name: string;
      /** @description What happens in this phase */
      description?: string | null;
      /** @description Expected duration in seconds (for pacing, not enforced) */
      durationSeconds?: number | null;
      /** @description Hint for dialogue generation system */
      dialogueHint?: string | null;
      /** @description Hint for behavior/GOAP system */
      actionHint?: string | null;
    };
    /** @description Prerequisite requirements for entering a scenario */
    ScenarioPrerequisites: {
      /** @description Minimum growth depth per domain (domain path to minimum depth) */
      requiredDomains?: {
        [key: string]: number;
      } | null;
      /** @description Scenario template codes that must be completed first */
      requiredScenarios?: string[] | null;
      /** @description Scenario template codes that disqualify the player */
      excludedScenarios?: string[] | null;
    };
    /** @description Quest to spawn on scenario completion */
    ScenarioQuestHook: {
      /** @description Quest definition code to spawn */
      questCode: string;
      /**
       * @description Delay before spawning quest (not implemented in Phase 1)
       * @default 0
       */
      delaySeconds: number;
      /** @description Variable overrides for quest template */
      termOverrides?: {
        [key: string]: string;
      } | null;
    };
    /** @description Current state of a scenario instance */
    ScenarioStateResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for this scenario instance
       */
      scenarioInstanceId: string;
      /**
       * Format: uuid
       * @description Template this instance was created from
       */
      scenarioTemplateId: string;
      /**
       * Format: uuid
       * @description Backing game session ID
       */
      gameSessionId: string;
      /** @description How this scenario connects to the game world */
      connectivityMode: components['schemas']['ConnectivityMode'];
      /** @description Current lifecycle status */
      status: components['schemas']['ScenarioStatus'];
      /**
       * Format: date-time
       * @description When this instance was created
       */
      createdAt: string;
      /**
       * Format: uuid
       * @description Previous scenario instance if this was chained
       */
      chainedFrom?: string | null;
      /**
       * @description Current chain depth from the initial scenario
       * @default 0
       */
      chainDepth: number;
    };
    /**
     * @description Current lifecycle status of a scenario instance
     * @enum {string}
     */
    ScenarioStatus: 'Initializing' | 'Active' | 'Completing' | 'Completed' | 'Abandoned';
    /** @description Full scenario template with all fields */
    ScenarioTemplateResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for this template
       */
      scenarioTemplateId: string;
      /** @description Unique template code */
      code: string;
      /** @description Human-readable name */
      displayName: string;
      /** @description Template description */
      description: string;
      /** @description Primary gameplay category */
      category: components['schemas']['ScenarioCategory'];
      /** @description Subcategory within the primary category */
      subcategory?: string | null;
      /** @description Growth domain weights */
      domainWeights: components['schemas']['DomainWeight'][];
      /** @description Minimum seed growth phase */
      minGrowthPhase?: string | null;
      /** @description World connectivity mode */
      connectivityMode: components['schemas']['ConnectivityMode'];
      /** @description Deployment phases where this template is available. Always contains explicit values (never empty). */
      allowedPhases: components['schemas']['DeploymentPhase'][];
      /** @description Maximum concurrent active instances */
      maxConcurrentInstances: number;
      /** @description Estimated scenario duration in minutes */
      estimatedDurationMinutes?: number | null;
      /** @description Entry requirements */
      prerequisites?: components['schemas']['ScenarioPrerequisites'];
      /** @description Chaining configuration */
      chaining?: components['schemas']['ScenarioChaining'];
      /** @description Multiplayer support */
      multiplayer?: components['schemas']['ScenarioMultiplayer'];
      /** @description Content references */
      content?: components['schemas']['ScenarioContent'];
      /** @description Current lifecycle status */
      status: components['schemas']['TemplateStatus'];
      /**
       * Format: date-time
       * @description When this template was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When this template was last updated
       */
      updatedAt: string;
    };
    /** @description A complete scene document with hierarchical node structure */
    Scene: {
      /**
       * @description Schema identifier for validation
       * @default bannou://schemas/scene/v1
       */
      schema: string;
      /**
       * Format: uuid
       * @description Unique scene identifier
       */
      sceneId: string;
      /**
       * @description Game service identifier for partitioning. Treated as opaque string.
       *     Default is the nil UUID for unpartitioned scenes.
       * @default 00000000-0000-0000-0000-000000000000
       */
      gameId: string;
      /** @description Scene classification for querying and validation */
      sceneType: components['schemas']['SceneType'];
      /** @description Human-readable scene name */
      name: string;
      /** @description Optional scene description */
      description?: string | null;
      /** @description Semantic version (MAJOR.MINOR.PATCH) */
      version: string;
      /** @description Root node of the scene hierarchy */
      root: components['schemas']['SceneNode'];
      /** @description Searchable tags for filtering scenes */
      tags?: string[];
      /** @description Client-only scene metadata (author, thumbnail, editor preferences). No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When the scene was first created
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description When the scene was last modified
       */
      updatedAt?: string;
    };
    /**
     * @description A node in the scene hierarchy. Nodes can contain children to form
     *     a tree structure. Each node has a local transform relative to its parent.
     */
    SceneNode: {
      /**
       * Format: uuid
       * @description Globally unique node identifier
       */
      nodeId: string;
      /**
       * @description Scene-local reference identifier. Must be unique within the scene.
       *     Used for scripting and cross-referencing. Examples: main_door, npc_spawn_1
       */
      refId: string;
      /**
       * Format: uuid
       * @description Parent node ID. Null for the root node only.
       */
      parentNodeId?: string | null;
      /** @description Human-readable display name for the node */
      name: string;
      /** @description The structural type of this node */
      nodeType: components['schemas']['NodeType'];
      /** @description Transform relative to parent node */
      localTransform: components['schemas']['Transform'];
      /** @description Optional asset binding (mesh, sound, particle effect) */
      asset?: components['schemas']['AssetReference'];
      /** @description Child nodes in the hierarchy */
      children?: components['schemas']['SceneNode'][];
      /**
       * @description Whether this node is active in the scene definition
       * @default true
       */
      enabled: boolean;
      /**
       * @description Ordering among siblings for deterministic iteration
       * @default 0
       */
      sortOrder: number;
      /** @description Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive) */
      tags?: string[];
      /** @description Client-only node annotations for game engines and editors. No Bannou plugin reads specific keys from this field by convention. */
      annotations?: {
        [key: string]: unknown;
      } | null;
      /**
       * @description Predefined locations for attaching child objects.
       *     Used by Scene Composer for furniture decoration, wall accessories, etc.
       */
      attachmentPoints?: components['schemas']['AttachmentPoint'][];
      /**
       * @description Interaction capabilities of this node.
       *     Used by AI navigation and character controllers.
       */
      affordances?: components['schemas']['Affordance'][];
      /**
       * @description Procedural asset swapping configuration.
       *     Defines which assets can substitute for this node's asset.
       */
      assetSlot?: components['schemas']['AssetSlot'];
      /**
       * @description Type of marker for marker nodes.
       *     Only relevant when nodeType is 'marker'.
       */
      markerType?: components['schemas']['MarkerType'];
      /**
       * @description Shape of volume for volume nodes.
       *     Only relevant when nodeType is 'volume'.
       */
      volumeShape?: components['schemas']['VolumeShape'];
      /**
       * @description Size/extents of the volume (interpretation depends on volumeShape).
       *     For box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.
       */
      volumeSize?: components['schemas']['Vector3'];
      /**
       * Format: uuid
       * @description Scene ID to embed for reference nodes.
       *     Only relevant when nodeType is 'reference'.
       */
      referenceSceneId?: string | null;
    };
    /** @description Standard response containing a scene */
    SceneResponse: {
      /** @description The scene document */
      scene: components['schemas']['Scene'];
    };
    /** @description Summary of a scene for list results (excludes full node tree) */
    SceneSummary: {
      /**
       * Format: uuid
       * @description Unique scene identifier
       */
      sceneId: string;
      /** @description Game service identifier */
      gameId: string;
      /** @description Scene classification */
      sceneType: components['schemas']['SceneType'];
      /** @description Scene name */
      name: string;
      /** @description Scene description */
      description?: string | null;
      /** @description Current version */
      version: string;
      /** @description Scene tags */
      tags?: string[];
      /** @description Total number of nodes in scene */
      nodeCount?: number;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description Last update timestamp
       */
      updatedAt?: string;
      /** @description Whether scene is currently checked out */
      isCheckedOut?: boolean;
    };
    /**
     * @description Scene classification for querying and validation rule lookup.
     *     Different types may have different validation requirements per game.
     * @enum {string}
     */
    SceneType:
      | 'unknown'
      | 'region'
      | 'city'
      | 'district'
      | 'lot'
      | 'building'
      | 'room'
      | 'dungeon'
      | 'arena'
      | 'vehicle'
      | 'prefab'
      | 'cutscene'
      | 'other';
    /** @description Registered schema definition with version lineage information */
    SchemaResponse: {
      /** @description Schema namespace */
      namespace: string;
      /** @description Schema version */
      schemaVersion: string;
      /** @description JSON Schema definition */
      schema?: Record<string, never>;
      /** @description Previous version */
      previousVersion?: string | null;
      /** @description Whether migration script is registered */
      hasMigration?: boolean;
      /**
       * Format: date-time
       * @description Registration timestamp
       */
      createdAt: string;
    };
    /** @description Request to search documentation using keyword matching */
    SearchDocumentationRequest: {
      /** @description Documentation namespace to search within */
      namespace: string;
      /** @description Keyword or phrase to search for */
      searchTerm: string;
      /**
       * Format: uuid
       * @description Optional session ID for tracking searches (null if not tracking)
       */
      sessionId?: string | null;
      /** @description Filter results to a specific category (null for all categories) */
      category?: components['schemas']['DocumentCategory'];
      /**
       * @description Maximum number of results to return
       * @default 10
       */
      maxResults: number;
      /** @description Fields to search within (null for default fields) */
      searchIn?: components['schemas']['SearchField'][] | null;
      /**
       * @description How to sort the search results
       * @default relevance
       * @enum {string}
       */
      sortBy: 'relevance' | 'recency' | 'alphabetical';
      /**
       * @description Whether to include full document content in results
       * @default false
       */
      includeContent: boolean;
    };
    /** @description Response containing keyword search results */
    SearchDocumentationResponse: {
      /** @description The namespace that was searched */
      namespace: string;
      /** @description List of matching documents */
      results: components['schemas']['DocumentResult'][];
      /** @description Total number of matching documents */
      totalResults?: number;
      /** @description The original search term */
      searchTerm?: string;
    };
    /**
     * @description Fields that can be searched within documents
     * @enum {string}
     */
    SearchField: 'title' | 'content' | 'tags' | 'summary';
    /**
     * @description Where the search match was found
     * @enum {string}
     */
    SearchMatchType: 'name' | 'description' | 'tag' | 'node_name';
    /** @description Request to full-text search messages in a persistent room */
    SearchMessagesRequest: {
      /**
       * Format: uuid
       * @description Room ID to search in (must be a persistent room)
       */
      roomId: string;
      /** @description Full-text search query string */
      query: string;
      /**
       * @description Maximum number of results to return
       * @default 20
       */
      limit: number;
    };
    /** @description Full-text search results with total match count */
    SearchMessagesResponse: {
      /** @description Messages matching the search query */
      messages: components['schemas']['ChatMessageResponse'][];
      /** @description Total number of matching messages */
      totalMatches: number;
    };
    /** @description A single search result */
    SearchResult: {
      /** @description Matching scene summary */
      scene: components['schemas']['SceneSummary'];
      /** @description Where the match was found */
      matchType: components['schemas']['SearchMatchType'];
      /** @description Context around the match */
      matchContext?: string | null;
    };
    /** @description Request for full-text search */
    SearchScenesRequest: {
      /** @description Search query text */
      query: string;
      /** @description Filter by game ID */
      gameId?: string | null;
      /** @description Filter by scene types */
      sceneTypes?: components['schemas']['SceneType'][] | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results
       * @default 50
       */
      limit: number;
    };
    /** @description Search results */
    SearchScenesResponse: {
      /** @description Matching scenes */
      results: components['schemas']['SearchResult'][];
      /** @description Total matches */
      total: number;
    };
    /** @description A season within a calendar template year */
    SeasonDefinition: {
      /** @description Season identifier code (e.g., "winter", "spring", "summer", "autumn") */
      code: string;
      /** @description Display name for the season */
      name: string;
      /** @description Position in annual cycle (0-based) */
      ordinal: number;
    };
    /** @description Season information */
    SeasonResponse: {
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /** @description Season number */
      seasonNumber: number;
      /** @description Name of the season */
      seasonName?: string | null;
      /**
       * Format: date-time
       * @description When this season started
       */
      startedAt: string;
      /**
       * Format: date-time
       * @description When this season ended (null if active)
       */
      endedAt?: string | null;
      /** @description Whether this is the current season */
      isActive: boolean;
      /**
       * Format: int64
       * @description Number of entries in this season
       */
      entryCount?: number;
    };
    /** @description Request to bulk seed a board template with license definitions */
    SeedBoardTemplateRequest: {
      /**
       * Format: uuid
       * @description Board template to seed with definitions
       */
      boardTemplateId: string;
      /** @description License definitions to add (boardTemplateId in each is ignored, uses top-level) */
      definitions: components['schemas']['AddLicenseDefinitionRequest'][];
    };
    /** @description Result of bulk seeding a board template */
    SeedBoardTemplateResponse: {
      /**
       * Format: uuid
       * @description Board template that was seeded
       */
      boardTemplateId: string;
      /** @description Number of definitions created */
      definitionsCreated: number;
      /** @description All created license definitions */
      definitions: components['schemas']['LicenseDefinitionResponse'][];
    };
    /** @description Request to create a calendar template for a game service */
    SeedCalendarRequest: {
      /** @description Unique identifier for this calendar template within the game service */
      templateCode: string;
      /**
       * Format: uuid
       * @description Game service this calendar belongs to
       */
      gameServiceId: string;
      /** @description Number of game hours in a day (day periods must cover [0, gameHoursPerDay) without gaps or overlaps) */
      gameHoursPerDay: number;
      /** @description Named time-of-day periods (must cover [0, gameHoursPerDay) without gaps or overlaps) */
      dayPeriods: components['schemas']['DayPeriodDefinition'][];
      /** @description Ordered list of months in a year (each month's seasonCode must reference a defined season) */
      months: components['schemas']['MonthDefinition'][];
      /** @description Ordered list of seasons in a year */
      seasons: components['schemas']['SeasonDefinition'][];
      /** @description Named time spans for display purposes (optional) */
      eraLabels?: components['schemas']['EraLabel'][] | null;
    };
    /** @description A single seed-derived passive effect entry */
    SeedEffectEntry: {
      /** @description Capability code from the seed's capability manifest */
      capabilityCode: string;
      /** @description Seed domain this capability belongs to */
      domain: string;
      /**
       * Format: float
       * @description Capability fidelity value (0.0 to 1.0)
       */
      fidelity: number;
      /**
       * Format: uuid
       * @description Seed providing this capability
       */
      seedId: string;
      /** @description Type code of the seed providing this capability */
      seedTypeCode: string;
    };
    /** @description Seed-derived passive effects for an entity */
    SeedEffectsResponse: {
      /**
       * Format: uuid
       * @description Entity these effects belong to
       */
      entityId: string;
      /** @description Entity type discriminator */
      entityType: components['schemas']['EntityType'];
      /** @description Seed-derived passive effects */
      effects: components['schemas']['SeedEffectEntry'][];
    };
    /** @description Request to bulk seed entry templates */
    SeedEntryTemplatesRequest: {
      /** @description Entry templates to create (duplicates are skipped) */
      templates: components['schemas']['CreateEntryTemplateRequest'][];
    };
    /** @description Result of bulk seed operation */
    SeedEntryTemplatesResponse: {
      /** @description Number of entry templates successfully created */
      created: number;
      /** @description Number of templates skipped (duplicates) */
      skipped: number;
    };
    /** @description Full seed entity response. */
    SeedResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for this seed.
       */
      seedId: string;
      /**
       * Format: uuid
       * @description The entity that owns this seed.
       */
      ownerId: string;
      /** @description Owner entity type discriminator. */
      ownerType: components['schemas']['EntityType'];
      /** @description Registered seed type code. */
      seedTypeCode: string;
      /**
       * Format: uuid
       * @description Game service this seed is scoped to. Null for cross-game seed types.
       */
      gameServiceId?: string | null;
      /**
       * Format: date-time
       * @description When the seed was created.
       */
      createdAt: string;
      /** @description Current computed growth phase code. */
      growthPhase: string;
      /**
       * Format: float
       * @description Aggregate growth across all domains.
       */
      totalGrowth: number;
      /**
       * Format: uuid
       * @description Bond ID if this seed is bonded, null otherwise.
       */
      bondId?: string | null;
      /** @description Human-readable name. */
      displayName: string;
      /** @description Current lifecycle status. */
      status: components['schemas']['SeedStatus'];
    };
    /** @description A source of seed data (archive or snapshot) */
    SeedSource: {
      /**
       * Format: uuid
       * @description ID of a compressed archive (dead entity)
       */
      archiveId?: string | null;
      /**
       * Format: uuid
       * @description ID of a live snapshot (living entity)
       */
      snapshotId?: string | null;
      /**
       * @description Optional actant role hint (e.g., "protagonist", "antagonist", "helper").
       *     Used for Greimas actant assignment if provided.
       */
      role?: string | null;
    };
    /**
     * @description Lifecycle status of a seed.
     * @enum {string}
     */
    SeedStatus: 'Active' | 'Dormant' | 'Archived';
    /** @description Request to bulk seed status templates for a game service */
    SeedStatusTemplatesRequest: {
      /**
       * Format: uuid
       * @description Game service to seed templates for (all templates must belong to this game service)
       */
      gameServiceId: string;
      /** @description Status templates to create (duplicates are skipped) */
      templates: components['schemas']['CreateStatusTemplateRequest'][];
    };
    /** @description Result of bulk seed operation */
    SeedStatusTemplatesResponse: {
      /** @description Number of status templates successfully created */
      created: number;
      /** @description Number of templates skipped (duplicates) */
      skipped: number;
    };
    /** @description Full seed type definition response. */
    SeedTypeResponse: {
      /** @description Unique type code. */
      seedTypeCode: string;
      /**
       * Format: uuid
       * @description Game service scope. Null for cross-game seed types.
       */
      gameServiceId?: string | null;
      /** @description Human-readable name. */
      displayName: string;
      /** @description Type description. */
      description: string;
      /** @description Maximum seeds of this type per owner. */
      maxPerOwner: number;
      /** @description Allowed owner entity types. */
      allowedOwnerTypes: components['schemas']['EntityType'][];
      /** @description Phase definitions with thresholds. */
      growthPhases: components['schemas']['GrowthPhaseDefinition'][];
      /** @description Bond participant limit. */
      bondCardinality: number;
      /** @description Whether bonds of this type are permanent. */
      bondPermanent: boolean;
      /** @description Capability computation rules. */
      capabilityRules?: components['schemas']['CapabilityRule'][] | null;
      /** @description Whether unused growth domains decay over time for this seed type. Null means using global config. */
      growthDecayEnabled?: boolean | null;
      /**
       * Format: float
       * @description Daily decay rate for unused domains of this seed type. Null means using global config.
       */
      growthDecayRatePerDay?: number | null;
      /**
       * Format: float
       * @description Fraction of growth applied to other seeds of the same type owned by the same entity.
       */
      sameOwnerGrowthMultiplier?: number;
      /** @description Collection-to-growth-domain mappings for this seed type. Null if this type does not respond to collection unlocks. */
      collectionGrowthMappings?: components['schemas']['CollectionGrowthMapping'][] | null;
      /** @description Whether this seed type is deprecated and cannot be used for new seeds. */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this seed type was deprecated.
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation. */
      deprecationReason?: string | null;
    };
    /** @description Request to select content for an area based on unlocked collection */
    SelectContentForAreaRequest: {
      /**
       * Format: uuid
       * @description Entity whose collection to search
       */
      ownerId: string;
      /** @description Entity type discriminator */
      ownerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Game service scope
       */
      gameServiceId: string;
      /** @description Type of collection to select content from */
      collectionType: components['schemas']['CollectionType'];
      /** @description Area code to select content for */
      areaCode: string;
    };
    /** @description Request to send multiple messages to a room atomically */
    SendMessageBatchRequest: {
      /**
       * Format: uuid
       * @description Room ID to send messages to
       */
      roomId: string;
      /** @description Messages to send atomically */
      messages: components['schemas']['BatchMessageEntry'][];
    };
    /** @description Result of a batch message send operation with per-message failure tracking */
    SendMessageBatchResponse: {
      /** @description Number of messages successfully sent */
      messageCount: number;
      /** @description Details of messages that failed to send (empty array when all succeeded) */
      failed: components['schemas']['BatchMessageFailure'][];
    };
    /** @description Message content discriminated by the room message format. Exactly one content field group must be set, matching the room type format. */
    SendMessageContent: {
      /** @description Text content (for Text format rooms) */
      text?: string | null;
      /** @description Sentiment category (for Sentiment format rooms) */
      sentimentCategory?: components['schemas']['SentimentCategory'] | null;
      /**
       * Format: float
       * @description Sentiment intensity 0.0-1.0 (for Sentiment format rooms)
       */
      sentimentIntensity?: number | null;
      /** @description Emoji code (Unicode or custom) for Emoji format rooms */
      emojiCode?: string | null;
      /**
       * Format: uuid
       * @description Custom emoji set reference (null for Unicode)
       */
      emojiSetId?: string | null;
      /** @description JSON string validated against room type validator config (for Custom format rooms) */
      customPayload?: string | null;
    };
    /** @description Request to send a message to a chat room */
    SendMessageRequest: {
      /**
       * Format: uuid
       * @description Room ID to send the message to
       */
      roomId: string;
      /** @description Message content matching the room format */
      content: components['schemas']['SendMessageContent'];
      /** @description Opaque sender type for this message */
      senderType?: string | null;
      /**
       * Format: uuid
       * @description Sender entity ID
       */
      senderId?: string | null;
      /** @description Sender display name for this message */
      displayName?: string | null;
    };
    /**
     * @description Standardized sentiment categories for anonymous audience and reaction data. Used by lib-chat for sentiment room messages and lib-stream for platform audience processing. Designed for privacy-safe communication where text content is inappropriate or unnecessary.
     * @enum {string}
     */
    SentimentCategory:
      | 'Excited'
      | 'Supportive'
      | 'Critical'
      | 'Curious'
      | 'Surprised'
      | 'Amused'
      | 'Bored'
      | 'Hostile';
    /** @description Response containing aggregate sentiment */
    SentimentResponse: {
      /**
       * Format: uuid
       * @description Character whose sentiment was queried
       */
      characterId: string;
      /**
       * Format: uuid
       * @description Target of the sentiment
       */
      targetCharacterId: string;
      /**
       * Format: float
       * @description Aggregate sentiment (-1.0 = hostile, +1.0 = friendly)
       */
      sentiment: number;
      /** @description Number of encounters factored in */
      encounterCount: number;
      /** @description Most common emotional impact across encounters */
      dominantEmotion?: components['schemas']['EmotionalImpact'];
    };
    /** @description Information about a game service */
    ServiceInfo: {
      /**
       * Format: uuid
       * @description Unique identifier for the service
       */
      serviceId: string;
      /** @description URL-safe identifier (e.g., "my-game") */
      stubName: string;
      /** @description Human-readable name (e.g., "My Game Online") */
      displayName: string;
      /** @description Optional description */
      description?: string | null;
      /** @description Whether the service is currently active */
      isActive: boolean;
      /** @description Whether GameSession auto-creates lobby sessions and publishes join shortcuts for this game service on player connect */
      autoLobbyEnabled: boolean;
      /**
       * Format: date-time
       * @description When the service was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the service was last updated
       */
      updatedAt?: string | null;
    };
    /**
     * @description Game service stub name for created sessions. Use the game service's stubName property (e.g., "my-game"). Use "generic" for non-game-specific sessions.
     * @default generic
     */
    SessionGameType: string;
    /** @description Information about an active user session including device and activity details */
    SessionInfo: {
      /**
       * Format: uuid
       * @description Unique identifier for the session
       */
      sessionId: string;
      /** @description Information about the device used for this session */
      deviceInfo?: components['schemas']['DeviceInfo'];
      /**
       * Format: date-time
       * @description Timestamp when the session was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp of the last activity in this session
       */
      lastActive: string;
      /** @description IP address from which the session was initiated */
      ipAddress?: string | null;
      /** @description Geographic location derived from the IP address */
      location?: string | null;
    };
    /**
     * @description Current status of the game session
     * @enum {string}
     */
    SessionStatus: 'waiting' | 'active' | 'full' | 'finished';
    /**
     * @description Type of game session - determines join behavior
     * @enum {string}
     */
    SessionType: 'lobby' | 'matchmade';
    /** @description Response containing a list of all active sessions for an account */
    SessionsResponse: {
      /** @description List of active sessions for the account */
      sessions: components['schemas']['SessionInfo'][];
    };
    /** @description Request to create or update an action tag mapping */
    SetActionMappingRequest: {
      /** @description The GOAP action tag to map (e.g., "steal_food") */
      tag: string;
      /** @description Violation type codes this tag should map to */
      violationTypes: string[];
      /** @description Human-readable description of this mapping */
      description?: string | null;
    };
    /** @description Request to create or update an area content configuration */
    SetAreaContentConfigRequest: {
      /** @description Area code to configure (unique per game service and collection type) */
      areaCode: string;
      /**
       * Format: uuid
       * @description Game service this area config belongs to
       */
      gameServiceId: string;
      /** @description Type of collection this area config applies to */
      collectionType: components['schemas']['CollectionType'];
      /** @description Theme tags for this area (matched against collection entry themes) */
      themes: string[];
      /** @description Default entry code to use when no matches are found */
      defaultEntryCode: string;
    };
    /** @description Request to set template values on a contract */
    SetTemplateValuesRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractInstanceId: string;
      /** @description Key-value pairs for template substitution (keys follow pattern EscrowId, PartyA_EscrowWalletId, etc.) */
      templateValues: {
        [key: string]: string;
      };
    };
    /** @description Response from setting template values. HTTP 200 confirms values were set. */
    SetTemplateValuesResponse: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Number of template values set */
      valueCount: number;
    };
    /** @description Request to change the time ratio for a realm */
    SetTimeRatioRequest: {
      /**
       * Format: uuid
       * @description Realm to change the time ratio for
       */
      realmId: string;
      /**
       * Format: float
       * @description New game-seconds per real-second (0.0 pauses the clock)
       */
      newRatio: number;
      /** @description Reason for the ratio change */
      reason: components['schemas']['TimeRatioChangeReason'];
    };
    /** @description Confirmation of time ratio change */
    SetTimeRatioResponse: {
      /**
       * Format: uuid
       * @description Realm the ratio was changed for
       */
      realmId: string;
      /**
       * Format: float
       * @description Previous game-seconds per real-second
       */
      previousRatio: number;
      /**
       * Format: float
       * @description New game-seconds per real-second
       */
      newRatio: number;
      /** @description Reason for the ratio change */
      reason: components['schemas']['TimeRatioChangeReason'];
    };
    /** @description Shared garden state for bonded players */
    SharedGardenStateResponse: {
      /**
       * Format: uuid
       * @description Bond linking the participants
       */
      bondId: string;
      /** @description Per-player garden state */
      participants: components['schemas']['BondedPlayerGardenState'][];
      /** @description POIs visible to all bond participants */
      sharedPois: components['schemas']['PoiSummary'][];
    };
    /** @description Global website configuration including branding, languages, and integrations */
    SiteSettings: {
      /** @description Display name of the website */
      siteName: string;
      /**
       * Format: uri
       * @description Base URL of the website
       */
      siteUrl: string;
      /** @description Short slogan or description of the site */
      tagline?: string | null;
      /**
       * @description Default language code for the website
       * @default en
       */
      defaultLanguage: string;
      /** @description List of supported language codes */
      supportedLanguages?: string[];
      /**
       * @description Whether the site is in maintenance mode
       * @default false
       */
      maintenanceMode: boolean;
      /** @description Message displayed during maintenance mode */
      maintenanceMessage?: string | null;
      /**
       * Format: email
       * @description Primary contact email address for the site
       */
      contactEmail?: string;
      /** @description Map of social media platform names to profile URLs */
      socialLinks?: {
        [key: string]: string;
      };
      /** @description Analytics and tracking service configuration */
      analytics?: components['schemas']['Analytics'];
      /** @description Custom JavaScript scripts to inject into pages */
      customScripts?: components['schemas']['CustomScripts'];
    };
    /** @description A step in the skill window expansion curve */
    SkillExpansionStep: {
      /** @description Number of intervals after which this step applies */
      intervals: number;
      /** @description Skill range (null means any skill level) */
      range?: number | null;
    };
    /** @description Complete metadata for a save slot including version statistics */
    SlotResponse: {
      /**
       * Format: uuid
       * @description Unique slot identifier
       */
      slotId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Slot name */
      slotName: string;
      /** @description Save category determining retention and cleanup behavior */
      category: components['schemas']['SaveCategory'];
      /** @description Maximum versions to retain */
      maxVersions?: number;
      /** @description Days to retain versions (null = indefinite) */
      retentionDays?: number | null;
      /** @description Compression algorithm used for save data */
      compressionType?: components['schemas']['CompressionType'];
      /** @description Current number of versions in slot */
      versionCount?: number;
      /** @description Latest version number (null if empty) */
      latestVersion?: number | null;
      /**
       * Format: int64
       * @description Total storage used by all versions
       */
      totalSizeBytes?: number;
      /**
       * Format: date-time
       * @description Slot creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last modification timestamp
       */
      updatedAt?: string;
      /** @description Custom key-value metadata */
      metadata?: {
        [key: string]: string;
      };
    };
    /**
     * @description How scores are sorted
     * @enum {string}
     */
    SortOrder: 'descending' | 'ascending';
    /**
     * @description When item becomes bound to a character
     * @enum {string}
     */
    SoulboundType: 'none' | 'on_pickup' | 'on_equip' | 'on_use';
    /** @description Provenance reference to a source bundle used in metabundle creation */
    SourceBundleReference: {
      /** @description Source bundle identifier */
      bundleId: string;
      /** @description Version of source bundle at composition time */
      version: string;
      /** @description Asset IDs contributed from this source bundle */
      assetIds: string[];
      /** @description Hash of source bundle at composition time (for integrity verification) */
      contentHash: string;
    };
    /** @description Potential placement location */
    SpaceCandidate: {
      /**
       * Format: uuid
       * @description Container ID
       */
      containerId: string;
      /** @description Container type */
      containerType: string;
      /**
       * Format: double
       * @description How much can fit
       */
      canFitQuantity: number;
      /** @description Available slot */
      slotIndex?: number | null;
      /** @description Available grid X */
      slotX?: number | null;
      /** @description Available grid Y */
      slotY?: number | null;
      /**
       * Format: uuid
       * @description Stack to merge with
       */
      existingStackInstanceId?: string | null;
    };
    /** @description Spatial context derived from game server's authoritative spatial state. Included in perception events to give NPC actors awareness of their environment. Core properties are schema-defined; additionalProperties allows game-specific spatial extensions. No Bannou plugin reads specific extension keys by convention. */
    SpatialContext: {
      /** @description Terrain type at character position (grass, stone, water, etc.) */
      terrainType?: string | null;
      /**
       * Format: float
       * @description Elevation at character position
       */
      elevation?: number | null;
      /** @description Objects within perception radius */
      nearbyObjects?: components['schemas']['NearbyObject'][] | null;
      /** @description Active hazards within detection range */
      hazardsInRange?: components['schemas']['HazardInfo'][] | null;
      /** @description Directions the character can move (for navigation awareness) */
      pathableDirections?: string[] | null;
      /** @description Whether cover is available within close range */
      coverNearby?: boolean | null;
      /** @description Whether character is currently indoors/under roof */
      indoors?: boolean | null;
    } & {
      [key: string]: unknown;
    };
    /** @description Request to spawn a new actor from a template */
    SpawnActorRequest: {
      /**
       * Format: uuid
       * @description Template to instantiate from
       */
      templateId: string;
      /** @description Optional custom actor ID (auto-generated if not provided) */
      actorId?: string | null;
      /** @description Game-specific configuration overrides merged with template defaults. No Bannou plugin reads specific keys from this field by convention. */
      configurationOverrides?: {
        [key: string]: unknown;
      } | null;
      /** @description Initial actor state snapshot. Deserialized internally to ActorStateSnapshot. No Bannou plugin reads specific keys from this field by convention. */
      initialState?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: uuid
       * @description Optional character ID for NPC brain actors
       */
      characterId?: string | null;
      /**
       * Format: uuid
       * @description Realm the actor operates in. Optional on request -- when not provided and characterId is set, the service looks up the character's realm automatically. Required for non-character actors that operate in a specific realm.
       */
      realmId?: string | null;
    };
    /** @description Paginated list of species with total count for pagination */
    SpeciesListResponse: {
      /** @description List of species matching the query */
      species: components['schemas']['SpeciesResponse'][];
      /** @description Total number of species matching the query (for pagination) */
      totalCount: number;
      /** @description Current page number */
      page?: number;
      /** @description Number of items per page */
      pageSize?: number;
    };
    /** @description Complete species data including all attributes and realm associations */
    SpeciesResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the species
       */
      speciesId: string;
      /** @description Unique code for the species (e.g., "HUMAN", "ELF") */
      code: string;
      /** @description Display name for the species */
      name: string;
      /** @description Description of the species */
      description?: string | null;
      /** @description Category for grouping (e.g., "HUMANOID", "BEAST", "MAGICAL") */
      category?: string | null;
      /** @description Whether players can create characters of this species */
      isPlayable: boolean;
      /** @description Whether this species is deprecated and cannot be used for new characters */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this species was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation */
      deprecationReason?: string | null;
      /** @description Base lifespan in game years */
      baseLifespan?: number | null;
      /** @description Age at which the species reaches maturity */
      maturityAge?: number | null;
      /** @description Client-only trait modifiers. No Bannou plugin reads specific keys from this field by convention. */
      traitModifiers?: {
        [key: string]: unknown;
      } | null;
      /** @description Realms where this species is available */
      realmIds?: string[];
      /** @description Client-only metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Timestamp when the species was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the species was last updated
       */
      updatedAt: string;
    };
    /**
     * @description The 10 Story Grid Life Value spectrums.
     *     These are bipolar axes for emotional progression.
     * @enum {string}
     */
    SpectrumType:
      | 'LifeDeath'
      | 'HonorDishonor'
      | 'JusticeInjustice'
      | 'FreedomSubjugation'
      | 'LoveHate'
      | 'RespectShame'
      | 'PowerImpotence'
      | 'SuccessFailure'
      | 'AltruismSelfishness'
      | 'WisdomIgnorance';
    /** @description Allocation of assets to a party in a split resolution */
    SplitAllocation: {
      /**
       * Format: uuid
       * @description Party ID
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Assets allocated to this party */
      assets: components['schemas']['EscrowAssetInput'][];
    };
    /** @description Request to split a stack */
    SplitStackRequest: {
      /**
       * Format: uuid
       * @description Stack to split
       */
      instanceId: string;
      /**
       * Format: double
       * @description Quantity to split off
       */
      quantity: number;
      /** @description Slot for new stack */
      targetSlotIndex?: number | null;
      /** @description Grid X for new stack */
      targetSlotX?: number | null;
      /** @description Grid Y for new stack */
      targetSlotY?: number | null;
    };
    /** @description Response after splitting. HTTP 200 confirms split. */
    SplitStackResponse: {
      /**
       * Format: uuid
       * @description New stack ID
       */
      newInstanceId: string;
      /**
       * Format: double
       * @description Remaining quantity
       */
      originalQuantity: number;
      /**
       * Format: double
       * @description Split quantity
       */
      newQuantity: number;
    };
    /**
     * @description How multiple applications of the same status template interact.
     *     - refresh_duration: resets timer, preserves or increments stack count
     *     - independent: each application is a separate item with own timer
     *     - increase_intensity: stacks increase effect magnitude, shared timer reset
     *     - replace: new application replaces existing entirely
     *     - ignore: cannot apply if already present
     * @enum {string}
     */
    StackBehavior: 'refresh_duration' | 'independent' | 'increase_intensity' | 'replace' | 'ignore';
    /** @description Request to start an encounter managed by an Event Brain actor */
    StartEncounterRequest: {
      /** @description ID of the Event Brain actor that will manage this encounter */
      actorId: string;
      /**
       * Format: uuid
       * @description Unique identifier for this encounter
       */
      encounterId: string;
      /** @description Type of encounter (e.g., "combat", "conversation", "choreography") */
      encounterType: string;
      /** @description Character IDs of participants in the encounter */
      participants: string[];
      /** @description Game-specific encounter initialization data passed to ABML behavior scope. No Bannou plugin reads specific keys from this field by convention. */
      initialData?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Empty response. HTTP 200 confirms the encounter was started. */
    StartEncounterResponse: Record<string, never>;
    /** @description Request to start a regional watcher */
    StartWatcherRequest: {
      /**
       * Format: uuid
       * @description Realm the watcher should monitor
       */
      realmId: string;
      /** @description Type of watcher to start (e.g., "regional", "dungeon", "event") */
      watcherType: string;
      /** @description Optional specific behavior document reference. If not provided, uses default for watcher type. */
      behaviorRef?: string | null;
    };
    /** @description Response after starting a watcher */
    StartWatcherResponse: {
      /** @description The watcher that was started or already existed */
      watcher: components['schemas']['WatcherInfo'];
      /** @description True if a matching watcher was already running */
      alreadyExisted: boolean;
    };
    /** @description Request to start all relevant watchers for a realm */
    StartWatchersForRealmRequest: {
      /**
       * Format: uuid
       * @description Realm to start watchers for
       */
      realmId: string;
    };
    /** @description Response after starting watchers for a realm */
    StartWatchersForRealmResponse: {
      /** @description Number of new watchers started */
      watchersStarted: number;
      /** @description Number of watchers that already existed */
      watchersExisted?: number;
      /** @description All watchers now active for this realm */
      watchers: components['schemas']['WatcherInfo'][];
    };
    /**
     * @description Classification of status effects for filtering and cleanse targeting.
     *     - buff: positive temporary effect (strength boost, speed increase)
     *     - debuff: negative temporary effect (poison, slow, weakness)
     *     - death: death penalty or incapacitation state
     *     - subscription: account-level subscription benefit
     *     - event: time-limited event effect (festival bonus, seasonal)
     *     - passive: seed-derived passive capability (used in unified queries)
     * @enum {string}
     */
    StatusCategory: 'buff' | 'debuff' | 'death' | 'subscription' | 'event' | 'passive';
    /** @description Unified summary of an active effect from any source (item-based or seed-derived) */
    StatusEffectSummary: {
      /** @description Status template code (item-based) or capability code (seed-derived) */
      statusCode: string;
      /** @description Status category for filtering */
      category: components['schemas']['StatusCategory'];
      /** @description Whether this effect is item-based or seed-derived */
      effectSource: components['schemas']['EffectSource'];
      /** @description Current stack count (null for seed-derived effects) */
      stackCount?: number | null;
      /**
       * Format: date-time
       * @description When this effect expires (null for permanent or seed-derived)
       */
      expiresAt?: string | null;
      /**
       * Format: float
       * @description Seed capability fidelity value (null for item-based effects)
       */
      fidelity?: number | null;
      /**
       * Format: uuid
       * @description Seed providing this effect (null for item-based effects)
       */
      seedId?: string | null;
      /**
       * Format: uuid
       * @description What granted this status (null for seed-derived effects)
       */
      sourceId?: string | null;
    };
    /** @description Full details of a status instance */
    StatusInstanceResponse: {
      /**
       * Format: uuid
       * @description Unique status instance identifier
       */
      statusInstanceId: string;
      /**
       * Format: uuid
       * @description Entity this status is applied to
       */
      entityId: string;
      /** @description Entity type discriminator */
      entityType: components['schemas']['EntityType'];
      /** @description Status template code */
      statusTemplateCode: string;
      /** @description Status category */
      category: components['schemas']['StatusCategory'];
      /** @description Current stack count */
      stackCount: number;
      /**
       * Format: uuid
       * @description What granted this status (null if no source tracking)
       */
      sourceId?: string | null;
      /**
       * Format: uuid
       * @description Contract instance managing lifecycle (null if not contract-managed)
       */
      contractInstanceId?: string | null;
      /**
       * Format: uuid
       * @description Item instance in the status container
       */
      itemInstanceId: string;
      /**
       * Format: date-time
       * @description When this status was granted
       */
      grantedAt: string;
      /**
       * Format: date-time
       * @description When this status expires (null for permanent)
       */
      expiresAt?: string | null;
      /** @description Arbitrary metadata associated with this status instance */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Why a status was removed from an entity.
     *     - expired: TTL or contract duration elapsed
     *     - cleansed: removed by category cleanse mechanic
     *     - cancelled: explicitly cancelled by service or admin
     *     - source_removed: source entity was deleted (cascading removal)
     *     - admin: removed by administrative action
     * @enum {string}
     */
    StatusRemoveReason: 'expired' | 'cleansed' | 'cancelled' | 'source_removed' | 'admin';
    /** @description Health and version status information for the website service */
    StatusResponse: {
      /**
       * @description Current health status of the website service
       * @enum {string}
       */
      status: 'healthy' | 'degraded' | 'maintenance';
      /**
       * @description Current version of the website service
       * @example 1.0.0
       */
      version: string;
      /** @description Uptime in seconds */
      uptime: number;
      /** @description Message displayed during maintenance mode */
      maintenanceMessage?: string | null;
    };
    /** @description Status template with all fields */
    StatusTemplateResponse: {
      /**
       * Format: uuid
       * @description Unique status template identifier
       */
      statusTemplateId: string;
      /**
       * Format: uuid
       * @description Game service this template is scoped to
       */
      gameServiceId: string;
      /** @description Unique status code within this game service */
      code: string;
      /** @description Human-readable display name */
      displayName: string;
      /** @description Detailed description of this status effect */
      description: string;
      /** @description Classification of this status effect */
      category: components['schemas']['StatusCategory'];
      /** @description Whether this status can stack */
      stackable: boolean;
      /** @description Maximum number of stacks */
      maxStacks: number;
      /** @description How multiple applications interact */
      stackBehavior: components['schemas']['StackBehavior'];
      /**
       * Format: uuid
       * @description Contract template for lifecycle management (null if not contract-managed)
       */
      contractTemplateId?: string | null;
      /**
       * Format: uuid
       * @description Item template used when granting this status
       */
      itemTemplateId: string;
      /** @description Default duration in seconds (null for permanent statuses) */
      defaultDurationSeconds?: number | null;
      /**
       * Format: uuid
       * @description Asset identifier for this status effect's icon
       */
      iconAssetId?: string | null;
      /**
       * Format: date-time
       * @description When this template was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When this template was last updated
       */
      updatedAt?: string | null;
    };
    /**
     * @description Request to verify a Steam Session Ticket. The ticket is obtained client-side via
     *     ISteamUser::GetAuthTicketForWebApi("bannou"). SteamID is NOT included because
     *     it must be obtained from Steam's Web API response (never trust client-provided SteamID).
     */
    SteamVerifyRequest: {
      /**
       * @description Hex-encoded Steam Session Ticket from ISteamUser::GetAuthTicketForWebApi().
       *     Client converts ticket bytes to hex string: BitConverter.ToString(ticketData).Replace("-", "")
       * @example 140000006A7B3C8E...
       */
      ticket: string;
      /** @description Information about the client device (optional) */
      deviceInfo?: components['schemas']['DeviceInfo'];
    };
    /** @description Request to stop a running actor */
    StopActorRequest: {
      /** @description ID of the actor to stop */
      actorId: string;
      /**
       * @description If true, allows behavior to complete current iteration
       * @default true
       */
      graceful: boolean;
    };
    /** @description Response confirming actor stop operation */
    StopActorResponse: {
      /** @description Final status of the actor after stopping */
      finalStatus: components['schemas']['ActorStatus'];
    };
    /** @description Request to stop broadcasting from a voice room */
    StopBroadcastConsentRequest: {
      /**
       * Format: uuid
       * @description Voice room ID
       */
      roomId: string;
      /**
       * Format: uuid
       * @description Session ID of the participant stopping the broadcast
       */
      sessionId?: string | null;
    };
    /** @description Request to stop a regional watcher */
    StopWatcherRequest: {
      /**
       * Format: uuid
       * @description ID of the watcher to stop
       */
      watcherId: string;
    };
    /** @description Response after stopping a watcher */
    StopWatcherResponse: {
      /** @description True if the watcher was found and stopped */
      stopped: boolean;
    };
    /**
     * @description Complete storyline participation data for archive storage and SDK consumption.
     *     Inherits base archive properties from ResourceArchiveBase.
     *     The characterId field equals resourceId for convenience.
     */
    StorylineArchive: {
      /**
       * Format: uuid
       * @description Character this data belongs to (equals resourceId)
       */
      characterId: string;
      /** @description All scenario participations (completed and active) */
      participations: components['schemas']['StorylineParticipation'][];
      /** @description Story arcs the character is currently involved in */
      activeArcs: string[];
      /** @description Total count of completed scenarios */
      completedStorylines: number;
    } & components['schemas']['ResourceArchiveBase'];
    /**
     * @description High-level story goal that drives arc selection.
     *     revenge: Character seeks vengeance for past wrongs
     *     resurrection: Restoring something/someone lost
     *     legacy: Creating or continuing a lasting impact
     *     mystery: Uncovering hidden truths
     *     peace: Resolving conflicts and finding harmony
     * @enum {string}
     */
    StorylineGoal: 'revenge' | 'resurrection' | 'legacy' | 'mystery' | 'peace';
    /** @description A relationship link in the storyline */
    StorylineLink: {
      /** @description Source entity role */
      sourceRole: string;
      /** @description Target entity role */
      targetRole: string;
      /** @description Type of relationship (e.g., "opposes", "allies_with", "seeks") */
      linkType: string;
    };
    /** @description Summary of a scenario participation for archive purposes */
    StorylineParticipation: {
      /**
       * Format: uuid
       * @description Scenario execution ID
       */
      executionId: string;
      /**
       * Format: uuid
       * @description Scenario definition ID (if available)
       */
      scenarioId?: string | null;
      /** @description Scenario code for lookup */
      scenarioCode: string;
      /** @description Scenario display name */
      scenarioName?: string | null;
      /** @description Character's role in the scenario (primary, secondary, witness) */
      role: string;
      /** @description Current phase number (or final phase if completed) */
      phase: number;
      /** @description Total number of phases in the scenario */
      totalPhases: number;
      /** @description Current status of the scenario execution */
      status: components['schemas']['ScenarioStatus'];
      /**
       * Format: date-time
       * @description When the scenario was triggered
       */
      startedAt: string;
      /**
       * Format: date-time
       * @description When the scenario completed (null if still active)
       */
      completedAt?: string | null;
      /** @description Key choices made during the scenario (for narrative hooks) */
      choices?: string[] | null;
    };
    /** @description A planned action in the storyline */
    StorylinePlanAction: {
      /** @description Action identifier from action registry */
      actionId: string;
      /** @description Sequence index within the plan */
      sequenceIndex: number;
      /** @description World state effects of this action */
      effects: components['schemas']['ActionEffect'][];
      /** @description Narrative effect on the emotional arc */
      narrativeEffect: components['schemas']['NarrativeEffect'];
      /** @description Whether this is an obligatory scene */
      isCoreEvent: boolean;
      /** @description If chained, the ID of the action it was chained from */
      chainedFrom?: string | null;
    };
    /** @description A phase in the storyline plan */
    StorylinePlanPhase: {
      /** @description 1-based phase number */
      phaseNumber: number;
      /** @description Phase name */
      name: string;
      /** @description Actions in this phase */
      actions: components['schemas']['StorylinePlanAction'][];
      /** @description Target state for phase completion */
      targetState: components['schemas']['PhaseTargetState'];
      /** @description Position bounds for this phase */
      positionBounds: components['schemas']['PhasePosition'];
    };
    /** @description Identified risk in the plan */
    StorylineRisk: {
      /** @description Risk category (e.g., "missing_entity", "low_tension", "weak_climax") */
      riskType: string;
      /** @description Risk description */
      description: string;
      /**
       * @description Risk severity
       * @enum {string}
       */
      severity: 'low' | 'medium' | 'high';
      /** @description Suggested mitigation */
      mitigation?: string | null;
    };
    /** @description Response containing a style definition */
    StyleDefinitionResponse: {
      /** @description Unique style identifier */
      styleId: string;
      /** @description Style name */
      name: string;
      /** @description Style category */
      category: string;
      /** @description Human-readable description */
      description?: string | null;
      /** @description Mode probability distribution */
      modeDistribution?: components['schemas']['ModeDistribution'];
      /** @description Interval preferences */
      intervalPreferences?: components['schemas']['IntervalPreferences'];
      /** @description Available forms */
      formTemplates?: components['schemas']['FormTemplate'][] | null;
      /** @description Style-specific tune types */
      tuneTypes?: components['schemas']['TuneType'][] | null;
      /** @description Default tempo */
      defaultTempo?: number;
      /** @description Harmony preferences */
      harmonyStyle?: components['schemas']['HarmonyStyle'];
    };
    /** @description Brief style summary for listing */
    StyleSummary: {
      /** @description Style identifier */
      styleId: string;
      /** @description Style name */
      name: string;
      /** @description Style category */
      category: string;
      /** @description Brief description */
      description?: string | null;
    };
    /** @description Information about a subscription */
    SubscriptionInfo: {
      /**
       * Format: uuid
       * @description Unique identifier for the subscription
       */
      subscriptionId: string;
      /**
       * Format: uuid
       * @description ID of the account this subscription belongs to
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the subscribed service (game)
       */
      serviceId: string;
      /** @description Stub name of the service (denormalized for efficiency) */
      stubName: string;
      /** @description Display name of the service (denormalized for efficiency) */
      displayName?: string;
      /**
       * Format: date-time
       * @description When the subscription started
       */
      startDate: string;
      /**
       * Format: date-time
       * @description When the subscription expires (null for unlimited)
       */
      expirationDate?: string | null;
      /** @description Whether the subscription is currently active */
      isActive: boolean;
      /**
       * Format: date-time
       * @description When the subscription was cancelled (if applicable)
       */
      cancelledAt?: string | null;
      /** @description Reason for cancellation (if applicable) */
      cancellationReason?: string | null;
      /**
       * Format: date-time
       * @description When the subscription was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the subscription was last updated
       */
      updatedAt?: string | null;
    };
    /** @description Response containing list of subscriptions */
    SubscriptionListResponse: {
      /** @description List of subscriptions matching the filter criteria */
      subscriptions: components['schemas']['SubscriptionInfo'][];
      /** @description Total number of subscriptions matching the filter */
      totalCount: number;
    };
    /** @description Request to get related topic suggestions based on a source */
    SuggestRelatedRequest: {
      /** @description Documentation namespace for suggestions */
      namespace: string;
      /** @description Type of source to base suggestions on */
      suggestionSource: components['schemas']['SuggestionSource'];
      /** @description The value for the suggestion source (document ID, slug, topic, or category) */
      sourceValue?: string;
      /**
       * Format: uuid
       * @description Optional session ID for personalized suggestions
       */
      sessionId?: string;
      /**
       * @description Maximum number of suggestions to return
       * @default 5
       */
      maxSuggestions: number;
      /**
       * @description Exclude documents viewed in current session
       * @default true
       */
      excludeRecentlyViewed: boolean;
    };
    /** @description Response containing suggested related topics for conversational flow */
    SuggestRelatedResponse: {
      /** @description The namespace suggestions are from */
      namespace: string;
      /** @description List of suggested related topics */
      suggestions: components['schemas']['TopicSuggestion'][];
      /** @description Voice-friendly prompt for presenting suggestions */
      voicePrompt?: string;
      /** @description Whether suggestions were influenced by session history */
      sessionInfluenced?: boolean;
    };
    /**
     * @description Source type for generating related topic suggestions
     * @enum {string}
     */
    SuggestionSource: 'document_id' | 'slug' | 'topic' | 'category';
    /** @description Information about a repository sync operation */
    SyncInfo: {
      /**
       * Format: uuid
       * @description Unique identifier of the sync operation
       */
      syncId?: string;
      /** @description Result status of the sync */
      status?: components['schemas']['SyncStatus'];
      /** @description What triggered the sync */
      triggeredBy?: components['schemas']['SyncTrigger'];
      /**
       * Format: date-time
       * @description Timestamp when sync started
       */
      startedAt?: string;
      /**
       * Format: date-time
       * @description Timestamp when sync completed
       */
      completedAt?: string;
      /** @description Git commit hash that was synced (null if sync failed or repo is empty) */
      commitHash?: string | null;
      /** @description Total documents processed in sync */
      documentsProcessed?: number;
    };
    /** @description Request to trigger a manual repository sync */
    SyncRepositoryRequest: {
      /** @description Documentation namespace to sync */
      namespace: string;
      /**
       * @description Force full re-sync even if commit hash unchanged
       * @default false
       */
      force: boolean;
    };
    /** @description Response containing sync operation results and statistics */
    SyncRepositoryResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of this sync operation
       */
      syncId: string;
      /** @description Result status of the sync */
      status: components['schemas']['SyncStatus'];
      /** @description Git commit hash that was synced (null if sync failed or repo is empty) */
      commitHash?: string | null;
      /** @description Number of new documents created */
      documentsCreated?: number;
      /** @description Number of existing documents updated */
      documentsUpdated?: number;
      /** @description Number of documents deleted */
      documentsDeleted?: number;
      /** @description Number of documents that failed to process */
      documentsFailed?: number;
      /** @description Time taken for sync in milliseconds */
      durationMs?: number;
      /** @description Error message if sync failed */
      errorMessage?: string | null;
    };
    /**
     * @description Status of platform synchronization
     * @enum {string}
     */
    SyncStatus: 'pending' | 'synced' | 'failed' | 'not_linked';
    /**
     * @description What triggered the sync operation
     * @enum {string}
     */
    SyncTrigger: 'manual' | 'scheduled';
    /**
     * @description Current lifecycle status of a scenario template
     * @enum {string}
     */
    TemplateStatus: 'Draft' | 'Active' | 'Deprecated';
    /** @description A tempo change event */
    TempoEvent: {
      /** @description Tick position */
      tick: number;
      /**
       * Format: float
       * @description Tempo in BPM
       */
      bpm: number;
    };
    /** @description A tempo range with min and max BPM */
    TempoRange: {
      /** @description Minimum tempo */
      min: number;
      /** @description Maximum tempo */
      max: number;
    };
    /** @description Request to terminate a contract */
    TerminateContractInstanceRequest: {
      /**
       * Format: uuid
       * @description Contract to terminate
       */
      contractId: string;
      /**
       * Format: uuid
       * @description Entity requesting termination
       */
      requestingEntityId: string;
      /** @description Type of requesting entity */
      requestingEntityType: components['schemas']['EntityType'];
      /** @description Reason for termination */
      reason?: string | null;
    };
    /** @description Request to terminate a specific session */
    TerminateSessionRequest: {
      /**
       * Format: uuid
       * @description ID of the session to terminate
       */
      sessionId: string;
    };
    /**
     * @description How the contract can be terminated
     * @enum {string}
     */
    TerminationPolicy:
      | 'mutual_consent'
      | 'unilateral_with_notice'
      | 'unilateral_immediate'
      | 'non_terminable';
    /** @description A faction's territory claim on a location */
    TerritoryClaimResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for this territory claim
       */
      claimId: string;
      /**
       * Format: uuid
       * @description Faction that holds this claim
       */
      factionId: string;
      /**
       * Format: uuid
       * @description Location that is claimed
       */
      locationId: string;
      /** @description Current status of the territory claim */
      status: components['schemas']['TerritoryClaimStatus'];
      /**
       * Format: date-time
       * @description When the territory was claimed
       */
      claimedAt: string;
      /**
       * Format: date-time
       * @description When the territory was released (null if still active)
       */
      releasedAt?: string | null;
    };
    /**
     * @description Lifecycle status of a territory claim
     * @enum {string}
     */
    TerritoryClaimStatus: 'Active' | 'Contested' | 'Released';
    /**
     * @description Territory validation mode for constraint checking
     * @enum {string}
     */
    TerritoryMode: 'exclusive' | 'inclusive';
    /** @description Request to dry-run scenario trigger */
    TestScenarioRequest: {
      /**
       * Format: uuid
       * @description Scenario to test
       */
      scenarioId: string;
      /**
       * Format: uuid
       * @description Character to test against
       */
      characterId: string;
      /** @description Current character state */
      characterState: components['schemas']['CharacterStateSnapshot'];
      /**
       * Format: uuid
       * @description Location context
       */
      locationId?: string | null;
      /** @description Current in-game hour */
      timeOfDay?: number | null;
      /** @description World state context */
      worldState?: {
        [key: string]: string;
      } | null;
    };
    /** @description Result of scenario dry-run */
    TestScenarioResponse: {
      /** @description Whether scenario would trigger */
      wouldTrigger: boolean;
      /** @description Result of each condition check */
      conditionResults: components['schemas']['ConditionResult'][];
      /** @description Mutations that would be applied */
      predictedMutations?: components['schemas']['PredictedMutation'][] | null;
      /** @description Why scenario would not trigger (cooldown, exclusivity, etc.) */
      blockingReason?: string | null;
    };
    /** @description Visual theme configuration including colors, fonts, and navigation */
    ThemeConfig: {
      /** @description Name of the active theme */
      themeName: string;
      /** @description Primary brand color in hex format */
      primaryColor: string;
      /** @description Secondary brand color in hex format */
      secondaryColor?: string;
      /** @description Default background color in hex format */
      backgroundColor?: string;
      /** @description Default text color in hex format */
      textColor?: string;
      /** @description Primary font family for the site */
      fontFamily?: string;
      /** @description Additional custom CSS styles */
      customCSS?: string | null;
      /** @description Site logo configuration for branding */
      logo?: components['schemas']['Logo'];
      /**
       * Format: uri
       * @description URL of the site favicon
       */
      favicon?: string | null;
      /** @description Main navigation menu items */
      navigation?: components['schemas']['NavigationItem'][];
    };
    /**
     * @description Current status of a matchmaking ticket
     * @enum {string}
     */
    TicketStatus: 'searching' | 'match_found' | 'match_accepted' | 'cancelled' | 'expired';
    /**
     * @description Type of time commitment for scheduling constraints
     * @enum {string}
     */
    TimeCommitmentType: 'exclusive' | 'partial';
    /**
     * @description Why the time ratio was changed
     * @enum {string}
     */
    TimeRatioChangeReason: 'Initial' | 'AdminAdjustment' | 'Event' | 'Pause' | 'Resume';
    /** @description A time signature change event */
    TimeSignatureEvent: {
      /** @description Tick position */
      tick: number;
      /** @description Beats per measure */
      numerator: number;
      /** @description Beat unit (4 = quarter, 8 = eighth) */
      denominator: number;
    };
    /** @description A suggested related topic with relevance context */
    TopicSuggestion: {
      /**
       * Format: uuid
       * @description Unique identifier of the suggested document
       */
      documentId: string;
      /** @description URL-friendly slug of the suggested document */
      slug?: string;
      /** @description Title of the suggested document */
      title: string;
      /** @description Category of the suggested document */
      category?: components['schemas']['DocumentCategory'];
      /** @description Explanation of why this document is relevant */
      relevanceReason?: string;
    };
    /**
     * @description Core personality trait axes. Each represents a spectrum from -1.0 to +1.0.
     *     Based on psychological research (Big Five + game-relevant extensions).
     * @enum {string}
     */
    TraitAxis:
      | 'OPENNESS'
      | 'CONSCIENTIOUSNESS'
      | 'EXTRAVERSION'
      | 'AGREEABLENESS'
      | 'NEUROTICISM'
      | 'HONESTY'
      | 'AGGRESSION'
      | 'LOYALTY';
    /** @description Snapshot of a personality trait */
    TraitSnapshot: {
      /** @description Trait axis name (e.g., AGGRESSION, OPENNESS) */
      axis: string;
      /**
       * Format: float
       * @description Trait value (-1.0 to 1.0)
       */
      value: number;
    };
    /** @description A single personality trait with its current value and evolution history */
    TraitValue: {
      /** @description The personality axis this value represents */
      axis: components['schemas']['TraitAxis'];
      /**
       * Format: float
       * @description Current trait value on the spectrum (-1.0 to +1.0)
       */
      value: number;
      /**
       * Format: date-time
       * @description When this trait last evolved (null if never changed since creation)
       */
      lastChangedAt?: string | null;
      /**
       * @description Number of times this trait has evolved
       * @default 0
       */
      changeCount: number;
    };
    /** @description Transaction details */
    TransactionResponse: {
      /** @description Transaction record */
      transaction: components['schemas']['CurrencyTransactionRecord'];
    };
    /**
     * @description Classification of the currency transaction
     * @enum {string}
     */
    TransactionType:
      | 'mint'
      | 'quest_reward'
      | 'loot_drop'
      | 'vendor_sale'
      | 'autogain'
      | 'refund'
      | 'conversion_credit'
      | 'burn'
      | 'vendor_purchase'
      | 'fee'
      | 'expiration'
      | 'cap_overflow'
      | 'conversion_debit'
      | 'transfer'
      | 'trade'
      | 'gift'
      | 'escrow_deposit'
      | 'escrow_release'
      | 'escrow_refund';
    /** @description Request to transfer a party role to a new entity */
    TransferContractPartyRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractInstanceId: string;
      /**
       * Format: uuid
       * @description Current party entity ID
       */
      fromEntityId: string;
      /** @description Current party entity type */
      fromEntityType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description New entity ID to receive the role
       */
      toEntityId: string;
      /** @description New entity type */
      toEntityType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Guardian entity ID (must be current guardian)
       */
      guardianId: string;
      /** @description Guardian entity type */
      guardianType: string;
      /** @description Optional idempotency key for the operation */
      idempotencyKey?: string | null;
    };
    /** @description Response from transferring a party role. HTTP 200 confirms the transfer succeeded. */
    TransferContractPartyResponse: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Role that was transferred */
      role: string;
      /**
       * Format: uuid
       * @description Previous party entity ID
       */
      fromEntityId: string;
      /**
       * Format: uuid
       * @description New party entity ID
       */
      toEntityId: string;
    };
    /** @description Request to transfer currency between wallets */
    TransferCurrencyRequest: {
      /**
       * Format: uuid
       * @description Source wallet ID
       */
      sourceWalletId: string;
      /**
       * Format: uuid
       * @description Target wallet ID
       */
      targetWalletId: string;
      /**
       * Format: uuid
       * @description Currency to transfer
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to transfer (must be positive)
       */
      amount: number;
      /** @description Must be a transfer type (transfer, trade, gift) */
      transactionType: components['schemas']['TransactionType'];
      /** @description What triggered this transfer */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference entity ID
       */
      referenceId?: string | null;
      /** @description Unique key to prevent duplicate processing */
      idempotencyKey: string;
      /** @description Free-form transaction metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Result of transfer operation */
    TransferCurrencyResponse: {
      /** @description Created transaction record */
      transaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Source wallet balance after transfer
       */
      sourceNewBalance: number;
      /**
       * Format: double
       * @description Target wallet balance after transfer
       */
      targetNewBalance: number;
      /** @description Whether target wallet cap was applied */
      targetCapApplied: boolean;
      /**
       * Format: double
       * @description Amount lost due to target wallet cap
       */
      targetCapAmountLost?: number | null;
    };
    /** @description Request to transfer item ownership */
    TransferItemRequest: {
      /**
       * Format: uuid
       * @description Item instance ID
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Target container ID
       */
      targetContainerId: string;
      /**
       * Format: double
       * @description Quantity to transfer (all if null)
       */
      quantity?: number | null;
    };
    /** @description Response after transfer. HTTP 200 confirms transfer. */
    TransferItemResponse: {
      /**
       * Format: uuid
       * @description Transferred item ID (for partial transfers, this is the new split item)
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Container the item was transferred from
       */
      sourceContainerId: string;
      /**
       * Format: double
       * @description Amount transferred
       */
      quantityTransferred: number;
    };
    /** @description Result of transferring assets to a party during resolution */
    TransferResult: {
      /**
       * Format: uuid
       * @description Party ID
       */
      partyId: string;
      /** @description Assets transferred (null if failed) */
      assets?: components['schemas']['EscrowAssetBundle'];
      /** @description Whether transfer succeeded */
      success: boolean;
      /** @description Error message if failed */
      error?: string | null;
    };
    /** @description Position, rotation, and scale in 3D space */
    Transform: {
      /** @description Position relative to parent */
      position: components['schemas']['Vector3'];
      /** @description Rotation relative to parent */
      rotation: components['schemas']['Quaternion'];
      /** @description Scale relative to parent */
      scale: components['schemas']['Vector3'];
    };
    /** @description A condition that must be met for scenario triggering */
    TriggerCondition: {
      /** @description Type of condition to evaluate */
      conditionType: components['schemas']['TriggerConditionType'];
      /** @description Personality trait axis for TraitRange (e.g., AGGRESSION) */
      traitAxis?: string | null;
      /**
       * Format: float
       * @description Minimum trait value for TraitRange (-1.0 to 1.0)
       */
      traitMin?: number | null;
      /**
       * Format: float
       * @description Maximum trait value for TraitRange (-1.0 to 1.0)
       */
      traitMax?: number | null;
      /** @description Backstory element type for BackstoryElement (e.g., TRAUMA) */
      backstoryType?: string | null;
      /** @description Backstory element key for BackstoryElement */
      backstoryKey?: string | null;
      /** @description Relationship type code for RelationshipExists/Missing */
      relationshipTypeCode?: string | null;
      /** @description Type of other entity in relationship check */
      otherEntityType?: string | null;
      /** @description Minimum character age for AgeRange */
      ageMin?: number | null;
      /** @description Maximum character age for AgeRange */
      ageMax?: number | null;
      /**
       * Format: uuid
       * @description Required location ID for LocationAt
       */
      locationId?: string | null;
      /** @description Minimum hour of day (0-23) for TimeOfDay */
      timeOfDayMin?: number | null;
      /** @description Maximum hour of day (0-23) for TimeOfDay */
      timeOfDayMax?: number | null;
      /** @description Custom state key for WorldState/Custom */
      worldStateKey?: string | null;
      /** @description Expected value for WorldState/Custom */
      worldStateValue?: string | null;
    };
    /**
     * @description Types of trigger conditions for scenario activation.
     *     TraitRange: Character trait within value range
     *     BackstoryElement: Character has specific backstory element
     *     RelationshipExists: Relationship exists between entities
     *     RelationshipMissing: Relationship does not exist
     *     AgeRange: Character age within range
     *     LocationAt: Character at specific location
     *     TimeOfDay: In-game time within range
     *     WorldState: Custom world state check
     *     Custom: Custom condition (not evaluated server-side)
     * @enum {string}
     */
    TriggerConditionType:
      | 'TraitRange'
      | 'BackstoryElement'
      | 'RelationshipExists'
      | 'RelationshipMissing'
      | 'AgeRange'
      | 'LocationAt'
      | 'TimeOfDay'
      | 'WorldState'
      | 'Custom';
    /**
     * @description How a POI is triggered by the player
     * @enum {string}
     */
    TriggerMode: 'Proximity' | 'Interaction' | 'Prompted' | 'Forced';
    /** @description Request to trigger a time sync event for an entity's sessions */
    TriggerTimeSyncRequest: {
      /**
       * Format: uuid
       * @description Realm to sync time for
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Entity whose sessions should receive the sync (typically a character or account)
       */
      entityId: string;
    };
    /** @description Result of a time sync trigger */
    TriggerTimeSyncResponse: {
      /** @description Number of sessions that received the time sync event */
      sessionsNotified: number;
    };
    /** @description A style-specific tune type definition */
    TuneType: {
      /** @description Tune type name (e.g., "reel", "jig") */
      name: string;
      /** @description Time signature for this tune type */
      meter: components['schemas']['TimeSignatureEvent'];
      /** @description Typical tempo range */
      tempoRange?: components['schemas']['TempoRange'];
      /** @description Default form for this tune type */
      defaultForm?: string | null;
      /** @description Rhythm pattern names to use */
      rhythmPatterns?: string[] | null;
    };
    /** @description Request to remove a ban for a participant */
    UnbanParticipantRequest: {
      /**
       * Format: uuid
       * @description Room ID
       */
      roomId: string;
      /**
       * Format: uuid
       * @description Session ID of participant to unban
       */
      targetSessionId: string;
    };
    /** @description Request to reactivate a deprecated faction */
    UndeprecateFactionRequest: {
      /**
       * Format: uuid
       * @description ID of the faction to reactivate
       */
      factionId: string;
    };
    /** @description Request to restore a deprecated seed type to active status. */
    UndeprecateSeedTypeRequest: {
      /** @description The seed type to restore. */
      seedTypeCode: string;
      /**
       * Format: uuid
       * @description The game service scope. Null for cross-game seed types.
       */
      gameServiceId?: string | null;
    };
    /** @description Request to unlock a contract from guardian custody */
    UnlockContractRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID to unlock
       */
      contractInstanceId: string;
      /**
       * Format: uuid
       * @description Guardian entity ID (must match current guardian)
       */
      guardianId: string;
      /** @description Guardian entity type */
      guardianType: string;
      /** @description Optional idempotency key for the operation */
      idempotencyKey?: string | null;
    };
    /** @description Response from unlocking a contract. HTTP 200 confirms the contract was unlocked. */
    UnlockContractResponse: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
    };
    /** @description Request to unlock a license on a board */
    UnlockLicenseRequest: {
      /**
       * Format: uuid
       * @description Board instance to unlock on
       */
      boardId: string;
      /** @description License code to unlock */
      licenseCode: string;
    };
    /** @description Result of a successful license unlock */
    UnlockLicenseResponse: {
      /**
       * Format: uuid
       * @description Board the license was unlocked on
       */
      boardId: string;
      /** @description License code that was unlocked */
      licenseCode: string;
      /** @description Grid position of the unlocked license */
      position: components['schemas']['GridPosition'];
      /**
       * Format: uuid
       * @description Item instance created for this license
       */
      itemInstanceId: string;
      /**
       * Format: uuid
       * @description Contract instance created for this unlock
       */
      contractInstanceId: string;
    };
    /** @description An unlocked achievement instance */
    UnlockedAchievement: {
      /** @description Achievement identifier */
      achievementId: string;
      /** @description Achievement name */
      displayName: string;
      /** @description Achievement description */
      description?: string;
      /** @description Point value */
      points: number;
      /** @description Achievement icon */
      iconUrl?: string | null;
      /**
       * Format: date-time
       * @description When it was unlocked
       */
      unlockedAt: string;
    };
    /** @description An unlocked entry with template info and metadata */
    UnlockedEntryResponse: {
      /**
       * Format: uuid
       * @description Entry template identifier
       */
      entryTemplateId: string;
      /** @description Entry code */
      code: string;
      /** @description Display name from the template */
      displayName: string;
      /** @description Category from the template */
      category?: string | null;
      /** @description Tags from the template */
      tags?: string[] | null;
      /**
       * Format: uuid
       * @description Item instance for this unlocked entry
       */
      itemInstanceId: string;
      /**
       * Format: date-time
       * @description When this entry was unlocked
       */
      unlockedAt: string;
      /** @description Entry instance metadata (null if no metadata was provided at grant time) */
      metadata?: components['schemas']['EntryMetadata'] | null;
    };
    /** @description Request to unpin a message in a room */
    UnpinMessageRequest: {
      /**
       * Format: uuid
       * @description Room the message belongs to
       */
      roomId: string;
      /**
       * Format: uuid
       * @description Message ID to unpin
       */
      messageId: string;
    };
    /** @description Request to unpin a previously pinned save version */
    UnpinVersionRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Slot name */
      slotName: string;
      /** @description Version to unpin */
      versionNumber: number;
    };
    /** @description Request to unregister a character as a deity follower */
    UnregisterFollowerRequest: {
      /**
       * Format: uuid
       * @description Deity to unfollow
       */
      deityId: string;
      /**
       * Format: uuid
       * @description Character to remove as follower
       */
      characterId: string;
    };
    /** @description Request to unregister a reference to a resource */
    UnregisterReferenceRequest: {
      /** @description Type of resource being dereferenced (opaque identifier) */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource being dereferenced
       */
      resourceId: string;
      /** @description Type of entity releasing the reference (opaque identifier) */
      sourceType: string;
      /** @description ID of the entity releasing the reference (opaque string, supports non-Guid IDs) */
      sourceId: string;
    };
    /** @description Response after unregistering a reference */
    UnregisterReferenceResponse: {
      /** @description Type of resource dereferenced */
      resourceType: string;
      /**
       * Format: uuid
       * @description ID of the resource dereferenced
       */
      resourceId: string;
      /** @description Reference count after unregistration */
      newRefCount: number;
      /** @description True if this reference existed before unregistration */
      wasRegistered: boolean;
      /**
       * Format: date-time
       * @description When grace period started (null if refCount > 0)
       */
      gracePeriodStartedAt?: string | null;
    };
    /** @description A scene reference that could not be resolved */
    UnresolvedReference: {
      /**
       * Format: uuid
       * @description Node ID containing the reference
       */
      nodeId: string;
      /** @description refId of the referencing node */
      refId: string;
      /**
       * Format: uuid
       * @description ID of the scene that could not be resolved
       */
      referencedSceneId: string;
      /** @description Why the reference could not be resolved */
      reason: components['schemas']['UnresolvedReferenceReason'];
      /** @description For circular references, the cycle path (sceneId chain) */
      cyclePath?: string[] | null;
    };
    /**
     * @description Reason why a scene reference could not be resolved
     * @enum {string}
     */
    UnresolvedReferenceReason:
      | 'not_found'
      | 'circular_reference'
      | 'depth_exceeded'
      | 'access_denied';
    /** @description Request to update an achievement definition */
    UpdateAchievementDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the achievement to update */
      achievementId: string;
      /** @description New display name */
      displayName?: string | null;
      /** @description New description */
      description?: string | null;
      /** @description New active status */
      isActive?: boolean | null;
      /** @description Updated platform ID mappings */
      platformIds?: {
        [key: string]: string;
      } | null;
    };
    /** @description Request to update an existing actor template */
    UpdateActorTemplateRequest: {
      /**
       * Format: uuid
       * @description ID of the template to update
       */
      templateId: string;
      /** @description New behavior reference (triggers behavior.updated subscription) */
      behaviorRef?: string | null;
      /** @description Updated game-specific configuration for ABML behavior execution scope. No Bannou plugin reads specific keys from this field by convention. */
      configuration?: {
        [key: string]: unknown;
      } | null;
      /** @description Updated auto-spawn configuration */
      autoSpawn?: components['schemas']['AutoSpawnConfig'];
      /** @description Updated tick interval in milliseconds */
      tickIntervalMs?: number | null;
      /** @description Updated auto-save interval in seconds */
      autoSaveIntervalSeconds?: number | null;
      /**
       * @description Updated cognition template ID. Set to override the cognition pipeline
       *     for actors created from this template.
       */
      cognitionTemplateId?: string | null;
      /** @description Updated cognition overrides (polymorphic JSON). Deserialized internally to CognitionOverrides type with discriminated subtypes. No Bannou plugin reads specific keys from this field by convention. */
      cognitionOverrides?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update mutable fields of a board template */
    UpdateBoardTemplateRequest: {
      /**
       * Format: uuid
       * @description Board template to update
       */
      boardTemplateId: string;
      /** @description Updated display name */
      name?: string | null;
      /** @description Updated description */
      description?: string | null;
      /** @description Whether the template is active (can create new board instances) */
      isActive?: boolean | null;
      /** @description Updated allowed owner types. Narrowing checks for existing boards with removed types. */
      allowedOwnerTypes?: components['schemas']['EntityType'][] | null;
    };
    /** @description Request to update bundle metadata */
    UpdateBundleRequest: {
      /** @description Human-readable bundle identifier to update */
      bundleId: string;
      /** @description New bundle name (null to leave unchanged) */
      name?: string | null;
      /** @description New bundle description (null to leave unchanged) */
      description?: string | null;
      /** @description Replace all tags with these (null to leave unchanged) */
      tags?: {
        [key: string]: string;
      } | null;
      /** @description Tags to add (merged with existing) */
      addTags?: {
        [key: string]: string;
      } | null;
      /** @description Tag keys to remove */
      removeTags?: string[] | null;
      /** @description Optional reason for the update (recorded in version history) */
      reason?: string | null;
    };
    /** @description Result of bundle update operation */
    UpdateBundleResponse: {
      /** @description Human-readable bundle identifier that was updated */
      bundleId: string;
      /** @description New version number after update */
      version: number;
      /** @description Version number before update */
      previousVersion: number;
      /** @description List of changes made (e.g., "name changed", "tag 'env' added") */
      changes: string[];
      /**
       * Format: date-time
       * @description When the update occurred
       */
      updatedAt?: string;
    };
    /** @description Request to partially update a calendar template (only non-null fields are applied) */
    UpdateCalendarRequest: {
      /**
       * Format: uuid
       * @description Game service the calendar belongs to (identity, cannot be changed)
       */
      gameServiceId: string;
      /** @description Calendar template code (identity, cannot be changed) */
      templateCode: string;
      /** @description New number of game hours in a day (triggers day period re-validation) */
      gameHoursPerDay?: number | null;
      /** @description New day period definitions (must cover [0, gameHoursPerDay) without gaps or overlaps) */
      dayPeriods?: components['schemas']['DayPeriodDefinition'][] | null;
      /** @description New month definitions (season codes must reference defined seasons) */
      months?: components['schemas']['MonthDefinition'][] | null;
      /** @description New season definitions */
      seasons?: components['schemas']['SeasonDefinition'][] | null;
      /** @description New era label definitions (null = no change, empty array = clear all) */
      eraLabels?: components['schemas']['EraLabel'][] | null;
    };
    /** @description Request to update container properties */
    UpdateContainerRequest: {
      /**
       * Format: uuid
       * @description Container ID to update
       */
      containerId: string;
      /** @description New max slots */
      maxSlots?: number | null;
      /**
       * Format: double
       * @description New max weight
       */
      maxWeight?: number | null;
      /** @description New grid width */
      gridWidth?: number | null;
      /** @description New grid height */
      gridHeight?: number | null;
      /**
       * Format: double
       * @description New max volume
       */
      maxVolume?: number | null;
      /** @description New allowed categories */
      allowedCategories?: string[] | null;
      /** @description New forbidden categories */
      forbiddenCategories?: string[] | null;
      /** @description New allowed tags */
      allowedTags?: string[] | null;
      /** @description New container tags */
      tags?: string[] | null;
      /** @description New game-specific container data. Client-only metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update contract metadata */
    UpdateContractMetadataRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Which metadata to update */
      metadataType: components['schemas']['MetadataType'];
      /** @description Client-only metadata payload. No Bannou plugin reads specific keys from this field by convention. */
      data: {
        [key: string]: unknown;
      };
    };
    /** @description Request to update a map definition */
    UpdateDefinitionRequest: {
      /**
       * Format: uuid
       * @description Definition ID to update
       */
      definitionId: string;
      /** @description New name (optional) */
      name?: string | null;
      /** @description New description (optional) */
      description?: string | null;
      /** @description New layer configurations (replaces existing) */
      layers?: components['schemas']['LayerDefinition'][] | null;
      /** @description New default bounds */
      defaultBounds?: components['schemas']['Bounds'];
      /** @description Updated client-provided definition metadata (replaces existing). No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update deity properties (partial update, only non-null fields applied) */
    UpdateDeityRequest: {
      /**
       * Format: uuid
       * @description Deity to update
       */
      deityId: string;
      /** @description Updated display name */
      displayName?: string | null;
      /** @description Updated description */
      description?: string | null;
      /** @description Updated domain influences (replaces entire list) */
      domains?: components['schemas']['DomainInfluence'][] | null;
      /** @description Updated personality traits */
      personalityTraits?: components['schemas']['DeityPersonalityTraits'] | null;
      /** @description Updated maximum attention slots */
      maxAttentionSlots?: number | null;
    };
    /** @description Request to update the phase of an active encounter */
    UpdateEncounterPhaseRequest: {
      /** @description ID of the Event Brain actor managing the encounter */
      actorId: string;
      /** @description New phase name for the encounter */
      phase: string;
    };
    /** @description Response after updating encounter phase */
    UpdateEncounterPhaseResponse: {
      /** @description ID of the actor managing the encounter */
      actorId: string;
      /** @description Previous phase name */
      previousPhase?: string | null;
      /** @description Current phase name after update */
      currentPhase: string;
    };
    /** @description Request to update metadata for an unlocked entry */
    UpdateEntryMetadataRequest: {
      /**
       * Format: uuid
       * @description Collection containing the entry
       */
      collectionId: string;
      /** @description Entry code to update metadata for */
      entryCode: string;
      /** @description Updated play count (replaces current value) */
      playCount?: number | null;
      /** @description Updated kill count (replaces current value) */
      killCount?: number | null;
      /** @description Updated favorite status */
      favorited?: boolean | null;
      /** @description Updated discovery level */
      discoveryLevel?: number | null;
      /** @description Updated custom data (merged with existing). No Bannou plugin reads specific keys from this field by convention. */
      customData?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update mutable fields of an entry template */
    UpdateEntryTemplateRequest: {
      /**
       * Format: uuid
       * @description Entry template to update
       */
      entryTemplateId: string;
      /** @description Updated display name */
      displayName?: string | null;
      /** @description Updated category */
      category?: string | null;
      /** @description Updated tags */
      tags?: string[] | null;
      /** @description Updated primary asset identifier */
      assetId?: string | null;
      /** @description Updated thumbnail asset identifier */
      thumbnailAssetId?: string | null;
      /** @description Updated unlock hint text */
      unlockHint?: string | null;
      /** @description Updated spoiler protection flag */
      hideWhenLocked?: boolean | null;
      /** @description Updated discovery levels */
      discoveryLevels?: components['schemas']['DiscoveryLevel'][] | null;
      /** @description Updated theme tags for music entries */
      themes?: string[] | null;
      /** @description Updated duration */
      duration?: string | null;
      /** @description Updated loop point */
      loopPoint?: string | null;
      /** @description Updated composer name */
      composer?: string | null;
    };
    /** @description Request to update a faction */
    UpdateFactionRequest: {
      /**
       * Format: uuid
       * @description ID of the faction to update
       */
      factionId: string;
      /** @description New display name (null to keep current) */
      name?: string | null;
      /** @description New code (null to keep current, must be unique within game service) */
      code?: string | null;
      /** @description New description (null to keep current) */
      description?: string | null;
    };
    /** @description Request to update mutable fields of an item template */
    UpdateItemTemplateRequest: {
      /**
       * Format: uuid
       * @description Template ID to update
       */
      templateId: string;
      /** @description New display name */
      name?: string | null;
      /** @description New description */
      description?: string | null;
      /** @description New subcategory */
      subcategory?: string | null;
      /** @description New tags (replaces existing) */
      tags?: string[] | null;
      /** @description New rarity tier */
      rarity?: components['schemas']['ItemRarity'];
      /**
       * Format: double
       * @description New weight value
       */
      weight?: number | null;
      /**
       * Format: double
       * @description New volume value
       */
      volume?: number | null;
      /** @description New grid width */
      gridWidth?: number | null;
      /** @description New grid height */
      gridHeight?: number | null;
      /** @description New rotation setting */
      canRotate?: boolean | null;
      /**
       * Format: double
       * @description New base value
       */
      baseValue?: number | null;
      /** @description New tradeable setting */
      tradeable?: boolean | null;
      /** @description New destroyable setting */
      destroyable?: boolean | null;
      /** @description New max durability */
      maxDurability?: number | null;
      /** @description New available realms */
      availableRealms?: string[] | null;
      /** @description New stats. Opaque to Bannou; no plugin reads keys by convention. */
      stats?: Record<string, never> | null;
      /** @description New effects. Opaque to Bannou; no plugin reads keys by convention. */
      effects?: Record<string, never> | null;
      /** @description New requirements. Opaque to Bannou; no plugin reads keys by convention. */
      requirements?: Record<string, never> | null;
      /** @description New display properties. Opaque to Bannou; no plugin reads keys by convention. */
      display?: Record<string, never> | null;
      /** @description New metadata. Opaque to Bannou; no plugin reads keys by convention. */
      metadata?: Record<string, never> | null;
      /** @description Active status */
      isActive?: boolean | null;
      /**
       * Format: uuid
       * @description Contract template ID for executable item behavior (null to clear)
       */
      useBehaviorContractTemplateId?: string | null;
      /**
       * Format: uuid
       * @description Contract template for pre-use validation (null to clear)
       */
      canUseBehaviorContractTemplateId?: string | null;
      /**
       * Format: uuid
       * @description Contract template for use failure handling (null to clear)
       */
      onUseFailedBehaviorContractTemplateId?: string | null;
      /** @description How the item should behave when used */
      itemUseBehavior?: components['schemas']['ItemUseBehavior'];
      /** @description How CanUse validation failures should be handled */
      canUseBehavior?: components['schemas']['CanUseBehavior'];
    };
    /** @description Request to update a leaderboard definition */
    UpdateLeaderboardDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard to update */
      leaderboardId: string;
      /** @description New display name */
      displayName?: string | null;
      /** @description New description */
      description?: string | null;
      /** @description New visibility setting */
      isPublic?: boolean | null;
    };
    /** @description Request to update mutable fields of a license definition */
    UpdateLicenseDefinitionRequest: {
      /**
       * Format: uuid
       * @description Board template containing the definition
       */
      boardTemplateId: string;
      /** @description License code to update */
      code: string;
      /** @description Updated LP cost */
      lpCost?: number | null;
      /** @description Updated prerequisite license codes */
      prerequisites?: string[] | null;
      /** @description Updated description */
      description?: string | null;
      /** @description Updated game-specific metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update a member's role */
    UpdateMemberRoleRequest: {
      /**
       * Format: uuid
       * @description Faction containing the membership
       */
      factionId: string;
      /**
       * Format: uuid
       * @description Character whose role to update
       */
      characterId: string;
      /** @description New role to assign */
      role: components['schemas']['FactionMemberRole'];
    };
    /** @description Request to update MFA settings for an account */
    UpdateMfaRequest: {
      /**
       * Format: uuid
       * @description ID of the account to update
       */
      accountId: string;
      /** @description Whether to enable or disable MFA */
      mfaEnabled: boolean;
      /** @description Encrypted TOTP secret (set when enabling, null when disabling) */
      mfaSecret?: string | null;
      /** @description BCrypt-hashed recovery codes (set when enabling, null when disabling) */
      mfaRecoveryCodes?: string[] | null;
    };
    /**
     * @description How to handle score updates
     * @enum {string}
     */
    UpdateMode: 'replace' | 'increment' | 'max' | 'min';
    /** @description Request to update an existing norm definition */
    UpdateNormRequest: {
      /**
       * Format: uuid
       * @description ID of the norm to update
       */
      normId: string;
      /**
       * Format: float
       * @description New base penalty (null to keep current)
       */
      basePenalty?: number | null;
      /** @description New severity level (null to keep current) */
      severity?: components['schemas']['NormSeverity'];
      /** @description New scope (null to keep current) */
      scope?: components['schemas']['NormScope'];
      /** @description New description (null to keep current) */
      description?: string | null;
    };
    /** @description Request to update an account password */
    UpdatePasswordRequest: {
      /**
       * Format: uuid
       * @description ID of the account to update
       */
      accountId: string;
      /** @description New pre-hashed password from Auth service */
      passwordHash: string;
    };
    /** @description Request to update deployment phase configuration (non-null fields applied) */
    UpdatePhaseConfigRequest: {
      /** @description New deployment phase */
      currentPhase?: components['schemas']['DeploymentPhase'];
      /** @description Updated global scenario capacity */
      maxConcurrentScenariosGlobal?: number | null;
      /** @description Whether persistent world entry is enabled */
      persistentEntryEnabled?: boolean | null;
      /** @description Whether garden minigames are enabled */
      gardenMinigamesEnabled?: boolean | null;
    };
    /** @description Request to update player position in the garden */
    UpdatePositionRequest: {
      /**
       * Format: uuid
       * @description Account whose position to update
       */
      accountId: string;
      /** @description New position in garden space */
      position: components['schemas']['Vec3'];
      /** @description Current velocity vector */
      velocity: components['schemas']['Vec3'];
    };
    /** @description Request to update an account profile */
    UpdateProfileRequest: {
      /**
       * Format: uuid
       * @description ID of the account to update
       */
      accountId: string;
      /** @description New display name for the account */
      displayName?: string | null;
      /** @description Client-only metadata. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update quest definition metadata */
    UpdateQuestDefinitionRequest: {
      /**
       * Format: uuid
       * @description Definition to update
       */
      definitionId: string;
      /** @description New name */
      name?: string | null;
      /** @description New description */
      description?: string | null;
      /** @description New quest category */
      category?: components['schemas']['QuestCategory'] | null;
      /** @description New difficulty rating */
      difficulty?: components['schemas']['QuestDifficulty'] | null;
      /** @description New tags */
      tags?: string[] | null;
    };
    /** @description Request to partially update realm worldstate configuration */
    UpdateRealmConfigRequest: {
      /**
       * Format: uuid
       * @description Realm to update configuration for
       */
      realmId: string;
      /** @description New downtime handling policy (null = no change) */
      downtimePolicy?: components['schemas']['DowntimePolicy'] | null;
      /** @description New calendar template code (validated for existence, null = no change) */
      calendarTemplateCode?: string | null;
    };
    /** @description Request to update repository binding configuration */
    UpdateRepositoryBindingRequest: {
      /** @description Documentation namespace of the binding to update */
      namespace: string;
      /** @description Enable or disable automatic syncing */
      syncEnabled?: boolean;
      /** @description New sync interval in minutes */
      syncIntervalMinutes?: number;
      /** @description New glob patterns for files to include (null to keep unchanged) */
      filePatterns?: string[] | null;
      /** @description New glob patterns for files to exclude (null to keep unchanged) */
      excludePatterns?: string[] | null;
      /** @description New directory-to-category mapping (null to keep unchanged) */
      categoryMapping?: {
        [key: string]: string;
      } | null;
      /** @description New default category for unmapped documents */
      defaultCategory?: components['schemas']['DocumentCategory'];
      /** @description Enable or disable archive functionality */
      archiveEnabled?: boolean;
      /** @description Enable or disable archiving after each sync */
      archiveOnSync?: boolean;
    };
    /** @description Response containing the updated binding configuration */
    UpdateRepositoryBindingResponse: {
      /** @description Updated binding configuration */
      binding: components['schemas']['RepositoryBindingInfo'];
    };
    /** @description Request to update room properties (null fields left unchanged) */
    UpdateRoomRequest: {
      /**
       * Format: uuid
       * @description Room ID to update
       */
      roomId: string;
      /** @description Updated room name */
      displayName?: string | null;
      /** @description Updated participant limit */
      maxParticipants?: number | null;
      /** @description Client-only metadata stored as JSON string. No Bannou plugin reads specific keys from this field by convention. */
      metadata?: string | null;
    };
    /** @description Request to update room type properties (null fields left unchanged) */
    UpdateRoomTypeRequest: {
      /** @description Room type code to update */
      code: string;
      /**
       * Format: uuid
       * @description Game service scope for the type
       */
      gameServiceId?: string | null;
      /** @description Updated display name */
      displayName?: string | null;
      /** @description Updated description */
      description?: string | null;
      /** @description Updated validation rules */
      validatorConfig?: components['schemas']['ValidatorConfig'] | null;
      /** @description Updated default participant limit */
      defaultMaxParticipants?: number | null;
      /** @description Updated message retention in days */
      retentionDays?: number | null;
      /**
       * Format: uuid
       * @description Updated default contract template
       */
      defaultContractTemplateId?: string | null;
      /** @description Updated anonymous sender policy */
      allowAnonymousSenders?: boolean | null;
      /** @description Updated rate limit */
      rateLimitPerMinute?: number | null;
      /** @description Updated JSON metadata */
      metadata?: string | null;
    };
    /** @description Request to update a scenario definition */
    UpdateScenarioDefinitionRequest: {
      /**
       * Format: uuid
       * @description Scenario to update
       */
      scenarioId: string;
      /** @description ETag for optimistic concurrency */
      etag: string;
      /** @description New name */
      name?: string | null;
      /** @description New description */
      description?: string | null;
      /** @description New trigger conditions */
      triggerConditions?: components['schemas']['TriggerCondition'][] | null;
      /** @description New phases */
      phases?: components['schemas']['ScenarioPhase'][] | null;
      /** @description New mutations */
      mutations?: components['schemas']['ScenarioMutation'][] | null;
      /** @description New quest hooks */
      questHooks?: components['schemas']['ScenarioQuestHook'][] | null;
      /** @description New cooldown */
      cooldownSeconds?: number | null;
      /** @description New exclusivity tags */
      exclusivityTags?: string[] | null;
      /** @description New priority */
      priority?: number | null;
      /** @description New enabled state */
      enabled?: boolean | null;
      /** @description New classification tags */
      tags?: string[] | null;
    };
    /** @description Request to update an existing scene */
    UpdateSceneRequest: {
      /** @description The updated scene document (sceneId must match existing) */
      scene: components['schemas']['Scene'];
      /** @description Checkout token if updating via checkout workflow */
      checkoutToken?: string | null;
    };
    /** @description Request to update a seed's mutable fields. */
    UpdateSeedRequest: {
      /**
       * Format: uuid
       * @description The seed to update.
       */
      seedId: string;
      /** @description New display name. */
      displayName?: string | null;
      /** @description Client-provided metadata fields to merge (set key to null to delete). No Bannou plugin reads specific keys from this field by convention. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update a seed type definition. */
    UpdateSeedTypeRequest: {
      /** @description The seed type to update. */
      seedTypeCode: string;
      /**
       * Format: uuid
       * @description The game service scope. Null for cross-game seed types.
       */
      gameServiceId?: string | null;
      /** @description New display name. */
      displayName?: string | null;
      /** @description New description. */
      description?: string | null;
      /** @description Updated maximum per owner. */
      maxPerOwner?: number | null;
      /** @description Updated phase definitions. */
      growthPhases?: components['schemas']['GrowthPhaseDefinition'][] | null;
      /** @description Updated capability rules. */
      capabilityRules?: components['schemas']['CapabilityRule'][] | null;
      /** @description Whether unused growth domains decay over time for this seed type. Falls back to global config if null. */
      growthDecayEnabled?: boolean | null;
      /**
       * Format: float
       * @description Daily decay rate for unused domains of this seed type. Falls back to global config if null.
       */
      growthDecayRatePerDay?: number | null;
      /**
       * Format: float
       * @description Updated fraction of growth applied to other seeds of the same type owned by the same entity.
       */
      sameOwnerGrowthMultiplier?: number | null;
      /** @description Updated collection growth mappings. Null means no change, empty array removes all mappings. */
      collectionGrowthMappings?: components['schemas']['CollectionGrowthMapping'][] | null;
    };
    /** @description Request to update mutable fields of a status template (null fields are not updated) */
    UpdateStatusTemplateRequest: {
      /**
       * Format: uuid
       * @description Status template to update
       */
      statusTemplateId: string;
      /** @description Updated display name (null means no change) */
      displayName?: string | null;
      /** @description Updated description (null means no change) */
      description?: string | null;
      /** @description Updated status category (null means no change) */
      category?: components['schemas']['StatusCategory'] | null;
      /** @description Updated stackable flag (null means no change) */
      stackable?: boolean | null;
      /** @description Updated maximum stack count (null means no change) */
      maxStacks?: number | null;
      /** @description Updated stacking behavior (null means no change) */
      stackBehavior?: components['schemas']['StackBehavior'] | null;
      /**
       * Format: uuid
       * @description Updated contract template reference (null means no change)
       */
      contractTemplateId?: string | null;
      /** @description Updated default duration in seconds (null means no change) */
      defaultDurationSeconds?: number | null;
      /**
       * Format: uuid
       * @description Updated icon asset reference (null means no change)
       */
      iconAssetId?: string | null;
    };
    /** @description Request to update a template (non-null fields are applied) */
    UpdateTemplateRequest: {
      /**
       * Format: uuid
       * @description Template ID to update
       */
      scenarioTemplateId: string;
      /** @description Updated display name */
      displayName?: string | null;
      /** @description Updated description */
      description?: string | null;
      /** @description Updated domain weights */
      domainWeights?: components['schemas']['DomainWeight'][] | null;
      /** @description Updated max concurrent instances */
      maxConcurrentInstances?: number | null;
      /** @description Updated prerequisites */
      prerequisites?: components['schemas']['ScenarioPrerequisites'];
      /** @description Updated chaining configuration */
      chaining?: components['schemas']['ScenarioChaining'];
      /** @description Updated multiplayer configuration */
      multiplayer?: components['schemas']['ScenarioMultiplayer'];
      /** @description Updated content references */
      content?: components['schemas']['ScenarioContent'];
    };
    /** @description Request to update email verification status */
    UpdateVerificationRequest: {
      /**
       * Format: uuid
       * @description ID of the account to update
       */
      accountId: string;
      /** @description New email verification status */
      emailVerified: boolean;
    };
    /** @description Request to initiate an asset upload and receive a pre-signed URL */
    UploadRequest: {
      /**
       * @description Owner of this asset operation. NOT a session ID.
       *     For user-initiated uploads: the accountId (UUID format).
       *     For service-initiated uploads: the service name (e.g., "behavior", "orchestrator").
       */
      owner: string;
      /** @description Original filename with extension */
      filename: string;
      /**
       * Format: int64
       * @description File size in bytes
       */
      size: number;
      /** @description MIME content type (e.g., image/png, model/gltf-binary) */
      contentType: string;
      /** @description Optional metadata for asset categorization */
      metadata?: components['schemas']['AssetMetadataInput'];
    };
    /** @description Response containing pre-signed URL and configuration for uploading an asset */
    UploadResponse: {
      /**
       * Format: uuid
       * @description Unique upload session identifier
       */
      uploadId: string;
      /**
       * Format: uri
       * @description Pre-signed URL for uploading the file
       */
      uploadUrl: string;
      /**
       * Format: date-time
       * @description When the upload URL expires
       */
      expiresAt: string;
      /** @description Configuration for multipart uploads if file size requires it */
      multipart?: components['schemas']['MultipartConfig'];
      /** @description Headers the client must include when uploading to the pre-signed URL */
      requiredHeaders?: {
        [key: string]: string;
      };
    };
    /** @description Request to use an item instance by executing its behavior contract */
    UseItemRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the item instance to use
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Unique identifier of the entity using the item (character, account, or actor)
       */
      userId: string;
      /** @description Type of user entity performing the use action */
      userType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Optional unique identifier of the target entity for directional item effects
       */
      targetId?: string | null;
      /** @description Type of target entity when targetId is provided */
      targetType?: components['schemas']['EntityType'];
      /** @description Caller-provided context merged into contract gameMetadata for template value substitution. No Bannou plugin reads specific keys from this field by convention. */
      context?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response containing the result of an item use attempt */
    UseItemResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the item template defining the used item
       */
      templateId: string;
      /**
       * Format: uuid
       * @description Unique identifier of the contract instance created for this use (null if creation failed)
       */
      contractInstanceId?: string | null;
      /** @description Whether the item was consumed (quantity decremented or destroyed) */
      consumed: boolean;
      /**
       * Format: double
       * @description Remaining quantity after use (null if item was fully consumed or destroyed)
       */
      remainingQuantity?: number | null;
      /** @description Human-readable reason for failure when success is false */
      failureReason?: string | null;
    };
    /** @description Request to complete a step of a multi-step item use */
    UseItemStepRequest: {
      /**
       * Format: uuid
       * @description Item instance being used
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description User performing the step
       */
      userId: string;
      /** @description Type of user entity performing the step */
      userType: components['schemas']['EntityType'];
      /** @description Milestone code to complete in the use behavior contract */
      milestoneCode: string;
      /** @description Evidence data passed through to Contract milestone completion. No Bannou plugin reads specific keys from this field by convention. */
      evidence?: {
        [key: string]: unknown;
      } | null;
      /** @description Caller-provided context merged into contract gameMetadata for template value substitution. No Bannou plugin reads specific keys from this field by convention. */
      context?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response from completing a multi-step item use milestone */
    UseItemStepResponse: {
      /**
       * Format: uuid
       * @description Item instance ID
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Contract instance tracking this use session
       */
      contractInstanceId: string;
      /** @description The milestone that was completed */
      completedMilestone: string;
      /** @description Milestones still to be completed (null if complete or failed) */
      remainingMilestones?: string[] | null;
      /** @description Whether all required milestones are complete */
      isComplete: boolean;
      /** @description Whether item was consumed (only true when all steps complete per itemUseBehavior) */
      consumed: boolean;
      /** @description Human-readable reason for failure when success is false */
      failureReason?: string | null;
    };
    /** @description Request to validate ABML YAML content against schema and semantic rules */
    ValidateAbmlRequest: {
      /** @description Raw ABML YAML content to validate */
      abmlContent: string;
      /**
       * @description Enable strict validation mode with enhanced checking
       * @default false
       */
      strictMode: boolean;
    };
    /** @description Response containing the results of ABML validation including errors and warnings */
    ValidateAbmlResponse: {
      /** @description Whether the ABML definition is valid */
      isValid: boolean;
      /** @description List of validation errors if invalid */
      validationErrors?: components['schemas']['ValidationError'][] | null;
      /** @description Semantic warnings that don't prevent compilation */
      semanticWarnings?: string[] | null;
      /** @description ABML schema version used for validation */
      schemaVersion?: string | null;
    };
    /** @description Request to validate a deposit without executing */
    ValidateDepositRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Party to validate
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Assets to validate */
      assets: components['schemas']['EscrowAssetBundleInput'];
    };
    /** @description Response from deposit validation */
    ValidateDepositResponse: {
      /** @description Whether the deposit would be valid */
      valid: boolean;
      /** @description Validation errors */
      errors: string[];
      /** @description Validation warnings */
      warnings: string[];
    };
    /** @description Request to validate an existing GOAP plan against current world state */
    ValidateGoapPlanRequest: {
      /** @description The plan to validate */
      plan: components['schemas']['GoapPlanResult'];
      /** @description Index of the action currently being executed */
      currentActionIndex: number;
      /** @description Current world state */
      worldState: {
        [key: string]: unknown;
      };
      /** @description All active goals for priority checking */
      activeGoals?: components['schemas']['GoapGoal'][] | null;
    };
    /** @description Response indicating whether a GOAP plan is still valid and suggested next action */
    ValidateGoapPlanResponse: {
      /** @description Whether the plan is still valid */
      isValid: boolean;
      /**
       * @description Reason for the validation result
       * @enum {string}
       */
      reason:
        | 'none'
        | 'preconditionInvalidated'
        | 'actionFailed'
        | 'betterGoalAvailable'
        | 'planCompleted'
        | 'goalAlreadySatisfied'
        | 'suboptimalPlan';
      /**
       * @description Suggested action based on validation
       * @enum {string}
       */
      suggestedAction: 'continue' | 'replan' | 'abort';
      /** @description Index where plan became invalid (if applicable) */
      invalidatedAtIndex?: number;
      /** @description Additional details about the validation result. Null when no additional context is needed. */
      message?: string | null;
    };
    /** @description Request to validate MIDI-JSON structure */
    ValidateMidiJsonRequest: {
      /** @description MIDI-JSON structure to validate */
      midiJson: components['schemas']['MidiJson'];
      /**
       * @description Enable strict validation with additional checks
       * @default false
       */
      strictMode: boolean;
    };
    /** @description Response containing validation results */
    ValidateMidiJsonResponse: {
      /** @description Whether the MIDI-JSON is valid */
      isValid: boolean;
      /** @description Validation errors if invalid */
      errors?: components['schemas']['ValidationError'][] | null;
      /** @description Non-fatal warnings */
      warnings?: string[] | null;
    };
    /** @description Request to validate a scene structure */
    ValidateSceneRequest: {
      /** @description The scene to validate */
      scene: components['schemas']['Scene'];
      /**
       * @description Whether to apply registered game-specific validation rules
       * @default true
       */
      applyGameRules: boolean;
    };
    /** @description Request to validate a location against territory boundaries */
    ValidateTerritoryRequest: {
      /**
       * Format: uuid
       * @description The location to validate
       */
      locationId: string;
      /** @description Territory boundary location IDs */
      territoryLocationIds: string[];
      /** @description Validation mode (exclusive or inclusive). Defaults to exclusive. */
      territoryMode?: components['schemas']['TerritoryMode'] | null;
    };
    /** @description Territory validation result */
    ValidateTerritoryResponse: {
      /** @description True if location passes territory validation */
      isValid: boolean;
      /** @description Human-readable reason if validation failed */
      violationReason?: string | null;
      /**
       * Format: uuid
       * @description The territory location that matched (for inclusive) or conflicted (for exclusive)
       */
      matchedTerritoryId?: string | null;
    };
    /** @description Response from token validation containing associated account details. HTTP 200 confirms the token is valid; 401 indicates invalid or expired. */
    ValidateTokenResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the account associated with the token
       */
      accountId: string;
      /**
       * Format: uuid
       * @description Internal session key used by Connect service for WebSocket connection tracking and service routing
       */
      sessionKey: string;
      /** @description List of roles assigned to the authenticated user */
      roles?: string[] | null;
      /**
       * @description Authorization strings from active subscriptions.
       *     Format: "{stubName}:{state}" (e.g., "my-game:authorized")
       */
      authorizations?: string[] | null;
      /** @description Seconds until expiration */
      remainingTime: number;
    };
    /** @description A single condition to check against an API response */
    ValidationCondition: {
      /** @description The type of validation condition to check */
      type: components['schemas']['ValidationConditionType'];
      /** @description JsonPath expression to extract value from response (required for jsonPathEquals/Exists/NotExists, e.g. "$.balance") */
      jsonPath?: string | null;
      /** @description Expected value for comparison conditions with type coercion ("true"/"false" for booleans, numeric strings for numbers) */
      expectedValue?: string | null;
      /** @description Comparison operator for numeric comparisons */
      operator?: components['schemas']['ComparisonOperator'];
      /** @description HTTP status codes for statusCodeIn condition */
      statusCodes?: number[];
    };
    /**
     * @description Type of validation condition
     * @enum {string}
     */
    ValidationConditionType:
      | 'statusCodeIn'
      | 'jsonPathEquals'
      | 'jsonPathNotEquals'
      | 'jsonPathExists'
      | 'jsonPathNotExists'
      | 'jsonPathGreaterThan'
      | 'jsonPathLessThan'
      | 'jsonPathContains';
    /** @description Detailed validation error with type, location, and message information */
    ValidationError: {
      /**
       * @description Type of validation error
       * @enum {string}
       */
      type: 'syntax' | 'semantic' | 'schema' | 'context' | 'service_dependency';
      /** @description Human-readable error message */
      message: string;
      /** @description Line number where the error occurred (if applicable) */
      lineNumber?: number;
      /** @description Column number where the error occurred (if applicable) */
      columnNumber?: number;
      /**
       * @description YAML path to the problematic element
       * @example behaviors.morning_startup.actions[0]
       */
      yamlPath?: string | null;
    };
    /** @description Records a validation check failure */
    ValidationFailure: {
      /**
       * Format: date-time
       * @description When the failure was detected
       */
      detectedAt: string;
      /** @description Type of asset affected */
      assetType: components['schemas']['AssetType'];
      /** @description Description of the affected asset */
      assetDescription: string;
      /** @description Type of validation failure */
      failureType: components['schemas']['ValidationFailureType'];
      /**
       * Format: uuid
       * @description Which party deposit is affected
       */
      affectedPartyId: string;
      /** @description Type of the affected party */
      affectedPartyType: components['schemas']['EntityType'];
      /** @description Validation failure diagnostic details. No Bannou plugin reads specific keys from this field by convention. */
      details?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Type of validation failure detected.
     *     - asset_missing: Asset no longer exists in escrow custody
     *     - asset_mutated: Asset properties changed (e.g., item durability)
     *     - asset_expired: Asset has a time-based expiration that triggered
     *     - balance_mismatch: Wallet balance does not match expected held amount
     * @enum {string}
     */
    ValidationFailureType: 'asset_missing' | 'asset_mutated' | 'asset_expired' | 'balance_mismatch';
    /** @description Result of scene validation */
    ValidationResult: {
      /** @description Whether the scene passed all validation checks */
      valid: boolean;
      /** @description Validation errors (severity = error) */
      errors?: components['schemas']['ValidationError'][] | null;
      /** @description Validation warnings (severity = warning) */
      warnings?: components['schemas']['ValidationError'][] | null;
    };
    /** @description A validation rule definition */
    ValidationRule: {
      /** @description Unique rule identifier within the gameId+sceneType */
      ruleId: string;
      /** @description Human-readable description of the rule */
      description: string;
      /** @description Whether violation is an error or warning */
      severity: components['schemas']['ValidationSeverity'];
      /** @description Type of validation check */
      ruleType: components['schemas']['ValidationRuleType'];
      /** @description Rule-specific configuration */
      config?: components['schemas']['ValidationRuleConfig'];
    };
    /** @description Configuration for a validation rule */
    ValidationRuleConfig: {
      /** @description Filter to nodes of this type (for require_tag) */
      nodeType?: string | null;
      /** @description Tag to check for */
      tag?: string | null;
      /** @description Minimum occurrences required */
      minCount?: number | null;
      /** @description Maximum occurrences allowed */
      maxCount?: number | null;
      /** @description JSONPath to required annotation field (for require_annotation) */
      annotationPath?: string | null;
      /** @description Custom validation expression (for custom_expression) */
      expression?: string | null;
    };
    /**
     * @description Type of validation check to perform
     * @enum {string}
     */
    ValidationRuleType:
      | 'require_tag'
      | 'require_node_type'
      | 'forbid_tag'
      | 'require_annotation'
      | 'custom_expression';
    /**
     * @description Severity level of a validation issue
     * @enum {string}
     */
    ValidationSeverity: 'error' | 'warning';
    /** @description Validation rules applied to messages in rooms of this type */
    ValidatorConfig: {
      /** @description Maximum message length in characters for text and custom formats */
      maxMessageLength?: number | null;
      /** @description Regex pattern for content validation */
      allowedPattern?: string | null;
      /** @description Whitelist of allowed values (emoji codes, etc.) */
      allowedValues?: string[] | null;
      /** @description Required JSON fields for Custom format messages */
      requiredFields?: string[] | null;
      /** @description Full JSON Schema string for complex Custom format validation */
      jsonSchema?: string | null;
    };
    /** @description Three-dimensional spatial coordinates in garden space */
    Vec3: {
      /**
       * Format: float
       * @description X coordinate in garden space units
       */
      x: number;
      /**
       * Format: float
       * @description Y coordinate in garden space units
       */
      y: number;
      /**
       * Format: float
       * @description Z coordinate in garden space units
       */
      z: number;
    };
    /** @description A point or direction in 3D space */
    Vector3: {
      /**
       * Format: double
       * @description X coordinate
       */
      x: number;
      /**
       * Format: double
       * @description Y coordinate
       */
      y: number;
      /**
       * Format: double
       * @description Z coordinate
       */
      z: number;
    };
    /** @description Request to verify a condition for conditional escrow */
    VerifyConditionRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /** @description Whether the condition was met */
      conditionMet: boolean;
      /**
       * Format: uuid
       * @description Verifier entity ID
       */
      verifierId: string;
      /** @description Verifier entity type */
      verifierType: components['schemas']['EntityType'];
      /** @description Caller-provided proof/evidence data for condition verification. No Bannou plugin reads specific keys from this field by convention. */
      verificationData?: {
        [key: string]: unknown;
      } | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from verifying a condition on an escrow */
    VerifyConditionResponse: {
      /** @description Updated escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Whether this triggered release/refund */
      triggered: boolean;
    };
    /** @description Request to verify data integrity of a save version via hash comparison */
    VerifyIntegrityRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['EntityType'];
      /** @description Name of the slot to verify */
      slotName: string;
      /** @description Version to verify (latest if null) */
      versionNumber?: number | null;
    };
    /** @description Result of integrity verification with hash comparison details */
    VerifyIntegrityResponse: {
      /** @description Whether integrity check passed */
      valid: boolean;
      /** @description Version that was verified */
      versionNumber: number;
      /** @description Expected SHA-256 hash */
      expectedHash?: string;
      /** @description Actual hash (null if data unavailable) */
      actualHash?: string | null;
      /** @description Error details if verification failed */
      errorMessage?: string | null;
    };
    /** @description Information about a specific version */
    VersionInfo: {
      /** @description Version string */
      version: string;
      /**
       * Format: date-time
       * @description When this version was created
       */
      createdAt: string;
      /** @description Who created this version */
      createdBy?: string | null;
      /** @description Summary of changes */
      changesSummary?: string | null;
      /** @description Node count at this version */
      nodeCount?: number;
    };
    /** @description Metadata for a single save version including size and checkpoint info */
    VersionResponse: {
      /** @description Version number */
      versionNumber: number;
      /**
       * Format: uuid
       * @description Reference to asset in lib-asset
       */
      assetId?: string;
      /** @description SHA-256 hash */
      contentHash: string;
      /**
       * Format: int64
       * @description Size in bytes
       */
      sizeBytes: number;
      /**
       * Format: int64
       * @description Compressed size if applicable
       */
      compressedSizeBytes?: number;
      /** @description Schema version */
      schemaVersion?: string | null;
      /** @description Human-readable name */
      displayName?: string | null;
      /** @description Whether version is pinned */
      pinned?: boolean;
      /** @description Checkpoint name if pinned */
      checkpointName?: string | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /** @description Custom metadata */
      metadata?: {
        [key: string]: string;
      };
    };
    /** @description Record of a knowing obligation violation by a character */
    ViolationRecord: {
      /**
       * Format: uuid
       * @description Unique identifier for this violation record
       */
      violationId: string;
      /**
       * Format: uuid
       * @description Character who committed the violation
       */
      characterId: string;
      /**
       * Format: uuid
       * @description Contract that was violated
       */
      contractId: string;
      /** @description Code of the behavioral clause that was violated */
      clauseCode: string;
      /** @description Violation type code */
      violationType: string;
      /** @description GOAP action tag that triggered the violation */
      actionTag: string;
      /**
       * Format: float
       * @description Goal urgency that overrode the obligation (0.0-1.0)
       */
      motivationScore: number;
      /**
       * Format: float
       * @description Total violation cost that was accepted
       */
      violationCost: number;
      /** @description Whether a breach was filed with the contract service */
      breachReported: boolean;
      /**
       * Format: uuid
       * @description Breach record ID from contract service (null if breach not reported)
       */
      breachId?: string | null;
      /**
       * Format: uuid
       * @description Target entity of the violating action (null if no specific target)
       */
      targetEntityId?: string | null;
      /** @description Entity type of the target */
      targetEntityType?: components['schemas']['EntityType'];
      /**
       * Format: date-time
       * @description When the violation occurred
       */
      timestamp: string;
    };
    /** @description Request to apply voice leading to a chord sequence */
    VoiceLeadRequest: {
      /** @description Chord symbols to voice */
      chords: components['schemas']['ChordSymbol'][];
      /** @description Number of voices */
      voiceCount: number;
      /** @description Pitch range per voice (defaults based on voice count) */
      ranges?: components['schemas']['PitchRange'][] | null;
      /** @description Voice leading rules to apply */
      rules?: components['schemas']['VoiceLeadingRules'];
    };
    /** @description Response containing voiced chords */
    VoiceLeadResponse: {
      /** @description Voiced chord realizations */
      voicings: components['schemas']['VoicedChord'][];
      /** @description Voice leading rule violations (warnings) */
      violations?: components['schemas']['VoiceLeadingViolation'][] | null;
    };
    /** @description Rules for voice leading */
    VoiceLeadingRules: {
      /**
       * @description Avoid parallel perfect fifths
       * @default true
       */
      avoidParallelFifths: boolean;
      /**
       * @description Avoid parallel octaves
       * @default true
       */
      avoidParallelOctaves: boolean;
      /**
       * @description Prefer stepwise voice motion
       * @default true
       */
      preferStepwiseMotion: boolean;
      /**
       * @description Avoid voice crossing
       * @default true
       */
      avoidVoiceCrossing: boolean;
      /**
       * @description Maximum leap in semitones
       * @default 7
       */
      maxLeap: number;
    };
    /** @description A voice leading rule violation */
    VoiceLeadingViolation: {
      /** @description Type of violation */
      type: components['schemas']['VoiceLeadingViolationType'];
      /** @description Position in the progression (0-based) */
      position: number;
      /** @description Voice indices involved (0 = bass) */
      voices: number[];
      /** @description Severity (true = error, false = warning) */
      isError: boolean;
      /** @description Human-readable description */
      message: string;
    };
    /**
     * @description Type of voice leading rule violation
     * @enum {string}
     */
    VoiceLeadingViolationType:
      | 'ParallelFifths'
      | 'ParallelOctaves'
      | 'VoiceCrossing'
      | 'VoiceOverlap'
      | 'LargeLeap'
      | 'UnresolvedLeap'
      | 'DoubledLeadingTone';
    /** @description A chord with specific voice pitches */
    VoicedChord: {
      /** @description Original chord symbol */
      symbol: components['schemas']['ChordSymbol'];
      /** @description Pitches from lowest to highest voice */
      pitches: components['schemas']['Pitch'][];
    };
    /**
     * @description Shape of a volume node for spatial bounds
     * @enum {string}
     */
    VolumeShape: 'box' | 'sphere' | 'capsule' | 'cylinder';
    /** @description Wallet details */
    WalletResponse: {
      /**
       * Format: uuid
       * @description Unique wallet identifier
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Owner entity ID
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Realm ID
       */
      realmId?: string | null;
      /** @description Current wallet status */
      status: components['schemas']['WalletStatus'];
      /** @description Reason wallet was frozen */
      frozenReason?: string | null;
      /**
       * Format: date-time
       * @description When wallet was frozen
       */
      frozenAt?: string | null;
      /** @description Who froze the wallet */
      frozenBy?: string | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last transaction timestamp
       */
      lastActivityAt?: string | null;
    };
    /**
     * @description Current status of a wallet
     * @enum {string}
     */
    WalletStatus: 'active' | 'frozen' | 'closed';
    /** @description Wallet with all non-zero balances */
    WalletWithBalancesResponse: {
      /** @description Wallet details */
      wallet: components['schemas']['WalletResponse'];
      /** @description All non-zero balances in this wallet */
      balances: components['schemas']['BalanceSummary'][];
    };
    /** @description Information about an active regional watcher */
    WatcherInfo: {
      /**
       * Format: uuid
       * @description Unique identifier for this watcher instance
       */
      watcherId: string;
      /**
       * Format: uuid
       * @description Realm this watcher monitors
       */
      realmId: string;
      /** @description Type of watcher (e.g., "regional", "dungeon", "event") */
      watcherType: string;
      /**
       * Format: date-time
       * @description When this watcher was started
       */
      startedAt: string;
      /** @description Behavior document reference this watcher uses */
      behaviorRef?: string | null;
      /** @description Actor instance ID running this watcher's behavior */
      actorId?: string | null;
    };
    /**
     * @description How container weight propagates to parent
     * @enum {string}
     */
    WeightContribution: 'none' | 'self_only' | 'self_plus_contents';
    /**
     * @description Precision for weight values (consistent with CurrencyPrecision)
     * @enum {string}
     */
    WeightPrecision: 'integer' | 'decimal_1' | 'decimal_2' | 'decimal_3';
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  updateProfile: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateProfileRequest'];
      };
    };
    responses: {
      /** @description Profile updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AccountResponse'];
        };
      };
      /** @description Account not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updatePasswordHash: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdatePasswordRequest'];
      };
    };
    responses: {
      /** @description Password hash updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Account not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateMfa: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateMfaRequest'];
      };
    };
    responses: {
      /** @description MFA settings updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Account not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Concurrent modification detected */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateVerificationStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateVerificationRequest'];
      };
    };
    responses: {
      /** @description Verification status updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Account not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createAchievementDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateAchievementDefinitionRequest'];
      };
    };
    responses: {
      /** @description Achievement created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AchievementDefinitionResponse'];
        };
      };
      /** @description Achievement with this ID already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listAchievementDefinitions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListAchievementDefinitionsRequest'];
      };
    };
    responses: {
      /** @description Achievement definitions retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListAchievementDefinitionsResponse'];
        };
      };
    };
  };
  updateAchievementDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateAchievementDefinitionRequest'];
      };
    };
    responses: {
      /** @description Achievement updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AchievementDefinitionResponse'];
        };
      };
      /** @description Achievement not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteAchievementDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteAchievementDefinitionRequest'];
      };
    };
    responses: {
      /** @description Achievement deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Achievement not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAchievementProgress: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAchievementProgressRequest'];
      };
    };
    responses: {
      /** @description Progress retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AchievementProgressResponse'];
        };
      };
    };
  };
  listUnlockedAchievements: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListUnlockedAchievementsRequest'];
      };
    };
    responses: {
      /** @description Unlocked achievements retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListUnlockedAchievementsResponse'];
        };
      };
    };
  };
  CreateActorTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateActorTemplateRequest'];
      };
    };
    responses: {
      /** @description Template created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorTemplateResponse'];
        };
      };
    };
  };
  UpdateActorTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateActorTemplateRequest'];
      };
    };
    responses: {
      /** @description Template updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorTemplateResponse'];
        };
      };
    };
  };
  DeleteActorTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteActorTemplateRequest'];
      };
    };
    responses: {
      /** @description Template deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteActorTemplateResponse'];
        };
      };
    };
  };
  SpawnActor: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SpawnActorRequest'];
      };
    };
    responses: {
      /** @description Actor spawned successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorInstanceResponse'];
        };
      };
    };
  };
  StopActor: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StopActorRequest'];
      };
    };
    responses: {
      /** @description Actor stopped successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StopActorResponse'];
        };
      };
    };
  };
  BindActorCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BindActorCharacterRequest'];
      };
    };
    responses: {
      /** @description Actor bound to character successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorInstanceResponse'];
        };
      };
    };
  };
  CleanupByCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CleanupByCharacterRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CleanupByCharacterResponse'];
        };
      };
    };
  };
  InjectPerception: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InjectPerceptionRequest'];
      };
    };
    responses: {
      /** @description Perception injected successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InjectPerceptionResponse'];
        };
      };
    };
  };
  StartEncounter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StartEncounterRequest'];
      };
    };
    responses: {
      /** @description Encounter started successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StartEncounterResponse'];
        };
      };
    };
  };
  UpdateEncounterPhase: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateEncounterPhaseRequest'];
      };
    };
    responses: {
      /** @description Encounter phase updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateEncounterPhaseResponse'];
        };
      };
    };
  };
  EndEncounter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EndEncounterRequest'];
      };
    };
    responses: {
      /** @description Encounter ended successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EndEncounterResponse'];
        };
      };
    };
  };
  requestUpload: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UploadRequest'];
      };
    };
    responses: {
      /** @description Upload URL generated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UploadResponse'];
        };
      };
      /** @description Invalid request (filename, size, or content_type) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authenticated */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Insufficient permissions */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  completeUpload: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CompleteUploadRequest'];
      };
    };
    responses: {
      /** @description Asset created, processing started */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetMetadata'];
        };
      };
      /** @description Invalid upload_id or missing parts for multipart */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Upload session not found or expired */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAsset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAssetRequest'];
      };
    };
    responses: {
      /** @description Asset metadata with download URL */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetWithDownloadUrl'];
        };
      };
      /** @description Asset not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listAssetVersions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListVersionsRequest'];
      };
    };
    responses: {
      /** @description List of asset versions */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetVersionList'];
        };
      };
      /** @description Asset not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  searchAssets: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AssetSearchRequest'];
      };
    };
    responses: {
      /** @description Matching assets */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetSearchResult'];
        };
      };
    };
  };
  createBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle created immediately (small bundles) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateBundleResponse'];
        };
      };
      /** @description Bundle creation queued (large bundles) */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateBundleResponse'];
        };
      };
      /** @description Invalid asset_ids or bundle_id */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle manifest with download URL */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BundleWithDownloadUrl'];
        };
      };
      /** @description Bundle not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  requestBundleUpload: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BundleUploadRequest'];
      };
    };
    responses: {
      /** @description Upload URL generated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UploadResponse'];
        };
      };
      /** @description Invalid filename or size */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createMetabundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateMetabundleRequest'];
      };
    };
    responses: {
      /** @description Metabundle created or queued for creation */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateMetabundleResponse'];
        };
      };
      /** @description Invalid request or asset conflicts detected */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description One or more source bundles not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Metabundle ID already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getJobStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetJobStatusRequest'];
      };
    };
    responses: {
      /** @description Job status retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetJobStatusResponse'];
        };
      };
      /** @description Job not found or expired */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cancelJob: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CancelJobRequest'];
      };
    };
    responses: {
      /** @description Job cancellation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CancelJobResponse'];
        };
      };
      /** @description Job not found or expired */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Job cannot be cancelled (already completed) */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  resolveBundles: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResolveBundlesRequest'];
      };
    };
    responses: {
      /** @description Resolution complete with download URLs */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ResolveBundlesResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryBundlesByAsset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBundlesByAssetRequest'];
      };
    };
    responses: {
      /** @description Bundles containing the asset */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryBundlesByAssetResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateBundleResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to update this bundle */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle not found or deleted */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteBundleResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to delete this bundle */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  restoreBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RestoreBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle restored successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RestoreBundleResponse'];
        };
      };
      /** @description Invalid request or bundle not in deleted state */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to restore this bundle */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle not found or permanently deleted */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle retention period has expired */
      410: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryBundles: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBundlesRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryBundlesResponse'];
        };
      };
      /** @description Invalid query parameters */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listBundleVersions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListBundleVersionsRequest'];
      };
    };
    responses: {
      /** @description Version history */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListBundleVersionsResponse'];
        };
      };
      /** @description Bundle not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  bulkGetAssets: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BulkGetAssetsRequest'];
      };
    };
    responses: {
      /** @description Asset metadata retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BulkGetAssetsResponse'];
        };
      };
      /** @description Invalid request or too many asset IDs */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  login: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LoginRequest'];
      };
    };
    responses: {
      /** @description Login successful or MFA challenge issued */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LoginResponse'];
        };
      };
      /** @description Invalid credentials */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many login attempts */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  register: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterRequest'];
      };
    };
    responses: {
      /** @description Registration successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RegisterResponse'];
        };
      };
      /** @description Invalid request data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Username already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  initOAuth: {
    parameters: {
      query: {
        redirectUri: string;
        state?: string;
      };
      header?: never;
      path: {
        provider: components['schemas']['Provider'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Redirect to OAuth provider */
      302: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  completeOAuth: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        provider: components['schemas']['Provider'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OAuthCallbackRequest'];
      };
    };
    responses: {
      /** @description OAuth authentication successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthResponse'];
        };
      };
    };
  };
  verifySteamAuth: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SteamVerifyRequest'];
      };
    };
    responses: {
      /** @description Steam authentication successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthResponse'];
        };
      };
      /** @description Invalid or expired Steam ticket */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Steam API unavailable or internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  refreshToken: {
    parameters: {
      query?: never;
      header: {
        /** @description Current JWT access token for refresh */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RefreshRequest'];
      };
    };
    responses: {
      /** @description Token refreshed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthResponse'];
        };
      };
    };
  };
  validateToken: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token for validation */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Token is valid */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateTokenResponse'];
        };
      };
      /** @description Invalid or missing token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Token expired or malformed */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  logout: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token for session identification */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['LogoutRequest'];
      };
    };
    responses: {
      /** @description Logged out successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSessions: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token for session identification */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Active sessions retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SessionsResponse'];
        };
      };
    };
  };
  terminateSession: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token for session identification */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TerminateSessionRequest'];
      };
    };
    responses: {
      /** @description Session terminated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  requestPasswordReset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PasswordResetRequest'];
      };
    };
    responses: {
      /** @description Reset email sent if account exists */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  confirmPasswordReset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PasswordResetConfirmRequest'];
      };
    };
    responses: {
      /** @description Password reset successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listProviders: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of available providers */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ProvidersResponse'];
        };
      };
    };
  };
  setupMfa: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description MFA setup initiated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MfaSetupResponse'];
        };
      };
      /** @description MFA already enabled for this account */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  enableMfa: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaEnableRequest'];
      };
    };
    responses: {
      /** @description MFA enabled successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Invalid TOTP code or expired setup token */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description MFA already enabled */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  disableMfa: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaDisableRequest'];
      };
    };
    responses: {
      /** @description MFA disabled successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Invalid TOTP code or recovery code */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description MFA not enabled for this account */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  verifyMfa: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MfaVerifyRequest'];
      };
    };
    responses: {
      /** @description MFA verified, tokens issued */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthResponse'];
        };
      };
      /** @description Invalid TOTP code or recovery code */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Challenge token not found, expired, or already used */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CompileAbmlBehavior: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        /**
         * @example version: "1.0.0"
         *     metadata:
         *       id: "blacksmith_daily_routine"
         *       category: "profession"
         *       priority: 60
         *       description: "Daily routine for a master blacksmith NPC"
         *
         *     context:
         *       variables:
         *         energy_level: "${npc.stats.energy}"
         *         skill_level: "${npc.skills.blacksmithing}"
         *         shop_reputation: "${npc.reputation.local}"
         *
         *       services:
         *         - name: "crafting_service"
         *           required: true
         *         - name: "economy_service"
         *           required: true
         *
         *     behaviors:
         *       morning_startup:
         *         triggers:
         *           - time_range: "06:00-09:00"
         *           - condition: "${context.energy_level > 0.7}"
         *         actions:
         *           - wake_up:
         *               animation: "stretch_and_yawn"
         *               duration: 3
         *               energy_cost: -0.05
         */
        'application/yaml': string;
        'application/json': components['schemas']['CompileBehaviorRequest'];
      };
    };
    responses: {
      /** @description ABML behavior compiled successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CompileBehaviorResponse'];
        };
      };
      /** @description Invalid ABML definition or compilation error */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden - insufficient permissions */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ValidateAbml: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/yaml': string;
        'application/json': components['schemas']['ValidateAbmlRequest'];
      };
    };
    responses: {
      /** @description Validation completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateAbmlResponse'];
        };
      };
    };
  };
  GetCachedBehavior: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCachedBehaviorRequest'];
      };
    };
    responses: {
      /** @description Cached behavior retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CachedBehaviorResponse'];
        };
      };
      /** @description Behavior not found in cache */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  InvalidateCachedBehavior: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InvalidateCacheRequest'];
      };
    };
    responses: {
      /** @description Cache invalidated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Behavior not found in cache */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GenerateGoapPlan: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoapPlanRequest'];
      };
    };
    responses: {
      /** @description Plan generated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GoapPlanResponse'];
        };
      };
      /** @description Invalid request or planning failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ValidateGoapPlan: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidateGoapPlanRequest'];
      };
    };
    responses: {
      /** @description Plan validation completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateGoapPlanResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCharacterRequest'];
      };
    };
    responses: {
      /** @description Character retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterResponse'];
        };
      };
      /** @description Character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listCharacters: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListCharactersRequest'];
      };
    };
    responses: {
      /** @description Characters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterListResponse'];
        };
      };
    };
  };
  getEnrichedCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEnrichedCharacterRequest'];
      };
    };
    responses: {
      /** @description Character retrieved with requested includes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EnrichedCharacterResponse'];
        };
      };
      /** @description Character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCharacterArchive: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCharacterArchiveRequest'];
      };
    };
    responses: {
      /** @description Archive retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterArchive'];
        };
      };
      /** @description Archive not found (character may not be compressed yet) */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCharactersByRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCharactersByRealmRequest'];
      };
    };
    responses: {
      /** @description Characters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterListResponse'];
        };
      };
    };
  };
  getCompressData: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCompressDataRequest'];
      };
    };
    responses: {
      /** @description Character base data returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterBaseArchive'];
        };
      };
      /** @description Character is not dead (cannot compress alive characters) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getEncounterType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEncounterTypeRequest'];
      };
    };
    responses: {
      /** @description Encounter type retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterTypeResponse'];
        };
      };
      /** @description Encounter type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listEncounterTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListEncounterTypesRequest'];
      };
    };
    responses: {
      /** @description Encounter types retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterTypeListResponse'];
        };
      };
    };
  };
  queryByCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryByCharacterRequest'];
      };
    };
    responses: {
      /** @description Encounters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterListResponse'];
        };
      };
    };
  };
  queryBetween: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBetweenRequest'];
      };
    };
    responses: {
      /** @description Encounters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterListResponse'];
        };
      };
    };
  };
  queryByLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryByLocationRequest'];
      };
    };
    responses: {
      /** @description Encounters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterListResponse'];
        };
      };
    };
  };
  hasMet: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HasMetRequest'];
      };
    };
    responses: {
      /** @description Check completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HasMetResponse'];
        };
      };
    };
  };
  getSentiment: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSentimentRequest'];
      };
    };
    responses: {
      /** @description Sentiment calculated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SentimentResponse'];
        };
      };
    };
  };
  getPerspective: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetPerspectiveRequest'];
      };
    };
    responses: {
      /** @description Perspective retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PerspectiveResponse'];
        };
      };
      /** @description Perspective not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCompressData: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCompressDataRequest'];
      };
    };
    responses: {
      /** @description Compressed data returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterEncounterArchive'];
        };
      };
      /** @description No encounter data for character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getParticipation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetParticipationRequest'];
      };
    };
    responses: {
      /** @description Participation records retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ParticipationListResponse'];
        };
      };
    };
  };
  getEventParticipants: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEventParticipantsRequest'];
      };
    };
    responses: {
      /** @description Participants retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ParticipationListResponse'];
        };
      };
    };
  };
  getBackstory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBackstoryRequest'];
      };
    };
    responses: {
      /** @description Backstory retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BackstoryResponse'];
        };
      };
      /** @description No backstory defined for this character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCompressData: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCompressDataRequest'];
      };
    };
    responses: {
      /** @description Compressed data returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterHistoryArchive'];
        };
      };
      /** @description No history data for character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getPersonality: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetPersonalityRequest'];
      };
    };
    responses: {
      /** @description Personality retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PersonalityResponse'];
        };
      };
      /** @description No personality defined for this character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCombatPreferences: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCombatPreferencesRequest'];
      };
    };
    responses: {
      /** @description Combat preferences retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CombatPreferencesResponse'];
        };
      };
      /** @description No combat preferences defined for this character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCompressData: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCompressDataRequest'];
      };
    };
    responses: {
      /** @description Compressed data returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterPersonalityArchive'];
        };
      };
      /** @description No personality data for character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cleanupByCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CleanupByCharacterRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CleanupByCharacterResponse'];
        };
      };
    };
  };
  RegisterRoomType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterRoomTypeRequest'];
      };
    };
    responses: {
      /** @description Room type registered successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RoomTypeResponse'];
        };
      };
    };
  };
  GetRoomType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRoomTypeRequest'];
      };
    };
    responses: {
      /** @description Room type found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RoomTypeResponse'];
        };
      };
    };
  };
  ListRoomTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRoomTypesRequest'];
      };
    };
    responses: {
      /** @description Room types returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListRoomTypesResponse'];
        };
      };
    };
  };
  UpdateRoomType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateRoomTypeRequest'];
      };
    };
    responses: {
      /** @description Room type updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RoomTypeResponse'];
        };
      };
    };
  };
  DeprecateRoomType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeprecateRoomTypeRequest'];
      };
    };
    responses: {
      /** @description Room type deprecated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RoomTypeResponse'];
        };
      };
    };
  };
  CreateRoom: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateRoomRequest'];
      };
    };
    responses: {
      /** @description Room created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatRoomResponse'];
        };
      };
    };
  };
  GetRoom: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRoomRequest'];
      };
    };
    responses: {
      /** @description Room found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatRoomResponse'];
        };
      };
    };
  };
  ListRooms: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRoomsRequest'];
      };
    };
    responses: {
      /** @description Rooms returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListRoomsResponse'];
        };
      };
    };
  };
  UpdateRoom: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateRoomRequest'];
      };
    };
    responses: {
      /** @description Room updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatRoomResponse'];
        };
      };
    };
  };
  DeleteRoom: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteRoomRequest'];
      };
    };
    responses: {
      /** @description Room deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatRoomResponse'];
        };
      };
    };
  };
  ArchiveRoom: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ArchiveRoomRequest'];
      };
    };
    responses: {
      /** @description Room archived */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatRoomResponse'];
        };
      };
    };
  };
  JoinRoom: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['JoinRoomRequest'];
      };
    };
    responses: {
      /** @description Joined room */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatRoomResponse'];
        };
      };
    };
  };
  LeaveRoom: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveRoomRequest'];
      };
    };
    responses: {
      /** @description Left room */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatRoomResponse'];
        };
      };
    };
  };
  ListParticipants: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListParticipantsRequest'];
      };
    };
    responses: {
      /** @description Participants returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ParticipantsResponse'];
        };
      };
    };
  };
  KickParticipant: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['KickParticipantRequest'];
      };
    };
    responses: {
      /** @description Participant kicked */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatRoomResponse'];
        };
      };
    };
  };
  BanParticipant: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BanParticipantRequest'];
      };
    };
    responses: {
      /** @description Participant banned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatRoomResponse'];
        };
      };
    };
  };
  UnbanParticipant: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnbanParticipantRequest'];
      };
    };
    responses: {
      /** @description Participant unbanned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatRoomResponse'];
        };
      };
    };
  };
  MuteParticipant: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MuteParticipantRequest'];
      };
    };
    responses: {
      /** @description Participant muted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatRoomResponse'];
        };
      };
    };
  };
  SendMessage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SendMessageRequest'];
      };
    };
    responses: {
      /** @description Message sent */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatMessageResponse'];
        };
      };
    };
  };
  SendMessageBatch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SendMessageBatchRequest'];
      };
    };
    responses: {
      /** @description Messages sent */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SendMessageBatchResponse'];
        };
      };
    };
  };
  GetMessageHistory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MessageHistoryRequest'];
      };
    };
    responses: {
      /** @description Messages returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MessageHistoryResponse'];
        };
      };
    };
  };
  DeleteMessage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteMessageRequest'];
      };
    };
    responses: {
      /** @description Message deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatMessageResponse'];
        };
      };
    };
  };
  PinMessage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PinMessageRequest'];
      };
    };
    responses: {
      /** @description Message pinned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatMessageResponse'];
        };
      };
    };
  };
  UnpinMessage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnpinMessageRequest'];
      };
    };
    responses: {
      /** @description Message unpinned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ChatMessageResponse'];
        };
      };
    };
  };
  SearchMessages: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SearchMessagesRequest'];
      };
    };
    responses: {
      /** @description Search results returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SearchMessagesResponse'];
        };
      };
    };
  };
  AdminListRooms: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AdminListRoomsRequest'];
      };
    };
    responses: {
      /** @description Rooms returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListRoomsResponse'];
        };
      };
    };
  };
  AdminGetStats: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AdminGetStatsRequest'];
      };
    };
    responses: {
      /** @description Statistics returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AdminStatsResponse'];
        };
      };
    };
  };
  AdminForceCleanup: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AdminForceCleanupRequest'];
      };
    };
    responses: {
      /** @description Cleanup executed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AdminCleanupResponse'];
        };
      };
    };
  };
  createEntryTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateEntryTemplateRequest'];
      };
    };
    responses: {
      /** @description Entry template created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EntryTemplateResponse'];
        };
      };
      /** @description Invalid request (validation error) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Referenced game service or item template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Duplicate code for this collection type and game service */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getEntryTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEntryTemplateRequest'];
      };
    };
    responses: {
      /** @description Entry template retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EntryTemplateResponse'];
        };
      };
      /** @description Entry template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listEntryTemplates: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListEntryTemplatesRequest'];
      };
    };
    responses: {
      /** @description Entry templates retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListEntryTemplatesResponse'];
        };
      };
    };
  };
  updateEntryTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateEntryTemplateRequest'];
      };
    };
    responses: {
      /** @description Entry template updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EntryTemplateResponse'];
        };
      };
      /** @description Entry template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteEntryTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteEntryTemplateRequest'];
      };
    };
    responses: {
      /** @description Entry template deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EntryTemplateResponse'];
        };
      };
      /** @description Entry template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  seedEntryTemplates: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SeedEntryTemplatesRequest'];
      };
    };
    responses: {
      /** @description Seed completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedEntryTemplatesResponse'];
        };
      };
      /** @description Invalid request (validation errors) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createCollection: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateCollectionRequest'];
      };
    };
    responses: {
      /** @description Collection created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CollectionResponse'];
        };
      };
      /** @description Referenced game service not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Duplicate collection type for this owner and game service, or max collections exceeded */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCollection: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCollectionRequest'];
      };
    };
    responses: {
      /** @description Collection retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CollectionResponse'];
        };
      };
      /** @description Collection not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listCollections: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListCollectionsRequest'];
      };
    };
    responses: {
      /** @description Collections retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListCollectionsResponse'];
        };
      };
    };
  };
  deleteCollection: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteCollectionRequest'];
      };
    };
    responses: {
      /** @description Collection deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CollectionResponse'];
        };
      };
      /** @description Collection not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  grantEntry: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GrantEntryRequest'];
      };
    };
    responses: {
      /** @description Entry granted (or already unlocked) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GrantEntryResponse'];
        };
      };
      /** @description Entry template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Max entries reached or item creation failed */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  hasEntry: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HasEntryRequest'];
      };
    };
    responses: {
      /** @description Check completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HasEntryResponse'];
        };
      };
    };
  };
  queryEntries: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryEntriesRequest'];
      };
    };
    responses: {
      /** @description Entries retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryEntriesResponse'];
        };
      };
      /** @description Collection not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateEntryMetadata: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateEntryMetadataRequest'];
      };
    };
    responses: {
      /** @description Metadata updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UnlockedEntryResponse'];
        };
      };
      /** @description Collection or entry not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCompletionStats: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCompletionStatsRequest'];
      };
    };
    responses: {
      /** @description Statistics retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CompletionStatsResponse'];
        };
      };
      /** @description Collection not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  selectContentForArea: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SelectContentForAreaRequest'];
      };
    };
    responses: {
      /** @description Content selected successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContentSelectionResponse'];
        };
      };
      /** @description Area config not found or no matching collection exists */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  setAreaContentConfig: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SetAreaContentConfigRequest'];
      };
    };
    responses: {
      /** @description Area content config saved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AreaContentConfigResponse'];
        };
      };
      /** @description Game service or default entry template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAreaContentConfig: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAreaContentConfigRequest'];
      };
    };
    responses: {
      /** @description Area content config retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AreaContentConfigResponse'];
        };
      };
      /** @description Area content config not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listAreaContentConfigs: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListAreaContentConfigsRequest'];
      };
    };
    responses: {
      /** @description Area content configs retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListAreaContentConfigsResponse'];
        };
      };
    };
  };
  advanceDiscovery: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AdvanceDiscoveryRequest'];
      };
    };
    responses: {
      /** @description Discovery level advanced */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AdvanceDiscoveryResponse'];
        };
      };
      /** @description Collection or entry not found, or entry not unlocked */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Already at max discovery level */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cleanupByCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CleanupByCharacterRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CleanupByCharacterResponse'];
        };
      };
    };
  };
  getClientCapabilities: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetClientCapabilitiesRequest'];
      };
    };
    responses: {
      /** @description Client capabilities retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClientCapabilitiesResponse'];
        };
      };
      /** @description Not authenticated - requires valid session */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error retrieving capabilities */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getContractTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetContractTemplateRequest'];
      };
    };
    responses: {
      /** @description Template retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractTemplateResponse'];
        };
      };
      /** @description Neither templateId nor code provided */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listContractTemplates: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListContractTemplatesRequest'];
      };
    };
    responses: {
      /** @description Templates retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListContractTemplatesResponse'];
        };
      };
    };
  };
  createContractInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateContractInstanceRequest'];
      };
    };
    responses: {
      /** @description Instance created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractInstanceResponse'];
        };
      };
      /** @description Invalid request (missing required parties, invalid terms) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  proposeContractInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ProposeContractInstanceRequest'];
      };
    };
    responses: {
      /** @description Contract proposed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractInstanceResponse'];
        };
      };
      /** @description Contract not in draft status */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  consentToContract: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConsentToContractRequest'];
      };
    };
    responses: {
      /** @description Consent recorded successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractInstanceResponse'];
        };
      };
      /** @description Party not part of this contract or already consented */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getContractInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetContractInstanceRequest'];
      };
    };
    responses: {
      /** @description Instance retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractInstanceResponse'];
        };
      };
      /** @description Instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryContractInstances: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryContractInstancesRequest'];
      };
    };
    responses: {
      /** @description Instances retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryContractInstancesResponse'];
        };
      };
      /** @description No filter criteria provided */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  terminateContractInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TerminateContractInstanceRequest'];
      };
    };
    responses: {
      /** @description Termination processed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractInstanceResponse'];
        };
      };
      /** @description Contract cannot be terminated (policy violation) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getContractInstanceStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetContractInstanceStatusRequest'];
      };
    };
    responses: {
      /** @description Status retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractInstanceStatusResponse'];
        };
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  completeMilestone: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CompleteMilestoneRequest'];
      };
    };
    responses: {
      /** @description Milestone completed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MilestoneResponse'];
        };
      };
      /** @description Milestone not in valid state for completion */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract or milestone not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  failMilestone: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FailMilestoneRequest'];
      };
    };
    responses: {
      /** @description Milestone failure recorded */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MilestoneResponse'];
        };
      };
      /** @description Milestone not in valid state for failure */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract or milestone not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getMilestone: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetMilestoneRequest'];
      };
    };
    responses: {
      /** @description Milestone retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MilestoneResponse'];
        };
      };
      /** @description Contract or milestone not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  reportBreach: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReportBreachRequest'];
      };
    };
    responses: {
      /** @description Breach reported successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BreachResponse'];
        };
      };
      /** @description Invalid breach report */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cureBreach: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CureBreachRequest'];
      };
    };
    responses: {
      /** @description Breach cured successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BreachResponse'];
        };
      };
      /** @description Breach not in curable state */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Breach not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBreach: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBreachRequest'];
      };
    };
    responses: {
      /** @description Breach retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BreachResponse'];
        };
      };
      /** @description Breach not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateContractMetadata: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateContractMetadataRequest'];
      };
    };
    responses: {
      /** @description Metadata updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractMetadataResponse'];
        };
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getContractMetadata: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetContractMetadataRequest'];
      };
    };
    responses: {
      /** @description Metadata retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractMetadataResponse'];
        };
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  checkContractConstraint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckConstraintRequest'];
      };
    };
    responses: {
      /** @description Constraint check completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CheckConstraintResponse'];
        };
      };
    };
  };
  queryActiveContracts: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryActiveContractsRequest'];
      };
    };
    responses: {
      /** @description Active contracts retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryActiveContractsResponse'];
        };
      };
    };
  };
  lockContract: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LockContractRequest'];
      };
    };
    responses: {
      /** @description Contract locked successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LockContractResponse'];
        };
      };
      /** @description Contract not transferable */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract already locked */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  unlockContract: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnlockContractRequest'];
      };
    };
    responses: {
      /** @description Contract unlocked successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UnlockContractResponse'];
        };
      };
      /** @description Not the current guardian */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found or not locked */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  transferContractParty: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransferContractPartyRequest'];
      };
    };
    responses: {
      /** @description Party transferred successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TransferContractPartyResponse'];
        };
      };
      /** @description Party not found in contract */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not the current guardian or contract not locked */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listClauseTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListClauseTypesRequest'];
      };
    };
    responses: {
      /** @description Clause types listed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListClauseTypesResponse'];
        };
      };
    };
  };
  setContractTemplateValues: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SetTemplateValuesRequest'];
      };
    };
    responses: {
      /** @description Template values set successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SetTemplateValuesResponse'];
        };
      };
      /** @description Invalid template key format */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  checkAssetRequirements: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckAssetRequirementsRequest'];
      };
    };
    responses: {
      /** @description Asset requirements checked */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CheckAssetRequirementsResponse'];
        };
      };
      /** @description Template values not set */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  executeContract: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExecuteContractRequest'];
      };
    };
    responses: {
      /** @description Contract executed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExecuteContractResponse'];
        };
      };
      /** @description Contract not in fulfilled status or template values missing */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCurrencyDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCurrencyDefinitionRequest'];
      };
    };
    responses: {
      /** @description Currency definition retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CurrencyDefinitionResponse'];
        };
      };
      /** @description Neither definitionId nor code provided */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Currency definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listCurrencyDefinitions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListCurrencyDefinitionsRequest'];
      };
    };
    responses: {
      /** @description Currency definitions retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListCurrencyDefinitionsResponse'];
        };
      };
    };
  };
  createWallet: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateWalletRequest'];
      };
    };
    responses: {
      /** @description Wallet created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WalletResponse'];
        };
      };
      /** @description Wallet already exists for this owner/realm */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getWallet: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetWalletRequest'];
      };
    };
    responses: {
      /** @description Wallet retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WalletWithBalancesResponse'];
        };
      };
      /** @description Wallet not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getOrCreateWallet: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetOrCreateWalletRequest'];
      };
    };
    responses: {
      /** @description Wallet retrieved or created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetOrCreateWalletResponse'];
        };
      };
    };
  };
  getBalance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBalanceRequest'];
      };
    };
    responses: {
      /** @description Balance retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetBalanceResponse'];
        };
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  batchGetBalances: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BatchGetBalancesRequest'];
      };
    };
    responses: {
      /** @description Balances retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BatchGetBalancesResponse'];
        };
      };
    };
  };
  creditCurrency: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreditCurrencyRequest'];
      };
    };
    responses: {
      /** @description Currency credited successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreditCurrencyResponse'];
        };
      };
      /** @description Invalid transaction type or amount */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Idempotency key already used */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Earn cap or supply cap exceeded */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  debitCurrency: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DebitCurrencyRequest'];
      };
    };
    responses: {
      /** @description Currency debited successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DebitCurrencyResponse'];
        };
      };
      /** @description Invalid transaction type or amount */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Insufficient funds */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  transferCurrency: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransferCurrencyRequest'];
      };
    };
    responses: {
      /** @description Transfer completed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TransferCurrencyResponse'];
        };
      };
      /** @description Invalid request or currency not transferable */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Insufficient funds or cross-realm not allowed */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  batchCreditCurrency: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BatchCreditRequest'];
      };
    };
    responses: {
      /** @description Batch credit processed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BatchCreditResponse'];
        };
      };
    };
  };
  batchDebitCurrency: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BatchDebitRequest'];
      };
    };
    responses: {
      /** @description Batch debit processed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BatchDebitResponse'];
        };
      };
    };
  };
  calculateConversion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CalculateConversionRequest'];
      };
    };
    responses: {
      /** @description Conversion calculated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CalculateConversionResponse'];
        };
      };
      /** @description Currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description No base currency or missing exchange rate */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  executeConversion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExecuteConversionRequest'];
      };
    };
    responses: {
      /** @description Conversion executed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExecuteConversionResponse'];
        };
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Insufficient funds or missing exchange rate */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getExchangeRate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetExchangeRateRequest'];
      };
    };
    responses: {
      /** @description Exchange rate retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetExchangeRateResponse'];
        };
      };
      /** @description Currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description No base currency or missing exchange rate */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTransaction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetTransactionRequest'];
      };
    };
    responses: {
      /** @description Transaction retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TransactionResponse'];
        };
      };
      /** @description Transaction not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTransactionHistory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetTransactionHistoryRequest'];
      };
    };
    responses: {
      /** @description Transaction history retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetTransactionHistoryResponse'];
        };
      };
      /** @description Wallet not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTransactionsByReference: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetTransactionsByReferenceRequest'];
      };
    };
    responses: {
      /** @description Transactions retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetTransactionsByReferenceResponse'];
        };
      };
    };
  };
  getGlobalSupply: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetGlobalSupplyRequest'];
      };
    };
    responses: {
      /** @description Supply statistics retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetGlobalSupplyResponse'];
        };
      };
      /** @description Currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  escrowDeposit: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EscrowDepositRequest'];
      };
    };
    responses: {
      /** @description Escrow deposit processed (wallet debited) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EscrowDepositResponse'];
        };
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Insufficient funds or wallet frozen */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  escrowRelease: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EscrowReleaseRequest'];
      };
    };
    responses: {
      /** @description Escrow release processed (recipient credited) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EscrowReleaseResponse'];
        };
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  escrowRefund: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EscrowRefundRequest'];
      };
    };
    responses: {
      /** @description Escrow refund processed (depositor credited) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EscrowRefundResponse'];
        };
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createHold: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateHoldRequest'];
      };
    };
    responses: {
      /** @description Hold created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HoldResponse'];
        };
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Insufficient effective balance for hold */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  captureHold: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CaptureHoldRequest'];
      };
    };
    responses: {
      /** @description Hold captured successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CaptureHoldResponse'];
        };
      };
      /** @description Hold is not in active status or capture amount exceeds hold */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Hold not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  releaseHold: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReleaseHoldRequest'];
      };
    };
    responses: {
      /** @description Hold released successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HoldResponse'];
        };
      };
      /** @description Hold is not in active status */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Hold not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getHold: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetHoldRequest'];
      };
    };
    responses: {
      /** @description Hold retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HoldResponse'];
        };
      };
      /** @description Hold not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createDeity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateDeityRequest'];
      };
    };
    responses: {
      /** @description Deity created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeityResponse'];
        };
      };
      /** @description Game service not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Deity with this code already exists for this game service */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDeity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetDeityRequest'];
      };
    };
    responses: {
      /** @description Deity found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeityResponse'];
        };
      };
      /** @description Deity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDeityByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetDeityByCodeRequest'];
      };
    };
    responses: {
      /** @description Deity found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeityResponse'];
        };
      };
      /** @description Deity not found for this game service and code */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listDeities: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListDeitiesRequest'];
      };
    };
    responses: {
      /** @description Deities listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListDeitiesResponse'];
        };
      };
    };
  };
  updateDeity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateDeityRequest'];
      };
    };
    responses: {
      /** @description Deity updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeityResponse'];
        };
      };
      /** @description Deity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Concurrent modification conflict */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  activateDeity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ActivateDeityRequest'];
      };
    };
    responses: {
      /** @description Deity activated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeityResponse'];
        };
      };
      /** @description Deity is already active */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Deity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deactivateDeity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeactivateDeityRequest'];
      };
    };
    responses: {
      /** @description Deity deactivated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeityResponse'];
        };
      };
      /** @description Deity is already dormant or archived */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Deity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteDeity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteDeityRequest'];
      };
    };
    responses: {
      /** @description Deity deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Deity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDivinityBalance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetDivinityBalanceRequest'];
      };
    };
    responses: {
      /** @description Balance retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DivinityBalanceResponse'];
        };
      };
      /** @description Deity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  creditDivinity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreditDivinityRequest'];
      };
    };
    responses: {
      /** @description Divinity credited */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DivinityBalanceResponse'];
        };
      };
      /** @description Deity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  debitDivinity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DebitDivinityRequest'];
      };
    };
    responses: {
      /** @description Divinity debited */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DivinityBalanceResponse'];
        };
      };
      /** @description Insufficient divinity balance */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Deity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDivinityHistory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetDivinityHistoryRequest'];
      };
    };
    responses: {
      /** @description History retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DivinityHistoryResponse'];
        };
      };
      /** @description Deity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  grantBlessing: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GrantBlessingRequest'];
      };
    };
    responses: {
      /** @description Blessing granted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BlessingResponse'];
        };
      };
      /** @description Deity is not active or insufficient divinity */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Deity or target entity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Entity has reached maximum active blessings */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  revokeBlessing: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RevokeBlessingRequest'];
      };
    };
    responses: {
      /** @description Blessing revoked */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BlessingResponse'];
        };
      };
      /** @description Blessing is already revoked */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Blessing not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listBlessingsByEntity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListBlessingsByEntityRequest'];
      };
    };
    responses: {
      /** @description Blessings listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListBlessingsResponse'];
        };
      };
    };
  };
  listBlessingsByDeity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListBlessingsByDeityRequest'];
      };
    };
    responses: {
      /** @description Blessings listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListBlessingsResponse'];
        };
      };
    };
  };
  getBlessing: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBlessingRequest'];
      };
    };
    responses: {
      /** @description Blessing found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BlessingResponse'];
        };
      };
      /** @description Blessing not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  registerFollower: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterFollowerRequest'];
      };
    };
    responses: {
      /** @description Follower registered */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FollowerResponse'];
        };
      };
      /** @description Deity or character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Character is already a follower of this deity */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  unregisterFollower: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnregisterFollowerRequest'];
      };
    };
    responses: {
      /** @description Follower unregistered */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Deity, character, or follower relationship not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getFollowers: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetFollowersRequest'];
      };
    };
    responses: {
      /** @description Followers listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListFollowersResponse'];
        };
      };
      /** @description Deity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cleanupByCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CleanupByCharacterRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cleanupByGameService: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CleanupByGameServiceRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryDocumentation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryDocumentationRequest'];
      };
    };
    responses: {
      /** @description Search results with voice-friendly summaries */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryDocumentationResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDocument: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetDocumentRequest'];
      };
    };
    responses: {
      /** @description Document content */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetDocumentResponse'];
        };
      };
      /** @description Document not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  searchDocumentation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SearchDocumentationRequest'];
      };
    };
    responses: {
      /** @description Matching documents */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SearchDocumentationResponse'];
        };
      };
    };
  };
  listDocuments: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListDocumentsRequest'];
      };
    };
    responses: {
      /** @description Document list */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListDocumentsResponse'];
        };
      };
    };
  };
  suggestRelatedTopics: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SuggestRelatedRequest'];
      };
    };
    responses: {
      /** @description Related topics */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SuggestRelatedResponse'];
        };
      };
    };
  };
  bindRepository: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BindRepositoryRequest'];
      };
    };
    responses: {
      /** @description Repository binding created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BindRepositoryResponse'];
        };
      };
      /** @description Invalid request (malformed URL, invalid branch) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Namespace already bound to a repository */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  syncRepository: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SyncRepositoryRequest'];
      };
    };
    responses: {
      /** @description Sync completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SyncRepositoryResponse'];
        };
      };
      /** @description No binding found for namespace */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Sync already in progress */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRepositoryStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RepositoryStatusRequest'];
      };
    };
    responses: {
      /** @description Repository binding status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RepositoryStatusResponse'];
        };
      };
      /** @description No binding found for namespace */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRepositoryBindings: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRepositoryBindingsRequest'];
      };
    };
    responses: {
      /** @description List of repository bindings */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListRepositoryBindingsResponse'];
        };
      };
    };
  };
  updateRepositoryBinding: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateRepositoryBindingRequest'];
      };
    };
    responses: {
      /** @description Repository binding updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateRepositoryBindingResponse'];
        };
      };
      /** @description No binding found for namespace */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createDocumentationArchive: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateArchiveRequest'];
      };
    };
    responses: {
      /** @description Archive created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateArchiveResponse'];
        };
      };
      /** @description Namespace not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listDocumentationArchives: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListArchivesRequest'];
      };
    };
    responses: {
      /** @description List of archives */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListArchivesResponse'];
        };
      };
    };
  };
  createEscrow: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateEscrowRequest'];
      };
    };
    responses: {
      /** @description Escrow created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateEscrowResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getEscrow: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEscrowRequest'];
      };
    };
    responses: {
      /** @description Escrow details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetEscrowResponse'];
        };
      };
      /** @description Escrow not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listEscrows: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListEscrowsRequest'];
      };
    };
    responses: {
      /** @description List of escrows */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListEscrowsResponse'];
        };
      };
    };
  };
  deposit: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DepositRequest'];
      };
    };
    responses: {
      /** @description Deposit successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DepositResponse'];
        };
      };
      /** @description Deposit failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  validateDeposit: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidateDepositRequest'];
      };
    };
    responses: {
      /** @description Validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateDepositResponse'];
        };
      };
    };
  };
  getDepositStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetDepositStatusRequest'];
      };
    };
    responses: {
      /** @description Deposit status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetDepositStatusResponse'];
        };
      };
    };
  };
  recordConsent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConsentRequest'];
      };
    };
    responses: {
      /** @description Consent recorded */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ConsentResponse'];
        };
      };
      /** @description Consent failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getConsentStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetConsentStatusRequest'];
      };
    };
    responses: {
      /** @description Consent status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetConsentStatusResponse'];
        };
      };
    };
  };
  release: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReleaseRequest'];
      };
    };
    responses: {
      /** @description Release result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReleaseResponse'];
        };
      };
      /** @description Release failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  refund: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RefundRequest'];
      };
    };
    responses: {
      /** @description Refund result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RefundResponse'];
        };
      };
      /** @description Refund failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cancel: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CancelRequest'];
      };
    };
    responses: {
      /** @description Cancel result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CancelResponse'];
        };
      };
      /** @description Cancel failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  dispute: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DisputeRequest'];
      };
    };
    responses: {
      /** @description Dispute raised */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DisputeResponse'];
        };
      };
      /** @description Dispute failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  confirmRelease: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConfirmReleaseRequest'];
      };
    };
    responses: {
      /** @description Confirmation recorded */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ConfirmReleaseResponse'];
        };
      };
      /** @description Confirmation failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Escrow not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  confirmRefund: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConfirmRefundRequest'];
      };
    };
    responses: {
      /** @description Confirmation recorded */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ConfirmRefundResponse'];
        };
      };
      /** @description Confirmation failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Escrow not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  resolve: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResolveRequest'];
      };
    };
    responses: {
      /** @description Resolution result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ResolveResponse'];
        };
      };
      /** @description Resolution failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  verifyCondition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VerifyConditionRequest'];
      };
    };
    responses: {
      /** @description Verification result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifyConditionResponse'];
        };
      };
      /** @description Verification failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  reaffirm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReaffirmRequest'];
      };
    };
    responses: {
      /** @description Reaffirmation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReaffirmResponse'];
        };
      };
      /** @description Reaffirmation failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createFaction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateFactionRequest'];
      };
    };
    responses: {
      /** @description Faction created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FactionResponse'];
        };
      };
      /** @description Invalid faction data or hierarchy depth exceeded */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Parent faction, game service, or realm not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Faction code already exists in this game service */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getFaction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetFactionRequest'];
      };
    };
    responses: {
      /** @description Faction retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FactionResponse'];
        };
      };
      /** @description Faction not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getFactionByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetFactionByCodeRequest'];
      };
    };
    responses: {
      /** @description Faction retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FactionResponse'];
        };
      };
      /** @description Faction not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listFactions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListFactionsRequest'];
      };
    };
    responses: {
      /** @description Factions retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListFactionsResponse'];
        };
      };
    };
  };
  updateFaction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateFactionRequest'];
      };
    };
    responses: {
      /** @description Faction updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FactionResponse'];
        };
      };
      /** @description Faction not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Updated code conflicts with existing faction */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deprecateFaction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeprecateFactionRequest'];
      };
    };
    responses: {
      /** @description Faction deprecated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FactionResponse'];
        };
      };
      /** @description Faction not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Faction is already deprecated or dissolved */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  undeprecateFaction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UndeprecateFactionRequest'];
      };
    };
    responses: {
      /** @description Faction reactivated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FactionResponse'];
        };
      };
      /** @description Faction not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Faction is not in deprecated status */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  designateRealmBaseline: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DesignateRealmBaselineRequest'];
      };
    };
    responses: {
      /** @description Faction designated as realm baseline */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FactionResponse'];
        };
      };
      /** @description Faction not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Faction does not belong to the specified realm */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRealmBaseline: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmBaselineRequest'];
      };
    };
    responses: {
      /** @description Realm baseline faction retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FactionResponse'];
        };
      };
      /** @description No baseline faction designated for this realm */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  addMember: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AddMemberRequest'];
      };
    };
    responses: {
      /** @description Member added */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FactionMemberResponse'];
        };
      };
      /** @description Faction or character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Character is already a member of this faction, or faction is not active */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  removeMember: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RemoveMemberRequest'];
      };
    };
    responses: {
      /** @description Member removed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Membership not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listMembers: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListMembersRequest'];
      };
    };
    responses: {
      /** @description Members retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListMembersResponse'];
        };
      };
      /** @description Faction not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listMembershipsByCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListMembershipsByCharacterRequest'];
      };
    };
    responses: {
      /** @description Memberships retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListMembershipsByCharacterResponse'];
        };
      };
    };
  };
  updateMemberRole: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateMemberRoleRequest'];
      };
    };
    responses: {
      /** @description Role updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FactionMemberResponse'];
        };
      };
      /** @description Membership not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  checkMembership: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckMembershipRequest'];
      };
    };
    responses: {
      /** @description Membership check result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CheckMembershipResponse'];
        };
      };
    };
  };
  claimTerritory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ClaimTerritoryRequest'];
      };
    };
    responses: {
      /** @description Territory claimed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TerritoryClaimResponse'];
        };
      };
      /** @description Faction seed lacks territory.claim capability */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Faction or location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Location already claimed by another faction, or realm mismatch */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  releaseTerritory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReleaseTerritoryRequest'];
      };
    };
    responses: {
      /** @description Territory released */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Territory claim not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listTerritoryClaims: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListTerritoryClaimsRequest'];
      };
    };
    responses: {
      /** @description Territory claims retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListTerritoryClaimsResponse'];
        };
      };
      /** @description Faction not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getControllingFaction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetControllingFactionRequest'];
      };
    };
    responses: {
      /** @description Controlling faction retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ControllingFactionResponse'];
        };
      };
      /** @description No faction controls this location */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  defineNorm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DefineNormRequest'];
      };
    };
    responses: {
      /** @description Norm defined */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['NormDefinitionResponse'];
        };
      };
      /** @description Faction seed lacks required norm capability */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Faction not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Faction is not active, or maximum norms per faction reached */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateNorm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateNormRequest'];
      };
    };
    responses: {
      /** @description Norm updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['NormDefinitionResponse'];
        };
      };
      /** @description Faction seed lacks required capability for new severity */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Norm not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteNorm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteNormRequest'];
      };
    };
    responses: {
      /** @description Norm deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Norm not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listNorms: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListNormsRequest'];
      };
    };
    responses: {
      /** @description Norms retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListNormsResponse'];
        };
      };
      /** @description Faction not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cleanupByCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CleanupByCharacterRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CleanupByCharacterResponse'];
        };
      };
    };
  };
  cleanupByRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CleanupByRealmRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CleanupByRealmResponse'];
        };
      };
    };
  };
  cleanupByLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CleanupByLocationRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CleanupByLocationResponse'];
        };
      };
    };
  };
  getCompressData: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCompressDataRequest'];
      };
    };
    responses: {
      /** @description Compressed data returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FactionArchive'];
        };
      };
      /** @description No faction data for character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listServices: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListServicesRequest'];
      };
    };
    responses: {
      /** @description Services retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListServicesResponse'];
        };
      };
    };
  };
  getService: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetServiceRequest'];
      };
    };
    responses: {
      /** @description Service retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ServiceInfo'];
        };
      };
      /** @description Service not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getGameSession: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetGameSessionRequest'];
      };
    };
    responses: {
      /** @description Game session retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GameSessionResponse'];
        };
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  leaveGameSession: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveGameSessionRequest'];
      };
    };
    responses: {
      /** @description Successfully left game session */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  sendChatMessage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ChatMessageRequest'];
      };
    };
    responses: {
      /** @description Chat message sent successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  performGameAction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GameActionRequest'];
      };
    };
    responses: {
      /** @description Game action performed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GameActionResponse'];
        };
      };
      /** @description Invalid game action */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  leaveGameSessionById: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveGameSessionByIdRequest'];
      };
    };
    responses: {
      /** @description Successfully left game session */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found or player not in session */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  enterGarden: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EnterGardenRequest'];
      };
    };
    responses: {
      /** @description Garden instance created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GardenStateResponse'];
        };
      };
      /** @description No active seed found for account */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Player already has an active garden instance */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getGardenState: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetGardenStateRequest'];
      };
    };
    responses: {
      /** @description Garden state retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GardenStateResponse'];
        };
      };
      /** @description Player is not in the garden */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updatePosition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdatePositionRequest'];
      };
    };
    responses: {
      /** @description Position updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PositionUpdateResponse'];
        };
      };
      /** @description Player is not in the garden */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  leaveGarden: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveGardenRequest'];
      };
    };
    responses: {
      /** @description Left the garden */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeaveGardenResponse'];
        };
      };
      /** @description Player is not in the garden */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listPois: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListPoisRequest'];
      };
    };
    responses: {
      /** @description POIs retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListPoisResponse'];
        };
      };
      /** @description Player is not in the garden */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  interactWithPoi: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InteractWithPoiRequest'];
      };
    };
    responses: {
      /** @description Interaction result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PoiInteractionResponse'];
        };
      };
      /** @description POI is expired or already interacted with */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description POI not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  declinePoi: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeclinePoiRequest'];
      };
    };
    responses: {
      /** @description POI declined */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeclinePoiResponse'];
        };
      };
      /** @description POI is not in Active status */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description POI not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  enterScenario: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EnterScenarioRequest'];
      };
    };
    responses: {
      /** @description Scenario entered */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScenarioStateResponse'];
        };
      };
      /** @description Prerequisites not met or invalid template */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Global scenario capacity reached */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getScenarioState: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetScenarioStateRequest'];
      };
    };
    responses: {
      /** @description Scenario state retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScenarioStateResponse'];
        };
      };
      /** @description No active scenario */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  completeScenario: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CompleteScenarioRequest'];
      };
    };
    responses: {
      /** @description Scenario completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScenarioCompletionResponse'];
        };
      };
      /** @description Scenario instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  abandonScenario: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AbandonScenarioRequest'];
      };
    };
    responses: {
      /** @description Scenario abandoned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AbandonScenarioResponse'];
        };
      };
      /** @description Scenario instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  chainScenario: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ChainScenarioRequest'];
      };
    };
    responses: {
      /** @description Chained to new scenario */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScenarioStateResponse'];
        };
      };
      /** @description Chaining rules not met or max chain depth exceeded */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Current scenario or target template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateTemplateRequest'];
      };
    };
    responses: {
      /** @description Template created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScenarioTemplateResponse'];
        };
      };
      /** @description Template with this code already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetTemplateRequest'];
      };
    };
    responses: {
      /** @description Template retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScenarioTemplateResponse'];
        };
      };
      /** @description Template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTemplateByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetTemplateByCodeRequest'];
      };
    };
    responses: {
      /** @description Template retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScenarioTemplateResponse'];
        };
      };
      /** @description Template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listTemplates: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListTemplatesRequest'];
      };
    };
    responses: {
      /** @description Templates listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListTemplatesResponse'];
        };
      };
    };
  };
  updateTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateTemplateRequest'];
      };
    };
    responses: {
      /** @description Template updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScenarioTemplateResponse'];
        };
      };
      /** @description Template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deprecateTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeprecateTemplateRequest'];
      };
    };
    responses: {
      /** @description Template deprecated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScenarioTemplateResponse'];
        };
      };
      /** @description Template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteTemplateRequest'];
      };
    };
    responses: {
      /** @description Template deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScenarioTemplateResponse'];
        };
      };
      /** @description Template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Template is not in Deprecated status */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getPhaseConfig: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetPhaseConfigRequest'];
      };
    };
    responses: {
      /** @description Phase config retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PhaseConfigResponse'];
        };
      };
    };
  };
  updatePhaseConfig: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdatePhaseConfigRequest'];
      };
    };
    responses: {
      /** @description Phase config updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PhaseConfigResponse'];
        };
      };
    };
  };
  getPhaseMetrics: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetPhaseMetricsRequest'];
      };
    };
    responses: {
      /** @description Phase metrics retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PhaseMetricsResponse'];
        };
      };
    };
  };
  enterScenarioTogether: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EnterTogetherRequest'];
      };
    };
    responses: {
      /** @description Both players entered shared scenario */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScenarioStateResponse'];
        };
      };
      /** @description One or both participants not in garden, or template does not support multiplayer */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bond not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSharedGardenState: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSharedGardenRequest'];
      };
    };
    responses: {
      /** @description Shared garden state retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SharedGardenStateResponse'];
        };
      };
      /** @description Bond not found or participants not in garden */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createContainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateContainerRequest'];
      };
    };
    responses: {
      /** @description Container created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContainerResponse'];
        };
      };
      /** @description Invalid request (validation error) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getContainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetContainerRequest'];
      };
    };
    responses: {
      /** @description Container retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContainerWithContentsResponse'];
        };
      };
      /** @description Container not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getOrCreateContainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetOrCreateContainerRequest'];
      };
    };
    responses: {
      /** @description Container retrieved or created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContainerResponse'];
        };
      };
    };
  };
  listContainers: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListContainersRequest'];
      };
    };
    responses: {
      /** @description Containers retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListContainersResponse'];
        };
      };
    };
  };
  updateContainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateContainerRequest'];
      };
    };
    responses: {
      /** @description Container updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContainerResponse'];
        };
      };
      /** @description Container not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  addItemToContainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AddItemRequest'];
      };
    };
    responses: {
      /** @description Item added successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AddItemResponse'];
        };
      };
      /** @description Constraint violation (full, overweight, wrong category) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Container or item not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  removeItemFromContainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RemoveItemRequest'];
      };
    };
    responses: {
      /** @description Item removed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RemoveItemResponse'];
        };
      };
      /** @description Item not found in specified container */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  moveItem: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MoveItemRequest'];
      };
    };
    responses: {
      /** @description Item moved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MoveItemResponse'];
        };
      };
      /** @description Constraint violation at destination */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item or container not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  transferItem: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransferItemRequest'];
      };
    };
    responses: {
      /** @description Item transferred successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TransferItemResponse'];
        };
      };
      /** @description Item is bound or not tradeable */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item or container not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  splitStack: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SplitStackRequest'];
      };
    };
    responses: {
      /** @description Stack split successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SplitStackResponse'];
        };
      };
      /** @description Cannot split unique items or invalid quantity */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  mergeStacks: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MergeStacksRequest'];
      };
    };
    responses: {
      /** @description Stacks merged successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MergeStacksResponse'];
        };
      };
      /** @description Items are not the same template or target would exceed max stack */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryItems: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryItemsRequest'];
      };
    };
    responses: {
      /** @description Items found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryItemsResponse'];
        };
      };
    };
  };
  countItems: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CountItemsRequest'];
      };
    };
    responses: {
      /** @description Count completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CountItemsResponse'];
        };
      };
    };
  };
  hasItems: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HasItemsRequest'];
      };
    };
    responses: {
      /** @description Check completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HasItemsResponse'];
        };
      };
    };
  };
  findSpace: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FindSpaceRequest'];
      };
    };
    responses: {
      /** @description Space search completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FindSpaceResponse'];
        };
      };
    };
  };
  createItemTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateItemTemplateRequest'];
      };
    };
    responses: {
      /** @description Item template created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ItemTemplateResponse'];
        };
      };
      /** @description Invalid request (validation error) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Code already exists for this gameId */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getItemTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetItemTemplateRequest'];
      };
    };
    responses: {
      /** @description Item template retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ItemTemplateResponse'];
        };
      };
      /** @description Neither templateId nor code+gameId provided */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listItemTemplates: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListItemTemplatesRequest'];
      };
    };
    responses: {
      /** @description Item templates retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListItemTemplatesResponse'];
        };
      };
    };
  };
  updateItemTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateItemTemplateRequest'];
      };
    };
    responses: {
      /** @description Item template updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ItemTemplateResponse'];
        };
      };
      /** @description Attempted to change immutable field */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createItemInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateItemInstanceRequest'];
      };
    };
    responses: {
      /** @description Item instance created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ItemInstanceResponse'];
        };
      };
      /** @description Invalid request (validation error) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Template is deprecated */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getItemInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetItemInstanceRequest'];
      };
    };
    responses: {
      /** @description Item instance retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ItemInstanceResponse'];
        };
      };
      /** @description Item instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  modifyItemInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ModifyItemInstanceRequest'];
      };
    };
    responses: {
      /** @description Item instance modified successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ItemInstanceResponse'];
        };
      };
      /** @description Invalid modification (e.g., negative durability) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item is corrupted/mirrored and cannot be modified */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  bindItemInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BindItemInstanceRequest'];
      };
    };
    responses: {
      /** @description Item instance bound successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ItemInstanceResponse'];
        };
      };
      /** @description Item cannot be bound (template doesn't allow binding) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item already bound */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  destroyItemInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DestroyItemInstanceRequest'];
      };
    };
    responses: {
      /** @description Item instance destroyed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DestroyItemInstanceResponse'];
        };
      };
      /** @description Item instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item is bound and cannot be destroyed */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  useItem: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UseItemRequest'];
      };
    };
    responses: {
      /** @description Item used successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UseItemResponse'];
        };
      };
      /** @description Item template has no behavior contract or invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item use failed (contract prebound APIs failed) */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  useItemStep: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UseItemStepRequest'];
      };
    };
    responses: {
      /** @description Step completed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UseItemStepResponse'];
        };
      };
      /** @description Invalid request or item template has no behavior contract */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Another operation is in progress on this item (distributed lock held) */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Step execution failed (CanUse validation or milestone completion) */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listItemsByContainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListItemsByContainerRequest'];
      };
    };
    responses: {
      /** @description Items retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListItemsResponse'];
        };
      };
    };
  };
  batchGetItemInstances: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BatchGetItemInstancesRequest'];
      };
    };
    responses: {
      /** @description Items retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BatchGetItemInstancesResponse'];
        };
      };
    };
  };
  createLeaderboardDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateLeaderboardDefinitionRequest'];
      };
    };
    responses: {
      /** @description Leaderboard created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeaderboardDefinitionResponse'];
        };
      };
      /** @description Leaderboard with this ID already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateLeaderboardDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateLeaderboardDefinitionRequest'];
      };
    };
    responses: {
      /** @description Leaderboard updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeaderboardDefinitionResponse'];
        };
      };
      /** @description Leaderboard not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteLeaderboardDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteLeaderboardDefinitionRequest'];
      };
    };
    responses: {
      /** @description Leaderboard deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Leaderboard not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getEntityRank: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEntityRankRequest'];
      };
    };
    responses: {
      /** @description Rank retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EntityRankResponse'];
        };
      };
      /** @description Entity not found on leaderboard */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTopRanks: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetTopRanksRequest'];
      };
    };
    responses: {
      /** @description Top ranks retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeaderboardEntriesResponse'];
        };
      };
    };
  };
  getRanksAround: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRanksAroundRequest'];
      };
    };
    responses: {
      /** @description Ranks retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeaderboardEntriesResponse'];
        };
      };
      /** @description Entity not found on leaderboard */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSeason: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSeasonRequest'];
      };
    };
    responses: {
      /** @description Season info retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeasonResponse'];
        };
      };
      /** @description Season not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createBoardTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateBoardTemplateRequest'];
      };
    };
    responses: {
      /** @description Board template created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BoardTemplateResponse'];
        };
      };
      /** @description Invalid request (validation error) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Referenced game service or contract template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBoardTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBoardTemplateRequest'];
      };
    };
    responses: {
      /** @description Board template retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BoardTemplateResponse'];
        };
      };
      /** @description Board template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listBoardTemplates: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListBoardTemplatesRequest'];
      };
    };
    responses: {
      /** @description Board templates retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListBoardTemplatesResponse'];
        };
      };
    };
  };
  updateBoardTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateBoardTemplateRequest'];
      };
    };
    responses: {
      /** @description Board template updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BoardTemplateResponse'];
        };
      };
      /** @description Board template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteBoardTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteBoardTemplateRequest'];
      };
    };
    responses: {
      /** @description Board template deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BoardTemplateResponse'];
        };
      };
      /** @description Board template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Active board instances exist for this template */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  addLicenseDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AddLicenseDefinitionRequest'];
      };
    };
    responses: {
      /** @description License definition added successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LicenseDefinitionResponse'];
        };
      };
      /** @description Invalid request (position out of bounds, invalid item template) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Board template or item template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Duplicate code or position, or max definitions exceeded */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getLicenseDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLicenseDefinitionRequest'];
      };
    };
    responses: {
      /** @description License definition retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LicenseDefinitionResponse'];
        };
      };
      /** @description Board template or license definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listLicenseDefinitions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListLicenseDefinitionsRequest'];
      };
    };
    responses: {
      /** @description License definitions retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListLicenseDefinitionsResponse'];
        };
      };
      /** @description Board template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateLicenseDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateLicenseDefinitionRequest'];
      };
    };
    responses: {
      /** @description License definition updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LicenseDefinitionResponse'];
        };
      };
      /** @description Board template or license definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  removeLicenseDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RemoveLicenseDefinitionRequest'];
      };
    };
    responses: {
      /** @description License definition removed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LicenseDefinitionResponse'];
        };
      };
      /** @description Board template or license definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description License is unlocked by active board instances */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createBoard: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateBoardRequest'];
      };
    };
    responses: {
      /** @description Board created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BoardResponse'];
        };
      };
      /** @description Invalid request (inactive template) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Character, game service, or board template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Duplicate board or max boards per character exceeded */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBoard: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBoardRequest'];
      };
    };
    responses: {
      /** @description Board retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BoardResponse'];
        };
      };
      /** @description Board not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listBoardsByOwner: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListBoardsByOwnerRequest'];
      };
    };
    responses: {
      /** @description Boards retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListBoardsByOwnerResponse'];
        };
      };
    };
  };
  deleteBoard: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteBoardRequest'];
      };
    };
    responses: {
      /** @description Board deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BoardResponse'];
        };
      };
      /** @description Board not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  unlockLicense: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnlockLicenseRequest'];
      };
    };
    responses: {
      /** @description License unlocked successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UnlockLicenseResponse'];
        };
      };
      /** @description Not adjacent, prerequisites not met, or insufficient LP */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Board or license definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description License already unlocked */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract execution failed */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  checkUnlockable: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckUnlockableRequest'];
      };
    };
    responses: {
      /** @description Unlockability check completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CheckUnlockableResponse'];
        };
      };
      /** @description Board or license definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBoardState: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BoardStateRequest'];
      };
    };
    responses: {
      /** @description Board state retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BoardStateResponse'];
        };
      };
      /** @description Board not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  seedBoardTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SeedBoardTemplateRequest'];
      };
    };
    responses: {
      /** @description Board template seeded successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedBoardTemplateResponse'];
        };
      };
      /** @description Invalid definitions (out of bounds, duplicates) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Board template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cloneBoard: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CloneBoardRequest'];
      };
    };
    responses: {
      /** @description Board cloned successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CloneBoardResponse'];
        };
      };
      /** @description Invalid request (owner type not allowed, missing realm for character) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Source board, target owner (character), or template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Target already has a board for this template, or max boards exceeded */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cleanupByOwner: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CleanupByOwnerRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CleanupByOwnerResponse'];
        };
      };
    };
  };
  getLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationRequest'];
      };
    };
    responses: {
      /** @description Location retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getLocationByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationByCodeRequest'];
      };
    };
    responses: {
      /** @description Location retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listLocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListLocationsRequest'];
      };
    };
    responses: {
      /** @description Locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
    };
  };
  listLocationsByRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListLocationsByRealmRequest'];
      };
    };
    responses: {
      /** @description Locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
    };
  };
  listLocationsByParent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListLocationsByParentRequest'];
      };
    };
    responses: {
      /** @description Child locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
      /** @description Parent location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRootLocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRootLocationsRequest'];
      };
    };
    responses: {
      /** @description Root locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
    };
  };
  getLocationAncestors: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationAncestorsRequest'];
      };
    };
    responses: {
      /** @description Ancestors retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  validateTerritory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidateTerritoryRequest'];
      };
    };
    responses: {
      /** @description Territory validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateTerritoryResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getLocationDescendants: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationDescendantsRequest'];
      };
    };
    responses: {
      /** @description Descendants retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  locationExists: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LocationExistsRequest'];
      };
    };
    responses: {
      /** @description Validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationExistsResponse'];
        };
      };
    };
  };
  queryLocationsByPosition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryLocationsByPositionRequest'];
      };
    };
    responses: {
      /** @description Locations containing the position */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
    };
  };
  reportEntityPosition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReportEntityPositionRequest'];
      };
    };
    responses: {
      /** @description Position reported successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReportEntityPositionResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getEntityLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEntityLocationRequest'];
      };
    };
    responses: {
      /** @description Entity location query result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetEntityLocationResponse'];
        };
      };
    };
  };
  listEntitiesAtLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListEntitiesAtLocationRequest'];
      };
    };
    responses: {
      /** @description Entity list for the location */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListEntitiesAtLocationResponse'];
        };
      };
    };
  };
  clearEntityPosition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ClearEntityPositionRequest'];
      };
    };
    responses: {
      /** @description Entity position cleared */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClearEntityPositionResponse'];
        };
      };
    };
  };
  requestSnapshot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RequestSnapshotRequest'];
      };
    };
    responses: {
      /** @description Snapshot returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RequestSnapshotResponse'];
        };
      };
      /** @description Region not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryPoint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryPointRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryPointResponse'];
        };
      };
    };
  };
  queryBounds: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBoundsRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryBoundsResponse'];
        };
      };
    };
  };
  queryObjectsByType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryObjectsByTypeRequest'];
      };
    };
    responses: {
      /** @description Matching objects */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryObjectsByTypeResponse'];
        };
      };
    };
  };
  queryAffordance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AffordanceQueryRequest'];
      };
    };
    responses: {
      /** @description Scored locations */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AffordanceQueryResponse'];
        };
      };
    };
  };
  checkoutForAuthoring: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthoringCheckoutRequest'];
      };
    };
    responses: {
      /** @description Checkout successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthoringCheckoutResponse'];
        };
      };
      /** @description Already checked out by another editor */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  commitAuthoring: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthoringCommitRequest'];
      };
    };
    responses: {
      /** @description Changes committed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthoringCommitResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  releaseAuthoring: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthoringReleaseRequest'];
      };
    };
    responses: {
      /** @description Checkout released */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthoringReleaseResponse'];
        };
      };
    };
  };
  createDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateDefinitionRequest'];
      };
    };
    responses: {
      /** @description Definition created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MapDefinition'];
        };
      };
      /** @description Definition with this name already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetDefinitionRequest'];
      };
    };
    responses: {
      /** @description Definition found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MapDefinition'];
        };
      };
      /** @description Definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listDefinitions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListDefinitionsRequest'];
      };
    };
    responses: {
      /** @description Definitions list */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListDefinitionsResponse'];
        };
      };
    };
  };
  updateDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateDefinitionRequest'];
      };
    };
    responses: {
      /** @description Definition updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MapDefinition'];
        };
      };
      /** @description Definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listQueues: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListQueuesRequest'];
      };
    };
    responses: {
      /** @description Queues retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListQueuesResponse'];
        };
      };
    };
  };
  getQueue: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetQueueRequest'];
      };
    };
    responses: {
      /** @description Queue details retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueueResponse'];
        };
      };
      /** @description Queue not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  joinMatchmaking: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['JoinMatchmakingRequest'];
      };
    };
    responses: {
      /** @description Successfully joined matchmaking queue */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['JoinMatchmakingResponse'];
        };
      };
      /** @description Invalid query syntax or properties */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Already in queue, queue limit reached, or exclusive group conflict */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  leaveMatchmaking: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveMatchmakingRequest'];
      };
    };
    responses: {
      /** @description Successfully left matchmaking queue */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Ticket not found or not in queue */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getMatchmakingStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetMatchmakingStatusRequest'];
      };
    };
    responses: {
      /** @description Status retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MatchmakingStatusResponse'];
        };
      };
      /** @description No active matchmaking ticket */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  acceptMatch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AcceptMatchRequest'];
      };
    };
    responses: {
      /** @description Match acceptance recorded */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AcceptMatchResponse'];
        };
      };
      /** @description No pending match or already processed */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  declineMatch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeclineMatchRequest'];
      };
    };
    responses: {
      /** @description Match declined */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description No pending match or already processed */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getMatchmakingStats: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetMatchmakingStatsRequest'];
      };
    };
    responses: {
      /** @description Statistics retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MatchmakingStatsResponse'];
        };
      };
    };
  };
  GenerateComposition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateCompositionRequest'];
      };
    };
    responses: {
      /** @description Composition generated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateCompositionResponse'];
        };
      };
      /** @description Invalid request or generation constraints */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Style not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ValidateMidiJson: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidateMidiJsonRequest'];
      };
    };
    responses: {
      /** @description Validation completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateMidiJsonResponse'];
        };
      };
    };
  };
  GetStyle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetStyleRequest'];
      };
    };
    responses: {
      /** @description Style retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StyleDefinitionResponse'];
        };
      };
      /** @description Style not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListStyles: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListStylesRequest'];
      };
    };
    responses: {
      /** @description Styles listed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListStylesResponse'];
        };
      };
    };
  };
  GenerateProgression: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateProgressionRequest'];
      };
    };
    responses: {
      /** @description Progression generated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateProgressionResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GenerateMelody: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateMelodyRequest'];
      };
    };
    responses: {
      /** @description Melody generated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateMelodyResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ApplyVoiceLeading: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VoiceLeadRequest'];
      };
    };
    responses: {
      /** @description Voice leading applied successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VoiceLeadResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  setActionMapping: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SetActionMappingRequest'];
      };
    };
    responses: {
      /** @description Mapping saved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActionMappingResponse'];
        };
      };
      /** @description Invalid mapping data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listActionMappings: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListActionMappingsRequest'];
      };
    };
    responses: {
      /** @description Mappings retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListActionMappingsResponse'];
        };
      };
    };
  };
  deleteActionMapping: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteActionMappingRequest'];
      };
    };
    responses: {
      /** @description Mapping deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description No mapping found for this tag */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryViolations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryViolationsRequest'];
      };
    };
    responses: {
      /** @description Violations retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryViolationsResponse'];
        };
      };
    };
  };
  invalidateCache: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InvalidateCacheRequest'];
      };
    };
    responses: {
      /** @description Cache refreshed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InvalidateCacheResponse'];
        };
      };
    };
  };
  getCompressData: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCompressDataRequest'];
      };
    };
    responses: {
      /** @description Compressed data returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ObligationArchive'];
        };
      };
      /** @description No obligation data for character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cleanupByCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CleanupByCharacterRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CleanupByCharacterResponse'];
        };
      };
    };
  };
  startWatcher: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StartWatcherRequest'];
      };
    };
    responses: {
      /** @description Watcher started or already exists */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StartWatcherResponse'];
        };
      };
    };
  };
  stopWatcher: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StopWatcherRequest'];
      };
    };
    responses: {
      /** @description Watcher stopped successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StopWatcherResponse'];
        };
      };
    };
  };
  startWatchersForRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StartWatchersForRealmRequest'];
      };
    };
    responses: {
      /** @description Watchers started for realm */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StartWatchersForRealmResponse'];
        };
      };
    };
  };
  createQuestDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateQuestDefinitionRequest'];
      };
    };
    responses: {
      /** @description Quest definition created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QuestDefinitionResponse'];
        };
      };
      /** @description Invalid request (validation error) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Quest definition with this code already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getQuestDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetQuestDefinitionRequest'];
      };
    };
    responses: {
      /** @description Quest definition found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QuestDefinitionResponse'];
        };
      };
      /** @description Quest definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listQuestDefinitions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListQuestDefinitionsRequest'];
      };
    };
    responses: {
      /** @description Quest definitions retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListQuestDefinitionsResponse'];
        };
      };
    };
  };
  updateQuestDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateQuestDefinitionRequest'];
      };
    };
    responses: {
      /** @description Quest definition updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QuestDefinitionResponse'];
        };
      };
      /** @description Quest definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deprecateQuestDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeprecateQuestDefinitionRequest'];
      };
    };
    responses: {
      /** @description Quest definition deprecated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QuestDefinitionResponse'];
        };
      };
      /** @description Quest definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  acceptQuest: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AcceptQuestRequest'];
      };
    };
    responses: {
      /** @description Quest accepted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QuestInstanceResponse'];
        };
      };
      /** @description Prerequisites not met or already at max quests */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Quest definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Quest already active or on cooldown */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  abandonQuest: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AbandonQuestRequest'];
      };
    };
    responses: {
      /** @description Quest abandoned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QuestInstanceResponse'];
        };
      };
      /** @description Quest not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Quest not in abandonable state */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getQuest: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetQuestRequest'];
      };
    };
    responses: {
      /** @description Quest instance found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QuestInstanceResponse'];
        };
      };
      /** @description Quest not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listQuests: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListQuestsRequest'];
      };
    };
    responses: {
      /** @description Quests retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListQuestsResponse'];
        };
      };
    };
  };
  listAvailableQuests: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListAvailableQuestsRequest'];
      };
    };
    responses: {
      /** @description Available quests retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListAvailableQuestsResponse'];
        };
      };
    };
  };
  getQuestLog: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetQuestLogRequest'];
      };
    };
    responses: {
      /** @description Quest log retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QuestLogResponse'];
        };
      };
    };
  };
  reportObjectiveProgress: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReportProgressRequest'];
      };
    };
    responses: {
      /** @description Progress recorded */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ObjectiveProgressResponse'];
        };
      };
      /** @description Quest or objective not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getObjectiveProgress: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetObjectiveProgressRequest'];
      };
    };
    responses: {
      /** @description Objective progress retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ObjectiveProgressResponse'];
        };
      };
      /** @description Quest or objective not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCompressData: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCompressDataRequest'];
      };
    };
    responses: {
      /** @description Compressed data returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QuestArchive'];
        };
      };
      /** @description No quest data for character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmRequest'];
      };
    };
    responses: {
      /** @description Realm retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmResponse'];
        };
      };
      /** @description Realm not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRealmByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmByCodeRequest'];
      };
    };
    responses: {
      /** @description Realm retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmResponse'];
        };
      };
      /** @description Realm not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRealms: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRealmsRequest'];
      };
    };
    responses: {
      /** @description Realms retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmListResponse'];
        };
      };
    };
  };
  realmExists: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RealmExistsRequest'];
      };
    };
    responses: {
      /** @description Validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmExistsResponse'];
        };
      };
    };
  };
  realmsExistBatch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RealmsExistBatchRequest'];
      };
    };
    responses: {
      /** @description Validation results for all requested realms */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmsExistBatchResponse'];
        };
      };
    };
  };
  getRealmParticipation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmParticipationRequest'];
      };
    };
    responses: {
      /** @description Participation records retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmParticipationListResponse'];
        };
      };
    };
  };
  getRealmEventParticipants: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmEventParticipantsRequest'];
      };
    };
    responses: {
      /** @description Participants retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmParticipationListResponse'];
        };
      };
    };
  };
  getRealmLore: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmLoreRequest'];
      };
    };
    responses: {
      /** @description Lore retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmLoreResponse'];
        };
      };
      /** @description No lore defined for this realm */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRelationship: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipRequest'];
      };
    };
    responses: {
      /** @description Relationship retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipResponse'];
        };
      };
      /** @description Relationship not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRelationshipsByEntity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRelationshipsByEntityRequest'];
      };
    };
    responses: {
      /** @description Relationships retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipListResponse'];
        };
      };
    };
  };
  getRelationshipsBetween: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipsBetweenRequest'];
      };
    };
    responses: {
      /** @description Relationships retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipListResponse'];
        };
      };
    };
  };
  listRelationshipsByType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRelationshipsByTypeRequest'];
      };
    };
    responses: {
      /** @description Relationships retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipListResponse'];
        };
      };
    };
  };
  cleanupByEntity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CleanupByEntityRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CleanupByEntityResponse'];
        };
      };
    };
  };
  getRelationshipType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipTypeRequest'];
      };
    };
    responses: {
      /** @description Relationship type retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeResponse'];
        };
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRelationshipTypeByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipTypeByCodeRequest'];
      };
    };
    responses: {
      /** @description Relationship type retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeResponse'];
        };
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRelationshipTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRelationshipTypesRequest'];
      };
    };
    responses: {
      /** @description Relationship types retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeListResponse'];
        };
      };
    };
  };
  getChildRelationshipTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetChildRelationshipTypesRequest'];
      };
    };
    responses: {
      /** @description Child relationship types retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeListResponse'];
        };
      };
      /** @description Parent relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  matchesHierarchy: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MatchesHierarchyRequest'];
      };
    };
    responses: {
      /** @description Hierarchy match result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MatchesHierarchyResponse'];
        };
      };
      /** @description One or both relationship types not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAncestors: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAncestorsRequest'];
      };
    };
    responses: {
      /** @description Ancestors retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeListResponse'];
        };
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  registerReference: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterReferenceRequest'];
      };
    };
    responses: {
      /** @description Reference registered */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RegisterReferenceResponse'];
        };
      };
    };
  };
  unregisterReference: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnregisterReferenceRequest'];
      };
    };
    responses: {
      /** @description Reference unregistered */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UnregisterReferenceResponse'];
        };
      };
    };
  };
  checkReferences: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckReferencesRequest'];
      };
    };
    responses: {
      /** @description Reference status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CheckReferencesResponse'];
        };
      };
    };
  };
  listReferences: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListReferencesRequest'];
      };
    };
    responses: {
      /** @description List of references */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListReferencesResponse'];
        };
      };
    };
  };
  executeCleanup: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExecuteCleanupRequest'];
      };
    };
    responses: {
      /** @description Cleanup executed or rejected */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExecuteCleanupResponse'];
        };
      };
    };
  };
  listCleanupCallbacks: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListCleanupCallbacksRequest'];
      };
    };
    responses: {
      /** @description List of registered callbacks */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListCleanupCallbacksResponse'];
        };
      };
    };
  };
  executeCompress: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExecuteCompressRequest'];
      };
    };
    responses: {
      /** @description Compression result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExecuteCompressResponse'];
        };
      };
    };
  };
  listCompressCallbacks: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListCompressCallbacksRequest'];
      };
    };
    responses: {
      /** @description Callback list */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListCompressCallbacksResponse'];
        };
      };
    };
  };
  getArchive: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetArchiveRequest'];
      };
    };
    responses: {
      /** @description Archive data */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetArchiveResponse'];
        };
      };
    };
  };
  executeSnapshot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExecuteSnapshotRequest'];
      };
    };
    responses: {
      /** @description Snapshot result with snapshot ID and data */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExecuteSnapshotResponse'];
        };
      };
    };
  };
  getSnapshot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSnapshotRequest'];
      };
    };
    responses: {
      /** @description Snapshot data */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetSnapshotResponse'];
        };
      };
    };
  };
  CreateSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSlotRequest'];
      };
    };
    responses: {
      /** @description Slot created or updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SlotResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Slot already exists with different owner */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSlotRequest'];
      };
    };
    responses: {
      /** @description Slot found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SlotResponse'];
        };
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListSlots: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSlotsRequest'];
      };
    };
    responses: {
      /** @description Slots listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListSlotsResponse'];
        };
      };
    };
  };
  DeleteSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteSlotRequest'];
      };
    };
    responses: {
      /** @description Slot deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteSlotResponse'];
        };
      };
      /** @description Not authorized to delete this slot */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  RenameSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RenameSlotRequest'];
      };
    };
    responses: {
      /** @description Slot renamed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SlotResponse'];
        };
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Target name already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  Save: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SaveRequest'];
      };
    };
    responses: {
      /** @description Save successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Invalid request or data validation failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to save to this slot */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Save data exceeds maximum size limit */
      413: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  Load: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LoadRequest'];
      };
    };
    responses: {
      /** @description Load successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LoadResponse'];
        };
      };
      /** @description Not authorized to load from this slot */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  SaveDelta: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SaveDeltaRequest'];
      };
    };
    responses: {
      /** @description Delta save successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveDeltaResponse'];
        };
      };
      /** @description Invalid delta or base version not found */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Base version has been deleted (cannot apply delta) */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Delta too large (consider full save instead) */
      413: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  LoadWithDeltas: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LoadRequest'];
      };
    };
    responses: {
      /** @description Load successful (reconstructed if delta) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LoadResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Delta chain broken (base version missing) */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CollapseDeltas: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CollapseDeltasRequest'];
      };
    };
    responses: {
      /** @description Delta chain collapsed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListVersions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListVersionsRequest'];
      };
    };
    responses: {
      /** @description Versions listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListVersionsResponse'];
        };
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PinVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PinVersionRequest'];
      };
    };
    responses: {
      /** @description Version pinned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VersionResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UnpinVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnpinVersionRequest'];
      };
    };
    responses: {
      /** @description Version unpinned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VersionResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteVersionRequest'];
      };
    };
    responses: {
      /** @description Version deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteVersionResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cannot delete pinned version */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  QuerySaves: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QuerySavesRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QuerySavesResponse'];
        };
      };
    };
  };
  CopySave: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CopySaveRequest'];
      };
    };
    responses: {
      /** @description Save copied */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Not authorized to copy to target */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Source slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ExportSaves: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExportSavesRequest'];
      };
    };
    responses: {
      /** @description Export prepared */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExportSavesResponse'];
        };
      };
    };
  };
  VerifyIntegrity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VerifyIntegrityRequest'];
      };
    };
    responses: {
      /** @description Verification result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifyIntegrityResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PromoteVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PromoteVersionRequest'];
      };
    };
    responses: {
      /** @description Version promoted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  MigrateSave: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MigrateSaveRequest'];
      };
    };
    responses: {
      /** @description Migration successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MigrateSaveResponse'];
        };
      };
      /** @description Migration failed or no path exists */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Save not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  RegisterSchema: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterSchemaRequest'];
      };
    };
    responses: {
      /** @description Schema registered */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SchemaResponse'];
        };
      };
    };
  };
  ListSchemas: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSchemasRequest'];
      };
    };
    responses: {
      /** @description Schemas listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListSchemasResponse'];
        };
      };
    };
  };
  createScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSceneRequest'];
      };
    };
    responses: {
      /** @description Scene created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SceneResponse'];
        };
      };
      /** @description Invalid scene structure (validation failed) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene with this sceneId already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSceneRequest'];
      };
    };
    responses: {
      /** @description Scene retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetSceneResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listScenes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListScenesRequest'];
      };
    };
    responses: {
      /** @description Scenes listed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListScenesResponse'];
        };
      };
    };
  };
  updateScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateSceneRequest'];
      };
    };
    responses: {
      /** @description Scene updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SceneResponse'];
        };
      };
      /** @description Invalid scene structure */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene is checked out by another user */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteSceneRequest'];
      };
    };
    responses: {
      /** @description Scene deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteSceneResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cannot delete - other scenes reference this scene */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  validateScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidateSceneRequest'];
      };
    };
    responses: {
      /** @description Validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidationResult'];
        };
      };
    };
  };
  checkoutScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckoutRequest'];
      };
    };
    responses: {
      /** @description Checkout successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CheckoutResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene already checked out by another user */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  commitScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CommitRequest'];
      };
    };
    responses: {
      /** @description Commit successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CommitResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Checkout expired */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  discardCheckout: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DiscardRequest'];
      };
    };
    responses: {
      /** @description Discard successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DiscardResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  heartbeatCheckout: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HeartbeatRequest'];
      };
    };
    responses: {
      /** @description Lock extended */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HeartbeatResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Checkout expired */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSceneHistory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HistoryRequest'];
      };
    };
    responses: {
      /** @description History retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HistoryResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getValidationRules: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetValidationRulesRequest'];
      };
    };
    responses: {
      /** @description Rules retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetValidationRulesResponse'];
        };
      };
    };
  };
  searchScenes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SearchScenesRequest'];
      };
    };
    responses: {
      /** @description Search results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SearchScenesResponse'];
        };
      };
    };
  };
  findReferences: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FindReferencesRequest'];
      };
    };
    responses: {
      /** @description Referencing scenes found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FindReferencesResponse'];
        };
      };
    };
  };
  findAssetUsage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FindAssetUsageRequest'];
      };
    };
    responses: {
      /** @description Asset usage found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FindAssetUsageResponse'];
        };
      };
    };
  };
  duplicateScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DuplicateSceneRequest'];
      };
    };
    responses: {
      /** @description Scene duplicated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SceneResponse'];
        };
      };
      /** @description Source scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateSeed: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSeedRequest'];
      };
    };
    responses: {
      /** @description Seed created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedResponse'];
        };
      };
    };
  };
  GetSeed: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSeedRequest'];
      };
    };
    responses: {
      /** @description Seed found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedResponse'];
        };
      };
    };
  };
  GetSeedsByOwner: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSeedsByOwnerRequest'];
      };
    };
    responses: {
      /** @description Seeds found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListSeedsResponse'];
        };
      };
    };
  };
  ListSeeds: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSeedsRequest'];
      };
    };
    responses: {
      /** @description Seeds returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListSeedsResponse'];
        };
      };
    };
  };
  UpdateSeed: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateSeedRequest'];
      };
    };
    responses: {
      /** @description Seed updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedResponse'];
        };
      };
    };
  };
  ActivateSeed: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ActivateSeedRequest'];
      };
    };
    responses: {
      /** @description Seed activated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedResponse'];
        };
      };
    };
  };
  ArchiveSeed: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ArchiveSeedRequest'];
      };
    };
    responses: {
      /** @description Seed archived */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedResponse'];
        };
      };
    };
  };
  GetGrowth: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetGrowthRequest'];
      };
    };
    responses: {
      /** @description Growth data returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GrowthResponse'];
        };
      };
    };
  };
  RecordGrowth: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RecordGrowthRequest'];
      };
    };
    responses: {
      /** @description Growth recorded */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GrowthResponse'];
        };
      };
    };
  };
  RecordGrowthBatch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RecordGrowthBatchRequest'];
      };
    };
    responses: {
      /** @description Growth recorded */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GrowthResponse'];
        };
      };
    };
  };
  GetGrowthPhase: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetGrowthPhaseRequest'];
      };
    };
    responses: {
      /** @description Phase returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GrowthPhaseResponse'];
        };
      };
    };
  };
  GetCapabilityManifest: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCapabilityManifestRequest'];
      };
    };
    responses: {
      /** @description Manifest returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CapabilityManifestResponse'];
        };
      };
    };
  };
  RegisterSeedType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterSeedTypeRequest'];
      };
    };
    responses: {
      /** @description Seed type registered */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedTypeResponse'];
        };
      };
    };
  };
  GetSeedType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSeedTypeRequest'];
      };
    };
    responses: {
      /** @description Seed type found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedTypeResponse'];
        };
      };
    };
  };
  ListSeedTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSeedTypesRequest'];
      };
    };
    responses: {
      /** @description Seed types returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListSeedTypesResponse'];
        };
      };
    };
  };
  UpdateSeedType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateSeedTypeRequest'];
      };
    };
    responses: {
      /** @description Seed type updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedTypeResponse'];
        };
      };
    };
  };
  DeprecateSeedType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeprecateSeedTypeRequest'];
      };
    };
    responses: {
      /** @description Seed type deprecated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedTypeResponse'];
        };
      };
      /** @description Seed type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Seed type already deprecated */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UndeprecateSeedType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UndeprecateSeedTypeRequest'];
      };
    };
    responses: {
      /** @description Seed type restored */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedTypeResponse'];
        };
      };
      /** @description Seed type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Seed type is not deprecated */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteSeedType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteSeedTypeRequest'];
      };
    };
    responses: {
      /** @description Seed type deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Seed type is not deprecated */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Seed type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Non-archived seeds still exist for this type */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  InitiateBond: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InitiateBondRequest'];
      };
    };
    responses: {
      /** @description Bond initiated, awaiting confirmation */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BondResponse'];
        };
      };
    };
  };
  ConfirmBond: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConfirmBondRequest'];
      };
    };
    responses: {
      /** @description Bond confirmed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BondResponse'];
        };
      };
    };
  };
  GetBond: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBondRequest'];
      };
    };
    responses: {
      /** @description Bond found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BondResponse'];
        };
      };
    };
  };
  GetBondForSeed: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBondForSeedRequest'];
      };
    };
    responses: {
      /** @description Bond found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BondResponse'];
        };
      };
    };
  };
  GetBondPartners: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBondPartnersRequest'];
      };
    };
    responses: {
      /** @description Partners returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BondPartnersResponse'];
        };
      };
    };
  };
  getSpecies: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSpeciesRequest'];
      };
    };
    responses: {
      /** @description Species retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SpeciesResponse'];
        };
      };
      /** @description Species not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSpeciesByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSpeciesByCodeRequest'];
      };
    };
    responses: {
      /** @description Species retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SpeciesResponse'];
        };
      };
      /** @description Species not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listSpecies: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSpeciesRequest'];
      };
    };
    responses: {
      /** @description Species retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SpeciesListResponse'];
        };
      };
    };
  };
  listSpeciesByRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSpeciesByRealmRequest'];
      };
    };
    responses: {
      /** @description Species retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SpeciesListResponse'];
        };
      };
      /** @description Realm not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createStatusTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateStatusTemplateRequest'];
      };
    };
    responses: {
      /** @description Status template created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StatusTemplateResponse'];
        };
      };
      /** @description Invalid request (validation error) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Referenced game service or item template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Duplicate code for this game service, or max templates exceeded */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getStatusTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetStatusTemplateRequest'];
      };
    };
    responses: {
      /** @description Status template retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StatusTemplateResponse'];
        };
      };
      /** @description Status template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getStatusTemplateByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetStatusTemplateByCodeRequest'];
      };
    };
    responses: {
      /** @description Status template retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StatusTemplateResponse'];
        };
      };
      /** @description Status template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listStatusTemplates: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListStatusTemplatesRequest'];
      };
    };
    responses: {
      /** @description Status templates retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListStatusTemplatesResponse'];
        };
      };
    };
  };
  updateStatusTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateStatusTemplateRequest'];
      };
    };
    responses: {
      /** @description Status template updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StatusTemplateResponse'];
        };
      };
      /** @description Status template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  seedStatusTemplates: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SeedStatusTemplatesRequest'];
      };
    };
    responses: {
      /** @description Seed completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedStatusTemplatesResponse'];
        };
      };
      /** @description Invalid request (validation errors) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  grantStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GrantStatusRequest'];
      };
    };
    responses: {
      /** @description Status granted successfully (or stacked/refreshed/replaced) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GrantStatusResponse'];
        };
      };
      /** @description Status template or game service not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Grant rejected (max statuses, stack limit, ignore behavior, contract/item failure) */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  removeStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RemoveStatusRequest'];
      };
    };
    responses: {
      /** @description Status removed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StatusInstanceResponse'];
        };
      };
      /** @description Status instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  removeBySource: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RemoveBySourceRequest'];
      };
    };
    responses: {
      /** @description Statuses removed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RemoveStatusesResponse'];
        };
      };
    };
  };
  removeByCategory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RemoveByCategoryRequest'];
      };
    };
    responses: {
      /** @description Statuses cleansed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RemoveStatusesResponse'];
        };
      };
    };
  };
  hasStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HasStatusRequest'];
      };
    };
    responses: {
      /** @description Check completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HasStatusResponse'];
        };
      };
    };
  };
  listStatuses: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListStatusesRequest'];
      };
    };
    responses: {
      /** @description Statuses retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListStatusesResponse'];
        };
      };
    };
  };
  getStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetStatusRequest'];
      };
    };
    responses: {
      /** @description Status instance retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StatusInstanceResponse'];
        };
      };
      /** @description Status instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getEffects: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEffectsRequest'];
      };
    };
    responses: {
      /** @description Effects retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetEffectsResponse'];
        };
      };
    };
  };
  getSeedEffects: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSeedEffectsRequest'];
      };
    };
    responses: {
      /** @description Seed effects retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedEffectsResponse'];
        };
      };
    };
  };
  cleanupByOwner: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CleanupByOwnerRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CleanupResponse'];
        };
      };
    };
  };
  Compose: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ComposeRequest'];
      };
    };
    responses: {
      /** @description Storyline plan generated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ComposeResponse'];
        };
      };
      /** @description Invalid request (no valid archives, incompatible goal/genre) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Archive or snapshot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetPlan: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetPlanRequest'];
      };
    };
    responses: {
      /** @description Plan retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetPlanResponse'];
        };
      };
      /** @description Plan not found or expired */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListPlans: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListPlansRequest'];
      };
    };
    responses: {
      /** @description Plans listed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListPlansResponse'];
        };
      };
    };
  };
  CreateScenarioDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateScenarioDefinitionRequest'];
      };
    };
    responses: {
      /** @description Scenario definition created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScenarioDefinition'];
        };
      };
      /** @description Invalid request (validation error) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scenario with code already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetScenarioDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetScenarioDefinitionRequest'];
      };
    };
    responses: {
      /** @description Scenario definition retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetScenarioDefinitionResponse'];
        };
      };
      /** @description Scenario not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListScenarioDefinitions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListScenarioDefinitionsRequest'];
      };
    };
    responses: {
      /** @description Scenarios listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListScenarioDefinitionsResponse'];
        };
      };
    };
  };
  UpdateScenarioDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateScenarioDefinitionRequest'];
      };
    };
    responses: {
      /** @description Scenario updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScenarioDefinition'];
        };
      };
      /** @description Scenario not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Concurrent modification conflict */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeprecateScenarioDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeprecateScenarioDefinitionRequest'];
      };
    };
    responses: {
      /** @description Scenario deprecated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scenario not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TestScenarioTrigger: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TestScenarioRequest'];
      };
    };
    responses: {
      /** @description Test result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TestScenarioResponse'];
        };
      };
      /** @description Scenario not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetActiveScenarios: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetActiveScenariosRequest'];
      };
    };
    responses: {
      /** @description Active scenarios */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetActiveScenariosResponse'];
        };
      };
    };
  };
  GetScenarioHistory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetScenarioHistoryRequest'];
      };
    };
    responses: {
      /** @description Scenario history */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetScenarioHistoryResponse'];
        };
      };
    };
  };
  getCompressData: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCompressDataRequest'];
      };
    };
    responses: {
      /** @description Compressed data returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StorylineArchive'];
        };
      };
      /** @description No storyline data for character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAccountSubscriptions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAccountSubscriptionsRequest'];
      };
    };
    responses: {
      /** @description Subscriptions retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SubscriptionListResponse'];
        };
      };
    };
  };
  getSubscription: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSubscriptionRequest'];
      };
    };
    responses: {
      /** @description Subscription retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SubscriptionInfo'];
        };
      };
      /** @description Subscription not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cancelSubscription: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CancelSubscriptionRequest'];
      };
    };
    responses: {
      /** @description Subscription cancelled successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SubscriptionInfo'];
        };
      };
      /** @description Not authorized to cancel this subscription */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Subscription not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  answerPeer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AnswerPeerRequest'];
      };
    };
    responses: {
      /** @description SDP answer processed, peer notified */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not in voice:ringing state (no pending offers) */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Peer or room not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  requestBroadcastConsent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BroadcastConsentRequest'];
      };
    };
    responses: {
      /** @description Consent request sent to all participants */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BroadcastConsentStatus'];
        };
      };
      /** @description Room not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Broadcast already active or consent pending */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  respondBroadcastConsent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BroadcastConsentResponse'];
      };
    };
    responses: {
      /** @description Consent response recorded */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BroadcastConsentStatus'];
        };
      };
      /** @description Room not found or no pending consent request */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  stopBroadcast: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StopBroadcastConsentRequest'];
      };
    };
    responses: {
      /** @description Broadcast stopped */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Room not found or not broadcasting */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBroadcastStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BroadcastStatusRequest'];
      };
    };
    responses: {
      /** @description Broadcast status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BroadcastConsentStatus'];
        };
      };
      /** @description Room not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Website service status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StatusResponse'];
        };
      };
    };
  };
  getPageContent: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Page slug identifier */
        slug: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Page content retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PageContent'];
        };
      };
      /** @description Page not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getNews: {
    parameters: {
      query?: {
        /** @description Number of news items to return */
        limit?: number;
        /** @description Pagination offset */
        offset?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description News items retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['NewsResponse'];
        };
      };
    };
  };
  getDownloads: {
    parameters: {
      query?: {
        /** @description Filter by platform */
        platform?: components['schemas']['Platform'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Download links retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DownloadsResponse'];
        };
      };
    };
  };
  submitContact: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ContactRequest'];
      };
    };
    responses: {
      /** @description Contact form submitted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContactResponse'];
        };
      };
      /** @description Invalid form data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAccountProfile: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Account profile retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AccountProfile'];
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listPages: {
    parameters: {
      query?: {
        includeUnpublished?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Page list retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PageMetadata'][];
        };
      };
    };
  };
  createPage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PageContent'];
      };
    };
    responses: {
      /** @description Page created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PageContent'];
        };
      };
    };
  };
  updatePage: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        slug: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PageContent'];
      };
    };
    responses: {
      /** @description Page updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PageContent'];
        };
      };
    };
  };
  deletePage: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        slug: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Page deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSiteSettings: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Site settings retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SiteSettings'];
        };
      };
    };
  };
  updateSiteSettings: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SiteSettings'];
      };
    };
    responses: {
      /** @description Settings updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SiteSettings'];
        };
      };
    };
  };
  getTheme: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Theme configuration retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ThemeConfig'];
        };
      };
    };
  };
  updateTheme: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ThemeConfig'];
      };
    };
    responses: {
      /** @description Theme updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRealmTime: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmTimeRequest'];
      };
    };
    responses: {
      /** @description Current game time snapshot for the realm */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GameTimeSnapshot'];
        };
      };
      /** @description No clock initialized for this realm */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRealmTimeByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmTimeByCodeRequest'];
      };
    };
    responses: {
      /** @description Current game time snapshot for the realm */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GameTimeSnapshot'];
        };
      };
      /** @description Realm code not found or no clock initialized */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  batchGetRealmTimes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BatchGetRealmTimesRequest'];
      };
    };
    responses: {
      /** @description Game time snapshots for the requested realms */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BatchGetRealmTimesResponse'];
        };
      };
    };
  };
  getElapsedGameTime: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetElapsedGameTimeRequest'];
      };
    };
    responses: {
      /** @description Elapsed game time as raw seconds and decomposed calendar units */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetElapsedGameTimeResponse'];
        };
      };
      /** @description No clock initialized for this realm */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  triggerTimeSync: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TriggerTimeSyncRequest'];
      };
    };
    responses: {
      /** @description Time sync triggered successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TriggerTimeSyncResponse'];
        };
      };
      /** @description No clock initialized for this realm */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  initializeRealmClock: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InitializeRealmClockRequest'];
      };
    };
    responses: {
      /** @description Realm clock initialized successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InitializeRealmClockResponse'];
        };
      };
      /** @description Both calendarTemplateCode and DefaultCalendarTemplateCode config are null */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Realm or calendar template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Clock already initialized for this realm */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  setTimeRatio: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SetTimeRatioRequest'];
      };
    };
    responses: {
      /** @description Time ratio changed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SetTimeRatioResponse'];
        };
      };
      /** @description No clock initialized for this realm */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  advanceClock: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AdvanceClockRequest'];
      };
    };
    responses: {
      /** @description Clock advanced successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AdvanceClockResponse'];
        };
      };
      /** @description No advancement amount specified */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description No clock initialized for this realm */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  seedCalendar: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SeedCalendarRequest'];
      };
    };
    responses: {
      /** @description Calendar template created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CalendarTemplateResponse'];
        };
      };
      /** @description Structural validation failed (period gaps, season-month mismatch, etc.) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game service not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Template code already exists for this game service or max calendars exceeded */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCalendar: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCalendarRequest'];
      };
    };
    responses: {
      /** @description Calendar template found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CalendarTemplateResponse'];
        };
      };
      /** @description Calendar template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listCalendars: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListCalendarsRequest'];
      };
    };
    responses: {
      /** @description Calendar templates listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListCalendarsResponse'];
        };
      };
    };
  };
  updateCalendar: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateCalendarRequest'];
      };
    };
    responses: {
      /** @description Calendar template updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CalendarTemplateResponse'];
        };
      };
      /** @description Structural validation failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Calendar template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteCalendar: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteCalendarRequest'];
      };
    };
    responses: {
      /** @description Calendar template deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteCalendarResponse'];
        };
      };
      /** @description Calendar template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Active realm clocks reference this template */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRealmConfig: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmConfigRequest'];
      };
    };
    responses: {
      /** @description Realm configuration found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmConfigResponse'];
        };
      };
      /** @description No clock initialized for this realm */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateRealmConfig: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateRealmConfigRequest'];
      };
    };
    responses: {
      /** @description Realm configuration updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmConfigResponse'];
        };
      };
      /** @description No clock initialized for this realm or calendar template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRealmClocks: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRealmClocksRequest'];
      };
    };
    responses: {
      /** @description Realm clocks listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListRealmClocksResponse'];
        };
      };
    };
  };
}
