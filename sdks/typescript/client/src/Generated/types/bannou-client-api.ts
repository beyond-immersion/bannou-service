/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/account/profile/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update account profile */
    post: operations['updateProfile'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/account/password/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update account password hash */
    post: operations['updatePasswordHash'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/account/verification/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update email verification status */
    post: operations['updateVerificationStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/definition/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new achievement definition
     * @description Create a new achievement with specified criteria and platform mappings.
     *     Developer-only endpoint.
     */
    post: operations['createAchievementDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/definition/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List achievement definitions
     * @description List achievements for a game service with optional platform filtering.
     */
    post: operations['listAchievementDefinitions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/definition/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update achievement definition
     * @description Update properties of an existing achievement.
     *     Developer-only endpoint.
     */
    post: operations['updateAchievementDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/definition/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete achievement definition
     * @description Delete an achievement. Earned instances are preserved in history.
     *     Developer-only endpoint.
     */
    post: operations['deleteAchievementDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/progress/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get entity's achievement progress
     * @description Get progress for an entity across all achievements or a specific one.
     */
    post: operations['getAchievementProgress'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/list-unlocked': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List unlocked achievements
     * @description Get all achievements unlocked by an entity.
     */
    post: operations['listUnlockedAchievements'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/template/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create an actor template (category definition) */
    post: operations['CreateActorTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/template/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update an actor template */
    post: operations['UpdateActorTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/template/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Delete an actor template */
    post: operations['DeleteActorTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/spawn': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Spawn a new actor from a template */
    post: operations['SpawnActor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Stop a running actor */
    post: operations['StopActor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/inject-perception': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Inject a perception event into an actor's queue (testing)
     * @description Injects a perception event directly into the actor's perception queue
     *     for testing purposes. Useful for testing actor behavior without a
     *     full game server setup.
     */
    post: operations['InjectPerception'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/encounter/start': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Start an encounter managed by an Event Brain actor
     * @description Initializes an encounter with the specified participants. The Event Brain actor
     *     will coordinate the encounter, sending instructions to participant NPC Brain actors
     *     via their character perception channels.
     */
    post: operations['StartEncounter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/encounter/update-phase': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update the phase of an active encounter
     * @description Updates the phase of an encounter being managed by an Event Brain actor.
     *     Phase changes are logged and can trigger behavior changes in participant actors.
     */
    post: operations['UpdateEncounterPhase'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/encounter/end': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * End an active encounter
     * @description Ends an encounter being managed by an Event Brain actor. This clears the
     *     encounter state and allows the actor to manage a new encounter.
     */
    post: operations['EndEncounter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/upload/request': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request upload URL for a new asset
     * @description Generate a pre-signed URL for uploading a new asset directly to storage.
     *     For large files (>50MB), returns multipart upload configuration.
     */
    post: operations['requestUpload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/upload/complete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Mark upload as complete, trigger processing
     * @description Called after the client has uploaded the file to the pre-signed URL.
     *     Triggers the asset processing pipeline (texture conversion, model validation, etc.)
     *     and emits completion events via WebSocket.
     */
    post: operations['completeUpload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get asset metadata and download URL
     * @description Retrieve asset metadata and generate a pre-signed download URL.
     *     Specify version to download a specific version, or omit for latest.
     */
    post: operations['getAsset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/list-versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all versions of an asset
     * @description Retrieve version history for an asset with pagination.
     *     Includes version IDs, creation timestamps, and archive status.
     */
    post: operations['listAssetVersions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Search assets by tags, type, or realm
     * @description Search assets using various filters with pagination.
     *     All filters are optional and combine with AND logic.
     */
    post: operations['searchAssets'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create asset bundle from multiple assets
     * @description Create a .bannou bundle containing multiple assets.
     *     For large bundles, processing is delegated to the processing pool.
     *     Completion notification sent via WebSocket event.
     */
    post: operations['createBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get bundle manifest and download URL
     * @description Retrieve bundle metadata and generate a pre-signed download URL.
     *     Supports both native .bannou format and ZIP conversion (cached).
     */
    post: operations['getBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/upload/request': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request upload URL for a pre-made bundle
     * @description Upload a pre-built bundle (.bannou or .zip format).
     *     After upload, the bundle undergoes validation before registration.
     */
    post: operations['requestBundleUpload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/metabundle/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create metabundle from source bundles
     * @description Compose a metabundle by extracting and repackaging assets from multiple
     *     source bundles. The resulting metabundle is a complete physical copy with
     *     provenance metadata tracking the source bundles.
     *
     *     Assets are deduplicated by content hash. If the same asset ID exists in
     *     multiple source bundles with different content hashes, the request fails
     *     with conflict details.
     */
    post: operations['createMetabundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/job/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get async metabundle job status
     * @description Poll the status of an async metabundle creation job.
     *     Use the jobId returned from createMetabundle when status was 'queued'.
     *
     *     Clients can either poll this endpoint or wait for the
     *     MetabundleCreationCompleteEvent via WebSocket for completion notification.
     */
    post: operations['getJobStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/job/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel an async metabundle job
     * @description Cancel a pending or processing metabundle creation job.
     *     Jobs that are already completed (ready or failed) cannot be cancelled.
     *
     *     Successfully cancelled jobs will emit a MetabundleCreationCompleteEvent
     *     with status 'cancelled' via WebSocket.
     */
    post: operations['cancelJob'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/resolve': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Compute optimal bundles for requested assets
     * @description Given a list of asset IDs, compute the optimal set of bundles to download
     *     to obtain all requested assets with minimal transfers.
     *
     *     The algorithm uses greedy set-cover optimization:
     *     1. Find all bundles containing requested assets
     *     2. Select bundles that cover the most uncovered assets
     *     3. Prefer metabundles when coverage is equal (tie-breaker)
     *     4. Include standalone assets for any remaining unresolved IDs
     *
     *     Returns pre-signed download URLs for all selected bundles and assets.
     */
    post: operations['resolveBundles'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/query/by-asset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find all bundles containing a specific asset
     * @description Query the reverse index to find all bundles (source and metabundle)
     *     that contain a specific asset ID. Useful for understanding asset
     *     distribution and debugging resolution issues.
     */
    post: operations['queryBundlesByAsset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update bundle metadata
     * @description Update metadata for an existing bundle (name, description, tags).
     *     Does not modify bundle contents - for that, create a new bundle.
     *
     *     Increments the bundle version and records the change in version history.
     *     Only the bundle owner or admin can update.
     */
    post: operations['updateBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Soft-delete a bundle
     * @description Soft-delete a bundle, marking it as deleted but retaining data
     *     for the configured retention period (default 30 days).
     *
     *     Deleted bundles are excluded from resolution and queries by default.
     *     Use permanent=true for immediate, unrecoverable deletion (admin only).
     *
     *     Only the bundle owner or admin can delete.
     */
    post: operations['deleteBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/restore': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Restore a soft-deleted bundle
     * @description Restore a bundle that was soft-deleted, making it active again.
     *     Can only restore bundles within their retention period.
     *
     *     Only the bundle owner or admin can restore.
     */
    post: operations['restoreBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query bundles with advanced filters
     * @description Query bundles with flexible filtering options including:
     *     - Tag matching (exact, exists, not exists)
     *     - Status filtering (active, deleted)
     *     - Date range filtering
     *     - Name search (contains)
     *     - Owner filtering
     *     - Realm and bundle type filtering
     *
     *     Supports pagination and sorting.
     */
    post: operations['queryBundles'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/list-versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List version history for a bundle
     * @description Get the version history for a bundle, showing all metadata changes
     *     over time. Each version record includes:
     *     - Version number
     *     - When the change was made
     *     - Who made the change
     *     - What changed
     *     - Optional reason for the change
     *
     *     The current version's full metadata snapshot is always included.
     */
    post: operations['listBundleVersions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/bulk-get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Batch asset metadata lookup
     * @description Retrieve metadata for multiple assets in a single request.
     *     Optionally includes pre-signed download URLs.
     *     Maximum 100 asset IDs per request.
     */
    post: operations['bulkGetAssets'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/login': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Login with email/password */
    post: operations['login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/register': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Register new user account */
    post: operations['register'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/oauth/{provider}/init': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Initialize OAuth2 flow (browser redirect)
     * @description Browser-facing endpoint for initiating OAuth flows. The user's browser navigates
     *     to this URL directly, which then redirects to the OAuth provider.
     *
     *     **Note**: This endpoint uses GET with path parameters because it's a browser
     *     redirect flow, not a WebSocket-routed API call.
     */
    get: operations['initOAuth'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/oauth/{provider}/callback': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Complete OAuth2 flow (browser redirect callback)
     * @description Browser-facing callback endpoint for OAuth providers. The OAuth provider redirects
     *     the user's browser back to this URL after authentication.
     *
     *     **Note**: This endpoint uses path parameters because the callback URL is registered
     *     with OAuth providers and cannot be changed without updating provider configurations.
     */
    post: operations['completeOAuth'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/steam/verify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Verify Steam Session Ticket
     * @description Validates a Steam Session Ticket obtained from the game client via ISteamUser::GetAuthTicketForWebApi().
     *     The server validates the ticket with Steam's Web API and retrieves the SteamID from Steam's response.
     *     NEVER trust client-provided SteamID - it must come from Steam's authenticated response.
     */
    post: operations['verifySteamAuth'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/refresh': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Refresh access token */
    post: operations['refreshToken'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Validate access token */
    post: operations['validateToken'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/logout': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Logout and invalidate tokens */
    post: operations['logout'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/sessions/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get active sessions for account */
    post: operations['getSessions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/sessions/terminate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Terminate specific session */
    post: operations['terminateSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/password/reset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Request password reset */
    post: operations['requestPasswordReset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/password/confirm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Confirm password reset with token */
    post: operations['confirmPasswordReset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/providers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List available authentication providers
     * @description Returns a list of available OAuth and authentication providers based on server configuration.
     *     Providers are only listed if their client credentials are configured.
     *     Steam authentication uses session tickets, not OAuth, but is included for completeness.
     */
    post: operations['listProviders'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/compile': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Compile ABML behavior definition
     * @description Compiles a YAML-based ABML behavior definition into executable behavior trees.
     *     Handles stackable behavior sets, cultural adaptations, and context variable resolution.
     */
    post: operations['CompileAbmlBehavior'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate ABML definition
     * @description Validates ABML YAML against schema and checks for semantic correctness.
     *     Includes context variable validation and service dependency checking.
     */
    post: operations['ValidateAbml'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cache/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get cached compiled behavior
     * @description Retrieves a previously compiled behavior from the cache.
     *     Used for performance optimization in high-frequency behavior execution.
     */
    post: operations['GetCachedBehavior'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cache/invalidate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Invalidate cached behavior
     * @description Removes a behavior from the cache, forcing recompilation on next access.
     *     Used when behavior definitions are updated.
     */
    post: operations['InvalidateCachedBehavior'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/goap/plan': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate GOAP plan
     * @description Generates a GOAP plan to achieve a goal from the current world state.
     *     Uses A* search to find the optimal sequence of actions.
     */
    post: operations['GenerateGoapPlan'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/goap/validate-plan': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate existing GOAP plan
     * @description Validates an existing GOAP plan against the current world state.
     *     Returns whether the plan is still valid or needs replanning.
     */
    post: operations['ValidateGoapPlan'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get character by ID */
    post: operations['getCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** List characters with filtering */
    post: operations['listCharacters'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/get-enriched': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get character with optional related data (personality, backstory, family)
     * @description Retrieves a character with optional include flags for related data.
     *     Use this endpoint when you need aggregated character data from multiple services.
     *     Each included dataset is fetched from its respective service.
     */
    post: operations['getEnrichedCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/get-archive': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get compressed archive data for a character */
    post: operations['getCharacterArchive'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/by-realm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get all characters in a realm (primary query pattern) */
    post: operations['getCharactersByRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/type/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get encounter type by code
     * @description Retrieve an encounter type by its unique code.
     */
    post: operations['getEncounterType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/type/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all encounter types
     * @description Retrieve all encounter types including built-in and custom types.
     */
    post: operations['listEncounterTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/query/by-character': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get character's encounters (paginated)
     * @description Retrieves all encounters for a character with optional filtering.
     *     Memory decay is applied lazily on access.
     */
    post: operations['queryByCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/query/between': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get encounters between two characters
     * @description Retrieves all encounters between two specific characters.
     *     Useful for relationship history and dialogue context.
     */
    post: operations['queryBetween'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/query/by-location': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Recent encounters at location
     * @description Retrieves recent encounters at a specific location.
     *     Useful for scene context and area history.
     */
    post: operations['queryByLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/has-met': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Quick check if two characters have met
     * @description Fast boolean check for whether two characters have any recorded encounters.
     *     Does not apply memory decay or return encounter details.
     */
    post: operations['hasMet'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/get-sentiment': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Aggregate sentiment toward another character
     * @description Calculates the aggregate sentiment a character has toward another based
     *     on all their encounters. Memory strength is factored into the calculation.
     */
    post: operations['getSentiment'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/get-perspective': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get character's view of encounter
     * @description Retrieves a specific character's perspective on an encounter.
     *     Includes emotional impact, sentiment shift, and memory strength.
     */
    post: operations['getPerspective'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-history/get-participation': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all historical events a character participated in
     * @description Retrieves all historical event participation records for a character.
     *     Supports filtering by event category and minimum significance.
     */
    post: operations['getParticipation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-history/get-event-participants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all characters who participated in a historical event
     * @description Retrieves all characters who participated in a specific historical event.
     *     Useful for generating event summaries or finding related characters.
     */
    post: operations['getEventParticipants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-history/get-backstory': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get machine-readable backstory elements for behavior system
     * @description Retrieves structured backstory elements for a character. These elements
     *     are machine-readable key-value pairs used by the behavior system for
     *     decision-making, not narrative text for players.
     */
    post: operations['getBackstory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-personality/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get personality for a character
     * @description Retrieves the personality profile for a character. Returns 404 if no
     *     personality has been defined for this character.
     */
    post: operations['getPersonality'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-personality/get-combat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get combat preferences for a character
     * @description Retrieves the combat preferences for a character. Combat preferences
     *     influence tactical decisions in the behavior system, including engagement
     *     style, positioning, and retreat conditions.
     */
    post: operations['getCombatPreferences'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/client-capabilities': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get client capability manifest (GUID â†’ API mappings)
     * @description Returns the capability manifest for the authenticated client's session.
     *     Maps client-salted GUIDs to available API endpoints based on the client's
     *     current permissions and session state.
     *
     *     **Security**: Each client receives unique GUIDs for the same API endpoints.
     *     This prevents cross-session exploitation and enables per-client rate limiting.
     *
     *     **Dynamic Updates**: Capabilities may change during a session when:
     *     - Role changes occur (admin promotion, etc.)
     *     - Subscription status changes
     *     - Session state transitions
     *
     *     Clients should listen for capability update events via WebSocket to stay current.
     */
    post: operations['getClientCapabilities'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Natural language documentation search
     * @description Search documentation using natural language queries.
     *     Returns the most relevant documents with voice-friendly summaries.
     */
    post: operations['queryDocumentation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get specific document by ID or slug
     * @description Retrieve a specific document by its unique identifier or slug.
     *     Returns full content with metadata.
     */
    post: operations['getDocument'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Full-text keyword search
     * @description Search documentation using exact keyword matching.
     *     Faster than semantic search but less flexible.
     */
    post: operations['searchDocumentation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List documents by category
     * @description List all documents in a specific category or all categories.
     *     Supports pagination for large result sets.
     */
    post: operations['listDocuments'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/suggest': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get related topics and follow-up suggestions
     * @description Given a topic or document ID, returns related topics the user
     *     might want to explore. Useful for conversational AI flow.
     */
    post: operations['suggestRelatedTopics'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/bind': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Bind a git repository to a documentation namespace
     * @description Bind a git repository URL to a documentation namespace.
     *     The namespace will be exclusively managed by the repository - manual edits will be blocked.
     *     Triggers initial sync after binding.
     */
    post: operations['bindRepository'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/sync': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Manually trigger repository sync
     * @description Manually trigger synchronization of a bound repository.
     *     If force=true, performs full re-sync regardless of commit hash.
     */
    post: operations['syncRepository'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get repository binding status
     * @description Get current status of a repository binding including sync state and statistics.
     */
    post: operations['getRepositoryStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all repository bindings
     * @description List all repository bindings with optional filtering by status.
     */
    post: operations['listRepositoryBindings'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update repository binding configuration
     * @description Update sync settings, file patterns, category mappings, or archive configuration.
     */
    post: operations['updateRepositoryBinding'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/archive/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create documentation archive
     * @description Create a .bannou bundle archive of all documents in a namespace.
     *     Archives are stored via Asset Service.
     */
    post: operations['createDocumentationArchive'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/archive/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List documentation archives
     * @description List all archives for a namespace.
     */
    post: operations['listDocumentationArchives'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/game-service/services/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all registered game services
     * @description Returns all game services, optionally filtered by active status.
     */
    post: operations['listServices'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/game-service/services/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get service by ID or stub name
     * @description Retrieves a single service by either serviceId (GUID) or stubName.
     */
    post: operations['getService'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get game session details
     * @description Get details of the current game session the user has joined.
     */
    post: operations['getGameSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/leave': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Leave a game session */
    post: operations['leaveGameSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/chat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Send chat message to game session */
    post: operations['sendChatMessage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/actions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Perform game action (enhanced permissions after joining) */
    post: operations['performGameAction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/leave-session': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Leave a specific game session by ID
     * @description Leave a game session by its session ID. This is the session-specific alternative
     *     to /sessions/leave which uses gameType. Useful for matchmade sessions.
     */
    post: operations['leaveGameSessionById'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/definition/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new leaderboard definition
     * @description Create a new leaderboard with specified properties.
     *     Developer-only endpoint for setting up game leaderboards.
     */
    post: operations['createLeaderboardDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/definition/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update leaderboard definition
     * @description Update properties of an existing leaderboard.
     *     Developer-only endpoint.
     */
    post: operations['updateLeaderboardDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/definition/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete leaderboard definition
     * @description Delete a leaderboard and all its scores.
     *     Developer-only endpoint. This action is irreversible.
     */
    post: operations['deleteLeaderboardDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/rank/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get entity's rank
     * @description Get the current rank and score for a specific entity.
     */
    post: operations['getEntityRank'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/rank/top': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get top entries
     * @description Get the top N entries on a leaderboard.
     */
    post: operations['getTopRanks'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/rank/around': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get entries around entity
     * @description Get leaderboard entries surrounding a specific entity.
     *     Useful for showing a player's position with nearby competitors.
     */
    post: operations['getRanksAround'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/season/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current season info
     * @description Get information about the current or a specific past season.
     */
    post: operations['getSeason'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get location by ID */
    post: operations['getLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get location by code and realm
     * @description Retrieve a location using its unique code within a specific realm
     */
    post: operations['getLocationByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List locations with filtering
     * @description Retrieve locations with optional realm, parent, and type filtering
     */
    post: operations['listLocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list-by-realm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all locations in a realm (primary query pattern)
     * @description Returns all locations within a specific realm, optionally filtered by
     *     location type and parent. This is the primary access pattern for
     *     realm-scoped location queries.
     */
    post: operations['listLocationsByRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list-by-parent': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get child locations for a parent location
     * @description Retrieve all locations that have the specified location as their parent.
     *     Useful for getting all cities in a region, all buildings in a city, etc.
     */
    post: operations['listLocationsByParent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list-root': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get root locations in a realm
     * @description Returns all top-level locations in a realm (locations with no parent).
     *     These are typically regions or major areas within the realm.
     */
    post: operations['listRootLocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get-ancestors': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all ancestors of a location
     * @description Returns the full ancestry chain from the specified location up to the
     *     root location (parentLocationId=null). For example, for a specific building
     *     might return [district, city, region].
     */
    post: operations['getLocationAncestors'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get-descendants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all descendants of a location
     * @description Returns all locations that are descendants of the specified location
     *     (direct children, grandchildren, etc.). Useful for finding all places
     *     within a region or city.
     */
    post: operations['getLocationDescendants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/exists': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if location exists and is active
     * @description Fast validation endpoint for other services to check location validity.
     *     Returns true if location exists and is not deprecated, false otherwise.
     */
    post: operations['locationExists'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/request-snapshot': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request full snapshot for cold start
     * @description Consumers use this when starting up to get initial state.
     *     Returns current snapshot of requested region/kinds.
     *     For very large maps, payloadRef points to lib-asset storage.
     */
    post: operations['requestSnapshot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/point': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query map data at a specific point
     * @description Returns all map data at a point across requested kinds.
     *     Used by behavior stacks for contextual decisions.
     *     Optionally includes objects within radius.
     */
    post: operations['queryPoint'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/bounds': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query map data within bounds
     * @description Returns map data within a bounding box.
     *     For event actors needing region overview.
     *     Limited to maxObjects per kind.
     */
    post: operations['queryBounds'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/objects-by-type': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find all objects of a type in region
     * @description Returns all objects matching an objectType filter.
     *     For event actors asking "where are all the boulder clusters?"
     */
    post: operations['queryObjectsByType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/affordance': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find locations that afford a specific action or scene type
     * @description Affordance queries answer "where can I do X?" by combining
     *     multiple map kinds and applying game-specific scoring logic.
     *
     *     Used by Event Brain for procedural scene orchestration:
     *     - "Find ambush locations"
     *     - "Find dramatic reveal spots"
     *     - "Find sheltered rest areas"
     *
     *     Well-known types have predefined scoring; use affordanceType=custom
     *     with customAffordance for novel scenarios.
     */
    post: operations['queryAffordance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/authoring/checkout': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Acquire exclusive edit lock for design-time editing
     * @description For level editors and design tools only.
     *     Game servers do NOT use this - they use create-channel for implicit authority.
     *     Returns authority token for publishing edits.
     */
    post: operations['checkoutForAuthoring'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/authoring/commit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Commit design-time changes
     * @description Commits pending changes and releases the checkout lock.
     *     Optionally includes a commit message for history.
     */
    post: operations['commitAuthoring'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/authoring/release': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Release authoring checkout without committing
     * @description Discards pending changes and releases the checkout lock.
     *     Use when abandoning edits.
     */
    post: operations['releaseAuthoring'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a map definition template
     * @description Creates a new map definition (template) that describes the structure
     *     of a region. Definitions are templates that can be used to bootstrap
     *     channels with predefined layer configurations.
     */
    post: operations['createDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a map definition by ID
     * @description Returns the full map definition including all layer configurations.
     */
    post: operations['getDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List map definitions with optional filters
     * @description Returns a paginated list of map definitions.
     */
    post: operations['listDefinitions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a map definition
     * @description Updates an existing map definition. Cannot change the definition ID.
     *     Layer configurations can be modified.
     */
    post: operations['updateDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/queue/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List available matchmaking queues
     * @description List all available matchmaking queues that players can join.
     *     Returns queue configuration details including skill settings.
     */
    post: operations['listQueues'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/queue/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get queue details
     * @description Get detailed configuration for a specific matchmaking queue.
     */
    post: operations['getQueue'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/join': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Join matchmaking queue
     * @description Join a matchmaking queue with specified properties and query.
     *     Creates a matchmaking ticket and begins searching for compatible players.
     *     Returns immediately after ticket creation. Match results are delivered
     *     via WebSocket push events.
     */
    post: operations['joinMatchmaking'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/leave': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Leave matchmaking queue
     * @description Leave a matchmaking queue and cancel the ticket.
     *     Only available when actively in a queue (shortcut/prebound).
     */
    post: operations['leaveMatchmaking'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get matchmaking status
     * @description Get current matchmaking status for the player's active ticket.
     *     Only available when actively in a queue (shortcut/prebound).
     */
    post: operations['getMatchmakingStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/accept': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Accept a formed match
     * @description Accept a match that has been formed. Only available when a match
     *     is pending acceptance (shortcut/prebound after match formation).
     *     All players must accept within the timeout for the match to start.
     */
    post: operations['acceptMatch'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/decline': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Decline a formed match
     * @description Decline a match that has been formed. Only available when a match
     *     is pending acceptance (shortcut/prebound after match formation).
     *     Declining cancels the match for all participants.
     */
    post: operations['declineMatch'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/stats': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get queue statistics
     * @description Get operational statistics for matchmaking queues.
     *     Includes queue depths, average wait times, and match rates.
     */
    post: operations['getMatchmakingStats'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/generate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate composition from style and constraints
     * @description Generates a complete musical composition using the specified style definition
     *     and compositional constraints. Returns MIDI-JSON format output.
     */
    post: operations['GenerateComposition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate MIDI-JSON structure
     * @description Validates a MIDI-JSON structure for correctness including note ranges,
     *     timing, and format compliance.
     */
    post: operations['ValidateMidiJson'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/style/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get style definition
     * @description Retrieves a style definition by ID or name. Styles define mode preferences,
     *     interval rules, form templates, and genre-specific parameters.
     */
    post: operations['GetStyle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/style/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List available styles
     * @description Lists all available style definitions with optional filtering by category.
     */
    post: operations['ListStyles'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/theory/progression': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate chord progression
     * @description Generates a chord progression using harmonic function theory.
     *     Supports multiple harmonic styles including functional harmony,
     *     modal interchange, and jazz voicings.
     */
    post: operations['GenerateProgression'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/theory/melody': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate melody over harmony
     * @description Generates a melodic line over a chord progression using contour rules,
     *     interval preferences, and rhythmic patterns from the specified style.
     */
    post: operations['GenerateMelody'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/theory/voice-lead': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Apply voice leading to chords
     * @description Applies voice leading rules to a chord sequence, ensuring smooth
     *     part-writing according to traditional or style-specific rules.
     */
    post: operations['ApplyVoiceLeading'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get realm by ID */
    post: operations['getRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get realm by code
     * @description Retrieve a realm using its unique code (e.g., "OMEGA", "ARCADIA", "FANTASIA")
     */
    post: operations['getRealmByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all realms
     * @description Retrieve all realms with optional filtering
     */
    post: operations['listRealms'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm/exists': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if realm exists and is active
     * @description Fast validation endpoint for other services to check realm validity.
     *     Returns true if realm exists and is not deprecated, false otherwise.
     */
    post: operations['realmExists'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm-history/get-participation': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all historical events a realm participated in
     * @description Retrieves all historical event participation records for a realm.
     *     Supports filtering by event category and minimum impact.
     */
    post: operations['getRealmParticipation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm-history/get-event-participants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all realms that participated in a historical event
     * @description Retrieves all realms that participated in a specific historical event.
     *     Useful for generating event summaries or finding related realms.
     */
    post: operations['getRealmEventParticipants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm-history/get-lore': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get machine-readable lore elements for behavior system
     * @description Retrieves structured lore elements for a realm. These elements
     *     are machine-readable key-value pairs used by the behavior system for
     *     decision-making, not narrative text for players.
     */
    post: operations['getRealmLore'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get a relationship by ID */
    post: operations['getRelationship'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/list-by-entity': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all relationships for an entity
     * @description Returns all relationships where the specified entity is either
     *     entity1 or entity2. Supports filtering by relationship type,
     *     other entity type, and whether to include ended relationships.
     */
    post: operations['listRelationshipsByEntity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/get-between': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all relationships between two specific entities
     * @description Returns all relationships that exist between two specific entities,
     *     regardless of which is entity1 or entity2.
     */
    post: operations['getRelationshipsBetween'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/list-by-type': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all relationships of a specific type
     * @description Returns all relationships that use a specific relationship type.
     *     Useful for finding all "FRIEND" relationships, for example.
     */
    post: operations['listRelationshipsByType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get relationship type by ID */
    post: operations['getRelationshipType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get relationship type by code
     * @description Retrieve a relationship type using its unique code (e.g., "SON", "MOTHER", "FRIEND")
     */
    post: operations['getRelationshipTypeByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all relationship types
     * @description Retrieve all relationship types with optional hierarchy filtering
     */
    post: operations['listRelationshipTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get-children': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get child types for a parent type
     * @description Retrieve all relationship types that have the specified type as their parent
     */
    post: operations['getChildRelationshipTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/matches-hierarchy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if type matches ancestor in hierarchy
     * @description Checks if a relationship type matches or descends from an ancestor type.
     *     For example, "SON" matches "CHILD" because CHILD is an ancestor of SON.
     *     This enables queries like "find all CHILD relationships" to match SON, DAUGHTER, etc.
     */
    post: operations['matchesHierarchy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get-ancestors': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all ancestors of a relationship type
     * @description Returns the full ancestry chain from the specified type up to the root.
     *     For example, for "SON" might return ["CHILD", "FAMILY"].
     */
    post: operations['getAncestors'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create or configure a save slot
     * @description Creates a new save slot or updates configuration of an existing slot.
     *     Slots are auto-created on first save, but pre-creation allows setting
     *     custom configuration (max versions, retention policy, etc.).
     */
    post: operations['CreateSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get slot metadata
     * @description Returns slot configuration and version summary.
     */
    post: operations['GetSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List slots for owner
     * @description Returns all slots owned by the specified entity.
     */
    post: operations['ListSlots'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete slot and all versions
     * @description Permanently deletes a slot and all save versions within it.
     *     This is irreversible. Requires owner access or admin role.
     */
    post: operations['DeleteSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/rename': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Rename a save slot
     * @description Renames an existing slot without affecting its versions or data.
     *     The new name must not already exist for this owner.
     */
    post: operations['RenameSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/save': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Save data to slot
     * @description Creates a new version in the specified slot with the provided data.
     *     If the slot doesn't exist, it's auto-created with default configuration.
     *
     *     Large saves (>1MB by default) are automatically compressed.
     *     Rolling version cleanup is applied based on slot configuration.
     */
    post: operations['Save'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/load': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Load data from slot
     * @description Retrieves save data from the specified slot. By default, loads the
     *     latest version. Optionally specify a version number or checkpoint name.
     */
    post: operations['Load'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/save-delta': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Save incremental changes from base version
     * @description Creates a new version by applying a delta (patch) to a base version.
     *     Significantly reduces storage for large saves with small incremental changes.
     *
     *     Uses JSON Patch (RFC 6902) by default. The implementation is designed to
     *     allow swapping to binary diff algorithms (bsdiff/xdelta) if needed for
     *     specific use cases (e.g., binary game state).
     *
     *     Delta versions store only the patch; full data is reconstructed on load.
     */
    post: operations['SaveDelta'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/load-with-deltas': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Load save reconstructing from delta chain
     * @description Loads save data, automatically reconstructing from delta chain if needed.
     *     Returns the full reconstructed data, not the raw delta.
     *
     *     For performance, the service may cache reconstructed data or collapse
     *     delta chains during background cleanup.
     */
    post: operations['LoadWithDeltas'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/collapse-deltas': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Collapse delta chain into full snapshot
     * @description Collapses a chain of delta versions into a single full snapshot.
     *     Useful for reducing load latency or before deleting base versions.
     */
    post: operations['CollapseDeltas'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List versions in slot
     * @description Returns all versions in a slot with metadata.
     */
    post: operations['ListVersions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/pin': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Pin a version as checkpoint
     * @description Pins a specific version, excluding it from rolling cleanup.
     *     Optionally assigns a checkpoint name for easy retrieval.
     */
    post: operations['PinVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/unpin': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Unpin a version
     * @description Removes pin from a version, making it eligible for rolling cleanup.
     */
    post: operations['UnpinVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete specific version
     * @description Permanently deletes a specific version from a slot.
     *     Cannot delete pinned versions; unpin first.
     */
    post: operations['DeleteVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query saves with filters
     * @description Search and filter saves across slots. Supports filtering by owner,
     *     category, date range, metadata, and more. Paginated results.
     */
    post: operations['QuerySaves'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/copy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Copy save to different slot or owner
     * @description Copies a save version to a different slot or owner.
     *     Can copy to same owner (different slot) or different owner (with admin).
     */
    post: operations['CopySave'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Export saves for backup/portability
     * @description Exports one or more slots with all versions as a downloadable archive.
     *     Returns a pre-signed URL to download the export bundle.
     */
    post: operations['ExportSaves'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/verify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Verify save data integrity
     * @description Verifies the integrity of stored save data by comparing content hash
     *     against the stored SHA-256 hash. Detects corruption or tampering.
     */
    post: operations['VerifyIntegrity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/promote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Promote old version to latest
     * @description Creates a new version from an existing older version, effectively
     *     "promoting" it to be the latest. Useful for rollback scenarios.
     */
    post: operations['PromoteVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/migrate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Migrate save to new schema version
     * @description Applies migration handlers to upgrade a save from one schema version
     *     to another. Creates a new version with the migrated data.
     */
    post: operations['MigrateSave'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/schema/register': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Register a save data schema
     * @description Registers a JSON schema for validation of save data.
     *     Optionally includes migration handlers from previous versions.
     */
    post: operations['RegisterSchema'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/schema/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List registered schemas
     * @description Returns all registered schemas for a game/namespace.
     */
    post: operations['ListSchemas'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new scene document
     * @description Creates a new scene document and stores it in lib-asset.
     *     Publishes scene.created event on success.
     *     Returns Conflict if a scene with the same sceneId already exists.
     */
    post: operations['createScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Retrieve a scene by ID
     * @description Retrieves a scene document. Optionally resolves nested scene references
     *     up to a configurable depth.
     */
    post: operations['getScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List scenes with filtering
     * @description Lists scenes matching the provided filters. Supports pagination.
     *     Results are ordered by updatedAt descending (most recent first).
     */
    post: operations['listScenes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a scene document
     * @description Updates an existing scene document. Scene must not be checked out by
     *     another user. Increments the PATCH version automatically.
     *     Publishes scene.updated event on success.
     */
    post: operations['updateScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a scene
     * @description Soft-deletes a scene. The scene data remains recoverable via lib-asset
     *     for approximately 30 days. Cannot delete if other scenes reference this one.
     *     Publishes scene.deleted event on success.
     */
    post: operations['deleteScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate a scene structure
     * @description Validates a scene document without saving it. Checks structural validity
     *     and optionally applies game-specific validation rules.
     */
    post: operations['validateScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/checkout': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Lock a scene for editing
     * @description Acquires an exclusive lock on the scene for editing.
     *     Returns a checkout token required for commit.
     *     Lock expires after TTL if not extended via heartbeat.
     */
    post: operations['checkoutScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/commit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Save changes and release lock
     * @description Commits the changes made during checkout, increments version,
     *     and releases the lock. Publishes scene.committed event.
     */
    post: operations['commitScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/discard': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Release lock without saving changes
     * @description Discards any changes and releases the checkout lock.
     *     Scene remains at its pre-checkout version.
     */
    post: operations['discardCheckout'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/heartbeat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Extend checkout lock TTL
     * @description Extends the checkout lock TTL. Should be called periodically
     *     during editing to prevent lock expiration.
     */
    post: operations['heartbeatCheckout'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/history': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get version history for a scene
     * @description Returns the version history for a scene, up to the configured
     *     retention limit per gameId.
     */
    post: operations['getSceneHistory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/get-validation-rules': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get validation rules for a gameId+sceneType
     * @description Retrieves the registered validation rules for a specific
     *     gameId and sceneType combination.
     */
    post: operations['getValidationRules'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Full-text search across scenes
     * @description Searches scene names, descriptions, tags, and node names
     *     for matching content.
     */
    post: operations['searchScenes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/find-references': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find scenes that reference a given scene
     * @description Returns all scenes that contain reference nodes pointing
     *     to the specified scene.
     */
    post: operations['findReferences'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/find-asset-usage': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find scenes using a specific asset
     * @description Returns all scenes containing nodes that reference
     *     a specific asset ID.
     */
    post: operations['findAssetUsage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/duplicate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Duplicate a scene with a new ID
     * @description Creates a copy of a scene with a new sceneId and name.
     *     All node IDs are regenerated. Version resets to 1.0.0.
     */
    post: operations['duplicateScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/species/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get species by ID */
    post: operations['getSpecies'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/species/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get species by code
     * @description Retrieve a species using its unique code (e.g., "HUMAN", "ELF", "DWARF")
     */
    post: operations['getSpeciesByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/species/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all species
     * @description Retrieve all species with optional realm filtering
     */
    post: operations['listSpecies'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/species/list-by-realm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List species available in a realm
     * @description Retrieve all species that are available in a specific realm
     */
    post: operations['listSpeciesByRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/subscription/account/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get subscriptions for an account
     * @description Returns all subscriptions for a given account, with optional filtering.
     */
    post: operations['getAccountSubscriptions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/subscription/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get a specific subscription by ID */
    post: operations['getSubscription'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/subscription/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel a subscription
     * @description Cancels a subscription. Users can cancel their own subscriptions,
     *     admins can cancel any subscription.
     */
    post: operations['cancelSubscription'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/voice/peer/answer': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Send SDP answer to complete WebRTC handshake
     * @description Called by clients after receiving a VoicePeerJoinedEvent containing an SDP offer.
     *     The client generates an SDP answer and sends it via this endpoint.
     *     The answering peer is notified via VoicePeerUpdatedEvent.
     *
     *     **Access Control**: This endpoint requires the `voice:ringing` state, which is
     *     automatically set by the Voice service when a VoicePeerJoinedEvent is sent to the client.
     *     The state is cleared after the answer is processed or times out.
     */
    post: operations['answerPeer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get website status and version */
    get: operations['getStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/content/{slug}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get dynamic page content from CMS */
    get: operations['getPageContent'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/news': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get latest news and announcements */
    get: operations['getNews'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/server-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get game server status for all realms */
    get: operations['getServerStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/downloads': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get download links for game clients */
    get: operations['getDownloads'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/contact': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Submit contact form */
    post: operations['submitContact'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/account/profile': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get account profile for logged-in user */
    get: operations['getAccountProfile'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/account/characters': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get character list for logged-in user */
    get: operations['getAccountCharacters'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/cms/pages': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all CMS pages */
    get: operations['listPages'];
    put?: never;
    /** Create new CMS page */
    post: operations['createPage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/cms/pages/{slug}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /** Update CMS page */
    put: operations['updatePage'];
    post?: never;
    /** Delete CMS page */
    delete: operations['deletePage'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/cms/site-settings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get site configuration */
    get: operations['getSiteSettings'];
    /** Update site configuration */
    put: operations['updateSiteSettings'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/cms/theme': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get current theme configuration */
    get: operations['getTheme'];
    /** Update theme configuration */
    put: operations['updateTheme'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/account/subscription': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get subscription status */
    get: operations['getSubscription'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Request to accept a formed match */
    AcceptMatchRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the match to accept
       */
      matchId: string;
    };
    /** @description Response after accepting a match */
    AcceptMatchResponse: {
      /**
       * Format: uuid
       * @description Match identifier
       */
      matchId: string;
      /** @description Whether all players have accepted */
      allAccepted: boolean;
      /** @description Number of players who have accepted */
      acceptedCount?: number | null;
      /** @description Total players who need to accept */
      totalCount?: number | null;
      /**
       * Format: uuid
       * @description Game session ID (set when all players accept)
       */
      gameSessionId?: string | null;
    };
    /** @description User account information displayed on the website profile page */
    AccountProfile: {
      /**
       * Format: uuid
       * @description Unique identifier for the account
       */
      accountId: string;
      /**
       * Format: email
       * @description Email address associated with the account
       */
      email: string;
      /** @description User-chosen display name */
      displayName?: string | null;
      /**
       * Format: date-time
       * @description Date and time when the account was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Date and time of the last successful login
       */
      lastLogin?: string | null;
      /** @description Total number of character slots available */
      characterSlots?: number;
      /** @description Number of character slots currently in use */
      usedSlots?: number;
    };
    /** @description Account information response */
    AccountResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the account
       */
      accountId: string;
      /**
       * Format: email
       * @description Email address associated with the account
       */
      email: string;
      /** @description Display name for the account */
      displayName?: string | null;
      /** @description BCrypt hashed password for authentication */
      passwordHash?: string | null;
      /**
       * Format: date-time
       * @description Timestamp when the account was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the account was last updated
       */
      updatedAt?: string | null;
      /** @description Whether the email address has been verified */
      emailVerified: boolean;
      /** @description List of roles assigned to the account */
      roles: string[];
      /** @description List of authentication methods linked to the account */
      authMethods?: components['schemas']['AuthMethodInfo'][];
      /** @description Custom metadata associated with the account */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Achievement definition details */
    AchievementDefinitionResponse: {
      /**
       * Format: uuid
       * @description ID of the owning game service
       */
      gameServiceId: string;
      /** @description Unique identifier */
      achievementId: string;
      /** @description Human-readable name */
      displayName: string;
      /** @description How to earn this achievement */
      description: string;
      /** @description Description for hidden achievements */
      hiddenDescription?: string | null;
      /** @description Classification of the achievement */
      achievementType: components['schemas']['AchievementType'];
      /** @description Allowed entity types */
      entityTypes?: components['schemas']['EntityType'][];
      /** @description Target for progressive achievements */
      progressTarget?: number | null;
      /** @description Point value */
      points: number;
      /**
       * Format: uri
       * @description Achievement icon URL
       */
      iconUrl?: string | null;
      /** @description Available platforms */
      platforms?: components['schemas']['Platform'][];
      /** @description Platform-specific IDs */
      platformIds?: {
        [key: string]: string;
      } | null;
      /** @description Required achievements */
      prerequisites?: string[] | null;
      /** @description Whether achievement is earnable */
      isActive: boolean;
      /**
       * Format: int64
       * @description How many entities have earned this
       */
      earnedCount?: number;
      /**
       * Format: date-time
       * @description When the achievement was created
       */
      createdAt: string;
      /** @description Additional metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Progress toward a single achievement */
    AchievementProgress: {
      /** @description Achievement identifier */
      achievementId: string;
      /** @description Achievement display name */
      displayName?: string;
      /** @description Current progress (for progressive) */
      currentProgress?: number | null;
      /** @description Target progress (for progressive) */
      targetProgress?: number | null;
      /**
       * Format: double
       * @description Completion percentage (0-100)
       */
      percentComplete?: number | null;
      /** @description Whether achievement is unlocked */
      isUnlocked: boolean;
      /**
       * Format: date-time
       * @description When achievement was unlocked
       */
      unlockedAt?: string | null;
    };
    /** @description Achievement progress for an entity */
    AchievementProgressResponse: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type that owns this progress summary */
      entityType: components['schemas']['EntityType'];
      /** @description Progress for each achievement */
      progress: components['schemas']['AchievementProgress'][];
      /** @description Total points from unlocked achievements */
      totalPoints?: number;
      /** @description Number of unlocked achievements */
      unlockedCount?: number;
    };
    /**
     * @description Type of achievement
     * @enum {string}
     */
    AchievementType: 'standard' | 'progressive' | 'hidden' | 'secret';
    /**
     * @description Actor-specific capabilities that affect affordance evaluation.
     *     Same location may afford different actions to different actor types.
     */
    ActorCapabilities: {
      /** @description Affects cover requirements and passage width */
      size?: components['schemas']['ActorSize'];
      /** @description Actor height in meters (affects cover, sightlines) */
      height?: number | null;
      /**
       * @description Can reach elevated positions
       * @default false
       */
      canClimb: boolean;
      /**
       * @description Includes water-based positions
       * @default false
       */
      canSwim: boolean;
      /**
       * @description Includes aerial positions
       * @default false
       */
      canFly: boolean;
      /** @description Affects sightline distance requirements */
      perceptionRange?: number | null;
      /** @description Affects escape route viability calculations */
      movementSpeed?: number | null;
      /** @description Affects ambush/hidden_path affordance scoring */
      stealthRating?: number | null;
    };
    /** @description Response containing actor instance details */
    ActorInstanceResponse: {
      /** @description Unique actor identifier */
      actorId: string;
      /**
       * Format: uuid
       * @description Template this actor was instantiated from
       */
      templateId: string;
      /** @description Actor category from template */
      category: string;
      /** @description Pool node running this actor (null in bannou mode) */
      nodeId?: string | null;
      /** @description Pool node's app-id for direct messaging */
      nodeAppId?: string | null;
      /** @description Current actor lifecycle state */
      status: components['schemas']['ActorStatus'];
      /**
       * Format: uuid
       * @description Associated character ID (for NPC brains)
       */
      characterId?: string | null;
      /**
       * Format: date-time
       * @description When the actor started running
       */
      startedAt: string;
      /**
       * Format: date-time
       * @description Last heartbeat timestamp from the actor
       */
      lastHeartbeat?: string | null;
      /**
       * Format: int64
       * @description Number of behavior loop iterations executed
       */
      loopIterations: number;
    };
    /**
     * @description Size classification affecting cover requirements and passage width
     * @default medium
     * @enum {string}
     */
    ActorSize: 'tiny' | 'small' | 'medium' | 'large' | 'huge';
    /**
     * @description Current actor lifecycle state
     * @enum {string}
     */
    ActorStatus: 'pending' | 'starting' | 'running' | 'paused' | 'stopping' | 'stopped' | 'error';
    /** @description Response containing actor template details */
    ActorTemplateResponse: {
      /**
       * Format: uuid
       * @description Unique template identifier
       */
      templateId: string;
      /** @description Category identifier */
      category: string;
      /** @description Reference to behavior in lib-assets */
      behaviorRef: string;
      /** @description Default configuration passed to behavior execution */
      configuration?: {
        [key: string]: unknown;
      } | null;
      /** @description Auto-spawn configuration for instantiate-on-access */
      autoSpawn?: components['schemas']['AutoSpawnConfig'];
      /** @description Milliseconds between behavior loop iterations */
      tickIntervalMs: number;
      /** @description Seconds between automatic state saves */
      autoSaveIntervalSeconds: number;
      /** @description Maximum actors of this category per pool node */
      maxInstancesPerNode: number;
      /**
       * Format: date-time
       * @description When the template was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the template was last updated
       */
      updatedAt: string;
    };
    /**
     * @description Describes a capability or interaction mode for a node.
     *     Used by AI systems to understand what actions are possible and by
     *     character controllers for contextual animations.
     */
    Affordance: {
      /** @description The type of affordance */
      type: components['schemas']['AffordanceType'];
      /**
       * @description Type-specific parameters. Examples:
       *     - sittable: { height: 0.5, facing: [0,0,1] }
       *     - door: { openAngle: 90, locked: false }
       *     - container: { capacity: 10, itemTypes: ["weapon", "consumable"] }
       */
      parameters?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Controls caching behavior for affordance queries
     * @default cached
     * @enum {string}
     */
    AffordanceFreshness: 'fresh' | 'cached' | 'aggressive_cache';
    /** @description A location that affords the requested action */
    AffordanceLocation: {
      /** @description Location position */
      position?: components['schemas']['Position3D'];
      /** @description Area bounds if affordance spans an area */
      bounds?: components['schemas']['Bounds'];
      /** @description How well this location affords the action (0-1) */
      score?: number;
      /**
       * @description What makes this location suitable.
       *     Example: { "cover_rating": 0.8, "sightlines": ["north"], "terrain": "rocky" }
       */
      features?: {
        [key: string]: unknown;
      } | null;
      /** @description Map objects contributing to this affordance */
      objectIds?: string[] | null;
    };
    /** @description Metadata about the affordance query execution */
    AffordanceQueryMetadata: {
      /** @description Map kinds that were queried */
      kindsSearched?: string[] | null;
      /** @description Number of candidate objects evaluated */
      objectsEvaluated?: number;
      /** @description Number of candidate positions generated */
      candidatesGenerated?: number;
      /** @description Query execution time in milliseconds */
      searchDurationMs?: number;
      /** @description Whether results came from cache */
      cacheHit?: boolean;
    };
    /** @description Query for locations that afford a specific action */
    AffordanceQueryRequest: {
      /**
       * Format: uuid
       * @description Region to search
       */
      regionId: string;
      /** @description Type of affordance to search for */
      affordanceType: components['schemas']['AffordanceType'];
      /** @description Custom affordance definition (when affordanceType=custom) */
      customAffordance?: components['schemas']['CustomAffordance'];
      /** @description Optional bounds to search within */
      bounds?: components['schemas']['Bounds'];
      /**
       * @description Maximum locations to return
       * @default 10
       */
      maxResults: number;
      /**
       * @description Minimum affordance score to include
       * @default 0.5
       */
      minScore: number;
      /** @description Expected participants (affects space requirements) */
      participantCount?: number | null;
      /** @description Positions to exclude (e.g., player's current location) */
      excludePositions?: components['schemas']['Position3D'][] | null;
      /** @description Actor capabilities affecting evaluation */
      actorCapabilities?: components['schemas']['ActorCapabilities'];
      /** @description Cache freshness level */
      freshness?: components['schemas']['AffordanceFreshness'];
      /** @description Max age of cached results (for cached/aggressive_cache) */
      maxAgeSeconds?: number | null;
    };
    /** @description Affordance query results */
    AffordanceQueryResponse: {
      /** @description Scored locations (highest score first) */
      locations?: components['schemas']['AffordanceLocation'][];
      /** @description Metadata about query execution (optional) */
      queryMetadata?: components['schemas']['AffordanceQueryMetadata'];
    };
    /**
     * @description Well-known affordance types with predefined scoring logic.
     *     Use 'custom' for novel affordance definitions.
     * @enum {string}
     */
    AffordanceType:
      | 'ambush'
      | 'shelter'
      | 'vista'
      | 'choke_point'
      | 'gathering_spot'
      | 'dramatic_reveal'
      | 'hidden_path'
      | 'defensible_position'
      | 'custom';
    /** @description Analytics and tracking configuration for website visitor metrics */
    Analytics: {
      /** @description Google Analytics tracking ID */
      googleAnalyticsId?: string | null;
      /** @description Configuration for other analytics trackers */
      otherTrackers?: {
        [key: string]: unknown;
      };
    };
    /**
     * @description Request to send an SDP answer to complete a WebRTC handshake.
     *     Sent by clients after receiving a VoicePeerJoinedEvent with an SDP offer.
     */
    AnswerPeerRequest: {
      /**
       * Format: uuid
       * @description Voice room ID
       */
      roomId: string;
      /** @description Session ID of the answering peer (caller of this endpoint) */
      senderSessionId: string;
      /** @description Session ID of the peer whose offer we're answering */
      targetSessionId: string;
      /** @description SDP answer generated by this client's WebRTC stack */
      sdpAnswer: string;
      /** @description ICE candidates for NAT traversal (can be trickled later) */
      iceCandidates?: string[];
    };
    /** @description Archive metadata including size and document count */
    ArchiveInfo: {
      /**
       * Format: uuid
       * @description Unique identifier of the archive
       */
      archiveId: string;
      /** @description Namespace the archive belongs to */
      namespace: string;
      /**
       * Format: uuid
       * @description Asset ID in Asset Service
       */
      bundleAssetId?: string;
      /** @description Description of the archive */
      description?: string | null;
      /** @description Number of documents in the archive */
      documentCount?: number;
      /** @description Total size of the archive in bytes */
      sizeBytes?: number;
      /** @description Git commit hash if namespace was bound at archive time */
      commitHash?: string | null;
      /**
       * Format: date-time
       * @description Timestamp when the archive was created
       */
      createdAt: string;
      /**
       * @description Owner of this archive. NOT a session ID.
       *     Contains either an accountId (UUID format) for user-initiated archives
       *     or a service name for service-initiated archives.
       */
      owner?: string;
    };
    /** @description Describes a conflict when the same asset ID has different content hashes */
    AssetConflict: {
      /** @description The conflicting asset identifier */
      assetId: string;
      /** @description Bundles with conflicting versions of this asset */
      conflictingBundles: components['schemas']['ConflictingBundleEntry'][];
    };
    /** @description Complete asset metadata including system-generated fields */
    AssetMetadata: {
      /** @description Unique asset identifier */
      assetId: string;
      /** @description SHA256 hash of file contents */
      contentHash: string;
      /** @description Original filename */
      filename: string;
      /** @description MIME content type */
      contentType: string;
      /**
       * Format: int64
       * @description File size in bytes
       */
      size: number;
      /** @description Type classification for the asset */
      assetType: components['schemas']['AssetType'];
      /** @description Game realm the asset belongs to */
      realm: components['schemas']['Realm'];
      /** @description Searchable tags for the asset */
      tags: string[];
      /** @description Current status of asset processing pipeline */
      processingStatus: components['schemas']['ProcessingStatus'];
      /**
       * @description Whether the asset is in cold/archival storage
       * @default false
       */
      isArchived: boolean;
      /**
       * Format: date-time
       * @description Timestamp when the asset was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the asset was last updated
       */
      updatedAt: string;
    };
    /** @description User-provided metadata for asset categorization */
    AssetMetadataInput: {
      /** @description Type classification for the asset */
      assetType?: components['schemas']['AssetType'];
      /** @description Game realm the asset belongs to */
      realm?: components['schemas']['Realm'];
      /** @description Searchable tags for the asset */
      tags?: string[];
    };
    /** @description Reference to an asset in lib-asset */
    AssetReference: {
      /**
       * Format: uuid
       * @description Optional bundle containing the asset
       */
      bundleId?: string | null;
      /**
       * Format: uuid
       * @description Asset identifier in lib-asset
       */
      assetId: string;
      /** @description Variant identifier (consumer interprets meaning) */
      variantId?: string | null;
    };
    /** @description Search criteria for filtering assets with pagination */
    AssetSearchRequest: {
      /** @description Filter by tags (assets must have all specified tags) (null to skip tag filtering) */
      tags?: string[] | null;
      /** @description Filter by asset type */
      assetType: components['schemas']['AssetType'];
      /** @description Filter by game realm */
      realm: components['schemas']['Realm'];
      /** @description MIME content type filter (null to skip content type filtering) */
      contentType?: string | null;
      /**
       * @description Maximum number of results to return
       * @default 50
       */
      limit: number;
      /**
       * @description Number of results to skip for pagination
       * @default 0
       */
      offset: number;
    };
    /** @description Paginated results from an asset search query */
    AssetSearchResult: {
      /** @description List of matching assets */
      assets: components['schemas']['AssetMetadata'][];
      /** @description Total number of matching assets */
      total: number;
      /** @description Maximum number of results returned per page */
      limit: number;
      /** @description Number of results skipped */
      offset: number;
    };
    /**
     * @description Defines acceptable asset types for procedural swapping at this node.
     *     Used by procedural generation systems to substitute assets while
     *     maintaining scene coherence.
     */
    AssetSlot: {
      /**
       * @description Category of acceptable assets.
       *     Examples: chair, table, wall_art, floor_lamp
       */
      slotType: string;
      /**
       * @description Tags that acceptable assets must have.
       *     Used for filtering when selecting random variations.
       */
      acceptsTags?: string[];
      /** @description Default asset if no specific asset is bound */
      defaultAsset?: components['schemas']['AssetReference'];
      /**
       * @description Pre-approved asset variations for random selection.
       *     Procedural systems pick from this list rather than searching all assets.
       */
      variations?: components['schemas']['AssetReference'][];
    };
    /**
     * @description Type classification for assets
     * @enum {string}
     */
    AssetType: 'texture' | 'model' | 'audio' | 'behavior' | 'bundle' | 'prefab' | 'other';
    /** @description Information about asset usage */
    AssetUsageInfo: {
      /**
       * Format: uuid
       * @description Scene using the asset
       */
      sceneId: string;
      /** @description Scene name */
      sceneName: string;
      /**
       * Format: uuid
       * @description Node using the asset
       */
      nodeId: string;
      /** @description refId of the node */
      nodeRefId: string;
      /** @description Node name */
      nodeName?: string;
      /** @description Type of the node */
      nodeType?: components['schemas']['NodeType'];
    };
    /** @description Metadata for a specific version of an asset */
    AssetVersion: {
      /** @description Unique version identifier */
      versionId: string;
      /**
       * Format: date-time
       * @description Timestamp when this version was created
       */
      createdAt: string;
      /**
       * Format: int64
       * @description File size in bytes for this version
       */
      size: number;
      /** @description Whether this version is in cold storage */
      isArchived: boolean;
    };
    /** @description Paginated list of asset versions */
    AssetVersionList: {
      /** @description Asset identifier */
      assetId: string;
      /** @description List of asset versions */
      versions: components['schemas']['AssetVersion'][];
      /** @description Total number of versions available */
      total: number;
      /** @description Maximum number of versions returned per page */
      limit: number;
      /** @description Number of versions skipped */
      offset: number;
    };
    /** @description Asset metadata with optional pre-signed download URL */
    AssetWithDownloadUrl: {
      /** @description Unique asset identifier */
      assetId: string;
      /** @description Version identifier for this specific asset version */
      versionId: string;
      /**
       * Format: uri
       * @description Pre-signed download URL (only populated when requested)
       */
      downloadUrl?: string | null;
      /**
       * Format: date-time
       * @description When the download URL expires (only populated when requested)
       */
      expiresAt?: string | null;
      /**
       * Format: int64
       * @description File size in bytes
       */
      size: number;
      /** @description SHA256 hash of file contents */
      contentHash: string;
      /** @description MIME content type */
      contentType: string;
      /** @description Complete asset metadata */
      metadata: components['schemas']['AssetMetadata'];
    };
    /**
     * @description A predefined location where child objects can be attached.
     *     Used for decorating furniture, walls, and other objects with accessories.
     *     Example: A wall may have attachment points for paintings, shelves, or light fixtures.
     */
    AttachmentPoint: {
      /**
       * @description Unique name for this attachment point within the node.
       *     Examples: wall_hook_left, shelf_1, lamp_socket
       */
      name: string;
      /** @description Position and orientation relative to the owning node */
      localTransform: components['schemas']['Transform'];
      /**
       * @description Tags of assets that can attach here.
       *     Examples: wall_decoration, picture_frame, plant
       */
      acceptsTags?: string[];
      /** @description Default asset to display if no specific attachment is specified */
      defaultAsset?: components['schemas']['AssetReference'];
      /**
       * Format: uuid
       * @description ID of the node currently attached at this point (runtime state)
       */
      attachedNodeId?: string | null;
    };
    /** @description Information about a linked authentication method */
    AuthMethodInfo: {
      /**
       * Format: uuid
       * @description Unique identifier for the authentication method
       */
      methodId?: string | null;
      /** @description Authentication provider type */
      provider: components['schemas']['AuthProvider'];
      /** @description External user ID from the authentication provider */
      externalId?: string | null;
      /** @description Display name from the authentication provider */
      displayName?: string | null;
      /**
       * Format: date-time
       * @description Timestamp when the authentication method was linked
       */
      linkedAt: string;
    };
    /**
     * @description All authentication provider types including email
     * @enum {string}
     */
    AuthProvider: 'email' | 'google' | 'discord' | 'twitch' | 'steam';
    /** @description Successful authentication response containing tokens and session information */
    AuthResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the authenticated account
       */
      accountId: string;
      /** @description JWT access token for API authentication */
      accessToken: string;
      /** @description Token used to obtain new access tokens when the current one expires */
      refreshToken: string;
      /** @description Seconds until access token expires */
      expiresIn: number;
      /**
       * Format: uri
       * @description WebSocket endpoint for Connect service
       */
      connectUrl: string;
      /** @description List of roles assigned to the authenticated user */
      roles?: string[] | null;
      /**
       * @description Whether the user needs to complete two-factor authentication
       * @default false
       */
      requiresTwoFactor: boolean;
    };
    /** @description Request to checkout for authoring */
    AuthoringCheckoutRequest: {
      /**
       * Format: uuid
       * @description Region to checkout
       */
      regionId: string;
      /** @description Map kind to checkout */
      kind: components['schemas']['MapKind'];
      /** @description Identifier for the editor/user */
      editorId: string;
    };
    /** @description Checkout response */
    AuthoringCheckoutResponse: {
      /** @description Token for publishing changes (if successful) */
      authorityToken?: string | null;
      /**
       * Format: date-time
       * @description When the checkout expires
       */
      expiresAt?: string | null;
      /** @description Who has the lock (if checkout failed) */
      lockedBy?: string | null;
      /**
       * Format: date-time
       * @description When the lock was acquired (if checkout failed)
       */
      lockedAt?: string | null;
    };
    /** @description Request to commit authoring changes */
    AuthoringCommitRequest: {
      /**
       * Format: uuid
       * @description Region being edited
       */
      regionId: string;
      /** @description Map kind being edited */
      kind: components['schemas']['MapKind'];
      /** @description Checkout authority token */
      authorityToken: string;
      /** @description Optional commit message for history */
      commitMessage?: string | null;
    };
    /** @description Commit response */
    AuthoringCommitResponse: {
      /**
       * Format: int64
       * @description Committed version number
       */
      version?: number | null;
    };
    /** @description Request to release authoring checkout */
    AuthoringReleaseRequest: {
      /**
       * Format: uuid
       * @description Region being edited
       */
      regionId: string;
      /** @description Map kind being edited */
      kind: components['schemas']['MapKind'];
      /** @description Checkout authority token */
      authorityToken: string;
    };
    /** @description Release response */
    AuthoringReleaseResponse: {
      /** @description Whether checkout was released */
      released?: boolean;
    };
    /** @description Configuration for instantiate-on-access behavior */
    AutoSpawnConfig: {
      /**
       * @description If true, accessing a non-existent actor creates it
       * @default false
       */
      enabled: boolean;
      /**
       * @description Regex pattern for actor IDs that trigger auto-spawn.
       *     Examples: "npc-.*" matches "npc-grok", "npc-merchant-123"
       */
      idPattern?: string | null;
      /** @description Maximum auto-spawned instances (0 = unlimited) */
      maxInstances?: number | null;
      /**
       * @description 1-based regex capture group index for extracting CharacterId from actor ID.
       *     Example: With idPattern "npc-brain-([a-f0-9-]+)" and characterIdCaptureGroup: 1,
       *     actor ID "npc-brain-abc-123-def" extracts "abc-123-def" as CharacterId (parsed as GUID).
       */
      characterIdCaptureGroup?: number | null;
    };
    /** @description A machine-readable backstory element for behavior system consumption */
    BackstoryElement: {
      /** @description Category of this backstory element */
      elementType: components['schemas']['BackstoryElementType'];
      /**
       * @description Machine-readable key (e.g., "homeland", "trained_by", "past_job").
       *     Used by behavior system to query specific aspects.
       */
      key: string;
      /**
       * @description Machine-readable value (e.g., "northlands", "knights_guild", "blacksmith").
       *     Referenced in behavior rules.
       */
      value: string;
      /**
       * Format: float
       * @description How strongly this element affects behavior (0.0 to 1.0).
       *     Higher strength = greater influence on decisions.
       * @default 0.5
       */
      strength: number;
      /**
       * Format: uuid
       * @description Optional related entity (location, organization, character)
       */
      relatedEntityId?: string | null;
      /** @description Type of the related entity (if any) */
      relatedEntityType?: string | null;
    };
    /** @description Single backstory element */
    BackstoryElementSnapshot: {
      /** @description Type of backstory element (ORIGIN, TRAUMA, GOAL, etc.) */
      elementType: string;
      /** @description Machine-readable key (homeland, past_job, etc.) */
      key: string;
      /** @description Machine-readable value (northlands, blacksmith, etc.) */
      value: string;
      /**
       * Format: float
       * @description How strongly this affects behavior (0.0 to 1.0)
       */
      strength: number;
    };
    /**
     * @description Types of backstory elements. Each type represents a different aspect
     *     of the character's background that influences behavior.
     * @enum {string}
     */
    BackstoryElementType:
      | 'ORIGIN'
      | 'OCCUPATION'
      | 'TRAINING'
      | 'TRAUMA'
      | 'ACHIEVEMENT'
      | 'SECRET'
      | 'GOAL'
      | 'FEAR'
      | 'BELIEF';
    /** @description Complete backstory data for a character */
    BackstoryResponse: {
      /**
       * Format: uuid
       * @description ID of the character this backstory belongs to
       */
      characterId: string;
      /** @description All backstory elements for this character */
      elements: components['schemas']['BackstoryElement'][];
      /**
       * Format: date-time
       * @description When this backstory was first created
       */
      createdAt?: string | null;
      /**
       * Format: date-time
       * @description When this backstory was last modified
       */
      updatedAt?: string | null;
    };
    /** @description Snapshot of backstory for enriched response */
    BackstorySnapshot: {
      /** @description List of backstory elements */
      elements: components['schemas']['BackstoryElementSnapshot'][];
    };
    /** @description Compiled behavior tree data with bytecode or download reference */
    BehaviorTreeData: {
      /** @description Base64-encoded compiled bytecode for the behavior tree */
      bytecode?: string | null;
      /** @description Size of the bytecode in bytes */
      bytecodeSize?: number;
      /** @description URL to download the compiled behavior asset */
      downloadUrl?: string | null;
    };
    /** @description Request to bind a Git repository for automatic documentation sync */
    BindRepositoryRequest: {
      /**
       * @description Owner of this binding. NOT a session ID.
       *     For user-initiated bindings: the accountId (UUID format).
       *     For service-initiated bindings: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Documentation namespace to bind */
      namespace: string;
      /** @description Git clone URL (HTTPS for public repos) */
      repositoryUrl: string;
      /**
       * @description Branch to sync from
       * @default main
       */
      branch: string;
      /**
       * @description How often to sync (5 min to 24 hours)
       * @default 60
       */
      syncIntervalMinutes: number;
      /**
       * @description Glob patterns for files to include
       * @default [
       *       "**\/*.md"
       *     ]
       */
      filePatterns: string[];
      /**
       * @description Glob patterns for files to exclude
       * @default [
       *       ".git/**",
       *       ".obsidian/**",
       *       "node_modules/**"
       *     ]
       */
      excludePatterns: string[];
      /** @description Map directory prefixes to categories */
      categoryMapping?: {
        [key: string]: string;
      };
      /** @description Default category for documents without mapping */
      defaultCategory?: components['schemas']['DocumentCategory'];
      /**
       * @description Enable archive functionality
       * @default false
       */
      archiveEnabled: boolean;
      /**
       * @description Create archive after each sync
       * @default false
       */
      archiveOnSync: boolean;
    };
    /** @description Response confirming repository binding creation */
    BindRepositoryResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the repository binding
       */
      bindingId: string;
      /** @description Namespace the repository is bound to */
      namespace: string;
      /** @description URL of the bound repository */
      repositoryUrl?: string;
      /** @description Branch being synced */
      branch?: string;
      /** @description Current status of the binding */
      status: components['schemas']['BindingStatus'];
      /**
       * Format: date-time
       * @description Timestamp when the binding was created
       */
      createdAt?: string;
    };
    /**
     * @description Status of a repository binding
     * @enum {string}
     */
    BindingStatus: 'pending' | 'syncing' | 'synced' | 'error' | 'disabled';
    /** @description An axis-aligned bounding box in 3D space */
    Bounds: {
      /** @description Minimum corner (lowest x, y, z values) */
      min: components['schemas']['Position3D'];
      /** @description Maximum corner (highest x, y, z values) */
      max: components['schemas']['Position3D'];
    };
    /** @description Request to retrieve metadata for multiple assets */
    BulkGetAssetsRequest: {
      /** @description Asset IDs to retrieve (max 100) */
      assetIds: string[];
      /**
       * @description Whether to generate pre-signed download URLs
       * @default false
       */
      includeDownloadUrls: boolean;
    };
    /** @description Batch asset metadata response */
    BulkGetAssetsResponse: {
      /** @description Found assets with metadata */
      assets: components['schemas']['AssetWithDownloadUrl'][];
      /** @description Asset IDs that weren't found */
      notFound: string[];
    };
    /**
     * @description Bundle file format
     * @enum {string}
     */
    BundleFormat: 'bannou' | 'zip';
    /** @description Complete metadata for an asset bundle (API response model) */
    BundleInfo: {
      /** @description Unique bundle identifier */
      bundleId: string;
      /** @description Whether source or metabundle */
      bundleType: components['schemas']['BundleType'];
      /** @description Bundle content version string */
      version: string;
      /** @description Metadata version number (increments on metadata changes) */
      metadataVersion: number;
      /** @description Human-readable bundle name */
      name?: string | null;
      /** @description Bundle description */
      description?: string | null;
      /** @description Owner account ID or service name */
      owner: string;
      /** @description Game realm this bundle belongs to */
      realm: components['schemas']['Realm'];
      /** @description Key-value tags for categorization and filtering */
      tags?: {
        [key: string]: string;
      } | null;
      /** @description Bundle lifecycle status */
      status: components['schemas']['BundleLifecycle'];
      /** @description Number of assets in the bundle */
      assetCount: number;
      /**
       * Format: int64
       * @description Bundle file size in bytes (null if not yet calculated)
       */
      sizeBytes?: number | null;
      /**
       * Format: date-time
       * @description When the bundle was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the bundle metadata was last updated
       */
      updatedAt?: string | null;
      /**
       * Format: date-time
       * @description When the bundle was soft-deleted (null if active)
       */
      deletedAt?: string | null;
    };
    /**
     * @description Bundle lifecycle status:
     *     - active: Bundle is available for use
     *     - deleted: Bundle has been soft-deleted (within retention period)
     *     - processing: Bundle is being processed (metabundle creation)
     * @enum {string}
     */
    BundleLifecycle: 'active' | 'deleted' | 'processing';
    /** @description Preview of bundle manifest for validation */
    BundleManifestPreview: {
      /** @description Bundle identifier from the manifest */
      bundleId: string;
      /** @description Bundle version from the manifest */
      version: string;
      /** @description Number of assets declared in the manifest */
      assetCount: number;
    };
    /** @description Summary information about a bundle */
    BundleSummary: {
      /** @description Bundle identifier */
      bundleId: string;
      /** @description Source or metabundle */
      bundleType: components['schemas']['BundleType'];
      /** @description Bundle version */
      version: string;
      /** @description Number of assets in bundle */
      assetCount: number;
      /**
       * Format: int64
       * @description Bundle file size
       */
      sizeBytes?: number | null;
      /** @description Game realm */
      realm: components['schemas']['Realm'];
      /**
       * Format: date-time
       * @description When the bundle was created
       */
      createdAt?: string | null;
    };
    /**
     * @description Bundle category:
     *     - source: Original bundle (uploaded or server-created from assets)
     *     - metabundle: Composed from other bundles server-side
     * @enum {string}
     */
    BundleType: 'source' | 'metabundle';
    /** @description Request to upload a pre-built asset bundle file */
    BundleUploadRequest: {
      /**
       * @description Owner of this bundle upload. NOT a session ID.
       *     For user-initiated uploads: the accountId (UUID format).
       *     For service-initiated uploads: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Must end with .bannou or .zip */
      filename: string;
      /**
       * Format: int64
       * @description Bundle file size in bytes
       */
      size: number;
      /** @description Optional preview of bundle manifest for validation */
      manifestPreview?: components['schemas']['BundleManifestPreview'] | null;
    };
    /** @description A single version record in bundle history */
    BundleVersionRecord: {
      /** @description Version number */
      version: number;
      /**
       * Format: date-time
       * @description When this version was created
       */
      createdAt: string;
      /** @description Account ID that made the change */
      createdBy: string;
      /** @description List of changes in this version */
      changes: string[];
      /** @description Reason provided for the change */
      reason?: string | null;
      /** @description Full metadata snapshot at this version (only for current version) */
      snapshot?: components['schemas']['BundleInfo'] | null;
    };
    /** @description Bundle metadata combined with a pre-signed download URL */
    BundleWithDownloadUrl: {
      /** @description Unique bundle identifier */
      bundleId: string;
      /** @description Bundle version string */
      version: string;
      /**
       * Format: uri
       * @description Pre-signed URL for downloading the bundle
       */
      downloadUrl: string;
      /** @description Format of the downloadable bundle */
      format: components['schemas']['BundleFormat'];
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Bundle file size in bytes
       */
      size: number;
      /** @description Number of assets contained in the bundle */
      assetCount: number;
      /** @description True if ZIP format was served from conversion cache */
      fromCache: boolean;
    };
    /** @description Response containing a previously compiled behavior retrieved from cache */
    CachedBehaviorResponse: {
      /** @description Unique identifier for the cached behavior */
      behaviorId: string;
      /** @description The compiled behavior data retrieved from cache */
      compiledBehavior: components['schemas']['CompiledBehavior'];
      /**
       * Format: date-time
       * @description When the behavior was cached
       */
      cacheTimestamp?: string | null;
      /** @description Whether this was a cache hit or miss */
      cacheHit?: boolean;
    };
    /** @description Information about a cadence */
    CadenceInfo: {
      /**
       * @description Cadence type
       * @enum {string}
       */
      type: 'authentic' | 'half' | 'plagal' | 'deceptive';
      /** @description Chord index where cadence ends */
      position: number;
      /**
       * @description Cadence strength
       * @enum {string|null}
       */
      strength?: 'perfect' | 'imperfect' | null;
    };
    /** @description Request to cancel an async metabundle creation job */
    CancelJobRequest: {
      /**
       * Format: uuid
       * @description Job ID from the createMetabundle response
       */
      jobId: string;
    };
    /** @description Result of job cancellation attempt */
    CancelJobResponse: {
      /**
       * Format: uuid
       * @description Job identifier
       */
      jobId: string;
      /** @description Whether the job was successfully cancelled */
      cancelled: boolean;
      /**
       * @description Current job status after cancellation attempt
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed' | 'cancelled';
      /** @description Additional context about the cancellation result */
      message?: string | null;
    };
    /** @description Request to cancel a subscription */
    CancelSubscriptionRequest: {
      /**
       * Format: uuid
       * @description ID of the subscription to cancel
       */
      subscriptionId: string;
      /** @description Optional reason for cancellation */
      reason?: string | null;
    };
    /**
     * @description Compressed archive of a dead character.
     *     Contains text summaries instead of structured data for long-term storage.
     *     Self-contained with no external references (suitable for cleanup).
     */
    CharacterArchive: {
      /**
       * Format: uuid
       * @description Original character ID
       */
      characterId: string;
      /** @description Character display name */
      name: string;
      /**
       * Format: uuid
       * @description Realm the character belonged to
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Character's species
       */
      speciesId: string;
      /**
       * Format: date-time
       * @description In-game birth date
       */
      birthDate: string;
      /**
       * Format: date-time
       * @description In-game death date
       */
      deathDate: string;
      /**
       * Format: date-time
       * @description When this archive was created
       */
      compressedAt: string;
      /**
       * @description Text summary of personality traits.
       *     Example: "Brave and loyal, somewhat hot-tempered with a strong sense of justice"
       */
      personalitySummary?: string | null;
      /**
       * @description Key backstory elements as text.
       *     Example: ["Trained by the Knights Guild", "Born in the Northlands"]
       */
      keyBackstoryPoints?: string[];
      /**
       * @description Significant life events as text.
       *     Example: ["Fought in the Battle of Stormgate (Hero)", "Survived the Great Flood"]
       */
      majorLifeEvents?: string[];
      /**
       * @description Text summary of family relationships.
       *     Example: "Father of 3, married to Elena, orphaned at young age"
       */
      familySummary?: string | null;
    };
    /** @description Context information about a character for behavior resolution */
    CharacterContext: {
      /**
       * @description Unique identifier for the NPC
       * @example npc_12345
       */
      npcId?: string | null;
      /**
       * @description Cultural background identifier
       * @example european_medieval
       */
      culture?: string | null;
      /**
       * @description Character profession identifier
       * @example blacksmith
       */
      profession?: string | null;
      /**
       * @description Character statistics and attributes
       * @example {
       *       "energy": 0.8,
       *       "health": 1,
       *       "hunger": 0.3
       *     }
       */
      stats?: {
        [key: string]: number;
      } | null;
      /**
       * @description Character skill levels
       * @example {
       *       "blacksmithing": 85,
       *       "trading": 42
       *     }
       */
      skills?: {
        [key: string]: number;
      } | null;
      /** @description Current location information for the character */
      location?: components['schemas']['Location'];
      /** @description Relationship values with other characters */
      relationships?: {
        [key: string]: number;
      } | null;
      /** @description Relevant world state information */
      worldState?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Paginated list of characters with metadata for navigation */
    CharacterListResponse: {
      /** @description List of characters matching the query */
      characters: components['schemas']['CharacterResponse'][];
      /** @description Total number of characters matching the filter criteria */
      totalCount: number;
      /** @description Current page number (1-based) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more results after this page */
      hasNextPage?: boolean;
      /** @description Whether there are results before this page */
      hasPreviousPage?: boolean;
    };
    /** @description Complete character data returned from character operations */
    CharacterResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the character
       */
      characterId: string;
      /** @description Display name of the character */
      name: string;
      /**
       * Format: uuid
       * @description Realm ID (partition key)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Species ID (foreign key to Species service)
       */
      speciesId: string;
      /**
       * Format: date-time
       * @description In-game birth timestamp
       */
      birthDate: string;
      /**
       * Format: date-time
       * @description In-game death timestamp
       */
      deathDate?: string | null;
      /** @description Current lifecycle status of the character */
      status: components['schemas']['CharacterStatus'];
      /**
       * Format: date-time
       * @description Real-world creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Real-world last update timestamp
       */
      updatedAt?: string | null;
    };
    /**
     * @description Character lifecycle status
     * @enum {string}
     */
    CharacterStatus: 'alive' | 'dead' | 'dormant';
    /** @description Request to send a chat message to players in a game session */
    ChatMessageRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the sender. Provided by shortcut system.
       */
      sessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the sender. Provided by shortcut system.
       */
      accountId: string;
      /** @description Game type for the chat. Determines which lobby's players receive the message. Provided by shortcut system. */
      gameType: string;
      /** @description Content of the chat message */
      message: string;
      /**
       * @description Type of message (public to all, whisper to one player, or system announcement)
       * @default public
       * @enum {string}
       */
      messageType: 'public' | 'whisper' | 'system';
      /**
       * Format: uuid
       * @description For whisper messages
       */
      targetPlayerId?: string | null;
    };
    /** @description Request to checkout a scene for editing */
    CheckoutRequest: {
      /**
       * Format: uuid
       * @description Scene to checkout
       */
      sceneId: string;
      /** @description Optional editor identifier (defaults to caller identity) */
      editorId?: string | null;
      /** @description Custom lock TTL (uses default if not specified) */
      ttlMinutes?: number | null;
    };
    /** @description Response containing checkout token and scene */
    CheckoutResponse: {
      /** @description Token required for commit/discard/heartbeat */
      checkoutToken: string;
      /** @description Current scene document */
      scene: components['schemas']['Scene'];
      /**
       * Format: date-time
       * @description When the checkout lock expires
       */
      expiresAt: string;
    };
    /** @description A chord with timing information */
    ChordEvent: {
      /** @description Chord symbol */
      chord: components['schemas']['ChordSymbol'];
      /** @description Start position in ticks */
      startTick: number;
      /** @description Duration in ticks */
      durationTicks: number;
      /** @description Roman numeral analysis (e.g., "IV", "V7") */
      romanNumeral?: string | null;
    };
    /** @description A chord symbol with root and quality */
    ChordSymbol: {
      /** @description Chord root */
      root: components['schemas']['PitchClass'];
      /**
       * @description Chord quality
       * @enum {string}
       */
      quality:
        | 'major'
        | 'minor'
        | 'diminished'
        | 'augmented'
        | 'dominant7'
        | 'major7'
        | 'minor7'
        | 'diminished7'
        | 'halfDiminished7'
        | 'augmented7'
        | 'sus2'
        | 'sus4';
      /** @description Bass note (for inversions/slash chords) */
      bass?: components['schemas']['PitchClass'];
      /** @description Chord extensions (e.g., "9", "11", "13") */
      extensions?: string[] | null;
    };
    /** @description Response containing the client's capability manifest with available API endpoints and shortcuts */
    ClientCapabilitiesResponse: {
      /** @description Session ID this capability manifest belongs to */
      sessionId: string;
      /** @description Available API capabilities for this client */
      capabilities: components['schemas']['ClientCapability'][];
      /**
       * @description Pre-bound API calls available for this session.
       *     Shortcuts are invoked like normal capabilities but Connect injects
       *     a pre-bound payload instead of using the client's payload.
       */
      shortcuts?: components['schemas']['ClientShortcut'][] | null;
      /** @description Capability manifest version (increments on changes) */
      version: number;
      /**
       * Format: date-time
       * @description When this capability manifest was generated
       */
      generatedAt: string;
      /**
       * Format: date-time
       * @description When these capabilities expire and need refresh
       */
      expiresAt?: string | null;
    };
    /** @description A single API capability available to the client, mapping a client-salted GUID to a service endpoint */
    ClientCapability: {
      /**
       * Format: uuid
       * @description Client-salted GUID for this API endpoint (unique per session)
       */
      guid: string;
      /** @description Service name (e.g., "account", "auth") */
      service: string;
      /** @description API endpoint path (e.g., "/account/create") */
      endpoint: string;
      /**
       * @description HTTP method for this endpoint
       * @enum {string}
       */
      method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
      /** @description Human-readable description of this capability */
      description?: string | null;
      /**
       * Format: uint16
       * @description Preferred WebSocket channel for this capability
       * @default 0
       */
      channel: number;
    };
    /**
     * @description Session shortcut information sent to clients in the capability manifest.
     *     Shortcuts appear as invocable capabilities but Connect injects a pre-bound
     *     payload when the shortcut GUID is used, replacing any client-provided payload.
     */
    ClientShortcut: {
      /**
       * Format: uuid
       * @description GUID to use in WebSocket message header when invoking this shortcut.
       *     Uses UUID version 7 bits to distinguish from regular service GUIDs (version 5).
       */
      guid: string;
      /** @description The service this shortcut invokes (for client display purposes). */
      targetService: string;
      /** @description The endpoint this shortcut invokes (for client display purposes). */
      targetEndpoint: string;
      /** @description Machine-readable shortcut identifier (e.g., "get_my_stats", "join_game"). */
      name: string;
      /** @description Human-readable description of what this shortcut does. */
      description?: string | null;
      /** @description User-friendly name for display in client UIs. */
      displayName?: string | null;
      /** @description The service that created this shortcut. */
      sourceService?: string | null;
      /** @description Categorization tags for client-side organization. */
      tags?: string[] | null;
      /**
       * Format: date-time
       * @description When this shortcut expires (if time-limited).
       */
      expiresAt?: string | null;
    };
    /** @description Request to collapse a delta chain into a full snapshot */
    CollapseDeltasRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the save slot
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Name of the slot containing deltas to collapse */
      slotName: string;
      /** @description Version to collapse to (latest if null) */
      versionNumber?: number | null;
      /**
       * @description Delete intermediate delta versions after collapse
       * @default true
       */
      deleteIntermediates: boolean;
    };
    /**
     * @description Combat behavior preferences that influence tactical decisions.
     *     These values affect GOAP action selection, retreat conditions,
     *     and group coordination behavior.
     */
    CombatPreferences: {
      /** @description Overall combat approach */
      style: components['schemas']['CombatStyle'];
      /** @description Preferred engagement distance */
      preferredRange: components['schemas']['PreferredRange'];
      /** @description Role when fighting in groups */
      groupRole: components['schemas']['GroupRole'];
      /**
       * Format: float
       * @description Willingness to take dangerous actions (0.0 = very cautious, 1.0 = reckless).
       *     Affects ability selection and target prioritization.
       */
      riskTolerance: number;
      /**
       * Format: float
       * @description Health percentage at which retreat is considered (0.0 = fight to death,
       *     0.5 = retreat at half health, 1.0 = retreat at any damage).
       */
      retreatThreshold: number;
      /**
       * @description Whether to prioritize ally protection over self-preservation.
       *     Affects target selection and positioning decisions.
       */
      protectAllies: boolean;
    };
    /** @description Combat preferences profile for behavior system consumption */
    CombatPreferencesResponse: {
      /**
       * Format: uuid
       * @description Character these preferences belong to
       */
      characterId: string;
      /** @description The combat preferences values */
      preferences: components['schemas']['CombatPreferences'];
      /** @description Preferences version number (increments on each evolution) */
      version: number;
      /**
       * Format: date-time
       * @description When these preferences were first created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When these preferences were last modified
       */
      updatedAt?: string | null;
    };
    /** @description Snapshot of combat preferences for enriched response */
    CombatPreferencesSnapshot: {
      /** @description Combat style (DEFENSIVE, BALANCED, AGGRESSIVE, BERSERKER, TACTICAL) */
      style: string;
      /** @description Preferred engagement distance (MELEE, CLOSE, MEDIUM, RANGED) */
      preferredRange: string;
      /** @description Role in group combat (FRONTLINE, SUPPORT, FLANKER, LEADER, SOLO) */
      groupRole: string;
      /**
       * Format: float
       * @description Willingness to take risky actions (0.0 to 1.0)
       */
      riskTolerance: number;
      /**
       * Format: float
       * @description Health percentage at which retreat is considered (0.0 to 1.0)
       */
      retreatThreshold: number;
      /** @description Whether to prioritize ally protection */
      protectAllies: boolean;
    };
    /**
     * @description Overall approach to combat situations. Affects target selection,
     *     ability usage, and engagement decisions.
     * @enum {string}
     */
    CombatStyle: 'DEFENSIVE' | 'BALANCED' | 'AGGRESSIVE' | 'BERSERKER' | 'TACTICAL';
    /** @description Request to commit checkout changes */
    CommitRequest: {
      /**
       * Format: uuid
       * @description Scene being committed
       */
      sceneId: string;
      /** @description Checkout token from checkout response */
      checkoutToken: string;
      /** @description Updated scene document */
      scene: components['schemas']['Scene'];
      /** @description Optional summary of changes for audit */
      changesSummary?: string | null;
    };
    /** @description Response confirming commit */
    CommitResponse: {
      /** @description Whether commit was successful */
      committed: boolean;
      /** @description New version after commit */
      newVersion: string;
      /** @description Committed scene with updated metadata */
      scene?: components['schemas']['Scene'];
    };
    /** @description Options controlling the ABML compilation process including optimizations and caching */
    CompilationOptions: {
      /**
       * @description Enable behavior tree optimizations
       * @default true
       */
      enableOptimizations: boolean;
      /**
       * @description Cache the compiled behavior for reuse
       * @default true
       */
      cacheCompiledResult: boolean;
      /**
       * @description Enable strict validation mode
       * @default false
       */
      strictValidation: boolean;
      /**
       * @description Apply cultural adaptations during compilation
       * @default true
       */
      culturalAdaptations: boolean;
      /**
       * @description Generate GOAP goals from behaviors
       * @default true
       */
      goapIntegration: boolean;
    };
    /** @description Request to compile an ABML behavior definition into executable behavior trees */
    CompileBehaviorRequest: {
      /**
       * @description Raw ABML YAML content to compile
       * @example version: "1.0.0"
       *     metadata:
       *       id: "example_behavior"
       *       category: "basic"
       *     behaviors:
       *       example:
       *         triggers:
       *           - condition: "true"
       *         actions:
       *           - log:
       *               message: "Hello World"
       */
      abmlContent: string;
      /**
       * @description Optional human-readable name for the behavior.
       *     If not provided, extracted from ABML metadata.id or generated from content hash.
       * @example blacksmith_daily_routine
       */
      behaviorName?: string | null;
      /**
       * @description Category for organizing behaviors (e.g., profession, cultural, situational).
       *     Used for filtering and grouping in bundles.
       * @example professional
       * @enum {string|null}
       */
      behaviorCategory?:
        | 'base'
        | 'cultural'
        | 'professional'
        | 'personal'
        | 'situational'
        | 'ambient'
        | null;
      /**
       * @description Optional bundle identifier for grouping related behaviors.
       *     When specified, the compiled behavior will be added to a bundle with this ID.
       *     Clients can then download entire bundles for efficient bulk loading.
       *     If the bundle doesn't exist, it will be created.
       * @example blacksmith-behaviors-v1
       */
      bundleId?: string | null;
      /** @description Character context for context variable resolution during compilation */
      characterContext?: components['schemas']['CharacterContext'];
      /** @description Options controlling the compilation process */
      compilationOptions?: components['schemas']['CompilationOptions'];
    };
    /** @description Response containing the results of an ABML behavior compilation */
    CompileBehaviorResponse: {
      /**
       * @description Unique identifier for the compiled behavior (content-addressable hash)
       * @example behavior-a1b2c3d4e5f6g7h8
       */
      behaviorId: string;
      /**
       * @description Human-readable name of the behavior
       * @example blacksmith_daily_routine
       */
      behaviorName?: string | null;
      /** @description The compiled behavior data including behavior tree and metadata */
      compiledBehavior?: components['schemas']['CompiledBehavior'];
      /** @description Time taken to compile the behavior in milliseconds */
      compilationTimeMs?: number;
      /** @description Asset service ID where the compiled bytecode is stored. Null only when caching is explicitly disabled. */
      assetId?: string | null;
      /** @description Bundle ID if the behavior was added to a bundle. Null if not bundled. */
      bundleId?: string | null;
      /** @description True if this replaced an existing behavior with the same content hash */
      isUpdate?: boolean;
      /** @description Non-fatal warnings during compilation */
      warnings?: string[] | null;
    };
    /** @description Compiled behavior containing behavior tree, context schema, and GOAP integration data */
    CompiledBehavior: {
      /** @description Compiled behavior tree data with bytecode or download reference */
      behaviorTree: components['schemas']['BehaviorTreeData'];
      /** @description Schema defining required context variables for execution */
      contextSchema: components['schemas']['ContextSchemaData'];
      /** @description List of required services for this behavior */
      serviceDependencies?: string[] | null;
      /** @description GOAP goals extracted from the behavior */
      goapGoals?: components['schemas']['GoapGoal'][] | null;
      /** @description Metadata for behavior execution including performance hints and resource requirements */
      executionMetadata?: components['schemas']['ExecutionMetadata'];
    };
    /** @description Request to finalize an upload and trigger asset processing */
    CompleteUploadRequest: {
      /**
       * Format: uuid
       * @description Upload session ID from requestUpload
       */
      uploadId: string;
      /** @description For multipart uploads - ETags of completed parts (null for single-file uploads) */
      parts?: components['schemas']['CompletedPart'][] | null;
    };
    /** @description Information about a completed part in a multipart upload */
    CompletedPart: {
      /** @description Part number (1-based) */
      partNumber: number;
      /** @description ETag returned from part upload */
      etag: string;
    };
    /** @description Metadata about a generated composition */
    CompositionMetadata: {
      /** @description Style used */
      styleId?: string | null;
      /** @description Key signature */
      key?: components['schemas']['KeySignature'];
      /** @description Tempo in BPM */
      tempo?: number | null;
      /** @description Number of bars */
      bars?: number | null;
      /** @description Tune type if applicable */
      tuneType?: string | null;
      /** @description Random seed used */
      seed?: number | null;
    };
    /**
     * @description Compression algorithm for bundles
     * @enum {string}
     */
    CompressionType: 'lz4' | 'lzma' | 'none';
    /** @description A bundle entry in an asset conflict */
    ConflictingBundleEntry: {
      /** @description Bundle containing this version */
      bundleId: string;
      /** @description Content hash of asset in this bundle */
      contentHash: string;
    };
    /** @description User-submitted contact form data */
    ContactRequest: {
      /**
       * Format: email
       * @description Sender email address for replies
       */
      email: string;
      /** @description Name of the person submitting the form */
      name?: string | null;
      /** @description Subject line of the contact message */
      subject: string;
      /** @description Body content of the contact message */
      message: string;
      /**
       * @description Category to route the contact request
       * @default general
       * @enum {string}
       */
      category: 'general' | 'support' | 'bug' | 'feedback' | 'business';
    };
    /** @description Confirmation response after submitting a contact form */
    ContactResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the created support ticket
       */
      ticketId: string;
      /**
       * @description Confirmation message displayed to the user
       * @default Thank you for contacting us. We will respond within 24-48 hours.
       */
      message: string;
    };
    /** @description Schema defining required context variables for behavior execution */
    ContextSchemaData: {
      [key: string]: unknown;
    };
    /** @description 3D spatial coordinates representing a position in the game world */
    Coordinates: {
      /** @description X coordinate position */
      x?: number;
      /** @description Y coordinate position */
      y?: number;
      /** @description Z coordinate position */
      z?: number;
    };
    /** @description Request to copy save data from one slot to another, optionally across different entities or games. */
    CopySaveRequest: {
      /** @description Game identifier of the source save */
      sourceGameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the source save
       */
      sourceOwnerId: string;
      /** @description Type of entity that owns the source save */
      sourceOwnerType: components['schemas']['OwnerType'];
      /** @description Name of the source slot to copy from */
      sourceSlotName: string;
      /** @description Version to copy (latest if null) */
      sourceVersion?: number | null;
      /** @description Game identifier for the target save */
      targetGameId: string;
      /**
       * Format: uuid
       * @description Entity ID that will own the copied save
       */
      targetOwnerId: string;
      /** @description Type of entity that will own the copied save */
      targetOwnerType: components['schemas']['OwnerType'];
      /** @description Name of the target slot to copy to */
      targetSlotName: string;
      /** @description Category for new slot if auto-created */
      targetCategory?: components['schemas']['SaveCategory'];
    };
    /** @description Statistics about asset resolution coverage */
    CoverageAnalysis: {
      /** @description Total number of assets requested */
      totalRequested: number;
      /** @description Assets resolved through bundle downloads */
      resolvedViaBundles: number;
      /** @description Assets resolved as standalone downloads */
      resolvedStandalone: number;
      /** @description Assets that could not be found */
      unresolvedCount: number;
      /**
       * Format: float
       * @description Ratio of assets provided to bundle downloads (higher is better)
       */
      bundleEfficiency?: number | null;
    };
    /** @description Request to create a new achievement */
    CreateAchievementDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service owning this achievement
       */
      gameServiceId: string;
      /** @description Unique identifier for this achievement (lowercase, no spaces) */
      achievementId: string;
      /** @description Human-readable name */
      displayName: string;
      /** @description Description of how to earn this achievement */
      description: string;
      /** @description Description shown before achievement is earned (for hidden types) */
      hiddenDescription?: string | null;
      /**
       * @description Classification of the achievement (affects visibility and progress behavior)
       * @default standard
       */
      achievementType: components['schemas']['AchievementType'];
      /** @description Which entity types can earn this achievement */
      entityTypes?: components['schemas']['EntityType'][];
      /** @description Target value for progressive achievements */
      progressTarget?: number | null;
      /**
       * @description Point value of this achievement
       * @default 10
       */
      points: number;
      /**
       * Format: uri
       * @description URL to achievement icon
       */
      iconUrl?: string | null;
      /** @description Platforms where this achievement exists */
      platforms?: components['schemas']['Platform'][];
      /** @description Platform-specific achievement IDs (e.g., {"steam": "ACH_001"}) */
      platformIds?: {
        [key: string]: string;
      } | null;
      /** @description Achievement IDs that must be unlocked first */
      prerequisites?: string[] | null;
      /**
       * @description Whether this achievement can be earned
       * @default true
       */
      isActive: boolean;
      /** @description Additional achievement-specific metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to create a new actor template definition */
    CreateActorTemplateRequest: {
      /** @description Category identifier (e.g., "npc-brain", "world-admin", "cron-cleanup") */
      category: string;
      /** @description Reference to behavior in lib-assets (e.g., "asset://behaviors/npc-brain-v1") */
      behaviorRef: string;
      /** @description Default configuration passed to behavior execution */
      configuration?: {
        [key: string]: unknown;
      } | null;
      /** @description Auto-spawn configuration for instantiate-on-access */
      autoSpawn?: components['schemas']['AutoSpawnConfig'];
      /**
       * @description Milliseconds between behavior loop iterations
       * @default 1000
       */
      tickIntervalMs: number;
      /**
       * @description Seconds between automatic state saves (0 to disable)
       * @default 60
       */
      autoSaveIntervalSeconds: number;
      /**
       * @description Maximum actors of this category per pool node
       * @default 100
       */
      maxInstancesPerNode: number;
    };
    /** @description Request to create a point-in-time snapshot of namespace documentation */
    CreateArchiveRequest: {
      /**
       * @description Owner of this archive. NOT a session ID.
       *     For user-initiated archives: the accountId (UUID format).
       *     For service-initiated archives: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Documentation namespace to archive */
      namespace: string;
      /** @description Optional description for the archive */
      description?: string;
    };
    /** @description Response containing the created archive details */
    CreateArchiveResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the created archive
       */
      archiveId: string;
      /** @description Namespace that was archived */
      namespace: string;
      /**
       * Format: uuid
       * @description Asset ID in Asset Service
       */
      bundleAssetId?: string;
      /** @description Number of documents in the archive */
      documentCount?: number;
      /** @description Total size of the archive in bytes */
      sizeBytes?: number;
      /**
       * Format: date-time
       * @description Timestamp when the archive was created
       */
      createdAt?: string;
      /** @description Git commit hash if namespace is bound */
      commitHash?: string | null;
    };
    /** @description Request to create a new asset bundle from multiple assets */
    CreateBundleRequest: {
      /**
       * @description Owner of this bundle. NOT a session ID.
       *     For user-initiated bundles: the accountId (UUID format).
       *     For service-initiated bundles: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Unique bundle identifier */
      bundleId: string;
      /**
       * @description Bundle version string
       * @default 1.0.0
       */
      version: string;
      /**
       * @description Game realm this bundle belongs to.
       *     Defaults to 'shared' if not specified.
       */
      realm?: components['schemas']['Realm'] | null;
      /** @description List of asset IDs to include in the bundle */
      assetIds: string[];
      /** @description Compression algorithm to use for the bundle */
      compression?: components['schemas']['CompressionType'];
      /** @description Custom metadata for the bundle (null if none) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response with bundle creation status and estimated size */
    CreateBundleResponse: {
      /** @description Unique bundle identifier */
      bundleId: string;
      /**
       * @description Bundle creation status
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed';
      /**
       * Format: int64
       * @description Estimated bundle size in bytes
       */
      estimatedSize: number;
    };
    /** @description Request to create a map definition */
    CreateDefinitionRequest: {
      /** @description Human-readable name */
      name: string;
      /** @description Description of the map template */
      description?: string | null;
      /** @description Layer configurations */
      layers?: components['schemas']['LayerDefinition'][] | null;
      /** @description Default bounds for regions using this definition */
      defaultBounds?: components['schemas']['Bounds'];
      /** @description Additional metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to create a new leaderboard */
    CreateLeaderboardDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service owning this leaderboard
       */
      gameServiceId: string;
      /** @description Unique identifier for this leaderboard (lowercase, no spaces) */
      leaderboardId: string;
      /** @description Human-readable name for the leaderboard */
      displayName: string;
      /** @description Description of what this leaderboard tracks */
      description?: string | null;
      /** @description Which entity types can appear on this leaderboard */
      entityTypes?: components['schemas']['EntityType'][];
      /**
       * @description Sort order (descending for high scores, ascending for times)
       * @default descending
       */
      sortOrder: components['schemas']['SortOrder'];
      /**
       * @description How to handle score updates
       * @default replace
       */
      updateMode: components['schemas']['UpdateMode'];
      /**
       * @description Whether this leaderboard resets each season
       * @default false
       */
      isSeasonal: boolean;
      /**
       * @description Whether the leaderboard is publicly visible
       * @default true
       */
      isPublic: boolean;
      /** @description Additional leaderboard-specific metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Request to create a metabundle from source bundles and/or standalone assets.
     *     At least one of sourceBundleIds or standaloneAssetIds must be provided.
     *     This enables packaging behaviors/scripts with 3D assets as a complete unit.
     */
    CreateMetabundleRequest: {
      /** @description Unique identifier for the new metabundle */
      metabundleId: string;
      /**
       * @description Source bundle IDs to pull assets from. Can cherry-pick specific
       *     assets using assetFilter, or include all if assetFilter is null.
       */
      sourceBundleIds?: string[] | null;
      /**
       * @description Individual asset IDs (not in bundles) to include directly.
       *     Useful for including behaviors, scripts, or metadata files
       *     alongside bundled 3D assets.
       */
      standaloneAssetIds?: string[] | null;
      /**
       * @description Metabundle version string
       * @default 1.0.0
       */
      version: string;
      /**
       * @description Owner of this metabundle. NOT a session ID.
       *     For user-initiated: the accountId (UUID format).
       *     For service-initiated: the service name.
       */
      owner: string;
      /** @description Game realm for this metabundle */
      realm: components['schemas']['Realm'];
      /** @description Human-readable description */
      description?: string | null;
      /**
       * @description Optional subset of asset IDs to include FROM SOURCE BUNDLES.
       *     If null, all assets from source bundles are included.
       *     Standalone assets are always included regardless of this filter.
       */
      assetFilter?: string[] | null;
      /** @description Custom metadata for the metabundle */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Response from metabundle creation.
     *     For synchronous creation (small jobs): status=ready with downloadUrl.
     *     For async creation (large jobs): status=queued with jobId for polling.
     */
    CreateMetabundleResponse: {
      /** @description Metabundle identifier */
      metabundleId: string;
      /**
       * Format: uuid
       * @description Job ID for async processing. Only present when status is 'queued' or 'processing'.
       *     Use /bundles/job/status to poll for completion, or wait for
       *     MetabundleCreationCompleteEvent via WebSocket.
       */
      jobId?: string | null;
      /**
       * @description Creation status.
       *     - queued: Job accepted for async processing (poll with jobId)
       *     - processing: Job is actively running
       *     - ready: Metabundle created and available for download
       *     - failed: Creation failed (see conflicts for details)
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed';
      /**
       * Format: uri
       * @description Pre-signed download URL (only present when status is 'ready')
       */
      downloadUrl?: string | null;
      /** @description Number of assets in the metabundle */
      assetCount: number;
      /** @description Number of standalone assets included directly (not from bundles) */
      standaloneAssetCount?: number | null;
      /**
       * Format: int64
       * @description Total size in bytes
       */
      sizeBytes: number;
      /** @description Provenance data for the metabundle */
      sourceBundles?: components['schemas']['SourceBundleReference'][];
      /** @description Present if creation failed due to asset conflicts */
      conflicts?: components['schemas']['AssetConflict'][] | null;
    };
    /** @description Request to create a new scene */
    CreateSceneRequest: {
      /** @description The scene document to create */
      scene: components['schemas']['Scene'];
    };
    /** @description Request to create a new save slot for an entity. */
    CreateSlotRequest: {
      /** @description Game identifier for namespace isolation (e.g., "arcadia", "fantasia") */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name (lowercase alphanumeric with hyphens, single char like "q" allowed) */
      slotName: string;
      /** @description Save category determining retention and cleanup behavior */
      category: components['schemas']['SaveCategory'];
      /** @description Override default max versions for this category (null = use category default) */
      maxVersions?: number | null;
      /** @description Days to retain versions (null = indefinite) */
      retentionDays?: number | null;
      /** @description Compression algorithm to use for save data (null = use category default) */
      compressionType?: components['schemas']['CompressionType'] | null;
      /** @description Searchable tags for slot categorization (e.g., "boss-fight", "chapter-3") */
      tags?: string[] | null;
      /** @description Custom key-value metadata for the slot */
      metadata?: {
        [key: string]: string;
      } | null;
    };
    /** @description Custom affordance definition for novel scenarios */
    CustomAffordance: {
      /** @description Human-readable description of this affordance */
      description?: string | null;
      /**
       * @description Required criteria. Object types, property constraints.
       *     Example: { "objectTypes": ["boulder"], "cover_rating": { "min": 0.5 } }
       */
      requires?: {
        [key: string]: unknown;
      } | null;
      /**
       * @description Preferred criteria (boost score but not required).
       *     Example: { "elevation": { "prefer_higher": true } }
       */
      prefers?: {
        [key: string]: unknown;
      } | null;
      /**
       * @description Exclusion criteria. Reject candidates matching these.
       *     Example: { "hazards": true, "contested": true }
       */
      excludes?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Custom script injection configuration for adding JavaScript to pages */
    CustomScripts: {
      /** @description Custom scripts to inject in the HTML head */
      head?: string | null;
      /** @description Custom scripts to inject at the start of the body */
      bodyStart?: string | null;
      /** @description Custom scripts to inject at the end of the body */
      bodyEnd?: string | null;
    };
    /** @description Request to decline a formed match */
    DeclineMatchRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the match to decline
       */
      matchId: string;
    };
    /** @description Request to delete an achievement */
    DeleteAchievementDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the achievement to delete */
      achievementId: string;
    };
    /** @description Request to delete an actor template */
    DeleteActorTemplateRequest: {
      /**
       * Format: uuid
       * @description ID of the template to delete
       */
      templateId: string;
      /**
       * @description If true, stops all running actors using this template
       * @default false
       */
      forceStopActors: boolean;
    };
    /** @description Response confirming template deletion */
    DeleteActorTemplateResponse: {
      /** @description Whether the template was successfully deleted */
      deleted: boolean;
      /** @description Number of running actors that were stopped */
      stoppedActorCount: number;
    };
    /** @description Request to delete a bundle */
    DeleteBundleRequest: {
      /** @description Bundle identifier to delete */
      bundleId: string;
      /**
       * @description If true, permanently delete (admin only). If false, soft-delete.
       * @default false
       */
      permanent: boolean;
      /** @description Optional reason for deletion (recorded in version history) */
      reason?: string | null;
    };
    /** @description Result of bundle deletion */
    DeleteBundleResponse: {
      /** @description Deleted bundle identifier */
      bundleId: string;
      /**
       * @description Deletion status
       * @enum {string}
       */
      status: 'deleted' | 'permanently_deleted';
      /**
       * Format: date-time
       * @description When the bundle was deleted
       */
      deletedAt: string;
      /**
       * Format: date-time
       * @description When soft-deleted bundle will be permanently removed (null for permanent deletes)
       */
      retentionUntil?: string | null;
    };
    /** @description Request to delete a leaderboard */
    DeleteLeaderboardDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard to delete */
      leaderboardId: string;
    };
    /** @description Request to delete a scene */
    DeleteSceneRequest: {
      /**
       * Format: uuid
       * @description ID of the scene to delete
       */
      sceneId: string;
      /** @description Optional reason for deletion (included in event) */
      reason?: string | null;
    };
    /** @description Response confirming scene deletion */
    DeleteSceneResponse: {
      /** @description Whether the scene was successfully deleted */
      deleted: boolean;
      /**
       * Format: uuid
       * @description ID of the deleted scene
       */
      sceneId?: string;
      /** @description If deletion failed, IDs of scenes that reference this one */
      referencingScenes?: string[] | null;
    };
    /** @description Request to permanently delete a save slot and all its versions */
    DeleteSlotRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
    };
    /** @description Result of a slot deletion operation with cleanup statistics */
    DeleteSlotResponse: {
      /** @description Whether slot was deleted */
      deleted: boolean;
      /** @description Number of versions deleted */
      versionsDeleted: number;
      /**
       * Format: int64
       * @description Storage freed in bytes
       */
      bytesFreed: number;
    };
    /** @description Request to permanently delete a specific save version */
    DeleteVersionRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Version to delete */
      versionNumber: number;
    };
    /** @description Result of a version deletion operation with storage freed */
    DeleteVersionResponse: {
      /** @description Whether version was deleted */
      deleted: boolean;
      /**
       * Format: int64
       * @description Storage freed in bytes
       */
      bytesFreed: number;
    };
    /**
     * @description Algorithm used for delta computation.
     *     JSON_PATCH: RFC 6902, best for structured JSON data
     *     BSDIFF: Binary diff, good for general binary data
     *     XDELTA: RFC 3284 VCDIFF, efficient for large binary files
     * @default JSON_PATCH
     * @enum {string}
     */
    DeltaAlgorithm: 'JSON_PATCH' | 'BSDIFF' | 'XDELTA';
    /** @description Information about the client device used for authentication or session tracking */
    DeviceInfo: {
      /**
       * @description Category of the device
       * @enum {string|null}
       */
      deviceType?: 'desktop' | 'mobile' | 'tablet' | 'console' | null;
      /** @description Operating system or platform name */
      platform?: string | null;
      /** @description Browser name and version if applicable */
      browser?: string | null;
      /** @description Version of the client application */
      appVersion?: string | null;
    };
    /** @description Request to discard checkout */
    DiscardRequest: {
      /**
       * Format: uuid
       * @description Scene to discard changes for
       */
      sceneId: string;
      /** @description Checkout token */
      checkoutToken: string;
    };
    /** @description Response confirming discard */
    DiscardResponse: {
      /** @description Whether discard was successful */
      discarded: boolean;
    };
    /** @description Complete document with all metadata and content */
    Document: {
      /**
       * Format: uuid
       * @description Unique identifier of the document
       */
      documentId: string;
      /** @description Namespace the document belongs to */
      namespace: string;
      /** @description URL-friendly unique identifier */
      slug: string;
      /** @description Display title of the document */
      title: string;
      /** @description Category for organizing the document */
      category: components['schemas']['DocumentCategory'];
      /** @description Full markdown content of the document */
      content?: string;
      /** @description Brief text summary of the document */
      summary?: string | null;
      /** @description Concise summary optimized for voice AI */
      voiceSummary?: string | null;
      /** @description Tags for filtering and search */
      tags?: string[];
      /** @description IDs of related documents */
      relatedDocuments?: string[];
      /** @description Custom metadata key-value pairs */
      metadata?: {
        [key: string]: unknown;
      };
      /**
       * Format: date-time
       * @description Timestamp when the document was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the document was last updated
       */
      updatedAt: string;
    };
    /**
     * @description Fixed categories for type-safe filtering
     * @enum {string}
     */
    DocumentCategory:
      | 'getting-started'
      | 'api-reference'
      | 'architecture'
      | 'deployment'
      | 'troubleshooting'
      | 'tutorials'
      | 'game-systems'
      | 'world-lore'
      | 'npc-ai'
      | 'other';
    /** @description Search result with relevance scoring and match highlights */
    DocumentResult: {
      /**
       * Format: uuid
       * @description Unique identifier of the document
       */
      documentId: string;
      /** @description URL-friendly unique identifier */
      slug: string;
      /** @description Display title of the document */
      title: string;
      /** @description Category of the document */
      category?: components['schemas']['DocumentCategory'];
      /** @description Brief text summary of the document */
      summary?: string | null;
      /** @description Concise summary optimized for voice AI */
      voiceSummary?: string | null;
      /** @description Full document content if requested */
      content?: string | null;
      /**
       * Format: float
       * @description Relevance score from 0.0 to 1.0
       */
      relevanceScore: number;
      /** @description Text snippets showing where matches occurred */
      matchHighlights?: string[];
    };
    /** @description Lightweight document representation for listings and references */
    DocumentSummary: {
      /**
       * Format: uuid
       * @description Unique identifier of the document
       */
      documentId: string;
      /** @description URL-friendly unique identifier */
      slug: string;
      /** @description Display title of the document */
      title: string;
      /** @description Category of the document */
      category: components['schemas']['DocumentCategory'];
      /** @description Brief text summary of the document */
      summary?: string | null;
      /** @description Concise summary optimized for voice AI */
      voiceSummary?: string | null;
      /** @description Tags associated with the document */
      tags?: string[];
    };
    /** @description Download details for a specific game client version and platform */
    DownloadInfo: {
      /**
       * @description Target operating system platform
       * @enum {string}
       */
      platform: 'windows' | 'macos' | 'linux';
      /** @description Version number of the game client */
      version: string;
      /**
       * Format: uri
       * @description Download URL for the game client
       */
      url: string;
      /** @description File size in bytes */
      size: number;
      /** @description SHA256 checksum */
      checksum: string;
      /** @description Release notes or changelog for this version */
      releaseNotes?: string | null;
      /** @description Minimum system requirements for the client */
      minimumRequirements?: {
        [key: string]: unknown;
      };
    };
    /** @description Collection of available game client downloads by platform */
    DownloadsResponse: {
      /** @description Available game client downloads */
      clients: components['schemas']['DownloadInfo'][];
    };
    /** @description Request to duplicate a scene */
    DuplicateSceneRequest: {
      /**
       * Format: uuid
       * @description Scene to duplicate
       */
      sourceSceneId: string;
      /** @description Name for the duplicate */
      newName: string;
      /** @description Optional different game ID */
      newGameId?: string | null;
      /** @description Optional different scene type */
      newSceneType?: components['schemas']['SceneType'];
    };
    /**
     * @description How the encounter emotionally affected the character
     * @enum {string}
     */
    EmotionalImpact:
      | 'GRATITUDE'
      | 'ANGER'
      | 'FEAR'
      | 'RESPECT'
      | 'CONTEMPT'
      | 'AFFECTION'
      | 'RIVALRY'
      | 'INDIFFERENCE'
      | 'GUILT'
      | 'PRIDE';
    /** @description 6-dimensional emotional state input (all values 0-1) */
    EmotionalStateInput: {
      /** @description Tension level (0=resolved, 1=maximum tension) */
      tension?: number | null;
      /** @description Brightness level (0=dark, 1=bright) */
      brightness?: number | null;
      /** @description Energy level (0=calm, 1=energetic) */
      energy?: number | null;
      /** @description Warmth level (0=distant, 1=intimate) */
      warmth?: number | null;
      /** @description Stability level (0=unstable, 1=grounded) */
      stability?: number | null;
      /** @description Valence level (0=negative, 1=positive) */
      valence?: number | null;
    };
    /** @description Snapshot of emotional state at a specific point in the composition */
    EmotionalStateSnapshot: {
      /** @description Bar number where this snapshot was taken */
      bar: number;
      /** @description Name of the narrative phase at this point */
      phaseName?: string | null;
      /** @description Tension level (0-1) */
      tension: number;
      /** @description Brightness level (0-1) */
      brightness: number;
      /** @description Energy level (0-1) */
      energy: number;
      /** @description Warmth level (0-1) */
      warmth?: number;
      /** @description Stability level (0-1) */
      stability?: number;
      /** @description Valence level (0-1) */
      valence?: number;
    };
    /** @description Paginated list of encounters */
    EncounterListResponse: {
      /** @description List of encounters with perspectives */
      encounters: components['schemas']['EncounterResponse'][];
      /** @description Total matching encounters */
      totalCount: number;
      /** @description Current page (1-based) */
      page: number;
      /** @description Results per page */
      pageSize: number;
      /** @description Whether more results exist */
      hasNextPage?: boolean;
      /** @description Whether previous results exist */
      hasPreviousPage?: boolean;
    };
    /** @description Core encounter record representing a memorable interaction */
    EncounterModel: {
      /**
       * Format: uuid
       * @description Unique identifier for this encounter
       */
      encounterId: string;
      /**
       * Format: date-time
       * @description In-game time when the encounter occurred
       */
      timestamp: string;
      /**
       * Format: uuid
       * @description Realm where the encounter took place
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Specific location within the realm (optional)
       */
      locationId?: string | null;
      /** @description Type code for this encounter (e.g., COMBAT, TRADE) */
      encounterTypeCode: string;
      /** @description What triggered or contextualized the encounter */
      context?: string | null;
      /** @description Outcome of the encounter (POSITIVE, NEGATIVE, NEUTRAL, MEMORABLE, TRANSFORMATIVE) */
      outcome: components['schemas']['EncounterOutcome'];
      /** @description All character IDs involved in the encounter */
      participantIds: string[];
      /** @description Additional encounter-specific data */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description System timestamp when record was created
       */
      createdAt: string;
    };
    /**
     * @description Overall outcome of an encounter
     * @enum {string}
     */
    EncounterOutcome: 'POSITIVE' | 'NEGATIVE' | 'NEUTRAL' | 'MEMORABLE' | 'TRANSFORMATIVE';
    /** @description A character's individual perspective on an encounter */
    EncounterPerspectiveModel: {
      /**
       * Format: uuid
       * @description Unique identifier for this perspective
       */
      perspectiveId: string;
      /**
       * Format: uuid
       * @description Reference to the shared encounter record
       */
      encounterId: string;
      /**
       * Format: uuid
       * @description Character holding this perspective
       */
      characterId: string;
      /** @description Primary emotional response to the encounter */
      emotionalImpact: components['schemas']['EmotionalImpact'];
      /**
       * Format: float
       * @description Opinion change toward other participants (-1.0 to +1.0)
       */
      sentimentShift?: number | null;
      /**
       * Format: float
       * @description How strongly remembered (0.0-1.0, decays over time)
       */
      memoryStrength: number;
      /** @description Short description from this character's POV */
      rememberedAs?: string | null;
      /**
       * Format: date-time
       * @description When memory decay was last applied
       */
      lastDecayedAt?: string | null;
      /**
       * Format: date-time
       * @description System timestamp when record was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last modification timestamp
       */
      updatedAt?: string | null;
    };
    /** @description Response containing an encounter with perspectives */
    EncounterResponse: {
      /** @description The shared encounter record */
      encounter: components['schemas']['EncounterModel'];
      /** @description All perspectives on this encounter */
      perspectives: components['schemas']['EncounterPerspectiveModel'][];
    };
    /** @description Response containing a list of encounter types */
    EncounterTypeListResponse: {
      /** @description List of encounter types */
      types: components['schemas']['EncounterTypeResponse'][];
      /** @description Total number of types */
      totalCount: number;
    };
    /** @description Response containing an encounter type */
    EncounterTypeResponse: {
      /**
       * Format: uuid
       * @description Unique identifier
       */
      typeId: string;
      /** @description Unique code */
      code: string;
      /** @description Display name */
      name: string;
      /** @description Description */
      description?: string | null;
      /** @description Whether this is a built-in type */
      isBuiltIn: boolean;
      /** @description Suggested emotional response */
      defaultEmotionalImpact?: components['schemas']['EmotionalImpact'];
      /** @description Display ordering */
      sortOrder: number;
      /** @description Whether the type is active */
      isActive: boolean;
      /**
       * Format: date-time
       * @description When the type was created
       */
      createdAt: string;
    };
    /** @description Request to end an active encounter */
    EndEncounterRequest: {
      /** @description ID of the Event Brain actor managing the encounter */
      actorId: string;
    };
    /** @description Response after ending an encounter */
    EndEncounterResponse: {
      /** @description ID of the actor */
      actorId: string;
      /** @description ID of the ended encounter */
      encounterId: string;
      /** @description Duration of the encounter in milliseconds */
      durationMs?: number | null;
    };
    /**
     * @description Character data with optional enriched fields.
     *     Fields are only populated if the corresponding include flag was set in the request.
     */
    EnrichedCharacterResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the character
       */
      characterId: string;
      /** @description Display name of the character */
      name: string;
      /**
       * Format: uuid
       * @description Realm ID (partition key)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Species ID (foreign key to Species service)
       */
      speciesId: string;
      /**
       * Format: date-time
       * @description In-game birth timestamp
       */
      birthDate: string;
      /**
       * Format: date-time
       * @description In-game death timestamp
       */
      deathDate?: string | null;
      /** @description Current lifecycle status of the character */
      status: components['schemas']['CharacterStatus'];
      /**
       * Format: date-time
       * @description Real-world creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Real-world last update timestamp
       */
      updatedAt?: string | null;
      /** @description Personality traits (included if includePersonality=true) */
      personality?: components['schemas']['PersonalitySnapshot'];
      /** @description Backstory elements (included if includeBackstory=true) */
      backstory?: components['schemas']['BackstorySnapshot'];
      /** @description Family relationships (included if includeFamilyTree=true) */
      familyTree?: components['schemas']['FamilyTreeResponse'];
      /** @description Combat preferences (included if includeCombatPreferences=true) */
      combatPreferences?: components['schemas']['CombatPreferencesSnapshot'];
    };
    /** @description Entity's rank on a leaderboard */
    EntityRankResponse: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type for the ranked entity */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: double
       * @description Entity's current score
       */
      score: number;
      /**
       * Format: int64
       * @description Entity's current rank (1-based)
       */
      rank: number;
      /**
       * Format: int64
       * @description Total entries on the leaderboard
       */
      totalEntries: number;
      /**
       * Format: double
       * @description Percentile ranking (0-100)
       */
      percentile?: number;
    };
    /**
     * @description Type of entity that can earn achievements
     * @enum {string}
     */
    EntityType: 'account' | 'character' | 'guild' | 'actor' | 'custom';
    /** @description Standard error response with code and message */
    ErrorResponse: {
      /** @description Error code identifying the type of error */
      error: string;
      /** @description Human-readable error message */
      message: string;
      /** @description Additional error details or context */
      details?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Categories of historical events that characters can participate in
     * @enum {string}
     */
    EventCategory:
      | 'WAR'
      | 'NATURAL_DISASTER'
      | 'POLITICAL'
      | 'ECONOMIC'
      | 'RELIGIOUS'
      | 'CULTURAL'
      | 'PERSONAL';
    /** @description Metadata about behavior execution requirements including timing, resources, and interrupt conditions */
    ExecutionMetadata: {
      /** @description Estimated execution time in seconds */
      estimatedDuration?: number;
      /** @description Resource requirements for behavior execution */
      resourceRequirements?: {
        [key: string]: number;
      } | null;
      /** @description Conditions that can interrupt behavior execution */
      interruptConditions?: string[] | null;
    };
    /** @description Request to export all saves for an owner to a downloadable archive */
    ExportSavesRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the saves to export
       */
      ownerId: string;
      /** @description Type of entity that owns the saves to export */
      ownerType: components['schemas']['OwnerType'];
      /** @description Specific slots to export (all if null) */
      slotNames?: string[];
    };
    /** @description Response with pre-signed URL for downloading exported save archive */
    ExportSavesResponse: {
      /**
       * Format: uri
       * @description Pre-signed URL to download export archive
       */
      downloadUrl: string;
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Archive size
       */
      sizeBytes: number;
    };
    /** @description Reference to a family member */
    FamilyMember: {
      /**
       * Format: uuid
       * @description ID of the related character
       */
      characterId: string;
      /** @description Display name (if available) */
      name?: string | null;
      /** @description Specific relationship type (MOTHER, FATHER, SON, DAUGHTER, etc.) */
      relationshipType: string;
      /** @description Whether the related character is alive */
      isAlive?: boolean;
    };
    /** @description Family relationships for a character */
    FamilyTreeResponse: {
      /** @description Parent relationships (biological and adoptive) */
      parents?: components['schemas']['FamilyMember'][];
      /** @description Child relationships */
      children?: components['schemas']['FamilyMember'][];
      /** @description Sibling relationships (including half-siblings) */
      siblings?: components['schemas']['FamilyMember'][];
      /** @description Current spouse (if any) */
      spouse?: components['schemas']['FamilyMember'];
      /** @description Previous incarnations (if reincarnation tracked) */
      pastLives?: components['schemas']['PastLifeReference'][];
    };
    /** @description Request to find asset usage */
    FindAssetUsageRequest: {
      /**
       * Format: uuid
       * @description Asset ID to find usage of
       */
      assetId: string;
      /** @description Optional game filter */
      gameId?: string | null;
    };
    /** @description Scenes using the asset */
    FindAssetUsageResponse: {
      /** @description Asset usage instances */
      usages: components['schemas']['AssetUsageInfo'][];
    };
    /** @description Request to find referencing scenes */
    FindReferencesRequest: {
      /**
       * Format: uuid
       * @description Scene ID to find references to
       */
      sceneId: string;
    };
    /** @description Scenes that reference the target */
    FindReferencesResponse: {
      /** @description Scenes containing references */
      referencingScenes: components['schemas']['ReferenceInfo'][];
    };
    /** @description A musical form structure template */
    FormTemplate: {
      /** @description Form name (e.g., "AABB", "verse-chorus") */
      name: string;
      /** @description Section sequence (e.g., ["A", "A", "B", "B"]) */
      sections: string[];
      /**
       * @description Default bars per section
       * @default 8
       */
      barsPerSection: number;
    };
    /** @description Request to perform a game action such as movement or combat */
    GameActionRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the client. Provided by shortcut system.
       */
      sessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player. Provided by shortcut system.
       */
      accountId: string;
      /** @description Game type for the action. Determines which lobby to apply the action. Provided by shortcut system. */
      gameType: string;
      /**
       * @description Type of game action to perform
       * @enum {string}
       */
      actionType: 'move' | 'interact' | 'attack' | 'cast_spell' | 'use_item';
      /** @description Action-specific data */
      actionData?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: uuid
       * @description Target of the action (if applicable)
       */
      targetId?: string | null;
    };
    /** @description Response indicating the result of a game action with any state changes */
    GameActionResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for this action instance
       */
      actionId: string;
      /** @description Action result data */
      result?: {
        [key: string]: unknown;
      } | null;
      /** @description Updated game state (if applicable) */
      newGameState?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Information about a player currently participating in a game session */
    GamePlayer: {
      /**
       * Format: uuid
       * @description Unique identifier for the player's account
       */
      accountId: string;
      /** @description WebSocket session ID that joined the game. Chat and events are delivered to this specific session only. */
      sessionId: string;
      /** @description Display name shown to other players */
      displayName?: string | null;
      /**
       * @description Role of the player in the game session
       * @enum {string}
       */
      role: 'player' | 'spectator' | 'moderator';
      /**
       * Format: date-time
       * @description Timestamp when the player joined the session
       */
      joinedAt: string;
      /** @description Game-specific character data for this player (null if none provided) */
      characterData?: {
        [key: string]: unknown;
      } | null;
      /** @description Voice participant session ID (if player has joined voice) */
      voiceSessionId?: string | null;
    };
    /** @description Complete details of a game session including players and settings */
    GameSessionResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the game session
       */
      sessionId: string;
      /**
       * @description Type of game for this session
       * @enum {string}
       */
      gameType: 'arcadia' | 'generic';
      /** @description Type of session - lobby or matchmade */
      sessionType: components['schemas']['SessionType'];
      /** @description Display name for the session */
      sessionName?: string | null;
      /**
       * @description Current status of the game session
       * @enum {string}
       */
      status: 'waiting' | 'active' | 'full' | 'finished';
      /** @description Maximum number of players allowed in the session */
      maxPlayers?: number;
      /** @description Current number of players in the session */
      currentPlayers?: number;
      /** @description Whether the session requires a password to join */
      isPrivate?: boolean;
      /**
       * Format: uuid
       * @description Account ID of the session owner
       */
      owner?: string;
      /** @description List of players currently in the session */
      players?: components['schemas']['GamePlayer'][];
      /**
       * Format: date-time
       * @description Timestamp when the session was created
       */
      createdAt: string;
      /** @description Game-specific configuration settings */
      gameSettings?: {
        [key: string]: unknown;
      } | null;
      /** @description For matchmade sessions - reservation tokens for expected players */
      reservations?: components['schemas']['ReservationInfo'][] | null;
      /**
       * Format: date-time
       * @description For matchmade sessions - when reservations expire
       */
      reservationExpiresAt?: string | null;
    };
    /** @description Request to generate a complete musical composition */
    GenerateCompositionRequest: {
      /**
       * @description ID of the style to use for generation
       * @example celtic
       */
      styleId: string;
      /**
       * @description Target duration in bars
       * @default 32
       */
      durationBars: number;
      /** @description Key signature (random if not specified) */
      key?: components['schemas']['KeySignature'];
      /** @description Tempo in BPM (uses style default if not specified) */
      tempo?: number;
      /**
       * @description Mood constraint for generation
       * @enum {string|null}
       */
      mood?: 'bright' | 'dark' | 'neutral' | 'melancholic' | 'triumphant' | null;
      /**
       * @description Style-specific tune type (e.g., "reel", "jig" for Celtic)
       * @example reel
       */
      tuneType?: string | null;
      /** @description Random seed for reproducible generation */
      seed?: number | null;
      /**
       * @description Narrative/emotional arc options for storyteller-driven composition.
       *     If omitted, narrative is inferred from mood. When provided, enables
       *     fine-grained control over emotional journey and tension curves.
       */
      narrative?: components['schemas']['NarrativeOptions'];
    };
    /** @description Response containing the generated composition */
    GenerateCompositionResponse: {
      /** @description Unique identifier for the composition */
      compositionId: string;
      /** @description Generated MIDI-JSON output */
      midiJson: components['schemas']['MidiJson'];
      /** @description Metadata about the generation */
      metadata?: components['schemas']['CompositionMetadata'];
      /** @description Time taken to generate in milliseconds */
      generationTimeMs?: number;
      /** @description ID of the narrative template used for composition */
      narrativeUsed?: string | null;
      /** @description Emotional state at each section boundary */
      emotionalJourney?: components['schemas']['EmotionalStateSnapshot'][] | null;
      /** @description Tension values at bar boundaries (0-1 scale) */
      tensionCurve?: number[] | null;
    };
    /** @description Request to generate a melody over harmony */
    GenerateMelodyRequest: {
      /** @description Chord progression to generate melody over */
      harmony: components['schemas']['ChordEvent'][];
      /** @description Style for melodic preferences */
      styleId?: string | null;
      /** @description Pitch range for the melody */
      range?: components['schemas']['PitchRange'];
      /**
       * @description Overall melodic contour
       * @enum {string|null}
       */
      contour?: 'arch' | 'wave' | 'ascending' | 'descending' | 'static' | null;
      /**
       * Format: float
       * @description Note density (0=sparse, 1=dense)
       */
      rhythmDensity?: number | null;
      /**
       * Format: float
       * @description Amount of syncopation
       */
      syncopation?: number | null;
      /** @description Random seed for reproducibility */
      seed?: number | null;
    };
    /** @description Response containing a generated melody */
    GenerateMelodyResponse: {
      /** @description Generated note events */
      notes: components['schemas']['NoteEvent'][];
      /** @description Analysis of the melody */
      analysis?: components['schemas']['MelodyAnalysis'];
    };
    /** @description Request to generate a chord progression */
    GenerateProgressionRequest: {
      /** @description Key for the progression */
      key: components['schemas']['KeySignature'];
      /** @description Number of chords in the progression */
      length: number;
      /** @description Style to use for harmonic preferences */
      styleId?: string | null;
      /** @description Starting chord (roman numeral, e.g., "I") */
      startChord?: string | null;
      /** @description Ending chord (roman numeral, e.g., "I") */
      endChord?: string | null;
      /**
       * @description Cadence type for ending
       * @enum {string|null}
       */
      cadenceType?: 'authentic' | 'half' | 'plagal' | 'deceptive' | null;
      /**
       * @description Allow secondary dominant chords
       * @default true
       */
      allowSecondaryDominants: boolean;
      /**
       * @description Allow borrowed chords from parallel modes
       * @default false
       */
      allowModalInterchange: boolean;
      /** @description Random seed for reproducibility */
      seed?: number | null;
    };
    /** @description Response containing a generated chord progression */
    GenerateProgressionResponse: {
      /** @description Generated chord events */
      chords: components['schemas']['ChordEvent'][];
      /** @description Analysis of the progression */
      analysis?: components['schemas']['ProgressionAnalysis'];
    };
    /** @description Request to get subscriptions for an account */
    GetAccountSubscriptionsRequest: {
      /**
       * Format: uuid
       * @description ID of the account to get subscriptions for
       */
      accountId: string;
      /**
       * @description If true, include cancelled subscriptions
       * @default false
       */
      includeInactive: boolean;
      /**
       * @description If true, include expired subscriptions
       * @default false
       */
      includeExpired: boolean;
    };
    /** @description Request to get achievement progress */
    GetAchievementProgressRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type whose progress is requested */
      entityType: components['schemas']['EntityType'];
      /** @description Specific achievement ID (null for all) */
      achievementId?: string | null;
    };
    /** @description Request to retrieve all ancestor types in the hierarchy chain from a relationship type up to the root */
    GetAncestorsRequest: {
      /**
       * Format: uuid
       * @description The relationship type to get ancestors for
       */
      typeId: string;
    };
    /** @description Request to retrieve asset metadata and download URL */
    GetAssetRequest: {
      /** @description Asset identifier */
      assetId: string;
      /**
       * @description Version ID or 'latest'
       * @default latest
       */
      version: string;
    };
    /** @description Request payload for getting a character's backstory */
    GetBackstoryRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get backstory for
       */
      characterId: string;
      /** @description Filter by element types (null for all) */
      elementTypes?: components['schemas']['BackstoryElementType'][] | null;
      /**
       * Format: float
       * @description Filter by minimum strength
       */
      minimumStrength?: number | null;
    };
    /** @description Request to retrieve bundle metadata and download URL */
    GetBundleRequest: {
      /** @description Bundle identifier to retrieve */
      bundleId: string;
      /** @description Desired download format (bannou or zip) */
      format?: components['schemas']['BundleFormat'];
    };
    /** @description Request to get a cached compiled behavior */
    GetCachedBehaviorRequest: {
      /** @description Unique identifier for the cached behavior */
      behaviorId: string;
    };
    /** @description Request to retrieve a character's compressed archive */
    GetCharacterArchiveRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get archive for
       */
      characterId: string;
    };
    /** @description Request payload for retrieving a single character by ID */
    GetCharacterRequest: {
      /**
       * Format: uuid
       * @description ID of the character to retrieve
       */
      characterId: string;
    };
    /** @description Request payload for retrieving all characters within a specific realm */
    GetCharactersByRealmRequest: {
      /**
       * Format: uuid
       * @description Realm ID to query (uses partition key for efficiency)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Filter by species
       */
      speciesId?: string | null;
      /** @description Optional status filter */
      status?: components['schemas']['CharacterStatus'] | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to retrieve all child relationship types for a given parent type */
    GetChildRelationshipTypesRequest: {
      /**
       * Format: uuid
       * @description ID of the parent relationship type
       */
      parentTypeId: string;
      /**
       * @description Include all descendants, not just direct children
       * @default false
       */
      recursive: boolean;
    };
    /** @description Request to get capability manifest for a connected session (debugging endpoint) */
    GetClientCapabilitiesRequest: {
      /** @description Session ID to retrieve capabilities for (must have active WebSocket connection) */
      sessionId: string;
      /** @description Optional filter by service name prefix */
      serviceFilter?: string | null;
      /**
       * @description Include additional metadata about each capability
       * @default false
       */
      includeMetadata: boolean;
    };
    /** @description Request payload for retrieving combat preferences */
    GetCombatPreferencesRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get combat preferences for
       */
      characterId: string;
    };
    /** @description Request to get a map definition */
    GetDefinitionRequest: {
      /**
       * Format: uuid
       * @description Definition ID to retrieve
       */
      definitionId: string;
    };
    /** @description Request to retrieve a specific document by ID or slug */
    GetDocumentRequest: {
      /** @description Documentation namespace containing the document */
      namespace: string;
      /**
       * Format: uuid
       * @description Unique identifier of the document to retrieve (null if using slug)
       */
      documentId?: string | null;
      /** @description URL-friendly slug of the document to retrieve (null if using documentId) */
      slug?: string | null;
      /**
       * Format: uuid
       * @description Optional session ID for tracking document views (null if not tracking)
       */
      sessionId?: string | null;
      /** @description How deep to fetch related documents (null for no related documents) */
      includeRelated?: components['schemas']['RelatedDepth'];
      /**
       * @description Whether to include full document content
       * @default false
       */
      includeContent: boolean;
      /**
       * @description Whether to render markdown content as HTML
       * @default false
       */
      renderHtml: boolean;
    };
    /** @description Response containing the requested document and optional related documents */
    GetDocumentResponse: {
      /** @description The requested document */
      document: components['schemas']['Document'];
      /** @description List of related documents based on includeRelated depth */
      relatedDocuments?: components['schemas']['DocumentSummary'][];
      /**
       * @description Format of the content field in the response
       * @enum {string}
       */
      contentFormat?: 'markdown' | 'html' | 'none';
    };
    /** @description Request to retrieve an encounter type by code */
    GetEncounterTypeRequest: {
      /** @description Unique code of the encounter type */
      code: string;
    };
    /**
     * @description Request payload for retrieving a character with optional related data.
     *     Each include flag fetches data from its respective service (zero overhead if not requested).
     */
    GetEnrichedCharacterRequest: {
      /**
       * Format: uuid
       * @description ID of the character to retrieve
       */
      characterId: string;
      /**
       * @description Include personality traits from character-personality service
       * @default false
       */
      includePersonality: boolean;
      /**
       * @description Include backstory elements from character-history service
       * @default false
       */
      includeBackstory: boolean;
      /**
       * @description Include family relationships from relationship service
       * @default false
       */
      includeFamilyTree: boolean;
      /**
       * @description Include combat preferences from character-personality service
       * @default false
       */
      includeCombatPreferences: boolean;
    };
    /** @description Request to get an entity's rank */
    GetEntityRankRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type whose rank is requested */
      entityType: components['schemas']['EntityType'];
    };
    /** @description Request payload for getting participants of an event */
    GetEventParticipantsRequest: {
      /**
       * Format: uuid
       * @description ID of the historical event
       */
      eventId: string;
      /** @description Filter by participation role */
      role?: components['schemas']['ParticipationRole'];
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to get a specific game session */
    GetGameSessionRequest: {
      /**
       * Format: uuid
       * @description ID of the game session to retrieve
       */
      sessionId: string;
    };
    /** @description Request to get the status of an async metabundle creation job */
    GetJobStatusRequest: {
      /**
       * Format: uuid
       * @description Job ID from the createMetabundle response
       */
      jobId: string;
    };
    /**
     * @description Status of an async metabundle creation job.
     *     When status is 'ready', the response includes the full metabundle details.
     */
    GetJobStatusResponse: {
      /**
       * Format: uuid
       * @description Job identifier
       */
      jobId: string;
      /** @description Metabundle identifier being created */
      metabundleId: string;
      /**
       * @description Current job status.
       *     - queued: Waiting for processing resources
       *     - processing: Actively being processed
       *     - ready: Completed successfully
       *     - failed: Creation failed
       *     - cancelled: Job was cancelled
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed' | 'cancelled';
      /** @description Progress percentage (0-100) when status is 'processing' */
      progress?: number | null;
      /**
       * Format: uri
       * @description Pre-signed download URL (only when status is 'ready')
       */
      downloadUrl?: string | null;
      /** @description Number of assets in metabundle (when ready) */
      assetCount?: number | null;
      /** @description Number of standalone assets included (when ready) */
      standaloneAssetCount?: number | null;
      /**
       * Format: int64
       * @description Total size in bytes (when ready)
       */
      sizeBytes?: number | null;
      /** @description Provenance data (when ready) */
      sourceBundles?: components['schemas']['SourceBundleReference'][] | null;
      /** @description Error code (when status is 'failed') */
      errorCode?: string | null;
      /** @description Human-readable error description (when status is 'failed') */
      errorMessage?: string | null;
      /**
       * Format: date-time
       * @description When the job was created
       */
      createdAt?: string | null;
      /**
       * Format: date-time
       * @description When the job was last updated
       */
      updatedAt?: string | null;
      /**
       * Format: int64
       * @description Total processing time in milliseconds (when complete)
       */
      processingTimeMs?: number | null;
    };
    /** @description Request to retrieve the full ancestry chain of a location up to the root */
    GetLocationAncestorsRequest: {
      /**
       * Format: uuid
       * @description The location to get ancestors for
       */
      locationId: string;
    };
    /** @description Request to retrieve a location by its code within a specific realm */
    GetLocationByCodeRequest: {
      /** @description Unique code for the location within the realm */
      code: string;
      /**
       * Format: uuid
       * @description Realm ID to scope the code lookup
       */
      realmId: string;
    };
    /** @description Request to retrieve all descendants of a location (children, grandchildren, etc.) */
    GetLocationDescendantsRequest: {
      /**
       * Format: uuid
       * @description The location to get descendants for
       */
      locationId: string;
      /** @description Optional filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /** @description Maximum depth of descendants to return (null = all) */
      maxDepth?: number | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to retrieve a location by its unique identifier */
    GetLocationRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the location
       */
      locationId: string;
    };
    /** @description Request to get matchmaking statistics */
    GetMatchmakingStatsRequest: {
      /** @description Filter by specific queue (null for all queues) */
      queueId?: string | null;
      /** @description Filter by game ID */
      gameId?: string | null;
    };
    /** @description Request to get matchmaking status */
    GetMatchmakingStatusRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the ticket to query
       */
      ticketId: string;
    };
    /** @description Request payload for getting a character's event participation */
    GetParticipationRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get participation for
       */
      characterId: string;
      /** @description Filter by event category */
      eventCategory?: components['schemas']['EventCategory'];
      /**
       * Format: float
       * @description Filter by minimum significance
       */
      minimumSignificance?: number | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request payload for retrieving a character's personality */
    GetPersonalityRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get personality for
       */
      characterId: string;
    };
    /** @description Request to get a character's perspective on an encounter */
    GetPerspectiveRequest: {
      /**
       * Format: uuid
       * @description Encounter to get perspective for
       */
      encounterId: string;
      /**
       * Format: uuid
       * @description Character whose perspective to retrieve
       */
      characterId: string;
    };
    /** @description Request to get details of a specific queue */
    GetQueueRequest: {
      /** @description ID of the queue to retrieve */
      queueId: string;
    };
    /** @description Request to get entries around an entity */
    GetRanksAroundRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /**
       * Format: uuid
       * @description ID of the entity to center on
       */
      entityId: string;
      /** @description Entity type of the anchor entry */
      entityType: components['schemas']['EntityType'];
      /**
       * @description Entries to show before the entity
       * @default 5
       */
      countBefore: number;
      /**
       * @description Entries to show after the entity
       * @default 5
       */
      countAfter: number;
    };
    /** @description Request to retrieve a realm by its unique code identifier */
    GetRealmByCodeRequest: {
      /** @description Unique code for the realm (e.g., "OMEGA", "ARCADIA", "FANTASIA") */
      code: string;
    };
    /** @description Request payload for getting participants of an event */
    GetRealmEventParticipantsRequest: {
      /**
       * Format: uuid
       * @description ID of the historical event
       */
      eventId: string;
      /** @description Filter by participation role */
      role?: components['schemas']['RealmEventRole'];
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request payload for getting a realm's lore */
    GetRealmLoreRequest: {
      /**
       * Format: uuid
       * @description ID of the realm to get lore for
       */
      realmId: string;
      /** @description Filter by element types (null for all) */
      elementTypes?: components['schemas']['RealmLoreElementType'][] | null;
      /**
       * Format: float
       * @description Filter by minimum strength
       */
      minimumStrength?: number | null;
    };
    /** @description Request payload for getting a realm's event participation */
    GetRealmParticipationRequest: {
      /**
       * Format: uuid
       * @description ID of the realm to get participation for
       */
      realmId: string;
      /** @description Filter by event category */
      eventCategory?: components['schemas']['RealmEventCategory'];
      /**
       * Format: float
       * @description Filter by minimum impact
       */
      minimumImpact?: number | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to retrieve a specific realm by its unique identifier */
    GetRealmRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the realm
       */
      realmId: string;
    };
    /** @description Request to retrieve a specific relationship by its ID */
    GetRelationshipRequest: {
      /**
       * Format: uuid
       * @description ID of the relationship to retrieve
       */
      relationshipId: string;
    };
    /** @description Request to retrieve a relationship type by its unique code string */
    GetRelationshipTypeByCodeRequest: {
      /** @description Unique code for the relationship type (e.g., "SON", "MOTHER", "FRIEND") */
      code: string;
    };
    /** @description Request to retrieve a relationship type by its unique identifier */
    GetRelationshipTypeRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the relationship type
       */
      relationshipTypeId: string;
    };
    /** @description Request to get all relationships between two specific entities */
    GetRelationshipsBetweenRequest: {
      /**
       * Format: uuid
       * @description ID of the first entity to check relationships for
       */
      entity1Id: string;
      /** @description Type of the first entity */
      entity1Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the second entity to check relationships for
       */
      entity2Id: string;
      /** @description Type of the second entity */
      entity2Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Optional filter by relationship type
       */
      relationshipTypeId?: string | null;
      /**
       * @description Include relationships that have ended
       * @default false
       */
      includeEnded: boolean;
    };
    /** @description Request to retrieve a scene */
    GetSceneRequest: {
      /**
       * Format: uuid
       * @description ID of the scene to retrieve
       */
      sceneId: string;
      /** @description Specific version to retrieve (null = latest) */
      version?: string | null;
      /**
       * @description Whether to resolve and embed referenced scenes
       * @default false
       */
      resolveReferences: boolean;
      /**
       * @description Maximum depth for reference resolution (prevents infinite recursion)
       * @default 3
       */
      maxReferenceDepth: number;
    };
    /** @description Response containing a scene and resolution metadata */
    GetSceneResponse: {
      /** @description The retrieved scene */
      scene: components['schemas']['Scene'];
      /** @description List of resolved references (if resolveReferences was true) */
      resolvedReferences?: components['schemas']['ResolvedReference'][] | null;
      /** @description References that could not be resolved (circular, missing, depth exceeded) */
      unresolvedReferences?: components['schemas']['UnresolvedReference'][] | null;
      /** @description Error messages for reference resolution issues */
      resolutionErrors?: string[] | null;
    };
    /** @description Request to get season information */
    GetSeasonRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /** @description Specific season number (null for current) */
      seasonNumber?: number | null;
    };
    /** @description Request to get aggregate sentiment toward another character */
    GetSentimentRequest: {
      /**
       * Format: uuid
       * @description Character whose sentiment to query
       */
      characterId: string;
      /**
       * Format: uuid
       * @description Target character to measure sentiment toward
       */
      targetCharacterId: string;
    };
    /** @description Request to get a service by ID or stub name (provide either one) */
    GetServiceRequest: {
      /**
       * Format: uuid
       * @description ID of the service to retrieve (null if using stubName)
       */
      serviceId?: string | null;
      /** @description Stub name of the service to retrieve (null if using serviceId) */
      stubName?: string | null;
    };
    /** @description Request to retrieve metadata for a specific save slot */
    GetSlotRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
    };
    /** @description Request to retrieve a species by its unique code identifier */
    GetSpeciesByCodeRequest: {
      /** @description Unique code for the species (e.g., "HUMAN", "ELF", "DWARF") */
      code: string;
    };
    /** @description Request to retrieve a single species by its unique identifier */
    GetSpeciesRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the species
       */
      speciesId: string;
    };
    /** @description Request to get a style definition */
    GetStyleRequest: {
      /** @description Style ID to retrieve */
      styleId?: string | null;
      /** @description Style name to retrieve (alternative to ID) */
      styleName?: string | null;
    };
    /** @description Request to get a specific subscription */
    GetSubscriptionRequest: {
      /**
       * Format: uuid
       * @description ID of the subscription to retrieve
       */
      subscriptionId: string;
    };
    /** @description Request to get top leaderboard entries */
    GetTopRanksRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /**
       * @description Number of entries to return
       * @default 100
       */
      count: number;
      /**
       * @description Number of entries to skip
       * @default 0
       */
      offset: number;
    };
    /** @description Request to get validation rules */
    GetValidationRulesRequest: {
      /** @description Game ID */
      gameId: string;
      /** @description Scene type */
      sceneType: components['schemas']['SceneType'];
    };
    /** @description Response containing validation rules */
    GetValidationRulesResponse: {
      /** @description Game ID */
      gameId: string;
      /** @description Scene type */
      sceneType: components['schemas']['SceneType'];
      /** @description Registered rules (empty if none) */
      rules?: components['schemas']['ValidationRule'][];
    };
    /** @description Goal definition for GOAP planning with conditions and priority */
    GoapGoal: {
      /**
       * @description Name of the goal
       * @example satisfy_hunger
       */
      name: string;
      /** @description Human-readable description of the goal */
      description?: string | null;
      /**
       * @description World state conditions that satisfy this goal (literal conditions)
       * @example {
       *       "hunger": "<= 0.3",
       *       "gold": ">= 50"
       *     }
       */
      conditions: {
        [key: string]: string;
      };
      /** @description Priority of this goal relative to others */
      priority: number;
      /** @description World state conditions required to pursue this goal */
      preconditions?: {
        [key: string]: string;
      } | null;
    };
    /** @description Request to generate a GOAP plan to achieve a goal from current world state */
    GoapPlanRequest: {
      /** @description Unique identifier for the agent requesting the plan */
      agentId?: string | null;
      /** @description The goal to achieve through planning */
      goal: components['schemas']['GoapGoal'];
      /**
       * @description Current world state as key-value pairs
       * @example {
       *       "hunger": 0.8,
       *       "gold": 50,
       *       "location": "home"
       *     }
       */
      worldState: {
        [key: string]: unknown;
      };
      /** @description ID of compiled behavior containing GOAP actions */
      behaviorId: string;
      /** @description Options controlling the planning process */
      options?: components['schemas']['GoapPlanningOptions'];
    };
    /** @description Response containing the generated GOAP plan. If no plan could be found, plan is null and failureReason explains why. */
    GoapPlanResponse: {
      /** @description The generated plan if successful */
      plan?: components['schemas']['GoapPlanResult'];
      /** @description Time spent planning in milliseconds */
      planningTimeMs?: number;
      /** @description Number of nodes expanded during A* search */
      nodesExpanded?: number;
      /**
       * @description Reason for planning failure if unsuccessful
       * @example No plan found - goal unreachable
       */
      failureReason?: string | null;
    };
    /** @description Result of GOAP planning containing the ordered sequence of actions to achieve a goal */
    GoapPlanResult: {
      /** @description ID of the goal this plan achieves */
      goalId: string;
      /** @description Ordered sequence of actions to execute */
      actions: components['schemas']['PlannedActionResponse'][];
      /**
       * Format: float
       * @description Total cost of all actions in the plan
       */
      totalCost: number;
    };
    /** @description Options controlling the GOAP planning process including depth and timeout limits */
    GoapPlanningOptions: {
      /**
       * @description Maximum plan depth (number of actions)
       * @default 10
       */
      maxDepth: number;
      /**
       * @description Maximum nodes to expand during search
       * @default 1000
       */
      maxNodes: number;
      /**
       * @description Planning timeout in milliseconds
       * @default 100
       */
      timeoutMs: number;
    };
    /**
     * @description Preferred role when fighting in groups. Affects positioning,
     *     target priority, and coordination behavior.
     * @enum {string}
     */
    GroupRole: 'FRONTLINE' | 'SUPPORT' | 'FLANKER' | 'LEADER' | 'SOLO';
    /** @description Harmonic progression style preferences */
    HarmonyStyle: {
      /**
       * @description Most common cadence type
       * @default authentic
       * @enum {string}
       */
      primaryCadence: 'authentic' | 'plagal' | 'half' | 'deceptive';
      /**
       * Format: float
       * @description Probability of pre-dominant before dominant
       * @default 0.6
       */
      dominantPrepProbability: number;
      /**
       * Format: float
       * @description Probability of secondary dominants
       * @default 0.3
       */
      secondaryDominantProbability: number;
      /**
       * Format: float
       * @description Probability of borrowed chords
       * @default 0.1
       */
      modalInterchangeProbability: number;
      /** @description Common chord progressions as roman numeral strings */
      commonProgressions?: string[] | null;
    };
    /** @description Request to check if two characters have met */
    HasMetRequest: {
      /**
       * Format: uuid
       * @description First character
       */
      characterIdA: string;
      /**
       * Format: uuid
       * @description Second character
       */
      characterIdB: string;
    };
    /** @description Response for has-met check */
    HasMetResponse: {
      /** @description Whether the characters have any recorded encounters */
      hasMet: boolean;
      /** @description Total number of encounters between them */
      encounterCount: number;
    };
    /** @description Information about a hazard in range */
    HazardInfo: {
      /** @description Type of hazard (fire, poison, radiation, deep_water, etc.) */
      hazardType?: string;
      /**
       * Format: float
       * @description Distance to hazard edge
       */
      distance?: number;
      /**
       * Format: float
       * @description Hazard severity (0-1)
       */
      severity?: number;
      /** @description Direction to hazard center */
      direction?: string | null;
    } & {
      [key: string]: unknown;
    };
    /** @description Request to extend checkout lock */
    HeartbeatRequest: {
      /**
       * Format: uuid
       * @description Scene being edited
       */
      sceneId: string;
      /** @description Checkout token */
      checkoutToken: string;
    };
    /** @description Response confirming lock extension */
    HeartbeatResponse: {
      /** @description Whether extension was successful */
      extended: boolean;
      /**
       * Format: date-time
       * @description New expiration time
       */
      newExpiresAt: string;
      /** @description Number of extensions remaining */
      extensionsRemaining?: number;
    };
    /** @description Record of a character's participation in a historical event */
    HistoricalParticipation: {
      /**
       * Format: uuid
       * @description Unique ID for this participation record
       */
      participationId: string;
      /**
       * Format: uuid
       * @description ID of the character who participated
       */
      characterId: string;
      /**
       * Format: uuid
       * @description ID of the historical event
       */
      eventId: string;
      /** @description Name of the event (for display and summarization) */
      eventName: string;
      /** @description Category of the historical event */
      eventCategory: components['schemas']['EventCategory'];
      /** @description How the character participated */
      role: components['schemas']['ParticipationRole'];
      /**
       * Format: date-time
       * @description In-game date when the event occurred
       */
      eventDate: string;
      /**
       * Format: float
       * @description How significant this event was for the character (0.0 to 1.0).
       *     Affects behavior system weighting of this memory.
       * @default 0.5
       */
      significance: number;
      /** @description Event-specific details for behavior decisions */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When this record was created
       */
      createdAt: string;
    };
    /** @description Request for scene version history */
    HistoryRequest: {
      /**
       * Format: uuid
       * @description Scene to get history for
       */
      sceneId: string;
      /**
       * @description Maximum versions to return
       * @default 10
       */
      limit: number;
    };
    /** @description Scene version history */
    HistoryResponse: {
      /**
       * Format: uuid
       * @description Scene ID
       */
      sceneId: string;
      /** @description Current active version */
      currentVersion?: string;
      /** @description Version history entries */
      versions: components['schemas']['VersionInfo'][];
    };
    /** @description Request to inject a perception event into an actor's queue */
    InjectPerceptionRequest: {
      /** @description Target actor to inject perception into */
      actorId: string;
      /** @description Perception data to inject */
      perception: components['schemas']['PerceptionData'];
    };
    /** @description Response confirming perception injection */
    InjectPerceptionResponse: {
      /** @description Whether the perception was successfully queued */
      queued: boolean;
      /** @description Current depth of the perception queue */
      queueDepth: number;
    };
    /** @description Melodic interval preference weights */
    IntervalPreferences: {
      /**
       * Format: float
       * @description Weight for stepwise motion (M2, m2)
       * @default 0.5
       */
      stepWeight: number;
      /**
       * Format: float
       * @description Weight for thirds (M3, m3)
       * @default 0.25
       */
      thirdWeight: number;
      /**
       * Format: float
       * @description Weight for larger leaps (P4, P5)
       * @default 0.15
       */
      leapWeight: number;
      /**
       * Format: float
       * @description Weight for leaps larger than P5
       * @default 0.1
       */
      largeLeapWeight: number;
    };
    /** @description Request to invalidate a cached behavior */
    InvalidateCacheRequest: {
      /** @description Unique identifier for the cached behavior to invalidate */
      behaviorId: string;
    };
    /** @description Request to join a matchmaking queue */
    JoinMatchmakingRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID for event delivery
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player joining
       */
      accountId: string;
      /** @description ID of the queue to join */
      queueId: string;
      /**
       * Format: uuid
       * @description Party ID if joining as part of a party
       */
      partyId?: string | null;
      /** @description Party member information (required if partyId provided) */
      partyMembers?: components['schemas']['PartyMemberInfo'][] | null;
      /** @description String properties for query matching */
      stringProperties?: {
        [key: string]: string;
      } | null;
      /** @description Numeric properties for query matching */
      numericProperties?: {
        [key: string]: number;
      } | null;
      /** @description Lucene-like query for opponent matching */
      query?: string | null;
      /**
       * Format: uuid
       * @description Tournament ID if joining tournament queue
       */
      tournamentId?: string | null;
    };
    /** @description Response after joining a matchmaking queue */
    JoinMatchmakingResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for this matchmaking ticket
       */
      ticketId: string;
      /** @description Queue that was joined */
      queueId: string;
      /** @description Estimated wait time based on current queue (null if unknown) */
      estimatedWaitSeconds: number | null;
      /** @description Approximate position in queue (null if not tracked) */
      position?: number | null;
    };
    /**
     * @description JSON Patch operation per RFC 6902.
     *     Uses JsonPatch.Net library (MIT licensed).
     */
    JsonPatchOperation: {
      /**
       * @description Operation type
       * @enum {string}
       */
      op: 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';
      /** @description JSON Pointer to target location */
      path: string;
      /** @description Source path (for move/copy operations) */
      from?: string | null;
      /** @description Value to use (for add/replace/test operations) */
      value?: unknown;
    };
    /** @description A key signature with tonic and mode */
    KeySignature: {
      /** @description Tonic pitch class */
      tonic: components['schemas']['PitchClass'];
      /**
       * @description Mode/scale type
       * @enum {string}
       */
      mode:
        | 'major'
        | 'minor'
        | 'dorian'
        | 'phrygian'
        | 'lydian'
        | 'mixolydian'
        | 'aeolian'
        | 'locrian';
    };
    /** @description A key signature change event */
    KeySignatureEvent: {
      /** @description Tick position */
      tick: number;
      /** @description Tonic pitch class */
      tonic: components['schemas']['PitchClass'];
      /** @description Mode/scale type */
      mode: components['schemas']['ModeType'];
    };
    /** @description Configuration for a specific layer within a map definition */
    LayerDefinition: {
      /** @description The layer kind */
      kind: components['schemas']['MapKind'];
      /**
       * @description How this layer's data should be stored
       * @default cached
       * @enum {string}
       */
      storageMode: 'durable' | 'cached' | 'ephemeral';
      /** @description TTL for cached/ephemeral data (0 = no TTL) */
      ttlSeconds?: number | null;
      /** @description Default non-authority handling for channels using this layer */
      defaultNonAuthorityHandling?: components['schemas']['NonAuthorityHandlingMode'];
      /**
       * Format: double
       * @description Spatial cell size for indexing (default from config if not set)
       */
      cellSize?: number | null;
    };
    /** @description Leaderboard definition details */
    LeaderboardDefinitionResponse: {
      /**
       * Format: uuid
       * @description ID of the owning game service
       */
      gameServiceId: string;
      /** @description Unique identifier for this leaderboard */
      leaderboardId: string;
      /** @description Human-readable name */
      displayName: string;
      /** @description Description of the leaderboard */
      description?: string | null;
      /** @description Allowed entity types */
      entityTypes?: components['schemas']['EntityType'][];
      /** @description Ordering used when ranking scores (descending for high scores, ascending for low) */
      sortOrder: components['schemas']['SortOrder'];
      /** @description Rule applied when new scores are submitted (replace/increment/max/min) */
      updateMode: components['schemas']['UpdateMode'];
      /** @description Whether the leaderboard is seasonal */
      isSeasonal: boolean;
      /** @description Whether the leaderboard is publicly visible */
      isPublic: boolean;
      /** @description Current season number (if seasonal) */
      currentSeason?: number | null;
      /**
       * Format: int64
       * @description Number of entries on the leaderboard
       */
      entryCount?: number;
      /**
       * Format: date-time
       * @description When the leaderboard was created
       */
      createdAt: string;
      /** @description Additional metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response containing leaderboard entries */
    LeaderboardEntriesResponse: {
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /** @description List of leaderboard entries */
      entries: components['schemas']['LeaderboardEntry'][];
      /**
       * Format: int64
       * @description Total entries on the leaderboard
       */
      totalEntries: number;
    };
    /** @description A single entry on a leaderboard */
    LeaderboardEntry: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type for this leaderboard entry */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: double
       * @description Entity's score
       */
      score: number;
      /**
       * Format: int64
       * @description Entity's rank (1-based)
       */
      rank: number;
      /** @description Cached display name for the entity */
      displayName?: string | null;
      /** @description Entry metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to leave a specific game session by ID */
    LeaveGameSessionByIdRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the client leaving.
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player leaving.
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the game session to leave.
       */
      gameSessionId: string;
    };
    /** @description Request to leave a game session */
    LeaveGameSessionRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the client leaving. Provided by shortcut system.
       */
      sessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player leaving. Provided by shortcut system.
       */
      accountId: string;
      /** @description Game type being left. Determines which lobby to leave. Provided by shortcut system. */
      gameType: string;
    };
    /** @description Request to leave a matchmaking queue */
    LeaveMatchmakingRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the ticket to cancel
       */
      ticketId: string;
    };
    /** @description Request to list achievement definitions */
    ListAchievementDefinitionsRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description Filter by platform */
      platform?: components['schemas']['Platform'];
      /** @description Filter by achievement classification */
      achievementType?: components['schemas']['AchievementType'];
      /** @description Filter by active status */
      isActive?: boolean | null;
      /**
       * @description Include hidden achievements in response
       * @default false
       */
      includeHidden: boolean;
    };
    /** @description Response containing achievement definitions */
    ListAchievementDefinitionsResponse: {
      /** @description List of achievement definitions */
      achievements: components['schemas']['AchievementDefinitionResponse'][];
    };
    /** @description Request to list available archives for a namespace */
    ListArchivesRequest: {
      /** @description Documentation namespace to list archives for */
      namespace: string;
      /**
       * @description Maximum number of archives to return
       * @default 20
       */
      limit: number;
      /**
       * @description Number of archives to skip
       * @default 0
       */
      offset: number;
    };
    /** @description Response containing a paginated list of archives */
    ListArchivesResponse: {
      /** @description List of archives for the namespace */
      archives: components['schemas']['ArchiveInfo'][];
      /** @description Total number of archives */
      total: number;
    };
    /** @description Request to list bundle version history */
    ListBundleVersionsRequest: {
      /** @description Bundle identifier to get history for */
      bundleId: string;
      /**
       * @description Maximum versions to return
       * @default 50
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description Bundle version history */
    ListBundleVersionsResponse: {
      /** @description Bundle identifier */
      bundleId: string;
      /** @description Current version number */
      currentVersion: number;
      /** @description Version history records (newest first) */
      versions: components['schemas']['BundleVersionRecord'][];
      /** @description Total number of versions */
      totalCount: number;
    };
    /** @description Request payload for listing characters with filtering and pagination */
    ListCharactersRequest: {
      /**
       * Format: uuid
       * @description Realm to list characters from (required for efficiency)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Filter by species
       */
      speciesId?: string | null;
      /** @description Filter by status */
      status?: components['schemas']['CharacterStatus'] | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list map definitions */
    ListDefinitionsRequest: {
      /** @description Filter by name (partial match) */
      nameFilter?: string | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Max results to return
       * @default 50
       */
      limit: number;
    };
    /** @description Response containing list of map definitions */
    ListDefinitionsResponse: {
      /** @description List of definitions */
      definitions?: components['schemas']['MapDefinition'][];
      /** @description Total count matching filter */
      total?: number;
      /** @description Current offset */
      offset?: number;
      /** @description Results limit used */
      limit?: number;
    };
    /** @description Request to list documents with optional filtering and pagination */
    ListDocumentsRequest: {
      /** @description Documentation namespace to list documents from */
      namespace: string;
      /** @description Filter to a specific category */
      category?: components['schemas']['DocumentCategory'];
      /** @description Filter by tags (null to skip tag filtering) */
      tags?: string[] | null;
      /**
       * @description Whether documents must match all tags or any tag
       * @default all
       * @enum {string}
       */
      tagsMatch: 'all' | 'any';
      /**
       * Format: date-time
       * @description Filter to documents created after this timestamp
       */
      createdAfter?: string;
      /**
       * Format: date-time
       * @description Filter to documents created before this timestamp
       */
      createdBefore?: string;
      /**
       * Format: date-time
       * @description Filter to documents updated after this timestamp
       */
      updatedAfter?: string;
      /**
       * Format: date-time
       * @description Filter to documents updated before this timestamp
       */
      updatedBefore?: string;
      /**
       * @description Return only document titles without summaries
       * @default false
       */
      titlesOnly: boolean;
      /**
       * @description Page number for pagination
       * @default 1
       */
      page: number;
      /**
       * @description Number of documents per page
       * @default 20
       */
      pageSize: number;
      /** @description Field to sort results by */
      sortBy?: components['schemas']['ListSortField'];
      /**
       * @description Sort order direction
       * @default desc
       * @enum {string}
       */
      sortOrder: 'asc' | 'desc';
    };
    /** @description Response containing a paginated list of documents */
    ListDocumentsResponse: {
      /** @description The namespace that was listed */
      namespace: string;
      /** @description List of documents in the namespace */
      documents: components['schemas']['DocumentSummary'][];
      /** @description Total number of documents matching filters */
      totalCount?: number;
      /** @description Current page number */
      page?: number;
      /** @description Number of documents per page */
      pageSize?: number;
      /** @description Total number of pages available */
      totalPages?: number;
    };
    /** @description Request to list encounter types with optional filtering */
    ListEncounterTypesRequest: {
      /**
       * @description Include soft-deleted types
       * @default false
       */
      includeInactive: boolean;
      /**
       * @description Only return built-in types
       * @default false
       */
      builtInOnly: boolean;
      /**
       * @description Only return custom types
       * @default false
       */
      customOnly: boolean;
    };
    /** @description Request to list all child locations of a specified parent location */
    ListLocationsByParentRequest: {
      /**
       * Format: uuid
       * @description ID of the parent location
       */
      parentLocationId: string;
      /** @description Optional filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list all locations within a specific realm with optional filtering */
    ListLocationsByRealmRequest: {
      /**
       * Format: uuid
       * @description Realm ID to query
       */
      realmId: string;
      /** @description Optional type filter */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list locations within a realm with optional type and deprecation filtering */
    ListLocationsRequest: {
      /**
       * Format: uuid
       * @description Realm ID to query (required - locations are partitioned by realm)
       */
      realmId: string;
      /** @description Filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list available matchmaking queues */
    ListQueuesRequest: {
      /** @description Filter by game ID (null for all games) */
      gameId?: string | null;
      /**
       * @description Include disabled queues in the list (admin only)
       * @default false
       */
      includeDisabled: boolean;
    };
    /** @description Response containing available matchmaking queues */
    ListQueuesResponse: {
      /** @description List of available queues */
      queues: components['schemas']['QueueSummary'][];
    };
    /** @description Request to list realms with optional filtering and pagination */
    ListRealmsRequest: {
      /** @description Filter by category (e.g., "MAIN", "SPECIAL", "TEST") */
      category?: string | null;
      /** @description Filter by active status */
      isActive?: boolean | null;
      /**
       * @description Whether to include deprecated realms in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of realms to return per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list relationship types with optional filtering by category, hierarchy, and deprecation status */
    ListRelationshipTypesRequest: {
      /** @description Filter by category (e.g., "FAMILY", "SOCIAL", "ECONOMIC") (null to include all) */
      category?: string | null;
      /**
       * @description Whether to include child types in the response
       * @default true
       */
      includeChildren: boolean;
      /**
       * @description Only return types with no parent (root types)
       * @default false
       */
      rootsOnly: boolean;
      /**
       * @description Whether to include deprecated types in the response
       * @default false
       */
      includeDeprecated: boolean;
    };
    /** @description Request to list all relationships for a specific entity with optional filters */
    ListRelationshipsByEntityRequest: {
      /**
       * Format: uuid
       * @description ID of the entity to get relationships for
       */
      entityId: string;
      /** @description Type of the entity to get relationships for */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Optional filter by relationship type
       */
      relationshipTypeId?: string | null;
      /** @description Optional filter by the other entity's type */
      otherEntityType?: components['schemas']['EntityType'];
      /**
       * @description Include relationships that have ended
       * @default false
       */
      includeEnded: boolean;
      /**
       * @description Page number for paginated results (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page (max 100)
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list all relationships of a specific relationship type */
    ListRelationshipsByTypeRequest: {
      /**
       * Format: uuid
       * @description Relationship type to filter by
       */
      relationshipTypeId: string;
      /** @description Optional filter by entity1 type */
      entity1Type?: components['schemas']['EntityType'];
      /** @description Optional filter by entity2 type */
      entity2Type?: components['schemas']['EntityType'];
      /**
       * @description Include relationships that have ended
       * @default false
       */
      includeEnded: boolean;
      /**
       * @description Page number for paginated results (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page (max 100)
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list all repository bindings with optional filtering */
    ListRepositoryBindingsRequest: {
      /** @description Filter by binding status */
      status?: components['schemas']['BindingStatus'];
      /**
       * @description Maximum number of bindings to return
       * @default 50
       */
      limit: number;
      /**
       * @description Number of bindings to skip
       * @default 0
       */
      offset: number;
    };
    /** @description Response containing a list of repository bindings */
    ListRepositoryBindingsResponse: {
      /** @description List of repository bindings */
      bindings: components['schemas']['RepositoryBindingInfo'][];
      /** @description Total number of bindings matching filter */
      total: number;
    };
    /** @description Request to list all top-level locations (without parents) in a realm */
    ListRootLocationsRequest: {
      /**
       * Format: uuid
       * @description Realm ID to get root locations for
       */
      realmId: string;
      /** @description Optional filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list scenes with optional filters */
    ListScenesRequest: {
      /** @description Filter by game ID */
      gameId?: string | null;
      /** @description Filter by single scene type */
      sceneType?: components['schemas']['SceneType'];
      /** @description Filter by multiple scene types (OR) */
      sceneTypes?: components['schemas']['SceneType'][] | null;
      /** @description Filter by tags (scenes must have ALL specified tags) */
      tags?: string[] | null;
      /** @description Filter by name containing this substring (case-insensitive) */
      nameContains?: string | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results to return
       * @default 50
       */
      limit: number;
    };
    /** @description Response containing scene list and pagination info */
    ListScenesResponse: {
      /** @description List of scene summaries (not full documents) */
      scenes: components['schemas']['SceneSummary'][];
      /** @description Total number of matching scenes */
      total: number;
      /** @description Current offset */
      offset?: number;
      /** @description Applied limit */
      limit?: number;
    };
    /** @description Request to list all registered schemas for a namespace */
    ListSchemasRequest: {
      /** @description Schema namespace to list */
      namespace: string;
    };
    /** @description List of registered schemas with latest version indicator */
    ListSchemasResponse: {
      /** @description Registered schemas */
      schemas: components['schemas']['SchemaResponse'][];
      /** @description Latest schema version */
      latestVersion?: string | null;
    };
    /** @description Request to list all game services */
    ListServicesRequest: {
      /**
       * @description If true, only return active services
       * @default false
       */
      activeOnly: boolean;
    };
    /** @description Response containing list of game services */
    ListServicesResponse: {
      /** @description List of game services matching the request criteria */
      services: components['schemas']['ServiceInfo'][];
      /** @description Total number of services matching the filter */
      totalCount: number;
    };
    /** @description Request to list all save slots belonging to a specific owner */
    ListSlotsRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns the save slots to list */
      ownerType: components['schemas']['OwnerType'];
      /** @description Optional filter by save category */
      category?: components['schemas']['SaveCategory'] | null;
      /**
       * @description Include version count in response
       * @default true
       */
      includeVersionCount: boolean;
    };
    /** @description Response containing a list of save slots for an owner */
    ListSlotsResponse: {
      /** @description List of slots */
      slots: components['schemas']['SlotResponse'][];
      /** @description Total number of slots for owner */
      totalCount?: number;
    };
    /**
     * @description Fields available for sorting document lists
     * @default updated_at
     * @enum {string}
     */
    ListSortField: 'created_at' | 'updated_at' | 'title';
    /** @description Request to list species available within a specific realm */
    ListSpeciesByRealmRequest: {
      /**
       * Format: uuid
       * @description ID of the realm to filter by
       */
      realmId: string;
      /** @description Filter by playable status */
      isPlayable?: boolean | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of items per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list species with optional filtering and pagination */
    ListSpeciesRequest: {
      /** @description Filter by category (e.g., "HUMANOID", "BEAST", "MAGICAL") */
      category?: string | null;
      /** @description Filter by playable status */
      isPlayable?: boolean | null;
      /**
       * @description Whether to include deprecated species in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of items per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list available styles */
    ListStylesRequest: {
      /** @description Filter by category (e.g., "folk", "classical", "jazz") */
      category?: string | null;
      /**
       * @description Maximum number of styles to return
       * @default 50
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description Response containing a list of styles */
    ListStylesResponse: {
      /** @description Style summaries */
      styles: components['schemas']['StyleSummary'][];
      /** @description Total number of styles matching filter */
      total: number;
    };
    /** @description Request to list unlocked achievements */
    ListUnlockedAchievementsRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type whose unlocked achievements are listed */
      entityType: components['schemas']['EntityType'];
      /** @description Filter by platform */
      platform?: components['schemas']['Platform'];
    };
    /** @description Response containing unlocked achievements */
    ListUnlockedAchievementsResponse: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type for the returned unlocked achievements */
      entityType: components['schemas']['EntityType'];
      /** @description List of unlocked achievements */
      achievements: components['schemas']['UnlockedAchievement'][];
      /** @description Total points earned */
      totalPoints: number;
    };
    /** @description Request to list all versions of an asset with pagination */
    ListVersionsRequest: {
      /** @description Asset identifier to list versions for */
      assetId: string;
      /**
       * @description Maximum number of versions to return
       * @default 50
       */
      limit: number;
      /**
       * @description Number of versions to skip for pagination
       * @default 0
       */
      offset: number;
    };
    /** @description Paginated list of save versions within a slot */
    ListVersionsResponse: {
      /** @description List of versions */
      versions: components['schemas']['VersionResponse'][];
      /** @description Total version count in slot */
      totalCount: number;
    };
    /** @description Request to load save data from a specific slot and version */
    LoadRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Specific version to load (defaults to latest) */
      versionNumber?: number | null;
      /** @description Load by checkpoint name instead of version number */
      checkpointName?: string | null;
      /**
       * @description Include version metadata in response
       * @default true
       */
      includeMetadata: boolean;
    };
    /** @description Response containing loaded save data with integrity verification */
    LoadResponse: {
      /**
       * Format: uuid
       * @description Slot identifier
       */
      slotId: string;
      /** @description Version number loaded */
      versionNumber: number;
      /**
       * Format: byte
       * @description Base64-encoded save data (decompressed)
       */
      data: string;
      /** @description SHA-256 hash for integrity verification */
      contentHash: string;
      /** @description Schema version of this save */
      schemaVersion?: string | null;
      /** @description Human-readable name */
      displayName?: string | null;
      /** @description Whether this version is pinned */
      pinned?: boolean;
      /** @description Checkpoint name if pinned */
      checkpointName?: string | null;
      /**
       * Format: date-time
       * @description Save timestamp
       */
      createdAt?: string;
      /** @description Custom metadata */
      metadata?: {
        [key: string]: string;
      };
    };
    /** @description Character location information including current position, region, and 3D coordinates */
    Location: {
      /** @description Current location name or identifier */
      current?: string | null;
      /** @description Region or zone the character is in */
      region?: string | null;
      /** @description 3D spatial coordinates of the character's position in the game world */
      coordinates?: components['schemas']['Coordinates'];
    };
    /** @description Request to check if a location exists and is active */
    LocationExistsRequest: {
      /**
       * Format: uuid
       * @description ID of the location to validate
       */
      locationId: string;
    };
    /** @description Response indicating whether a location exists and its active status */
    LocationExistsResponse: {
      /** @description Whether the location exists */
      exists: boolean;
      /** @description Whether the location is active (false if deprecated or not found) */
      isActive: boolean;
      /**
       * Format: uuid
       * @description The location ID if found
       */
      locationId?: string | null;
      /**
       * Format: uuid
       * @description The realm ID if location found
       */
      realmId?: string | null;
    };
    /** @description Paginated list of locations with metadata for navigation */
    LocationListResponse: {
      /** @description List of locations matching the query */
      locations: components['schemas']['LocationResponse'][];
      /** @description Total number of locations matching the query (across all pages) */
      totalCount: number;
      /** @description Current page number (1-indexed) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more pages after the current page */
      hasNextPage?: boolean;
      /** @description Whether there are pages before the current page */
      hasPreviousPage?: boolean;
    };
    /** @description Complete location data returned from API operations */
    LocationResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the location
       */
      locationId: string;
      /**
       * Format: uuid
       * @description Realm this location belongs to
       */
      realmId: string;
      /** @description Unique code for the location within its realm */
      code: string;
      /** @description Display name of the location */
      name: string;
      /** @description Optional description of the location */
      description?: string | null;
      /** @description Type classification of the location */
      locationType: components['schemas']['LocationType'];
      /**
       * Format: uuid
       * @description Parent location ID (null for root locations)
       */
      parentLocationId?: string | null;
      /** @description Depth in hierarchy (0 for root locations) */
      depth: number;
      /** @description Whether this location is deprecated and cannot be used */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this location was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation */
      deprecationReason?: string | null;
      /** @description Additional metadata for the location (JSON) */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Timestamp when the location was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the location was last updated
       */
      updatedAt: string;
    };
    /**
     * @description Type classification for locations
     * @enum {string}
     */
    LocationType:
      | 'CONTINENT'
      | 'REGION'
      | 'CITY'
      | 'DISTRICT'
      | 'BUILDING'
      | 'ROOM'
      | 'LANDMARK'
      | 'WILDERNESS'
      | 'DUNGEON'
      | 'OTHER';
    /** @description Request to authenticate a user with email and password credentials */
    LoginRequest: {
      /**
       * Format: email
       * @description Email address for authentication
       */
      email: string;
      /**
       * Format: password
       * @description User password for authentication
       */
      password: string;
      /**
       * @description Whether to extend the session duration for persistent login
       * @default false
       */
      rememberMe: boolean;
      /** @description Information about the client device (optional) */
      deviceInfo?: components['schemas']['DeviceInfo'];
    };
    /** @description Site logo configuration including image URL and accessibility text */
    Logo: {
      /**
       * Format: uri
       * @description URL of the site logo image
       */
      url?: string;
      /** @description Alt text for the logo image */
      alt?: string;
    };
    /** @description Request to logout and invalidate authentication tokens */
    LogoutRequest: {
      /**
       * @description Logout from all sessions/devices
       * @default false
       */
      allSessions: boolean;
    };
    /** @description A map definition template that describes the structure of a region */
    MapDefinition: {
      /**
       * Format: uuid
       * @description Unique identifier for this definition
       */
      definitionId: string;
      /** @description Human-readable name */
      name: string;
      /** @description Description of the map template */
      description?: string | null;
      /** @description Layer configurations for this map */
      layers?: components['schemas']['LayerDefinition'][] | null;
      /** @description Default bounds for regions using this definition */
      defaultBounds?: components['schemas']['Bounds'];
      /** @description Additional metadata (schema-less) */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When the definition was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the definition was last updated
       */
      updatedAt?: string | null;
    };
    /**
     * @description The category of spatial data this map contains.
     *     Different kinds have different update frequencies, storage models, and TTLs.
     * @enum {string}
     */
    MapKind:
      | 'terrain'
      | 'static_geometry'
      | 'navigation'
      | 'resources'
      | 'spawn_points'
      | 'points_of_interest'
      | 'dynamic_objects'
      | 'hazards'
      | 'weather_effects'
      | 'ownership'
      | 'combat_effects'
      | 'visual_effects';
    /** @description A stored map object with full metadata */
    MapObject: {
      /**
       * Format: uuid
       * @description Unique identifier for this object
       */
      objectId: string;
      /**
       * Format: uuid
       * @description Region this object belongs to
       */
      regionId: string;
      /** @description Map kind this object is stored under */
      kind: components['schemas']['MapKind'];
      /** @description Publisher-defined type */
      objectType: string;
      /** @description Position for point objects */
      position?: components['schemas']['Position3D'];
      /** @description Bounding box for area objects */
      bounds?: components['schemas']['Bounds'];
      /** @description Schema-less object data (publisher-defined) */
      data?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: int64
       * @description Monotonic version for ordering
       */
      version?: number;
      /**
       * Format: date-time
       * @description When the object was first created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the object was last updated
       */
      updatedAt: string;
    };
    /**
     * @description Types of marker nodes for spawn points, waypoints, and other positional markers.
     * @enum {string}
     */
    MarkerType:
      | 'generic'
      | 'spawn_point'
      | 'npc_spawn'
      | 'waypoint'
      | 'camera_point'
      | 'light_point'
      | 'audio_point'
      | 'trigger_point';
    /** @description Request to check if a relationship type matches or descends from an ancestor type in the hierarchy */
    MatchesHierarchyRequest: {
      /**
       * Format: uuid
       * @description The relationship type to check
       */
      typeId: string;
      /**
       * Format: uuid
       * @description The potential ancestor type
       */
      ancestorTypeId: string;
    };
    /** @description Response indicating whether a type matches an ancestor in the hierarchy and the depth between them */
    MatchesHierarchyResponse: {
      /** @description True if typeId equals or descends from ancestorTypeId */
      matches: boolean;
      /** @description Number of levels between the types (0 if same, -1 if no match) */
      depth?: number;
    };
    /** @description Matchmaking operational statistics */
    MatchmakingStatsResponse: {
      /**
       * Format: date-time
       * @description When these stats were collected
       */
      timestamp: string;
      /** @description Statistics per queue */
      queueStats: components['schemas']['QueueStats'][];
    };
    /** @description Current matchmaking status for a ticket */
    MatchmakingStatusResponse: {
      /**
       * Format: uuid
       * @description Ticket identifier
       */
      ticketId: string;
      /** @description Queue the ticket is in */
      queueId: string;
      /** @description Current ticket status */
      status: components['schemas']['TicketStatus'];
      /** @description Number of processing intervals elapsed */
      intervalsElapsed: number;
      /** @description Current skill matching range (null if skill not used) */
      currentSkillRange?: number | null;
      /** @description Updated estimated wait time */
      estimatedWaitSeconds?: number | null;
      /**
       * Format: date-time
       * @description When the ticket was created
       */
      createdAt: string;
      /**
       * Format: uuid
       * @description Match ID if a match has been found
       */
      matchId?: string | null;
    };
    /** @description Analysis of a melody */
    MelodyAnalysis: {
      /** @description Pitch range used */
      range?: components['schemas']['PitchRange'];
      /** @description Distribution of interval sizes */
      intervalDistribution?: {
        [key: string]: number;
      } | null;
      /** @description Detected contour shape */
      contour?: string | null;
      /** @description Total number of notes */
      noteCount?: number;
      /**
       * Format: float
       * @description Average note duration in ticks
       */
      averageNoteDuration?: number | null;
    };
    /** @description A single MIDI event */
    MidiEvent: {
      /** @description Absolute tick position */
      tick: number;
      /** @description Event type */
      type: components['schemas']['MidiEventType'];
      /** @description MIDI note number (for note events) */
      note?: number | null;
      /** @description Note velocity (for note events) */
      velocity?: number | null;
      /** @description Note duration in ticks (for noteOn with implicit noteOff) */
      duration?: number | null;
      /** @description Program number (for programChange) */
      program?: number | null;
      /** @description Controller number (for controlChange) */
      controller?: number | null;
      /** @description Controller value (for controlChange) */
      value?: number | null;
    };
    /**
     * @description MIDI event type
     * @enum {string}
     */
    MidiEventType: 'NoteOn' | 'NoteOff' | 'ProgramChange' | 'ControlChange';
    /** @description MIDI file header information */
    MidiHeader: {
      /**
       * @description MIDI format type (0, 1, or 2)
       * @default 1
       */
      format: number;
      /** @description Composition name */
      name?: string | null;
      /** @description Tempo changes */
      tempos?: components['schemas']['TempoEvent'][] | null;
      /** @description Time signature changes */
      timeSignatures?: components['schemas']['TimeSignatureEvent'][] | null;
      /** @description Key signature changes */
      keySignatures?: components['schemas']['KeySignatureEvent'][] | null;
    };
    /** @description MIDI-JSON format representation of a musical piece */
    MidiJson: {
      /** @description MIDI header information */
      header?: components['schemas']['MidiHeader'];
      /**
       * @description Ticks per beat (PPQN)
       * @default 480
       */
      ticksPerBeat: number;
      /** @description MIDI tracks */
      tracks: components['schemas']['MidiTrack'][];
    };
    /** @description A single MIDI track containing events */
    MidiTrack: {
      /** @description Track name */
      name?: string | null;
      /**
       * @description MIDI channel
       * @default 0
       */
      channel: number;
      /** @description GM instrument number */
      instrument?: number | null;
      /** @description Track events */
      events: components['schemas']['MidiEvent'][];
    };
    /** @description Request to migrate a save to a newer schema version */
    MigrateSaveRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Specific version to migrate (defaults to latest) */
      versionNumber?: number;
      /** @description Target schema version to migrate to */
      targetSchemaVersion: string;
      /**
       * @description Validate migration without saving
       * @default false
       */
      dryRun: boolean;
    };
    /** @description Result of a schema migration operation with version path details */
    MigrateSaveResponse: {
      /** @description Whether migration succeeded */
      success: boolean;
      /** @description Original schema version */
      fromSchemaVersion: string;
      /** @description Target schema version */
      toSchemaVersion: string;
      /** @description New version number (null if dry run) */
      newVersionNumber?: number | null;
      /** @description Migration path applied (list of versions) */
      migrationPath?: string[];
      /** @description Non-fatal migration warnings */
      warnings?: string[];
    };
    /** @description Probability distribution over musical modes */
    ModeDistribution: {
      /**
       * Format: float
       * @description Probability of major mode
       * @default 0
       */
      major: number;
      /**
       * Format: float
       * @description Probability of natural minor
       * @default 0
       */
      minor: number;
      /**
       * Format: float
       * @description Probability of dorian mode
       * @default 0
       */
      dorian: number;
      /**
       * Format: float
       * @description Probability of phrygian mode
       * @default 0
       */
      phrygian: number;
      /**
       * Format: float
       * @description Probability of lydian mode
       * @default 0
       */
      lydian: number;
      /**
       * Format: float
       * @description Probability of mixolydian mode
       * @default 0
       */
      mixolydian: number;
      /**
       * Format: float
       * @description Probability of aeolian mode
       * @default 0
       */
      aeolian: number;
      /**
       * Format: float
       * @description Probability of locrian mode
       * @default 0
       */
      locrian: number;
    };
    /**
     * @description Musical mode/scale type
     * @enum {string}
     */
    ModeType:
      | 'Major'
      | 'Minor'
      | 'Dorian'
      | 'Phrygian'
      | 'Lydian'
      | 'Mixolydian'
      | 'Aeolian'
      | 'Locrian'
      | 'HarmonicMinor'
      | 'MelodicMinor'
      | 'MajorPentatonic'
      | 'MinorPentatonic'
      | 'Blues'
      | 'WholeTone'
      | 'Chromatic';
    /** @description Configuration for multipart uploads of large files */
    MultipartConfig: {
      /** @description Whether multipart upload is required for this file size */
      required?: boolean;
      /** @description Size of each part in bytes */
      partSize?: number;
      /** @description Maximum number of parts */
      maxParts?: number;
      /** @description Pre-signed URLs for each part of the multipart upload */
      uploadUrls?: components['schemas']['PartUploadInfo'][] | null;
    };
    /** @description Options for narrative-driven composition using the Storyteller engine */
    NarrativeOptions: {
      /**
       * @description Specific narrative template ID (e.g., 'journey_and_return', 'tension_and_release', 'simple_arc').
       *     If not specified, template is inferred from mood or defaults to 'simple_arc'.
       */
      templateId?: string | null;
      /** @description Starting emotional state for the composition */
      initialEmotion?: components['schemas']['EmotionalStateInput'];
      /** @description Target emotional state for the ending */
      targetEmotion?: components['schemas']['EmotionalStateInput'];
      /**
       * @description Preferred tension curve shape throughout the composition
       * @enum {string|null}
       */
      tensionProfile?:
        | 'gradual_build'
        | 'early_climax'
        | 'late_climax'
        | 'sustained'
        | 'wave'
        | null;
    };
    /** @description A navigation menu entry with optional nested children for dropdowns */
    NavigationItem: {
      /** @description Display text for the navigation link */
      label: string;
      /** @description Target URL or path for the navigation link */
      url: string;
      /** @description Sort order for the navigation item */
      order: number;
      /**
       * @description Link target attribute for opening behavior
       * @default _self
       * @enum {string}
       */
      target: '_self' | '_blank';
      /** @description Nested child navigation items for dropdowns */
      children?: components['schemas']['NavigationItem'][];
    };
    /** @description Information about a nearby object perceived by the character */
    NearbyObject: {
      /**
       * Format: uuid
       * @description Unique identifier of the object
       */
      objectId?: string;
      /** @description Type of object (boulder_cluster, tree, building, etc.) */
      objectType?: string;
      /**
       * Format: float
       * @description Distance from character in game units
       */
      distance?: number;
      /** @description Relative direction (north, south, east, west, above, below, etc.) */
      direction?: string;
      /** @description Optional absolute position */
      position?: components['schemas']['Position3D'] | null;
    } & {
      [key: string]: unknown;
    };
    /** @description A single news article or announcement entry */
    NewsItem: {
      /**
       * Format: uuid
       * @description Unique identifier for the news item
       */
      id: string;
      /** @description Headline of the news item */
      title: string;
      /** @description Brief summary or excerpt of the news content */
      summary: string;
      /** @description Full content body of the news item */
      content?: string | null;
      /** @description Name of the news item author */
      author?: string;
      /**
       * Format: date-time
       * @description Date and time when the news was published
       */
      publishedAt: string;
      /** @description Category tags associated with the news item */
      tags?: string[];
      /**
       * Format: uri
       * @description URL of the featured image for the news item
       */
      imageUrl?: string | null;
    };
    /** @description Paginated list of news items with total count */
    NewsResponse: {
      /** @description List of news items for the current page */
      items: components['schemas']['NewsItem'][];
      /** @description Total number of news items available */
      total: number;
      /** @description Whether more news items are available beyond this page */
      hasMore?: boolean;
    };
    /**
     * @description Structural node type. Indicates what kind of data the node contains,
     *     not how it will be used at runtime. Consumers interpret nodes according
     *     to their own needs via tags and annotations.
     * @enum {string}
     */
    NodeType: 'group' | 'mesh' | 'marker' | 'volume' | 'emitter' | 'reference' | 'custom';
    /**
     * @description How to handle publish attempts from non-authority sources
     * @default reject_and_alert
     * @enum {string}
     */
    NonAuthorityHandlingMode: 'reject_and_alert' | 'accept_and_alert' | 'reject_silent';
    /** @description A musical note event with timing and pitch */
    NoteEvent: {
      /** @description Note pitch */
      pitch: components['schemas']['Pitch'];
      /** @description Start position in ticks */
      startTick: number;
      /** @description Duration in ticks */
      durationTicks: number;
      /**
       * @description Note velocity
       * @default 80
       */
      velocity: number;
    };
    /** @description Request containing OAuth provider callback data to complete authentication */
    OAuthCallbackRequest: {
      /** @description Authorization code returned by the OAuth provider */
      code: string;
      /** @description State parameter for CSRF protection, must match the value sent in the init request */
      state?: string | null;
      /** @description Information about the client device (optional) */
      deviceInfo?: components['schemas']['DeviceInfo'];
    };
    /**
     * @description Type of entity that owns this save slot
     * @enum {string}
     */
    OwnerType: 'ACCOUNT' | 'CHARACTER' | 'SESSION' | 'REALM';
    /** @description Full content and metadata for a CMS-managed page */
    PageContent: {
      /** @description URL-friendly identifier for the page */
      slug: string;
      /** @description Display title of the page */
      title: string;
      /** @description HTML, Markdown, or custom template content */
      content: string;
      /**
       * @description Format of the page content
       * @enum {string}
       */
      contentType: 'html' | 'markdown' | 'blazor';
      /** @description Template name for custom layouts */
      template?: string | null;
      /** @description Whether the page is publicly visible */
      published: boolean;
      /**
       * Format: date-time
       * @description Date and time when the page was published
       */
      publishedAt?: string | null;
      /**
       * Format: date-time
       * @description Date and time of the last modification
       */
      lastModified?: string;
      /** @description Name or identifier of the page author */
      author?: string | null;
      /** @description Custom metadata for the page */
      metadata?: {
        [key: string]: unknown;
      };
      /** @description Search engine optimization settings for the page */
      seo?: components['schemas']['SEOMetadata'];
    };
    /** @description Summary metadata for a CMS page without full content */
    PageMetadata: {
      /** @description URL-friendly identifier for the page */
      slug: string;
      /** @description Display title of the page */
      title: string;
      /** @description Whether the page is publicly visible */
      published: boolean;
      /**
       * Format: date-time
       * @description Date and time when the page was published
       */
      publishedAt?: string | null;
      /**
       * Format: date-time
       * @description Date and time of the last modification
       */
      lastModified?: string;
      /** @description Name or identifier of the page author */
      author?: string | null;
    };
    /** @description Upload information for a single part in a multipart upload */
    PartUploadInfo: {
      /** @description Part number (1-based) */
      partNumber: number;
      /**
       * Format: uri
       * @description Pre-signed URL for uploading this part
       */
      uploadUrl: string;
      /**
       * Format: int64
       * @description Minimum size for this part
       */
      minSize?: number;
      /**
       * Format: int64
       * @description Maximum size for this part
       */
      maxSize?: number;
    };
    /** @description Paginated list of participation records */
    ParticipationListResponse: {
      /** @description List of participation records */
      participations: components['schemas']['HistoricalParticipation'][];
      /** @description Total number of matching records */
      totalCount: number;
      /** @description Current page number (1-based) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more results after this page */
      hasNextPage?: boolean;
      /** @description Whether there are results before this page */
      hasPreviousPage?: boolean;
    };
    /**
     * @description How the character participated in the historical event
     * @enum {string}
     */
    ParticipationRole:
      | 'LEADER'
      | 'COMBATANT'
      | 'VICTIM'
      | 'WITNESS'
      | 'BENEFICIARY'
      | 'CONSPIRATOR'
      | 'HERO'
      | 'SURVIVOR';
    /** @description Information about a party member for matchmaking */
    PartyMemberInfo: {
      /**
       * Format: uuid
       * @description Account ID of the party member
       */
      accountId: string;
      /**
       * Format: uuid
       * @description WebSocket session ID for event delivery
       */
      webSocketSessionId: string;
      /** @description Pre-fetched skill rating (optional, will be looked up if not provided) */
      skillRating?: number | null;
    };
    /**
     * @description Method for aggregating party member skills
     * @enum {string}
     */
    PartySkillAggregation: 'highest' | 'average' | 'weighted';
    /** @description Request to confirm a password reset using the emailed token and new password */
    PasswordResetConfirmRequest: {
      /** @description Password reset token received via email */
      token: string;
      /**
       * Format: password
       * @description New password to set for the account
       */
      newPassword: string;
    };
    /** @description Request to initiate a password reset by sending a reset link to the email */
    PasswordResetRequest: {
      /**
       * Format: email
       * @description Email address associated with the account to reset
       */
      email: string;
    };
    /** @description Reference to a past incarnation */
    PastLifeReference: {
      /**
       * Format: uuid
       * @description ID of the previous incarnation
       */
      characterId: string;
      /** @description Display name of the past life */
      name?: string | null;
      /**
       * Format: date-time
       * @description When the past life ended
       */
      deathDate?: string | null;
    };
    /**
     * @description Data representing a perception event for an actor.
     *
     *     Spatial context can be provided in two ways (hybrid approach):
     *     1. Typed: Use the optional spatialContext field for structured spatial data
     *     2. Schema-less: Use perceptionType="spatial" with data containing spatial info
     *
     *     The typed approach is recommended when game server has structured spatial data.
     *     The schema-less approach allows flexibility for game-specific spatial formats.
     */
    PerceptionData: {
      /**
       * @description Perception type. Common values: visual, auditory, tactile, olfactory,
       *     proprioceptive, spatial. Use "spatial" for schema-less spatial data in 'data' field.
       */
      perceptionType: string;
      /** @description ID of the entity causing this perception */
      sourceId: string;
      /** @description Type of source (character, npc, object, environment) */
      sourceType?: string | null;
      /**
       * @description Perception-specific data. For perceptionType="spatial", this can contain
       *     game-specific spatial context in any format the game server defines.
       */
      data?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: float
       * @description How urgent this perception is (0-1)
       * @default 0.5
       */
      urgency: number;
      /**
       * @description Optional typed spatial context from game server's local spatial state.
       *     Provides structured information about terrain, nearby objects, hazards, etc.
       *     Alternative to using perceptionType="spatial" with schema-less data.
       */
      spatialContext?: components['schemas']['SpatialContext'] | null;
    };
    /** @description Complete personality profile for behavior system consumption */
    PersonalityResponse: {
      /**
       * Format: uuid
       * @description Character this personality belongs to
       */
      characterId: string;
      /** @description All trait axis values for this character */
      traits: components['schemas']['TraitValue'][];
      /** @description Personality version number (increments on each evolution) */
      version: number;
      /**
       * @description Optional archetype code for behavior optimization (e.g., "guardian",
       *     "merchant", "scholar", "trickster"). Allows behavior system to use
       *     pre-compiled behavior variants for common personality patterns.
       */
      archetypeHint?: string | null;
      /**
       * Format: date-time
       * @description When this personality was first created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When this personality was last modified
       */
      updatedAt?: string | null;
    };
    /** @description Snapshot of personality traits for enriched response */
    PersonalitySnapshot: {
      /** @description Trait values keyed by trait name (OPENNESS, AGREEABLENESS, etc.) */
      traits: {
        [key: string]: number;
      };
      /** @description Personality version number (increments on evolution) */
      version: number;
    };
    /** @description Response containing a perspective */
    PerspectiveResponse: {
      /** @description The character's perspective on the encounter */
      perspective: components['schemas']['EncounterPerspectiveModel'];
    };
    /** @description Request to pin a save version as a checkpoint to prevent cleanup */
    PinVersionRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Version to pin */
      versionNumber: number;
      /** @description Optional checkpoint name for easy retrieval */
      checkpointName?: string;
    };
    /** @description A specific pitch with pitch class and octave */
    Pitch: {
      /** @description Pitch class (note name) */
      pitchClass: components['schemas']['PitchClass'];
      /** @description Octave number (middle C = C4) */
      octave: number;
      /** @description MIDI note number (computed if not provided) */
      midiNumber?: number;
    };
    /**
     * @description A pitch class (note name without octave)
     * @enum {string}
     */
    PitchClass: 'C' | 'Cs' | 'D' | 'Ds' | 'E' | 'F' | 'Fs' | 'G' | 'Gs' | 'A' | 'As' | 'B';
    /** @description A pitch range from low to high */
    PitchRange: {
      /** @description Lowest pitch (inclusive) */
      low: components['schemas']['Pitch'];
      /** @description Highest pitch (inclusive) */
      high: components['schemas']['Pitch'];
    };
    /** @description Single action within a GOAP plan with position and cost information */
    PlannedActionResponse: {
      /** @description ID of the action (flow name) */
      actionId: string;
      /** @description Position in the plan sequence */
      index: number;
      /**
       * Format: float
       * @description Cost of this action
       */
      cost: number;
    };
    /**
     * @description External platform for achievement sync
     * @enum {string}
     */
    Platform: 'steam' | 'xbox' | 'playstation' | 'internal';
    /** @description 3D position in world coordinates */
    Position3D: {
      /**
       * Format: float
       * @description X coordinate
       */
      x: number;
      /**
       * Format: float
       * @description Y coordinate (typically vertical)
       */
      y: number;
      /**
       * Format: float
       * @description Z coordinate
       */
      z: number;
    };
    /**
     * @description Preferred engagement distance. Influences positioning and
     *     ability selection in combat.
     * @enum {string}
     */
    PreferredRange: 'MELEE' | 'CLOSE' | 'MEDIUM' | 'RANGED';
    /**
     * @description Asset processing pipeline status
     * @enum {string}
     */
    ProcessingStatus: 'pending' | 'processing' | 'complete' | 'failed';
    /** @description Analysis of a chord progression */
    ProgressionAnalysis: {
      /** @description Roman numeral analysis */
      romanNumerals?: string[] | null;
      /** @description Detected cadences */
      cadences?: components['schemas']['CadenceInfo'][] | null;
      /** @description Functional analysis per chord */
      functionalAnalysis?: ('tonic' | 'subdominant' | 'dominant' | 'predominant')[] | null;
    };
    /** @description Request to promote an older save version to be the latest */
    PromoteVersionRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Name of the slot containing the version to promote */
      slotName: string;
      /** @description Old version to promote to latest */
      versionNumber: number;
      /** @description Display name for promoted version */
      displayName?: string | null;
    };
    /**
     * @description OAuth provider type
     * @enum {string}
     */
    Provider: 'google' | 'discord' | 'twitch';
    /** @description Information about an available authentication provider */
    ProviderInfo: {
      /**
       * @description Internal identifier for the provider (matches Provider enum for OAuth)
       * @example discord
       */
      name: string;
      /**
       * @description Human-readable name for the provider
       * @example Discord
       */
      displayName: string;
      /**
       * @description Authentication mechanism (oauth = browser redirect, ticket = game client token)
       * @enum {string}
       */
      authType: 'oauth' | 'ticket';
      /**
       * Format: uri
       * @description URL to initiate OAuth authentication (null for ticket-based auth like Steam)
       * @example https://discord.com/oauth2/authorize
       */
      authUrl?: string | null;
    };
    /** @description List of available authentication providers */
    ProvidersResponse: {
      /** @description Available authentication providers */
      providers: components['schemas']['ProviderInfo'][];
    };
    /** @description Rotation represented as a quaternion */
    Quaternion: {
      /**
       * Format: double
       * @description X component
       */
      x: number;
      /**
       * Format: double
       * @description Y component
       */
      y: number;
      /**
       * Format: double
       * @description Z component
       */
      z: number;
      /**
       * Format: double
       * @description W component (scalar)
       */
      w: number;
    };
    /** @description Request to query encounters between two characters */
    QueryBetweenRequest: {
      /**
       * Format: uuid
       * @description First character
       */
      characterIdA: string;
      /**
       * Format: uuid
       * @description Second character
       */
      characterIdB: string;
      /** @description Filter by encounter type */
      encounterTypeCode?: string | null;
      /**
       * Format: float
       * @description Filter by minimum memory strength (for either character)
       */
      minimumMemoryStrength?: number | null;
      /**
       * @description Page number (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Query map data within bounds */
    QueryBoundsRequest: {
      /**
       * Format: uuid
       * @description Region to query
       */
      regionId: string;
      /** @description Bounding box to query */
      bounds: components['schemas']['Bounds'];
      /** @description Kinds to query (default all) */
      kinds?: components['schemas']['MapKind'][] | null;
      /**
       * @description Maximum objects to return
       * @default 500
       */
      maxObjects: number;
    };
    /** @description Bounds query results */
    QueryBoundsResponse: {
      /** @description Objects within bounds */
      objects?: components['schemas']['MapObject'][];
      /** @description Queried bounds */
      bounds?: components['schemas']['Bounds'];
      /** @description Whether results were truncated */
      truncated?: boolean;
    };
    /** @description Request to find bundles containing a specific asset */
    QueryBundlesByAssetRequest: {
      /** @description Platform asset ID to search for */
      assetId: string;
      /** @description Game realm to search within */
      realm: components['schemas']['Realm'];
      /** @description Filter by bundle type (optional, null for all types) */
      bundleType?: components['schemas']['BundleType'] | null;
      /**
       * @description Maximum results to return
       * @default 50
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description Bundles containing the requested asset */
    QueryBundlesByAssetResponse: {
      /** @description The queried asset ID */
      assetId: string;
      /** @description Bundles containing this asset */
      bundles: components['schemas']['BundleSummary'][];
      /** @description Total matching bundles */
      total: number;
      /** @description Page size */
      limit: number;
      /** @description Page offset */
      offset: number;
    };
    /** @description Advanced bundle query with filters */
    QueryBundlesRequest: {
      /** @description Filter by exact tag key-value matches */
      tags?: {
        [key: string]: string;
      } | null;
      /** @description Filter bundles that have these tag keys (any value) */
      tagExists?: string[] | null;
      /** @description Filter bundles that do NOT have these tag keys */
      tagNotExists?: string[] | null;
      /** @description Filter by lifecycle status (null for active only by default) */
      status?: components['schemas']['BundleLifecycle'] | null;
      /**
       * Format: date-time
       * @description Filter bundles created after this time
       */
      createdAfter?: string | null;
      /**
       * Format: date-time
       * @description Filter bundles created before this time
       */
      createdBefore?: string | null;
      /** @description Filter bundles with name containing this string (case-insensitive) */
      nameContains?: string | null;
      /** @description Filter by bundle owner account ID */
      owner?: string | null;
      /** @description Filter by realm */
      realm?: components['schemas']['Realm'] | null;
      /** @description Filter by bundle type (source or metabundle) */
      bundleType?: components['schemas']['BundleType'] | null;
      /**
       * @description Field to sort by (default created_at)
       * @enum {string|null}
       */
      sortField?: 'created_at' | 'updated_at' | 'name' | 'size' | null;
      /**
       * @description Sort order (default desc)
       * @enum {string|null}
       */
      sortOrder?: 'asc' | 'desc' | null;
      /**
       * @description Maximum results to return (max 1000)
       * @default 100
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Include soft-deleted bundles in results
       * @default false
       */
      includeDeleted: boolean;
    };
    /** @description Bundle query results */
    QueryBundlesResponse: {
      /** @description Matching bundles */
      bundles: components['schemas']['BundleInfo'][];
      /** @description Total number of matching bundles (for pagination) */
      totalCount: number;
      /** @description Page size used */
      limit: number;
      /** @description Page offset used */
      offset: number;
    };
    /** @description Request to query encounters by character */
    QueryByCharacterRequest: {
      /**
       * Format: uuid
       * @description Character to query encounters for
       */
      characterId: string;
      /** @description Filter by encounter type */
      encounterTypeCode?: string | null;
      /** @description Filter by outcome */
      outcome?: components['schemas']['EncounterOutcome'];
      /**
       * Format: float
       * @description Filter by minimum memory strength
       */
      minimumMemoryStrength?: number | null;
      /**
       * Format: date-time
       * @description Filter encounters after this time
       */
      fromTimestamp?: string | null;
      /**
       * Format: date-time
       * @description Filter encounters before this time
       */
      toTimestamp?: string | null;
      /**
       * @description Page number (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to query recent encounters at a location */
    QueryByLocationRequest: {
      /**
       * Format: uuid
       * @description Location to query
       */
      locationId: string;
      /** @description Filter by encounter type */
      encounterTypeCode?: string | null;
      /**
       * Format: date-time
       * @description Filter encounters after this time
       */
      fromTimestamp?: string | null;
      /**
       * @description Page number (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to search documentation using natural language queries */
    QueryDocumentationRequest: {
      /** @description Documentation namespace to search within */
      namespace: string;
      /** @description Natural language query to search for */
      query: string;
      /**
       * Format: uuid
       * @description Optional session ID for conversational context
       */
      sessionId?: string;
      /** @description Filter results to a specific category */
      category?: components['schemas']['DocumentCategory'];
      /**
       * @description Maximum number of results to return
       * @default 5
       */
      maxResults: number;
      /**
       * @description Whether to include full document content in results
       * @default false
       */
      includeContent: boolean;
      /**
       * @description Maximum length of summaries in characters
       * @default 300
       */
      maxSummaryLength: number;
      /**
       * Format: float
       * @description Minimum relevance score threshold for results
       * @default 0.3
       */
      minRelevanceScore: number;
    };
    /** @description Response containing search results and voice-friendly summaries */
    QueryDocumentationResponse: {
      /** @description The namespace that was searched */
      namespace: string;
      /** @description The original query string */
      query: string;
      /** @description List of matching documents */
      results: components['schemas']['DocumentResult'][];
      /** @description Total number of matching documents */
      totalResults?: number;
      /** @description Concise spoken summary for voice AI */
      voiceSummary?: string;
      /** @description Suggested follow-up queries */
      suggestedFollowups?: string[];
      /** @description User-friendly message when no results found */
      noResultsMessage?: string;
    };
    /** @description Query objects by type */
    QueryObjectsByTypeRequest: {
      /**
       * Format: uuid
       * @description Region to query
       */
      regionId: string;
      /** @description Object type to filter by */
      objectType: string;
      /** @description Optional bounds filter */
      bounds?: components['schemas']['Bounds'];
      /**
       * @description Maximum objects to return
       * @default 500
       */
      maxObjects: number;
    };
    /** @description Object type query results */
    QueryObjectsByTypeResponse: {
      /** @description Matching objects */
      objects?: components['schemas']['MapObject'][];
      /** @description Queried object type */
      objectType?: string;
      /** @description Whether results were truncated */
      truncated?: boolean;
    };
    /** @description Query map data at a point */
    QueryPointRequest: {
      /**
       * Format: uuid
       * @description Region to query
       */
      regionId: string;
      /** @description Point to query at */
      position: components['schemas']['Position3D'];
      /** @description Kinds to query (default all) */
      kinds?: components['schemas']['MapKind'][] | null;
      /** @description Include objects within this radius */
      radius?: number | null;
    };
    /** @description Point query results */
    QueryPointResponse: {
      /** @description Objects at/near the point */
      objects?: components['schemas']['MapObject'][];
      /** @description Queried position */
      position?: components['schemas']['Position3D'];
      /** @description Applied radius filter */
      radius?: number | null;
    };
    /** @description Single result item from a save query with slot and version metadata */
    QueryResultItem: {
      /**
       * Format: uuid
       * @description Slot identifier
       */
      slotId: string;
      /** @description Slot name */
      slotName: string;
      /**
       * Format: uuid
       * @description Owner ID
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Save category of the slot */
      category: components['schemas']['SaveCategory'];
      /** @description Version number */
      versionNumber: number;
      /**
       * Format: int64
       * @description Size in bytes
       */
      sizeBytes?: number;
      /** @description Schema version */
      schemaVersion?: string | null;
      /** @description Display name */
      displayName?: string | null;
      /** @description Whether pinned */
      pinned?: boolean;
      /** @description Checkpoint name */
      checkpointName?: string | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /** @description Custom metadata */
      metadata?: {
        [key: string]: string;
      };
    };
    /** @description Advanced query for saves across multiple owners with filtering and sorting */
    QuerySavesRequest: {
      /**
       * Format: uuid
       * @description Filter by owner ID
       */
      ownerId?: string | null;
      /** @description Filter by owner type */
      ownerType?: components['schemas']['OwnerType'] | null;
      /** @description Filter by save category */
      category?: components['schemas']['SaveCategory'] | null;
      /**
       * Format: date-time
       * @description Filter by creation date
       */
      createdAfter?: string | null;
      /**
       * Format: date-time
       * @description Filter by creation date
       */
      createdBefore?: string | null;
      /** @description Only return pinned versions */
      pinnedOnly?: boolean | null;
      /** @description Filter by schema version */
      schemaVersion?: string | null;
      /** @description Filter by metadata key-value pairs */
      metadataFilter?: {
        [key: string]: string;
      } | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results
       * @default 20
       */
      limit: number;
      /**
       * @description Sort field
       * @default created_at
       * @enum {string}
       */
      sortBy: 'created_at' | 'size' | 'version_number';
      /**
       * @description Sort order
       * @default desc
       * @enum {string}
       */
      sortOrder: 'asc' | 'desc';
    };
    /** @description Paginated results from a save query operation */
    QuerySavesResponse: {
      /** @description Query results */
      results: components['schemas']['QueryResultItem'][];
      /** @description Total matching results */
      totalCount: number;
    };
    /** @description Full configuration details of a matchmaking queue */
    QueueResponse: {
      /** @description Unique identifier for the queue */
      queueId: string;
      /** @description Game this queue is for */
      gameId: string;
      /** @description Game type for created sessions (maps to game-session service) */
      sessionGameType?: components['schemas']['SessionGameType'];
      /** @description Human-readable queue name */
      displayName: string;
      /** @description Detailed description of the queue */
      description?: string | null;
      /** @description Whether the queue is currently accepting tickets */
      enabled: boolean;
      /** @description Minimum players required for a match */
      minCount: number;
      /** @description Maximum players in a match */
      maxCount: number;
      /** @description Player count must be divisible by this (e.g., 2 for pairs) */
      countMultiple: number;
      /** @description Seconds between match processing intervals */
      intervalSeconds: number;
      /** @description Maximum intervals before relaxing to minCount */
      maxIntervals: number;
      /** @description Skill window expansion steps */
      skillExpansion?: components['schemas']['SkillExpansionStep'][] | null;
      /** @description How to calculate party skill rating */
      partySkillAggregation?: components['schemas']['PartySkillAggregation'];
      /** @description Weights for weighted party skill aggregation */
      partySkillWeights?: number[] | null;
      /** @description Maximum party size for this queue */
      partyMaxSize?: number | null;
      /**
       * @description Whether players can be in multiple queues
       * @default true
       */
      allowConcurrent: boolean;
      /** @description Exclusive group name (player can only be in one queue of the group) */
      exclusiveGroup?: string | null;
      /**
       * @description Whether to use lib-analytics skill rating for matching
       * @default true
       */
      useSkillRating: boolean;
      /** @description lib-analytics rating category to use */
      ratingCategory?: string | null;
      /**
       * @description Start match with minCount after maxIntervals (for large lobbies)
       * @default false
       */
      startWhenMinimumReached: boolean;
      /**
       * @description Whether players must be registered for a tournament
       * @default false
       */
      requiresRegistration: boolean;
      /**
       * @description Whether a tournament ID is required to join
       * @default false
       */
      tournamentIdRequired: boolean;
      /**
       * @description Seconds players have to accept/decline a formed match
       * @default 30
       */
      matchAcceptTimeoutSeconds: number;
      /**
       * Format: date-time
       * @description When the queue was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the queue was last updated
       */
      updatedAt?: string | null;
    };
    /** @description Statistics for a single matchmaking queue */
    QueueStats: {
      /** @description Queue identifier */
      queueId: string;
      /** @description Number of active tickets */
      currentTickets: number;
      /** @description Matches formed in the last hour */
      matchesFormedLastHour: number;
      /** @description Average wait time in seconds */
      averageWaitSeconds: number;
      /** @description Median wait time in seconds */
      medianWaitSeconds?: number | null;
      /** @description Percentage of tickets that timed out */
      timeoutRatePercent?: number | null;
      /** @description Percentage of tickets cancelled by user */
      cancelRatePercent?: number | null;
    };
    /** @description Summary information about a matchmaking queue */
    QueueSummary: {
      /** @description Unique identifier for the queue */
      queueId: string;
      /** @description Game this queue is for */
      gameId: string;
      /** @description Human-readable queue name */
      displayName: string;
      /** @description Whether the queue is currently accepting tickets */
      enabled: boolean;
      /** @description Minimum players required for a match */
      minCount: number;
      /** @description Maximum players in a match */
      maxCount: number;
      /** @description Current number of tickets in queue (if available) */
      currentTickets?: number | null;
      /** @description Average wait time in seconds (if available) */
      averageWaitSeconds?: number | null;
    };
    /**
     * @description Game realm the asset belongs to
     * @enum {string}
     */
    Realm: 'omega' | 'arcadia' | 'fantasia' | 'shared';
    /**
     * @description Categories of historical events that realms can participate in
     * @enum {string}
     */
    RealmEventCategory:
      | 'FOUNDING'
      | 'WAR'
      | 'TREATY'
      | 'CATACLYSM'
      | 'DISCOVERY'
      | 'MIGRATION'
      | 'CULTURAL_SHIFT'
      | 'ECONOMIC_CHANGE'
      | 'POLITICAL_UPHEAVAL';
    /**
     * @description How the realm participated in the historical event
     * @enum {string}
     */
    RealmEventRole:
      | 'ORIGIN'
      | 'AGGRESSOR'
      | 'DEFENDER'
      | 'MEDIATOR'
      | 'AFFECTED'
      | 'BENEFICIARY'
      | 'INSTIGATOR'
      | 'NEUTRAL_PARTY';
    /** @description Request to check if a realm exists and is available for use */
    RealmExistsRequest: {
      /**
       * Format: uuid
       * @description ID of the realm to validate
       */
      realmId: string;
    };
    /** @description Response indicating whether a realm exists and its active status */
    RealmExistsResponse: {
      /** @description Whether the realm exists */
      exists: boolean;
      /** @description Whether the realm is active (false if deprecated or not found) */
      isActive: boolean;
      /**
       * Format: uuid
       * @description The realm ID if found
       */
      realmId?: string | null;
    };
    /** @description Record of a realm's participation in a historical event */
    RealmHistoricalParticipation: {
      /**
       * Format: uuid
       * @description Unique ID for this participation record
       */
      participationId: string;
      /**
       * Format: uuid
       * @description ID of the realm that participated
       */
      realmId: string;
      /**
       * Format: uuid
       * @description ID of the historical event
       */
      eventId: string;
      /** @description Name of the event (for display and summarization) */
      eventName: string;
      /** @description Category of the historical event */
      eventCategory: components['schemas']['RealmEventCategory'];
      /** @description How the realm participated */
      role: components['schemas']['RealmEventRole'];
      /**
       * Format: date-time
       * @description In-game date when the event occurred
       */
      eventDate: string;
      /**
       * Format: float
       * @description How significant this event was for the realm (0.0 to 1.0).
       *     Affects behavior system weighting.
       * @default 0.5
       */
      impact: number;
      /** @description Event-specific details for behavior decisions */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When this record was created
       */
      createdAt: string;
    };
    /** @description Paginated list of realms with metadata for navigation */
    RealmListResponse: {
      /** @description List of realms matching the query criteria */
      realms: components['schemas']['RealmResponse'][];
      /** @description Total number of realms matching the query (before pagination) */
      totalCount: number;
      /** @description Current page number (1-indexed) */
      page: number;
      /** @description Number of realms per page */
      pageSize: number;
      /** @description Whether there are more realms available on the next page */
      hasNextPage?: boolean;
      /** @description Whether there are realms available on the previous page */
      hasPreviousPage?: boolean;
    };
    /** @description A machine-readable lore element for behavior system consumption */
    RealmLoreElement: {
      /** @description Category of this lore element */
      elementType: components['schemas']['RealmLoreElementType'];
      /**
       * @description Machine-readable key (e.g., "founding_year", "primary_export", "capital_city").
       *     Used by behavior system to query specific aspects.
       */
      key: string;
      /**
       * @description Machine-readable value (e.g., "year_of_the_dragon", "iron_ore", "stormgate").
       *     Referenced in behavior rules.
       */
      value: string;
      /**
       * Format: float
       * @description How strongly this element affects behavior (0.0 to 1.0).
       *     Higher strength = greater influence on decisions.
       * @default 0.5
       */
      strength: number;
      /**
       * Format: uuid
       * @description Optional related entity (location, organization, character)
       */
      relatedEntityId?: string | null;
      /** @description Type of the related entity (if any) */
      relatedEntityType?: string | null;
    };
    /**
     * @description Types of lore elements. Each type represents a different aspect
     *     of the realm's background that influences behavior.
     * @enum {string}
     */
    RealmLoreElementType:
      | 'ORIGIN_MYTH'
      | 'CULTURAL_PRACTICE'
      | 'POLITICAL_SYSTEM'
      | 'ECONOMIC_BASE'
      | 'RELIGIOUS_TRADITION'
      | 'GEOGRAPHIC_FEATURE'
      | 'FAMOUS_FIGURE'
      | 'TECHNOLOGICAL_LEVEL';
    /** @description Complete lore data for a realm */
    RealmLoreResponse: {
      /**
       * Format: uuid
       * @description ID of the realm this lore belongs to
       */
      realmId: string;
      /** @description All lore elements for this realm */
      elements: components['schemas']['RealmLoreElement'][];
      /**
       * Format: date-time
       * @description When this lore was first created
       */
      createdAt?: string | null;
      /**
       * Format: date-time
       * @description When this lore was last modified
       */
      updatedAt?: string | null;
    };
    /** @description Paginated list of participation records */
    RealmParticipationListResponse: {
      /** @description List of participation records */
      participations: components['schemas']['RealmHistoricalParticipation'][];
      /** @description Total number of matching records */
      totalCount: number;
      /** @description Current page number (1-based) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more results after this page */
      hasNextPage?: boolean;
      /** @description Whether there are results before this page */
      hasPreviousPage?: boolean;
    };
    /** @description Complete realm information returned from API operations */
    RealmResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the realm
       */
      realmId: string;
      /** @description Unique code for the realm (e.g., "OMEGA", "ARCADIA") */
      code: string;
      /** @description Display name for the realm */
      name: string;
      /** @description Detailed description of the realm */
      description?: string | null;
      /** @description Category for grouping realms */
      category?: string | null;
      /** @description Whether the realm is currently active for gameplay */
      isActive: boolean;
      /** @description Whether this realm is deprecated and cannot be used for new entities */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this realm was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation */
      deprecationReason?: string | null;
      /** @description Additional custom metadata for the realm */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Timestamp when the realm was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the realm was last updated
       */
      updatedAt: string;
    };
    /** @description Status and population information for a single game realm */
    RealmStatus: {
      /** @description Unique identifier for the game realm */
      realmId: string;
      /** @description Display name of the game realm */
      name: string;
      /**
       * @description Current operational status of the realm
       * @enum {string}
       */
      status: 'online' | 'offline' | 'maintenance' | 'full';
      /**
       * @description Current player population level
       * @enum {string}
       */
      population: 'low' | 'medium' | 'high' | 'full';
      /** @description Current number of players online */
      playerCount?: number | null;
      /** @description Latency in milliseconds */
      ping?: number | null;
    };
    /** @description Information about a reference */
    ReferenceInfo: {
      /**
       * Format: uuid
       * @description Scene containing the reference
       */
      sceneId: string;
      /** @description Name of the referencing scene */
      sceneName: string;
      /**
       * Format: uuid
       * @description Node containing the reference
       */
      nodeId: string;
      /** @description refId of the referencing node */
      nodeRefId: string;
      /** @description Name of the referencing node */
      nodeName?: string;
    };
    /** @description Request to obtain a new access token using a valid refresh token */
    RefreshRequest: {
      /** @description Refresh token issued during authentication to obtain a new access token */
      refreshToken: string;
    };
    /** @description Request to register a new user account */
    RegisterRequest: {
      /**
       * @description Unique username for the account
       * @example gameuser123
       */
      username: string;
      /**
       * Format: password
       * @description Password for the account (will be hashed)
       * @example SecurePassword123!
       */
      password: string;
      /**
       * Format: email
       * @description Email address for account recovery and notifications
       * @example user@example.com
       */
      email: string;
    };
    /** @description Response from successful user registration */
    RegisterResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the newly created account
       */
      accountId: string;
      /**
       * @description JWT access token for immediate authentication
       * @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJnYW1ldXNlcjEyMyIsImlhdCI6MTY0MDk5NTIwMCwiZXhwIjoxNjQwOTk4ODAwfQ.signature
       */
      accessToken: string;
      /**
       * @description Refresh token for obtaining new access tokens
       * @example refresh_token_abc123xyz789
       */
      refreshToken?: string | null;
      /**
       * Format: uri
       * @description WebSocket endpoint for Connect service
       */
      connectUrl: string;
    };
    /** @description Request to register a new save data schema with optional migration rules */
    RegisterSchemaRequest: {
      /** @description Schema namespace (e.g., game identifier) */
      namespace: string;
      /** @description Schema version identifier */
      schemaVersion: string;
      /** @description JSON Schema definition for validation */
      schema: Record<string, never>;
      /** @description Previous version this migrates from */
      previousVersion?: string | null;
      /**
       * @description JSON Patch (RFC 6902) operations to migrate from previousVersion.
       *     Uses JsonPatch.Net library (MIT licensed).
       */
      migrationPatch?: components['schemas']['JsonPatchOperation'][] | null;
    };
    /**
     * @description How deep to traverse related document links:
     *     - none: No related documents included
     *     - direct: Only directly linked documents (depth 1)
     *     - extended: Related documents + their related documents (depth 2)
     * @default direct
     * @enum {string}
     */
    RelatedDepth: 'none' | 'direct' | 'extended';
    /** @description Paginated list of relationships with metadata for navigation */
    RelationshipListResponse: {
      /** @description List of relationships matching the query */
      relationships: components['schemas']['RelationshipResponse'][];
      /** @description Total number of relationships matching the query */
      totalCount: number;
      /** @description Current page number (1-based) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more results on the next page */
      hasNextPage?: boolean;
      /** @description Whether there are results on the previous page */
      hasPreviousPage?: boolean;
    };
    /** @description Complete details of a relationship between two entities */
    RelationshipResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the relationship
       */
      relationshipId: string;
      /**
       * Format: uuid
       * @description ID of the first entity in the relationship
       */
      entity1Id: string;
      /** @description Type of the first entity in the relationship */
      entity1Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the second entity in the relationship
       */
      entity2Id: string;
      /** @description Type of the second entity in the relationship */
      entity2Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Relationship type ID (from RelationshipType service)
       */
      relationshipTypeId: string;
      /**
       * Format: date-time
       * @description In-game timestamp when relationship started
       */
      startedAt: string;
      /**
       * Format: date-time
       * @description In-game timestamp when relationship ended, null if still active
       */
      endedAt?: string | null;
      /** @description Type-specific relationship data */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description System timestamp when the relationship record was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description System timestamp when the relationship record was last updated
       */
      updatedAt?: string | null;
    };
    /** @description Response containing a list of relationship types with total count */
    RelationshipTypeListResponse: {
      /** @description List of relationship types matching the query */
      types: components['schemas']['RelationshipTypeResponse'][];
      /** @description Total number of relationship types returned */
      totalCount: number;
    };
    /** @description Complete representation of a relationship type including hierarchy, inverse, and deprecation information */
    RelationshipTypeResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the relationship type
       */
      relationshipTypeId: string;
      /** @description Unique code for the relationship type (e.g., "SON", "MOTHER") */
      code: string;
      /** @description Human-readable display name for the relationship type */
      name: string;
      /** @description Detailed description of the relationship type */
      description?: string | null;
      /** @description Category for grouping relationship types (e.g., "FAMILY", "SOCIAL") */
      category?: string | null;
      /**
       * Format: uuid
       * @description ID of the parent type in the hierarchy (null for root types)
       */
      parentTypeId?: string | null;
      /** @description Code of the parent type (for convenience) */
      parentTypeCode?: string | null;
      /**
       * Format: uuid
       * @description ID of the inverse relationship type (e.g., PARENT is inverse of CHILD)
       */
      inverseTypeId?: string | null;
      /** @description Code of the inverse relationship type (for convenience) */
      inverseTypeCode?: string | null;
      /** @description Whether the relationship is the same in both directions (e.g., SIBLING) */
      isBidirectional: boolean;
      /** @description Whether this type is deprecated and cannot be used for new relationships */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this type was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation */
      deprecationReason?: string | null;
      /** @description Depth in the hierarchy (0 for root types) */
      depth: number;
      /** @description Additional custom metadata for the relationship type */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Timestamp when the relationship type was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the relationship type was last updated
       */
      updatedAt: string;
    };
    /** @description Request to rename an existing save slot */
    RenameSlotRequest: {
      /** @description Game identifier */
      gameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the slot
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Current slot name */
      slotName: string;
      /** @description New slot name */
      newSlotName: string;
    };
    /** @description Detailed repository binding configuration and status */
    RepositoryBindingInfo: {
      /**
       * Format: uuid
       * @description Unique identifier of the repository binding
       */
      bindingId: string;
      /** @description Namespace the repository is bound to */
      namespace: string;
      /** @description URL of the bound repository */
      repositoryUrl: string;
      /** @description Branch being synced */
      branch?: string;
      /** @description Current status of the binding */
      status: components['schemas']['BindingStatus'];
      /** @description Whether automatic sync is enabled */
      syncEnabled?: boolean;
      /** @description Sync interval in minutes */
      syncIntervalMinutes?: number;
      /** @description Number of documents from this repository */
      documentCount?: number;
      /**
       * Format: date-time
       * @description Timestamp when the binding was created
       */
      createdAt?: string;
      /**
       * @description Owner of this binding. NOT a session ID.
       *     Contains either an accountId (UUID format) for user-initiated bindings
       *     or a service name for service-initiated bindings.
       */
      owner?: string;
    };
    /** @description Request to get current repository binding and sync status */
    RepositoryStatusRequest: {
      /** @description Documentation namespace to get status for */
      namespace: string;
    };
    /** @description Response containing binding configuration and recent sync information */
    RepositoryStatusResponse: {
      /** @description Current binding configuration and status */
      binding?: components['schemas']['RepositoryBindingInfo'];
      /** @description Information about the most recent sync */
      lastSync?: components['schemas']['SyncInfo'];
    };
    /** @description Request for full snapshot */
    RequestSnapshotRequest: {
      /**
       * Format: uuid
       * @description Region to snapshot
       */
      regionId: string;
      /** @description Which kinds to include (default all) */
      kinds?: components['schemas']['MapKind'][] | null;
      /** @description Optional bounds filter */
      bounds?: components['schemas']['Bounds'];
      /**
       * @description Optional authority token. If provided and valid, clears the
       *     RequiresConsumeBeforePublish flag for require_consume takeover mode.
       */
      authorityToken?: string | null;
    };
    /** @description Snapshot response */
    RequestSnapshotResponse: {
      /**
       * Format: uuid
       * @description Region ID
       */
      regionId?: string;
      /** @description All objects in snapshot */
      objects?: components['schemas']['MapObject'][];
      /** @description For large snapshots, lib-asset reference */
      payloadRef?: string | null;
      /**
       * Format: int64
       * @description Snapshot version
       */
      version?: number;
    };
    /** @description Reservation token returned when creating a matchmade session */
    ReservationInfo: {
      /**
       * Format: uuid
       * @description Account ID this reservation is for
       */
      accountId: string;
      /** @description Token to claim this reservation */
      token: string;
      /**
       * Format: date-time
       * @description When this reservation expires
       */
      expiresAt: string;
    };
    /** @description Request to resolve optimal bundle downloads for requested assets */
    ResolveBundlesRequest: {
      /** @description Platform asset IDs to resolve */
      assetIds: string[];
      /** @description Game realm to search within */
      realm: components['schemas']['Realm'];
      /**
       * @description Prefer metabundles when coverage is equal
       * @default true
       */
      preferMetabundles: boolean;
      /**
       * @description Include standalone assets not in any bundle
       * @default true
       */
      includeStandalone: boolean;
      /** @description Maximum number of bundles to return (optimization limit) */
      maxBundles?: number | null;
    };
    /** @description Optimal bundle set for requested assets */
    ResolveBundlesResponse: {
      /** @description Bundles to download */
      bundles: components['schemas']['ResolvedBundle'][];
      /** @description Individual assets to download */
      standaloneAssets: components['schemas']['ResolvedAsset'][];
      /** @description Coverage statistics */
      coverage: components['schemas']['CoverageAnalysis'];
      /** @description Asset IDs that couldn't be found (null if all resolved) */
      unresolved?: string[] | null;
    };
    /** @description A standalone asset selected for download */
    ResolvedAsset: {
      /** @description Asset identifier */
      assetId: string;
      /**
       * Format: uri
       * @description Pre-signed download URL
       */
      downloadUrl: string;
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Asset file size in bytes
       */
      size: number;
      /** @description SHA256 hash of asset content */
      contentHash?: string | null;
    };
    /** @description A bundle selected for download in resolution */
    ResolvedBundle: {
      /** @description Bundle identifier */
      bundleId: string;
      /** @description Whether source or metabundle */
      bundleType: components['schemas']['BundleType'];
      /** @description Bundle version */
      version?: string | null;
      /**
       * Format: uri
       * @description Pre-signed download URL
       */
      downloadUrl: string;
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Bundle file size in bytes
       */
      size: number;
      /** @description Which of the requested assets this bundle provides */
      assetsProvided: string[];
    };
    /** @description A successfully resolved scene reference */
    ResolvedReference: {
      /**
       * Format: uuid
       * @description Node ID containing the reference
       */
      nodeId: string;
      /** @description refId of the referencing node */
      refId: string;
      /**
       * Format: uuid
       * @description ID of the referenced scene
       */
      referencedSceneId: string;
      /** @description Version that was resolved */
      referencedVersion?: string | null;
      /** @description The resolved scene content */
      scene: components['schemas']['Scene'];
      /** @description Depth level of this reference */
      depth?: number;
    };
    /** @description Request to restore a soft-deleted bundle */
    RestoreBundleRequest: {
      /** @description Bundle identifier to restore */
      bundleId: string;
      /** @description Optional reason for restoration (recorded in version history) */
      reason?: string | null;
    };
    /** @description Result of bundle restoration */
    RestoreBundleResponse: {
      /** @description Restored bundle identifier */
      bundleId: string;
      /** @description Current bundle status (should be "active") */
      status: string;
      /**
       * Format: date-time
       * @description When the bundle was restored
       */
      restoredAt: string;
      /** @description Version number the bundle was restored from */
      restoredFromVersion: number;
    };
    /** @description Search engine optimization and social media sharing metadata */
    SEOMetadata: {
      /** @description Meta description for search engines */
      description?: string | null;
      /** @description Keywords for search engine indexing */
      keywords?: string[];
      /** @description Open Graph title for social media sharing */
      ogTitle?: string | null;
      /** @description Open Graph description for social media sharing */
      ogDescription?: string | null;
      /**
       * Format: uri
       * @description Open Graph image URL for social media sharing
       */
      ogImage?: string | null;
    };
    /**
     * @description Category of save with predefined behaviors.
     *     QUICK_SAVE: Single-slot fast save, overwritten frequently (max 1 version).
     *     AUTO_SAVE: System-triggered periodic saves (max 5 versions, rolling).
     *     MANUAL_SAVE: User-initiated named saves (max 10 versions, no auto-cleanup).
     *     CHECKPOINT: Progress markers (max 20 versions, rolling).
     *     STATE_SNAPSHOT: Full state captures for debugging (max 3 versions, rolling).
     * @enum {string}
     */
    SaveCategory: 'QUICK_SAVE' | 'AUTO_SAVE' | 'MANUAL_SAVE' | 'CHECKPOINT' | 'STATE_SNAPSHOT';
    /** @description Request to save incremental changes as a delta from a base version */
    SaveDeltaRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Name of the slot to save the delta to */
      slotName: string;
      /** @description Version number this delta is based on */
      baseVersion: number;
      /**
       * Format: byte
       * @description Base64-encoded delta/patch data.
       *     For JSON_PATCH: Array of RFC 6902 operations
       *     For BSDIFF/XDELTA: Binary patch data
       */
      delta: string;
      /** @description Delta computation algorithm to use (defaults to JSON_PATCH) */
      algorithm?: components['schemas']['DeltaAlgorithm'] | null;
      /** @description Schema version of this save for migration tracking */
      schemaVersion?: string | null;
      /** @description Human-readable name for this delta save */
      displayName?: string | null;
      /** @description Device identifier for cross-device sync conflict detection */
      deviceId?: string | null;
      /** @description Custom key-value metadata for this delta version */
      metadata?: {
        [key: string]: string;
      } | null;
    };
    /** @description Result of delta save operation with size and chain information */
    SaveDeltaResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the save slot
       */
      slotId: string;
      /** @description New version number */
      versionNumber: number;
      /** @description Base version this delta is relative to */
      baseVersion: number;
      /**
       * Format: int64
       * @description Size of stored delta
       */
      deltaSizeBytes: number;
      /**
       * Format: int64
       * @description Estimated size when reconstructed
       */
      estimatedFullSizeBytes: number;
      /** @description Number of deltas in chain to base snapshot */
      chainLength?: number;
      /**
       * Format: double
       * @description Storage savings vs full snapshot (0-1)
       */
      compressionSavings?: number;
      /**
       * Format: date-time
       * @description When the delta version was created
       */
      createdAt: string;
    };
    /** @description Request to save game state data to a slot with optional compression and metadata */
    SaveRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name (auto-created if doesn't exist) */
      slotName: string;
      /** @description Category for auto-created slots (defaults to MANUAL_SAVE) */
      category?: components['schemas']['SaveCategory'] | null;
      /**
       * Format: byte
       * @description Base64-encoded save data
       */
      data: string;
      /** @description Schema version identifier for migration tracking */
      schemaVersion?: string | null;
      /** @description Human-readable name for this save */
      displayName?: string | null;
      /**
       * Format: byte
       * @description Optional preview image (JPEG/WebP). Max size configurable
       *     (default 256KB). Used for save slot previews in game UI.
       */
      thumbnail?: string | null;
      /**
       * @description Optional device identifier for cloud save conflict detection.
       *     When provided, saves are prefixed/tagged with device info,
       *     enabling opt-in cross-device sync with collision awareness.
       */
      deviceId?: string | null;
      /** @description Custom metadata (e.g., level, playtime, location) */
      metadata?: {
        [key: string]: string;
      } | null;
      /** @description If provided, pin this version with checkpoint name */
      pinAsCheckpoint?: string | null;
    };
    /** @description Result of a save operation including version info and conflict detection */
    SaveResponse: {
      /**
       * Format: uuid
       * @description Slot identifier
       */
      slotId: string;
      /** @description Assigned version number */
      versionNumber: number;
      /** @description SHA-256 hash of save data */
      contentHash: string;
      /**
       * Format: int64
       * @description Size of save data in bytes
       */
      sizeBytes: number;
      /**
       * Format: int64
       * @description Compressed size (if compression applied)
       */
      compressedSizeBytes?: number;
      /**
       * Format: double
       * @description Compression ratio (0-1)
       */
      compressionRatio?: number;
      /** @description Whether version was pinned */
      pinned?: boolean;
      /** @description Checkpoint name if pinned */
      checkpointName?: string | null;
      /**
       * Format: uri
       * @description Pre-signed URL to retrieve thumbnail (if provided)
       */
      thumbnailUrl?: string | null;
      /**
       * @description True if this save overwrote a version from a different device.
       *     Only relevant when deviceId is used for cloud sync.
       */
      conflictDetected?: boolean;
      /** @description Device ID of the overwritten version (if conflict) */
      conflictingDeviceId?: string | null;
      /** @description Version number that was overwritten (if conflict) */
      conflictingVersion?: number | null;
      /**
       * Format: date-time
       * @description Save timestamp
       */
      createdAt: string;
      /** @description Number of old versions cleaned up by rolling policy */
      versionsCleanedUp?: number;
      /**
       * @description True if async upload is enabled and data is queued for MinIO upload.
       *     Save is immediately loadable from Redis cache, but not yet durable.
       */
      uploadPending?: boolean;
    };
    /** @description A complete scene document with hierarchical node structure */
    Scene: {
      /**
       * @description Schema identifier for validation
       * @default bannou://schemas/scene/v1
       */
      schema: string;
      /**
       * Format: uuid
       * @description Unique scene identifier
       */
      sceneId: string;
      /**
       * @description Game service identifier for partitioning. Treated as opaque string.
       *     Default is the nil UUID for unpartitioned scenes.
       * @default 00000000-0000-0000-0000-000000000000
       */
      gameId: string;
      /** @description Scene classification for querying and validation */
      sceneType: components['schemas']['SceneType'];
      /** @description Human-readable scene name */
      name: string;
      /** @description Optional scene description */
      description?: string | null;
      /** @description Semantic version (MAJOR.MINOR.PATCH) */
      version: string;
      /** @description Root node of the scene hierarchy */
      root: components['schemas']['SceneNode'];
      /** @description Searchable tags for filtering scenes */
      tags?: string[];
      /**
       * @description Scene-level metadata. Not interpreted by Scene service.
       *     Examples: author, thumbnail, editor preferences, generator config.
       */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When the scene was first created
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description When the scene was last modified
       */
      updatedAt?: string;
    };
    /**
     * @description A node in the scene hierarchy. Nodes can contain children to form
     *     a tree structure. Each node has a local transform relative to its parent.
     */
    SceneNode: {
      /**
       * Format: uuid
       * @description Globally unique node identifier
       */
      nodeId: string;
      /**
       * @description Scene-local reference identifier. Must be unique within the scene.
       *     Used for scripting and cross-referencing. Examples: main_door, npc_spawn_1
       */
      refId: string;
      /**
       * Format: uuid
       * @description Parent node ID. Null for the root node only.
       */
      parentNodeId?: string | null;
      /** @description Human-readable display name for the node */
      name: string;
      /** @description The structural type of this node */
      nodeType: components['schemas']['NodeType'];
      /** @description Transform relative to parent node */
      localTransform: components['schemas']['Transform'];
      /** @description Optional asset binding (mesh, sound, particle effect) */
      asset?: components['schemas']['AssetReference'];
      /** @description Child nodes in the hierarchy */
      children?: components['schemas']['SceneNode'][];
      /**
       * @description Whether this node is active in the scene definition
       * @default true
       */
      enabled: boolean;
      /**
       * @description Ordering among siblings for deterministic iteration
       * @default 0
       */
      sortOrder: number;
      /** @description Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive) */
      tags?: string[];
      /**
       * @description Consumer-specific data stored without interpretation.
       *     Use namespaced keys (e.g., render.castShadows, arcadia.interactionType).
       */
      annotations?: {
        [key: string]: unknown;
      } | null;
      /**
       * @description Predefined locations for attaching child objects.
       *     Used by Scene Composer for furniture decoration, wall accessories, etc.
       */
      attachmentPoints?: components['schemas']['AttachmentPoint'][];
      /**
       * @description Interaction capabilities of this node.
       *     Used by AI navigation and character controllers.
       */
      affordances?: components['schemas']['Affordance'][];
      /**
       * @description Procedural asset swapping configuration.
       *     Defines which assets can substitute for this node's asset.
       */
      assetSlot?: components['schemas']['AssetSlot'];
      /**
       * @description Type of marker for marker nodes.
       *     Only relevant when nodeType is 'marker'.
       */
      markerType?: components['schemas']['MarkerType'];
      /**
       * @description Shape of volume for volume nodes.
       *     Only relevant when nodeType is 'volume'.
       */
      volumeShape?: components['schemas']['VolumeShape'];
      /**
       * @description Size/extents of the volume (interpretation depends on volumeShape).
       *     For box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.
       */
      volumeSize?: components['schemas']['Vector3'];
      /**
       * Format: uuid
       * @description Scene ID to embed for reference nodes.
       *     Only relevant when nodeType is 'reference'.
       */
      referenceSceneId?: string | null;
    };
    /** @description Standard response containing a scene */
    SceneResponse: {
      /** @description The scene document */
      scene: components['schemas']['Scene'];
    };
    /** @description Summary of a scene for list results (excludes full node tree) */
    SceneSummary: {
      /**
       * Format: uuid
       * @description Unique scene identifier
       */
      sceneId: string;
      /** @description Game service identifier */
      gameId: string;
      /** @description Scene classification */
      sceneType: components['schemas']['SceneType'];
      /** @description Scene name */
      name: string;
      /** @description Scene description */
      description?: string | null;
      /** @description Current version */
      version: string;
      /** @description Scene tags */
      tags?: string[];
      /** @description Total number of nodes in scene */
      nodeCount?: number;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description Last update timestamp
       */
      updatedAt?: string;
      /** @description Whether scene is currently checked out */
      isCheckedOut?: boolean;
    };
    /**
     * @description Scene classification for querying and validation rule lookup.
     *     Different types may have different validation requirements per game.
     * @enum {string}
     */
    SceneType:
      | 'unknown'
      | 'region'
      | 'city'
      | 'district'
      | 'lot'
      | 'building'
      | 'room'
      | 'dungeon'
      | 'arena'
      | 'vehicle'
      | 'prefab'
      | 'cutscene'
      | 'other';
    /** @description Registered schema definition with version lineage information */
    SchemaResponse: {
      /** @description Schema namespace */
      namespace: string;
      /** @description Schema version */
      schemaVersion: string;
      /** @description JSON Schema definition */
      schema?: Record<string, never>;
      /** @description Previous version */
      previousVersion?: string | null;
      /** @description Whether migration script is registered */
      hasMigration?: boolean;
      /**
       * Format: date-time
       * @description Registration timestamp
       */
      createdAt: string;
    };
    /** @description Request to search documentation using keyword matching */
    SearchDocumentationRequest: {
      /** @description Documentation namespace to search within */
      namespace: string;
      /** @description Keyword or phrase to search for */
      searchTerm: string;
      /**
       * Format: uuid
       * @description Optional session ID for tracking searches (null if not tracking)
       */
      sessionId?: string | null;
      /** @description Filter results to a specific category (null for all categories) */
      category?: components['schemas']['DocumentCategory'];
      /**
       * @description Maximum number of results to return
       * @default 10
       */
      maxResults: number;
      /** @description Fields to search within (null for default fields) */
      searchIn?: components['schemas']['SearchField'][] | null;
      /**
       * @description How to sort the search results
       * @default relevance
       * @enum {string}
       */
      sortBy: 'relevance' | 'recency' | 'alphabetical';
      /**
       * @description Whether to include full document content in results
       * @default false
       */
      includeContent: boolean;
    };
    /** @description Response containing keyword search results */
    SearchDocumentationResponse: {
      /** @description The namespace that was searched */
      namespace: string;
      /** @description List of matching documents */
      results: components['schemas']['DocumentResult'][];
      /** @description Total number of matching documents */
      totalResults?: number;
      /** @description The original search term */
      searchTerm?: string;
    };
    /**
     * @description Fields that can be searched within documents
     * @enum {string}
     */
    SearchField: 'title' | 'content' | 'tags' | 'summary';
    /**
     * @description Where the search match was found
     * @enum {string}
     */
    SearchMatchType: 'name' | 'description' | 'tag' | 'node_name';
    /** @description A single search result */
    SearchResult: {
      /** @description Matching scene summary */
      scene: components['schemas']['SceneSummary'];
      /** @description Where the match was found */
      matchType: components['schemas']['SearchMatchType'];
      /** @description Context around the match */
      matchContext?: string | null;
    };
    /** @description Request for full-text search */
    SearchScenesRequest: {
      /** @description Search query text */
      query: string;
      /** @description Filter by game ID */
      gameId?: string | null;
      /** @description Filter by scene types */
      sceneTypes?: components['schemas']['SceneType'][] | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results
       * @default 50
       */
      limit: number;
    };
    /** @description Search results */
    SearchScenesResponse: {
      /** @description Matching scenes */
      results: components['schemas']['SearchResult'][];
      /** @description Total matches */
      total: number;
    };
    /** @description Season information */
    SeasonResponse: {
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /** @description Season number */
      seasonNumber: number;
      /** @description Name of the season */
      seasonName?: string | null;
      /**
       * Format: date-time
       * @description When this season started
       */
      startedAt: string;
      /**
       * Format: date-time
       * @description When this season ended (null if active)
       */
      endedAt?: string | null;
      /** @description Whether this is the current season */
      isActive: boolean;
      /**
       * Format: int64
       * @description Number of entries in this season
       */
      entryCount?: number;
    };
    /** @description Response containing aggregate sentiment */
    SentimentResponse: {
      /**
       * Format: uuid
       * @description Character whose sentiment was queried
       */
      characterId: string;
      /**
       * Format: uuid
       * @description Target of the sentiment
       */
      targetCharacterId: string;
      /**
       * Format: float
       * @description Aggregate sentiment (-1.0 = hostile, +1.0 = friendly)
       */
      sentiment: number;
      /** @description Number of encounters factored in */
      encounterCount: number;
      /** @description Most common emotional impact across encounters */
      dominantEmotion?: components['schemas']['EmotionalImpact'];
    };
    /** @description Aggregated status of all game server realms */
    ServerStatusResponse: {
      /**
       * @description Overall status across all game realms
       * @enum {string}
       */
      globalStatus: 'online' | 'partial' | 'offline' | 'maintenance';
      /** @description Status information for each game realm */
      realms: components['schemas']['RealmStatus'][];
    };
    /** @description Information about a game service */
    ServiceInfo: {
      /**
       * Format: uuid
       * @description Unique identifier for the service
       */
      serviceId: string;
      /** @description URL-safe identifier (e.g., "arcadia") */
      stubName: string;
      /** @description Human-readable name (e.g., "Arcadia Online") */
      displayName: string;
      /** @description Optional description */
      description?: string | null;
      /** @description Whether the service is currently active */
      isActive: boolean;
      /**
       * Format: date-time
       * @description When the service was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the service was last updated
       */
      updatedAt?: string | null;
    };
    /**
     * @description Game type for created sessions (maps to game-session service GameType)
     * @default generic
     * @enum {string}
     */
    SessionGameType: 'generic' | 'arcadia';
    /** @description Information about an active user session including device and activity details */
    SessionInfo: {
      /**
       * Format: uuid
       * @description Unique identifier for the session
       */
      sessionId: string;
      /** @description Information about the device used for this session */
      deviceInfo?: components['schemas']['DeviceInfo'];
      /**
       * Format: date-time
       * @description Timestamp when the session was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp of the last activity in this session
       */
      lastActive: string;
      /** @description IP address from which the session was initiated */
      ipAddress?: string | null;
      /** @description Geographic location derived from the IP address */
      location?: string | null;
    };
    /**
     * @description Type of game session - determines join behavior
     * @enum {string}
     */
    SessionType: 'lobby' | 'matchmade';
    /** @description Response containing a list of all active sessions for an account */
    SessionsResponse: {
      /** @description List of active sessions for the account */
      sessions: components['schemas']['SessionInfo'][];
    };
    /** @description Global website configuration including branding, languages, and integrations */
    SiteSettings: {
      /** @description Display name of the website */
      siteName: string;
      /**
       * Format: uri
       * @description Base URL of the website
       */
      siteUrl: string;
      /** @description Short slogan or description of the site */
      tagline?: string | null;
      /**
       * @description Default language code for the website
       * @default en
       */
      defaultLanguage: string;
      /** @description List of supported language codes */
      supportedLanguages?: string[];
      /**
       * @description Whether the site is in maintenance mode
       * @default false
       */
      maintenanceMode: boolean;
      /** @description Message displayed during maintenance mode */
      maintenanceMessage?: string | null;
      /**
       * Format: email
       * @description Primary contact email address for the site
       */
      contactEmail?: string;
      /** @description Map of social media platform names to profile URLs */
      socialLinks?: {
        [key: string]: string;
      };
      /** @description Analytics and tracking service configuration */
      analytics?: components['schemas']['Analytics'];
      /** @description Custom JavaScript scripts to inject into pages */
      customScripts?: components['schemas']['CustomScripts'];
    };
    /** @description A step in the skill window expansion curve */
    SkillExpansionStep: {
      /** @description Number of intervals after which this step applies */
      intervals: number;
      /** @description Skill range (null means any skill level) */
      range?: number | null;
    };
    /** @description Complete metadata for a save slot including version statistics */
    SlotResponse: {
      /**
       * Format: uuid
       * @description Unique slot identifier
       */
      slotId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Save category determining retention and cleanup behavior */
      category: components['schemas']['SaveCategory'];
      /** @description Maximum versions to retain */
      maxVersions?: number;
      /** @description Days to retain versions (null = indefinite) */
      retentionDays?: number | null;
      /** @description Compression algorithm used for save data */
      compressionType?: components['schemas']['CompressionType'];
      /** @description Current number of versions in slot */
      versionCount?: number;
      /** @description Latest version number (null if empty) */
      latestVersion?: number | null;
      /**
       * Format: int64
       * @description Total storage used by all versions
       */
      totalSizeBytes?: number;
      /**
       * Format: date-time
       * @description Slot creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last modification timestamp
       */
      updatedAt?: string;
      /** @description Custom key-value metadata */
      metadata?: {
        [key: string]: string;
      };
    };
    /**
     * @description How scores are sorted
     * @enum {string}
     */
    SortOrder: 'descending' | 'ascending';
    /** @description Provenance reference to a source bundle used in metabundle creation */
    SourceBundleReference: {
      /** @description Source bundle identifier */
      bundleId: string;
      /** @description Version of source bundle at composition time */
      version: string;
      /** @description Asset IDs contributed from this source bundle */
      assetIds: string[];
      /** @description Hash of source bundle at composition time (for integrity verification) */
      contentHash: string;
    };
    /**
     * @description Spatial context derived from game server's authoritative spatial state.
     *     Included in perception events to give NPC actors awareness of their environment
     *     without requiring direct map subscriptions.
     *
     *     Note: additionalProperties=true allows game-specific extensions.
     */
    SpatialContext: {
      /** @description Terrain type at character position (grass, stone, water, etc.) */
      terrainType?: string | null;
      /**
       * Format: float
       * @description Elevation at character position
       */
      elevation?: number | null;
      /** @description Objects within perception radius */
      nearbyObjects?: components['schemas']['NearbyObject'][] | null;
      /** @description Active hazards within detection range */
      hazardsInRange?: components['schemas']['HazardInfo'][] | null;
      /** @description Directions the character can move (for navigation awareness) */
      pathableDirections?: string[] | null;
      /** @description Whether cover is available within close range */
      coverNearby?: boolean | null;
      /** @description Whether character is currently indoors/under roof */
      indoors?: boolean | null;
    } & {
      [key: string]: unknown;
    };
    /** @description Request to spawn a new actor from a template */
    SpawnActorRequest: {
      /**
       * Format: uuid
       * @description Template to instantiate from
       */
      templateId: string;
      /** @description Optional custom actor ID (auto-generated if not provided) */
      actorId?: string | null;
      /** @description Override template defaults */
      configurationOverrides?: {
        [key: string]: unknown;
      } | null;
      /** @description Initial state passed to behavior */
      initialState?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: uuid
       * @description Optional character ID for NPC brain actors
       */
      characterId?: string | null;
    };
    /** @description Paginated list of species with total count for pagination */
    SpeciesListResponse: {
      /** @description List of species matching the query */
      species: components['schemas']['SpeciesResponse'][];
      /** @description Total number of species matching the query (for pagination) */
      totalCount: number;
      /** @description Current page number */
      page?: number;
      /** @description Number of items per page */
      pageSize?: number;
    };
    /** @description Complete species data including all attributes and realm associations */
    SpeciesResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the species
       */
      speciesId: string;
      /** @description Unique code for the species (e.g., "HUMAN", "ELF") */
      code: string;
      /** @description Display name for the species */
      name: string;
      /** @description Description of the species */
      description?: string | null;
      /** @description Category for grouping (e.g., "HUMANOID", "BEAST", "MAGICAL") */
      category?: string | null;
      /** @description Whether players can create characters of this species */
      isPlayable: boolean;
      /** @description Whether this species is deprecated and cannot be used for new characters */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this species was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation */
      deprecationReason?: string | null;
      /** @description Base lifespan in game years */
      baseLifespan?: number | null;
      /** @description Age at which the species reaches maturity */
      maturityAge?: number | null;
      /** @description Base trait modifiers for this species */
      traitModifiers?: {
        [key: string]: unknown;
      } | null;
      /** @description Realms where this species is available */
      realmIds?: string[];
      /** @description Additional metadata for the species */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Timestamp when the species was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the species was last updated
       */
      updatedAt: string;
    };
    /** @description Request to start an encounter managed by an Event Brain actor */
    StartEncounterRequest: {
      /** @description ID of the Event Brain actor that will manage this encounter */
      actorId: string;
      /** @description Unique identifier for this encounter */
      encounterId: string;
      /** @description Type of encounter (e.g., "combat", "conversation", "choreography") */
      encounterType: string;
      /** @description Character IDs of participants in the encounter */
      participants: string[];
      /** @description Optional initial data for the encounter */
      initialData?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Health and version status information for the website service */
    StatusResponse: {
      /**
       * @description Current health status of the website service
       * @enum {string}
       */
      status: 'healthy' | 'degraded' | 'maintenance';
      /**
       * @description Current version of the website service
       * @example 1.0.0
       */
      version: string;
      /** @description Uptime in seconds */
      uptime: number;
      /** @description Message displayed during maintenance mode */
      maintenanceMessage?: string | null;
    };
    /**
     * @description Request to verify a Steam Session Ticket. The ticket is obtained client-side via
     *     ISteamUser::GetAuthTicketForWebApi("bannou"). SteamID is NOT included because
     *     it must be obtained from Steam's Web API response (never trust client-provided SteamID).
     */
    SteamVerifyRequest: {
      /**
       * @description Hex-encoded Steam Session Ticket from ISteamUser::GetAuthTicketForWebApi().
       *     Client converts ticket bytes to hex string: BitConverter.ToString(ticketData).Replace("-", "")
       * @example 140000006A7B3C8E...
       */
      ticket: string;
      /** @description Information about the client device (optional) */
      deviceInfo?: components['schemas']['DeviceInfo'];
    };
    /** @description Request to stop a running actor */
    StopActorRequest: {
      /** @description ID of the actor to stop */
      actorId: string;
      /**
       * @description If true, allows behavior to complete current iteration
       * @default true
       */
      graceful: boolean;
    };
    /** @description Response confirming actor stop operation */
    StopActorResponse: {
      /** @description Whether the actor was successfully stopped */
      stopped: boolean;
      /** @description Final status of the actor after stopping */
      finalStatus: components['schemas']['ActorStatus'];
    };
    /** @description Response containing a style definition */
    StyleDefinitionResponse: {
      /** @description Unique style identifier */
      styleId: string;
      /** @description Style name */
      name: string;
      /** @description Style category */
      category: string;
      /** @description Human-readable description */
      description?: string | null;
      /** @description Mode probability distribution */
      modeDistribution?: components['schemas']['ModeDistribution'];
      /** @description Interval preferences */
      intervalPreferences?: components['schemas']['IntervalPreferences'];
      /** @description Available forms */
      formTemplates?: components['schemas']['FormTemplate'][] | null;
      /** @description Style-specific tune types */
      tuneTypes?: components['schemas']['TuneType'][] | null;
      /** @description Default tempo */
      defaultTempo?: number;
      /** @description Harmony preferences */
      harmonyStyle?: components['schemas']['HarmonyStyle'];
    };
    /** @description Brief style summary for listing */
    StyleSummary: {
      /** @description Style identifier */
      styleId: string;
      /** @description Style name */
      name: string;
      /** @description Style category */
      category: string;
      /** @description Brief description */
      description?: string | null;
    };
    /** @description Information about a subscription */
    SubscriptionInfo: {
      /**
       * Format: uuid
       * @description Unique identifier for the subscription
       */
      subscriptionId: string;
      /**
       * Format: uuid
       * @description ID of the account this subscription belongs to
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the subscribed service (game)
       */
      serviceId: string;
      /** @description Stub name of the service (denormalized for efficiency) */
      stubName: string;
      /** @description Display name of the service (denormalized for efficiency) */
      displayName?: string;
      /**
       * Format: date-time
       * @description When the subscription started
       */
      startDate: string;
      /**
       * Format: date-time
       * @description When the subscription expires (null for unlimited)
       */
      expirationDate?: string | null;
      /** @description Whether the subscription is currently active */
      isActive: boolean;
      /**
       * Format: date-time
       * @description When the subscription was cancelled (if applicable)
       */
      cancelledAt?: string | null;
      /** @description Reason for cancellation (if applicable) */
      cancellationReason?: string | null;
      /**
       * Format: date-time
       * @description When the subscription was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the subscription was last updated
       */
      updatedAt?: string | null;
    };
    /** @description Response containing list of subscriptions */
    SubscriptionListResponse: {
      /** @description List of subscriptions matching the filter criteria */
      subscriptions: components['schemas']['SubscriptionInfo'][];
      /** @description Total number of subscriptions matching the filter */
      totalCount: number;
    };
    /** @description Current subscription status and plan details for an account */
    SubscriptionResponse: {
      /**
       * @description Current state of the subscription
       * @enum {string}
       */
      status: 'active' | 'inactive' | 'trial' | 'expired';
      /**
       * @description Subscription tier or plan type
       * @enum {string}
       */
      type: 'free' | 'basic' | 'premium' | 'lifetime';
      /**
       * Format: date-time
       * @description Date and time when the subscription expires
       */
      expiresAt?: string | null;
      /** @description Whether automatic renewal is enabled */
      autoRenew?: boolean;
      /** @description List of benefits included in the subscription */
      benefits?: string[];
    };
    /** @description Request to get related topic suggestions based on a source */
    SuggestRelatedRequest: {
      /** @description Documentation namespace for suggestions */
      namespace: string;
      /** @description Type of source to base suggestions on */
      suggestionSource: components['schemas']['SuggestionSource'];
      /** @description The value for the suggestion source (document ID, slug, topic, or category) */
      sourceValue?: string;
      /**
       * Format: uuid
       * @description Optional session ID for personalized suggestions
       */
      sessionId?: string;
      /**
       * @description Maximum number of suggestions to return
       * @default 5
       */
      maxSuggestions: number;
      /**
       * @description Exclude documents viewed in current session
       * @default true
       */
      excludeRecentlyViewed: boolean;
    };
    /** @description Response containing suggested related topics for conversational flow */
    SuggestRelatedResponse: {
      /** @description The namespace suggestions are from */
      namespace: string;
      /** @description List of suggested related topics */
      suggestions: components['schemas']['TopicSuggestion'][];
      /** @description Voice-friendly prompt for presenting suggestions */
      voicePrompt?: string;
      /** @description Whether suggestions were influenced by session history */
      sessionInfluenced?: boolean;
    };
    /**
     * @description Source type for generating related topic suggestions
     * @enum {string}
     */
    SuggestionSource: 'document_id' | 'slug' | 'topic' | 'category';
    /** @description Information about a repository sync operation */
    SyncInfo: {
      /**
       * Format: uuid
       * @description Unique identifier of the sync operation
       */
      syncId?: string;
      /** @description Result status of the sync */
      status?: components['schemas']['SyncStatus'];
      /** @description What triggered the sync */
      triggeredBy?: components['schemas']['SyncTrigger'];
      /**
       * Format: date-time
       * @description Timestamp when sync started
       */
      startedAt?: string;
      /**
       * Format: date-time
       * @description Timestamp when sync completed
       */
      completedAt?: string;
      /** @description Git commit hash that was synced (null if sync failed or repo is empty) */
      commitHash?: string | null;
      /** @description Total documents processed in sync */
      documentsProcessed?: number;
    };
    /** @description Request to trigger a manual repository sync */
    SyncRepositoryRequest: {
      /** @description Documentation namespace to sync */
      namespace: string;
      /**
       * @description Force full re-sync even if commit hash unchanged
       * @default false
       */
      force: boolean;
    };
    /** @description Response containing sync operation results and statistics */
    SyncRepositoryResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of this sync operation
       */
      syncId: string;
      /** @description Result status of the sync */
      status: components['schemas']['SyncStatus'];
      /** @description Git commit hash that was synced (null if sync failed or repo is empty) */
      commitHash?: string | null;
      /** @description Number of new documents created */
      documentsCreated?: number;
      /** @description Number of existing documents updated */
      documentsUpdated?: number;
      /** @description Number of documents deleted */
      documentsDeleted?: number;
      /** @description Number of documents that failed to process */
      documentsFailed?: number;
      /** @description Time taken for sync in milliseconds */
      durationMs?: number;
      /** @description Error message if sync failed */
      errorMessage?: string | null;
    };
    /**
     * @description Status of platform synchronization
     * @enum {string}
     */
    SyncStatus: 'pending' | 'synced' | 'failed' | 'not_linked';
    /**
     * @description What triggered the sync operation
     * @enum {string}
     */
    SyncTrigger: 'manual' | 'scheduled';
    /** @description A tempo change event */
    TempoEvent: {
      /** @description Tick position */
      tick: number;
      /**
       * Format: float
       * @description Tempo in BPM
       */
      bpm: number;
    };
    /** @description A tempo range with min and max BPM */
    TempoRange: {
      /** @description Minimum tempo */
      min: number;
      /** @description Maximum tempo */
      max: number;
    };
    /** @description Request to terminate a specific session */
    TerminateSessionRequest: {
      /**
       * Format: uuid
       * @description ID of the session to terminate
       */
      sessionId: string;
    };
    /** @description Visual theme configuration including colors, fonts, and navigation */
    ThemeConfig: {
      /** @description Name of the active theme */
      themeName: string;
      /** @description Primary brand color in hex format */
      primaryColor: string;
      /** @description Secondary brand color in hex format */
      secondaryColor?: string;
      /** @description Default background color in hex format */
      backgroundColor?: string;
      /** @description Default text color in hex format */
      textColor?: string;
      /** @description Primary font family for the site */
      fontFamily?: string;
      /** @description Additional custom CSS styles */
      customCSS?: string | null;
      /** @description Site logo configuration for branding */
      logo?: components['schemas']['Logo'];
      /**
       * Format: uri
       * @description URL of the site favicon
       */
      favicon?: string | null;
      /** @description Main navigation menu items */
      navigation?: components['schemas']['NavigationItem'][];
    };
    /**
     * @description Current status of a matchmaking ticket
     * @enum {string}
     */
    TicketStatus: 'searching' | 'match_found' | 'match_accepted' | 'cancelled' | 'expired';
    /** @description A time signature change event */
    TimeSignatureEvent: {
      /** @description Tick position */
      tick: number;
      /** @description Beats per measure */
      numerator: number;
      /** @description Beat unit (4 = quarter, 8 = eighth) */
      denominator: number;
    };
    /** @description A suggested related topic with relevance context */
    TopicSuggestion: {
      /**
       * Format: uuid
       * @description Unique identifier of the suggested document
       */
      documentId: string;
      /** @description URL-friendly slug of the suggested document */
      slug?: string;
      /** @description Title of the suggested document */
      title: string;
      /** @description Category of the suggested document */
      category?: components['schemas']['DocumentCategory'];
      /** @description Explanation of why this document is relevant */
      relevanceReason?: string;
    };
    /**
     * @description Core personality trait axes. Each represents a spectrum from -1.0 to +1.0.
     *     Based on psychological research (Big Five + game-relevant extensions).
     * @enum {string}
     */
    TraitAxis:
      | 'OPENNESS'
      | 'CONSCIENTIOUSNESS'
      | 'EXTRAVERSION'
      | 'AGREEABLENESS'
      | 'NEUROTICISM'
      | 'HONESTY'
      | 'AGGRESSION'
      | 'LOYALTY';
    /** @description A single personality trait with its current value and evolution history */
    TraitValue: {
      /** @description The personality axis this value represents */
      axis: components['schemas']['TraitAxis'];
      /**
       * Format: float
       * @description Current trait value on the spectrum (-1.0 to +1.0)
       */
      value: number;
      /**
       * Format: date-time
       * @description When this trait last evolved (null if never changed since creation)
       */
      lastChangedAt?: string | null;
      /**
       * @description Number of times this trait has evolved
       * @default 0
       */
      changeCount: number;
    };
    /** @description Position, rotation, and scale in 3D space */
    Transform: {
      /** @description Position relative to parent */
      position: components['schemas']['Vector3'];
      /** @description Rotation relative to parent */
      rotation: components['schemas']['Quaternion'];
      /** @description Scale relative to parent */
      scale: components['schemas']['Vector3'];
    };
    /** @description A style-specific tune type definition */
    TuneType: {
      /** @description Tune type name (e.g., "reel", "jig") */
      name: string;
      /** @description Time signature for this tune type */
      meter: components['schemas']['TimeSignatureEvent'];
      /** @description Typical tempo range */
      tempoRange?: components['schemas']['TempoRange'];
      /** @description Default form for this tune type */
      defaultForm?: string | null;
      /** @description Rhythm pattern names to use */
      rhythmPatterns?: string[] | null;
    };
    /** @description An unlocked achievement instance */
    UnlockedAchievement: {
      /** @description Achievement identifier */
      achievementId: string;
      /** @description Achievement name */
      displayName: string;
      /** @description Achievement description */
      description?: string;
      /** @description Point value */
      points: number;
      /**
       * Format: uri
       * @description Achievement icon
       */
      iconUrl?: string | null;
      /**
       * Format: date-time
       * @description When it was unlocked
       */
      unlockedAt: string;
    };
    /** @description Request to unpin a previously pinned save version */
    UnpinVersionRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Version to unpin */
      versionNumber: number;
    };
    /** @description A scene reference that could not be resolved */
    UnresolvedReference: {
      /**
       * Format: uuid
       * @description Node ID containing the reference
       */
      nodeId: string;
      /** @description refId of the referencing node */
      refId: string;
      /**
       * Format: uuid
       * @description ID of the scene that could not be resolved
       */
      referencedSceneId: string;
      /** @description Why the reference could not be resolved */
      reason: components['schemas']['UnresolvedReferenceReason'];
      /** @description For circular references, the cycle path (sceneId chain) */
      cyclePath?: string[] | null;
    };
    /**
     * @description Reason why a scene reference could not be resolved
     * @enum {string}
     */
    UnresolvedReferenceReason:
      | 'not_found'
      | 'circular_reference'
      | 'depth_exceeded'
      | 'access_denied';
    /** @description Request to update an achievement definition */
    UpdateAchievementDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the achievement to update */
      achievementId: string;
      /** @description New display name */
      displayName?: string | null;
      /** @description New description */
      description?: string | null;
      /** @description New active status */
      isActive?: boolean | null;
      /** @description Updated platform ID mappings */
      platformIds?: {
        [key: string]: string;
      } | null;
    };
    /** @description Request to update an existing actor template */
    UpdateActorTemplateRequest: {
      /**
       * Format: uuid
       * @description ID of the template to update
       */
      templateId: string;
      /** @description New behavior reference (triggers behavior.updated subscription) */
      behaviorRef?: string | null;
      /** @description Updated configuration settings */
      configuration?: {
        [key: string]: unknown;
      } | null;
      /** @description Updated auto-spawn configuration */
      autoSpawn?: components['schemas']['AutoSpawnConfig'];
      /** @description Updated tick interval in milliseconds */
      tickIntervalMs?: number | null;
      /** @description Updated auto-save interval in seconds */
      autoSaveIntervalSeconds?: number | null;
    };
    /** @description Request to update bundle metadata */
    UpdateBundleRequest: {
      /** @description Bundle identifier to update */
      bundleId: string;
      /** @description New bundle name (null to leave unchanged) */
      name?: string | null;
      /** @description New bundle description (null to leave unchanged) */
      description?: string | null;
      /** @description Replace all tags with these (null to leave unchanged) */
      tags?: {
        [key: string]: string;
      } | null;
      /** @description Tags to add (merged with existing) */
      addTags?: {
        [key: string]: string;
      } | null;
      /** @description Tag keys to remove */
      removeTags?: string[] | null;
      /** @description Optional reason for the update (recorded in version history) */
      reason?: string | null;
    };
    /** @description Result of bundle update operation */
    UpdateBundleResponse: {
      /** @description Updated bundle identifier */
      bundleId: string;
      /** @description New version number after update */
      version: number;
      /** @description Version number before update */
      previousVersion: number;
      /** @description List of changes made (e.g., "name changed", "tag 'env' added") */
      changes: string[];
      /**
       * Format: date-time
       * @description When the update occurred
       */
      updatedAt?: string;
    };
    /** @description Request to update a map definition */
    UpdateDefinitionRequest: {
      /**
       * Format: uuid
       * @description Definition ID to update
       */
      definitionId: string;
      /** @description New name (optional) */
      name?: string | null;
      /** @description New description (optional) */
      description?: string | null;
      /** @description New layer configurations (replaces existing) */
      layers?: components['schemas']['LayerDefinition'][] | null;
      /** @description New default bounds */
      defaultBounds?: components['schemas']['Bounds'];
      /** @description New metadata (replaces existing) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update the phase of an active encounter */
    UpdateEncounterPhaseRequest: {
      /** @description ID of the Event Brain actor managing the encounter */
      actorId: string;
      /** @description New phase name for the encounter */
      phase: string;
    };
    /** @description Response after updating encounter phase */
    UpdateEncounterPhaseResponse: {
      /** @description ID of the actor managing the encounter */
      actorId: string;
      /** @description Previous phase name */
      previousPhase?: string | null;
      /** @description Current phase name after update */
      currentPhase: string;
    };
    /** @description Request to update a leaderboard definition */
    UpdateLeaderboardDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard to update */
      leaderboardId: string;
      /** @description New display name */
      displayName?: string | null;
      /** @description New description */
      description?: string | null;
      /** @description New visibility setting */
      isPublic?: boolean | null;
    };
    /**
     * @description How to handle score updates
     * @enum {string}
     */
    UpdateMode: 'replace' | 'increment' | 'max' | 'min';
    /** @description Request to update an account password */
    UpdatePasswordRequest: {
      /**
       * Format: uuid
       * @description ID of the account to update
       */
      accountId: string;
      /** @description New pre-hashed password from Auth service */
      passwordHash: string;
    };
    /** @description Request to update an account profile */
    UpdateProfileRequest: {
      /**
       * Format: uuid
       * @description ID of the account to update
       */
      accountId: string;
      /** @description New display name for the account */
      displayName?: string | null;
      /** @description Updated custom metadata for the account */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update repository binding configuration */
    UpdateRepositoryBindingRequest: {
      /** @description Documentation namespace of the binding to update */
      namespace: string;
      /** @description Enable or disable automatic syncing */
      syncEnabled?: boolean;
      /** @description New sync interval in minutes */
      syncIntervalMinutes?: number;
      /** @description New glob patterns for files to include (null to keep unchanged) */
      filePatterns?: string[] | null;
      /** @description New glob patterns for files to exclude (null to keep unchanged) */
      excludePatterns?: string[] | null;
      /** @description New directory-to-category mapping (null to keep unchanged) */
      categoryMapping?: {
        [key: string]: string;
      } | null;
      /** @description New default category for unmapped documents */
      defaultCategory?: components['schemas']['DocumentCategory'];
      /** @description Enable or disable archive functionality */
      archiveEnabled?: boolean;
      /** @description Enable or disable archiving after each sync */
      archiveOnSync?: boolean;
    };
    /** @description Response containing the updated binding configuration */
    UpdateRepositoryBindingResponse: {
      /** @description Updated binding configuration */
      binding: components['schemas']['RepositoryBindingInfo'];
    };
    /** @description Request to update an existing scene */
    UpdateSceneRequest: {
      /** @description The updated scene document (sceneId must match existing) */
      scene: components['schemas']['Scene'];
      /** @description Checkout token if updating via checkout workflow */
      checkoutToken?: string | null;
    };
    /** @description Request to update email verification status */
    UpdateVerificationRequest: {
      /**
       * Format: uuid
       * @description ID of the account to update
       */
      accountId: string;
      /** @description New email verification status */
      emailVerified: boolean;
    };
    /** @description Request to initiate an asset upload and receive a pre-signed URL */
    UploadRequest: {
      /**
       * @description Owner of this asset operation. NOT a session ID.
       *     For user-initiated uploads: the accountId (UUID format).
       *     For service-initiated uploads: the service name (e.g., "behavior", "orchestrator").
       */
      owner: string;
      /** @description Original filename with extension */
      filename: string;
      /**
       * Format: int64
       * @description File size in bytes
       */
      size: number;
      /** @description MIME content type (e.g., image/png, model/gltf-binary) */
      contentType: string;
      /** @description Optional metadata for asset categorization */
      metadata?: components['schemas']['AssetMetadataInput'];
    };
    /** @description Response containing pre-signed URL and configuration for uploading an asset */
    UploadResponse: {
      /**
       * Format: uuid
       * @description Unique upload session identifier
       */
      uploadId: string;
      /**
       * Format: uri
       * @description Pre-signed URL for uploading the file
       */
      uploadUrl: string;
      /**
       * Format: date-time
       * @description When the upload URL expires
       */
      expiresAt: string;
      /** @description Configuration for multipart uploads if file size requires it */
      multipart?: components['schemas']['MultipartConfig'];
      /** @description Headers the client must include when uploading to the pre-signed URL */
      requiredHeaders?: {
        [key: string]: string;
      };
    };
    /** @description Request to validate ABML YAML content against schema and semantic rules */
    ValidateAbmlRequest: {
      /** @description Raw ABML YAML content to validate */
      abmlContent: string;
      /**
       * @description Enable strict validation mode with enhanced checking
       * @default false
       */
      strictMode: boolean;
    };
    /** @description Response containing the results of ABML validation including errors and warnings */
    ValidateAbmlResponse: {
      /** @description Whether the ABML definition is valid */
      isValid: boolean;
      /** @description List of validation errors if invalid */
      validationErrors?: components['schemas']['ValidationError'][] | null;
      /** @description Semantic warnings that don't prevent compilation */
      semanticWarnings?: string[] | null;
      /** @description ABML schema version used for validation */
      schemaVersion?: string | null;
    };
    /** @description Request to validate an existing GOAP plan against current world state */
    ValidateGoapPlanRequest: {
      /** @description The plan to validate */
      plan: components['schemas']['GoapPlanResult'];
      /** @description Index of the action currently being executed */
      currentActionIndex: number;
      /** @description Current world state */
      worldState: {
        [key: string]: unknown;
      };
      /** @description All active goals for priority checking */
      activeGoals?: components['schemas']['GoapGoal'][] | null;
    };
    /** @description Response indicating whether a GOAP plan is still valid and suggested next action */
    ValidateGoapPlanResponse: {
      /** @description Whether the plan is still valid */
      isValid: boolean;
      /**
       * @description Reason for the validation result
       * @enum {string}
       */
      reason:
        | 'none'
        | 'preconditionInvalidated'
        | 'actionFailed'
        | 'betterGoalAvailable'
        | 'planCompleted'
        | 'goalAlreadySatisfied'
        | 'suboptimalPlan';
      /**
       * @description Suggested action based on validation
       * @enum {string}
       */
      suggestedAction: 'continue' | 'replan' | 'abort';
      /** @description Index where plan became invalid (if applicable) */
      invalidatedAtIndex?: number;
      /** @description Additional details about the validation result. Null when no additional context is needed. */
      message?: string | null;
    };
    /** @description Request to validate MIDI-JSON structure */
    ValidateMidiJsonRequest: {
      /** @description MIDI-JSON structure to validate */
      midiJson: components['schemas']['MidiJson'];
      /**
       * @description Enable strict validation with additional checks
       * @default false
       */
      strictMode: boolean;
    };
    /** @description Response containing validation results */
    ValidateMidiJsonResponse: {
      /** @description Whether the MIDI-JSON is valid */
      isValid: boolean;
      /** @description Validation errors if invalid */
      errors?: components['schemas']['ValidationError'][] | null;
      /** @description Non-fatal warnings */
      warnings?: string[] | null;
    };
    /** @description Request to validate a scene structure */
    ValidateSceneRequest: {
      /** @description The scene to validate */
      scene: components['schemas']['Scene'];
      /**
       * @description Whether to apply registered game-specific validation rules
       * @default true
       */
      applyGameRules: boolean;
    };
    /** @description Response from token validation containing validity status and associated account details */
    ValidateTokenResponse: {
      /** @description Whether the token is valid and not expired */
      valid: boolean;
      /**
       * Format: uuid
       * @description Unique identifier for the account associated with the token
       */
      accountId: string;
      /**
       * Format: uuid
       * @description Session identifier for WebSocket connections and service routing
       */
      sessionId: string;
      /** @description List of roles assigned to the authenticated user */
      roles?: string[] | null;
      /**
       * @description Authorization strings from active subscriptions.
       *     Format: "{stubName}:{state}" (e.g., "arcadia:authorized")
       */
      authorizations?: string[] | null;
      /** @description Seconds until expiration */
      remainingTime?: number;
    };
    /** @description Detailed validation error with type, location, and message information */
    ValidationError: {
      /**
       * @description Type of validation error
       * @enum {string}
       */
      type: 'syntax' | 'semantic' | 'schema' | 'context' | 'service_dependency';
      /** @description Human-readable error message */
      message: string;
      /** @description Line number where the error occurred (if applicable) */
      lineNumber?: number;
      /** @description Column number where the error occurred (if applicable) */
      columnNumber?: number;
      /**
       * @description YAML path to the problematic element
       * @example behaviors.morning_startup.actions[0]
       */
      yamlPath?: string | null;
    };
    /** @description Result of scene validation */
    ValidationResult: {
      /** @description Whether the scene passed all validation checks */
      valid: boolean;
      /** @description Validation errors (severity = error) */
      errors?: components['schemas']['ValidationError'][] | null;
      /** @description Validation warnings (severity = warning) */
      warnings?: components['schemas']['ValidationError'][] | null;
    };
    /** @description A validation rule definition */
    ValidationRule: {
      /** @description Unique rule identifier within the gameId+sceneType */
      ruleId: string;
      /** @description Human-readable description of the rule */
      description: string;
      /** @description Whether violation is an error or warning */
      severity: components['schemas']['ValidationSeverity'];
      /** @description Type of validation check */
      ruleType: components['schemas']['ValidationRuleType'];
      /** @description Rule-specific configuration */
      config?: components['schemas']['ValidationRuleConfig'];
    };
    /** @description Configuration for a validation rule */
    ValidationRuleConfig: {
      /** @description Filter to nodes of this type (for require_tag) */
      nodeType?: string | null;
      /** @description Tag to check for */
      tag?: string | null;
      /** @description Minimum occurrences required */
      minCount?: number | null;
      /** @description Maximum occurrences allowed */
      maxCount?: number | null;
      /** @description JSONPath to required annotation field (for require_annotation) */
      annotationPath?: string | null;
      /** @description Custom validation expression (for custom_expression) */
      expression?: string | null;
    };
    /**
     * @description Type of validation check to perform
     * @enum {string}
     */
    ValidationRuleType:
      | 'require_tag'
      | 'require_node_type'
      | 'forbid_tag'
      | 'require_annotation'
      | 'custom_expression';
    /**
     * @description Severity level of a validation issue
     * @enum {string}
     */
    ValidationSeverity: 'error' | 'warning';
    /** @description A point or direction in 3D space */
    Vector3: {
      /**
       * Format: double
       * @description X coordinate
       */
      x: number;
      /**
       * Format: double
       * @description Y coordinate
       */
      y: number;
      /**
       * Format: double
       * @description Z coordinate
       */
      z: number;
    };
    /** @description Request to verify data integrity of a save version via hash comparison */
    VerifyIntegrityRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Name of the slot to verify */
      slotName: string;
      /** @description Version to verify (latest if null) */
      versionNumber?: number | null;
    };
    /** @description Result of integrity verification with hash comparison details */
    VerifyIntegrityResponse: {
      /** @description Whether integrity check passed */
      valid: boolean;
      /** @description Version that was verified */
      versionNumber: number;
      /** @description Expected SHA-256 hash */
      expectedHash?: string;
      /** @description Actual hash (null if data unavailable) */
      actualHash?: string | null;
      /** @description Error details if verification failed */
      errorMessage?: string | null;
    };
    /** @description Information about a specific version */
    VersionInfo: {
      /** @description Version string */
      version: string;
      /**
       * Format: date-time
       * @description When this version was created
       */
      createdAt: string;
      /** @description Who created this version */
      createdBy?: string | null;
      /** @description Summary of changes */
      changesSummary?: string | null;
      /** @description Node count at this version */
      nodeCount?: number;
    };
    /** @description Metadata for a single save version including size and checkpoint info */
    VersionResponse: {
      /** @description Version number */
      versionNumber: number;
      /**
       * Format: uuid
       * @description Reference to asset in lib-asset
       */
      assetId?: string;
      /** @description SHA-256 hash */
      contentHash: string;
      /**
       * Format: int64
       * @description Size in bytes
       */
      sizeBytes: number;
      /**
       * Format: int64
       * @description Compressed size if applicable
       */
      compressedSizeBytes?: number;
      /** @description Schema version */
      schemaVersion?: string | null;
      /** @description Human-readable name */
      displayName?: string | null;
      /** @description Whether version is pinned */
      pinned?: boolean;
      /** @description Checkpoint name if pinned */
      checkpointName?: string | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /** @description Custom metadata */
      metadata?: {
        [key: string]: string;
      };
    };
    /** @description Request to apply voice leading to a chord sequence */
    VoiceLeadRequest: {
      /** @description Chord symbols to voice */
      chords: components['schemas']['ChordSymbol'][];
      /** @description Number of voices */
      voiceCount: number;
      /** @description Pitch range per voice (defaults based on voice count) */
      ranges?: components['schemas']['PitchRange'][] | null;
      /** @description Voice leading rules to apply */
      rules?: components['schemas']['VoiceLeadingRules'];
    };
    /** @description Response containing voiced chords */
    VoiceLeadResponse: {
      /** @description Voiced chord realizations */
      voicings: components['schemas']['VoicedChord'][];
      /** @description Voice leading rule violations (warnings) */
      violations?: components['schemas']['VoiceLeadingViolation'][] | null;
    };
    /** @description Rules for voice leading */
    VoiceLeadingRules: {
      /**
       * @description Avoid parallel perfect fifths
       * @default true
       */
      avoidParallelFifths: boolean;
      /**
       * @description Avoid parallel octaves
       * @default true
       */
      avoidParallelOctaves: boolean;
      /**
       * @description Prefer stepwise voice motion
       * @default true
       */
      preferStepwiseMotion: boolean;
      /**
       * @description Avoid voice crossing
       * @default true
       */
      avoidVoiceCrossing: boolean;
      /**
       * @description Maximum leap in semitones
       * @default 7
       */
      maxLeap: number;
    };
    /** @description A voice leading rule violation */
    VoiceLeadingViolation: {
      /** @description Type of violation */
      type: components['schemas']['VoiceLeadingViolationType'];
      /** @description Position in the progression (0-based) */
      position: number;
      /** @description Voice indices involved (0 = bass) */
      voices: number[];
      /** @description Severity (true = error, false = warning) */
      isError: boolean;
      /** @description Human-readable description */
      message: string;
    };
    /**
     * @description Type of voice leading rule violation
     * @enum {string}
     */
    VoiceLeadingViolationType:
      | 'ParallelFifths'
      | 'ParallelOctaves'
      | 'VoiceCrossing'
      | 'VoiceOverlap'
      | 'LargeLeap'
      | 'UnresolvedLeap'
      | 'DoubledLeadingTone';
    /** @description A chord with specific voice pitches */
    VoicedChord: {
      /** @description Original chord symbol */
      symbol: components['schemas']['ChordSymbol'];
      /** @description Pitches from lowest to highest voice */
      pitches: components['schemas']['Pitch'][];
    };
    /**
     * @description Shape of a volume node for spatial bounds
     * @enum {string}
     */
    VolumeShape: 'box' | 'sphere' | 'capsule' | 'cylinder';
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  updateProfile: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateProfileRequest'];
      };
    };
    responses: {
      /** @description Profile updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AccountResponse'];
        };
      };
      /** @description Account not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updatePasswordHash: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdatePasswordRequest'];
      };
    };
    responses: {
      /** @description Password hash updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Account not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateVerificationStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateVerificationRequest'];
      };
    };
    responses: {
      /** @description Verification status updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Account not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createAchievementDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateAchievementDefinitionRequest'];
      };
    };
    responses: {
      /** @description Achievement created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AchievementDefinitionResponse'];
        };
      };
      /** @description Achievement with this ID already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listAchievementDefinitions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListAchievementDefinitionsRequest'];
      };
    };
    responses: {
      /** @description Achievement definitions retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListAchievementDefinitionsResponse'];
        };
      };
    };
  };
  updateAchievementDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateAchievementDefinitionRequest'];
      };
    };
    responses: {
      /** @description Achievement updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AchievementDefinitionResponse'];
        };
      };
      /** @description Achievement not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteAchievementDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteAchievementDefinitionRequest'];
      };
    };
    responses: {
      /** @description Achievement deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Achievement not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAchievementProgress: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAchievementProgressRequest'];
      };
    };
    responses: {
      /** @description Progress retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AchievementProgressResponse'];
        };
      };
    };
  };
  listUnlockedAchievements: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListUnlockedAchievementsRequest'];
      };
    };
    responses: {
      /** @description Unlocked achievements retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListUnlockedAchievementsResponse'];
        };
      };
    };
  };
  CreateActorTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateActorTemplateRequest'];
      };
    };
    responses: {
      /** @description Template created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorTemplateResponse'];
        };
      };
    };
  };
  UpdateActorTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateActorTemplateRequest'];
      };
    };
    responses: {
      /** @description Template updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorTemplateResponse'];
        };
      };
    };
  };
  DeleteActorTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteActorTemplateRequest'];
      };
    };
    responses: {
      /** @description Template deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteActorTemplateResponse'];
        };
      };
    };
  };
  SpawnActor: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SpawnActorRequest'];
      };
    };
    responses: {
      /** @description Actor spawned successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorInstanceResponse'];
        };
      };
    };
  };
  StopActor: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StopActorRequest'];
      };
    };
    responses: {
      /** @description Actor stopped successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StopActorResponse'];
        };
      };
    };
  };
  InjectPerception: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InjectPerceptionRequest'];
      };
    };
    responses: {
      /** @description Perception injected successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InjectPerceptionResponse'];
        };
      };
    };
  };
  StartEncounter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StartEncounterRequest'];
      };
    };
    responses: {
      /** @description Encounter started successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateEncounterPhase: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateEncounterPhaseRequest'];
      };
    };
    responses: {
      /** @description Encounter phase updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateEncounterPhaseResponse'];
        };
      };
    };
  };
  EndEncounter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EndEncounterRequest'];
      };
    };
    responses: {
      /** @description Encounter ended successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EndEncounterResponse'];
        };
      };
    };
  };
  requestUpload: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UploadRequest'];
      };
    };
    responses: {
      /** @description Upload URL generated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UploadResponse'];
        };
      };
      /** @description Invalid request (filename, size, or content_type) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authenticated */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Insufficient permissions */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  completeUpload: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CompleteUploadRequest'];
      };
    };
    responses: {
      /** @description Asset created, processing started */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetMetadata'];
        };
      };
      /** @description Invalid upload_id or missing parts for multipart */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Upload session not found or expired */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAsset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAssetRequest'];
      };
    };
    responses: {
      /** @description Asset metadata with download URL */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetWithDownloadUrl'];
        };
      };
      /** @description Asset not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listAssetVersions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListVersionsRequest'];
      };
    };
    responses: {
      /** @description List of asset versions */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetVersionList'];
        };
      };
      /** @description Asset not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  searchAssets: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AssetSearchRequest'];
      };
    };
    responses: {
      /** @description Matching assets */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetSearchResult'];
        };
      };
    };
  };
  createBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle created immediately (small bundles) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateBundleResponse'];
        };
      };
      /** @description Bundle creation queued (large bundles) */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateBundleResponse'];
        };
      };
      /** @description Invalid asset_ids or bundle_id */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle manifest with download URL */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BundleWithDownloadUrl'];
        };
      };
      /** @description Bundle not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  requestBundleUpload: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BundleUploadRequest'];
      };
    };
    responses: {
      /** @description Upload URL generated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UploadResponse'];
        };
      };
      /** @description Invalid filename or size */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createMetabundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateMetabundleRequest'];
      };
    };
    responses: {
      /** @description Metabundle created or queued for creation */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateMetabundleResponse'];
        };
      };
      /** @description Invalid request or asset conflicts detected */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description One or more source bundles not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Metabundle ID already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getJobStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetJobStatusRequest'];
      };
    };
    responses: {
      /** @description Job status retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetJobStatusResponse'];
        };
      };
      /** @description Job not found or expired */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cancelJob: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CancelJobRequest'];
      };
    };
    responses: {
      /** @description Job cancellation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CancelJobResponse'];
        };
      };
      /** @description Job not found or expired */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Job cannot be cancelled (already completed) */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  resolveBundles: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResolveBundlesRequest'];
      };
    };
    responses: {
      /** @description Resolution complete with download URLs */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ResolveBundlesResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryBundlesByAsset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBundlesByAssetRequest'];
      };
    };
    responses: {
      /** @description Bundles containing the asset */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryBundlesByAssetResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateBundleResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to update this bundle */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle not found or deleted */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteBundleResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to delete this bundle */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  restoreBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RestoreBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle restored successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RestoreBundleResponse'];
        };
      };
      /** @description Invalid request or bundle not in deleted state */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to restore this bundle */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle not found or permanently deleted */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle retention period has expired */
      410: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryBundles: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBundlesRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryBundlesResponse'];
        };
      };
      /** @description Invalid query parameters */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listBundleVersions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListBundleVersionsRequest'];
      };
    };
    responses: {
      /** @description Version history */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListBundleVersionsResponse'];
        };
      };
      /** @description Bundle not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  bulkGetAssets: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BulkGetAssetsRequest'];
      };
    };
    responses: {
      /** @description Asset metadata retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BulkGetAssetsResponse'];
        };
      };
      /** @description Invalid request or too many asset IDs */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  login: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LoginRequest'];
      };
    };
    responses: {
      /** @description Login successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthResponse'];
        };
      };
      /** @description Invalid credentials */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many login attempts */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  register: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterRequest'];
      };
    };
    responses: {
      /** @description Registration successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RegisterResponse'];
        };
      };
      /** @description Invalid request data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Username already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  initOAuth: {
    parameters: {
      query: {
        redirectUri: string;
        state?: string;
      };
      header?: never;
      path: {
        provider: components['schemas']['Provider'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Redirect to OAuth provider */
      302: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  completeOAuth: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        provider: components['schemas']['Provider'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OAuthCallbackRequest'];
      };
    };
    responses: {
      /** @description OAuth authentication successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthResponse'];
        };
      };
    };
  };
  verifySteamAuth: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SteamVerifyRequest'];
      };
    };
    responses: {
      /** @description Steam authentication successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthResponse'];
        };
      };
      /** @description Invalid or expired Steam ticket */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Steam API unavailable or internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  refreshToken: {
    parameters: {
      query?: never;
      header: {
        /** @description Current JWT access token for refresh */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RefreshRequest'];
      };
    };
    responses: {
      /** @description Token refreshed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthResponse'];
        };
      };
    };
  };
  validateToken: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token for validation */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Token is valid */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateTokenResponse'];
        };
      };
      /** @description Invalid or missing token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Token expired or malformed */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  logout: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token for session identification */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['LogoutRequest'];
      };
    };
    responses: {
      /** @description Logged out successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSessions: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token for session identification */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Active sessions retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SessionsResponse'];
        };
      };
    };
  };
  terminateSession: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token for session identification */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TerminateSessionRequest'];
      };
    };
    responses: {
      /** @description Session terminated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  requestPasswordReset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PasswordResetRequest'];
      };
    };
    responses: {
      /** @description Reset email sent if account exists */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  confirmPasswordReset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PasswordResetConfirmRequest'];
      };
    };
    responses: {
      /** @description Password reset successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listProviders: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of available providers */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ProvidersResponse'];
        };
      };
    };
  };
  CompileAbmlBehavior: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        /**
         * @example version: "1.0.0"
         *     metadata:
         *       id: "blacksmith_daily_routine"
         *       category: "profession"
         *       priority: 60
         *       description: "Daily routine for a master blacksmith NPC"
         *
         *     context:
         *       variables:
         *         energy_level: "${npc.stats.energy}"
         *         skill_level: "${npc.skills.blacksmithing}"
         *         shop_reputation: "${npc.reputation.local}"
         *
         *       services:
         *         - name: "crafting_service"
         *           required: true
         *         - name: "economy_service"
         *           required: true
         *
         *     behaviors:
         *       morning_startup:
         *         triggers:
         *           - time_range: "06:00-09:00"
         *           - condition: "${context.energy_level > 0.7}"
         *         actions:
         *           - wake_up:
         *               animation: "stretch_and_yawn"
         *               duration: 3
         *               energy_cost: -0.05
         */
        'application/yaml': string;
        'application/json': components['schemas']['CompileBehaviorRequest'];
      };
    };
    responses: {
      /** @description ABML behavior compiled successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CompileBehaviorResponse'];
        };
      };
      /** @description Invalid ABML definition or compilation error */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden - insufficient permissions */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ValidateAbml: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/yaml': string;
        'application/json': components['schemas']['ValidateAbmlRequest'];
      };
    };
    responses: {
      /** @description Validation completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateAbmlResponse'];
        };
      };
    };
  };
  GetCachedBehavior: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCachedBehaviorRequest'];
      };
    };
    responses: {
      /** @description Cached behavior retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CachedBehaviorResponse'];
        };
      };
      /** @description Behavior not found in cache */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  InvalidateCachedBehavior: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InvalidateCacheRequest'];
      };
    };
    responses: {
      /** @description Cache invalidated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Behavior not found in cache */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GenerateGoapPlan: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoapPlanRequest'];
      };
    };
    responses: {
      /** @description Plan generated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GoapPlanResponse'];
        };
      };
      /** @description Invalid request or planning failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ValidateGoapPlan: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidateGoapPlanRequest'];
      };
    };
    responses: {
      /** @description Plan validation completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateGoapPlanResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCharacterRequest'];
      };
    };
    responses: {
      /** @description Character retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterResponse'];
        };
      };
      /** @description Character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listCharacters: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListCharactersRequest'];
      };
    };
    responses: {
      /** @description Characters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterListResponse'];
        };
      };
    };
  };
  getEnrichedCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEnrichedCharacterRequest'];
      };
    };
    responses: {
      /** @description Character retrieved with requested includes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EnrichedCharacterResponse'];
        };
      };
      /** @description Character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCharacterArchive: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCharacterArchiveRequest'];
      };
    };
    responses: {
      /** @description Archive retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterArchive'];
        };
      };
      /** @description Archive not found (character may not be compressed yet) */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCharactersByRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCharactersByRealmRequest'];
      };
    };
    responses: {
      /** @description Characters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterListResponse'];
        };
      };
    };
  };
  getEncounterType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEncounterTypeRequest'];
      };
    };
    responses: {
      /** @description Encounter type retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterTypeResponse'];
        };
      };
      /** @description Encounter type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listEncounterTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListEncounterTypesRequest'];
      };
    };
    responses: {
      /** @description Encounter types retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterTypeListResponse'];
        };
      };
    };
  };
  queryByCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryByCharacterRequest'];
      };
    };
    responses: {
      /** @description Encounters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterListResponse'];
        };
      };
    };
  };
  queryBetween: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBetweenRequest'];
      };
    };
    responses: {
      /** @description Encounters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterListResponse'];
        };
      };
    };
  };
  queryByLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryByLocationRequest'];
      };
    };
    responses: {
      /** @description Encounters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterListResponse'];
        };
      };
    };
  };
  hasMet: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HasMetRequest'];
      };
    };
    responses: {
      /** @description Check completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HasMetResponse'];
        };
      };
    };
  };
  getSentiment: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSentimentRequest'];
      };
    };
    responses: {
      /** @description Sentiment calculated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SentimentResponse'];
        };
      };
    };
  };
  getPerspective: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetPerspectiveRequest'];
      };
    };
    responses: {
      /** @description Perspective retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PerspectiveResponse'];
        };
      };
      /** @description Perspective not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getParticipation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetParticipationRequest'];
      };
    };
    responses: {
      /** @description Participation records retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ParticipationListResponse'];
        };
      };
    };
  };
  getEventParticipants: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEventParticipantsRequest'];
      };
    };
    responses: {
      /** @description Participants retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ParticipationListResponse'];
        };
      };
    };
  };
  getBackstory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBackstoryRequest'];
      };
    };
    responses: {
      /** @description Backstory retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BackstoryResponse'];
        };
      };
      /** @description No backstory defined for this character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getPersonality: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetPersonalityRequest'];
      };
    };
    responses: {
      /** @description Personality retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PersonalityResponse'];
        };
      };
      /** @description No personality defined for this character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCombatPreferences: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCombatPreferencesRequest'];
      };
    };
    responses: {
      /** @description Combat preferences retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CombatPreferencesResponse'];
        };
      };
      /** @description No combat preferences defined for this character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getClientCapabilities: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetClientCapabilitiesRequest'];
      };
    };
    responses: {
      /** @description Client capabilities retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClientCapabilitiesResponse'];
        };
      };
      /** @description Not authenticated - requires valid session */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error retrieving capabilities */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryDocumentation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryDocumentationRequest'];
      };
    };
    responses: {
      /** @description Search results with voice-friendly summaries */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryDocumentationResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDocument: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetDocumentRequest'];
      };
    };
    responses: {
      /** @description Document content */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetDocumentResponse'];
        };
      };
      /** @description Document not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  searchDocumentation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SearchDocumentationRequest'];
      };
    };
    responses: {
      /** @description Matching documents */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SearchDocumentationResponse'];
        };
      };
    };
  };
  listDocuments: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListDocumentsRequest'];
      };
    };
    responses: {
      /** @description Document list */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListDocumentsResponse'];
        };
      };
    };
  };
  suggestRelatedTopics: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SuggestRelatedRequest'];
      };
    };
    responses: {
      /** @description Related topics */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SuggestRelatedResponse'];
        };
      };
    };
  };
  bindRepository: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BindRepositoryRequest'];
      };
    };
    responses: {
      /** @description Repository binding created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BindRepositoryResponse'];
        };
      };
      /** @description Invalid request (malformed URL, invalid branch) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Namespace already bound to a repository */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  syncRepository: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SyncRepositoryRequest'];
      };
    };
    responses: {
      /** @description Sync completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SyncRepositoryResponse'];
        };
      };
      /** @description No binding found for namespace */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Sync already in progress */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRepositoryStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RepositoryStatusRequest'];
      };
    };
    responses: {
      /** @description Repository binding status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RepositoryStatusResponse'];
        };
      };
      /** @description No binding found for namespace */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRepositoryBindings: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRepositoryBindingsRequest'];
      };
    };
    responses: {
      /** @description List of repository bindings */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListRepositoryBindingsResponse'];
        };
      };
    };
  };
  updateRepositoryBinding: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateRepositoryBindingRequest'];
      };
    };
    responses: {
      /** @description Repository binding updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateRepositoryBindingResponse'];
        };
      };
      /** @description No binding found for namespace */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createDocumentationArchive: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateArchiveRequest'];
      };
    };
    responses: {
      /** @description Archive created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateArchiveResponse'];
        };
      };
      /** @description Namespace not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listDocumentationArchives: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListArchivesRequest'];
      };
    };
    responses: {
      /** @description List of archives */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListArchivesResponse'];
        };
      };
    };
  };
  listServices: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListServicesRequest'];
      };
    };
    responses: {
      /** @description Services retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListServicesResponse'];
        };
      };
    };
  };
  getService: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetServiceRequest'];
      };
    };
    responses: {
      /** @description Service retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ServiceInfo'];
        };
      };
      /** @description Service not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getGameSession: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetGameSessionRequest'];
      };
    };
    responses: {
      /** @description Game session retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GameSessionResponse'];
        };
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  leaveGameSession: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveGameSessionRequest'];
      };
    };
    responses: {
      /** @description Successfully left game session */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  sendChatMessage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ChatMessageRequest'];
      };
    };
    responses: {
      /** @description Chat message sent successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  performGameAction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GameActionRequest'];
      };
    };
    responses: {
      /** @description Game action performed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GameActionResponse'];
        };
      };
      /** @description Invalid game action */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  leaveGameSessionById: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveGameSessionByIdRequest'];
      };
    };
    responses: {
      /** @description Successfully left game session */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found or player not in session */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createLeaderboardDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateLeaderboardDefinitionRequest'];
      };
    };
    responses: {
      /** @description Leaderboard created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeaderboardDefinitionResponse'];
        };
      };
      /** @description Leaderboard with this ID already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateLeaderboardDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateLeaderboardDefinitionRequest'];
      };
    };
    responses: {
      /** @description Leaderboard updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeaderboardDefinitionResponse'];
        };
      };
      /** @description Leaderboard not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteLeaderboardDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteLeaderboardDefinitionRequest'];
      };
    };
    responses: {
      /** @description Leaderboard deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Leaderboard not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getEntityRank: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEntityRankRequest'];
      };
    };
    responses: {
      /** @description Rank retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EntityRankResponse'];
        };
      };
      /** @description Entity not found on leaderboard */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTopRanks: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetTopRanksRequest'];
      };
    };
    responses: {
      /** @description Top ranks retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeaderboardEntriesResponse'];
        };
      };
    };
  };
  getRanksAround: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRanksAroundRequest'];
      };
    };
    responses: {
      /** @description Ranks retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeaderboardEntriesResponse'];
        };
      };
      /** @description Entity not found on leaderboard */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSeason: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSeasonRequest'];
      };
    };
    responses: {
      /** @description Season info retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeasonResponse'];
        };
      };
      /** @description Season not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationRequest'];
      };
    };
    responses: {
      /** @description Location retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getLocationByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationByCodeRequest'];
      };
    };
    responses: {
      /** @description Location retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listLocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListLocationsRequest'];
      };
    };
    responses: {
      /** @description Locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
    };
  };
  listLocationsByRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListLocationsByRealmRequest'];
      };
    };
    responses: {
      /** @description Locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
    };
  };
  listLocationsByParent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListLocationsByParentRequest'];
      };
    };
    responses: {
      /** @description Child locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
      /** @description Parent location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRootLocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRootLocationsRequest'];
      };
    };
    responses: {
      /** @description Root locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
    };
  };
  getLocationAncestors: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationAncestorsRequest'];
      };
    };
    responses: {
      /** @description Ancestors retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getLocationDescendants: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationDescendantsRequest'];
      };
    };
    responses: {
      /** @description Descendants retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  locationExists: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LocationExistsRequest'];
      };
    };
    responses: {
      /** @description Validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationExistsResponse'];
        };
      };
    };
  };
  requestSnapshot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RequestSnapshotRequest'];
      };
    };
    responses: {
      /** @description Snapshot returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RequestSnapshotResponse'];
        };
      };
      /** @description Region not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryPoint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryPointRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryPointResponse'];
        };
      };
    };
  };
  queryBounds: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBoundsRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryBoundsResponse'];
        };
      };
    };
  };
  queryObjectsByType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryObjectsByTypeRequest'];
      };
    };
    responses: {
      /** @description Matching objects */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryObjectsByTypeResponse'];
        };
      };
    };
  };
  queryAffordance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AffordanceQueryRequest'];
      };
    };
    responses: {
      /** @description Scored locations */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AffordanceQueryResponse'];
        };
      };
    };
  };
  checkoutForAuthoring: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthoringCheckoutRequest'];
      };
    };
    responses: {
      /** @description Checkout successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthoringCheckoutResponse'];
        };
      };
      /** @description Already checked out by another editor */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  commitAuthoring: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthoringCommitRequest'];
      };
    };
    responses: {
      /** @description Changes committed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthoringCommitResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  releaseAuthoring: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthoringReleaseRequest'];
      };
    };
    responses: {
      /** @description Checkout released */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthoringReleaseResponse'];
        };
      };
    };
  };
  createDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateDefinitionRequest'];
      };
    };
    responses: {
      /** @description Definition created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MapDefinition'];
        };
      };
      /** @description Definition with this name already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetDefinitionRequest'];
      };
    };
    responses: {
      /** @description Definition found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MapDefinition'];
        };
      };
      /** @description Definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listDefinitions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListDefinitionsRequest'];
      };
    };
    responses: {
      /** @description Definitions list */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListDefinitionsResponse'];
        };
      };
    };
  };
  updateDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateDefinitionRequest'];
      };
    };
    responses: {
      /** @description Definition updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MapDefinition'];
        };
      };
      /** @description Definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listQueues: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListQueuesRequest'];
      };
    };
    responses: {
      /** @description Queues retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListQueuesResponse'];
        };
      };
    };
  };
  getQueue: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetQueueRequest'];
      };
    };
    responses: {
      /** @description Queue details retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueueResponse'];
        };
      };
      /** @description Queue not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  joinMatchmaking: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['JoinMatchmakingRequest'];
      };
    };
    responses: {
      /** @description Successfully joined matchmaking queue */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['JoinMatchmakingResponse'];
        };
      };
      /** @description Invalid query syntax or properties */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Already in queue, queue limit reached, or exclusive group conflict */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  leaveMatchmaking: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveMatchmakingRequest'];
      };
    };
    responses: {
      /** @description Successfully left matchmaking queue */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Ticket not found or not in queue */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getMatchmakingStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetMatchmakingStatusRequest'];
      };
    };
    responses: {
      /** @description Status retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MatchmakingStatusResponse'];
        };
      };
      /** @description No active matchmaking ticket */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  acceptMatch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AcceptMatchRequest'];
      };
    };
    responses: {
      /** @description Match acceptance recorded */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AcceptMatchResponse'];
        };
      };
      /** @description No pending match or already processed */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  declineMatch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeclineMatchRequest'];
      };
    };
    responses: {
      /** @description Match declined */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description No pending match or already processed */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getMatchmakingStats: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetMatchmakingStatsRequest'];
      };
    };
    responses: {
      /** @description Statistics retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MatchmakingStatsResponse'];
        };
      };
    };
  };
  GenerateComposition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateCompositionRequest'];
      };
    };
    responses: {
      /** @description Composition generated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateCompositionResponse'];
        };
      };
      /** @description Invalid request or generation constraints */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Style not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ValidateMidiJson: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidateMidiJsonRequest'];
      };
    };
    responses: {
      /** @description Validation completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateMidiJsonResponse'];
        };
      };
    };
  };
  GetStyle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetStyleRequest'];
      };
    };
    responses: {
      /** @description Style retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StyleDefinitionResponse'];
        };
      };
      /** @description Style not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListStyles: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListStylesRequest'];
      };
    };
    responses: {
      /** @description Styles listed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListStylesResponse'];
        };
      };
    };
  };
  GenerateProgression: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateProgressionRequest'];
      };
    };
    responses: {
      /** @description Progression generated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateProgressionResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GenerateMelody: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateMelodyRequest'];
      };
    };
    responses: {
      /** @description Melody generated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateMelodyResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ApplyVoiceLeading: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VoiceLeadRequest'];
      };
    };
    responses: {
      /** @description Voice leading applied successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VoiceLeadResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmRequest'];
      };
    };
    responses: {
      /** @description Realm retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmResponse'];
        };
      };
      /** @description Realm not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRealmByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmByCodeRequest'];
      };
    };
    responses: {
      /** @description Realm retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmResponse'];
        };
      };
      /** @description Realm not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRealms: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRealmsRequest'];
      };
    };
    responses: {
      /** @description Realms retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmListResponse'];
        };
      };
    };
  };
  realmExists: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RealmExistsRequest'];
      };
    };
    responses: {
      /** @description Validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmExistsResponse'];
        };
      };
    };
  };
  getRealmParticipation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmParticipationRequest'];
      };
    };
    responses: {
      /** @description Participation records retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmParticipationListResponse'];
        };
      };
    };
  };
  getRealmEventParticipants: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmEventParticipantsRequest'];
      };
    };
    responses: {
      /** @description Participants retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmParticipationListResponse'];
        };
      };
    };
  };
  getRealmLore: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmLoreRequest'];
      };
    };
    responses: {
      /** @description Lore retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmLoreResponse'];
        };
      };
      /** @description No lore defined for this realm */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRelationship: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipRequest'];
      };
    };
    responses: {
      /** @description Relationship retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipResponse'];
        };
      };
      /** @description Relationship not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRelationshipsByEntity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRelationshipsByEntityRequest'];
      };
    };
    responses: {
      /** @description Relationships retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipListResponse'];
        };
      };
    };
  };
  getRelationshipsBetween: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipsBetweenRequest'];
      };
    };
    responses: {
      /** @description Relationships retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipListResponse'];
        };
      };
    };
  };
  listRelationshipsByType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRelationshipsByTypeRequest'];
      };
    };
    responses: {
      /** @description Relationships retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipListResponse'];
        };
      };
    };
  };
  getRelationshipType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipTypeRequest'];
      };
    };
    responses: {
      /** @description Relationship type retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeResponse'];
        };
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRelationshipTypeByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipTypeByCodeRequest'];
      };
    };
    responses: {
      /** @description Relationship type retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeResponse'];
        };
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRelationshipTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRelationshipTypesRequest'];
      };
    };
    responses: {
      /** @description Relationship types retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeListResponse'];
        };
      };
    };
  };
  getChildRelationshipTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetChildRelationshipTypesRequest'];
      };
    };
    responses: {
      /** @description Child relationship types retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeListResponse'];
        };
      };
      /** @description Parent relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  matchesHierarchy: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MatchesHierarchyRequest'];
      };
    };
    responses: {
      /** @description Hierarchy match result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MatchesHierarchyResponse'];
        };
      };
      /** @description One or both relationship types not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAncestors: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAncestorsRequest'];
      };
    };
    responses: {
      /** @description Ancestors retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeListResponse'];
        };
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSlotRequest'];
      };
    };
    responses: {
      /** @description Slot created or updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SlotResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Slot already exists with different owner */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSlotRequest'];
      };
    };
    responses: {
      /** @description Slot found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SlotResponse'];
        };
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListSlots: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSlotsRequest'];
      };
    };
    responses: {
      /** @description Slots listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListSlotsResponse'];
        };
      };
    };
  };
  DeleteSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteSlotRequest'];
      };
    };
    responses: {
      /** @description Slot deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteSlotResponse'];
        };
      };
      /** @description Not authorized to delete this slot */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  RenameSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RenameSlotRequest'];
      };
    };
    responses: {
      /** @description Slot renamed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SlotResponse'];
        };
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Target name already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  Save: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SaveRequest'];
      };
    };
    responses: {
      /** @description Save successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Invalid request or data validation failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to save to this slot */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Save data exceeds maximum size limit */
      413: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  Load: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LoadRequest'];
      };
    };
    responses: {
      /** @description Load successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LoadResponse'];
        };
      };
      /** @description Not authorized to load from this slot */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  SaveDelta: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SaveDeltaRequest'];
      };
    };
    responses: {
      /** @description Delta save successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveDeltaResponse'];
        };
      };
      /** @description Invalid delta or base version not found */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Base version has been deleted (cannot apply delta) */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Delta too large (consider full save instead) */
      413: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  LoadWithDeltas: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LoadRequest'];
      };
    };
    responses: {
      /** @description Load successful (reconstructed if delta) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LoadResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Delta chain broken (base version missing) */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CollapseDeltas: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CollapseDeltasRequest'];
      };
    };
    responses: {
      /** @description Delta chain collapsed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListVersions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListVersionsRequest'];
      };
    };
    responses: {
      /** @description Versions listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListVersionsResponse'];
        };
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PinVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PinVersionRequest'];
      };
    };
    responses: {
      /** @description Version pinned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VersionResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UnpinVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnpinVersionRequest'];
      };
    };
    responses: {
      /** @description Version unpinned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VersionResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteVersionRequest'];
      };
    };
    responses: {
      /** @description Version deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteVersionResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cannot delete pinned version */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  QuerySaves: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QuerySavesRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QuerySavesResponse'];
        };
      };
    };
  };
  CopySave: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CopySaveRequest'];
      };
    };
    responses: {
      /** @description Save copied */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Not authorized to copy to target */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Source slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ExportSaves: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExportSavesRequest'];
      };
    };
    responses: {
      /** @description Export prepared */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExportSavesResponse'];
        };
      };
    };
  };
  VerifyIntegrity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VerifyIntegrityRequest'];
      };
    };
    responses: {
      /** @description Verification result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifyIntegrityResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PromoteVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PromoteVersionRequest'];
      };
    };
    responses: {
      /** @description Version promoted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  MigrateSave: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MigrateSaveRequest'];
      };
    };
    responses: {
      /** @description Migration successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MigrateSaveResponse'];
        };
      };
      /** @description Migration failed or no path exists */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Save not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  RegisterSchema: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterSchemaRequest'];
      };
    };
    responses: {
      /** @description Schema registered */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SchemaResponse'];
        };
      };
    };
  };
  ListSchemas: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSchemasRequest'];
      };
    };
    responses: {
      /** @description Schemas listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListSchemasResponse'];
        };
      };
    };
  };
  createScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSceneRequest'];
      };
    };
    responses: {
      /** @description Scene created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SceneResponse'];
        };
      };
      /** @description Invalid scene structure (validation failed) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene with this sceneId already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSceneRequest'];
      };
    };
    responses: {
      /** @description Scene retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetSceneResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listScenes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListScenesRequest'];
      };
    };
    responses: {
      /** @description Scenes listed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListScenesResponse'];
        };
      };
    };
  };
  updateScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateSceneRequest'];
      };
    };
    responses: {
      /** @description Scene updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SceneResponse'];
        };
      };
      /** @description Invalid scene structure */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene is checked out by another user */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteSceneRequest'];
      };
    };
    responses: {
      /** @description Scene deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteSceneResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cannot delete - other scenes reference this scene */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  validateScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidateSceneRequest'];
      };
    };
    responses: {
      /** @description Validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidationResult'];
        };
      };
    };
  };
  checkoutScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckoutRequest'];
      };
    };
    responses: {
      /** @description Checkout successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CheckoutResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene already checked out by another user */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  commitScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CommitRequest'];
      };
    };
    responses: {
      /** @description Commit successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CommitResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Checkout expired */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  discardCheckout: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DiscardRequest'];
      };
    };
    responses: {
      /** @description Discard successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DiscardResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  heartbeatCheckout: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HeartbeatRequest'];
      };
    };
    responses: {
      /** @description Lock extended */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HeartbeatResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Checkout expired */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSceneHistory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HistoryRequest'];
      };
    };
    responses: {
      /** @description History retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HistoryResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getValidationRules: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetValidationRulesRequest'];
      };
    };
    responses: {
      /** @description Rules retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetValidationRulesResponse'];
        };
      };
    };
  };
  searchScenes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SearchScenesRequest'];
      };
    };
    responses: {
      /** @description Search results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SearchScenesResponse'];
        };
      };
    };
  };
  findReferences: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FindReferencesRequest'];
      };
    };
    responses: {
      /** @description Referencing scenes found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FindReferencesResponse'];
        };
      };
    };
  };
  findAssetUsage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FindAssetUsageRequest'];
      };
    };
    responses: {
      /** @description Asset usage found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FindAssetUsageResponse'];
        };
      };
    };
  };
  duplicateScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DuplicateSceneRequest'];
      };
    };
    responses: {
      /** @description Scene duplicated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SceneResponse'];
        };
      };
      /** @description Source scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSpecies: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSpeciesRequest'];
      };
    };
    responses: {
      /** @description Species retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SpeciesResponse'];
        };
      };
      /** @description Species not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSpeciesByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSpeciesByCodeRequest'];
      };
    };
    responses: {
      /** @description Species retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SpeciesResponse'];
        };
      };
      /** @description Species not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listSpecies: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSpeciesRequest'];
      };
    };
    responses: {
      /** @description Species retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SpeciesListResponse'];
        };
      };
    };
  };
  listSpeciesByRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSpeciesByRealmRequest'];
      };
    };
    responses: {
      /** @description Species retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SpeciesListResponse'];
        };
      };
      /** @description Realm not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAccountSubscriptions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAccountSubscriptionsRequest'];
      };
    };
    responses: {
      /** @description Subscriptions retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SubscriptionListResponse'];
        };
      };
    };
  };
  getSubscription: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSubscriptionRequest'];
      };
    };
    responses: {
      /** @description Subscription retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SubscriptionInfo'];
        };
      };
      /** @description Subscription not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cancelSubscription: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CancelSubscriptionRequest'];
      };
    };
    responses: {
      /** @description Subscription cancelled successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SubscriptionInfo'];
        };
      };
      /** @description Not authorized to cancel this subscription */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Subscription not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  answerPeer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AnswerPeerRequest'];
      };
    };
    responses: {
      /** @description SDP answer processed, peer notified */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not in voice:ringing state (no pending offers) */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Peer or room not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Website service status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StatusResponse'];
        };
      };
    };
  };
  getPageContent: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Page slug identifier */
        slug: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Page content retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PageContent'];
        };
      };
      /** @description Page not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  getNews: {
    parameters: {
      query?: {
        /** @description Number of news items to return */
        limit?: number;
        /** @description Pagination offset */
        offset?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description News items retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['NewsResponse'];
        };
      };
    };
  };
  getServerStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Server status information */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ServerStatusResponse'];
        };
      };
    };
  };
  getDownloads: {
    parameters: {
      query?: {
        /** @description Filter by platform */
        platform?: 'windows' | 'macos' | 'linux';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Download links retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DownloadsResponse'];
        };
      };
    };
  };
  submitContact: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ContactRequest'];
      };
    };
    responses: {
      /** @description Contact form submitted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContactResponse'];
        };
      };
      /** @description Invalid form data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  getAccountProfile: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Account profile retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AccountProfile'];
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  getAccountCharacters: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Character list retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterListResponse'];
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  listPages: {
    parameters: {
      query?: {
        includeUnpublished?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Page list retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PageMetadata'][];
        };
      };
    };
  };
  createPage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PageContent'];
      };
    };
    responses: {
      /** @description Page created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PageContent'];
        };
      };
    };
  };
  updatePage: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        slug: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PageContent'];
      };
    };
    responses: {
      /** @description Page updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PageContent'];
        };
      };
    };
  };
  deletePage: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        slug: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Page deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSiteSettings: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Site settings retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SiteSettings'];
        };
      };
    };
  };
  updateSiteSettings: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SiteSettings'];
      };
    };
    responses: {
      /** @description Settings updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SiteSettings'];
        };
      };
    };
  };
  getTheme: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Theme configuration retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ThemeConfig'];
        };
      };
    };
  };
  updateTheme: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ThemeConfig'];
      };
    };
    responses: {
      /** @description Theme updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSubscription: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Subscription information retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SubscriptionResponse'];
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
}
