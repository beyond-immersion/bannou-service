/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/account/profile/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update account profile */
    post: operations['updateProfile'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/account/password/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update account password hash */
    post: operations['updatePasswordHash'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/account/verification/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update email verification status */
    post: operations['updateVerificationStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/definition/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new achievement definition
     * @description Create a new achievement with specified criteria and platform mappings.
     *     Developer-only endpoint.
     */
    post: operations['createAchievementDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/definition/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List achievement definitions
     * @description List achievements for a game service with optional platform filtering.
     */
    post: operations['listAchievementDefinitions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/definition/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update achievement definition
     * @description Update properties of an existing achievement.
     *     Developer-only endpoint.
     */
    post: operations['updateAchievementDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/definition/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete achievement definition
     * @description Delete an achievement. Earned instances are preserved in history.
     *     Developer-only endpoint.
     */
    post: operations['deleteAchievementDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/progress/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get entity's achievement progress
     * @description Get progress for an entity across all achievements or a specific one.
     */
    post: operations['getAchievementProgress'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/achievement/list-unlocked': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List unlocked achievements
     * @description Get all achievements unlocked by an entity.
     */
    post: operations['listUnlockedAchievements'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/template/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create an actor template (category definition) */
    post: operations['CreateActorTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/template/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update an actor template */
    post: operations['UpdateActorTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/template/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Delete an actor template */
    post: operations['DeleteActorTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/spawn': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Spawn a new actor from a template */
    post: operations['SpawnActor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Stop a running actor */
    post: operations['StopActor'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/inject-perception': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Inject a perception event into an actor's queue (testing)
     * @description Injects a perception event directly into the actor's perception queue
     *     for testing purposes. Useful for testing actor behavior without a
     *     full game server setup.
     */
    post: operations['InjectPerception'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/encounter/start': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Start an encounter managed by an Event Brain actor
     * @description Initializes an encounter with the specified participants. The Event Brain actor
     *     will coordinate the encounter, sending instructions to participant NPC Brain actors
     *     via their character perception channels.
     */
    post: operations['StartEncounter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/encounter/update-phase': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update the phase of an active encounter
     * @description Updates the phase of an encounter being managed by an Event Brain actor.
     *     Phase changes are logged and can trigger behavior changes in participant actors.
     */
    post: operations['UpdateEncounterPhase'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actor/encounter/end': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * End an active encounter
     * @description Ends an encounter being managed by an Event Brain actor. This clears the
     *     encounter state and allows the actor to manage a new encounter.
     */
    post: operations['EndEncounter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/upload/request': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request upload URL for a new asset
     * @description Generate a pre-signed URL for uploading a new asset directly to storage.
     *     For large files (>50MB), returns multipart upload configuration.
     */
    post: operations['requestUpload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/upload/complete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Mark upload as complete, trigger processing
     * @description Called after the client has uploaded the file to the pre-signed URL.
     *     Triggers the asset processing pipeline (texture conversion, model validation, etc.)
     *     and emits completion events via WebSocket.
     */
    post: operations['completeUpload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get asset metadata and download URL
     * @description Retrieve asset metadata and generate a pre-signed download URL.
     *     Specify version to download a specific version, or omit for latest.
     */
    post: operations['getAsset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/list-versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all versions of an asset
     * @description Retrieve version history for an asset with pagination.
     *     Includes version IDs, creation timestamps, and archive status.
     */
    post: operations['listAssetVersions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Search assets by tags, type, or realm
     * @description Search assets using various filters with pagination.
     *     All filters are optional and combine with AND logic.
     */
    post: operations['searchAssets'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create asset bundle from multiple assets
     * @description Create a .bannou bundle containing multiple assets.
     *     For large bundles, processing is delegated to the processing pool.
     *     Completion notification sent via WebSocket event.
     */
    post: operations['createBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get bundle manifest and download URL
     * @description Retrieve bundle metadata and generate a pre-signed download URL.
     *     Supports both native .bannou format and ZIP conversion (cached).
     */
    post: operations['getBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/upload/request': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request upload URL for a pre-made bundle
     * @description Upload a pre-built bundle (.bannou or .zip format).
     *     After upload, the bundle undergoes validation before registration.
     */
    post: operations['requestBundleUpload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/metabundle/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create metabundle from source bundles
     * @description Compose a metabundle by extracting and repackaging assets from multiple
     *     source bundles. The resulting metabundle is a complete physical copy with
     *     provenance metadata tracking the source bundles.
     *
     *     Assets are deduplicated by content hash. If the same asset ID exists in
     *     multiple source bundles with different content hashes, the request fails
     *     with conflict details.
     */
    post: operations['createMetabundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/job/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get async metabundle job status
     * @description Poll the status of an async metabundle creation job.
     *     Use the jobId returned from createMetabundle when status was 'queued'.
     *
     *     Clients can either poll this endpoint or wait for the
     *     MetabundleCreationCompleteEvent via WebSocket for completion notification.
     */
    post: operations['getJobStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/job/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel an async metabundle job
     * @description Cancel a pending or processing metabundle creation job.
     *     Jobs that are already completed (ready or failed) cannot be cancelled.
     *
     *     Successfully cancelled jobs will emit a MetabundleCreationCompleteEvent
     *     with status 'cancelled' via WebSocket.
     */
    post: operations['cancelJob'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/resolve': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Compute optimal bundles for requested assets
     * @description Given a list of asset IDs, compute the optimal set of bundles to download
     *     to obtain all requested assets with minimal transfers.
     *
     *     The algorithm uses greedy set-cover optimization:
     *     1. Find all bundles containing requested assets
     *     2. Select bundles that cover the most uncovered assets
     *     3. Prefer metabundles when coverage is equal (tie-breaker)
     *     4. Include standalone assets for any remaining unresolved IDs
     *
     *     Returns pre-signed download URLs for all selected bundles and assets.
     */
    post: operations['resolveBundles'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/query/by-asset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find all bundles containing a specific asset
     * @description Query the reverse index to find all bundles (source and metabundle)
     *     that contain a specific asset ID. Useful for understanding asset
     *     distribution and debugging resolution issues.
     */
    post: operations['queryBundlesByAsset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update bundle metadata
     * @description Update metadata for an existing bundle (name, description, tags).
     *     Does not modify bundle contents - for that, create a new bundle.
     *
     *     Increments the bundle version and records the change in version history.
     *     Only the bundle owner or admin can update.
     */
    post: operations['updateBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Soft-delete a bundle
     * @description Soft-delete a bundle, marking it as deleted but retaining data
     *     for the configured retention period (default 30 days).
     *
     *     Deleted bundles are excluded from resolution and queries by default.
     *     Use permanent=true for immediate, unrecoverable deletion (admin only).
     *
     *     Only the bundle owner or admin can delete.
     */
    post: operations['deleteBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/restore': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Restore a soft-deleted bundle
     * @description Restore a bundle that was soft-deleted, making it active again.
     *     Can only restore bundles within their retention period.
     *
     *     Only the bundle owner or admin can restore.
     */
    post: operations['restoreBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query bundles with advanced filters
     * @description Query bundles with flexible filtering options including:
     *     - Tag matching (exact, exists, not exists)
     *     - Status filtering (active, deleted)
     *     - Date range filtering
     *     - Name search (contains)
     *     - Owner filtering
     *     - Realm and bundle type filtering
     *
     *     Supports pagination and sorting.
     */
    post: operations['queryBundles'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/list-versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List version history for a bundle
     * @description Get the version history for a bundle, showing all metadata changes
     *     over time. Each version record includes:
     *     - Version number
     *     - When the change was made
     *     - Who made the change
     *     - What changed
     *     - Optional reason for the change
     *
     *     The current version's full metadata snapshot is always included.
     */
    post: operations['listBundleVersions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/bulk-get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Batch asset metadata lookup
     * @description Retrieve metadata for multiple assets in a single request.
     *     Optionally includes pre-signed download URLs.
     *     Maximum 100 asset IDs per request.
     */
    post: operations['bulkGetAssets'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/login': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Login with email/password */
    post: operations['login'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/register': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Register new user account */
    post: operations['register'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/oauth/{provider}/init': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Initialize OAuth2 flow (browser redirect)
     * @description Browser-facing endpoint for initiating OAuth flows. The user's browser navigates
     *     to this URL directly, which then redirects to the OAuth provider.
     *
     *     **Note**: This endpoint uses GET with path parameters because it's a browser
     *     redirect flow, not a WebSocket-routed API call.
     */
    get: operations['initOAuth'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/oauth/{provider}/callback': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Complete OAuth2 flow (browser redirect callback)
     * @description Browser-facing callback endpoint for OAuth providers. The OAuth provider redirects
     *     the user's browser back to this URL after authentication.
     *
     *     **Note**: This endpoint uses path parameters because the callback URL is registered
     *     with OAuth providers and cannot be changed without updating provider configurations.
     */
    post: operations['completeOAuth'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/steam/verify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Verify Steam Session Ticket
     * @description Validates a Steam Session Ticket obtained from the game client via ISteamUser::GetAuthTicketForWebApi().
     *     The server validates the ticket with Steam's Web API and retrieves the SteamID from Steam's response.
     *     NEVER trust client-provided SteamID - it must come from Steam's authenticated response.
     */
    post: operations['verifySteamAuth'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/refresh': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Refresh access token */
    post: operations['refreshToken'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Validate access token */
    post: operations['validateToken'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/logout': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Logout and invalidate tokens */
    post: operations['logout'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/sessions/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get active sessions for account */
    post: operations['getSessions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/sessions/terminate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Terminate specific session */
    post: operations['terminateSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/password/reset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Request password reset */
    post: operations['requestPasswordReset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/password/confirm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Confirm password reset with token */
    post: operations['confirmPasswordReset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/auth/providers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List available authentication providers
     * @description Returns a list of available OAuth and authentication providers based on server configuration.
     *     Providers are only listed if their client credentials are configured.
     *     Steam authentication uses session tickets, not OAuth, but is included for completeness.
     */
    post: operations['listProviders'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/compile': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Compile ABML behavior definition
     * @description Compiles a YAML-based ABML behavior definition into executable behavior trees.
     *     Handles stackable behavior sets, cultural adaptations, and context variable resolution.
     */
    post: operations['CompileAbmlBehavior'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate ABML definition
     * @description Validates ABML YAML against schema and checks for semantic correctness.
     *     Includes context variable validation and service dependency checking.
     */
    post: operations['ValidateAbml'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cache/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get cached compiled behavior
     * @description Retrieves a previously compiled behavior from the cache.
     *     Used for performance optimization in high-frequency behavior execution.
     */
    post: operations['GetCachedBehavior'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cache/invalidate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Invalidate cached behavior
     * @description Removes a behavior from the cache, forcing recompilation on next access.
     *     Used when behavior definitions are updated.
     */
    post: operations['InvalidateCachedBehavior'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/goap/plan': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate GOAP plan
     * @description Generates a GOAP plan to achieve a goal from the current world state.
     *     Uses A* search to find the optimal sequence of actions.
     */
    post: operations['GenerateGoapPlan'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/goap/validate-plan': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate existing GOAP plan
     * @description Validates an existing GOAP plan against the current world state.
     *     Returns whether the plan is still valid or needs replanning.
     */
    post: operations['ValidateGoapPlan'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get character by ID */
    post: operations['getCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** List characters with filtering */
    post: operations['listCharacters'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/get-enriched': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get character with optional related data (personality, backstory, family)
     * @description Retrieves a character with optional include flags for related data.
     *     Use this endpoint when you need aggregated character data from multiple services.
     *     Each included dataset is fetched from its respective service.
     */
    post: operations['getEnrichedCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/get-archive': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get compressed archive data for a character */
    post: operations['getCharacterArchive'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character/by-realm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get all characters in a realm (primary query pattern) */
    post: operations['getCharactersByRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/type/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get encounter type by code
     * @description Retrieve an encounter type by its unique code.
     */
    post: operations['getEncounterType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/type/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all encounter types
     * @description Retrieve all encounter types including built-in and custom types.
     */
    post: operations['listEncounterTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/query/by-character': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get character's encounters (paginated)
     * @description Retrieves all encounters for a character with optional filtering.
     *     Memory decay is applied lazily on access.
     */
    post: operations['queryByCharacter'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/query/between': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get encounters between two characters
     * @description Retrieves all encounters between two specific characters.
     *     Useful for relationship history and dialogue context.
     */
    post: operations['queryBetween'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/query/by-location': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Recent encounters at location
     * @description Retrieves recent encounters at a specific location.
     *     Useful for scene context and area history.
     */
    post: operations['queryByLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/has-met': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Quick check if two characters have met
     * @description Fast boolean check for whether two characters have any recorded encounters.
     *     Does not apply memory decay or return encounter details.
     */
    post: operations['hasMet'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/get-sentiment': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Aggregate sentiment toward another character
     * @description Calculates the aggregate sentiment a character has toward another based
     *     on all their encounters. Memory strength is factored into the calculation.
     */
    post: operations['getSentiment'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-encounter/get-perspective': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get character's view of encounter
     * @description Retrieves a specific character's perspective on an encounter.
     *     Includes emotional impact, sentiment shift, and memory strength.
     */
    post: operations['getPerspective'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-history/get-participation': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all historical events a character participated in
     * @description Retrieves all historical event participation records for a character.
     *     Supports filtering by event category and minimum significance.
     */
    post: operations['getParticipation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-history/get-event-participants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all characters who participated in a historical event
     * @description Retrieves all characters who participated in a specific historical event.
     *     Useful for generating event summaries or finding related characters.
     */
    post: operations['getEventParticipants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-history/get-backstory': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get machine-readable backstory elements for behavior system
     * @description Retrieves structured backstory elements for a character. These elements
     *     are machine-readable key-value pairs used by the behavior system for
     *     decision-making, not narrative text for players.
     */
    post: operations['getBackstory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-personality/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get personality for a character
     * @description Retrieves the personality profile for a character. Returns 404 if no
     *     personality has been defined for this character.
     */
    post: operations['getPersonality'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/character-personality/get-combat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get combat preferences for a character
     * @description Retrieves the combat preferences for a character. Combat preferences
     *     influence tactical decisions in the behavior system, including engagement
     *     style, positioning, and retreat conditions.
     */
    post: operations['getCombatPreferences'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/client-capabilities': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get client capability manifest (GUID â†’ API mappings)
     * @description Returns the capability manifest for the authenticated client's session.
     *     Maps client-salted GUIDs to available API endpoints based on the client's
     *     current permissions and session state.
     *
     *     **Security**: Each client receives unique GUIDs for the same API endpoints.
     *     This prevents cross-session exploitation and enables per-client rate limiting.
     *
     *     **Dynamic Updates**: Capabilities may change during a session when:
     *     - Role changes occur (admin promotion, etc.)
     *     - Subscription status changes
     *     - Session state transitions
     *
     *     Clients should listen for capability update events via WebSocket to stay current.
     */
    post: operations['getClientCapabilities'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/template/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get template by ID or code
     * @description Retrieves a contract template by its unique ID or code.
     *     At least one of templateId or code must be provided.
     */
    post: operations['getContractTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/template/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List templates with filters
     * @description Lists contract templates with optional filtering by realm, active status,
     *     and search term.
     */
    post: operations['listContractTemplates'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create contract instance from template
     * @description Creates a new contract instance from a template. The instance starts
     *     in 'draft' status and must be proposed to parties before activation.
     */
    post: operations['createContractInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/propose': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Propose contract to parties (starts consent flow)
     * @description Moves a draft contract to 'proposed' status and notifies parties.
     *     Parties must consent before the contract becomes active.
     */
    post: operations['proposeContractInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/consent': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Party consents to contract
     * @description Records a party's consent to a proposed contract. When all required
     *     parties consent, the contract moves to 'accepted' then 'active' status.
     */
    post: operations['consentToContract'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get instance by ID
     * @description Retrieves a contract instance by its unique ID.
     */
    post: operations['getContractInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query instances by party, template, status
     * @description Queries contract instances with various filters. At least one filter
     *     must be provided.
     */
    post: operations['queryContractInstances'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/terminate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request early termination
     * @description Requests early termination of an active contract. Depending on the
     *     contract's termination policy, this may require mutual consent or
     *     incur penalties.
     */
    post: operations['terminateContractInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/get-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current status and milestone progress
     * @description Gets the current status of a contract including milestone progress,
     *     pending consents, and any active breaches.
     */
    post: operations['getContractInstanceStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/milestone/complete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * External system reports milestone completed
     * @description Called by external systems to report that a milestone's conditions
     *     have been met. Triggers onComplete prebound APIs and may advance
     *     contract status.
     */
    post: operations['completeMilestone'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/milestone/fail': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * External system reports milestone failed
     * @description Called by external systems to report that a milestone has failed
     *     (e.g., deadline passed, conditions cannot be met). Triggers onExpire
     *     prebound APIs and may record a breach.
     */
    post: operations['failMilestone'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/milestone/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get milestone details and status
     * @description Gets the current state of a specific milestone.
     */
    post: operations['getMilestone'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/breach/report': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Report a contract breach
     * @description Reports a breach of contract terms. This can be called by parties
     *     or external systems. The breach enters a grace period for cure
     *     if configured.
     */
    post: operations['reportBreach'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/breach/cure': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Mark breach as cured (system/admin action)
     * @description Marks a breach as cured within the grace period. This prevents
     *     consequences from being applied. Called by systems that verify
     *     the breach has been remedied.
     */
    post: operations['cureBreach'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/breach/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get breach details
     * @description Retrieves details of a specific breach record.
     */
    post: operations['getBreach'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/metadata/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update game metadata on instance
     * @description Updates game-specific metadata on a contract instance without
     *     touching contract state. Used by higher-level systems (quests, etc.)
     *     to store additional context.
     */
    post: operations['updateContractMetadata'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/metadata/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get game metadata
     * @description Retrieves game-specific metadata from a contract instance.
     */
    post: operations['getContractMetadata'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/check-constraint': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if entity can take action given contracts
     * @description Checks whether an entity's proposed action would violate any
     *     active contract constraints (exclusivity, non-compete, territory, etc.).
     */
    post: operations['checkContractConstraint'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/query-active': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query active contracts for entity
     * @description Returns all active contracts where the specified entity is a party.
     *     Useful for displaying current obligations in UI.
     */
    post: operations['queryActiveContracts'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/lock': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Lock contract under guardian custody
     * @description Locks a contract under guardian custody (e.g., escrow). A locked contract
     *     cannot be modified, terminated, or have parties transferred except by the
     *     guardian. Requires the contract template to have `transferable: true`.
     */
    post: operations['lockContract'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/unlock': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Unlock contract from guardian custody
     * @description Unlocks a contract from guardian custody. Only the current guardian can
     *     unlock a contract. Called on escrow refund to restore contract to original state.
     */
    post: operations['unlockContract'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/transfer-party': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Transfer party role to new entity
     * @description Transfers a party role to a new entity. Used by escrow to reassign contract
     *     roles on release (e.g., transfer landlord role to new property owner).
     *     Contract must be locked and caller must be the guardian.
     */
    post: operations['transferContractParty'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/clause-type/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all registered clause types
     * @description Lists all registered clause types including built-in types and
     *     custom-registered types.
     */
    post: operations['listClauseTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/set-template-values': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Set template values on contract instance
     * @description Sets template values on a contract instance. Called by escrow when binding
     *     a contract to an escrow agreement. Template values are used for variable
     *     substitution in clause handlers (e.g., wallet IDs, container IDs).
     */
    post: operations['setContractTemplateValues'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/check-asset-requirements': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if asset requirement clauses are satisfied
     * @description Checks if all asset requirement clauses are satisfied. Uses template values
     *     (e.g., PartyA_EscrowWalletId) to query actual balances in escrow wallets/containers
     *     via the registered clause type handlers.
     */
    post: operations['checkAssetRequirements'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/contract/instance/execute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Execute all contract clauses (idempotent)
     * @description Executes all contract distribution clauses - distribute assets per clauses,
     *     collect fees, mark contract as executed. This is idempotent - calling twice
     *     returns the same result without re-executing. Contract must be in fulfilled
     *     status and all template values must be set.
     */
    post: operations['executeContract'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/definition/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get currency definition by ID or code
     * @description Retrieves a currency definition by its unique ID or code.
     *     At least one of definitionId or code must be provided.
     */
    post: operations['getCurrencyDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/definition/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List currency definitions with filters
     * @description Lists currency definitions with optional filtering by realm, scope,
     *     active status, and base currency flag.
     */
    post: operations['listCurrencyDefinitions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/wallet/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new wallet for an owner
     * @description Creates a new wallet for a polymorphic owner (account, character, NPC, guild, etc.).
     *     Each owner+ownerType+realm combination can have at most one wallet.
     */
    post: operations['createWallet'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/wallet/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get wallet by ID or owner
     * @description Retrieves a wallet by its ID, or by owner+ownerType+realm combination.
     *     Returns the wallet with all non-zero balances.
     */
    post: operations['getWallet'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/wallet/get-or-create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get existing wallet or create if not exists
     * @description Retrieves a wallet if it exists, otherwise creates a new one.
     *     Upsert pattern for convenience.
     */
    post: operations['getOrCreateWallet'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/balance/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get balance for a specific currency in a wallet
     * @description Retrieves the current balance for a specific currency in a wallet.
     *     In lazy autogain mode, this may trigger autogain calculation and emit events.
     *     Returns earn cap info and autogain info when applicable.
     */
    post: operations['getBalance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/balance/batch-get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get multiple balances in one call
     * @description Retrieves balances for multiple wallet+currency combinations.
     *     Autogain is applied where applicable.
     */
    post: operations['batchGetBalances'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/credit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Credit currency to a wallet (faucet operation)
     * @description Credits currency to a wallet. This is a faucet operation (currency enters the system).
     *     Enforces earn caps, wallet caps, and global supply caps. Requires idempotency key.
     */
    post: operations['creditCurrency'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/debit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Debit currency from a wallet (sink operation)
     * @description Debits currency from a wallet. This is a sink operation (currency exits the system).
     *     Checks for sufficient funds unless negative balance is allowed.
     */
    post: operations['debitCurrency'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/transfer': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Transfer currency between wallets
     * @description Transfers currency from one wallet to another. Validates transferability,
     *     realm compatibility, and sufficient funds.
     */
    post: operations['transferCurrency'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/batch-credit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Credit multiple wallets in one call
     * @description Credits currency to multiple wallets in one call. Each operation is independent;
     *     failures do not rollback others. For atomic multi-wallet operations, use lib-escrow.
     */
    post: operations['batchCreditCurrency'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/convert/calculate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Calculate conversion without executing
     * @description Previews a currency conversion calculation without executing it.
     *     Uses base currency exchange rates to compute the effective rate.
     */
    post: operations['calculateConversion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/convert/execute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Execute currency conversion in a wallet
     * @description Executes a currency conversion within a single wallet. Debits the source
     *     currency and credits the target currency at the computed exchange rate.
     */
    post: operations['executeConversion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/exchange-rate/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get exchange rate between two currencies
     * @description Retrieves the exchange rate between two currencies using the base currency
     *     as an intermediary.
     */
    post: operations['getExchangeRate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/transaction/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a transaction by ID
     * @description Retrieves a single transaction record by its unique ID.
     */
    post: operations['getTransaction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/transaction/history': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get paginated transaction history for a wallet
     * @description Retrieves transaction history for a wallet with optional filters
     *     by currency, transaction type, and date range.
     */
    post: operations['getTransactionHistory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/transaction/by-reference': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get transactions by reference type and ID
     * @description Retrieves all transactions linked to a specific reference (quest, auction,
     *     escrow, etc.).
     */
    post: operations['getTransactionsByReference'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/stats/global-supply': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get global supply statistics for a currency
     * @description Returns aggregate supply statistics including total supply, circulation,
     *     escrow amounts, and lifetime mint/burn totals.
     */
    post: operations['getGlobalSupply'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/escrow/deposit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Debit wallet for escrow deposit
     * @description Called by lib-escrow when a party deposits currency into an escrow agreement.
     *     Immediately debits the wallet (no lock tracking needed - escrow owns the funds).
     */
    post: operations['escrowDeposit'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/escrow/release': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Credit recipient on escrow completion
     * @description Called by lib-escrow when an escrow agreement completes successfully.
     *     Credits the recipient wallet with the released funds.
     */
    post: operations['escrowRelease'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/escrow/refund': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Credit depositor on escrow refund
     * @description Called by lib-escrow when an escrow agreement is cancelled or refunded.
     *     Credits the original depositor wallet with the refunded funds.
     */
    post: operations['escrowRefund'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/hold/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create an authorization hold (reserve funds)
     * @description Creates an authorization hold that reserves funds without debiting.
     *     The held amount reduces the effective balance but does not leave the wallet.
     *     Used for pre-auth scenarios (dining, gas, hotels) where final amount may differ.
     */
    post: operations['createHold'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/hold/capture': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Capture held funds (debit final amount)
     * @description Captures an active hold by debiting the final amount (which may be less than
     *     or equal to the held amount). Any difference is released back to available balance.
     */
    post: operations['captureHold'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/hold/release': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Release held funds (make available again)
     * @description Releases an active hold, making all held funds available again.
     *     No debit occurs.
     */
    post: operations['releaseHold'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/currency/hold/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get hold status and details
     * @description Retrieves the current status and details of an authorization hold.
     */
    post: operations['getHold'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Natural language documentation search
     * @description Search documentation using natural language queries.
     *     Returns the most relevant documents with voice-friendly summaries.
     */
    post: operations['queryDocumentation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get specific document by ID or slug
     * @description Retrieve a specific document by its unique identifier or slug.
     *     Returns full content with metadata.
     */
    post: operations['getDocument'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Full-text keyword search
     * @description Search documentation using exact keyword matching.
     *     Faster than semantic search but less flexible.
     */
    post: operations['searchDocumentation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List documents by category
     * @description List all documents in a specific category or all categories.
     *     Supports pagination for large result sets.
     */
    post: operations['listDocuments'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/suggest': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get related topics and follow-up suggestions
     * @description Given a topic or document ID, returns related topics the user
     *     might want to explore. Useful for conversational AI flow.
     */
    post: operations['suggestRelatedTopics'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/bind': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Bind a git repository to a documentation namespace
     * @description Bind a git repository URL to a documentation namespace.
     *     The namespace will be exclusively managed by the repository - manual edits will be blocked.
     *     Triggers initial sync after binding.
     */
    post: operations['bindRepository'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/sync': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Manually trigger repository sync
     * @description Manually trigger synchronization of a bound repository.
     *     If force=true, performs full re-sync regardless of commit hash.
     */
    post: operations['syncRepository'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get repository binding status
     * @description Get current status of a repository binding including sync state and statistics.
     */
    post: operations['getRepositoryStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all repository bindings
     * @description List all repository bindings with optional filtering by status.
     */
    post: operations['listRepositoryBindings'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update repository binding configuration
     * @description Update sync settings, file patterns, category mappings, or archive configuration.
     */
    post: operations['updateRepositoryBinding'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/archive/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create documentation archive
     * @description Create a .bannou bundle archive of all documents in a namespace.
     *     Archives are stored via Asset Service.
     */
    post: operations['createDocumentationArchive'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/archive/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List documentation archives
     * @description List all archives for a namespace.
     */
    post: operations['listDocumentationArchives'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new escrow agreement
     * @description Create a new escrow agreement. For each party, creates a dedicated escrow wallet
     *     and container (owned by escrow entity). Issues deposit tokens and returns ALL
     *     tokens to the creating service, which is responsible for distributing them to
     *     parties through appropriate channels. Sets template values on bound contract.
     */
    post: operations['createEscrow'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get escrow details
     * @description Get escrow agreement details by ID.
     */
    post: operations['getEscrow'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List escrows for a party
     * @description List escrow agreements with filtering options.
     */
    post: operations['listEscrows'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/deposit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Deposit assets into escrow
     * @description Deposit assets into escrow. Transfers currency from party's own wallet to that
     *     party's escrow wallet. Moves items from party's own container to that party's
     *     escrow container. Locks contracts with escrow as guardian.
     *     Rejects soulbound/non-tradeable items. After each deposit, queries bound contract
     *     to check if all asset requirements are satisfied.
     */
    post: operations['deposit'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/deposit/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate a deposit without executing
     * @description Validate a deposit without executing (dry run).
     */
    post: operations['validateDeposit'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/deposit/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get deposit status for a party
     * @description Get deposit status for a party in an escrow.
     */
    post: operations['getDepositStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/consent': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Record party consent
     * @description Record party consent for release, refund, or re-affirmation.
     */
    post: operations['recordConsent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/consent/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get consent status for escrow
     * @description Get consent status for all parties in an escrow.
     */
    post: operations['getConsentStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/release': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Trigger release
     * @description Trigger release (for trusted modes or after consent).
     *     If boundContractId is set, checks contract status first (must be fulfilled).
     *     Runs finalization flow before releasing remaining assets.
     */
    post: operations['release'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/refund': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Trigger refund
     * @description Trigger refund (for trusted modes or consent).
     */
    post: operations['refund'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel escrow before fully funded
     * @description Cancel escrow before fully funded, refunding any deposits.
     */
    post: operations['cancel'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/dispute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Raise a dispute on funded escrow
     * @description Raise a dispute on a funded escrow.
     */
    post: operations['dispute'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/resolve': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Arbiter resolves disputed escrow
     * @description Arbiter resolves a disputed escrow.
     */
    post: operations['resolve'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/verify-condition': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Verify condition for conditional escrow
     * @description Verify condition for conditional escrow (non-contract path).
     *     For escrows with boundContractId, use contract milestones instead.
     */
    post: operations['verifyCondition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/escrow/reaffirm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Re-affirm after validation failure
     * @description Re-affirm after validation failure (party accepts changed state).
     */
    post: operations['reaffirm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/game-service/services/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all registered game services
     * @description Returns all game services, optionally filtered by active status.
     */
    post: operations['listServices'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/game-service/services/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get service by ID or stub name
     * @description Retrieves a single service by either serviceId (GUID) or stubName.
     */
    post: operations['getService'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get game session details
     * @description Get details of the current game session the user has joined.
     */
    post: operations['getGameSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/leave': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Leave a game session */
    post: operations['leaveGameSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/chat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Send chat message to game session */
    post: operations['sendChatMessage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/actions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Perform game action (enhanced permissions after joining) */
    post: operations['performGameAction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sessions/leave-session': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Leave a specific game session by ID
     * @description Leave a game session by its session ID. This is the session-specific alternative
     *     to /sessions/leave which uses gameType. Useful for matchmade sessions.
     */
    post: operations['leaveGameSessionById'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/container/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new container
     * @description Creates a new container with the specified constraint model and capacity.
     *     Container types are game-defined strings (e.g., "inventory", "bank", "equipment_slot").
     */
    post: operations['createContainer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/container/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get container with contents
     * @description Retrieves a container by ID, optionally including its contents.
     */
    post: operations['getContainer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/container/get-or-create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get container or create if not exists
     * @description Enables lazy container creation for character inventories.
     *     If a container doesn't exist for the owner/type combination, creates it
     *     with the specified defaults.
     */
    post: operations['getOrCreateContainer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/container/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List containers for owner
     * @description Returns all containers owned by the specified entity.
     */
    post: operations['listContainers'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/container/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update container properties
     * @description Updates mutable container properties like capacity limits and filtering.
     */
    post: operations['updateContainer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/add': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Add item to container
     * @description Adds an item instance to a container. Validates container constraints
     *     (slots, weight, grid, category filters). For stackable items, may
     *     merge with existing stacks.
     */
    post: operations['addItemToContainer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/remove': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Remove item from container
     * @description Removes an item from its container. The item still exists but has no
     *     container assignment. Use destroy via lib-item to permanently delete.
     */
    post: operations['removeItemFromContainer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/move': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Move item to different slot or container
     * @description Moves an item within the same container (slot change) or to a different
     *     container. Validates destination constraints. For equipment slots, this
     *     effectively equips/unequips items.
     */
    post: operations['moveItem'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/transfer': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Transfer item to different owner
     * @description Transfers an item to a container owned by a different entity.
     *     Used for trades, gifts, and loot distribution.
     */
    post: operations['transferItem'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/split': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Split stack into two
     * @description Splits a stack of items into two stacks. The original stack keeps the
     *     remainder, and a new stack is created with the split quantity.
     */
    post: operations['splitStack'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/merge': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Merge two stacks
     * @description Merges two stacks of the same item template. The source stack is
     *     destroyed and its quantity added to the target stack.
     */
    post: operations['mergeStacks'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find items across containers
     * @description Searches for items across all containers owned by an entity.
     *     Can filter by template, category, tags, and other criteria.
     */
    post: operations['queryItems'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/count': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Count items of a template
     * @description Counts total quantity of a specific item template across containers.
     */
    post: operations['countItems'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/has': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if entity has required items
     * @description Checks if an entity has the required quantities of specified items.
     *     Used for crafting and quest requirements validation.
     */
    post: operations['hasItems'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory/find-space': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find where item would fit
     * @description Finds available space for an item in the owner's containers.
     *     Returns candidate containers and slots where the item could be placed.
     */
    post: operations['findSpace'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/template/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new item template
     * @description Creates a new item definition for a game. Code, gameId, quantityModel, and scope
     *     are immutable after creation.
     */
    post: operations['createItemTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/template/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get item template by ID or code
     * @description Retrieves an item template by its unique ID or by code+gameId combination.
     *     At least one of templateId or (code + gameId) must be provided.
     */
    post: operations['getItemTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/template/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List item templates with filters
     * @description Lists item templates with optional filtering by gameId, category, tags,
     *     rarity, scope, and active status.
     */
    post: operations['listItemTemplates'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/template/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update mutable fields of an item template
     * @description Updates mutable fields of an item template. Code, gameId, quantityModel, and scope
     *     are immutable after creation and cannot be changed.
     */
    post: operations['updateItemTemplate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/instance/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new item instance
     * @description Creates a new item instance from a template. The instance must be placed
     *     in a container (containerId required). Use lib-inventory's /inventory/add
     *     for most use cases - this endpoint is for low-level instance creation.
     */
    post: operations['createItemInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/instance/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get item instance by ID
     * @description Retrieves an item instance by its unique ID.
     */
    post: operations['getItemInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/instance/modify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Modify item instance state
     * @description Modifies an item instance's mutable state: durability, custom stats,
     *     custom name, and metadata. Cannot modify bound items unless admin.
     */
    post: operations['modifyItemInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/instance/bind': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Bind item to character
     * @description Binds an item instance to a character. The bind type must be allowed by
     *     the template's soulboundType. Once bound, the item cannot be traded.
     */
    post: operations['bindItemInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/instance/destroy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Destroy item instance
     * @description Permanently destroys an item instance. The reason is recorded for audit.
     *     Cannot destroy bound items unless admin or reason is 'admin'.
     */
    post: operations['destroyItemInstance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/instance/list-by-container': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List items in a container
     * @description Returns all item instances in the specified container.
     */
    post: operations['listItemsByContainer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/item/instance/batch-get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get multiple item instances by ID
     * @description Retrieves multiple item instances in a single request.
     */
    post: operations['batchGetItemInstances'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/definition/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new leaderboard definition
     * @description Create a new leaderboard with specified properties.
     *     Developer-only endpoint for setting up game leaderboards.
     */
    post: operations['createLeaderboardDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/definition/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update leaderboard definition
     * @description Update properties of an existing leaderboard.
     *     Developer-only endpoint.
     */
    post: operations['updateLeaderboardDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/definition/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete leaderboard definition
     * @description Delete a leaderboard and all its scores.
     *     Developer-only endpoint. This action is irreversible.
     */
    post: operations['deleteLeaderboardDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/rank/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get entity's rank
     * @description Get the current rank and score for a specific entity.
     */
    post: operations['getEntityRank'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/rank/top': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get top entries
     * @description Get the top N entries on a leaderboard.
     */
    post: operations['getTopRanks'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/rank/around': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get entries around entity
     * @description Get leaderboard entries surrounding a specific entity.
     *     Useful for showing a player's position with nearby competitors.
     */
    post: operations['getRanksAround'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/leaderboard/season/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get current season info
     * @description Get information about the current or a specific past season.
     */
    post: operations['getSeason'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get location by ID */
    post: operations['getLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get location by code and realm
     * @description Retrieve a location using its unique code within a specific realm
     */
    post: operations['getLocationByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List locations with filtering
     * @description Retrieve locations with optional realm, parent, and type filtering
     */
    post: operations['listLocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list-by-realm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all locations in a realm (primary query pattern)
     * @description Returns all locations within a specific realm, optionally filtered by
     *     location type and parent. This is the primary access pattern for
     *     realm-scoped location queries.
     */
    post: operations['listLocationsByRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list-by-parent': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get child locations for a parent location
     * @description Retrieve all locations that have the specified location as their parent.
     *     Useful for getting all cities in a region, all buildings in a city, etc.
     */
    post: operations['listLocationsByParent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list-root': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get root locations in a realm
     * @description Returns all top-level locations in a realm (locations with no parent).
     *     These are typically regions or major areas within the realm.
     */
    post: operations['listRootLocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get-ancestors': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all ancestors of a location
     * @description Returns the full ancestry chain from the specified location up to the
     *     root location (parentLocationId=null). For example, for a specific building
     *     might return [district, city, region].
     */
    post: operations['getLocationAncestors'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get-descendants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all descendants of a location
     * @description Returns all locations that are descendants of the specified location
     *     (direct children, grandchildren, etc.). Useful for finding all places
     *     within a region or city.
     */
    post: operations['getLocationDescendants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/exists': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if location exists and is active
     * @description Fast validation endpoint for other services to check location validity.
     *     Returns true if location exists and is not deprecated, false otherwise.
     */
    post: operations['locationExists'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/request-snapshot': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request full snapshot for cold start
     * @description Consumers use this when starting up to get initial state.
     *     Returns current snapshot of requested region/kinds.
     *     For very large maps, payloadRef points to lib-asset storage.
     */
    post: operations['requestSnapshot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/point': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query map data at a specific point
     * @description Returns all map data at a point across requested kinds.
     *     Used by behavior stacks for contextual decisions.
     *     Optionally includes objects within radius.
     */
    post: operations['queryPoint'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/bounds': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query map data within bounds
     * @description Returns map data within a bounding box.
     *     For event actors needing region overview.
     *     Limited to maxObjects per kind.
     */
    post: operations['queryBounds'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/objects-by-type': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find all objects of a type in region
     * @description Returns all objects matching an objectType filter.
     *     For event actors asking "where are all the boulder clusters?"
     */
    post: operations['queryObjectsByType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/affordance': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find locations that afford a specific action or scene type
     * @description Affordance queries answer "where can I do X?" by combining
     *     multiple map kinds and applying game-specific scoring logic.
     *
     *     Used by Event Brain for procedural scene orchestration:
     *     - "Find ambush locations"
     *     - "Find dramatic reveal spots"
     *     - "Find sheltered rest areas"
     *
     *     Well-known types have predefined scoring; use affordanceType=custom
     *     with customAffordance for novel scenarios.
     */
    post: operations['queryAffordance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/authoring/checkout': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Acquire exclusive edit lock for design-time editing
     * @description For level editors and design tools only.
     *     Game servers do NOT use this - they use create-channel for implicit authority.
     *     Returns authority token for publishing edits.
     */
    post: operations['checkoutForAuthoring'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/authoring/commit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Commit design-time changes
     * @description Commits pending changes and releases the checkout lock.
     *     Optionally includes a commit message for history.
     */
    post: operations['commitAuthoring'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/authoring/release': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Release authoring checkout without committing
     * @description Discards pending changes and releases the checkout lock.
     *     Use when abandoning edits.
     */
    post: operations['releaseAuthoring'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a map definition template
     * @description Creates a new map definition (template) that describes the structure
     *     of a region. Definitions are templates that can be used to bootstrap
     *     channels with predefined layer configurations.
     */
    post: operations['createDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a map definition by ID
     * @description Returns the full map definition including all layer configurations.
     */
    post: operations['getDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List map definitions with optional filters
     * @description Returns a paginated list of map definitions.
     */
    post: operations['listDefinitions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a map definition
     * @description Updates an existing map definition. Cannot change the definition ID.
     *     Layer configurations can be modified.
     */
    post: operations['updateDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/queue/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List available matchmaking queues
     * @description List all available matchmaking queues that players can join.
     *     Returns queue configuration details including skill settings.
     */
    post: operations['listQueues'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/queue/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get queue details
     * @description Get detailed configuration for a specific matchmaking queue.
     */
    post: operations['getQueue'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/join': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Join matchmaking queue
     * @description Join a matchmaking queue with specified properties and query.
     *     Creates a matchmaking ticket and begins searching for compatible players.
     *     Returns immediately after ticket creation. Match results are delivered
     *     via WebSocket push events.
     */
    post: operations['joinMatchmaking'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/leave': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Leave matchmaking queue
     * @description Leave a matchmaking queue and cancel the ticket.
     *     Only available when actively in a queue (shortcut/prebound).
     */
    post: operations['leaveMatchmaking'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get matchmaking status
     * @description Get current matchmaking status for the player's active ticket.
     *     Only available when actively in a queue (shortcut/prebound).
     */
    post: operations['getMatchmakingStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/accept': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Accept a formed match
     * @description Accept a match that has been formed. Only available when a match
     *     is pending acceptance (shortcut/prebound after match formation).
     *     All players must accept within the timeout for the match to start.
     */
    post: operations['acceptMatch'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/decline': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Decline a formed match
     * @description Decline a match that has been formed. Only available when a match
     *     is pending acceptance (shortcut/prebound after match formation).
     *     Declining cancels the match for all participants.
     */
    post: operations['declineMatch'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/matchmaking/stats': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get queue statistics
     * @description Get operational statistics for matchmaking queues.
     *     Includes queue depths, average wait times, and match rates.
     */
    post: operations['getMatchmakingStats'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/generate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate composition from style and constraints
     * @description Generates a complete musical composition using the specified style definition
     *     and compositional constraints. Returns MIDI-JSON format output.
     */
    post: operations['GenerateComposition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate MIDI-JSON structure
     * @description Validates a MIDI-JSON structure for correctness including note ranges,
     *     timing, and format compliance.
     */
    post: operations['ValidateMidiJson'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/style/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get style definition
     * @description Retrieves a style definition by ID or name. Styles define mode preferences,
     *     interval rules, form templates, and genre-specific parameters.
     */
    post: operations['GetStyle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/style/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List available styles
     * @description Lists all available style definitions with optional filtering by category.
     */
    post: operations['ListStyles'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/theory/progression': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate chord progression
     * @description Generates a chord progression using harmonic function theory.
     *     Supports multiple harmonic styles including functional harmony,
     *     modal interchange, and jazz voicings.
     */
    post: operations['GenerateProgression'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/theory/melody': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate melody over harmony
     * @description Generates a melodic line over a chord progression using contour rules,
     *     interval preferences, and rhythmic patterns from the specified style.
     */
    post: operations['GenerateMelody'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/music/theory/voice-lead': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Apply voice leading to chords
     * @description Applies voice leading rules to a chord sequence, ensuring smooth
     *     part-writing according to traditional or style-specific rules.
     */
    post: operations['ApplyVoiceLeading'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get realm by ID */
    post: operations['getRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get realm by code
     * @description Retrieve a realm using its unique code (e.g., "REALM_1", "REALM_2")
     */
    post: operations['getRealmByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all realms
     * @description Retrieve all realms with optional filtering
     */
    post: operations['listRealms'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm/exists': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if realm exists and is active
     * @description Fast validation endpoint for other services to check realm validity.
     *     Returns true if realm exists and is not deprecated, false otherwise.
     */
    post: operations['realmExists'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm-history/get-participation': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all historical events a realm participated in
     * @description Retrieves all historical event participation records for a realm.
     *     Supports filtering by event category and minimum impact.
     */
    post: operations['getRealmParticipation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm-history/get-event-participants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all realms that participated in a historical event
     * @description Retrieves all realms that participated in a specific historical event.
     *     Useful for generating event summaries or finding related realms.
     */
    post: operations['getRealmEventParticipants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/realm-history/get-lore': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get machine-readable lore elements for behavior system
     * @description Retrieves structured lore elements for a realm. These elements
     *     are machine-readable key-value pairs used by the behavior system for
     *     decision-making, not narrative text for players.
     */
    post: operations['getRealmLore'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get a relationship by ID */
    post: operations['getRelationship'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/list-by-entity': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all relationships for an entity
     * @description Returns all relationships where the specified entity is either
     *     entity1 or entity2. Supports filtering by relationship type,
     *     other entity type, and whether to include ended relationships.
     */
    post: operations['listRelationshipsByEntity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/get-between': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all relationships between two specific entities
     * @description Returns all relationships that exist between two specific entities,
     *     regardless of which is entity1 or entity2.
     */
    post: operations['getRelationshipsBetween'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/list-by-type': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all relationships of a specific type
     * @description Returns all relationships that use a specific relationship type.
     *     Useful for finding all "FRIEND" relationships, for example.
     */
    post: operations['listRelationshipsByType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get relationship type by ID */
    post: operations['getRelationshipType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get relationship type by code
     * @description Retrieve a relationship type using its unique code (e.g., "SON", "MOTHER", "FRIEND")
     */
    post: operations['getRelationshipTypeByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all relationship types
     * @description Retrieve all relationship types with optional hierarchy filtering
     */
    post: operations['listRelationshipTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get-children': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get child types for a parent type
     * @description Retrieve all relationship types that have the specified type as their parent
     */
    post: operations['getChildRelationshipTypes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/matches-hierarchy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if type matches ancestor in hierarchy
     * @description Checks if a relationship type matches or descends from an ancestor type.
     *     For example, "SON" matches "CHILD" because CHILD is an ancestor of SON.
     *     This enables queries like "find all CHILD relationships" to match SON, DAUGHTER, etc.
     */
    post: operations['matchesHierarchy'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship-type/get-ancestors': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all ancestors of a relationship type
     * @description Returns the full ancestry chain from the specified type up to the root.
     *     For example, for "SON" might return ["CHILD", "FAMILY"].
     */
    post: operations['getAncestors'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create or configure a save slot
     * @description Creates a new save slot or updates configuration of an existing slot.
     *     Slots are auto-created on first save, but pre-creation allows setting
     *     custom configuration (max versions, retention policy, etc.).
     */
    post: operations['CreateSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get slot metadata
     * @description Returns slot configuration and version summary.
     */
    post: operations['GetSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List slots for owner
     * @description Returns all slots owned by the specified entity.
     */
    post: operations['ListSlots'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete slot and all versions
     * @description Permanently deletes a slot and all save versions within it.
     *     This is irreversible. Requires owner access or admin role.
     */
    post: operations['DeleteSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/rename': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Rename a save slot
     * @description Renames an existing slot without affecting its versions or data.
     *     The new name must not already exist for this owner.
     */
    post: operations['RenameSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/save': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Save data to slot
     * @description Creates a new version in the specified slot with the provided data.
     *     If the slot doesn't exist, it's auto-created with default configuration.
     *
     *     Large saves (>1MB by default) are automatically compressed.
     *     Rolling version cleanup is applied based on slot configuration.
     */
    post: operations['Save'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/load': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Load data from slot
     * @description Retrieves save data from the specified slot. By default, loads the
     *     latest version. Optionally specify a version number or checkpoint name.
     */
    post: operations['Load'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/save-delta': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Save incremental changes from base version
     * @description Creates a new version by applying a delta (patch) to a base version.
     *     Significantly reduces storage for large saves with small incremental changes.
     *
     *     Uses JSON Patch (RFC 6902) by default. The implementation is designed to
     *     allow swapping to binary diff algorithms (bsdiff/xdelta) if needed for
     *     specific use cases (e.g., binary game state).
     *
     *     Delta versions store only the patch; full data is reconstructed on load.
     */
    post: operations['SaveDelta'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/load-with-deltas': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Load save reconstructing from delta chain
     * @description Loads save data, automatically reconstructing from delta chain if needed.
     *     Returns the full reconstructed data, not the raw delta.
     *
     *     For performance, the service may cache reconstructed data or collapse
     *     delta chains during background cleanup.
     */
    post: operations['LoadWithDeltas'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/collapse-deltas': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Collapse delta chain into full snapshot
     * @description Collapses a chain of delta versions into a single full snapshot.
     *     Useful for reducing load latency or before deleting base versions.
     */
    post: operations['CollapseDeltas'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List versions in slot
     * @description Returns all versions in a slot with metadata.
     */
    post: operations['ListVersions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/pin': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Pin a version as checkpoint
     * @description Pins a specific version, excluding it from rolling cleanup.
     *     Optionally assigns a checkpoint name for easy retrieval.
     */
    post: operations['PinVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/unpin': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Unpin a version
     * @description Removes pin from a version, making it eligible for rolling cleanup.
     */
    post: operations['UnpinVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete specific version
     * @description Permanently deletes a specific version from a slot.
     *     Cannot delete pinned versions; unpin first.
     */
    post: operations['DeleteVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query saves with filters
     * @description Search and filter saves across slots. Supports filtering by owner,
     *     category, date range, metadata, and more. Paginated results.
     */
    post: operations['QuerySaves'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/copy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Copy save to different slot or owner
     * @description Copies a save version to a different slot or owner.
     *     Can copy to same owner (different slot) or different owner (with admin).
     */
    post: operations['CopySave'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Export saves for backup/portability
     * @description Exports one or more slots with all versions as a downloadable archive.
     *     Returns a pre-signed URL to download the export bundle.
     */
    post: operations['ExportSaves'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/verify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Verify save data integrity
     * @description Verifies the integrity of stored save data by comparing content hash
     *     against the stored SHA-256 hash. Detects corruption or tampering.
     */
    post: operations['VerifyIntegrity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/promote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Promote old version to latest
     * @description Creates a new version from an existing older version, effectively
     *     "promoting" it to be the latest. Useful for rollback scenarios.
     */
    post: operations['PromoteVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/migrate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Migrate save to new schema version
     * @description Applies migration handlers to upgrade a save from one schema version
     *     to another. Creates a new version with the migrated data.
     */
    post: operations['MigrateSave'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/schema/register': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Register a save data schema
     * @description Registers a JSON schema for validation of save data.
     *     Optionally includes migration handlers from previous versions.
     */
    post: operations['RegisterSchema'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/schema/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List registered schemas
     * @description Returns all registered schemas for a game/namespace.
     */
    post: operations['ListSchemas'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new scene document
     * @description Creates a new scene document and stores it in lib-asset.
     *     Publishes scene.created event on success.
     *     Returns Conflict if a scene with the same sceneId already exists.
     */
    post: operations['createScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Retrieve a scene by ID
     * @description Retrieves a scene document. Optionally resolves nested scene references
     *     up to a configurable depth.
     */
    post: operations['getScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List scenes with filtering
     * @description Lists scenes matching the provided filters. Supports pagination.
     *     Results are ordered by updatedAt descending (most recent first).
     */
    post: operations['listScenes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a scene document
     * @description Updates an existing scene document. Scene must not be checked out by
     *     another user. Increments the PATCH version automatically.
     *     Publishes scene.updated event on success.
     */
    post: operations['updateScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a scene
     * @description Soft-deletes a scene. The scene data remains recoverable via lib-asset
     *     for approximately 30 days. Cannot delete if other scenes reference this one.
     *     Publishes scene.deleted event on success.
     */
    post: operations['deleteScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate a scene structure
     * @description Validates a scene document without saving it. Checks structural validity
     *     and optionally applies game-specific validation rules.
     */
    post: operations['validateScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/checkout': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Lock a scene for editing
     * @description Acquires an exclusive lock on the scene for editing.
     *     Returns a checkout token required for commit.
     *     Lock expires after TTL if not extended via heartbeat.
     */
    post: operations['checkoutScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/commit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Save changes and release lock
     * @description Commits the changes made during checkout, increments version,
     *     and releases the lock. Publishes scene.committed event.
     */
    post: operations['commitScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/discard': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Release lock without saving changes
     * @description Discards any changes and releases the checkout lock.
     *     Scene remains at its pre-checkout version.
     */
    post: operations['discardCheckout'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/heartbeat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Extend checkout lock TTL
     * @description Extends the checkout lock TTL. Should be called periodically
     *     during editing to prevent lock expiration.
     */
    post: operations['heartbeatCheckout'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/history': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get version history for a scene
     * @description Returns the version history for a scene, up to the configured
     *     retention limit per gameId.
     */
    post: operations['getSceneHistory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/get-validation-rules': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get validation rules for a gameId+sceneType
     * @description Retrieves the registered validation rules for a specific
     *     gameId and sceneType combination.
     */
    post: operations['getValidationRules'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Full-text search across scenes
     * @description Searches scene names, descriptions, tags, and node names
     *     for matching content.
     */
    post: operations['searchScenes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/find-references': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find scenes that reference a given scene
     * @description Returns all scenes that contain reference nodes pointing
     *     to the specified scene.
     */
    post: operations['findReferences'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/find-asset-usage': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find scenes using a specific asset
     * @description Returns all scenes containing nodes that reference
     *     a specific asset ID.
     */
    post: operations['findAssetUsage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scene/duplicate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Duplicate a scene with a new ID
     * @description Creates a copy of a scene with a new sceneId and name.
     *     All node IDs are regenerated. Version resets to 1.0.0.
     */
    post: operations['duplicateScene'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/species/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get species by ID */
    post: operations['getSpecies'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/species/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get species by code
     * @description Retrieve a species using its unique code (e.g., "HUMAN", "ELF", "DWARF")
     */
    post: operations['getSpeciesByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/species/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all species
     * @description Retrieve all species with optional realm filtering
     */
    post: operations['listSpecies'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/species/list-by-realm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List species available in a realm
     * @description Retrieve all species that are available in a specific realm
     */
    post: operations['listSpeciesByRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/subscription/account/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get subscriptions for an account
     * @description Returns all subscriptions for a given account, with optional filtering.
     */
    post: operations['getAccountSubscriptions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/subscription/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get a specific subscription by ID */
    post: operations['getSubscription'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/subscription/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel a subscription
     * @description Cancels a subscription. Users can cancel their own subscriptions,
     *     admins can cancel any subscription.
     */
    post: operations['cancelSubscription'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/voice/peer/answer': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Send SDP answer to complete WebRTC handshake
     * @description Called by clients after receiving a VoicePeerJoinedEvent containing an SDP offer.
     *     The client generates an SDP answer and sends it via this endpoint.
     *     The answering peer is notified via VoicePeerUpdatedEvent.
     *
     *     **Access Control**: This endpoint requires the `voice:ringing` state, which is
     *     automatically set by the Voice service when a VoicePeerJoinedEvent is sent to the client.
     *     The state is cleared after the answer is processed or times out.
     */
    post: operations['answerPeer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get website status and version */
    get: operations['getStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/content/{slug}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get dynamic page content from CMS */
    get: operations['getPageContent'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/news': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get latest news and announcements */
    get: operations['getNews'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/server-status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get game server status for all realms */
    get: operations['getServerStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/downloads': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get download links for game clients */
    get: operations['getDownloads'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/contact': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Submit contact form */
    post: operations['submitContact'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/account/profile': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get account profile for logged-in user */
    get: operations['getAccountProfile'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/account/characters': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get character list for logged-in user */
    get: operations['getAccountCharacters'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/cms/pages': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all CMS pages */
    get: operations['listPages'];
    put?: never;
    /** Create new CMS page */
    post: operations['createPage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/cms/pages/{slug}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /** Update CMS page */
    put: operations['updatePage'];
    post?: never;
    /** Delete CMS page */
    delete: operations['deletePage'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/cms/site-settings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get site configuration */
    get: operations['getSiteSettings'];
    /** Update site configuration */
    put: operations['updateSiteSettings'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/cms/theme': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get current theme configuration */
    get: operations['getTheme'];
    /** Update theme configuration */
    put: operations['updateTheme'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/website/account/subscription': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get subscription status */
    get: operations['getAccountSubscription'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Request to accept a formed match */
    AcceptMatchRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the match to accept
       */
      matchId: string;
    };
    /** @description Response after accepting a match */
    AcceptMatchResponse: {
      /**
       * Format: uuid
       * @description Match identifier
       */
      matchId: string;
      /** @description Whether all players have accepted */
      allAccepted: boolean;
      /** @description Number of players who have accepted */
      acceptedCount?: number | null;
      /** @description Total players who need to accept */
      totalCount?: number | null;
      /**
       * Format: uuid
       * @description Game session ID (set when all players accept)
       */
      gameSessionId?: string | null;
    };
    /** @description User account information displayed on the website profile page */
    AccountProfile: {
      /**
       * Format: uuid
       * @description Unique identifier for the account
       */
      accountId: string;
      /**
       * Format: email
       * @description Email address associated with the account
       */
      email: string;
      /** @description User-chosen display name */
      displayName?: string | null;
      /**
       * Format: date-time
       * @description Date and time when the account was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Date and time of the last successful login
       */
      lastLogin?: string | null;
      /** @description Total number of character slots available */
      characterSlots?: number;
      /** @description Number of character slots currently in use */
      usedSlots?: number;
    };
    /** @description Account information response */
    AccountResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the account
       */
      accountId: string;
      /**
       * Format: email
       * @description Email address associated with the account. Null for OAuth/Steam accounts without email.
       */
      email?: string | null;
      /** @description Display name for the account */
      displayName?: string | null;
      /** @description BCrypt hashed password for authentication */
      passwordHash?: string | null;
      /**
       * Format: date-time
       * @description Timestamp when the account was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the account was last updated
       */
      updatedAt?: string | null;
      /** @description Whether the email address has been verified */
      emailVerified: boolean;
      /** @description List of roles assigned to the account */
      roles: string[];
      /** @description List of authentication methods linked to the account */
      authMethods?: components['schemas']['AuthMethodInfo'][];
      /** @description Custom metadata associated with the account */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Achievement definition details */
    AchievementDefinitionResponse: {
      /**
       * Format: uuid
       * @description ID of the owning game service
       */
      gameServiceId: string;
      /** @description Unique identifier */
      achievementId: string;
      /** @description Human-readable name */
      displayName: string;
      /** @description How to earn this achievement */
      description: string;
      /** @description Description for hidden achievements */
      hiddenDescription?: string | null;
      /** @description Classification of the achievement */
      achievementType: components['schemas']['AchievementType'];
      /** @description Allowed entity types */
      entityTypes?: components['schemas']['EntityType'][];
      /** @description Target for progressive achievements */
      progressTarget?: number | null;
      /** @description Point value */
      points: number;
      /** @description Achievement icon URL */
      iconUrl?: string | null;
      /** @description Available platforms */
      platforms?: components['schemas']['Platform'][];
      /** @description Platform-specific IDs */
      platformIds?: {
        [key: string]: string;
      } | null;
      /** @description Required achievements */
      prerequisites?: string[] | null;
      /** @description Whether achievement is earnable */
      isActive: boolean;
      /**
       * Format: int64
       * @description How many entities have earned this
       */
      earnedCount?: number;
      /**
       * Format: date-time
       * @description When the achievement was created
       */
      createdAt: string;
      /** @description Additional metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Progress toward a single achievement */
    AchievementProgress: {
      /** @description Achievement identifier */
      achievementId: string;
      /** @description Achievement display name */
      displayName?: string;
      /** @description Current progress (for progressive) */
      currentProgress?: number | null;
      /** @description Target progress (for progressive) */
      targetProgress?: number | null;
      /**
       * Format: double
       * @description Completion percentage (0-100)
       */
      percentComplete?: number | null;
      /** @description Whether achievement is unlocked */
      isUnlocked: boolean;
      /**
       * Format: date-time
       * @description When achievement was unlocked
       */
      unlockedAt?: string | null;
    };
    /** @description Achievement progress for an entity */
    AchievementProgressResponse: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type that owns this progress summary */
      entityType: components['schemas']['EntityType'];
      /** @description Progress for each achievement */
      progress: components['schemas']['AchievementProgress'][];
      /** @description Total points from unlocked achievements */
      totalPoints?: number;
      /** @description Number of unlocked achievements */
      unlockedCount?: number;
    };
    /**
     * @description Type of achievement
     * @enum {string}
     */
    AchievementType: 'standard' | 'progressive' | 'hidden' | 'secret';
    /**
     * @description Actor-specific capabilities that affect affordance evaluation.
     *     Same location may afford different actions to different actor types.
     */
    ActorCapabilities: {
      /** @description Affects cover requirements and passage width */
      size?: components['schemas']['ActorSize'];
      /** @description Actor height in meters (affects cover, sightlines) */
      height?: number | null;
      /**
       * @description Can reach elevated positions
       * @default false
       */
      canClimb: boolean;
      /**
       * @description Includes water-based positions
       * @default false
       */
      canSwim: boolean;
      /**
       * @description Includes aerial positions
       * @default false
       */
      canFly: boolean;
      /** @description Affects sightline distance requirements */
      perceptionRange?: number | null;
      /** @description Affects escape route viability calculations */
      movementSpeed?: number | null;
      /** @description Affects ambush/hidden_path affordance scoring */
      stealthRating?: number | null;
    };
    /** @description Response containing actor instance details */
    ActorInstanceResponse: {
      /** @description Unique actor identifier */
      actorId: string;
      /**
       * Format: uuid
       * @description Template this actor was instantiated from
       */
      templateId: string;
      /** @description Actor category from template */
      category: string;
      /** @description Pool node running this actor (null in bannou mode) */
      nodeId?: string | null;
      /** @description Pool node's app-id for direct messaging */
      nodeAppId?: string | null;
      /** @description Current actor lifecycle state */
      status: components['schemas']['ActorStatus'];
      /**
       * Format: uuid
       * @description Associated character ID (for NPC brains)
       */
      characterId?: string | null;
      /**
       * Format: date-time
       * @description When the actor started running
       */
      startedAt: string;
      /**
       * Format: date-time
       * @description Last heartbeat timestamp from the actor
       */
      lastHeartbeat?: string | null;
      /**
       * Format: int64
       * @description Number of behavior loop iterations executed
       */
      loopIterations: number;
    };
    /**
     * @description Size classification affecting cover requirements and passage width
     * @default medium
     * @enum {string}
     */
    ActorSize: 'tiny' | 'small' | 'medium' | 'large' | 'huge';
    /**
     * @description Current actor lifecycle state
     * @enum {string}
     */
    ActorStatus: 'pending' | 'starting' | 'running' | 'paused' | 'stopping' | 'stopped' | 'error';
    /** @description Response containing actor template details */
    ActorTemplateResponse: {
      /**
       * Format: uuid
       * @description Unique template identifier
       */
      templateId: string;
      /** @description Category identifier */
      category: string;
      /** @description Reference to behavior in lib-assets */
      behaviorRef: string;
      /** @description Default configuration passed to behavior execution */
      configuration?: {
        [key: string]: unknown;
      } | null;
      /** @description Auto-spawn configuration for instantiate-on-access */
      autoSpawn?: components['schemas']['AutoSpawnConfig'];
      /** @description Milliseconds between behavior loop iterations */
      tickIntervalMs: number;
      /** @description Seconds between automatic state saves */
      autoSaveIntervalSeconds: number;
      /** @description Maximum actors of this category per pool node */
      maxInstancesPerNode: number;
      /**
       * Format: date-time
       * @description When the template was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the template was last updated
       */
      updatedAt: string;
    };
    /** @description Request to add item to container */
    AddItemRequest: {
      /**
       * Format: uuid
       * @description Item instance ID to add
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Target container ID
       */
      containerId: string;
      /** @description Specific slot (auto-assign if null) */
      slotIndex?: number | null;
      /** @description Grid X position */
      slotX?: number | null;
      /** @description Grid Y position */
      slotY?: number | null;
      /** @description Rotate in grid */
      rotated?: boolean | null;
      /**
       * @description Auto-merge with existing stacks
       * @default true
       */
      autoStack: boolean;
    };
    /** @description Response after adding item */
    AddItemResponse: {
      /** @description Whether add succeeded */
      success: boolean;
      /**
       * Format: uuid
       * @description Added item ID
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Container ID
       */
      containerId: string;
      /** @description Assigned slot */
      slotIndex?: number | null;
      /** @description Assigned X position */
      slotX?: number | null;
      /** @description Assigned Y position */
      slotY?: number | null;
      /**
       * Format: uuid
       * @description Instance merged into if stacked
       */
      mergedWithInstanceId?: string | null;
    };
    /**
     * @description Describes a capability or interaction mode for a node.
     *     Used by AI systems to understand what actions are possible and by
     *     character controllers for contextual animations.
     */
    Affordance: {
      /** @description The type of affordance */
      type: components['schemas']['AffordanceType'];
      /**
       * @description Type-specific parameters. Examples:
       *     - sittable: { height: 0.5, facing: [0,0,1] }
       *     - door: { openAngle: 90, locked: false }
       *     - container: { capacity: 10, itemTypes: ["weapon", "consumable"] }
       */
      parameters?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Controls caching behavior for affordance queries
     * @default cached
     * @enum {string}
     */
    AffordanceFreshness: 'fresh' | 'cached' | 'aggressive_cache';
    /** @description A location that affords the requested action */
    AffordanceLocation: {
      /** @description Location position */
      position?: components['schemas']['Position3D'];
      /** @description Area bounds if affordance spans an area */
      bounds?: components['schemas']['Bounds'];
      /** @description How well this location affords the action (0-1) */
      score?: number;
      /**
       * @description What makes this location suitable.
       *     Example: { "cover_rating": 0.8, "sightlines": ["north"], "terrain": "rocky" }
       */
      features?: {
        [key: string]: unknown;
      } | null;
      /** @description Map objects contributing to this affordance */
      objectIds?: string[] | null;
    };
    /** @description Metadata about the affordance query execution */
    AffordanceQueryMetadata: {
      /** @description Map kinds that were queried */
      kindsSearched?: string[] | null;
      /** @description Number of candidate objects evaluated */
      objectsEvaluated?: number;
      /** @description Number of candidate positions generated */
      candidatesGenerated?: number;
      /** @description Query execution time in milliseconds */
      searchDurationMs?: number;
      /** @description Whether results came from cache */
      cacheHit?: boolean;
    };
    /** @description Query for locations that afford a specific action */
    AffordanceQueryRequest: {
      /**
       * Format: uuid
       * @description Region to search
       */
      regionId: string;
      /** @description Type of affordance to search for */
      affordanceType: components['schemas']['AffordanceType'];
      /** @description Custom affordance definition (when affordanceType=custom) */
      customAffordance?: components['schemas']['CustomAffordance'];
      /** @description Optional bounds to search within */
      bounds?: components['schemas']['Bounds'];
      /**
       * @description Maximum locations to return
       * @default 10
       */
      maxResults: number;
      /**
       * @description Minimum affordance score to include
       * @default 0.5
       */
      minScore: number;
      /** @description Expected participants (affects space requirements) */
      participantCount?: number | null;
      /** @description Positions to exclude (e.g., player's current location) */
      excludePositions?: components['schemas']['Position3D'][] | null;
      /** @description Actor capabilities affecting evaluation */
      actorCapabilities?: components['schemas']['ActorCapabilities'];
      /** @description Cache freshness level */
      freshness?: components['schemas']['AffordanceFreshness'];
      /** @description Max age of cached results (for cached/aggressive_cache) */
      maxAgeSeconds?: number | null;
    };
    /** @description Affordance query results */
    AffordanceQueryResponse: {
      /** @description Scored locations (highest score first) */
      locations?: components['schemas']['AffordanceLocation'][];
      /** @description Metadata about query execution (optional) */
      queryMetadata?: components['schemas']['AffordanceQueryMetadata'];
    };
    /**
     * @description Well-known affordance types with predefined scoring logic.
     *     Use 'custom' for novel affordance definitions.
     * @enum {string}
     */
    AffordanceType:
      | 'ambush'
      | 'shelter'
      | 'vista'
      | 'choke_point'
      | 'gathering_spot'
      | 'dramatic_reveal'
      | 'hidden_path'
      | 'defensible_position'
      | 'custom';
    /** @description Analytics and tracking configuration for website visitor metrics */
    Analytics: {
      /** @description Google Analytics tracking ID */
      googleAnalyticsId?: string | null;
      /** @description Configuration for other analytics trackers */
      otherTrackers?: {
        [key: string]: unknown;
      };
    };
    /**
     * @description Request to send an SDP answer to complete a WebRTC handshake.
     *     Sent by clients after receiving a VoicePeerJoinedEvent with an SDP offer.
     */
    AnswerPeerRequest: {
      /**
       * Format: uuid
       * @description Voice room ID
       */
      roomId: string;
      /**
       * Format: uuid
       * @description Session ID of the answering peer (caller of this endpoint)
       */
      senderSessionId: string;
      /**
       * Format: uuid
       * @description Session ID of the peer whose offer we're answering
       */
      targetSessionId: string;
      /** @description SDP answer generated by this client's WebRTC stack */
      sdpAnswer: string;
      /** @description ICE candidates for NAT traversal (can be trickled later) */
      iceCandidates?: string[];
    };
    /** @description Archive metadata including size and document count */
    ArchiveInfo: {
      /**
       * Format: uuid
       * @description Unique identifier of the archive
       */
      archiveId: string;
      /** @description Namespace the archive belongs to */
      namespace: string;
      /**
       * Format: uuid
       * @description Asset ID in Asset Service
       */
      bundleAssetId?: string;
      /** @description Description of the archive */
      description?: string | null;
      /** @description Number of documents in the archive */
      documentCount?: number;
      /** @description Total size of the archive in bytes */
      sizeBytes?: number;
      /** @description Git commit hash if namespace was bound at archive time */
      commitHash?: string | null;
      /**
       * Format: date-time
       * @description Timestamp when the archive was created
       */
      createdAt: string;
      /**
       * @description Owner of this archive. NOT a session ID.
       *     Contains either an accountId (UUID format) for user-initiated archives
       *     or a service name for service-initiated archives.
       */
      owner?: string;
    };
    /** @description Describes a conflict when the same asset ID has different content hashes */
    AssetConflict: {
      /** @description The conflicting asset identifier */
      assetId: string;
      /** @description Bundles with conflicting versions of this asset */
      conflictingBundles: components['schemas']['ConflictingBundleEntry'][];
    };
    /** @description Complete asset metadata including system-generated fields */
    AssetMetadata: {
      /** @description Unique asset identifier */
      assetId: string;
      /** @description SHA256 hash of file contents */
      contentHash: string;
      /** @description Original filename */
      filename: string;
      /** @description MIME content type */
      contentType: string;
      /**
       * Format: int64
       * @description File size in bytes
       */
      size: number;
      /** @description Type classification for the asset */
      assetType: components['schemas']['AssetType'];
      /** @description Game realm the asset belongs to */
      realm: components['schemas']['GameRealm'];
      /** @description Searchable tags for the asset */
      tags: string[];
      /** @description Current status of asset processing pipeline */
      processingStatus: components['schemas']['ProcessingStatus'];
      /**
       * @description Whether the asset is in cold/archival storage
       * @default false
       */
      isArchived: boolean;
      /**
       * Format: date-time
       * @description Timestamp when the asset was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the asset was last updated
       */
      updatedAt: string;
    };
    /** @description User-provided metadata for asset categorization */
    AssetMetadataInput: {
      /** @description Type classification for the asset */
      assetType?: components['schemas']['AssetType'];
      /** @description Game realm the asset belongs to */
      realm?: components['schemas']['GameRealm'];
      /** @description Searchable tags for the asset */
      tags?: string[];
    };
    /** @description Reference to an asset in lib-asset */
    AssetReference: {
      /**
       * Format: uuid
       * @description Optional bundle containing the asset
       */
      bundleId?: string | null;
      /**
       * Format: uuid
       * @description Asset identifier in lib-asset
       */
      assetId: string;
      /** @description Variant identifier (consumer interprets meaning) */
      variantId?: string | null;
    };
    /** @description Information about a required asset */
    AssetRequirementInfo: {
      /** @description Asset type (currency, item, item_stack) */
      type: string;
      /** @description Currency code or item template code */
      code: string;
      /** @description Amount or quantity required */
      amount: number;
    };
    /** @description Search criteria for filtering assets with pagination */
    AssetSearchRequest: {
      /** @description Filter by tags (assets must have all specified tags) (null to skip tag filtering) */
      tags?: string[] | null;
      /** @description Filter by asset type */
      assetType: components['schemas']['AssetType'];
      /** @description Filter by game realm */
      realm: components['schemas']['GameRealm'];
      /** @description MIME content type filter (null to skip content type filtering) */
      contentType?: string | null;
      /**
       * @description Maximum number of results to return
       * @default 50
       */
      limit: number;
      /**
       * @description Number of results to skip for pagination
       * @default 0
       */
      offset: number;
    };
    /** @description Paginated results from an asset search query */
    AssetSearchResult: {
      /** @description List of matching assets */
      assets: components['schemas']['AssetMetadata'][];
      /** @description Total number of matching assets */
      total: number;
      /** @description Maximum number of results returned per page */
      limit: number;
      /** @description Number of results skipped */
      offset: number;
    };
    /**
     * @description Defines acceptable asset types for procedural swapping at this node.
     *     Used by procedural generation systems to substitute assets while
     *     maintaining scene coherence.
     */
    AssetSlot: {
      /**
       * @description Category of acceptable assets.
       *     Examples: chair, table, wall_art, floor_lamp
       */
      slotType: string;
      /**
       * @description Tags that acceptable assets must have.
       *     Used for filtering when selecting random variations.
       */
      acceptsTags?: string[];
      /** @description Default asset if no specific asset is bound */
      defaultAsset?: components['schemas']['AssetReference'];
      /**
       * @description Pre-approved asset variations for random selection.
       *     Procedural systems pick from this list rather than searching all assets.
       */
      variations?: components['schemas']['AssetReference'][];
    };
    /**
     * @description Type classification for assets
     * @enum {string}
     */
    AssetType: 'texture' | 'model' | 'audio' | 'behavior' | 'bundle' | 'prefab' | 'other';
    /** @description Information about asset usage */
    AssetUsageInfo: {
      /**
       * Format: uuid
       * @description Scene using the asset
       */
      sceneId: string;
      /** @description Scene name */
      sceneName: string;
      /**
       * Format: uuid
       * @description Node using the asset
       */
      nodeId: string;
      /** @description refId of the node */
      nodeRefId: string;
      /** @description Node name */
      nodeName?: string;
      /** @description Type of the node */
      nodeType?: components['schemas']['NodeType'];
    };
    /** @description Metadata for a specific version of an asset */
    AssetVersion: {
      /** @description Unique version identifier */
      versionId: string;
      /**
       * Format: date-time
       * @description Timestamp when this version was created
       */
      createdAt: string;
      /**
       * Format: int64
       * @description File size in bytes for this version
       */
      size: number;
      /** @description Whether this version is in cold storage */
      isArchived: boolean;
    };
    /** @description Paginated list of asset versions */
    AssetVersionList: {
      /** @description Asset identifier */
      assetId: string;
      /** @description List of asset versions */
      versions: components['schemas']['AssetVersion'][];
      /** @description Total number of versions available */
      total: number;
      /** @description Maximum number of versions returned per page */
      limit: number;
      /** @description Number of versions skipped */
      offset: number;
    };
    /** @description Asset metadata with optional pre-signed download URL */
    AssetWithDownloadUrl: {
      /** @description Unique asset identifier */
      assetId: string;
      /** @description Version identifier for this specific asset version */
      versionId: string;
      /**
       * Format: uri
       * @description Pre-signed download URL (only populated when requested)
       */
      downloadUrl?: string | null;
      /**
       * Format: date-time
       * @description When the download URL expires (only populated when requested)
       */
      expiresAt?: string | null;
      /**
       * Format: int64
       * @description File size in bytes
       */
      size: number;
      /** @description SHA256 hash of file contents */
      contentHash: string;
      /** @description MIME content type */
      contentType: string;
      /** @description Complete asset metadata */
      metadata: components['schemas']['AssetMetadata'];
    };
    /**
     * @description A predefined location where child objects can be attached.
     *     Used for decorating furniture, walls, and other objects with accessories.
     *     Example: A wall may have attachment points for paintings, shelves, or light fixtures.
     */
    AttachmentPoint: {
      /**
       * @description Unique name for this attachment point within the node.
       *     Examples: wall_hook_left, shelf_1, lamp_socket
       */
      name: string;
      /** @description Position and orientation relative to the owning node */
      localTransform: components['schemas']['Transform'];
      /**
       * @description Tags of assets that can attach here.
       *     Examples: wall_decoration, picture_frame, plant
       */
      acceptsTags?: string[];
      /** @description Default asset to display if no specific attachment is specified */
      defaultAsset?: components['schemas']['AssetReference'];
      /**
       * Format: uuid
       * @description ID of the node currently attached at this point (runtime state)
       */
      attachedNodeId?: string | null;
    };
    /** @description Information about a linked authentication method */
    AuthMethodInfo: {
      /**
       * Format: uuid
       * @description Unique identifier for the authentication method
       */
      methodId?: string | null;
      /** @description Authentication provider type */
      provider: components['schemas']['AuthProvider'];
      /** @description External user ID from the authentication provider */
      externalId?: string | null;
      /** @description Display name from the authentication provider */
      displayName?: string | null;
      /**
       * Format: date-time
       * @description Timestamp when the authentication method was linked
       */
      linkedAt: string;
    };
    /**
     * @description All authentication provider types including email
     * @enum {string}
     */
    AuthProvider: 'email' | 'google' | 'discord' | 'twitch' | 'steam';
    /** @description Successful authentication response containing tokens and session information */
    AuthResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the authenticated account
       */
      accountId: string;
      /** @description JWT access token for API authentication */
      accessToken: string;
      /** @description Token used to obtain new access tokens when the current one expires */
      refreshToken: string;
      /** @description Seconds until access token expires */
      expiresIn: number;
      /**
       * Format: uri
       * @description WebSocket endpoint for Connect service
       */
      connectUrl: string;
      /** @description List of roles assigned to the authenticated user */
      roles?: string[] | null;
      /**
       * @description Whether the user needs to complete two-factor authentication
       * @default false
       */
      requiresTwoFactor: boolean;
    };
    /** @description Request to checkout for authoring */
    AuthoringCheckoutRequest: {
      /**
       * Format: uuid
       * @description Region to checkout
       */
      regionId: string;
      /** @description Map kind to checkout */
      kind: components['schemas']['MapKind'];
      /** @description Identifier for the editor/user */
      editorId: string;
    };
    /** @description Checkout response */
    AuthoringCheckoutResponse: {
      /** @description Token for publishing changes (if successful) */
      authorityToken?: string | null;
      /**
       * Format: date-time
       * @description When the checkout expires
       */
      expiresAt?: string | null;
      /** @description Who has the lock (if checkout failed) */
      lockedBy?: string | null;
      /**
       * Format: date-time
       * @description When the lock was acquired (if checkout failed)
       */
      lockedAt?: string | null;
    };
    /** @description Request to commit authoring changes */
    AuthoringCommitRequest: {
      /**
       * Format: uuid
       * @description Region being edited
       */
      regionId: string;
      /** @description Map kind being edited */
      kind: components['schemas']['MapKind'];
      /** @description Checkout authority token */
      authorityToken: string;
      /** @description Optional commit message for history */
      commitMessage?: string | null;
    };
    /** @description Commit response */
    AuthoringCommitResponse: {
      /**
       * Format: int64
       * @description Committed version number
       */
      version?: number | null;
    };
    /** @description Request to release authoring checkout */
    AuthoringReleaseRequest: {
      /**
       * Format: uuid
       * @description Region being edited
       */
      regionId: string;
      /** @description Map kind being edited */
      kind: components['schemas']['MapKind'];
      /** @description Checkout authority token */
      authorityToken: string;
    };
    /** @description Release response */
    AuthoringReleaseResponse: {
      /** @description Whether checkout was released */
      released?: boolean;
    };
    /** @description Configuration for instantiate-on-access behavior */
    AutoSpawnConfig: {
      /**
       * @description If true, accessing a non-existent actor creates it
       * @default false
       */
      enabled: boolean;
      /**
       * @description Regex pattern for actor IDs that trigger auto-spawn.
       *     Examples: "npc-.*" matches "npc-grok", "npc-merchant-123"
       */
      idPattern?: string | null;
      /** @description Maximum auto-spawned instances (0 = unlimited) */
      maxInstances?: number | null;
      /**
       * @description 1-based regex capture group index for extracting CharacterId from actor ID.
       *     Example: With idPattern "npc-brain-([a-f0-9-]+)" and characterIdCaptureGroup: 1,
       *     actor ID "npc-brain-abc-123-def" extracts "abc-123-def" as CharacterId (parsed as GUID).
       */
      characterIdCaptureGroup?: number | null;
    };
    /** @description Autogain status for a balance */
    AutogainInfo: {
      /**
       * Format: date-time
       * @description When autogain was last calculated
       */
      lastCalculatedAt: string;
      /**
       * Format: date-time
       * @description When the next autogain will apply
       */
      nextGainAt: string;
      /**
       * Format: double
       * @description Estimated next gain amount
       */
      nextGainAmount: number;
      /** @description Current autogain mode */
      mode: components['schemas']['AutogainMode'];
    };
    /**
     * @description How autogain (energy/interest) is calculated
     * @enum {string}
     */
    AutogainMode: 'simple' | 'compound';
    /** @description A machine-readable backstory element for behavior system consumption */
    BackstoryElement: {
      /** @description Category of this backstory element */
      elementType: components['schemas']['BackstoryElementType'];
      /**
       * @description Machine-readable key (e.g., "homeland", "trained_by", "past_job").
       *     Used by behavior system to query specific aspects.
       */
      key: string;
      /**
       * @description Machine-readable value (e.g., "northlands", "knights_guild", "blacksmith").
       *     Referenced in behavior rules.
       */
      value: string;
      /**
       * Format: float
       * @description How strongly this element affects behavior (0.0 to 1.0).
       *     Higher strength = greater influence on decisions.
       * @default 0.5
       */
      strength: number;
      /**
       * Format: uuid
       * @description Optional related entity (location, organization, character)
       */
      relatedEntityId?: string | null;
      /** @description Type of the related entity (if any) */
      relatedEntityType?: string | null;
    };
    /** @description Single backstory element */
    BackstoryElementSnapshot: {
      /** @description Type of backstory element (ORIGIN, TRAUMA, GOAL, etc.) */
      elementType: string;
      /** @description Machine-readable key (homeland, past_job, etc.) */
      key: string;
      /** @description Machine-readable value (northlands, blacksmith, etc.) */
      value: string;
      /**
       * Format: float
       * @description How strongly this affects behavior (0.0 to 1.0)
       */
      strength: number;
    };
    /**
     * @description Types of backstory elements. Each type represents a different aspect
     *     of the character's background that influences behavior.
     * @enum {string}
     */
    BackstoryElementType:
      | 'ORIGIN'
      | 'OCCUPATION'
      | 'TRAINING'
      | 'TRAUMA'
      | 'ACHIEVEMENT'
      | 'SECRET'
      | 'GOAL'
      | 'FEAR'
      | 'BELIEF';
    /** @description Complete backstory data for a character */
    BackstoryResponse: {
      /**
       * Format: uuid
       * @description ID of the character this backstory belongs to
       */
      characterId: string;
      /** @description All backstory elements for this character */
      elements: components['schemas']['BackstoryElement'][];
      /**
       * Format: date-time
       * @description When this backstory was first created
       */
      createdAt?: string | null;
      /**
       * Format: date-time
       * @description When this backstory was last modified
       */
      updatedAt?: string | null;
    };
    /** @description Snapshot of backstory for enriched response */
    BackstorySnapshot: {
      /** @description List of backstory elements */
      elements: components['schemas']['BackstoryElementSnapshot'][];
    };
    /** @description A single balance query */
    BalanceQuery: {
      /**
       * Format: uuid
       * @description Wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency definition ID
       */
      currencyDefinitionId: string;
    };
    /** @description Summary of a balance in a wallet */
    BalanceSummary: {
      /**
       * Format: uuid
       * @description Currency definition ID
       */
      currencyDefinitionId: string;
      /** @description Currency code for convenience */
      currencyCode: string;
      /**
       * Format: double
       * @description Total balance amount
       */
      amount: number;
      /**
       * Format: double
       * @description Amount reserved by authorization holds
       */
      lockedAmount: number;
      /**
       * Format: double
       * @description Available balance (amount - lockedAmount)
       */
      effectiveAmount: number;
    };
    /** @description Result of a single balance query in a batch */
    BatchBalanceResult: {
      /**
       * Format: uuid
       * @description Wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency definition ID
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Total balance
       */
      amount: number;
      /**
       * Format: double
       * @description Amount in holds
       */
      lockedAmount: number;
      /**
       * Format: double
       * @description Available balance
       */
      effectiveAmount: number;
    };
    /** @description A single credit operation in a batch */
    BatchCreditOperation: {
      /**
       * Format: uuid
       * @description Target wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to credit
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to credit
       */
      amount: number;
      /** @description Faucet transaction type */
      transactionType: components['schemas']['TransactionType'];
      /** @description Reference type */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference ID
       */
      referenceId?: string | null;
    };
    /** @description Request to credit multiple wallets */
    BatchCreditRequest: {
      /** @description Credit operations to execute */
      operations: components['schemas']['BatchCreditOperation'][];
      /** @description Unique key covering the entire batch */
      idempotencyKey: string;
    };
    /** @description Results of batch credit operations */
    BatchCreditResponse: {
      /** @description Results for each operation */
      results: components['schemas']['BatchCreditResult'][];
    };
    /** @description Result of a single credit in a batch */
    BatchCreditResult: {
      /** @description Index in the operations array */
      index: number;
      /** @description Whether the operation succeeded */
      success: boolean;
      /** @description Transaction record if successful */
      transaction?: components['schemas']['CurrencyTransactionRecord'];
      /** @description Error code if failed */
      error?: string | null;
    };
    /** @description Request to get multiple balances */
    BatchGetBalancesRequest: {
      /** @description Balance queries to execute */
      queries: components['schemas']['BalanceQuery'][];
    };
    /** @description Results of batch balance queries */
    BatchGetBalancesResponse: {
      /** @description Balance results (same order as queries) */
      balances: components['schemas']['BatchBalanceResult'][];
    };
    /** @description Request to get multiple item instances */
    BatchGetItemInstancesRequest: {
      /** @description Instance IDs to retrieve */
      instanceIds: string[];
    };
    /** @description Multiple item instances */
    BatchGetItemInstancesResponse: {
      /** @description Found items */
      items: components['schemas']['ItemInstanceResponse'][];
      /** @description Instance IDs that were not found */
      notFound: string[];
    };
    /** @description Compiled behavior tree data with bytecode or download reference */
    BehaviorTreeData: {
      /** @description Base64-encoded compiled bytecode for the behavior tree */
      bytecode?: string | null;
      /** @description Size of the bytecode in bytes */
      bytecodeSize?: number;
      /** @description URL to download the compiled behavior asset */
      downloadUrl?: string | null;
    };
    /** @description Request to bind an item to a character */
    BindItemInstanceRequest: {
      /**
       * Format: uuid
       * @description Instance ID to bind
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Character to bind the item to
       */
      characterId: string;
      /** @description Type of binding to apply */
      bindType?: components['schemas']['SoulboundType'];
    };
    /** @description Request to bind a Git repository for automatic documentation sync */
    BindRepositoryRequest: {
      /**
       * @description Owner of this binding. NOT a session ID.
       *     For user-initiated bindings: the accountId (UUID format).
       *     For service-initiated bindings: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Documentation namespace to bind */
      namespace: string;
      /** @description Git clone URL (HTTPS for public repos) */
      repositoryUrl: string;
      /**
       * @description Branch to sync from
       * @default main
       */
      branch: string;
      /**
       * @description How often to sync (5 min to 24 hours)
       * @default 60
       */
      syncIntervalMinutes: number;
      /**
       * @description Glob patterns for files to include (defaults to all markdown files if not provided)
       * @default [
       *       "**\/*.md"
       *     ]
       */
      filePatterns: string[] | null;
      /**
       * @description Glob patterns for files to exclude (defaults to common non-content directories if not provided)
       * @default [
       *       ".git/**",
       *       ".obsidian/**",
       *       "node_modules/**"
       *     ]
       */
      excludePatterns: string[] | null;
      /** @description Map directory prefixes to categories (empty mapping if not provided) */
      categoryMapping?: {
        [key: string]: string;
      } | null;
      /** @description Default category for documents without mapping */
      defaultCategory?: components['schemas']['DocumentCategory'];
      /**
       * @description Enable archive functionality
       * @default false
       */
      archiveEnabled: boolean;
      /**
       * @description Create archive after each sync
       * @default false
       */
      archiveOnSync: boolean;
    };
    /** @description Response confirming repository binding creation */
    BindRepositoryResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the repository binding
       */
      bindingId: string;
      /** @description Namespace the repository is bound to */
      namespace: string;
      /** @description URL of the bound repository */
      repositoryUrl?: string;
      /** @description Branch being synced */
      branch?: string;
      /** @description Current status of the binding */
      status: components['schemas']['BindingStatus'];
      /**
       * Format: date-time
       * @description Timestamp when the binding was created
       */
      createdAt?: string;
    };
    /**
     * @description Status of a repository binding
     * @enum {string}
     */
    BindingStatus: 'pending' | 'syncing' | 'synced' | 'error' | 'disabled';
    /** @description An axis-aligned bounding box in 3D space */
    Bounds: {
      /** @description Minimum corner (lowest x, y, z values) */
      min: components['schemas']['Position3D'];
      /** @description Maximum corner (highest x, y, z values) */
      max: components['schemas']['Position3D'];
    };
    /** @description Breach record details */
    BreachResponse: {
      /**
       * Format: uuid
       * @description Unique breach identifier
       */
      breachId: string;
      /**
       * Format: uuid
       * @description Contract that was breached
       */
      contractId: string;
      /**
       * Format: uuid
       * @description Entity that breached
       */
      breachingEntityId: string;
      /** @description Type of breaching entity */
      breachingEntityType: components['schemas']['EntityType'];
      /** @description Type of breach */
      breachType: components['schemas']['BreachType'];
      /** @description What was breached */
      breachedTermOrMilestone?: string | null;
      /** @description Breach description */
      description?: string | null;
      /** @description Current status */
      status: components['schemas']['BreachStatus'];
      /**
       * Format: date-time
       * @description When breach was detected
       */
      detectedAt: string;
      /**
       * Format: date-time
       * @description Deadline to cure breach
       */
      cureDeadline?: string | null;
      /**
       * Format: date-time
       * @description When breach was cured
       */
      curedAt?: string | null;
      /**
       * Format: date-time
       * @description When consequences were applied
       */
      consequencesAppliedAt?: string | null;
    };
    /**
     * @description Current status of a breach record
     * @enum {string}
     */
    BreachStatus:
      | 'detected'
      | 'cure_period'
      | 'cured'
      | 'consequences_applied'
      | 'disputed'
      | 'forgiven';
    /** @description Brief breach information */
    BreachSummary: {
      /**
       * Format: uuid
       * @description Breach ID
       */
      breachId: string;
      /** @description Type of breach */
      breachType: components['schemas']['BreachType'];
      /** @description Current status */
      status: components['schemas']['BreachStatus'];
    };
    /**
     * @description Type of contract breach
     * @enum {string}
     */
    BreachType: 'term_violation' | 'milestone_missed' | 'unauthorized_action' | 'non_payment';
    /** @description Request to retrieve metadata for multiple assets */
    BulkGetAssetsRequest: {
      /** @description Asset IDs to retrieve (max 100) */
      assetIds: string[];
      /**
       * @description Whether to generate pre-signed download URLs
       * @default false
       */
      includeDownloadUrls: boolean;
    };
    /** @description Batch asset metadata response */
    BulkGetAssetsResponse: {
      /** @description Found assets with metadata */
      assets: components['schemas']['AssetWithDownloadUrl'][];
      /** @description Asset IDs that weren't found */
      notFound: string[];
    };
    /**
     * @description Bundle file format
     * @enum {string}
     */
    BundleFormat: 'bannou' | 'zip';
    /** @description Complete metadata for an asset bundle (API response model) */
    BundleInfo: {
      /** @description Human-readable bundle identifier (e.g., "synty/polygon-adventure", "my-bundle-v1") */
      bundleId: string;
      /** @description Whether source or metabundle */
      bundleType: components['schemas']['BundleType'];
      /** @description Bundle content version string */
      version: string;
      /** @description Metadata version number (increments on metadata changes) */
      metadataVersion: number;
      /** @description Human-readable bundle name */
      name?: string | null;
      /** @description Bundle description */
      description?: string | null;
      /** @description Owner account ID or service name (null for system-owned bundles) */
      owner?: string | null;
      /** @description Game realm this bundle belongs to */
      realm: components['schemas']['GameRealm'];
      /** @description Key-value tags for categorization and filtering */
      tags?: {
        [key: string]: string;
      } | null;
      /** @description Bundle lifecycle status */
      status: components['schemas']['BundleLifecycle'];
      /** @description Number of assets in the bundle */
      assetCount: number;
      /**
       * Format: int64
       * @description Bundle file size in bytes (null if not yet calculated)
       */
      sizeBytes?: number | null;
      /**
       * Format: date-time
       * @description When the bundle was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the bundle metadata was last updated
       */
      updatedAt?: string | null;
      /**
       * Format: date-time
       * @description When the bundle was soft-deleted (null if active)
       */
      deletedAt?: string | null;
    };
    /**
     * @description Bundle lifecycle status:
     *     - active: Bundle is available for use
     *     - deleted: Bundle has been soft-deleted (within retention period)
     *     - processing: Bundle is being processed (metabundle creation)
     * @enum {string}
     */
    BundleLifecycle: 'active' | 'deleted' | 'processing';
    /** @description Preview of bundle manifest for validation */
    BundleManifestPreview: {
      /** @description Human-readable bundle identifier from the manifest */
      bundleId: string;
      /** @description Bundle version from the manifest */
      version: string;
      /** @description Number of assets declared in the manifest */
      assetCount: number;
    };
    /** @description Summary information about a bundle */
    BundleSummary: {
      /** @description Human-readable bundle identifier */
      bundleId: string;
      /** @description Source or metabundle */
      bundleType: components['schemas']['BundleType'];
      /** @description Bundle version */
      version: string;
      /** @description Number of assets in bundle */
      assetCount: number;
      /**
       * Format: int64
       * @description Bundle file size
       */
      sizeBytes?: number | null;
      /** @description Game realm */
      realm: components['schemas']['GameRealm'];
      /**
       * Format: date-time
       * @description When the bundle was created
       */
      createdAt?: string | null;
    };
    /**
     * @description Bundle category:
     *     - source: Original bundle (uploaded or server-created from assets)
     *     - metabundle: Composed from other bundles server-side
     * @enum {string}
     */
    BundleType: 'source' | 'metabundle';
    /** @description Request to upload a pre-built asset bundle file */
    BundleUploadRequest: {
      /**
       * @description Owner of this bundle upload. NOT a session ID.
       *     For user-initiated uploads: the accountId (UUID format).
       *     For service-initiated uploads: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Must end with .bannou or .zip */
      filename: string;
      /**
       * Format: int64
       * @description Bundle file size in bytes
       */
      size: number;
      /** @description Optional preview of bundle manifest for validation */
      manifestPreview?: components['schemas']['BundleManifestPreview'] | null;
    };
    /** @description A single version record in bundle history */
    BundleVersionRecord: {
      /** @description Version number */
      version: number;
      /**
       * Format: date-time
       * @description When this version was created
       */
      createdAt: string;
      /** @description Account ID that made the change */
      createdBy: string;
      /** @description List of changes in this version */
      changes: string[];
      /** @description Reason provided for the change */
      reason?: string | null;
      /** @description Full metadata snapshot at this version (only for current version) */
      snapshot?: components['schemas']['BundleInfo'] | null;
    };
    /** @description Bundle metadata combined with a pre-signed download URL */
    BundleWithDownloadUrl: {
      /** @description Human-readable bundle identifier (e.g., "synty/polygon-adventure", "my-bundle-v1") */
      bundleId: string;
      /** @description Bundle version string */
      version: string;
      /**
       * Format: uri
       * @description Pre-signed URL for downloading the bundle
       */
      downloadUrl: string;
      /** @description Format of the downloadable bundle */
      format: components['schemas']['BundleFormat'];
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Bundle file size in bytes
       */
      size: number;
      /** @description Number of assets contained in the bundle */
      assetCount: number;
      /** @description True if ZIP format was served from conversion cache */
      fromCache: boolean;
    };
    /** @description Response containing a previously compiled behavior retrieved from cache */
    CachedBehaviorResponse: {
      /** @description Unique identifier for the cached behavior */
      behaviorId: string;
      /** @description The compiled behavior data retrieved from cache */
      compiledBehavior: components['schemas']['CompiledBehavior'];
      /**
       * Format: date-time
       * @description When the behavior was cached
       */
      cacheTimestamp?: string | null;
      /** @description Whether this was a cache hit or miss */
      cacheHit?: boolean;
    };
    /** @description Information about a cadence */
    CadenceInfo: {
      /**
       * @description Cadence type
       * @enum {string}
       */
      type: 'authentic' | 'half' | 'plagal' | 'deceptive';
      /** @description Chord index where cadence ends */
      position: number;
      /**
       * @description Cadence strength
       * @enum {string|null}
       */
      strength?: 'perfect' | 'imperfect' | null;
    };
    /** @description Request to preview a currency conversion */
    CalculateConversionRequest: {
      /**
       * Format: uuid
       * @description Source currency definition ID
       */
      fromCurrencyId: string;
      /**
       * Format: uuid
       * @description Target currency definition ID
       */
      toCurrencyId: string;
      /**
       * Format: double
       * @description Amount to convert
       */
      fromAmount: number;
    };
    /** @description Conversion preview result */
    CalculateConversionResponse: {
      /**
       * Format: double
       * @description Amount that would be received
       */
      toAmount: number;
      /**
       * Format: double
       * @description Effective conversion rate applied
       */
      effectiveRate: number;
      /** @description Steps in the conversion */
      conversionPath?: components['schemas']['ConversionStep'][];
      /** @description Base currency used for conversion */
      baseCurrency: string;
    };
    /** @description Request to cancel an async metabundle creation job */
    CancelJobRequest: {
      /**
       * Format: uuid
       * @description Job ID from the createMetabundle response
       */
      jobId: string;
    };
    /** @description Result of job cancellation attempt */
    CancelJobResponse: {
      /**
       * Format: uuid
       * @description Job identifier
       */
      jobId: string;
      /** @description Whether the job was successfully cancelled */
      cancelled: boolean;
      /**
       * @description Current job status after cancellation attempt
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed' | 'cancelled';
      /** @description Additional context about the cancellation result */
      message?: string | null;
    };
    /** @description Request to cancel escrow before fully funded */
    CancelRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /** @description Reason for cancellation */
      reason?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from cancelling an escrow */
    CancelResponse: {
      /** @description Cancelled escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Refund results for any deposits */
      refunds: components['schemas']['RefundResult'][];
    };
    /** @description Request to cancel a subscription */
    CancelSubscriptionRequest: {
      /**
       * Format: uuid
       * @description ID of the subscription to cancel
       */
      subscriptionId: string;
      /** @description Optional reason for cancellation */
      reason?: string | null;
    };
    /**
     * @description What happens when a credit would exceed the wallet cap
     * @enum {string}
     */
    CapOverflowBehavior: 'reject' | 'cap_and_lose' | 'cap_and_return';
    /** @description Request to capture (finalize) a hold */
    CaptureHoldRequest: {
      /**
       * Format: uuid
       * @description Hold ID to capture
       */
      holdId: string;
      /**
       * Format: double
       * @description Final amount to debit (may be less than hold amount)
       */
      captureAmount: number;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Result of hold capture */
    CaptureHoldResponse: {
      /** @description Updated hold record */
      hold: components['schemas']['HoldRecord'];
      /** @description Debit transaction */
      transaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Balance after capture
       */
      newBalance: number;
      /**
       * Format: double
       * @description Difference between hold and capture (released back)
       */
      amountReleased: number;
    };
    /**
     * @description Compressed archive of a dead character.
     *     Contains text summaries instead of structured data for long-term storage.
     *     Self-contained with no external references (suitable for cleanup).
     */
    CharacterArchive: {
      /**
       * Format: uuid
       * @description Original character ID
       */
      characterId: string;
      /** @description Character display name */
      name: string;
      /**
       * Format: uuid
       * @description Realm the character belonged to
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Character's species
       */
      speciesId: string;
      /**
       * Format: date-time
       * @description In-game birth date
       */
      birthDate: string;
      /**
       * Format: date-time
       * @description In-game death date
       */
      deathDate: string;
      /**
       * Format: date-time
       * @description When this archive was created
       */
      compressedAt: string;
      /**
       * @description Text summary of personality traits.
       *     Example: "Brave and loyal, somewhat hot-tempered with a strong sense of justice"
       */
      personalitySummary?: string | null;
      /**
       * @description Key backstory elements as text.
       *     Example: ["Trained by the Knights Guild", "Born in the Northlands"]
       */
      keyBackstoryPoints?: string[];
      /**
       * @description Significant life events as text.
       *     Example: ["Fought in the Battle of Stormgate (Hero)", "Survived the Great Flood"]
       */
      majorLifeEvents?: string[];
      /**
       * @description Text summary of family relationships.
       *     Example: "Father of 3, married to Elena, orphaned at young age"
       */
      familySummary?: string | null;
    };
    /** @description Context information about a character for behavior resolution */
    CharacterContext: {
      /**
       * @description Unique identifier for the NPC
       * @example npc_12345
       */
      npcId?: string | null;
      /**
       * @description Cultural background identifier
       * @example european_medieval
       */
      culture?: string | null;
      /**
       * @description Character profession identifier
       * @example blacksmith
       */
      profession?: string | null;
      /**
       * @description Character statistics and attributes
       * @example {
       *       "energy": 0.8,
       *       "health": 1,
       *       "hunger": 0.3
       *     }
       */
      stats?: {
        [key: string]: number;
      } | null;
      /**
       * @description Character skill levels
       * @example {
       *       "blacksmithing": 85,
       *       "trading": 42
       *     }
       */
      skills?: {
        [key: string]: number;
      } | null;
      /** @description Current location information for the character */
      location?: components['schemas']['Location'];
      /** @description Relationship values with other characters */
      relationships?: {
        [key: string]: number;
      } | null;
      /** @description Relevant world state information */
      worldState?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Paginated list of characters with metadata for navigation */
    CharacterListResponse: {
      /** @description List of characters matching the query */
      characters: components['schemas']['CharacterResponse'][];
      /** @description Total number of characters matching the filter criteria */
      totalCount: number;
      /** @description Current page number (1-based) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more results after this page */
      hasNextPage?: boolean;
      /** @description Whether there are results before this page */
      hasPreviousPage?: boolean;
    };
    /** @description Complete character data returned from character operations */
    CharacterResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the character
       */
      characterId: string;
      /** @description Display name of the character */
      name: string;
      /**
       * Format: uuid
       * @description Realm ID (partition key)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Species ID (foreign key to Species service)
       */
      speciesId: string;
      /**
       * Format: date-time
       * @description In-game birth timestamp
       */
      birthDate: string;
      /**
       * Format: date-time
       * @description In-game death timestamp
       */
      deathDate?: string | null;
      /** @description Current lifecycle status of the character */
      status: components['schemas']['CharacterStatus'];
      /**
       * Format: date-time
       * @description Real-world creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Real-world last update timestamp
       */
      updatedAt?: string | null;
    };
    /**
     * @description Character lifecycle status
     * @enum {string}
     */
    CharacterStatus: 'alive' | 'dead' | 'dormant';
    /** @description Request to send a chat message to players in a game session */
    ChatMessageRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the sender. Provided by shortcut system.
       */
      sessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the sender. Provided by shortcut system.
       */
      accountId: string;
      /** @description Game type for the chat. Determines which lobby's players receive the message. Provided by shortcut system. */
      gameType: string;
      /** @description Content of the chat message */
      message: string;
      /**
       * @description Type of message (public to all, whisper to one player, or system announcement)
       * @default public
       */
      messageType: components['schemas']['ChatMessageType'];
      /**
       * Format: uuid
       * @description For whisper messages
       */
      targetPlayerId?: string | null;
    };
    /**
     * @description Type of chat message
     * @enum {string}
     */
    ChatMessageType: 'public' | 'whisper' | 'system';
    /** @description Request to check asset requirement clauses */
    CheckAssetRequirementsRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractInstanceId: string;
    };
    /** @description Response from checking asset requirements */
    CheckAssetRequirementsResponse: {
      /** @description Whether all requirements across all parties are satisfied */
      allSatisfied: boolean;
      /** @description Status broken down by party */
      byParty: components['schemas']['PartyAssetRequirementStatus'][];
    };
    /** @description Request to check constraint */
    CheckConstraintRequest: {
      /**
       * Format: uuid
       * @description Entity to check
       */
      entityId: string;
      /** @description Entity type */
      entityType: components['schemas']['EntityType'];
      /** @description Type of constraint to check */
      constraintType: components['schemas']['ConstraintType'];
      /** @description What the entity wants to do */
      proposedAction?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Constraint check result */
    CheckConstraintResponse: {
      /** @description Whether action is allowed */
      allowed: boolean;
      /** @description Contracts that would be violated */
      conflictingContracts?: components['schemas']['ContractSummary'][] | null;
      /** @description Explanation if not allowed */
      reason?: string | null;
    };
    /** @description Request to checkout a scene for editing */
    CheckoutRequest: {
      /**
       * Format: uuid
       * @description Scene to checkout
       */
      sceneId: string;
      /** @description Optional editor identifier (defaults to caller identity) */
      editorId?: string | null;
      /** @description Custom lock TTL (uses default if not specified) */
      ttlMinutes?: number | null;
    };
    /** @description Response containing checkout token and scene */
    CheckoutResponse: {
      /** @description Token required for commit/discard/heartbeat */
      checkoutToken: string;
      /** @description Current scene document */
      scene: components['schemas']['Scene'];
      /**
       * Format: date-time
       * @description When the checkout lock expires
       */
      expiresAt: string;
    };
    /** @description A chord with timing information */
    ChordEvent: {
      /** @description Chord symbol */
      chord: components['schemas']['ChordSymbol'];
      /** @description Start position in ticks */
      startTick: number;
      /** @description Duration in ticks */
      durationTicks: number;
      /** @description Roman numeral analysis (e.g., "IV", "V7") */
      romanNumeral?: string | null;
    };
    /** @description A chord symbol with root and quality */
    ChordSymbol: {
      /** @description Chord root */
      root: components['schemas']['PitchClass'];
      /**
       * @description Chord quality
       * @enum {string}
       */
      quality:
        | 'major'
        | 'minor'
        | 'diminished'
        | 'augmented'
        | 'dominant7'
        | 'major7'
        | 'minor7'
        | 'diminished7'
        | 'halfDiminished7'
        | 'augmented7'
        | 'sus2'
        | 'sus4';
      /** @description Bass note (for inversions/slash chords) */
      bass?: components['schemas']['PitchClass'];
      /** @description Chord extensions (e.g., "9", "11", "13") */
      extensions?: string[] | null;
    };
    /** @description Status of a single clause's asset requirements */
    ClauseAssetStatus: {
      /** @description Clause identifier */
      clauseId: string;
      /** @description Whether requirement is satisfied */
      satisfied: boolean;
      /** @description What the clause requires */
      required: components['schemas']['AssetRequirementInfo'];
      /** @description Current amount present */
      current: number;
      /** @description Amount still needed (0 if satisfied) */
      missing: number;
    };
    /**
     * @description Category of clause type
     * @enum {string}
     */
    ClauseCategory: 'validation' | 'execution' | 'both';
    /** @description Summary of a clause type */
    ClauseTypeSummary: {
      /** @description Unique identifier */
      typeCode: string;
      /** @description Human-readable description */
      description: string;
      /** @description Clause category */
      category: components['schemas']['ClauseCategory'];
      /** @description Whether a validation handler is registered */
      hasValidationHandler: boolean;
      /** @description Whether an execution handler is registered */
      hasExecutionHandler: boolean;
      /** @description Whether this is a built-in type */
      isBuiltIn: boolean;
    };
    /** @description Response containing the client's capability manifest with available API endpoints and shortcuts */
    ClientCapabilitiesResponse: {
      /**
       * Format: uuid
       * @description Session ID this capability manifest belongs to
       */
      sessionId: string;
      /** @description Available API capabilities for this client */
      capabilities: components['schemas']['ClientCapability'][];
      /**
       * @description Pre-bound API calls available for this session.
       *     Shortcuts are invoked like normal capabilities but Connect injects
       *     a pre-bound payload instead of using the client's payload.
       */
      shortcuts?: components['schemas']['ClientShortcut'][] | null;
      /** @description Capability manifest version (increments on changes) */
      version: number;
      /**
       * Format: date-time
       * @description When this capability manifest was generated
       */
      generatedAt: string;
      /**
       * Format: date-time
       * @description When these capabilities expire and need refresh
       */
      expiresAt?: string | null;
    };
    /** @description A single API capability available to the client, mapping a client-salted GUID to a service endpoint */
    ClientCapability: {
      /**
       * Format: uuid
       * @description Client-salted GUID for this API endpoint (unique per session)
       */
      guid: string;
      /** @description Service name (e.g., "account", "auth") */
      service: string;
      /** @description API endpoint path (e.g., "/account/create") */
      endpoint: string;
      /**
       * @description HTTP method for this endpoint
       * @enum {string}
       */
      method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
      /** @description Human-readable description of this capability */
      description?: string | null;
      /**
       * Format: uint16
       * @description Preferred WebSocket channel for this capability
       * @default 0
       */
      channel: number;
    };
    /**
     * @description Session shortcut information sent to clients in the capability manifest.
     *     Shortcuts appear as invocable capabilities but Connect injects a pre-bound
     *     payload when the shortcut GUID is used, replacing any client-provided payload.
     */
    ClientShortcut: {
      /**
       * Format: uuid
       * @description GUID to use in WebSocket message header when invoking this shortcut.
       *     Uses UUID version 7 bits to distinguish from regular service GUIDs (version 5).
       */
      guid: string;
      /** @description The service this shortcut invokes (for client display purposes). */
      targetService: string;
      /** @description The endpoint this shortcut invokes (for client display purposes). */
      targetEndpoint: string;
      /** @description Machine-readable shortcut identifier (e.g., "get_my_stats", "join_game"). */
      name: string;
      /** @description Human-readable description of what this shortcut does. */
      description?: string | null;
      /** @description User-friendly name for display in client UIs. */
      displayName?: string | null;
      /** @description The service that created this shortcut. */
      sourceService?: string | null;
      /** @description Categorization tags for client-side organization. */
      tags?: string[] | null;
      /**
       * Format: date-time
       * @description When this shortcut expires (if time-limited).
       */
      expiresAt?: string | null;
    };
    /** @description Request to collapse a delta chain into a full snapshot */
    CollapseDeltasRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the save slot
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Name of the slot containing deltas to collapse */
      slotName: string;
      /** @description Version to collapse to (latest if null) */
      versionNumber?: number | null;
      /**
       * @description Delete intermediate delta versions after collapse
       * @default true
       */
      deleteIntermediates: boolean;
    };
    /**
     * @description Combat behavior preferences that influence tactical decisions.
     *     These values affect GOAP action selection, retreat conditions,
     *     and group coordination behavior.
     */
    CombatPreferences: {
      /** @description Overall combat approach */
      style: components['schemas']['CombatStyle'];
      /** @description Preferred engagement distance */
      preferredRange: components['schemas']['PreferredRange'];
      /** @description Role when fighting in groups */
      groupRole: components['schemas']['GroupRole'];
      /**
       * Format: float
       * @description Willingness to take dangerous actions (0.0 = very cautious, 1.0 = reckless).
       *     Affects ability selection and target prioritization.
       */
      riskTolerance: number;
      /**
       * Format: float
       * @description Health percentage at which retreat is considered (0.0 = fight to death,
       *     0.5 = retreat at half health, 1.0 = retreat at any damage).
       */
      retreatThreshold: number;
      /**
       * @description Whether to prioritize ally protection over self-preservation.
       *     Affects target selection and positioning decisions.
       */
      protectAllies: boolean;
    };
    /** @description Combat preferences profile for behavior system consumption */
    CombatPreferencesResponse: {
      /**
       * Format: uuid
       * @description Character these preferences belong to
       */
      characterId: string;
      /** @description The combat preferences values */
      preferences: components['schemas']['CombatPreferences'];
      /** @description Preferences version number (increments on each evolution) */
      version: number;
      /**
       * Format: date-time
       * @description When these preferences were first created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When these preferences were last modified
       */
      updatedAt?: string | null;
    };
    /** @description Snapshot of combat preferences for enriched response */
    CombatPreferencesSnapshot: {
      /** @description Combat style (DEFENSIVE, BALANCED, AGGRESSIVE, BERSERKER, TACTICAL) */
      style: string;
      /** @description Preferred engagement distance (MELEE, CLOSE, MEDIUM, RANGED) */
      preferredRange: string;
      /** @description Role in group combat (FRONTLINE, SUPPORT, FLANKER, LEADER, SOLO) */
      groupRole: string;
      /**
       * Format: float
       * @description Willingness to take risky actions (0.0 to 1.0)
       */
      riskTolerance: number;
      /**
       * Format: float
       * @description Health percentage at which retreat is considered (0.0 to 1.0)
       */
      retreatThreshold: number;
      /** @description Whether to prioritize ally protection */
      protectAllies: boolean;
    };
    /**
     * @description Overall approach to combat situations. Affects target selection,
     *     ability usage, and engagement decisions.
     * @enum {string}
     */
    CombatStyle: 'DEFENSIVE' | 'BALANCED' | 'AGGRESSIVE' | 'BERSERKER' | 'TACTICAL';
    /** @description Request to commit checkout changes */
    CommitRequest: {
      /**
       * Format: uuid
       * @description Scene being committed
       */
      sceneId: string;
      /** @description Checkout token from checkout response */
      checkoutToken: string;
      /** @description Updated scene document */
      scene: components['schemas']['Scene'];
      /** @description Optional summary of changes for audit */
      changesSummary?: string | null;
    };
    /** @description Response confirming commit */
    CommitResponse: {
      /** @description Whether commit was successful */
      committed: boolean;
      /** @description New version after commit */
      newVersion: string;
      /** @description Committed scene with updated metadata */
      scene?: components['schemas']['Scene'];
    };
    /**
     * @description Comparison operators for numeric conditions
     * @enum {string}
     */
    ComparisonOperator: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte';
    /** @description Options controlling the ABML compilation process including optimizations and caching */
    CompilationOptions: {
      /**
       * @description Enable behavior tree optimizations
       * @default true
       */
      enableOptimizations: boolean;
      /**
       * @description Cache the compiled behavior for reuse
       * @default true
       */
      cacheCompiledResult: boolean;
      /**
       * @description Enable strict validation mode
       * @default false
       */
      strictValidation: boolean;
      /**
       * @description Apply cultural adaptations during compilation
       * @default true
       */
      culturalAdaptations: boolean;
      /**
       * @description Generate GOAP goals from behaviors
       * @default true
       */
      goapIntegration: boolean;
    };
    /** @description Request to compile an ABML behavior definition into executable behavior trees */
    CompileBehaviorRequest: {
      /**
       * @description Raw ABML YAML content to compile
       * @example version: "1.0.0"
       *     metadata:
       *       id: "example_behavior"
       *       category: "basic"
       *     behaviors:
       *       example:
       *         triggers:
       *           - condition: "true"
       *         actions:
       *           - log:
       *               message: "Hello World"
       */
      abmlContent: string;
      /**
       * @description Optional human-readable name for the behavior.
       *     If not provided, extracted from ABML metadata.id or generated from content hash.
       * @example blacksmith_daily_routine
       */
      behaviorName?: string | null;
      /**
       * @description Category for organizing behaviors (e.g., profession, cultural, situational).
       *     Used for filtering and grouping in bundles.
       * @example professional
       * @enum {string|null}
       */
      behaviorCategory?:
        | 'base'
        | 'cultural'
        | 'professional'
        | 'personal'
        | 'situational'
        | 'ambient'
        | null;
      /**
       * @description Optional bundle identifier for grouping related behaviors.
       *     When specified, the compiled behavior will be added to a bundle with this ID.
       *     Clients can then download entire bundles for efficient bulk loading.
       *     If the bundle doesn't exist, it will be created.
       * @example blacksmith-behaviors-v1
       */
      bundleId?: string | null;
      /** @description Character context for context variable resolution during compilation */
      characterContext?: components['schemas']['CharacterContext'];
      /** @description Options controlling the compilation process */
      compilationOptions?: components['schemas']['CompilationOptions'];
    };
    /** @description Response containing the results of an ABML behavior compilation */
    CompileBehaviorResponse: {
      /**
       * @description Unique identifier for the compiled behavior (content-addressable hash)
       * @example behavior-a1b2c3d4e5f6g7h8
       */
      behaviorId: string;
      /**
       * @description Human-readable name of the behavior
       * @example blacksmith_daily_routine
       */
      behaviorName?: string | null;
      /** @description The compiled behavior data including behavior tree and metadata */
      compiledBehavior?: components['schemas']['CompiledBehavior'];
      /** @description Time taken to compile the behavior in milliseconds */
      compilationTimeMs?: number;
      /** @description Asset service ID where the compiled bytecode is stored. Null only when caching is explicitly disabled. */
      assetId?: string | null;
      /** @description Bundle ID if the behavior was added to a bundle. Null if not bundled. */
      bundleId?: string | null;
      /** @description True if this replaced an existing behavior with the same content hash */
      isUpdate?: boolean;
      /** @description Non-fatal warnings during compilation */
      warnings?: string[] | null;
    };
    /** @description Compiled behavior containing behavior tree, context schema, and GOAP integration data */
    CompiledBehavior: {
      /** @description Compiled behavior tree data with bytecode or download reference */
      behaviorTree: components['schemas']['BehaviorTreeData'];
      /** @description Schema defining required context variables for execution */
      contextSchema: components['schemas']['ContextSchemaData'];
      /** @description List of required services for this behavior */
      serviceDependencies?: string[] | null;
      /** @description GOAP goals extracted from the behavior */
      goapGoals?: components['schemas']['GoapGoal'][] | null;
      /** @description Metadata for behavior execution including performance hints and resource requirements */
      executionMetadata?: components['schemas']['ExecutionMetadata'];
    };
    /** @description Request to complete a milestone */
    CompleteMilestoneRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Milestone to complete */
      milestoneCode: string;
      /** @description Evidence of completion */
      evidence?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to finalize an upload and trigger asset processing */
    CompleteUploadRequest: {
      /**
       * Format: uuid
       * @description Upload session ID from requestUpload
       */
      uploadId: string;
      /** @description For multipart uploads - ETags of completed parts (null for single-file uploads) */
      parts?: components['schemas']['CompletedPart'][] | null;
    };
    /** @description Information about a completed part in a multipart upload */
    CompletedPart: {
      /** @description Part number (1-based) */
      partNumber: number;
      /** @description ETag returned from part upload */
      etag: string;
    };
    /** @description Metadata about a generated composition */
    CompositionMetadata: {
      /** @description Style used */
      styleId?: string | null;
      /** @description Key signature */
      key?: components['schemas']['KeySignature'];
      /** @description Tempo in BPM */
      tempo?: number | null;
      /** @description Number of bars */
      bars?: number | null;
      /** @description Tune type if applicable */
      tuneType?: string | null;
      /** @description Random seed used */
      seed?: number | null;
    };
    /**
     * @description Compression algorithm for bundles
     * @enum {string}
     */
    CompressionType: 'lz4' | 'lzma' | 'none';
    /** @description A bundle entry in an asset conflict */
    ConflictingBundleEntry: {
      /** @description Bundle containing this version */
      bundleId: string;
      /** @description Content hash of asset in this bundle */
      contentHash: string;
    };
    /** @description Request to record party consent for release or refund */
    ConsentRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Party giving consent
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Type of consent being given */
      consentType: components['schemas']['EscrowConsentType'];
      /** @description Release token (required for full_consent) */
      releaseToken?: string | null;
      /** @description Optional notes */
      notes?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from recording party consent */
    ConsentResponse: {
      /** @description Updated escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Whether consent was recorded */
      consentRecorded: boolean;
      /** @description Whether this consent triggered completion */
      triggered: boolean;
      /** @description New escrow status after consent */
      newStatus: components['schemas']['EscrowStatus'];
    };
    /**
     * @description Party's consent status
     * @enum {string}
     */
    ConsentStatus: 'pending' | 'consented' | 'declined' | 'implicit';
    /** @description Request to consent to a contract */
    ConsentToContractRequest: {
      /**
       * Format: uuid
       * @description Contract to consent to
       */
      contractId: string;
      /**
       * Format: uuid
       * @description Entity ID of consenting party
       */
      partyEntityId: string;
      /** @description Entity type of consenting party */
      partyEntityType: components['schemas']['EntityType'];
    };
    /**
     * @description Type of constraint to check
     * @enum {string}
     */
    ConstraintType: 'exclusivity' | 'non_compete' | 'territory' | 'time_commitment';
    /** @description User-submitted contact form data */
    ContactRequest: {
      /**
       * Format: email
       * @description Sender email address for replies
       */
      email: string;
      /** @description Name of the person submitting the form */
      name?: string | null;
      /** @description Subject line of the contact message */
      subject: string;
      /** @description Body content of the contact message */
      message: string;
      /**
       * @description Category to route the contact request
       * @default general
       * @enum {string}
       */
      category: 'general' | 'support' | 'bug' | 'feedback' | 'business';
    };
    /** @description Confirmation response after submitting a contact form */
    ContactResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the created support ticket
       */
      ticketId: string;
      /**
       * @description Confirmation message displayed to the user
       * @default Thank you for contacting us. We will respond within 24-48 hours.
       */
      message: string;
    };
    /**
     * @description Container capacity constraint type
     * @enum {string}
     */
    ContainerConstraintModel:
      | 'slot_only'
      | 'weight_only'
      | 'slot_and_weight'
      | 'grid'
      | 'volumetric'
      | 'unlimited';
    /** @description Item in a container */
    ContainerItem: {
      /**
       * Format: uuid
       * @description Item instance ID
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Item template ID
       */
      templateId: string;
      /**
       * Format: double
       * @description Item quantity
       */
      quantity: number;
      /** @description Slot position */
      slotIndex?: number | null;
      /** @description Grid X position */
      slotX?: number | null;
      /** @description Grid Y position */
      slotY?: number | null;
      /** @description Rotated in grid */
      rotated?: boolean | null;
    };
    /**
     * @description Type of entity that owns this container
     * @enum {string}
     */
    ContainerOwnerType:
      | 'character'
      | 'account'
      | 'location'
      | 'vehicle'
      | 'guild'
      | 'escrow'
      | 'mail'
      | 'other';
    /** @description Container details */
    ContainerResponse: {
      /**
       * Format: uuid
       * @description Container unique identifier
       */
      containerId: string;
      /**
       * Format: uuid
       * @description Owner entity ID
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['ContainerOwnerType'];
      /** @description Container type */
      containerType: string;
      /** @description Constraint model */
      constraintModel: components['schemas']['ContainerConstraintModel'];
      /** @description Whether this is an equipment slot */
      isEquipmentSlot: boolean;
      /** @description Equipment slot name */
      equipmentSlotName?: string | null;
      /** @description Maximum slots */
      maxSlots?: number | null;
      /** @description Current used slots */
      usedSlots?: number | null;
      /**
       * Format: double
       * @description Maximum weight
       */
      maxWeight?: number | null;
      /** @description Internal grid width */
      gridWidth?: number | null;
      /** @description Internal grid height */
      gridHeight?: number | null;
      /**
       * Format: double
       * @description Maximum volume
       */
      maxVolume?: number | null;
      /**
       * Format: double
       * @description Current volume used
       */
      currentVolume?: number | null;
      /**
       * Format: uuid
       * @description Parent container ID
       */
      parentContainerId?: string | null;
      /** @description Depth in container hierarchy */
      nestingDepth: number;
      /** @description Whether can hold containers */
      canContainContainers: boolean;
      /** @description Max nesting depth */
      maxNestingDepth?: number | null;
      /**
       * Format: double
       * @description Empty container weight
       */
      selfWeight: number;
      /** @description Weight propagation mode */
      weightContribution: components['schemas']['WeightContribution'];
      /** @description Slots used in parent */
      slotCost: number;
      /** @description Width in parent grid */
      parentGridWidth?: number | null;
      /** @description Height in parent grid */
      parentGridHeight?: number | null;
      /**
       * Format: double
       * @description Volume in parent
       */
      parentVolume?: number | null;
      /**
       * Format: double
       * @description Weight of direct contents
       */
      contentsWeight: number;
      /**
       * Format: double
       * @description Total weight including self
       */
      totalWeight: number;
      /** @description Allowed categories */
      allowedCategories?: string[] | null;
      /** @description Forbidden categories */
      forbiddenCategories?: string[] | null;
      /** @description Required tags */
      allowedTags?: string[] | null;
      /**
       * Format: uuid
       * @description Realm ID
       */
      realmId?: string | null;
      /** @description Container tags */
      tags?: string[];
      /** @description Game-specific data */
      metadata?: Record<string, never> | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last modification
       */
      modifiedAt?: string | null;
    };
    /** @description Container with item contents */
    ContainerWithContentsResponse: {
      /** @description Container details */
      container: components['schemas']['ContainerResponse'];
      /** @description Items in container */
      items: components['schemas']['ContainerItem'][];
    };
    /** @description Schema defining required context variables for behavior execution */
    ContextSchemaData: {
      [key: string]: unknown;
    };
    /** @description Contract instance details */
    ContractInstanceResponse: {
      /**
       * Format: uuid
       * @description Unique contract identifier
       */
      contractId: string;
      /**
       * Format: uuid
       * @description Source template ID
       */
      templateId: string;
      /** @description Source template code */
      templateCode?: string;
      /** @description Current contract status */
      status: components['schemas']['ContractStatus'];
      /** @description Contract parties */
      parties: components['schemas']['ContractPartyResponse'][];
      /** @description Contract terms */
      terms?: components['schemas']['ContractTerms'];
      /** @description Milestone progress */
      milestones?: components['schemas']['MilestoneInstanceResponse'][] | null;
      /** @description Index of current milestone */
      currentMilestoneIndex?: number | null;
      /** @description Related escrow IDs */
      escrowIds?: string[] | null;
      /**
       * Format: date-time
       * @description When contract was proposed
       */
      proposedAt?: string | null;
      /**
       * Format: date-time
       * @description When all parties consented
       */
      acceptedAt?: string | null;
      /**
       * Format: date-time
       * @description When contract became active
       */
      effectiveFrom?: string | null;
      /**
       * Format: date-time
       * @description When contract expires
       */
      effectiveUntil?: string | null;
      /**
       * Format: date-time
       * @description When contract was terminated
       */
      terminatedAt?: string | null;
      /** @description Game-specific metadata */
      gameMetadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last update timestamp
       */
      updatedAt?: string | null;
    };
    /** @description Contract status summary */
    ContractInstanceStatusResponse: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Current status */
      status: components['schemas']['ContractStatus'];
      /** @description Milestone progress summary */
      milestoneProgress: components['schemas']['MilestoneProgressSummary'][];
      /** @description Parties who haven't consented */
      pendingConsents?: components['schemas']['PendingConsentSummary'][] | null;
      /** @description Active breach records */
      activeBreaches?: components['schemas']['BreachSummary'][] | null;
      /** @description Days until natural expiration */
      daysUntilExpiration?: number | null;
    };
    /** @description Contract metadata */
    ContractMetadataResponse: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Instance-level metadata */
      instanceData?: {
        [key: string]: unknown;
      } | null;
      /** @description Runtime state metadata */
      runtimeState?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Party input for contract creation */
    ContractPartyInput: {
      /**
       * Format: uuid
       * @description Entity ID
       */
      entityId: string;
      /** @description Entity type */
      entityType: components['schemas']['EntityType'];
      /** @description Role from template */
      role: string;
    };
    /** @description Contract party details */
    ContractPartyResponse: {
      /**
       * Format: uuid
       * @description Entity ID
       */
      entityId: string;
      /** @description Entity type */
      entityType: components['schemas']['EntityType'];
      /** @description Role in contract */
      role: string;
      /** @description Consent status */
      consentStatus: components['schemas']['ConsentStatus'];
      /**
       * Format: date-time
       * @description When consent was given
       */
      consentedAt?: string | null;
    };
    /**
     * @description Current status of a contract instance
     * @enum {string}
     */
    ContractStatus:
      | 'draft'
      | 'proposed'
      | 'pending'
      | 'active'
      | 'fulfilled'
      | 'expired'
      | 'terminated'
      | 'breached'
      | 'suspended'
      | 'disputed'
      | 'declined';
    /** @description Brief contract information */
    ContractSummary: {
      /**
       * Format: uuid
       * @description Contract ID
       */
      contractId: string;
      /** @description Template code */
      templateCode: string;
      /** @description Template name */
      templateName?: string | null;
      /** @description Current status */
      status: components['schemas']['ContractStatus'];
      /** @description Entity's role in contract */
      role: string;
      /**
       * Format: date-time
       * @description When contract expires
       */
      effectiveUntil?: string | null;
    };
    /** @description Contract template details */
    ContractTemplateResponse: {
      /**
       * Format: uuid
       * @description Unique template identifier
       */
      templateId: string;
      /** @description Unique template code */
      code: string;
      /** @description Human-readable name */
      name: string;
      /** @description Detailed description */
      description?: string | null;
      /**
       * Format: uuid
       * @description Realm ID if realm-specific
       */
      realmId?: string | null;
      /** @description Minimum parties required */
      minParties: number;
      /** @description Maximum parties allowed */
      maxParties: number;
      /** @description Party role definitions */
      partyRoles: components['schemas']['PartyRoleDefinition'][];
      /** @description Default contract terms */
      defaultTerms?: components['schemas']['ContractTerms'];
      /** @description Milestone definitions */
      milestones?: components['schemas']['MilestoneDefinition'][] | null;
      /** @description Default enforcement mode */
      defaultEnforcementMode: components['schemas']['EnforcementMode'];
      /** @description Whether contracts can be transferred */
      transferable?: boolean;
      /** @description Game-specific metadata */
      gameMetadata?: {
        [key: string]: unknown;
      } | null;
      /** @description Whether template is active */
      isActive: boolean;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last update timestamp
       */
      updatedAt?: string | null;
    };
    /** @description Configurable contract terms */
    ContractTerms: {
      /** @description Contract duration (ISO 8601 duration, null for perpetual) */
      duration?: string | null;
      /** @description When payments occur */
      paymentSchedule?: components['schemas']['PaymentSchedule'];
      /** @description Recurring payment frequency (ISO 8601 duration) */
      paymentFrequency?: string | null;
      /** @description How contract can be terminated */
      terminationPolicy?: components['schemas']['TerminationPolicy'];
      /** @description Required notice for termination (ISO 8601 duration) */
      terminationNoticePeriod?: string | null;
      /** @description Breaches before auto-termination (0 for no auto) */
      breachThreshold?: number | null;
      /** @description Time to cure breach (ISO 8601 duration) */
      gracePeriodForCure?: string | null;
      /** @description Game-specific custom terms */
      customTerms?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description A step in the conversion path */
    ConversionStep: {
      /** @description Source currency code */
      from: string;
      /** @description Target currency code */
      to: string;
      /**
       * Format: double
       * @description Rate applied in this step
       */
      rate: number;
    };
    /** @description 3D spatial coordinates representing a position in the game world */
    Coordinates: {
      /** @description X coordinate position */
      x?: number;
      /** @description Y coordinate position */
      y?: number;
      /** @description Z coordinate position */
      z?: number;
    };
    /** @description Request to copy save data from one slot to another, optionally across different entities or games. */
    CopySaveRequest: {
      /** @description Game identifier of the source save */
      sourceGameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the source save
       */
      sourceOwnerId: string;
      /** @description Type of entity that owns the source save */
      sourceOwnerType: components['schemas']['OwnerType'];
      /** @description Name of the source slot to copy from */
      sourceSlotName: string;
      /** @description Version to copy (latest if null) */
      sourceVersion?: number | null;
      /** @description Game identifier for the target save */
      targetGameId: string;
      /**
       * Format: uuid
       * @description Entity ID that will own the copied save
       */
      targetOwnerId: string;
      /** @description Type of entity that will own the copied save */
      targetOwnerType: components['schemas']['OwnerType'];
      /** @description Name of the target slot to copy to */
      targetSlotName: string;
      /** @description Category for new slot if auto-created */
      targetCategory?: components['schemas']['SaveCategory'];
    };
    /** @description Request to count items */
    CountItemsRequest: {
      /**
       * Format: uuid
       * @description Owner to count for
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['ContainerOwnerType'];
      /**
       * Format: uuid
       * @description Template to count
       */
      templateId: string;
    };
    /** @description Count result */
    CountItemsResponse: {
      /**
       * Format: uuid
       * @description Counted template
       */
      templateId: string;
      /**
       * Format: double
       * @description Total quantity
       */
      totalQuantity: number;
      /** @description Number of stacks */
      stackCount: number;
    };
    /** @description Statistics about asset resolution coverage */
    CoverageAnalysis: {
      /** @description Total number of assets requested */
      totalRequested: number;
      /** @description Assets resolved through bundle downloads */
      resolvedViaBundles: number;
      /** @description Assets resolved as standalone downloads */
      resolvedStandalone: number;
      /** @description Assets that could not be found */
      unresolvedCount: number;
      /**
       * Format: float
       * @description Ratio of assets provided to bundle downloads (higher is better)
       */
      bundleEfficiency?: number | null;
    };
    /** @description Request to create a new achievement */
    CreateAchievementDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service owning this achievement
       */
      gameServiceId: string;
      /** @description Unique identifier for this achievement (lowercase, no spaces) */
      achievementId: string;
      /** @description Human-readable name */
      displayName: string;
      /** @description Description of how to earn this achievement */
      description: string;
      /** @description Description shown before achievement is earned (for hidden types) */
      hiddenDescription?: string | null;
      /**
       * @description Classification of the achievement (affects visibility and progress behavior)
       * @default standard
       */
      achievementType: components['schemas']['AchievementType'];
      /** @description Which entity types can earn this achievement */
      entityTypes?: components['schemas']['EntityType'][];
      /** @description Target value for progressive achievements */
      progressTarget?: number | null;
      /**
       * @description Point value of this achievement
       * @default 10
       */
      points: number;
      /** @description URL to achievement icon */
      iconUrl?: string | null;
      /** @description Platforms where this achievement exists */
      platforms?: components['schemas']['Platform'][];
      /** @description Platform-specific achievement IDs (e.g., {"steam": "ACH_001"}) */
      platformIds?: {
        [key: string]: string;
      } | null;
      /** @description Achievement IDs that must be unlocked first */
      prerequisites?: string[] | null;
      /**
       * @description Whether this achievement can be earned
       * @default true
       */
      isActive: boolean;
      /** @description Additional achievement-specific metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to create a new actor template definition */
    CreateActorTemplateRequest: {
      /** @description Category identifier (e.g., "npc-brain", "world-admin", "cron-cleanup") */
      category: string;
      /** @description Reference to behavior in lib-assets (e.g., "asset://behaviors/npc-brain-v1") */
      behaviorRef: string;
      /** @description Default configuration passed to behavior execution */
      configuration?: {
        [key: string]: unknown;
      } | null;
      /** @description Auto-spawn configuration for instantiate-on-access */
      autoSpawn?: components['schemas']['AutoSpawnConfig'];
      /**
       * @description Milliseconds between behavior loop iterations
       * @default 1000
       */
      tickIntervalMs: number;
      /**
       * @description Seconds between automatic state saves (0 to disable)
       * @default 60
       */
      autoSaveIntervalSeconds: number;
      /**
       * @description Maximum actors of this category per pool node
       * @default 100
       */
      maxInstancesPerNode: number;
    };
    /** @description Request to create a point-in-time snapshot of namespace documentation */
    CreateArchiveRequest: {
      /**
       * @description Owner of this archive. NOT a session ID.
       *     For user-initiated archives: the accountId (UUID format).
       *     For service-initiated archives: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Documentation namespace to archive */
      namespace: string;
      /** @description Optional description for the archive */
      description?: string;
    };
    /** @description Response containing the created archive details */
    CreateArchiveResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the created archive
       */
      archiveId: string;
      /** @description Namespace that was archived */
      namespace: string;
      /**
       * Format: uuid
       * @description Asset ID in Asset Service
       */
      bundleAssetId?: string;
      /** @description Number of documents in the archive */
      documentCount?: number;
      /** @description Total size of the archive in bytes */
      sizeBytes?: number;
      /**
       * Format: date-time
       * @description Timestamp when the archive was created
       */
      createdAt?: string;
      /** @description Git commit hash if namespace is bound */
      commitHash?: string | null;
    };
    /** @description Request to create a new asset bundle from multiple assets */
    CreateBundleRequest: {
      /**
       * @description Owner of this bundle. NOT a session ID.
       *     For user-initiated bundles: the accountId (UUID format).
       *     For service-initiated bundles: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Human-readable bundle identifier (e.g., "synty/polygon-adventure", "my-bundle-v1") */
      bundleId: string;
      /**
       * @description Bundle version string
       * @default 1.0.0
       */
      version: string;
      /**
       * @description Game realm this bundle belongs to.
       *     Defaults to 'shared' if not specified.
       */
      realm?: components['schemas']['GameRealm'] | null;
      /** @description List of asset IDs to include in the bundle */
      assetIds: string[];
      /** @description Compression algorithm to use for the bundle */
      compression?: components['schemas']['CompressionType'];
      /** @description Custom metadata for the bundle (null if none) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response with bundle creation status and estimated size */
    CreateBundleResponse: {
      /** @description Human-readable bundle identifier (e.g., "synty/polygon-adventure", "my-bundle-v1") */
      bundleId: string;
      /**
       * @description Bundle creation status
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed';
      /**
       * Format: int64
       * @description Estimated bundle size in bytes
       */
      estimatedSize: number;
    };
    /** @description Request to create a new container */
    CreateContainerRequest: {
      /**
       * Format: uuid
       * @description ID of the entity that owns this container
       */
      ownerId: string;
      /** @description Type of the owning entity */
      ownerType: components['schemas']['ContainerOwnerType'];
      /** @description Game-defined container type (e.g., inventory, bank, equipment_slot) */
      containerType: string;
      /** @description Capacity constraint model */
      constraintModel: components['schemas']['ContainerConstraintModel'];
      /**
       * @description Whether this container is an equipment slot
       * @default false
       */
      isEquipmentSlot: boolean;
      /** @description Equipment slot name if isEquipmentSlot is true */
      equipmentSlotName?: string | null;
      /** @description Maximum slots for slot-based containers */
      maxSlots?: number | null;
      /**
       * Format: double
       * @description Maximum weight capacity
       */
      maxWeight?: number | null;
      /** @description Internal grid width for grid containers */
      gridWidth?: number | null;
      /** @description Internal grid height for grid containers */
      gridHeight?: number | null;
      /**
       * Format: double
       * @description Maximum volume for volumetric containers
       */
      maxVolume?: number | null;
      /**
       * Format: uuid
       * @description Parent container ID for nested containers
       */
      parentContainerId?: string | null;
      /**
       * @description Whether this container can hold other containers
       * @default false
       */
      canContainContainers: boolean;
      /** @description Maximum nesting depth (null uses global default) */
      maxNestingDepth?: number | null;
      /**
       * Format: double
       * @description Empty container weight
       * @default 0
       */
      selfWeight: number;
      /** @description How weight propagates to parent */
      weightContribution?: components['schemas']['WeightContribution'];
      /**
       * @description Slots used in slot-based parent
       * @default 1
       */
      slotCost: number;
      /** @description Width footprint in grid-based parent */
      parentGridWidth?: number | null;
      /** @description Height footprint in grid-based parent */
      parentGridHeight?: number | null;
      /**
       * Format: double
       * @description Volume footprint in volumetric parent
       */
      parentVolume?: number | null;
      /** @description Allowed item categories (null allows all) */
      allowedCategories?: string[] | null;
      /** @description Forbidden item categories */
      forbiddenCategories?: string[] | null;
      /** @description Required item tags for placement */
      allowedTags?: string[] | null;
      /**
       * Format: uuid
       * @description Realm this container belongs to (null for account-level)
       */
      realmId?: string | null;
      /** @description Container tags for filtering */
      tags?: string[] | null;
      /** @description Game-specific container data */
      metadata?: Record<string, never> | null;
    };
    /** @description Request to create a contract instance */
    CreateContractInstanceRequest: {
      /**
       * Format: uuid
       * @description Template to create instance from
       */
      templateId: string;
      /** @description Parties to this contract */
      parties: components['schemas']['ContractPartyInput'][];
      /** @description Terms overriding template defaults */
      terms?: components['schemas']['ContractTerms'];
      /**
       * Format: date-time
       * @description When contract becomes active (null for immediate)
       */
      effectiveFrom?: string | null;
      /**
       * Format: date-time
       * @description When contract expires (null for perpetual)
       */
      effectiveUntil?: string | null;
      /** @description Related escrow IDs */
      escrowIds?: string[] | null;
      /** @description Instance-level game metadata */
      gameMetadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to create a map definition */
    CreateDefinitionRequest: {
      /** @description Human-readable name */
      name: string;
      /** @description Description of the map template */
      description?: string | null;
      /** @description Layer configurations */
      layers?: components['schemas']['LayerDefinition'][] | null;
      /** @description Default bounds for regions using this definition */
      defaultBounds?: components['schemas']['Bounds'];
      /** @description Additional metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Input for defining a party in escrow creation */
    CreateEscrowPartyInput: {
      /**
       * Format: uuid
       * @description Party entity ID
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Display name */
      displayName?: string | null;
      /** @description Role of this party in the escrow */
      role: components['schemas']['EscrowPartyRole'];
      /** @description Whether consent is required (defaults based on role) */
      consentRequired?: boolean | null;
      /**
       * Format: uuid
       * @description Party wallet for currency operations
       */
      walletId?: string | null;
      /**
       * Format: uuid
       * @description Party container for item operations
       */
      containerId?: string | null;
    };
    /** @description Request to create a new escrow agreement */
    CreateEscrowRequest: {
      /** @description Type of escrow agreement */
      escrowType: components['schemas']['EscrowType'];
      /** @description Trust mode for the escrow */
      trustMode: components['schemas']['EscrowTrustMode'];
      /**
       * Format: uuid
       * @description For single_party_trusted mode
       */
      trustedPartyId?: string | null;
      /** @description Type of the trusted party */
      trustedPartyType?: components['schemas']['EntityType'] | null;
      /** @description Parties in the escrow */
      parties: components['schemas']['CreateEscrowPartyInput'][];
      /** @description Expected deposits from parties */
      expectedDeposits: components['schemas']['ExpectedDepositInput'][];
      /** @description Optional explicit release allocations */
      releaseAllocations?: components['schemas']['ReleaseAllocationInput'][] | null;
      /**
       * Format: uuid
       * @description Contract governing this escrow
       */
      boundContractId?: string | null;
      /** @description Number of consents required (-1 for all) */
      requiredConsentsForRelease?: number | null;
      /**
       * Format: date-time
       * @description Optional expiration time
       */
      expiresAt?: string | null;
      /** @description Reference type (trade, auction, etc.) */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference entity ID
       */
      referenceId?: string | null;
      /** @description Human-readable description */
      description?: string | null;
      /** @description Application metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /** @description Idempotency key for this operation */
      idempotencyKey: string;
    };
    /** @description Response from creating an escrow agreement */
    CreateEscrowResponse: {
      /** @description Created escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Deposit tokens for each party (full_consent mode) */
      depositTokens: components['schemas']['PartyToken'][];
    };
    /** @description Request to create an authorization hold */
    CreateHoldRequest: {
      /**
       * Format: uuid
       * @description Wallet to hold funds in
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to hold
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to reserve
       */
      amount: number;
      /**
       * Format: date-time
       * @description When the hold auto-releases
       */
      expiresAt: string;
      /** @description Reference type (e.g. dining, hotel, gas) */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference entity ID
       */
      referenceId?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Request to create a new item instance */
    CreateItemInstanceRequest: {
      /**
       * Format: uuid
       * @description Template to instantiate
       */
      templateId: string;
      /**
       * Format: uuid
       * @description Container to place the item in
       */
      containerId: string;
      /**
       * Format: uuid
       * @description Realm this instance exists in
       */
      realmId: string;
      /**
       * Format: double
       * @description Item quantity (respects template's quantityModel)
       */
      quantity: number;
      /** @description Slot position in slot-based containers */
      slotIndex?: number | null;
      /** @description X position in grid-based containers */
      slotX?: number | null;
      /** @description Y position in grid-based containers */
      slotY?: number | null;
      /** @description Whether item is rotated in grid */
      rotated?: boolean | null;
      /** @description Initial durability (defaults to template's maxDurability) */
      currentDurability?: number | null;
      /** @description Instance-specific stat modifications */
      customStats?: Record<string, never> | null;
      /** @description Player-assigned custom name */
      customName?: string | null;
      /** @description Any other instance-specific data */
      instanceMetadata?: Record<string, never> | null;
      /** @description How this item instance was created */
      originType: components['schemas']['ItemOriginType'];
      /**
       * Format: uuid
       * @description Source entity ID (quest ID, creature ID, etc.)
       */
      originId?: string | null;
    };
    /** @description Request to create a new item template */
    CreateItemTemplateRequest: {
      /** @description Unique code within the game (immutable after creation) */
      code: string;
      /** @description Game service this template belongs to (immutable after creation) */
      gameId: string;
      /** @description Human-readable display name */
      name: string;
      /** @description Detailed description of this item */
      description?: string | null;
      /** @description Item classification category */
      category: components['schemas']['ItemCategory'];
      /** @description Game-defined subcategory (e.g., sword, helmet) */
      subcategory?: string | null;
      /** @description Flexible filtering tags */
      tags?: string[] | null;
      /** @description Item rarity tier (defaults to config when not specified) */
      rarity?: components['schemas']['ItemRarity'];
      /** @description How quantities are tracked for this item */
      quantityModel: components['schemas']['QuantityModel'];
      /** @description Maximum stack size (1 for unique items) */
      maxStackSize: number;
      /** @description Unit for continuous quantities (e.g., liters, kg) */
      unitOfMeasure?: string | null;
      /** @description Precision for weight values (defaults to config when not specified) */
      weightPrecision?: components['schemas']['WeightPrecision'];
      /**
       * Format: double
       * @description Weight value (interpreted per weightPrecision)
       */
      weight?: number | null;
      /**
       * Format: double
       * @description Volume for volumetric inventories
       */
      volume?: number | null;
      /** @description Width in grid-based inventories */
      gridWidth?: number | null;
      /** @description Height in grid-based inventories */
      gridHeight?: number | null;
      /** @description Whether item can be rotated in grid */
      canRotate?: boolean | null;
      /**
       * Format: double
       * @description Reference price for vendors/markets
       */
      baseValue?: number | null;
      /**
       * @description Whether item can be traded/auctioned
       * @default true
       */
      tradeable: boolean;
      /**
       * @description Whether item can be destroyed/discarded
       * @default true
       */
      destroyable: boolean;
      /** @description Binding behavior when item is acquired (defaults to config when not specified) */
      soulboundType?: components['schemas']['SoulboundType'];
      /**
       * @description Whether item has durability tracking
       * @default false
       */
      hasDurability: boolean;
      /** @description Maximum durability value */
      maxDurability?: number | null;
      /** @description Realm availability scope */
      scope: components['schemas']['ItemScope'];
      /** @description Realm IDs where this template is available (for realm_specific or multi_realm) */
      availableRealms?: string[] | null;
      /** @description Game-defined stats (e.g., attack, defense) */
      stats?: Record<string, never> | null;
      /** @description Game-defined effects (e.g., on_use, on_equip) */
      effects?: Record<string, never> | null;
      /** @description Game-defined requirements (e.g., level, strength) */
      requirements?: Record<string, never> | null;
      /** @description Display properties (e.g., iconId, modelId) */
      display?: Record<string, never> | null;
      /** @description Any other game-specific data */
      metadata?: Record<string, never> | null;
    };
    /** @description Request to create a new leaderboard */
    CreateLeaderboardDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service owning this leaderboard
       */
      gameServiceId: string;
      /** @description Unique identifier for this leaderboard (lowercase, no spaces) */
      leaderboardId: string;
      /** @description Human-readable name for the leaderboard */
      displayName: string;
      /** @description Description of what this leaderboard tracks */
      description?: string | null;
      /** @description Which entity types can appear on this leaderboard */
      entityTypes?: components['schemas']['EntityType'][];
      /**
       * @description Sort order (descending for high scores, ascending for times)
       * @default descending
       */
      sortOrder: components['schemas']['SortOrder'];
      /**
       * @description How to handle score updates
       * @default replace
       */
      updateMode: components['schemas']['UpdateMode'];
      /**
       * @description Whether this leaderboard resets each season
       * @default false
       */
      isSeasonal: boolean;
      /**
       * @description Whether the leaderboard is publicly visible
       * @default true
       */
      isPublic: boolean;
      /** @description Additional leaderboard-specific metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Request to create a metabundle from source bundles and/or standalone assets.
     *     At least one of sourceBundleIds or standaloneAssetIds must be provided.
     *     This enables packaging behaviors/scripts with 3D assets as a complete unit.
     */
    CreateMetabundleRequest: {
      /** @description Human-readable identifier for the new metabundle (e.g., "game-assets-v1") */
      metabundleId: string;
      /**
       * @description Human-readable source bundle IDs (e.g., "synty/polygon-adventure") to pull assets from.
       *     Can cherry-pick specific assets using assetFilter, or include all if assetFilter is null.
       */
      sourceBundleIds?: string[] | null;
      /**
       * @description Individual asset IDs (not in bundles) to include directly.
       *     Useful for including behaviors, scripts, or metadata files
       *     alongside bundled 3D assets.
       */
      standaloneAssetIds?: string[] | null;
      /**
       * @description Metabundle version string
       * @default 1.0.0
       */
      version: string;
      /**
       * @description Owner of this metabundle. NOT a session ID.
       *     For user-initiated: the accountId (UUID format).
       *     For service-initiated: the service name.
       */
      owner: string;
      /** @description Game realm for this metabundle */
      realm: components['schemas']['GameRealm'];
      /** @description Human-readable description */
      description?: string | null;
      /**
       * @description Optional subset of asset IDs to include FROM SOURCE BUNDLES.
       *     If null, all assets from source bundles are included.
       *     Standalone assets are always included regardless of this filter.
       */
      assetFilter?: string[] | null;
      /** @description Custom metadata for the metabundle */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Response from metabundle creation.
     *     For synchronous creation (small jobs): status=ready with downloadUrl.
     *     For async creation (large jobs): status=queued with jobId for polling.
     */
    CreateMetabundleResponse: {
      /** @description Human-readable metabundle identifier */
      metabundleId: string;
      /**
       * Format: uuid
       * @description Job ID for async processing. Only present when status is 'queued' or 'processing'.
       *     Use /bundles/job/status to poll for completion, or wait for
       *     MetabundleCreationCompleteEvent via WebSocket.
       */
      jobId?: string | null;
      /**
       * @description Creation status.
       *     - queued: Job accepted for async processing (poll with jobId)
       *     - processing: Job is actively running
       *     - ready: Metabundle created and available for download
       *     - failed: Creation failed (see conflicts for details)
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed';
      /**
       * Format: uri
       * @description Pre-signed download URL (only present when status is 'ready')
       */
      downloadUrl?: string | null;
      /** @description Number of assets in the metabundle */
      assetCount: number;
      /** @description Number of standalone assets included directly (not from bundles) */
      standaloneAssetCount?: number | null;
      /**
       * Format: int64
       * @description Total size in bytes
       */
      sizeBytes: number;
      /** @description Provenance data for the metabundle */
      sourceBundles?: components['schemas']['SourceBundleReference'][];
      /** @description Present if creation failed due to asset conflicts */
      conflicts?: components['schemas']['AssetConflict'][] | null;
    };
    /** @description Request to create a new scene */
    CreateSceneRequest: {
      /** @description The scene document to create */
      scene: components['schemas']['Scene'];
    };
    /** @description Request to create a new save slot for an entity. */
    CreateSlotRequest: {
      /** @description Game identifier for namespace isolation (e.g., "game-1", "game-2") */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name (lowercase alphanumeric with hyphens, single char like "q" allowed) */
      slotName: string;
      /** @description Save category determining retention and cleanup behavior */
      category: components['schemas']['SaveCategory'];
      /** @description Override default max versions for this category (null = use category default) */
      maxVersions?: number | null;
      /** @description Days to retain versions (null = indefinite) */
      retentionDays?: number | null;
      /** @description Compression algorithm to use for save data (null = use category default) */
      compressionType?: components['schemas']['CompressionType'] | null;
      /** @description Searchable tags for slot categorization (e.g., "boss-fight", "chapter-3") */
      tags?: string[] | null;
      /** @description Custom key-value metadata for the slot */
      metadata?: {
        [key: string]: string;
      } | null;
    };
    /** @description Request to create a new wallet */
    CreateWalletRequest: {
      /**
       * Format: uuid
       * @description Owner entity ID
       */
      ownerId: string;
      /** @description Type of owner entity */
      ownerType: components['schemas']['WalletOwnerType'];
      /**
       * Format: uuid
       * @description Realm ID for realm-scoped wallets (null for global)
       */
      realmId?: string | null;
    };
    /** @description Request to credit currency to a wallet */
    CreditCurrencyRequest: {
      /**
       * Format: uuid
       * @description Target wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to credit
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to credit (must be positive)
       */
      amount: number;
      /** @description Must be a faucet type (mint, quest_reward, loot_drop, etc.) */
      transactionType: components['schemas']['TransactionType'];
      /** @description What triggered this transaction (quest, admin, etc.) */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference entity ID
       */
      referenceId?: string | null;
      /** @description Unique key to prevent duplicate processing */
      idempotencyKey: string;
      /**
       * @description Skip earn cap enforcement (admin use)
       * @default false
       */
      bypassEarnCap: boolean;
      /** @description Free-form transaction metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Result of credit operation */
    CreditCurrencyResponse: {
      /** @description Created transaction record */
      transaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Balance after credit
       */
      newBalance: number;
      /** @description Whether earn cap limited the credit */
      earnCapApplied: boolean;
      /**
       * Format: double
       * @description Amount reduced by earn cap
       */
      earnCapAmountLimited?: number | null;
      /** @description Whether wallet cap limited the credit */
      walletCapApplied: boolean;
      /**
       * Format: double
       * @description Amount lost due to wallet cap (cap_and_lose behavior)
       */
      walletCapAmountLost?: number | null;
    };
    /** @description Request to cure a breach */
    CureBreachRequest: {
      /**
       * Format: uuid
       * @description Breach to cure
       */
      breachId: string;
      /** @description Evidence of cure */
      cureEvidence?: string | null;
    };
    /** @description Currency definition details */
    CurrencyDefinitionResponse: {
      /**
       * Format: uuid
       * @description Unique definition identifier
       */
      definitionId: string;
      /** @description Unique currency code */
      code: string;
      /** @description Human-readable name */
      name: string;
      /** @description Detailed description */
      description?: string | null;
      /** @description Realm availability scope */
      scope: components['schemas']['CurrencyScope'];
      /** @description Available realm IDs */
      realmsAvailable?: string[] | null;
      /** @description Decimal precision */
      precision: components['schemas']['CurrencyPrecision'];
      /** @description Whether transferable between wallets */
      transferable: boolean;
      /** @description Whether usable in trades */
      tradeable: boolean;
      /** @description Whether negative balance allowed (null uses plugin default) */
      allowNegative?: boolean | null;
      /**
       * Format: double
       * @description Maximum per-wallet balance
       */
      perWalletCap?: number | null;
      /** @description Overflow behavior when cap exceeded */
      capOverflowBehavior?: components['schemas']['CapOverflowBehavior'];
      /**
       * Format: double
       * @description Global supply cap
       */
      globalSupplyCap?: number | null;
      /**
       * Format: double
       * @description Daily earn cap
       */
      dailyEarnCap?: number | null;
      /**
       * Format: double
       * @description Weekly earn cap
       */
      weeklyEarnCap?: number | null;
      /** @description Earn cap reset time */
      earnCapResetTime?: string | null;
      /** @description Whether autogain is enabled */
      autogainEnabled: boolean;
      /** @description Autogain calculation mode */
      autogainMode?: components['schemas']['AutogainMode'];
      /**
       * Format: double
       * @description Autogain amount per interval
       */
      autogainAmount?: number | null;
      /** @description Autogain interval duration */
      autogainInterval?: string | null;
      /**
       * Format: double
       * @description Autogain balance cap
       */
      autogainCap?: number | null;
      /** @description Whether currency can expire */
      expires: boolean;
      /** @description Expiration policy */
      expirationPolicy?: components['schemas']['ExpirationPolicy'];
      /**
       * Format: date-time
       * @description Fixed expiration date
       */
      expirationDate?: string | null;
      /** @description Expiration duration */
      expirationDuration?: string | null;
      /**
       * Format: uuid
       * @description Season ID for expiration
       */
      seasonId?: string | null;
      /** @description Whether linked to inventory item */
      linkedToItem: boolean;
      /**
       * Format: uuid
       * @description Linked item template ID
       */
      linkedItemTemplateId?: string | null;
      /** @description Item linkage mode */
      linkageMode?: components['schemas']['ItemLinkageMode'];
      /** @description Whether this is the base currency */
      isBaseCurrency: boolean;
      /**
       * Format: double
       * @description Exchange rate to base currency
       */
      exchangeRateToBase?: number | null;
      /**
       * Format: date-time
       * @description When exchange rate was last updated
       */
      exchangeRateUpdatedAt?: string | null;
      /**
       * Format: uuid
       * @description Icon asset ID
       */
      iconAssetId?: string | null;
      /** @description Display format string */
      displayFormat?: string | null;
      /** @description Whether definition is active */
      isActive: boolean;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last modification timestamp
       */
      modifiedAt?: string | null;
    };
    /**
     * @description How the currency handles decimal values (immutable after creation)
     * @enum {string}
     */
    CurrencyPrecision:
      | 'integer'
      | 'decimal_2'
      | 'decimal_4'
      | 'decimal_8'
      | 'decimal_full'
      | 'big_integer';
    /**
     * @description Scope of currency availability across realms
     * @enum {string}
     */
    CurrencyScope: 'global' | 'realm_specific' | 'multi_realm';
    /** @description Immutable record of a currency transaction */
    CurrencyTransactionRecord: {
      /**
       * Format: uuid
       * @description Unique transaction identifier
       */
      transactionId: string;
      /**
       * Format: uuid
       * @description Source wallet (null for faucets)
       */
      sourceWalletId?: string | null;
      /**
       * Format: uuid
       * @description Target wallet (null for sinks)
       */
      targetWalletId?: string | null;
      /**
       * Format: uuid
       * @description Currency definition ID
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Transaction amount (always positive)
       */
      amount: number;
      /** @description Transaction classification */
      transactionType: components['schemas']['TransactionType'];
      /** @description What triggered this transaction */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference entity ID
       */
      referenceId?: string | null;
      /**
       * Format: uuid
       * @description Associated escrow ID
       */
      escrowId?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
      /**
       * Format: date-time
       * @description When transaction occurred
       */
      timestamp: string;
      /**
       * Format: double
       * @description Source balance before transaction
       */
      sourceBalanceBefore?: number | null;
      /**
       * Format: double
       * @description Source balance after transaction
       */
      sourceBalanceAfter?: number | null;
      /**
       * Format: double
       * @description Target balance before transaction
       */
      targetBalanceBefore?: number | null;
      /**
       * Format: double
       * @description Target balance after transaction
       */
      targetBalanceAfter?: number | null;
      /** @description Number of autogain periods applied */
      autogainPeriodsApplied?: number | null;
      /**
       * Format: double
       * @description Amount lost to cap overflow
       */
      overflowAmountLost?: number | null;
      /**
       * Format: double
       * @description Amount limited by earn cap
       */
      earnCapAmountLimited?: number | null;
      /** @description Free-form metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Custom affordance definition for novel scenarios */
    CustomAffordance: {
      /** @description Human-readable description of this affordance */
      description?: string | null;
      /**
       * @description Required criteria. Object types, property constraints.
       *     Example: { "objectTypes": ["boulder"], "cover_rating": { "min": 0.5 } }
       */
      requires?: {
        [key: string]: unknown;
      } | null;
      /**
       * @description Preferred criteria (boost score but not required).
       *     Example: { "elevation": { "prefer_higher": true } }
       */
      prefers?: {
        [key: string]: unknown;
      } | null;
      /**
       * @description Exclusion criteria. Reject candidates matching these.
       *     Example: { "hazards": true, "contested": true }
       */
      excludes?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Custom script injection configuration for adding JavaScript to pages */
    CustomScripts: {
      /** @description Custom scripts to inject in the HTML head */
      head?: string | null;
      /** @description Custom scripts to inject at the start of the body */
      bodyStart?: string | null;
      /** @description Custom scripts to inject at the end of the body */
      bodyEnd?: string | null;
    };
    /** @description Request to debit currency from a wallet */
    DebitCurrencyRequest: {
      /**
       * Format: uuid
       * @description Source wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to debit
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to debit (must be positive)
       */
      amount: number;
      /** @description Must be a sink type (burn, vendor_purchase, fee, etc.) */
      transactionType: components['schemas']['TransactionType'];
      /** @description What triggered this transaction */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference entity ID
       */
      referenceId?: string | null;
      /** @description Unique key to prevent duplicate processing */
      idempotencyKey: string;
      /** @description Override negative balance allowance for this transaction */
      allowNegative?: boolean | null;
      /** @description Free-form transaction metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Result of debit operation */
    DebitCurrencyResponse: {
      /** @description Created transaction record */
      transaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Balance after debit
       */
      newBalance: number;
    };
    /** @description Request to decline a formed match */
    DeclineMatchRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the match to decline
       */
      matchId: string;
    };
    /** @description Request to delete an achievement */
    DeleteAchievementDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the achievement to delete */
      achievementId: string;
    };
    /** @description Request to delete an actor template */
    DeleteActorTemplateRequest: {
      /**
       * Format: uuid
       * @description ID of the template to delete
       */
      templateId: string;
      /**
       * @description If true, stops all running actors using this template
       * @default false
       */
      forceStopActors: boolean;
    };
    /** @description Response confirming template deletion */
    DeleteActorTemplateResponse: {
      /** @description Whether the template was successfully deleted */
      deleted: boolean;
      /** @description Number of running actors that were stopped */
      stoppedActorCount: number;
    };
    /** @description Request to delete a bundle */
    DeleteBundleRequest: {
      /** @description Human-readable bundle identifier to delete */
      bundleId: string;
      /**
       * @description If true, permanently delete (admin only). If false, soft-delete.
       * @default false
       */
      permanent: boolean;
      /** @description Optional reason for deletion (recorded in version history) */
      reason?: string | null;
    };
    /** @description Result of bundle deletion */
    DeleteBundleResponse: {
      /** @description Human-readable bundle identifier that was deleted */
      bundleId: string;
      /**
       * @description Deletion status
       * @enum {string}
       */
      status: 'deleted' | 'permanently_deleted';
      /**
       * Format: date-time
       * @description When the bundle was deleted
       */
      deletedAt: string;
      /**
       * Format: date-time
       * @description When soft-deleted bundle will be permanently removed (null for permanent deletes)
       */
      retentionUntil?: string | null;
    };
    /** @description Request to delete a leaderboard */
    DeleteLeaderboardDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard to delete */
      leaderboardId: string;
    };
    /** @description Request to delete a scene */
    DeleteSceneRequest: {
      /**
       * Format: uuid
       * @description ID of the scene to delete
       */
      sceneId: string;
      /** @description Optional reason for deletion (included in event) */
      reason?: string | null;
    };
    /** @description Response confirming scene deletion */
    DeleteSceneResponse: {
      /** @description Whether the scene was successfully deleted */
      deleted: boolean;
      /**
       * Format: uuid
       * @description ID of the deleted scene
       */
      sceneId?: string;
      /** @description If deletion failed, IDs of scenes that reference this one */
      referencingScenes?: string[] | null;
    };
    /** @description Request to permanently delete a save slot and all its versions */
    DeleteSlotRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
    };
    /** @description Result of a slot deletion operation with cleanup statistics */
    DeleteSlotResponse: {
      /** @description Whether slot was deleted */
      deleted: boolean;
      /** @description Number of versions deleted */
      versionsDeleted: number;
      /**
       * Format: int64
       * @description Storage freed in bytes
       */
      bytesFreed: number;
    };
    /** @description Request to permanently delete a specific save version */
    DeleteVersionRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Version to delete */
      versionNumber: number;
    };
    /** @description Result of a version deletion operation with storage freed */
    DeleteVersionResponse: {
      /** @description Whether version was deleted */
      deleted: boolean;
      /**
       * Format: int64
       * @description Storage freed in bytes
       */
      bytesFreed: number;
    };
    /**
     * @description Algorithm used for delta computation.
     *     JSON_PATCH: RFC 6902, best for structured JSON data
     *     BSDIFF: Binary diff, good for general binary data
     *     XDELTA: RFC 3284 VCDIFF, efficient for large binary files
     * @default JSON_PATCH
     * @enum {string}
     */
    DeltaAlgorithm: 'JSON_PATCH' | 'BSDIFF' | 'XDELTA';
    /** @description Request to deposit assets into an escrow */
    DepositRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Party depositing
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Assets to deposit */
      assets: components['schemas']['EscrowAssetBundleInput'];
      /** @description Deposit token (required for full_consent) */
      depositToken?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from depositing assets into an escrow */
    DepositResponse: {
      /** @description Updated escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Deposit record */
      deposit: components['schemas']['EscrowDeposit'];
      /** @description Whether escrow is now fully funded */
      fullyFunded: boolean;
      /** @description Release tokens (issued when fully funded) */
      releaseTokens: components['schemas']['PartyToken'][];
    };
    /** @description Request to destroy an item instance */
    DestroyItemInstanceRequest: {
      /**
       * Format: uuid
       * @description Instance ID to destroy
       */
      instanceId: string;
      /** @description Reason for destruction (consumed, destroyed, expired, admin) */
      reason: string;
    };
    /** @description Response after destroying an item instance */
    DestroyItemInstanceResponse: {
      /** @description Whether destruction was successful */
      destroyed: boolean;
      /**
       * Format: uuid
       * @description Destroyed instance ID
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Template of destroyed instance
       */
      templateId: string;
    };
    /** @description Information about the client device used for authentication or session tracking */
    DeviceInfo: {
      /**
       * @description Category of the device
       * @enum {string|null}
       */
      deviceType?: 'desktop' | 'mobile' | 'tablet' | 'console' | null;
      /** @description Operating system or platform name */
      platform?: string | null;
      /** @description Browser name and version if applicable */
      browser?: string | null;
      /** @description Version of the client application */
      appVersion?: string | null;
    };
    /** @description Request to discard checkout */
    DiscardRequest: {
      /**
       * Format: uuid
       * @description Scene to discard changes for
       */
      sceneId: string;
      /** @description Checkout token */
      checkoutToken: string;
    };
    /** @description Response confirming discard */
    DiscardResponse: {
      /** @description Whether discard was successful */
      discarded: boolean;
    };
    /** @description Request to raise a dispute on a funded escrow */
    DisputeRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Party raising dispute
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Reason for dispute */
      reason: string;
      /** @description Release token (proves party identity) */
      releaseToken?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from raising a dispute on an escrow */
    DisputeResponse: {
      /** @description Disputed escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
    };
    /** @description Record of an asset distribution */
    DistributionRecord: {
      /** @description Clause that was executed */
      clauseId: string;
      /** @description Type of clause (fee, distribution) */
      clauseType: string;
      /** @description Type of asset (currency, item) */
      assetType: string;
      /** @description Amount transferred */
      amount: number;
      /**
       * Format: uuid
       * @description Source wallet ID (for currency)
       */
      sourceWalletId?: string | null;
      /**
       * Format: uuid
       * @description Destination wallet ID (for currency)
       */
      destinationWalletId?: string | null;
      /**
       * Format: uuid
       * @description Source container ID (for items)
       */
      sourceContainerId?: string | null;
      /**
       * Format: uuid
       * @description Destination container ID (for items)
       */
      destinationContainerId?: string | null;
    };
    /** @description Complete document with all metadata and content */
    Document: {
      /**
       * Format: uuid
       * @description Unique identifier of the document
       */
      documentId: string;
      /** @description Namespace the document belongs to */
      namespace: string;
      /** @description URL-friendly unique identifier */
      slug: string;
      /** @description Display title of the document */
      title: string;
      /** @description Category for organizing the document */
      category: components['schemas']['DocumentCategory'];
      /** @description Full markdown content of the document */
      content?: string;
      /** @description Brief text summary of the document */
      summary?: string | null;
      /** @description Concise summary optimized for voice AI */
      voiceSummary?: string | null;
      /** @description Tags for filtering and search */
      tags?: string[];
      /** @description IDs of related documents */
      relatedDocuments?: string[];
      /** @description Custom metadata key-value pairs */
      metadata?: {
        [key: string]: unknown;
      };
      /**
       * Format: date-time
       * @description Timestamp when the document was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the document was last updated
       */
      updatedAt: string;
    };
    /**
     * @description Fixed categories for type-safe filtering
     * @enum {string}
     */
    DocumentCategory:
      | 'getting-started'
      | 'api-reference'
      | 'architecture'
      | 'deployment'
      | 'troubleshooting'
      | 'tutorials'
      | 'game-systems'
      | 'world-lore'
      | 'npc-ai'
      | 'other';
    /** @description Search result with relevance scoring and match highlights */
    DocumentResult: {
      /**
       * Format: uuid
       * @description Unique identifier of the document
       */
      documentId: string;
      /** @description URL-friendly unique identifier */
      slug: string;
      /** @description Display title of the document */
      title: string;
      /** @description Category of the document */
      category?: components['schemas']['DocumentCategory'];
      /** @description Brief text summary of the document */
      summary?: string | null;
      /** @description Concise summary optimized for voice AI */
      voiceSummary?: string | null;
      /** @description Full document content if requested */
      content?: string | null;
      /**
       * Format: float
       * @description Relevance score from 0.0 to 1.0
       */
      relevanceScore: number;
      /** @description Text snippets showing where matches occurred */
      matchHighlights?: string[];
    };
    /** @description Lightweight document representation for listings and references */
    DocumentSummary: {
      /**
       * Format: uuid
       * @description Unique identifier of the document
       */
      documentId: string;
      /** @description URL-friendly unique identifier */
      slug: string;
      /** @description Display title of the document */
      title: string;
      /** @description Category of the document */
      category: components['schemas']['DocumentCategory'];
      /** @description Brief text summary of the document */
      summary?: string | null;
      /** @description Concise summary optimized for voice AI */
      voiceSummary?: string | null;
      /** @description Tags associated with the document */
      tags?: string[];
    };
    /** @description Download details for a specific game client version and platform */
    DownloadInfo: {
      /** @description Target platform for this download */
      platform: components['schemas']['Platform'];
      /** @description Version number of the game client */
      version: string;
      /**
       * Format: uri
       * @description Download URL for the game client
       */
      url: string;
      /** @description File size in bytes */
      size: number;
      /** @description SHA256 checksum */
      checksum: string;
      /** @description Release notes or changelog for this version */
      releaseNotes?: string | null;
      /** @description Minimum system requirements for the client */
      minimumRequirements?: {
        [key: string]: unknown;
      };
    };
    /** @description Collection of available game client downloads by platform */
    DownloadsResponse: {
      /** @description Available game client downloads */
      clients: components['schemas']['DownloadInfo'][];
    };
    /** @description Request to duplicate a scene */
    DuplicateSceneRequest: {
      /**
       * Format: uuid
       * @description Scene to duplicate
       */
      sourceSceneId: string;
      /** @description Name for the duplicate */
      newName: string;
      /** @description Optional different game ID */
      newGameId?: string | null;
      /** @description Optional different scene type */
      newSceneType?: components['schemas']['SceneType'];
    };
    /** @description Current earn cap status for a balance */
    EarnCapInfo: {
      /**
       * Format: double
       * @description Amount earned today
       */
      dailyEarned: number;
      /**
       * Format: double
       * @description Remaining daily earn allowance
       */
      dailyRemaining: number;
      /**
       * Format: date-time
       * @description When daily counter resets
       */
      dailyResetsAt: string;
      /**
       * Format: double
       * @description Amount earned this week
       */
      weeklyEarned: number;
      /**
       * Format: double
       * @description Remaining weekly earn allowance
       */
      weeklyRemaining: number;
      /**
       * Format: date-time
       * @description When weekly counter resets
       */
      weeklyResetsAt: string;
    };
    /**
     * @description How the encounter emotionally affected the character
     * @enum {string}
     */
    EmotionalImpact:
      | 'GRATITUDE'
      | 'ANGER'
      | 'FEAR'
      | 'RESPECT'
      | 'CONTEMPT'
      | 'AFFECTION'
      | 'RIVALRY'
      | 'INDIFFERENCE'
      | 'GUILT'
      | 'PRIDE';
    /** @description 6-dimensional emotional state input (all values 0-1) */
    EmotionalStateInput: {
      /** @description Tension level (0=resolved, 1=maximum tension) */
      tension?: number | null;
      /** @description Brightness level (0=dark, 1=bright) */
      brightness?: number | null;
      /** @description Energy level (0=calm, 1=energetic) */
      energy?: number | null;
      /** @description Warmth level (0=distant, 1=intimate) */
      warmth?: number | null;
      /** @description Stability level (0=unstable, 1=grounded) */
      stability?: number | null;
      /** @description Valence level (0=negative, 1=positive) */
      valence?: number | null;
    };
    /** @description Snapshot of emotional state at a specific point in the composition */
    EmotionalStateSnapshot: {
      /** @description Bar number where this snapshot was taken */
      bar: number;
      /** @description Name of the narrative phase at this point */
      phaseName?: string | null;
      /** @description Tension level (0-1) */
      tension: number;
      /** @description Brightness level (0-1) */
      brightness: number;
      /** @description Energy level (0-1) */
      energy: number;
      /** @description Warmth level (0-1) */
      warmth?: number;
      /** @description Stability level (0-1) */
      stability?: number;
      /** @description Valence level (0-1) */
      valence?: number;
    };
    /** @description Paginated list of encounters */
    EncounterListResponse: {
      /** @description List of encounters with perspectives */
      encounters: components['schemas']['EncounterResponse'][];
      /** @description Total matching encounters */
      totalCount: number;
      /** @description Current page (1-based) */
      page: number;
      /** @description Results per page */
      pageSize: number;
      /** @description Whether more results exist */
      hasNextPage?: boolean;
      /** @description Whether previous results exist */
      hasPreviousPage?: boolean;
    };
    /** @description Core encounter record representing a memorable interaction */
    EncounterModel: {
      /**
       * Format: uuid
       * @description Unique identifier for this encounter
       */
      encounterId: string;
      /**
       * Format: date-time
       * @description In-game time when the encounter occurred
       */
      timestamp: string;
      /**
       * Format: uuid
       * @description Realm where the encounter took place
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Specific location within the realm (optional)
       */
      locationId?: string | null;
      /** @description Type code for this encounter (e.g., COMBAT, TRADE) */
      encounterTypeCode: string;
      /** @description What triggered or contextualized the encounter */
      context?: string | null;
      /** @description Outcome of the encounter (POSITIVE, NEGATIVE, NEUTRAL, MEMORABLE, TRANSFORMATIVE) */
      outcome: components['schemas']['EncounterOutcome'];
      /** @description All character IDs involved in the encounter */
      participantIds: string[];
      /** @description Additional encounter-specific data */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description System timestamp when record was created
       */
      createdAt: string;
    };
    /**
     * @description Overall outcome of an encounter
     * @enum {string}
     */
    EncounterOutcome: 'POSITIVE' | 'NEGATIVE' | 'NEUTRAL' | 'MEMORABLE' | 'TRANSFORMATIVE';
    /** @description A character's individual perspective on an encounter */
    EncounterPerspectiveModel: {
      /**
       * Format: uuid
       * @description Unique identifier for this perspective
       */
      perspectiveId: string;
      /**
       * Format: uuid
       * @description Reference to the shared encounter record
       */
      encounterId: string;
      /**
       * Format: uuid
       * @description Character holding this perspective
       */
      characterId: string;
      /** @description Primary emotional response to the encounter */
      emotionalImpact: components['schemas']['EmotionalImpact'];
      /**
       * Format: float
       * @description Opinion change toward other participants (-1.0 to +1.0)
       */
      sentimentShift?: number | null;
      /**
       * Format: float
       * @description How strongly remembered (0.0-1.0, decays over time)
       */
      memoryStrength: number;
      /** @description Short description from this character's POV */
      rememberedAs?: string | null;
      /**
       * Format: date-time
       * @description When memory decay was last applied
       */
      lastDecayedAt?: string | null;
      /**
       * Format: date-time
       * @description System timestamp when record was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last modification timestamp
       */
      updatedAt?: string | null;
    };
    /** @description Response containing an encounter with perspectives */
    EncounterResponse: {
      /** @description The shared encounter record */
      encounter: components['schemas']['EncounterModel'];
      /** @description All perspectives on this encounter */
      perspectives: components['schemas']['EncounterPerspectiveModel'][];
    };
    /** @description Response containing a list of encounter types */
    EncounterTypeListResponse: {
      /** @description List of encounter types */
      types: components['schemas']['EncounterTypeResponse'][];
      /** @description Total number of types */
      totalCount: number;
    };
    /** @description Response containing an encounter type */
    EncounterTypeResponse: {
      /**
       * Format: uuid
       * @description Unique identifier
       */
      typeId: string;
      /** @description Unique code */
      code: string;
      /** @description Display name */
      name: string;
      /** @description Description */
      description?: string | null;
      /** @description Whether this is a built-in type */
      isBuiltIn: boolean;
      /** @description Suggested emotional response */
      defaultEmotionalImpact?: components['schemas']['EmotionalImpact'];
      /** @description Display ordering */
      sortOrder: number;
      /** @description Whether the type is active */
      isActive: boolean;
      /**
       * Format: date-time
       * @description When the type was created
       */
      createdAt: string;
    };
    /** @description Request to end an active encounter */
    EndEncounterRequest: {
      /** @description ID of the Event Brain actor managing the encounter */
      actorId: string;
    };
    /** @description Response after ending an encounter */
    EndEncounterResponse: {
      /** @description ID of the actor */
      actorId: string;
      /**
       * Format: uuid
       * @description ID of the ended encounter
       */
      encounterId: string;
      /** @description Duration of the encounter in milliseconds */
      durationMs?: number | null;
    };
    /**
     * @description How contract breaches are handled
     * @enum {string}
     */
    EnforcementMode: 'advisory' | 'event_only' | 'consequence_based' | 'community';
    /**
     * @description Character data with optional enriched fields.
     *     Fields are only populated if the corresponding include flag was set in the request.
     */
    EnrichedCharacterResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the character
       */
      characterId: string;
      /** @description Display name of the character */
      name: string;
      /**
       * Format: uuid
       * @description Realm ID (partition key)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Species ID (foreign key to Species service)
       */
      speciesId: string;
      /**
       * Format: date-time
       * @description In-game birth timestamp
       */
      birthDate: string;
      /**
       * Format: date-time
       * @description In-game death timestamp
       */
      deathDate?: string | null;
      /** @description Current lifecycle status of the character */
      status: components['schemas']['CharacterStatus'];
      /**
       * Format: date-time
       * @description Real-world creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Real-world last update timestamp
       */
      updatedAt?: string | null;
      /** @description Personality traits (included if includePersonality=true) */
      personality?: components['schemas']['PersonalitySnapshot'];
      /** @description Backstory elements (included if includeBackstory=true) */
      backstory?: components['schemas']['BackstorySnapshot'];
      /** @description Family relationships (included if includeFamilyTree=true) */
      familyTree?: components['schemas']['FamilyTreeResponse'];
      /** @description Combat preferences (included if includeCombatPreferences=true) */
      combatPreferences?: components['schemas']['CombatPreferencesSnapshot'];
    };
    /** @description Entity's rank on a leaderboard */
    EntityRankResponse: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type for the ranked entity */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: double
       * @description Entity's current score
       */
      score: number;
      /**
       * Format: int64
       * @description Entity's current rank (1-based)
       */
      rank: number;
      /**
       * Format: int64
       * @description Total entries on the leaderboard
       */
      totalEntries: number;
      /**
       * Format: double
       * @description Percentile ranking (0-100)
       */
      percentile?: number;
    };
    /**
     * @description Universal entity type identifier used across Bannou services.
     *     Provides first-class support for various kinds of entities in analytics,
     *     achievements, leaderboards, contracts, relationships, and other systems.
     * @enum {string}
     */
    EntityType:
      | 'system'
      | 'account'
      | 'character'
      | 'actor'
      | 'guild'
      | 'organization'
      | 'government'
      | 'faction'
      | 'location'
      | 'realm'
      | 'item'
      | 'monster'
      | 'custom'
      | 'other';
    /** @description Standard error response format */
    ErrorResponse: {
      /** @description Error code */
      error: string;
      /** @description Human-readable error message */
      message: string;
      /** @description Additional error details */
      details?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Main escrow agreement record */
    EscrowAgreement: {
      /**
       * Format: uuid
       * @description Unique escrow agreement identifier
       */
      id: string;
      /** @description Type of escrow agreement */
      escrowType: components['schemas']['EscrowType'];
      /** @description Trust mode for the escrow */
      trustMode: components['schemas']['EscrowTrustMode'];
      /**
       * Format: uuid
       * @description For single_party_trusted - which party has authority
       */
      trustedPartyId?: string | null;
      /** @description Type of the trusted party */
      trustedPartyType?: components['schemas']['EntityType'] | null;
      /** @description For initiator_trusted - which service created this */
      initiatorServiceId?: string | null;
      /** @description All parties involved in the escrow */
      parties: components['schemas']['EscrowParty'][];
      /** @description What deposits are expected from each party */
      expectedDeposits: components['schemas']['ExpectedDeposit'][];
      /** @description Actual deposits received */
      deposits: components['schemas']['EscrowDeposit'][];
      /** @description How assets should be distributed on release */
      releaseAllocations?: components['schemas']['ReleaseAllocation'][] | null;
      /**
       * Format: uuid
       * @description Contract governing conditions for this escrow
       */
      boundContractId?: string | null;
      /** @description Consent decisions from parties */
      consents: components['schemas']['EscrowConsent'][];
      /** @description Current escrow status */
      status: components['schemas']['EscrowStatus'];
      /** @description How many parties must consent for release (-1 = all required) */
      requiredConsentsForRelease: number;
      /**
       * Format: date-time
       * @description When the escrow was last validated
       */
      lastValidatedAt?: string | null;
      /** @description Any validation failures detected */
      validationFailures?: components['schemas']['ValidationFailure'][] | null;
      /**
       * Format: date-time
       * @description When the escrow was created
       */
      createdAt: string;
      /**
       * Format: uuid
       * @description Who created the escrow
       */
      createdBy: string;
      /** @description Type of the creator entity */
      createdByType: components['schemas']['EntityType'];
      /**
       * Format: date-time
       * @description When all expected deposits were received
       */
      fundedAt?: string | null;
      /**
       * Format: date-time
       * @description Auto-refund if not completed by this time
       */
      expiresAt: string;
      /**
       * Format: date-time
       * @description When the escrow reached terminal state
       */
      completedAt?: string | null;
      /** @description What this escrow is for (e.g., trade, auction, contract) */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description ID of the referenced entity
       */
      referenceId?: string | null;
      /** @description Human-readable description */
      description?: string | null;
      /** @description Game/application specific metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /** @description How the escrow was resolved */
      resolution?: components['schemas']['EscrowResolution'];
      /** @description Notes about the resolution */
      resolutionNotes?: string | null;
    };
    /** @description An asset held in escrow */
    EscrowAsset: {
      /** @description Type of asset held in escrow */
      assetType: components['schemas']['AssetType'];
      /**
       * Format: uuid
       * @description For assetType=currency - currency definition ID
       */
      currencyDefinitionId?: string | null;
      /** @description Denormalized currency code for display */
      currencyCode?: string | null;
      /** @description Amount of currency */
      currencyAmount?: number | null;
      /**
       * Format: uuid
       * @description For assetType=item - unique item instance ID
       */
      itemInstanceId?: string | null;
      /** @description Denormalized item name for display */
      itemName?: string | null;
      /**
       * Format: uuid
       * @description For assetType=item_stack - stackable item template
       */
      itemTemplateId?: string | null;
      /** @description Denormalized template name for display */
      itemTemplateName?: string | null;
      /** @description For assetType=item_stack - quantity */
      itemQuantity?: number | null;
      /**
       * Format: uuid
       * @description For assetType=contract - contract instance ID
       */
      contractInstanceId?: string | null;
      /** @description Denormalized contract template code */
      contractTemplateCode?: string | null;
      /** @description Description of the contract */
      contractDescription?: string | null;
      /** @description Which party role in the contract is being escrowed */
      contractPartyRole?: string | null;
      /** @description For assetType=custom - registered handler type */
      customAssetType?: string | null;
      /** @description Custom asset identifier */
      customAssetId?: string | null;
      /** @description Handler-specific data */
      customAssetData?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: uuid
       * @description Where this asset came from (for refunds)
       */
      sourceOwnerId: string;
      /** @description Type of the source owner */
      sourceOwnerType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Source wallet/container ID
       */
      sourceContainerId?: string | null;
    };
    /** @description Groups multiple assets for a single deposit or release */
    EscrowAssetBundle: {
      /**
       * Format: uuid
       * @description Bundle identifier
       */
      bundleId: string;
      /** @description Assets in this bundle */
      assets: components['schemas']['EscrowAsset'][];
      /** @description Summary for display */
      description?: string | null;
      /** @description Optional valuation for UI display */
      estimatedValue?: number | null;
    };
    /** @description Input for specifying a bundle of assets */
    EscrowAssetBundleInput: {
      /** @description Assets to deposit */
      assets: components['schemas']['EscrowAssetInput'][];
      /** @description Bundle description */
      description?: string | null;
      /** @description Estimated value */
      estimatedValue?: number | null;
    };
    /** @description Input for specifying an asset in escrow operations */
    EscrowAssetInput: {
      /** @description Type of asset to deposit */
      assetType: components['schemas']['AssetType'];
      /**
       * Format: uuid
       * @description Currency definition ID
       */
      currencyDefinitionId?: string | null;
      /** @description Currency code */
      currencyCode?: string | null;
      /** @description Currency amount */
      currencyAmount?: number | null;
      /**
       * Format: uuid
       * @description Item instance ID
       */
      itemInstanceId?: string | null;
      /** @description Item name */
      itemName?: string | null;
      /**
       * Format: uuid
       * @description Item template ID (for stacks)
       */
      itemTemplateId?: string | null;
      /** @description Item template name */
      itemTemplateName?: string | null;
      /** @description Item quantity (for stacks) */
      itemQuantity?: number | null;
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractInstanceId?: string | null;
      /** @description Contract template code */
      contractTemplateCode?: string | null;
      /** @description Contract description */
      contractDescription?: string | null;
      /** @description Contract party role being escrowed */
      contractPartyRole?: string | null;
      /** @description Custom asset type */
      customAssetType?: string | null;
      /** @description Custom asset ID */
      customAssetId?: string | null;
      /** @description Custom asset data */
      customAssetData?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Records a party consent decision */
    EscrowConsent: {
      /**
       * Format: uuid
       * @description Party giving consent
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Type of consent given */
      consentType: components['schemas']['EscrowConsentType'];
      /**
       * Format: date-time
       * @description When consent was given
       */
      consentedAt: string;
      /** @description Token used (for audit) */
      releaseTokenUsed?: string | null;
      /** @description Optional notes */
      notes?: string | null;
    };
    /**
     * @description Type of consent being given.
     *     - release: Agrees to release assets to recipients
     *     - refund: Agrees to refund assets to depositors
     *     - dispute: Raises a dispute
     *     - reaffirm: Re-affirms after validation failure
     * @enum {string}
     */
    EscrowConsentType: 'release' | 'refund' | 'dispute' | 'reaffirm';
    /** @description Records an actual deposit */
    EscrowDeposit: {
      /**
       * Format: uuid
       * @description Deposit record identifier
       */
      id: string;
      /**
       * Format: uuid
       * @description Escrow this deposit belongs to
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Party who deposited
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Assets deposited */
      assets: components['schemas']['EscrowAssetBundle'];
      /**
       * Format: date-time
       * @description When the deposit was made
       */
      depositedAt: string;
      /** @description Token used (for audit) */
      depositTokenUsed?: string | null;
      /** @description Idempotency key for this deposit */
      idempotencyKey: string;
    };
    /** @description Request from lib-escrow to debit wallet for deposit */
    EscrowDepositRequest: {
      /**
       * Format: uuid
       * @description Wallet to debit
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to debit
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to debit for escrow
       */
      amount: number;
      /**
       * Format: uuid
       * @description Associated escrow agreement ID
       */
      escrowId: string;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Result of escrow deposit (wallet debit) */
    EscrowDepositResponse: {
      /** @description Debit transaction record */
      transaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Wallet balance after debit
       */
      newBalance: number;
    };
    /** @description A party in the escrow agreement */
    EscrowParty: {
      /**
       * Format: uuid
       * @description Party entity identifier
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Display name for UI/logging */
      displayName?: string | null;
      /** @description Role of this party in the escrow */
      role: components['schemas']['EscrowPartyRole'];
      /** @description Whether this party consent is required for release */
      consentRequired: boolean;
      /**
       * Format: uuid
       * @description Party own wallet (where currency comes from/returns to)
       */
      walletId?: string | null;
      /**
       * Format: uuid
       * @description Party own container (where items come from/return to)
       */
      containerId?: string | null;
      /**
       * Format: uuid
       * @description Escrow wallet for THIS party deposits (owned by escrow)
       */
      escrowWalletId?: string | null;
      /**
       * Format: uuid
       * @description Escrow container for THIS party deposits (owned by escrow)
       */
      escrowContainerId?: string | null;
      /** @description Token for depositing (full_consent mode) */
      depositToken?: string | null;
      /** @description Whether the deposit token has been used */
      depositTokenUsed: boolean;
      /**
       * Format: date-time
       * @description When the deposit token was used
       */
      depositTokenUsedAt?: string | null;
      /** @description Token for consenting to release */
      releaseToken?: string | null;
      /** @description Whether the release token has been used */
      releaseTokenUsed: boolean;
      /**
       * Format: date-time
       * @description When the release token was used
       */
      releaseTokenUsedAt?: string | null;
    };
    /**
     * @description Role of a party in the escrow.
     *     - depositor: Deposits assets into escrow
     *     - recipient: Receives assets when released
     *     - depositor_recipient: Both deposits and can receive (typical for trades)
     *     - arbiter: Can resolve disputes, does not deposit or receive
     *     - observer: Can view status but cannot act
     * @enum {string}
     */
    EscrowPartyRole: 'depositor' | 'recipient' | 'depositor_recipient' | 'arbiter' | 'observer';
    /** @description Request from lib-escrow to credit depositor on refund */
    EscrowRefundRequest: {
      /**
       * Format: uuid
       * @description Depositor wallet to credit
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to credit
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to refund
       */
      amount: number;
      /**
       * Format: uuid
       * @description Associated escrow agreement ID
       */
      escrowId: string;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Result of escrow refund (depositor credit) */
    EscrowRefundResponse: {
      /** @description Credit transaction record */
      transaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Depositor balance after credit
       */
      newBalance: number;
    };
    /** @description Request from lib-escrow to credit recipient on completion */
    EscrowReleaseRequest: {
      /**
       * Format: uuid
       * @description Recipient wallet to credit
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to credit
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to credit
       */
      amount: number;
      /**
       * Format: uuid
       * @description Associated escrow agreement ID
       */
      escrowId: string;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Result of escrow release (recipient credit) */
    EscrowReleaseResponse: {
      /** @description Credit transaction record */
      transaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Recipient balance after credit
       */
      newBalance: number;
    };
    /**
     * @description How the escrow was resolved.
     *     - released: Assets went to designated recipients
     *     - refunded: Assets returned to depositors
     *     - split: Arbiter split assets between parties
     *     - expired_refunded: Timed out, auto-refunded
     *     - cancelled_refunded: Cancelled, deposits refunded
     *     - violation_refunded: Validation failure caused refund
     * @enum {string}
     */
    EscrowResolution:
      | 'released'
      | 'refunded'
      | 'split'
      | 'expired_refunded'
      | 'cancelled_refunded'
      | 'violation_refunded';
    /**
     * @description Current status of the escrow agreement.
     *     - pending_deposits: Waiting for parties to deposit
     *     - partially_funded: Some but not all deposits received
     *     - funded: All deposits received, awaiting consent/condition
     *     - pending_consent: Some consents received, waiting for more
     *     - pending_condition: Waiting for contract fulfillment or external verification
     *     - finalizing: Running contract finalizer prebound APIs (transient)
     *     - releasing: Release in progress (transient)
     *     - released: Assets transferred to recipients
     *     - refunding: Refund in progress (transient)
     *     - refunded: Assets returned to depositors
     *     - disputed: In dispute, arbiter must resolve
     *     - expired: Timed out without completion
     *     - cancelled: Cancelled before funding complete
     *     - validation_failed: Held assets changed, awaiting re-affirmation
     * @enum {string}
     */
    EscrowStatus:
      | 'pending_deposits'
      | 'partially_funded'
      | 'funded'
      | 'pending_consent'
      | 'pending_condition'
      | 'finalizing'
      | 'releasing'
      | 'released'
      | 'refunding'
      | 'refunded'
      | 'disputed'
      | 'expired'
      | 'cancelled'
      | 'validation_failed';
    /**
     * @description Trust model for the escrow agreement.
     *     - full_consent: All parties must explicitly consent using tokens
     *     - initiator_trusted: The service that created the escrow can complete unilaterally
     *     - single_party_trusted: A designated party can complete unilaterally
     * @enum {string}
     */
    EscrowTrustMode: 'full_consent' | 'initiator_trusted' | 'single_party_trusted';
    /**
     * @description Type of escrow agreement.
     *     - two_party: Simple trade escrow between Party A and Party B
     *     - multi_party: N parties with complex deposit/receive rules
     *     - conditional: Release based on external condition or contract fulfillment
     *     - auction: Winner-takes-all with refunds to losers
     * @enum {string}
     */
    EscrowType: 'two_party' | 'multi_party' | 'conditional' | 'auction';
    /**
     * @description Categories of historical events that characters can participate in
     * @enum {string}
     */
    EventCategory:
      | 'WAR'
      | 'NATURAL_DISASTER'
      | 'POLITICAL'
      | 'ECONOMIC'
      | 'RELIGIOUS'
      | 'CULTURAL'
      | 'PERSONAL';
    /** @description Request to execute contract clauses */
    ExecuteContractRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractInstanceId: string;
      /** @description Idempotency key for the execution */
      idempotencyKey?: string | null;
    };
    /** @description Response from executing a contract */
    ExecuteContractResponse: {
      /** @description Whether execution was successful */
      executed: boolean;
      /** @description True if this was a repeat call (idempotency) */
      alreadyExecuted: boolean;
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId?: string;
      /** @description Records of what was moved where */
      distributions?: components['schemas']['DistributionRecord'][] | null;
      /**
       * Format: date-time
       * @description When execution occurred
       */
      executedAt?: string | null;
    };
    /** @description Request to execute a currency conversion */
    ExecuteConversionRequest: {
      /**
       * Format: uuid
       * @description Wallet to perform conversion in
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency to debit
       */
      fromCurrencyId: string;
      /**
       * Format: uuid
       * @description Currency to credit
       */
      toCurrencyId: string;
      /**
       * Format: double
       * @description Amount to convert
       */
      fromAmount: number;
      /** @description Unique key for idempotency */
      idempotencyKey: string;
    };
    /** @description Result of conversion execution */
    ExecuteConversionResponse: {
      /** @description Debit transaction (conversion_debit) */
      debitTransaction: components['schemas']['CurrencyTransactionRecord'];
      /** @description Credit transaction (conversion_credit) */
      creditTransaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Amount debited
       */
      fromDebited: number;
      /**
       * Format: double
       * @description Amount credited
       */
      toCredited: number;
      /**
       * Format: double
       * @description Rate applied
       */
      effectiveRate: number;
    };
    /** @description Metadata about behavior execution requirements including timing, resources, and interrupt conditions */
    ExecutionMetadata: {
      /** @description Estimated execution time in seconds */
      estimatedDuration?: number;
      /** @description Resource requirements for behavior execution */
      resourceRequirements?: {
        [key: string]: number;
      } | null;
      /** @description Conditions that can interrupt behavior execution */
      interruptConditions?: string[] | null;
    };
    /** @description Defines what a party should deposit */
    ExpectedDeposit: {
      /**
       * Format: uuid
       * @description Party who should deposit
       */
      partyId: string;
      /** @description Type of depositing party */
      partyType: components['schemas']['EntityType'];
      /** @description Expected assets from this party */
      expectedAssets: components['schemas']['EscrowAsset'][];
      /** @description Is this deposit optional */
      optional: boolean;
      /**
       * Format: date-time
       * @description Deadline for this specific deposit
       */
      depositDeadline?: string | null;
      /** @description Has this party fulfilled their deposit requirement */
      fulfilled: boolean;
    };
    /** @description Input for defining expected deposits from a party */
    ExpectedDepositInput: {
      /**
       * Format: uuid
       * @description Party who should deposit
       */
      partyId: string;
      /** @description Type of depositing party */
      partyType: components['schemas']['EntityType'];
      /** @description Expected assets */
      expectedAssets: components['schemas']['EscrowAssetInput'][];
      /** @description Is this deposit optional */
      optional?: boolean | null;
      /**
       * Format: date-time
       * @description Specific deadline for this deposit
       */
      depositDeadline?: string | null;
    };
    /**
     * @description How currency expiration is determined
     * @enum {string}
     */
    ExpirationPolicy: 'fixed_date' | 'duration_from_earn' | 'end_of_season';
    /** @description Request to export all saves for an owner to a downloadable archive */
    ExportSavesRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the saves to export
       */
      ownerId: string;
      /** @description Type of entity that owns the saves to export */
      ownerType: components['schemas']['OwnerType'];
      /** @description Specific slots to export (all if null) */
      slotNames?: string[];
    };
    /** @description Response with pre-signed URL for downloading exported save archive */
    ExportSavesResponse: {
      /**
       * Format: uri
       * @description Pre-signed URL to download export archive
       */
      downloadUrl: string;
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Archive size
       */
      sizeBytes: number;
    };
    /** @description Request to fail a milestone */
    FailMilestoneRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Milestone that failed */
      milestoneCode: string;
      /** @description Reason for failure */
      reason?: string | null;
    };
    /** @description Reference to a family member */
    FamilyMember: {
      /**
       * Format: uuid
       * @description ID of the related character
       */
      characterId: string;
      /** @description Display name (if available) */
      name?: string | null;
      /** @description Specific relationship type (MOTHER, FATHER, SON, DAUGHTER, etc.) */
      relationshipType: string;
      /** @description Whether the related character is alive */
      isAlive?: boolean;
    };
    /** @description Family relationships for a character */
    FamilyTreeResponse: {
      /** @description Parent relationships (biological and adoptive) */
      parents?: components['schemas']['FamilyMember'][];
      /** @description Child relationships */
      children?: components['schemas']['FamilyMember'][];
      /** @description Sibling relationships (including half-siblings) */
      siblings?: components['schemas']['FamilyMember'][];
      /** @description Current spouse (if any) */
      spouse?: components['schemas']['FamilyMember'];
      /** @description Previous incarnations (if reincarnation tracked) */
      pastLives?: components['schemas']['PastLifeReference'][];
    };
    /** @description Result from a contract finalizer API call */
    FinalizerResult: {
      /** @description Finalizer endpoint */
      endpoint: string;
      /** @description Whether it succeeded */
      success: boolean;
      /** @description Error message if failed */
      error?: string | null;
    };
    /** @description Request to find asset usage */
    FindAssetUsageRequest: {
      /**
       * Format: uuid
       * @description Asset ID to find usage of
       */
      assetId: string;
      /** @description Optional game filter */
      gameId?: string | null;
    };
    /** @description Scenes using the asset */
    FindAssetUsageResponse: {
      /** @description Asset usage instances */
      usages: components['schemas']['AssetUsageInfo'][];
    };
    /** @description Request to find referencing scenes */
    FindReferencesRequest: {
      /**
       * Format: uuid
       * @description Scene ID to find references to
       */
      sceneId: string;
    };
    /** @description Scenes that reference the target */
    FindReferencesResponse: {
      /** @description Scenes containing references */
      referencingScenes: components['schemas']['ReferenceInfo'][];
    };
    /** @description Request to find space for item */
    FindSpaceRequest: {
      /**
       * Format: uuid
       * @description Owner to search
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['ContainerOwnerType'];
      /**
       * Format: uuid
       * @description Item template
       */
      templateId: string;
      /**
       * Format: double
       * @description Quantity to place
       * @default 1
       */
      quantity: number;
      /**
       * @description Prefer existing stacks
       * @default true
       */
      preferStackable: boolean;
    };
    /** @description Find space result */
    FindSpaceResponse: {
      /** @description Whether space found */
      hasSpace: boolean;
      /** @description Potential placements */
      candidates: components['schemas']['SpaceCandidate'][];
    };
    /** @description A musical form structure template */
    FormTemplate: {
      /** @description Form name (e.g., "AABB", "verse-chorus") */
      name: string;
      /** @description Section sequence (e.g., ["A", "A", "B", "B"]) */
      sections: string[];
      /**
       * @description Default bars per section
       * @default 8
       */
      barsPerSection: number;
    };
    /** @description Request to perform a game action such as movement or combat */
    GameActionRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the client. Provided by shortcut system.
       */
      sessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player. Provided by shortcut system.
       */
      accountId: string;
      /** @description Game type for the action. Determines which lobby to apply the action. Provided by shortcut system. */
      gameType: string;
      /** @description Type of game action to perform */
      actionType: components['schemas']['GameActionType'];
      /** @description Action-specific data */
      actionData?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: uuid
       * @description Target of the action (if applicable)
       */
      targetId?: string | null;
    };
    /** @description Response indicating the result of a game action with any state changes */
    GameActionResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for this action instance
       */
      actionId: string;
      /** @description Action result data */
      result?: {
        [key: string]: unknown;
      } | null;
      /** @description Updated game state (if applicable) */
      newGameState?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Type of game action
     * @enum {string}
     */
    GameActionType: 'move' | 'interact' | 'attack' | 'cast_spell' | 'use_item';
    /** @description Information about a player currently participating in a game session */
    GamePlayer: {
      /**
       * Format: uuid
       * @description Unique identifier for the player's account
       */
      accountId: string;
      /**
       * Format: uuid
       * @description WebSocket session ID that joined the game. Chat and events are delivered to this specific session only.
       */
      sessionId: string;
      /** @description Display name shown to other players */
      displayName?: string | null;
      /** @description Role of the player in the game session */
      role: components['schemas']['PlayerRole'];
      /**
       * Format: date-time
       * @description Timestamp when the player joined the session
       */
      joinedAt: string;
      /** @description Game-specific character data for this player (null if none provided) */
      characterData?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: uuid
       * @description Voice participant session ID (if player has joined voice)
       */
      voiceSessionId?: string | null;
    };
    /**
     * @description Realm stub name (lowercase string identifier) that this asset belongs to.
     *     Use the realm's stub_name property (e.g., "realm-1", "realm-2") from the Realm service.
     *     Use "shared" for assets that are available across all realms.
     */
    GameRealm: string;
    /** @description Complete details of a game session including players and settings */
    GameSessionResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the game session
       */
      sessionId: string;
      /** @description Type of game for this session */
      gameType: components['schemas']['GameType'];
      /** @description Type of session - lobby or matchmade */
      sessionType: components['schemas']['SessionType'];
      /** @description Display name for the session */
      sessionName?: string | null;
      /** @description Current status of the game session */
      status: components['schemas']['SessionStatus'];
      /** @description Maximum number of players allowed in the session */
      maxPlayers?: number;
      /** @description Current number of players in the session */
      currentPlayers?: number;
      /** @description Whether the session requires a password to join */
      isPrivate?: boolean;
      /**
       * Format: uuid
       * @description Account ID of the session owner
       */
      owner?: string;
      /** @description List of players currently in the session */
      players?: components['schemas']['GamePlayer'][];
      /**
       * Format: date-time
       * @description Timestamp when the session was created
       */
      createdAt: string;
      /** @description Game-specific configuration settings */
      gameSettings?: {
        [key: string]: unknown;
      } | null;
      /** @description For matchmade sessions - reservation tokens for expected players */
      reservations?: components['schemas']['ReservationInfo'][] | null;
      /**
       * Format: date-time
       * @description For matchmade sessions - when reservations expire
       */
      reservationExpiresAt?: string | null;
    };
    /** @description Game service stub name for this session. Use the game service's stubName property (e.g., "my-game"). Use "generic" for non-game-specific sessions. */
    GameType: string;
    /** @description Request to generate a complete musical composition */
    GenerateCompositionRequest: {
      /**
       * @description ID of the style to use for generation
       * @example celtic
       */
      styleId: string;
      /**
       * @description Target duration in bars
       * @default 32
       */
      durationBars: number;
      /** @description Key signature (random if not specified) */
      key?: components['schemas']['KeySignature'];
      /** @description Tempo in BPM (uses style default if not specified) */
      tempo?: number;
      /**
       * @description Mood constraint for generation
       * @enum {string|null}
       */
      mood?: 'bright' | 'dark' | 'neutral' | 'melancholic' | 'triumphant' | null;
      /**
       * @description Style-specific tune type (e.g., "reel", "jig" for Celtic)
       * @example reel
       */
      tuneType?: string | null;
      /** @description Random seed for reproducible generation */
      seed?: number | null;
      /**
       * @description Narrative/emotional arc options for storyteller-driven composition.
       *     If omitted, narrative is inferred from mood. When provided, enables
       *     fine-grained control over emotional journey and tension curves.
       */
      narrative?: components['schemas']['NarrativeOptions'];
    };
    /** @description Response containing the generated composition */
    GenerateCompositionResponse: {
      /** @description Unique identifier for the composition */
      compositionId: string;
      /** @description Generated MIDI-JSON output */
      midiJson: components['schemas']['MidiJson'];
      /** @description Metadata about the generation */
      metadata?: components['schemas']['CompositionMetadata'];
      /** @description Time taken to generate in milliseconds */
      generationTimeMs?: number;
      /** @description ID of the narrative template used for composition */
      narrativeUsed?: string | null;
      /** @description Emotional state at each section boundary */
      emotionalJourney?: components['schemas']['EmotionalStateSnapshot'][] | null;
      /** @description Tension values at bar boundaries (0-1 scale) */
      tensionCurve?: number[] | null;
    };
    /** @description Request to generate a melody over harmony */
    GenerateMelodyRequest: {
      /** @description Chord progression to generate melody over */
      harmony: components['schemas']['ChordEvent'][];
      /** @description Style for melodic preferences */
      styleId?: string | null;
      /** @description Pitch range for the melody */
      range?: components['schemas']['PitchRange'];
      /**
       * @description Overall melodic contour
       * @enum {string|null}
       */
      contour?: 'arch' | 'wave' | 'ascending' | 'descending' | 'static' | null;
      /**
       * Format: float
       * @description Note density (0=sparse, 1=dense)
       */
      rhythmDensity?: number | null;
      /**
       * Format: float
       * @description Amount of syncopation
       */
      syncopation?: number | null;
      /** @description Random seed for reproducibility */
      seed?: number | null;
    };
    /** @description Response containing a generated melody */
    GenerateMelodyResponse: {
      /** @description Generated note events */
      notes: components['schemas']['NoteEvent'][];
      /** @description Analysis of the melody */
      analysis?: components['schemas']['MelodyAnalysis'];
    };
    /** @description Request to generate a chord progression */
    GenerateProgressionRequest: {
      /** @description Key for the progression */
      key: components['schemas']['KeySignature'];
      /** @description Number of chords in the progression */
      length: number;
      /** @description Style to use for harmonic preferences */
      styleId?: string | null;
      /** @description Starting chord (roman numeral, e.g., "I") */
      startChord?: string | null;
      /** @description Ending chord (roman numeral, e.g., "I") */
      endChord?: string | null;
      /**
       * @description Cadence type for ending
       * @enum {string|null}
       */
      cadenceType?: 'authentic' | 'half' | 'plagal' | 'deceptive' | null;
      /**
       * @description Allow secondary dominant chords
       * @default true
       */
      allowSecondaryDominants: boolean;
      /**
       * @description Allow borrowed chords from parallel modes
       * @default false
       */
      allowModalInterchange: boolean;
      /** @description Random seed for reproducibility */
      seed?: number | null;
    };
    /** @description Response containing a generated chord progression */
    GenerateProgressionResponse: {
      /** @description Generated chord events */
      chords: components['schemas']['ChordEvent'][];
      /** @description Analysis of the progression */
      analysis?: components['schemas']['ProgressionAnalysis'];
    };
    /** @description Request to get subscriptions for an account */
    GetAccountSubscriptionsRequest: {
      /**
       * Format: uuid
       * @description ID of the account to get subscriptions for
       */
      accountId: string;
      /**
       * @description If true, include cancelled subscriptions
       * @default false
       */
      includeInactive: boolean;
      /**
       * @description If true, include expired subscriptions
       * @default false
       */
      includeExpired: boolean;
    };
    /** @description Request to get achievement progress */
    GetAchievementProgressRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type whose progress is requested */
      entityType: components['schemas']['EntityType'];
      /** @description Specific achievement ID (null for all) */
      achievementId?: string | null;
    };
    /** @description Request to retrieve all ancestor types in the hierarchy chain from a relationship type up to the root */
    GetAncestorsRequest: {
      /**
       * Format: uuid
       * @description The relationship type to get ancestors for
       */
      typeId: string;
    };
    /** @description Request to retrieve asset metadata and download URL */
    GetAssetRequest: {
      /** @description Asset identifier */
      assetId: string;
      /**
       * @description Version ID or 'latest'
       * @default latest
       */
      version: string;
    };
    /** @description Request payload for getting a character's backstory */
    GetBackstoryRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get backstory for
       */
      characterId: string;
      /** @description Filter by element types (null for all) */
      elementTypes?: components['schemas']['BackstoryElementType'][] | null;
      /**
       * Format: float
       * @description Filter by minimum strength
       */
      minimumStrength?: number | null;
    };
    /** @description Request to get a specific currency balance */
    GetBalanceRequest: {
      /**
       * Format: uuid
       * @description Wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency definition ID
       */
      currencyDefinitionId: string;
    };
    /** @description Detailed balance information */
    GetBalanceResponse: {
      /**
       * Format: uuid
       * @description Wallet ID
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency definition ID
       */
      currencyDefinitionId: string;
      /** @description Currency code */
      currencyCode?: string;
      /**
       * Format: double
       * @description Total balance
       */
      amount: number;
      /**
       * Format: double
       * @description Amount in authorization holds
       */
      lockedAmount: number;
      /**
       * Format: double
       * @description Available balance (amount - lockedAmount)
       */
      effectiveAmount: number;
      /** @description Earn cap status (null if no caps configured) */
      earnCapInfo?: components['schemas']['EarnCapInfo'];
      /** @description Autogain status (null if autogain not enabled) */
      autogainInfo?: components['schemas']['AutogainInfo'];
    };
    /** @description Request to get breach details */
    GetBreachRequest: {
      /**
       * Format: uuid
       * @description Breach ID
       */
      breachId: string;
    };
    /** @description Request to retrieve bundle metadata and download URL */
    GetBundleRequest: {
      /** @description Human-readable bundle identifier to retrieve */
      bundleId: string;
      /** @description Desired download format (bannou or zip) */
      format?: components['schemas']['BundleFormat'];
    };
    /** @description Request to get a cached compiled behavior */
    GetCachedBehaviorRequest: {
      /** @description Unique identifier for the cached behavior */
      behaviorId: string;
    };
    /** @description Request to retrieve a character's compressed archive */
    GetCharacterArchiveRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get archive for
       */
      characterId: string;
    };
    /** @description Request payload for retrieving a single character by ID */
    GetCharacterRequest: {
      /**
       * Format: uuid
       * @description ID of the character to retrieve
       */
      characterId: string;
    };
    /** @description Request payload for retrieving all characters within a specific realm */
    GetCharactersByRealmRequest: {
      /**
       * Format: uuid
       * @description Realm ID to query (uses partition key for efficiency)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Filter by species
       */
      speciesId?: string | null;
      /** @description Optional status filter */
      status?: components['schemas']['CharacterStatus'] | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to retrieve all child relationship types for a given parent type */
    GetChildRelationshipTypesRequest: {
      /**
       * Format: uuid
       * @description ID of the parent relationship type
       */
      parentTypeId: string;
      /**
       * @description Include all descendants, not just direct children
       * @default false
       */
      recursive: boolean;
    };
    /** @description Request to get capability manifest for a connected session (debugging endpoint) */
    GetClientCapabilitiesRequest: {
      /**
       * Format: uuid
       * @description Session ID to retrieve capabilities for (must have active WebSocket connection)
       */
      sessionId: string;
      /** @description Optional filter by service name prefix */
      serviceFilter?: string | null;
      /**
       * @description Include additional metadata about each capability
       * @default false
       */
      includeMetadata: boolean;
    };
    /** @description Request payload for retrieving combat preferences */
    GetCombatPreferencesRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get combat preferences for
       */
      characterId: string;
    };
    /** @description Request to get consent status for all parties */
    GetConsentStatusRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
    };
    /** @description Response containing consent status for all parties */
    GetConsentStatusResponse: {
      /** @description Consent status per party */
      partiesRequiringConsent: components['schemas']['PartyConsentStatus'][];
      /** @description Number of consents received */
      consentsReceived: number;
      /** @description Number of consents required */
      consentsRequired: number;
      /** @description Whether release can proceed */
      canRelease: boolean;
      /** @description Whether refund can proceed */
      canRefund: boolean;
    };
    /** @description Request to get a container */
    GetContainerRequest: {
      /**
       * Format: uuid
       * @description Container ID to retrieve
       */
      containerId: string;
      /**
       * @description Whether to include item contents
       * @default true
       */
      includeContents: boolean;
    };
    /** @description Request to get a contract instance */
    GetContractInstanceRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
    };
    /** @description Request to get contract status */
    GetContractInstanceStatusRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
    };
    /** @description Request to get contract metadata */
    GetContractMetadataRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
    };
    /** @description Request to get a contract template */
    GetContractTemplateRequest: {
      /**
       * Format: uuid
       * @description Template ID (provide this or code)
       */
      templateId?: string | null;
      /** @description Template code (provide this or templateId) */
      code?: string | null;
    };
    /** @description Request to get a currency definition */
    GetCurrencyDefinitionRequest: {
      /**
       * Format: uuid
       * @description Definition ID (provide this or code)
       */
      definitionId?: string | null;
      /** @description Currency code (provide this or definitionId) */
      code?: string | null;
    };
    /** @description Request to get a map definition */
    GetDefinitionRequest: {
      /**
       * Format: uuid
       * @description Definition ID to retrieve
       */
      definitionId: string;
    };
    /** @description Request to get deposit status for a party */
    GetDepositStatusRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Party ID
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
    };
    /** @description Response containing party deposit status */
    GetDepositStatusResponse: {
      /** @description Expected assets from this party */
      expectedAssets: components['schemas']['EscrowAsset'][];
      /** @description Actually deposited assets */
      depositedAssets: components['schemas']['EscrowAsset'][];
      /** @description Whether deposit requirement is fulfilled */
      fulfilled: boolean;
      /** @description Deposit token (if not yet used) */
      depositToken?: string | null;
      /**
       * Format: date-time
       * @description Deposit deadline
       */
      depositDeadline?: string | null;
    };
    /** @description Request to retrieve a specific document by ID or slug */
    GetDocumentRequest: {
      /** @description Documentation namespace containing the document */
      namespace: string;
      /**
       * Format: uuid
       * @description Unique identifier of the document to retrieve (null if using slug)
       */
      documentId?: string | null;
      /** @description URL-friendly slug of the document to retrieve (null if using documentId) */
      slug?: string | null;
      /**
       * Format: uuid
       * @description Optional session ID for tracking document views (null if not tracking)
       */
      sessionId?: string | null;
      /** @description How deep to fetch related documents (null for no related documents) */
      includeRelated?: components['schemas']['RelatedDepth'];
      /**
       * @description Whether to include full document content
       * @default false
       */
      includeContent: boolean;
      /**
       * @description Whether to render markdown content as HTML
       * @default false
       */
      renderHtml: boolean;
    };
    /** @description Response containing the requested document and optional related documents */
    GetDocumentResponse: {
      /** @description The requested document */
      document: components['schemas']['Document'];
      /** @description List of related documents based on includeRelated depth */
      relatedDocuments?: components['schemas']['DocumentSummary'][];
      /**
       * @description Format of the content field in the response
       * @enum {string}
       */
      contentFormat?: 'markdown' | 'html' | 'none';
    };
    /** @description Request to retrieve an encounter type by code */
    GetEncounterTypeRequest: {
      /** @description Unique code of the encounter type */
      code: string;
    };
    /**
     * @description Request payload for retrieving a character with optional related data.
     *     Each include flag fetches data from its respective service (zero overhead if not requested).
     */
    GetEnrichedCharacterRequest: {
      /**
       * Format: uuid
       * @description ID of the character to retrieve
       */
      characterId: string;
      /**
       * @description Include personality traits from character-personality service
       * @default false
       */
      includePersonality: boolean;
      /**
       * @description Include backstory elements from character-history service
       * @default false
       */
      includeBackstory: boolean;
      /**
       * @description Include family relationships from relationship service
       * @default false
       */
      includeFamilyTree: boolean;
      /**
       * @description Include combat preferences from character-personality service
       * @default false
       */
      includeCombatPreferences: boolean;
    };
    /** @description Request to get an entity's rank */
    GetEntityRankRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type whose rank is requested */
      entityType: components['schemas']['EntityType'];
    };
    /** @description Request to retrieve an escrow agreement by ID */
    GetEscrowRequest: {
      /**
       * Format: uuid
       * @description Escrow ID to retrieve
       */
      escrowId: string;
    };
    /** @description Response containing escrow agreement details */
    GetEscrowResponse: {
      /** @description Escrow agreement details */
      escrow: components['schemas']['EscrowAgreement'];
    };
    /** @description Request payload for getting participants of an event */
    GetEventParticipantsRequest: {
      /**
       * Format: uuid
       * @description ID of the historical event
       */
      eventId: string;
      /** @description Filter by participation role */
      role?: components['schemas']['ParticipationRole'];
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to get exchange rate between currencies */
    GetExchangeRateRequest: {
      /**
       * Format: uuid
       * @description Source currency ID
       */
      fromCurrencyId: string;
      /**
       * Format: uuid
       * @description Target currency ID
       */
      toCurrencyId: string;
    };
    /** @description Exchange rate information */
    GetExchangeRateResponse: {
      /**
       * Format: double
       * @description Conversion rate (from -> to)
       */
      rate: number;
      /**
       * Format: double
       * @description Inverse rate (to -> from)
       */
      inverseRate: number;
      /** @description Base currency code */
      baseCurrency: string;
      /**
       * Format: double
       * @description Source currency rate to base
       */
      fromCurrencyRateToBase: number;
      /**
       * Format: double
       * @description Target currency rate to base
       */
      toCurrencyRateToBase: number;
    };
    /** @description Request to get a specific game session */
    GetGameSessionRequest: {
      /**
       * Format: uuid
       * @description ID of the game session to retrieve
       */
      sessionId: string;
    };
    /** @description Request to get global supply stats */
    GetGlobalSupplyRequest: {
      /**
       * Format: uuid
       * @description Currency to query
       */
      currencyDefinitionId: string;
    };
    /** @description Global supply statistics */
    GetGlobalSupplyResponse: {
      /**
       * Format: double
       * @description Sum of all positive balances
       */
      totalSupply: number;
      /**
       * Format: double
       * @description Total in wallets
       */
      inCirculation: number;
      /**
       * Format: double
       * @description Locked in escrow
       */
      inEscrow: number;
      /**
       * Format: double
       * @description All-time faucet total
       */
      totalMinted: number;
      /**
       * Format: double
       * @description All-time sink total
       */
      totalBurned: number;
      /**
       * Format: double
       * @description Global supply cap (null if none)
       */
      supplyCap?: number | null;
      /**
       * Format: double
       * @description Remaining supply before cap
       */
      supplyCapRemaining?: number | null;
    };
    /** @description Request to get hold details */
    GetHoldRequest: {
      /**
       * Format: uuid
       * @description Hold ID
       */
      holdId: string;
    };
    /** @description Request to get an item instance */
    GetItemInstanceRequest: {
      /**
       * Format: uuid
       * @description Instance ID to retrieve
       */
      instanceId: string;
    };
    /** @description Request to get an item template */
    GetItemTemplateRequest: {
      /**
       * Format: uuid
       * @description Template ID (provide this or code+gameId)
       */
      templateId?: string | null;
      /** @description Item code (provide with gameId) */
      code?: string | null;
      /** @description Game service ID (provide with code) */
      gameId?: string | null;
    };
    /** @description Request to get the status of an async metabundle creation job */
    GetJobStatusRequest: {
      /**
       * Format: uuid
       * @description Job ID from the createMetabundle response
       */
      jobId: string;
    };
    /**
     * @description Status of an async metabundle creation job.
     *     When status is 'ready', the response includes the full metabundle details.
     */
    GetJobStatusResponse: {
      /**
       * Format: uuid
       * @description Job identifier
       */
      jobId: string;
      /** @description Human-readable metabundle identifier being created */
      metabundleId: string;
      /**
       * @description Current job status.
       *     - queued: Waiting for processing resources
       *     - processing: Actively being processed
       *     - ready: Completed successfully
       *     - failed: Creation failed
       *     - cancelled: Job was cancelled
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed' | 'cancelled';
      /** @description Progress percentage (0-100) when status is 'processing' */
      progress?: number | null;
      /**
       * Format: uri
       * @description Pre-signed download URL (only when status is 'ready')
       */
      downloadUrl?: string | null;
      /** @description Number of assets in metabundle (when ready) */
      assetCount?: number | null;
      /** @description Number of standalone assets included (when ready) */
      standaloneAssetCount?: number | null;
      /**
       * Format: int64
       * @description Total size in bytes (when ready)
       */
      sizeBytes?: number | null;
      /** @description Provenance data (when ready) */
      sourceBundles?: components['schemas']['SourceBundleReference'][] | null;
      /** @description Error code (when status is 'failed') */
      errorCode?: string | null;
      /** @description Human-readable error description (when status is 'failed') */
      errorMessage?: string | null;
      /**
       * Format: date-time
       * @description When the job was created
       */
      createdAt?: string | null;
      /**
       * Format: date-time
       * @description When the job was last updated
       */
      updatedAt?: string | null;
      /**
       * Format: int64
       * @description Total processing time in milliseconds (when complete)
       */
      processingTimeMs?: number | null;
    };
    /** @description Request to retrieve the full ancestry chain of a location up to the root */
    GetLocationAncestorsRequest: {
      /**
       * Format: uuid
       * @description The location to get ancestors for
       */
      locationId: string;
    };
    /** @description Request to retrieve a location by its code within a specific realm */
    GetLocationByCodeRequest: {
      /** @description Unique code for the location within the realm */
      code: string;
      /**
       * Format: uuid
       * @description Realm ID to scope the code lookup
       */
      realmId: string;
    };
    /** @description Request to retrieve all descendants of a location (children, grandchildren, etc.) */
    GetLocationDescendantsRequest: {
      /**
       * Format: uuid
       * @description The location to get descendants for
       */
      locationId: string;
      /** @description Optional filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /** @description Maximum depth of descendants to return (null = all) */
      maxDepth?: number | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to retrieve a location by its unique identifier */
    GetLocationRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the location
       */
      locationId: string;
    };
    /** @description Request to get matchmaking statistics */
    GetMatchmakingStatsRequest: {
      /** @description Filter by specific queue (null for all queues) */
      queueId?: string | null;
      /** @description Filter by game ID */
      gameId?: string | null;
    };
    /** @description Request to get matchmaking status */
    GetMatchmakingStatusRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the ticket to query
       */
      ticketId: string;
    };
    /** @description Request to get milestone details */
    GetMilestoneRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Milestone code */
      milestoneCode: string;
    };
    /** @description Request to get or create a container */
    GetOrCreateContainerRequest: {
      /**
       * Format: uuid
       * @description Owner entity ID
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['ContainerOwnerType'];
      /** @description Container type to find or create */
      containerType: string;
      /** @description Constraint model for new container */
      constraintModel: components['schemas']['ContainerConstraintModel'];
      /** @description Default max slots if creating */
      maxSlots?: number | null;
      /**
       * Format: double
       * @description Default max weight if creating
       */
      maxWeight?: number | null;
      /** @description Default grid width if creating */
      gridWidth?: number | null;
      /** @description Default grid height if creating */
      gridHeight?: number | null;
      /**
       * Format: uuid
       * @description Realm for new container
       */
      realmId?: string | null;
    };
    /** @description Request to get or create a wallet */
    GetOrCreateWalletRequest: {
      /**
       * Format: uuid
       * @description Owner entity ID
       */
      ownerId: string;
      /** @description Type of owner entity */
      ownerType: components['schemas']['WalletOwnerType'];
      /**
       * Format: uuid
       * @description Realm ID for realm-scoped wallets
       */
      realmId?: string | null;
    };
    /** @description Result of get-or-create operation */
    GetOrCreateWalletResponse: {
      /** @description Wallet details */
      wallet: components['schemas']['WalletResponse'];
      /** @description All non-zero balances */
      balances: components['schemas']['BalanceSummary'][];
      /** @description Whether a new wallet was created */
      created: boolean;
    };
    /** @description Request payload for getting a character's event participation */
    GetParticipationRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get participation for
       */
      characterId: string;
      /** @description Filter by event category */
      eventCategory?: components['schemas']['EventCategory'];
      /**
       * Format: float
       * @description Filter by minimum significance
       */
      minimumSignificance?: number | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request payload for retrieving a character's personality */
    GetPersonalityRequest: {
      /**
       * Format: uuid
       * @description ID of the character to get personality for
       */
      characterId: string;
    };
    /** @description Request to get a character's perspective on an encounter */
    GetPerspectiveRequest: {
      /**
       * Format: uuid
       * @description Encounter to get perspective for
       */
      encounterId: string;
      /**
       * Format: uuid
       * @description Character whose perspective to retrieve
       */
      characterId: string;
    };
    /** @description Request to get details of a specific queue */
    GetQueueRequest: {
      /** @description ID of the queue to retrieve */
      queueId: string;
    };
    /** @description Request to get entries around an entity */
    GetRanksAroundRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /**
       * Format: uuid
       * @description ID of the entity to center on
       */
      entityId: string;
      /** @description Entity type of the anchor entry */
      entityType: components['schemas']['EntityType'];
      /**
       * @description Entries to show before the entity
       * @default 5
       */
      countBefore: number;
      /**
       * @description Entries to show after the entity
       * @default 5
       */
      countAfter: number;
    };
    /** @description Request to retrieve a realm by its unique code identifier */
    GetRealmByCodeRequest: {
      /** @description Unique code for the realm (e.g., "REALM_1", "REALM_2") */
      code: string;
    };
    /** @description Request payload for getting participants of an event */
    GetRealmEventParticipantsRequest: {
      /**
       * Format: uuid
       * @description ID of the historical event
       */
      eventId: string;
      /** @description Filter by participation role */
      role?: components['schemas']['RealmEventRole'];
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request payload for getting a realm's lore */
    GetRealmLoreRequest: {
      /**
       * Format: uuid
       * @description ID of the realm to get lore for
       */
      realmId: string;
      /** @description Filter by element types (null for all) */
      elementTypes?: components['schemas']['RealmLoreElementType'][] | null;
      /**
       * Format: float
       * @description Filter by minimum strength
       */
      minimumStrength?: number | null;
    };
    /** @description Request payload for getting a realm's event participation */
    GetRealmParticipationRequest: {
      /**
       * Format: uuid
       * @description ID of the realm to get participation for
       */
      realmId: string;
      /** @description Filter by event category */
      eventCategory?: components['schemas']['RealmEventCategory'];
      /**
       * Format: float
       * @description Filter by minimum impact
       */
      minimumImpact?: number | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to retrieve a specific realm by its unique identifier */
    GetRealmRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the realm
       */
      realmId: string;
    };
    /** @description Request to retrieve a specific relationship by its ID */
    GetRelationshipRequest: {
      /**
       * Format: uuid
       * @description ID of the relationship to retrieve
       */
      relationshipId: string;
    };
    /** @description Request to retrieve a relationship type by its unique code string */
    GetRelationshipTypeByCodeRequest: {
      /** @description Unique code for the relationship type (e.g., "SON", "MOTHER", "FRIEND") */
      code: string;
    };
    /** @description Request to retrieve a relationship type by its unique identifier */
    GetRelationshipTypeRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the relationship type
       */
      relationshipTypeId: string;
    };
    /** @description Request to get all relationships between two specific entities */
    GetRelationshipsBetweenRequest: {
      /**
       * Format: uuid
       * @description ID of the first entity to check relationships for
       */
      entity1Id: string;
      /** @description Type of the first entity */
      entity1Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the second entity to check relationships for
       */
      entity2Id: string;
      /** @description Type of the second entity */
      entity2Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Optional filter by relationship type
       */
      relationshipTypeId?: string | null;
      /**
       * @description Include relationships that have ended
       * @default false
       */
      includeEnded: boolean;
    };
    /** @description Request to retrieve a scene */
    GetSceneRequest: {
      /**
       * Format: uuid
       * @description ID of the scene to retrieve
       */
      sceneId: string;
      /** @description Specific version to retrieve (null = latest) */
      version?: string | null;
      /**
       * @description Whether to resolve and embed referenced scenes
       * @default false
       */
      resolveReferences: boolean;
      /**
       * @description Maximum depth for reference resolution (prevents infinite recursion)
       * @default 3
       */
      maxReferenceDepth: number;
    };
    /** @description Response containing a scene and resolution metadata */
    GetSceneResponse: {
      /** @description The retrieved scene */
      scene: components['schemas']['Scene'];
      /** @description List of resolved references (if resolveReferences was true) */
      resolvedReferences?: components['schemas']['ResolvedReference'][] | null;
      /** @description References that could not be resolved (circular, missing, depth exceeded) */
      unresolvedReferences?: components['schemas']['UnresolvedReference'][] | null;
      /** @description Error messages for reference resolution issues */
      resolutionErrors?: string[] | null;
    };
    /** @description Request to get season information */
    GetSeasonRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /** @description Specific season number (null for current) */
      seasonNumber?: number | null;
    };
    /** @description Request to get aggregate sentiment toward another character */
    GetSentimentRequest: {
      /**
       * Format: uuid
       * @description Character whose sentiment to query
       */
      characterId: string;
      /**
       * Format: uuid
       * @description Target character to measure sentiment toward
       */
      targetCharacterId: string;
    };
    /** @description Request to get a service by ID or stub name (provide either one) */
    GetServiceRequest: {
      /**
       * Format: uuid
       * @description ID of the service to retrieve (null if using stubName)
       */
      serviceId?: string | null;
      /** @description Stub name of the service to retrieve (null if using serviceId) */
      stubName?: string | null;
    };
    /** @description Request to retrieve metadata for a specific save slot */
    GetSlotRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
    };
    /** @description Request to retrieve a species by its unique code identifier */
    GetSpeciesByCodeRequest: {
      /** @description Unique code for the species (e.g., "HUMAN", "ELF", "DWARF") */
      code: string;
    };
    /** @description Request to retrieve a single species by its unique identifier */
    GetSpeciesRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the species
       */
      speciesId: string;
    };
    /** @description Request to get a style definition */
    GetStyleRequest: {
      /** @description Style ID to retrieve */
      styleId?: string | null;
      /** @description Style name to retrieve (alternative to ID) */
      styleName?: string | null;
    };
    /** @description Request to get a specific subscription */
    GetSubscriptionRequest: {
      /**
       * Format: uuid
       * @description ID of the subscription to retrieve
       */
      subscriptionId: string;
    };
    /** @description Request to get top leaderboard entries */
    GetTopRanksRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /**
       * @description Number of entries to return
       * @default 100
       */
      count: number;
      /**
       * @description Number of entries to skip
       * @default 0
       */
      offset: number;
    };
    /** @description Request to get transaction history */
    GetTransactionHistoryRequest: {
      /**
       * Format: uuid
       * @description Wallet to query
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Filter by currency
       */
      currencyDefinitionId?: string | null;
      /** @description Filter by transaction types */
      transactionTypes?: components['schemas']['TransactionType'][] | null;
      /**
       * Format: date-time
       * @description Start of date range
       */
      fromDate?: string | null;
      /**
       * Format: date-time
       * @description End of date range
       */
      toDate?: string | null;
      /**
       * @description Results per page
       * @default 50
       */
      limit: number;
      /**
       * @description Result offset
       * @default 0
       */
      offset: number;
    };
    /** @description Paginated transaction history */
    GetTransactionHistoryResponse: {
      /** @description Transaction records */
      transactions: components['schemas']['CurrencyTransactionRecord'][];
      /** @description Total matching transactions */
      totalCount: number;
    };
    /** @description Request to get a transaction by ID */
    GetTransactionRequest: {
      /**
       * Format: uuid
       * @description Transaction ID
       */
      transactionId: string;
    };
    /** @description Request to get transactions by reference */
    GetTransactionsByReferenceRequest: {
      /** @description Reference type */
      referenceType: string;
      /**
       * Format: uuid
       * @description Reference ID
       */
      referenceId: string;
    };
    /** @description Transactions for a reference */
    GetTransactionsByReferenceResponse: {
      /** @description Matching transactions */
      transactions: components['schemas']['CurrencyTransactionRecord'][];
    };
    /** @description Request to get validation rules */
    GetValidationRulesRequest: {
      /** @description Game ID */
      gameId: string;
      /** @description Scene type */
      sceneType: components['schemas']['SceneType'];
    };
    /** @description Response containing validation rules */
    GetValidationRulesResponse: {
      /** @description Game ID */
      gameId: string;
      /** @description Scene type */
      sceneType: components['schemas']['SceneType'];
      /** @description Registered rules (empty if none) */
      rules?: components['schemas']['ValidationRule'][];
    };
    /** @description Request to get a wallet */
    GetWalletRequest: {
      /**
       * Format: uuid
       * @description Wallet ID (provide this or ownerId+ownerType)
       */
      walletId?: string | null;
      /**
       * Format: uuid
       * @description Owner ID (requires ownerType)
       */
      ownerId?: string | null;
      /** @description Owner type (requires ownerId) */
      ownerType?: components['schemas']['WalletOwnerType'];
      /**
       * Format: uuid
       * @description Realm ID (required if using ownerId lookup)
       */
      realmId?: string | null;
    };
    /** @description Goal definition for GOAP planning with conditions and priority */
    GoapGoal: {
      /**
       * @description Name of the goal
       * @example satisfy_hunger
       */
      name: string;
      /** @description Human-readable description of the goal */
      description?: string | null;
      /**
       * @description World state conditions that satisfy this goal (literal conditions)
       * @example {
       *       "hunger": "<= 0.3",
       *       "gold": ">= 50"
       *     }
       */
      conditions: {
        [key: string]: string;
      };
      /** @description Priority of this goal relative to others */
      priority: number;
      /** @description World state conditions required to pursue this goal */
      preconditions?: {
        [key: string]: string;
      } | null;
    };
    /** @description Request to generate a GOAP plan to achieve a goal from current world state */
    GoapPlanRequest: {
      /** @description Unique identifier for the agent requesting the plan */
      agentId?: string | null;
      /** @description The goal to achieve through planning */
      goal: components['schemas']['GoapGoal'];
      /**
       * @description Current world state as key-value pairs
       * @example {
       *       "hunger": 0.8,
       *       "gold": 50,
       *       "location": "home"
       *     }
       */
      worldState: {
        [key: string]: unknown;
      };
      /** @description ID of compiled behavior containing GOAP actions */
      behaviorId: string;
      /** @description Options controlling the planning process */
      options?: components['schemas']['GoapPlanningOptions'];
    };
    /** @description Response containing the generated GOAP plan. If no plan could be found, plan is null and failureReason explains why. */
    GoapPlanResponse: {
      /** @description The generated plan if successful */
      plan?: components['schemas']['GoapPlanResult'];
      /** @description Time spent planning in milliseconds */
      planningTimeMs?: number;
      /** @description Number of nodes expanded during A* search */
      nodesExpanded?: number;
      /**
       * @description Reason for planning failure if unsuccessful
       * @example No plan found - goal unreachable
       */
      failureReason?: string | null;
    };
    /** @description Result of GOAP planning containing the ordered sequence of actions to achieve a goal */
    GoapPlanResult: {
      /** @description ID of the goal this plan achieves */
      goalId: string;
      /** @description Ordered sequence of actions to execute */
      actions: components['schemas']['PlannedActionResponse'][];
      /**
       * Format: float
       * @description Total cost of all actions in the plan
       */
      totalCost: number;
    };
    /** @description Options controlling the GOAP planning process including depth and timeout limits */
    GoapPlanningOptions: {
      /**
       * @description Maximum plan depth (number of actions)
       * @default 10
       */
      maxDepth: number;
      /**
       * @description Maximum nodes to expand during search
       * @default 1000
       */
      maxNodes: number;
      /**
       * @description Planning timeout in milliseconds
       * @default 100
       */
      timeoutMs: number;
    };
    /**
     * @description Preferred role when fighting in groups. Affects positioning,
     *     target priority, and coordination behavior.
     * @enum {string}
     */
    GroupRole: 'FRONTLINE' | 'SUPPORT' | 'FLANKER' | 'LEADER' | 'SOLO';
    /** @description Harmonic progression style preferences */
    HarmonyStyle: {
      /**
       * @description Most common cadence type
       * @default authentic
       * @enum {string}
       */
      primaryCadence: 'authentic' | 'plagal' | 'half' | 'deceptive';
      /**
       * Format: float
       * @description Probability of pre-dominant before dominant
       * @default 0.6
       */
      dominantPrepProbability: number;
      /**
       * Format: float
       * @description Probability of secondary dominants
       * @default 0.3
       */
      secondaryDominantProbability: number;
      /**
       * Format: float
       * @description Probability of borrowed chords
       * @default 0.1
       */
      modalInterchangeProbability: number;
      /** @description Common chord progressions as roman numeral strings */
      commonProgressions?: string[] | null;
    };
    /** @description Individual item check result */
    HasItemResult: {
      /**
       * Format: uuid
       * @description Template checked
       */
      templateId: string;
      /**
       * Format: double
       * @description Required quantity
       */
      required: number;
      /**
       * Format: double
       * @description Available quantity
       */
      available: number;
      /** @description Whether requirement met */
      satisfied: boolean;
    };
    /** @description Request to check for items */
    HasItemsRequest: {
      /**
       * Format: uuid
       * @description Owner to check
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['ContainerOwnerType'];
      /** @description Required items */
      requirements: components['schemas']['ItemRequirement'][];
    };
    /** @description Has items result */
    HasItemsResponse: {
      /** @description Whether all requirements met */
      hasAll: boolean;
      /** @description Per-item results */
      results: components['schemas']['HasItemResult'][];
    };
    /** @description Request to check if two characters have met */
    HasMetRequest: {
      /**
       * Format: uuid
       * @description First character
       */
      characterIdA: string;
      /**
       * Format: uuid
       * @description Second character
       */
      characterIdB: string;
    };
    /** @description Response for has-met check */
    HasMetResponse: {
      /** @description Whether the characters have any recorded encounters */
      hasMet: boolean;
      /** @description Total number of encounters between them */
      encounterCount: number;
    };
    /** @description Information about a hazard in range */
    HazardInfo: {
      /** @description Type of hazard (fire, poison, radiation, deep_water, etc.) */
      hazardType?: string;
      /**
       * Format: float
       * @description Distance to hazard edge
       */
      distance?: number;
      /**
       * Format: float
       * @description Hazard severity (0-1)
       */
      severity?: number;
      /** @description Direction to hazard center */
      direction?: string | null;
    } & {
      [key: string]: unknown;
    };
    /** @description Request to extend checkout lock */
    HeartbeatRequest: {
      /**
       * Format: uuid
       * @description Scene being edited
       */
      sceneId: string;
      /** @description Checkout token */
      checkoutToken: string;
    };
    /** @description Response confirming lock extension */
    HeartbeatResponse: {
      /** @description Whether extension was successful */
      extended: boolean;
      /**
       * Format: date-time
       * @description New expiration time
       */
      newExpiresAt: string;
      /** @description Number of extensions remaining */
      extensionsRemaining?: number;
    };
    /** @description Record of a character's participation in a historical event */
    HistoricalParticipation: {
      /**
       * Format: uuid
       * @description Unique ID for this participation record
       */
      participationId: string;
      /**
       * Format: uuid
       * @description ID of the character who participated
       */
      characterId: string;
      /**
       * Format: uuid
       * @description ID of the historical event
       */
      eventId: string;
      /** @description Name of the event (for display and summarization) */
      eventName: string;
      /** @description Category of the historical event */
      eventCategory: components['schemas']['EventCategory'];
      /** @description How the character participated */
      role: components['schemas']['ParticipationRole'];
      /**
       * Format: date-time
       * @description In-game date when the event occurred
       */
      eventDate: string;
      /**
       * Format: float
       * @description How significant this event was for the character (0.0 to 1.0).
       *     Affects behavior system weighting of this memory.
       * @default 0.5
       */
      significance: number;
      /** @description Event-specific details for behavior decisions */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When this record was created
       */
      createdAt: string;
    };
    /** @description Request for scene version history */
    HistoryRequest: {
      /**
       * Format: uuid
       * @description Scene to get history for
       */
      sceneId: string;
      /**
       * @description Maximum versions to return
       * @default 10
       */
      limit: number;
    };
    /** @description Scene version history */
    HistoryResponse: {
      /**
       * Format: uuid
       * @description Scene ID
       */
      sceneId: string;
      /** @description Current active version */
      currentVersion?: string;
      /** @description Version history entries */
      versions: components['schemas']['VersionInfo'][];
    };
    /** @description Authorization hold record */
    HoldRecord: {
      /**
       * Format: uuid
       * @description Unique hold identifier
       */
      holdId: string;
      /**
       * Format: uuid
       * @description Wallet with held funds
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Currency held
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount reserved
       */
      amount: number;
      /** @description Current hold status */
      status: components['schemas']['HoldStatus'];
      /**
       * Format: date-time
       * @description When hold was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When hold auto-releases
       */
      expiresAt: string;
      /** @description Reference type */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference ID
       */
      referenceId?: string | null;
      /**
       * Format: double
       * @description Amount actually captured (may differ from held amount)
       */
      capturedAmount?: number | null;
      /**
       * Format: date-time
       * @description When hold was captured/released/expired
       */
      completedAt?: string | null;
    };
    /** @description Hold details */
    HoldResponse: {
      /** @description Hold record */
      hold: components['schemas']['HoldRecord'];
    };
    /**
     * @description Current status of an authorization hold
     * @enum {string}
     */
    HoldStatus: 'active' | 'captured' | 'released' | 'expired';
    /** @description Request to inject a perception event into an actor's queue */
    InjectPerceptionRequest: {
      /** @description Target actor to inject perception into */
      actorId: string;
      /** @description Perception data to inject */
      perception: components['schemas']['PerceptionData'];
    };
    /** @description Response confirming perception injection */
    InjectPerceptionResponse: {
      /** @description Whether the perception was successfully queued */
      queued: boolean;
      /** @description Current depth of the perception queue */
      queueDepth: number;
    };
    /** @description Melodic interval preference weights */
    IntervalPreferences: {
      /**
       * Format: float
       * @description Weight for stepwise motion (M2, m2)
       * @default 0.5
       */
      stepWeight: number;
      /**
       * Format: float
       * @description Weight for thirds (M3, m3)
       * @default 0.25
       */
      thirdWeight: number;
      /**
       * Format: float
       * @description Weight for larger leaps (P4, P5)
       * @default 0.15
       */
      leapWeight: number;
      /**
       * Format: float
       * @description Weight for leaps larger than P5
       * @default 0.1
       */
      largeLeapWeight: number;
    };
    /** @description Request to invalidate a cached behavior */
    InvalidateCacheRequest: {
      /** @description Unique identifier for the cached behavior to invalidate */
      behaviorId: string;
    };
    /**
     * @description Item classification category
     * @enum {string}
     */
    ItemCategory:
      | 'weapon'
      | 'armor'
      | 'accessory'
      | 'consumable'
      | 'material'
      | 'container'
      | 'quest'
      | 'currency_like'
      | 'misc'
      | 'custom';
    /** @description Item instance details */
    ItemInstanceResponse: {
      /**
       * Format: uuid
       * @description Unique instance identifier
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Reference to the item template
       */
      templateId: string;
      /**
       * Format: uuid
       * @description Container holding this item
       */
      containerId: string;
      /**
       * Format: uuid
       * @description Realm this instance exists in
       */
      realmId: string;
      /**
       * Format: double
       * @description Item quantity
       */
      quantity: number;
      /** @description Slot position in slot-based containers */
      slotIndex?: number | null;
      /** @description X position in grid-based containers */
      slotX?: number | null;
      /** @description Y position in grid-based containers */
      slotY?: number | null;
      /** @description Whether item is rotated in grid */
      rotated?: boolean | null;
      /** @description Current durability */
      currentDurability?: number | null;
      /**
       * Format: uuid
       * @description Character ID this item is bound to
       */
      boundToId?: string | null;
      /**
       * Format: date-time
       * @description When item was bound
       */
      boundAt?: string | null;
      /** @description Instance-specific stat modifications */
      customStats?: Record<string, never> | null;
      /** @description Player-assigned custom name */
      customName?: string | null;
      /** @description Other instance-specific data */
      instanceMetadata?: Record<string, never> | null;
      /** @description How this item instance was created */
      originType: components['schemas']['ItemOriginType'];
      /**
       * Format: uuid
       * @description Source entity ID
       */
      originId?: string | null;
      /**
       * Format: date-time
       * @description Instance creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last modification timestamp
       */
      modifiedAt?: string | null;
    };
    /**
     * @description How currency is linked to inventory items
     * @enum {string}
     */
    ItemLinkageMode: 'none' | 'visual_only' | 'reference_only';
    /**
     * @description How an item instance was created
     * @enum {string}
     */
    ItemOriginType: 'loot' | 'quest' | 'craft' | 'trade' | 'purchase' | 'spawn' | 'other';
    /**
     * @description Item rarity tier
     * @enum {string}
     */
    ItemRarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary' | 'custom';
    /** @description Required item and quantity */
    ItemRequirement: {
      /**
       * Format: uuid
       * @description Required template
       */
      templateId: string;
      /**
       * Format: double
       * @description Required quantity
       */
      quantity: number;
    };
    /**
     * @description Realm availability scope (consistent with CurrencyScope)
     * @enum {string}
     */
    ItemScope: 'global' | 'realm_specific' | 'multi_realm';
    /** @description Item template details */
    ItemTemplateResponse: {
      /**
       * Format: uuid
       * @description Unique template identifier
       */
      templateId: string;
      /** @description Unique code within the game */
      code: string;
      /** @description Game service this template belongs to */
      gameId: string;
      /** @description Human-readable display name */
      name: string;
      /** @description Detailed description */
      description?: string | null;
      /** @description Item classification category */
      category: components['schemas']['ItemCategory'];
      /** @description Game-defined subcategory */
      subcategory?: string | null;
      /** @description Filtering tags */
      tags?: string[];
      /** @description Item rarity tier */
      rarity?: components['schemas']['ItemRarity'];
      /** @description How quantities are tracked */
      quantityModel: components['schemas']['QuantityModel'];
      /** @description Maximum stack size */
      maxStackSize: number;
      /** @description Unit for continuous quantities */
      unitOfMeasure?: string | null;
      /** @description Precision for weight values */
      weightPrecision?: components['schemas']['WeightPrecision'];
      /**
       * Format: double
       * @description Weight value
       */
      weight?: number | null;
      /**
       * Format: double
       * @description Volume for volumetric inventories
       */
      volume?: number | null;
      /** @description Width in grid-based inventories */
      gridWidth?: number | null;
      /** @description Height in grid-based inventories */
      gridHeight?: number | null;
      /** @description Whether item can be rotated in grid */
      canRotate?: boolean | null;
      /**
       * Format: double
       * @description Reference price
       */
      baseValue?: number | null;
      /** @description Whether item can be traded */
      tradeable: boolean;
      /** @description Whether item can be destroyed */
      destroyable: boolean;
      /** @description Binding behavior type */
      soulboundType: components['schemas']['SoulboundType'];
      /** @description Whether item has durability */
      hasDurability: boolean;
      /** @description Maximum durability value */
      maxDurability?: number | null;
      /** @description Realm availability scope */
      scope: components['schemas']['ItemScope'];
      /** @description Available realms */
      availableRealms?: string[] | null;
      /** @description Game-defined stats */
      stats?: Record<string, never> | null;
      /** @description Game-defined effects */
      effects?: Record<string, never> | null;
      /** @description Game-defined requirements */
      requirements?: Record<string, never> | null;
      /** @description Display properties */
      display?: Record<string, never> | null;
      /** @description Other game-specific data */
      metadata?: Record<string, never> | null;
      /** @description Whether template is active */
      isActive: boolean;
      /** @description Whether template is deprecated */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description When template was deprecated
       */
      deprecatedAt?: string | null;
      /**
       * Format: uuid
       * @description Migration target template
       */
      migrationTargetId?: string | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last update timestamp
       */
      updatedAt: string;
    };
    /** @description Request to join a matchmaking queue */
    JoinMatchmakingRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID for event delivery
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player joining
       */
      accountId: string;
      /** @description ID of the queue to join */
      queueId: string;
      /**
       * Format: uuid
       * @description Party ID if joining as part of a party
       */
      partyId?: string | null;
      /** @description Party member information (required if partyId provided) */
      partyMembers?: components['schemas']['PartyMemberInfo'][] | null;
      /** @description String properties for query matching */
      stringProperties?: {
        [key: string]: string;
      } | null;
      /** @description Numeric properties for query matching */
      numericProperties?: {
        [key: string]: number;
      } | null;
      /** @description Lucene-like query for opponent matching */
      query?: string | null;
      /**
       * Format: uuid
       * @description Tournament ID if joining tournament queue
       */
      tournamentId?: string | null;
    };
    /** @description Response after joining a matchmaking queue */
    JoinMatchmakingResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for this matchmaking ticket
       */
      ticketId: string;
      /** @description Queue that was joined */
      queueId: string;
      /** @description Estimated wait time based on current queue (null if unknown) */
      estimatedWaitSeconds: number | null;
      /** @description Approximate position in queue (null if not tracked) */
      position?: number | null;
    };
    /**
     * @description JSON Patch operation per RFC 6902.
     *     Uses JsonPatch.Net library (MIT licensed).
     */
    JsonPatchOperation: {
      /**
       * @description Operation type
       * @enum {string}
       */
      op: 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';
      /** @description JSON Pointer to target location */
      path: string;
      /** @description Source path (for move/copy operations) */
      from?: string | null;
      /** @description Value to use (for add/replace/test operations) */
      value?: unknown;
    };
    /** @description A key signature with tonic and mode */
    KeySignature: {
      /** @description Tonic pitch class */
      tonic: components['schemas']['PitchClass'];
      /**
       * @description Mode/scale type
       * @enum {string}
       */
      mode:
        | 'major'
        | 'minor'
        | 'dorian'
        | 'phrygian'
        | 'lydian'
        | 'mixolydian'
        | 'aeolian'
        | 'locrian';
    };
    /** @description A key signature change event */
    KeySignatureEvent: {
      /** @description Tick position */
      tick: number;
      /** @description Tonic pitch class */
      tonic: components['schemas']['PitchClass'];
      /** @description Mode/scale type */
      mode: components['schemas']['ModeType'];
    };
    /** @description Configuration for a specific layer within a map definition */
    LayerDefinition: {
      /** @description The layer kind */
      kind: components['schemas']['MapKind'];
      /**
       * @description How this layer's data should be stored
       * @default cached
       * @enum {string}
       */
      storageMode: 'durable' | 'cached' | 'ephemeral';
      /** @description TTL for cached/ephemeral data (0 = no TTL) */
      ttlSeconds?: number | null;
      /** @description Default non-authority handling for channels using this layer */
      defaultNonAuthorityHandling?: components['schemas']['NonAuthorityHandlingMode'];
      /**
       * Format: double
       * @description Spatial cell size for indexing (default from config if not set)
       */
      cellSize?: number | null;
    };
    /** @description Leaderboard definition details */
    LeaderboardDefinitionResponse: {
      /**
       * Format: uuid
       * @description ID of the owning game service
       */
      gameServiceId: string;
      /** @description Unique identifier for this leaderboard */
      leaderboardId: string;
      /** @description Human-readable name */
      displayName: string;
      /** @description Description of the leaderboard */
      description?: string | null;
      /** @description Allowed entity types */
      entityTypes?: components['schemas']['EntityType'][];
      /** @description Ordering used when ranking scores (descending for high scores, ascending for low) */
      sortOrder: components['schemas']['SortOrder'];
      /** @description Rule applied when new scores are submitted (replace/increment/max/min) */
      updateMode: components['schemas']['UpdateMode'];
      /** @description Whether the leaderboard is seasonal */
      isSeasonal: boolean;
      /** @description Whether the leaderboard is publicly visible */
      isPublic: boolean;
      /** @description Current season number (if seasonal) */
      currentSeason?: number | null;
      /**
       * Format: int64
       * @description Number of entries on the leaderboard
       */
      entryCount?: number;
      /**
       * Format: date-time
       * @description When the leaderboard was created
       */
      createdAt: string;
      /** @description Additional metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response containing leaderboard entries */
    LeaderboardEntriesResponse: {
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /** @description List of leaderboard entries */
      entries: components['schemas']['LeaderboardEntry'][];
      /**
       * Format: int64
       * @description Total entries on the leaderboard
       */
      totalEntries: number;
    };
    /** @description A single entry on a leaderboard */
    LeaderboardEntry: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type for this leaderboard entry */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: double
       * @description Entity's score
       */
      score: number;
      /**
       * Format: int64
       * @description Entity's rank (1-based)
       */
      rank: number;
      /** @description Cached display name for the entity */
      displayName?: string | null;
      /** @description Entry metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to leave a specific game session by ID */
    LeaveGameSessionByIdRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the client leaving.
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player leaving.
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the game session to leave.
       */
      gameSessionId: string;
    };
    /** @description Request to leave a game session */
    LeaveGameSessionRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID of the client leaving. Provided by shortcut system.
       */
      sessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player leaving. Provided by shortcut system.
       */
      accountId: string;
      /** @description Game type being left. Determines which lobby to leave. Provided by shortcut system. */
      gameType: string;
    };
    /** @description Request to leave a matchmaking queue */
    LeaveMatchmakingRequest: {
      /**
       * Format: uuid
       * @description WebSocket session ID
       */
      webSocketSessionId: string;
      /**
       * Format: uuid
       * @description Account ID of the player
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the ticket to cancel
       */
      ticketId: string;
    };
    /** @description Request to list achievement definitions */
    ListAchievementDefinitionsRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description Filter by platform */
      platform?: components['schemas']['Platform'];
      /** @description Filter by achievement classification */
      achievementType?: components['schemas']['AchievementType'];
      /** @description Filter by active status */
      isActive?: boolean | null;
      /**
       * @description Include hidden achievements in response
       * @default false
       */
      includeHidden: boolean;
    };
    /** @description Response containing achievement definitions */
    ListAchievementDefinitionsResponse: {
      /** @description List of achievement definitions */
      achievements: components['schemas']['AchievementDefinitionResponse'][];
    };
    /** @description Request to list available archives for a namespace */
    ListArchivesRequest: {
      /** @description Documentation namespace to list archives for */
      namespace: string;
      /**
       * @description Maximum number of archives to return
       * @default 20
       */
      limit: number;
      /**
       * @description Number of archives to skip
       * @default 0
       */
      offset: number;
    };
    /** @description Response containing a paginated list of archives */
    ListArchivesResponse: {
      /** @description List of archives for the namespace */
      archives: components['schemas']['ArchiveInfo'][];
      /** @description Total number of archives */
      total: number;
    };
    /** @description Request to list bundle version history */
    ListBundleVersionsRequest: {
      /** @description Human-readable bundle identifier to get history for */
      bundleId: string;
      /**
       * @description Maximum versions to return
       * @default 50
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description Bundle version history */
    ListBundleVersionsResponse: {
      /** @description Human-readable bundle identifier */
      bundleId: string;
      /** @description Current version number */
      currentVersion: number;
      /** @description Version history records (newest first) */
      versions: components['schemas']['BundleVersionRecord'][];
      /** @description Total number of versions */
      totalCount: number;
    };
    /** @description Request payload for listing characters with filtering and pagination */
    ListCharactersRequest: {
      /**
       * Format: uuid
       * @description Realm to list characters from (required for efficiency)
       */
      realmId: string;
      /**
       * Format: uuid
       * @description Filter by species
       */
      speciesId?: string | null;
      /** @description Filter by status */
      status?: components['schemas']['CharacterStatus'] | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list clause types */
    ListClauseTypesRequest: {
      /** @description Filter by category */
      category?: components['schemas']['ClauseCategory'];
      /**
       * @description Include built-in types in response
       * @default true
       */
      includeBuiltIn: boolean;
    };
    /** @description Response containing list of clause types */
    ListClauseTypesResponse: {
      /** @description List of registered clause types */
      clauseTypes: components['schemas']['ClauseTypeSummary'][];
    };
    /** @description Request to list containers for an owner */
    ListContainersRequest: {
      /**
       * Format: uuid
       * @description Owner entity ID
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['ContainerOwnerType'];
      /** @description Filter by container type */
      containerType?: string | null;
      /**
       * @description Include equipment slot containers
       * @default true
       */
      includeEquipmentSlots: boolean;
      /**
       * Format: uuid
       * @description Filter by realm
       */
      realmId?: string | null;
    };
    /** @description List of containers */
    ListContainersResponse: {
      /** @description List of containers */
      containers: components['schemas']['ContainerResponse'][];
      /** @description Total count */
      totalCount: number;
    };
    /** @description Request to list contract templates */
    ListContractTemplatesRequest: {
      /**
       * Format: uuid
       * @description Filter by realm (null includes cross-realm templates)
       */
      realmId?: string | null;
      /** @description Filter by active status */
      isActive?: boolean | null;
      /** @description Search in name and description */
      searchTerm?: string | null;
      /**
       * @description Page number (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Paginated list of contract templates */
    ListContractTemplatesResponse: {
      /** @description List of templates */
      templates: components['schemas']['ContractTemplateResponse'][];
      /** @description Total matching templates */
      totalCount: number;
      /** @description Current page number */
      page: number;
      /** @description Results per page */
      pageSize: number;
      /** @description Whether more results exist */
      hasNextPage?: boolean;
    };
    /** @description Request to list currency definitions */
    ListCurrencyDefinitionsRequest: {
      /**
       * Format: uuid
       * @description Filter by realm availability
       */
      realmId?: string | null;
      /** @description Filter by scope */
      scope?: components['schemas']['CurrencyScope'];
      /**
       * @description Include inactive definitions
       * @default false
       */
      includeInactive: boolean;
      /** @description Filter by base currency flag */
      isBaseCurrency?: boolean | null;
    };
    /** @description List of currency definitions */
    ListCurrencyDefinitionsResponse: {
      /** @description Currency definitions matching filter */
      definitions: components['schemas']['CurrencyDefinitionResponse'][];
    };
    /** @description Request to list map definitions */
    ListDefinitionsRequest: {
      /** @description Filter by name (partial match) */
      nameFilter?: string | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Max results to return
       * @default 50
       */
      limit: number;
    };
    /** @description Response containing list of map definitions */
    ListDefinitionsResponse: {
      /** @description List of definitions */
      definitions?: components['schemas']['MapDefinition'][];
      /** @description Total count matching filter */
      total?: number;
      /** @description Current offset */
      offset?: number;
      /** @description Results limit used */
      limit?: number;
    };
    /** @description Request to list documents with optional filtering and pagination */
    ListDocumentsRequest: {
      /** @description Documentation namespace to list documents from */
      namespace: string;
      /** @description Filter to a specific category */
      category?: components['schemas']['DocumentCategory'];
      /** @description Filter by tags (null to skip tag filtering) */
      tags?: string[] | null;
      /**
       * @description Whether documents must match all tags or any tag
       * @default all
       * @enum {string}
       */
      tagsMatch: 'all' | 'any';
      /**
       * Format: date-time
       * @description Filter to documents created after this timestamp
       */
      createdAfter?: string;
      /**
       * Format: date-time
       * @description Filter to documents created before this timestamp
       */
      createdBefore?: string;
      /**
       * Format: date-time
       * @description Filter to documents updated after this timestamp
       */
      updatedAfter?: string;
      /**
       * Format: date-time
       * @description Filter to documents updated before this timestamp
       */
      updatedBefore?: string;
      /**
       * @description Return only document titles without summaries
       * @default false
       */
      titlesOnly: boolean;
      /**
       * @description Page number for pagination
       * @default 1
       */
      page: number;
      /**
       * @description Number of documents per page
       * @default 20
       */
      pageSize: number;
      /** @description Field to sort results by */
      sortBy?: components['schemas']['ListSortField'];
      /**
       * @description Sort order direction
       * @default desc
       * @enum {string}
       */
      sortOrder: 'asc' | 'desc';
    };
    /** @description Response containing a paginated list of documents */
    ListDocumentsResponse: {
      /** @description The namespace that was listed */
      namespace: string;
      /** @description List of documents in the namespace */
      documents: components['schemas']['DocumentSummary'][];
      /** @description Total number of documents matching filters */
      totalCount?: number;
      /** @description Current page number */
      page?: number;
      /** @description Number of documents per page */
      pageSize?: number;
      /** @description Total number of pages available */
      totalPages?: number;
    };
    /** @description Request to list encounter types with optional filtering */
    ListEncounterTypesRequest: {
      /**
       * @description Include soft-deleted types
       * @default false
       */
      includeInactive: boolean;
      /**
       * @description Only return built-in types
       * @default false
       */
      builtInOnly: boolean;
      /**
       * @description Only return custom types
       * @default false
       */
      customOnly: boolean;
    };
    /** @description Request to list escrow agreements with optional filters */
    ListEscrowsRequest: {
      /**
       * Format: uuid
       * @description Filter by party
       */
      partyId?: string | null;
      /** @description Party type filter */
      partyType?: components['schemas']['EntityType'] | null;
      /** @description Filter by status */
      status?: components['schemas']['EscrowStatus'][] | null;
      /** @description Filter by reference type */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Filter by reference ID
       */
      referenceId?: string | null;
      /**
       * Format: date-time
       * @description Filter from date
       */
      fromDate?: string | null;
      /**
       * Format: date-time
       * @description Filter to date
       */
      toDate?: string | null;
      /** @description Limit results */
      limit?: number | null;
      /** @description Offset for pagination */
      offset?: number | null;
    };
    /** @description Response containing list of escrow agreements */
    ListEscrowsResponse: {
      /** @description List of escrow agreements matching the query */
      escrows: components['schemas']['EscrowAgreement'][];
      /** @description Total count for pagination */
      totalCount: number;
    };
    /** @description Request to list item templates */
    ListItemTemplatesRequest: {
      /** @description Filter by game service */
      gameId?: string;
      /** @description Filter by item category */
      category?: components['schemas']['ItemCategory'];
      /** @description Filter by subcategory */
      subcategory?: string | null;
      /** @description Filter by tags (items must have all specified tags) */
      tags?: string[] | null;
      /** @description Filter by rarity tier */
      rarity?: components['schemas']['ItemRarity'];
      /** @description Filter by realm scope */
      scope?: components['schemas']['ItemScope'];
      /**
       * Format: uuid
       * @description Filter by realm availability
       */
      realmId?: string | null;
      /**
       * @description Include inactive templates
       * @default false
       */
      includeInactive: boolean;
      /**
       * @description Include deprecated templates
       * @default false
       */
      includeDeprecated: boolean;
      /** @description Search in name and description */
      search?: string | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results to return
       * @default 50
       */
      limit: number;
    };
    /** @description Paginated list of item templates */
    ListItemTemplatesResponse: {
      /** @description List of templates */
      templates: components['schemas']['ItemTemplateResponse'][];
      /** @description Total number of matching templates */
      totalCount: number;
    };
    /** @description Request to list items in a container */
    ListItemsByContainerRequest: {
      /**
       * Format: uuid
       * @description Container to list items from
       */
      containerId: string;
    };
    /** @description List of item instances */
    ListItemsResponse: {
      /** @description List of items */
      items: components['schemas']['ItemInstanceResponse'][];
      /** @description Total number of matching items */
      totalCount: number;
    };
    /** @description Request to list all child locations of a specified parent location */
    ListLocationsByParentRequest: {
      /**
       * Format: uuid
       * @description ID of the parent location
       */
      parentLocationId: string;
      /** @description Optional filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list all locations within a specific realm with optional filtering */
    ListLocationsByRealmRequest: {
      /**
       * Format: uuid
       * @description Realm ID to query
       */
      realmId: string;
      /** @description Optional type filter */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list locations within a realm with optional type and deprecation filtering */
    ListLocationsRequest: {
      /**
       * Format: uuid
       * @description Realm ID to query (required - locations are partitioned by realm)
       */
      realmId: string;
      /** @description Filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list available matchmaking queues */
    ListQueuesRequest: {
      /** @description Filter by game ID (null for all games) */
      gameId?: string | null;
      /**
       * @description Include disabled queues in the list (admin only)
       * @default false
       */
      includeDisabled: boolean;
    };
    /** @description Response containing available matchmaking queues */
    ListQueuesResponse: {
      /** @description List of available queues */
      queues: components['schemas']['QueueSummary'][];
    };
    /** @description Request to list realms with optional filtering and pagination */
    ListRealmsRequest: {
      /** @description Filter by category (e.g., "MAIN", "SPECIAL", "TEST") */
      category?: string | null;
      /** @description Filter by active status */
      isActive?: boolean | null;
      /**
       * @description Whether to include deprecated realms in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of realms to return per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list relationship types with optional filtering by category, hierarchy, and deprecation status */
    ListRelationshipTypesRequest: {
      /** @description Filter by category (e.g., "FAMILY", "SOCIAL", "ECONOMIC") (null to include all) */
      category?: string | null;
      /**
       * @description Whether to include child types in the response
       * @default true
       */
      includeChildren: boolean;
      /**
       * @description Only return types with no parent (root types)
       * @default false
       */
      rootsOnly: boolean;
      /**
       * @description Whether to include deprecated types in the response
       * @default false
       */
      includeDeprecated: boolean;
    };
    /** @description Request to list all relationships for a specific entity with optional filters */
    ListRelationshipsByEntityRequest: {
      /**
       * Format: uuid
       * @description ID of the entity to get relationships for
       */
      entityId: string;
      /** @description Type of the entity to get relationships for */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Optional filter by relationship type
       */
      relationshipTypeId?: string | null;
      /** @description Optional filter by the other entity's type */
      otherEntityType?: components['schemas']['EntityType'];
      /**
       * @description Include relationships that have ended
       * @default false
       */
      includeEnded: boolean;
      /**
       * @description Page number for paginated results (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page (max 100)
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list all relationships of a specific relationship type */
    ListRelationshipsByTypeRequest: {
      /**
       * Format: uuid
       * @description Relationship type to filter by
       */
      relationshipTypeId: string;
      /** @description Optional filter by entity1 type */
      entity1Type?: components['schemas']['EntityType'];
      /** @description Optional filter by entity2 type */
      entity2Type?: components['schemas']['EntityType'];
      /**
       * @description Include relationships that have ended
       * @default false
       */
      includeEnded: boolean;
      /**
       * @description Page number for paginated results (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page (max 100)
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list all repository bindings with optional filtering */
    ListRepositoryBindingsRequest: {
      /** @description Filter by binding status */
      status?: components['schemas']['BindingStatus'];
      /**
       * @description Maximum number of bindings to return
       * @default 50
       */
      limit: number;
      /**
       * @description Number of bindings to skip
       * @default 0
       */
      offset: number;
    };
    /** @description Response containing a list of repository bindings */
    ListRepositoryBindingsResponse: {
      /** @description List of repository bindings */
      bindings: components['schemas']['RepositoryBindingInfo'][];
      /** @description Total number of bindings matching filter */
      total: number;
    };
    /** @description Request to list all top-level locations (without parents) in a realm */
    ListRootLocationsRequest: {
      /**
       * Format: uuid
       * @description Realm ID to get root locations for
       */
      realmId: string;
      /** @description Optional filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list scenes with optional filters */
    ListScenesRequest: {
      /** @description Filter by game ID */
      gameId?: string | null;
      /** @description Filter by single scene type */
      sceneType?: components['schemas']['SceneType'];
      /** @description Filter by multiple scene types (OR) */
      sceneTypes?: components['schemas']['SceneType'][] | null;
      /** @description Filter by tags (scenes must have ALL specified tags) */
      tags?: string[] | null;
      /** @description Filter by name containing this substring (case-insensitive) */
      nameContains?: string | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results to return
       * @default 50
       */
      limit: number;
    };
    /** @description Response containing scene list and pagination info */
    ListScenesResponse: {
      /** @description List of scene summaries (not full documents) */
      scenes: components['schemas']['SceneSummary'][];
      /** @description Total number of matching scenes */
      total: number;
      /** @description Current offset */
      offset?: number;
      /** @description Applied limit */
      limit?: number;
    };
    /** @description Request to list all registered schemas for a namespace */
    ListSchemasRequest: {
      /** @description Schema namespace to list */
      namespace: string;
    };
    /** @description List of registered schemas with latest version indicator */
    ListSchemasResponse: {
      /** @description Registered schemas */
      schemas: components['schemas']['SchemaResponse'][];
      /** @description Latest schema version */
      latestVersion?: string | null;
    };
    /** @description Request to list all game services */
    ListServicesRequest: {
      /**
       * @description If true, only return active services
       * @default false
       */
      activeOnly: boolean;
    };
    /** @description Response containing list of game services */
    ListServicesResponse: {
      /** @description List of game services matching the request criteria */
      services: components['schemas']['ServiceInfo'][];
      /** @description Total number of services matching the filter */
      totalCount: number;
    };
    /** @description Request to list all save slots belonging to a specific owner */
    ListSlotsRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns the save slots to list */
      ownerType: components['schemas']['OwnerType'];
      /** @description Optional filter by save category */
      category?: components['schemas']['SaveCategory'] | null;
      /**
       * @description Include version count in response
       * @default true
       */
      includeVersionCount: boolean;
    };
    /** @description Response containing a list of save slots for an owner */
    ListSlotsResponse: {
      /** @description List of slots */
      slots: components['schemas']['SlotResponse'][];
      /** @description Total number of slots for owner */
      totalCount?: number;
    };
    /**
     * @description Fields available for sorting document lists
     * @default updated_at
     * @enum {string}
     */
    ListSortField: 'created_at' | 'updated_at' | 'title';
    /** @description Request to list species available within a specific realm */
    ListSpeciesByRealmRequest: {
      /**
       * Format: uuid
       * @description ID of the realm to filter by
       */
      realmId: string;
      /** @description Filter by playable status */
      isPlayable?: boolean | null;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of items per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list species with optional filtering and pagination */
    ListSpeciesRequest: {
      /** @description Filter by category (e.g., "HUMANOID", "BEAST", "MAGICAL") */
      category?: string | null;
      /** @description Filter by playable status */
      isPlayable?: boolean | null;
      /**
       * @description Whether to include deprecated species in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of items per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list available styles */
    ListStylesRequest: {
      /** @description Filter by category (e.g., "folk", "classical", "jazz") */
      category?: string | null;
      /**
       * @description Maximum number of styles to return
       * @default 50
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description Response containing a list of styles */
    ListStylesResponse: {
      /** @description Style summaries */
      styles: components['schemas']['StyleSummary'][];
      /** @description Total number of styles matching filter */
      total: number;
    };
    /** @description Request to list unlocked achievements */
    ListUnlockedAchievementsRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type whose unlocked achievements are listed */
      entityType: components['schemas']['EntityType'];
      /** @description Filter by platform */
      platform?: components['schemas']['Platform'];
    };
    /** @description Response containing unlocked achievements */
    ListUnlockedAchievementsResponse: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type for the returned unlocked achievements */
      entityType: components['schemas']['EntityType'];
      /** @description List of unlocked achievements */
      achievements: components['schemas']['UnlockedAchievement'][];
      /** @description Total points earned */
      totalPoints: number;
    };
    /** @description Request to list all versions of an asset with pagination */
    ListVersionsRequest: {
      /** @description Asset identifier to list versions for */
      assetId: string;
      /**
       * @description Maximum number of versions to return
       * @default 50
       */
      limit: number;
      /**
       * @description Number of versions to skip for pagination
       * @default 0
       */
      offset: number;
    };
    /** @description Paginated list of save versions within a slot */
    ListVersionsResponse: {
      /** @description List of versions */
      versions: components['schemas']['VersionResponse'][];
      /** @description Total version count in slot */
      totalCount: number;
    };
    /** @description Request to load save data from a specific slot and version */
    LoadRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Specific version to load (defaults to latest) */
      versionNumber?: number | null;
      /** @description Load by checkpoint name instead of version number */
      checkpointName?: string | null;
      /**
       * @description Include version metadata in response
       * @default true
       */
      includeMetadata: boolean;
    };
    /** @description Response containing loaded save data with integrity verification */
    LoadResponse: {
      /**
       * Format: uuid
       * @description Slot identifier
       */
      slotId: string;
      /** @description Version number loaded */
      versionNumber: number;
      /**
       * Format: byte
       * @description Base64-encoded save data (decompressed)
       */
      data: string;
      /** @description SHA-256 hash for integrity verification */
      contentHash: string;
      /** @description Schema version of this save */
      schemaVersion?: string | null;
      /** @description Human-readable name */
      displayName?: string | null;
      /** @description Whether this version is pinned */
      pinned?: boolean;
      /** @description Checkpoint name if pinned */
      checkpointName?: string | null;
      /**
       * Format: date-time
       * @description Save timestamp
       */
      createdAt?: string;
      /** @description Custom metadata */
      metadata?: {
        [key: string]: string;
      };
    };
    /** @description Character location information including current position, region, and 3D coordinates */
    Location: {
      /** @description Current location name or identifier */
      current?: string | null;
      /** @description Region or zone the character is in */
      region?: string | null;
      /** @description 3D spatial coordinates of the character's position in the game world */
      coordinates?: components['schemas']['Coordinates'];
    };
    /** @description Request to check if a location exists and is active */
    LocationExistsRequest: {
      /**
       * Format: uuid
       * @description ID of the location to validate
       */
      locationId: string;
    };
    /** @description Response indicating whether a location exists and its active status */
    LocationExistsResponse: {
      /** @description Whether the location exists */
      exists: boolean;
      /** @description Whether the location is active (false if deprecated or not found) */
      isActive: boolean;
      /**
       * Format: uuid
       * @description The location ID if found
       */
      locationId?: string | null;
      /**
       * Format: uuid
       * @description The realm ID if location found
       */
      realmId?: string | null;
    };
    /** @description Paginated list of locations with metadata for navigation */
    LocationListResponse: {
      /** @description List of locations matching the query */
      locations: components['schemas']['LocationResponse'][];
      /** @description Total number of locations matching the query (across all pages) */
      totalCount: number;
      /** @description Current page number (1-indexed) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more pages after the current page */
      hasNextPage?: boolean;
      /** @description Whether there are pages before the current page */
      hasPreviousPage?: boolean;
    };
    /** @description Complete location data returned from API operations */
    LocationResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the location
       */
      locationId: string;
      /**
       * Format: uuid
       * @description Realm this location belongs to
       */
      realmId: string;
      /** @description Unique code for the location within its realm */
      code: string;
      /** @description Display name of the location */
      name: string;
      /** @description Optional description of the location */
      description?: string | null;
      /** @description Type classification of the location */
      locationType: components['schemas']['LocationType'];
      /**
       * Format: uuid
       * @description Parent location ID (null for root locations)
       */
      parentLocationId?: string | null;
      /** @description Depth in hierarchy (0 for root locations) */
      depth: number;
      /** @description Whether this location is deprecated and cannot be used */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this location was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation */
      deprecationReason?: string | null;
      /** @description Additional metadata for the location (JSON) */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Timestamp when the location was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the location was last updated
       */
      updatedAt: string;
    };
    /**
     * @description Type classification for locations
     * @enum {string}
     */
    LocationType:
      | 'CONTINENT'
      | 'REGION'
      | 'CITY'
      | 'DISTRICT'
      | 'BUILDING'
      | 'ROOM'
      | 'LANDMARK'
      | 'WILDERNESS'
      | 'DUNGEON'
      | 'OTHER';
    /** @description Request to lock a contract under guardian custody */
    LockContractRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID to lock
       */
      contractInstanceId: string;
      /**
       * Format: uuid
       * @description Guardian entity ID (e.g., escrow agreement ID)
       */
      guardianId: string;
      /** @description Guardian entity type (e.g., "escrow") */
      guardianType: string;
      /** @description Optional idempotency key for the operation */
      idempotencyKey?: string | null;
    };
    /** @description Response from locking a contract */
    LockContractResponse: {
      /** @description Whether the contract was locked */
      locked: boolean;
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /**
       * Format: uuid
       * @description Guardian entity ID
       */
      guardianId?: string;
      /**
       * Format: date-time
       * @description When the contract was locked
       */
      lockedAt?: string;
    };
    /** @description Request to authenticate a user with email and password credentials */
    LoginRequest: {
      /**
       * Format: email
       * @description Email address for authentication
       */
      email: string;
      /**
       * Format: password
       * @description User password for authentication
       */
      password: string;
      /**
       * @description Whether to extend the session duration for persistent login
       * @default false
       */
      rememberMe: boolean;
      /** @description Information about the client device (optional) */
      deviceInfo?: components['schemas']['DeviceInfo'];
    };
    /** @description Site logo configuration including image URL and accessibility text */
    Logo: {
      /**
       * Format: uri
       * @description URL of the site logo image
       */
      url?: string;
      /** @description Alt text for the logo image */
      alt?: string;
    };
    /** @description Request to logout and invalidate authentication tokens */
    LogoutRequest: {
      /**
       * @description Logout from all sessions/devices
       * @default false
       */
      allSessions: boolean;
    };
    /** @description A map definition template that describes the structure of a region */
    MapDefinition: {
      /**
       * Format: uuid
       * @description Unique identifier for this definition
       */
      definitionId: string;
      /** @description Human-readable name */
      name: string;
      /** @description Description of the map template */
      description?: string | null;
      /** @description Layer configurations for this map */
      layers?: components['schemas']['LayerDefinition'][] | null;
      /** @description Default bounds for regions using this definition */
      defaultBounds?: components['schemas']['Bounds'];
      /** @description Additional metadata (schema-less) */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When the definition was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the definition was last updated
       */
      updatedAt?: string | null;
    };
    /**
     * @description The category of spatial data this map contains.
     *     Different kinds have different update frequencies, storage models, and TTLs.
     * @enum {string}
     */
    MapKind:
      | 'terrain'
      | 'static_geometry'
      | 'navigation'
      | 'resources'
      | 'spawn_points'
      | 'points_of_interest'
      | 'dynamic_objects'
      | 'hazards'
      | 'weather_effects'
      | 'ownership'
      | 'combat_effects'
      | 'visual_effects';
    /** @description A stored map object with full metadata */
    MapObject: {
      /**
       * Format: uuid
       * @description Unique identifier for this object
       */
      objectId: string;
      /**
       * Format: uuid
       * @description Region this object belongs to
       */
      regionId: string;
      /** @description Map kind this object is stored under */
      kind: components['schemas']['MapKind'];
      /** @description Publisher-defined type */
      objectType: string;
      /** @description Position for point objects */
      position?: components['schemas']['Position3D'];
      /** @description Bounding box for area objects */
      bounds?: components['schemas']['Bounds'];
      /** @description Schema-less object data (publisher-defined) */
      data?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: int64
       * @description Monotonic version for ordering
       */
      version?: number;
      /**
       * Format: date-time
       * @description When the object was first created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the object was last updated
       */
      updatedAt: string;
    };
    /**
     * @description Types of marker nodes for spawn points, waypoints, and other positional markers.
     * @enum {string}
     */
    MarkerType:
      | 'generic'
      | 'spawn_point'
      | 'npc_spawn'
      | 'waypoint'
      | 'camera_point'
      | 'light_point'
      | 'audio_point'
      | 'trigger_point';
    /** @description Request to check if a relationship type matches or descends from an ancestor type in the hierarchy */
    MatchesHierarchyRequest: {
      /**
       * Format: uuid
       * @description The relationship type to check
       */
      typeId: string;
      /**
       * Format: uuid
       * @description The potential ancestor type
       */
      ancestorTypeId: string;
    };
    /** @description Response indicating whether a type matches an ancestor in the hierarchy and the depth between them */
    MatchesHierarchyResponse: {
      /** @description True if typeId equals or descends from ancestorTypeId */
      matches: boolean;
      /** @description Number of levels between the types (0 if same, -1 if no match) */
      depth?: number;
    };
    /** @description Matchmaking operational statistics */
    MatchmakingStatsResponse: {
      /**
       * Format: date-time
       * @description When these stats were collected
       */
      timestamp: string;
      /** @description Statistics per queue */
      queueStats: components['schemas']['QueueStats'][];
    };
    /** @description Current matchmaking status for a ticket */
    MatchmakingStatusResponse: {
      /**
       * Format: uuid
       * @description Ticket identifier
       */
      ticketId: string;
      /** @description Queue the ticket is in */
      queueId: string;
      /** @description Current ticket status */
      status: components['schemas']['TicketStatus'];
      /** @description Number of processing intervals elapsed */
      intervalsElapsed: number;
      /** @description Current skill matching range (null if skill not used) */
      currentSkillRange?: number | null;
      /** @description Updated estimated wait time */
      estimatedWaitSeconds?: number | null;
      /**
       * Format: date-time
       * @description When the ticket was created
       */
      createdAt: string;
      /**
       * Format: uuid
       * @description Match ID if a match has been found
       */
      matchId?: string | null;
    };
    /** @description Analysis of a melody */
    MelodyAnalysis: {
      /** @description Pitch range used */
      range?: components['schemas']['PitchRange'];
      /** @description Distribution of interval sizes */
      intervalDistribution?: {
        [key: string]: number;
      } | null;
      /** @description Detected contour shape */
      contour?: string | null;
      /** @description Total number of notes */
      noteCount?: number;
      /**
       * Format: float
       * @description Average note duration in ticks
       */
      averageNoteDuration?: number | null;
    };
    /** @description Request to merge stacks */
    MergeStacksRequest: {
      /**
       * Format: uuid
       * @description Stack to merge from (destroyed)
       */
      sourceInstanceId: string;
      /**
       * Format: uuid
       * @description Stack to merge into
       */
      targetInstanceId: string;
    };
    /** @description Response after merging */
    MergeStacksResponse: {
      /** @description Whether merge succeeded */
      success: boolean;
      /**
       * Format: uuid
       * @description Merged stack ID
       */
      targetInstanceId: string;
      /**
       * Format: double
       * @description New quantity
       */
      newQuantity: number;
      /** @description Whether source was destroyed */
      sourceDestroyed: boolean;
      /**
       * Format: double
       * @description Quantity that didn't fit
       */
      overflowQuantity?: number | null;
    };
    /**
     * @description Type of metadata to update
     * @enum {string}
     */
    MetadataType: 'instance_data' | 'runtime_state';
    /** @description A single MIDI event */
    MidiEvent: {
      /** @description Absolute tick position */
      tick: number;
      /** @description Event type */
      type: components['schemas']['MidiEventType'];
      /** @description MIDI note number (for note events) */
      note?: number | null;
      /** @description Note velocity (for note events) */
      velocity?: number | null;
      /** @description Note duration in ticks (for noteOn with implicit noteOff) */
      duration?: number | null;
      /** @description Program number (for programChange) */
      program?: number | null;
      /** @description Controller number (for controlChange) */
      controller?: number | null;
      /** @description Controller value (for controlChange) */
      value?: number | null;
    };
    /**
     * @description MIDI event type
     * @enum {string}
     */
    MidiEventType: 'NoteOn' | 'NoteOff' | 'ProgramChange' | 'ControlChange';
    /** @description MIDI file header information */
    MidiHeader: {
      /**
       * @description MIDI format type (0, 1, or 2)
       * @default 1
       */
      format: number;
      /** @description Composition name */
      name?: string | null;
      /** @description Tempo changes */
      tempos?: components['schemas']['TempoEvent'][] | null;
      /** @description Time signature changes */
      timeSignatures?: components['schemas']['TimeSignatureEvent'][] | null;
      /** @description Key signature changes */
      keySignatures?: components['schemas']['KeySignatureEvent'][] | null;
    };
    /** @description MIDI-JSON format representation of a musical piece */
    MidiJson: {
      /** @description MIDI header information */
      header?: components['schemas']['MidiHeader'];
      /**
       * @description Ticks per beat (PPQN)
       * @default 480
       */
      ticksPerBeat: number;
      /** @description MIDI tracks */
      tracks: components['schemas']['MidiTrack'][];
    };
    /** @description A single MIDI track containing events */
    MidiTrack: {
      /** @description Track name */
      name?: string | null;
      /**
       * @description MIDI channel
       * @default 0
       */
      channel: number;
      /** @description GM instrument number */
      instrument?: number | null;
      /** @description Track events */
      events: components['schemas']['MidiEvent'][];
    };
    /** @description Request to migrate a save to a newer schema version */
    MigrateSaveRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Specific version to migrate (defaults to latest) */
      versionNumber?: number;
      /** @description Target schema version to migrate to */
      targetSchemaVersion: string;
      /**
       * @description Validate migration without saving
       * @default false
       */
      dryRun: boolean;
    };
    /** @description Result of a schema migration operation with version path details */
    MigrateSaveResponse: {
      /** @description Whether migration succeeded */
      success: boolean;
      /** @description Original schema version */
      fromSchemaVersion: string;
      /** @description Target schema version */
      toSchemaVersion: string;
      /** @description New version number (null if dry run) */
      newVersionNumber?: number | null;
      /** @description Migration path applied (list of versions) */
      migrationPath?: string[];
      /** @description Non-fatal migration warnings */
      warnings?: string[];
    };
    /** @description Milestone definition in a template */
    MilestoneDefinition: {
      /** @description Unique milestone code within template */
      code: string;
      /** @description Human-readable name */
      name: string;
      /** @description What this milestone represents */
      description?: string | null;
      /** @description Order in the contract flow */
      sequence: number;
      /** @description Whether milestone must be completed */
      required: boolean;
      /** @description Relative deadline (ISO 8601 duration) */
      deadline?: string | null;
      /** @description APIs to call on completion */
      onComplete?: components['schemas']['PreboundApi'][] | null;
      /** @description APIs to call if deadline passes */
      onExpire?: components['schemas']['PreboundApi'][] | null;
    };
    /** @description Milestone instance status */
    MilestoneInstanceResponse: {
      /** @description Milestone code */
      code: string;
      /** @description Milestone name */
      name: string;
      /** @description Order in flow */
      sequence: number;
      /** @description Whether required */
      required: boolean;
      /** @description Current status */
      status: components['schemas']['MilestoneStatus'];
      /**
       * Format: date-time
       * @description When completed
       */
      completedAt?: string | null;
      /**
       * Format: date-time
       * @description When failed
       */
      failedAt?: string | null;
      /**
       * Format: date-time
       * @description Absolute deadline
       */
      deadline?: string | null;
    };
    /** @description Brief milestone progress */
    MilestoneProgressSummary: {
      /** @description Milestone code */
      code: string;
      /** @description Current status */
      status: components['schemas']['MilestoneStatus'];
    };
    /** @description Milestone details */
    MilestoneResponse: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Milestone details */
      milestone: components['schemas']['MilestoneInstanceResponse'];
    };
    /**
     * @description Current status of a milestone
     * @enum {string}
     */
    MilestoneStatus: 'pending' | 'active' | 'completed' | 'failed' | 'skipped';
    /** @description Probability distribution over musical modes */
    ModeDistribution: {
      /**
       * Format: float
       * @description Probability of major mode
       * @default 0
       */
      major: number;
      /**
       * Format: float
       * @description Probability of natural minor
       * @default 0
       */
      minor: number;
      /**
       * Format: float
       * @description Probability of dorian mode
       * @default 0
       */
      dorian: number;
      /**
       * Format: float
       * @description Probability of phrygian mode
       * @default 0
       */
      phrygian: number;
      /**
       * Format: float
       * @description Probability of lydian mode
       * @default 0
       */
      lydian: number;
      /**
       * Format: float
       * @description Probability of mixolydian mode
       * @default 0
       */
      mixolydian: number;
      /**
       * Format: float
       * @description Probability of aeolian mode
       * @default 0
       */
      aeolian: number;
      /**
       * Format: float
       * @description Probability of locrian mode
       * @default 0
       */
      locrian: number;
    };
    /**
     * @description Musical mode/scale type
     * @enum {string}
     */
    ModeType:
      | 'Major'
      | 'Minor'
      | 'Dorian'
      | 'Phrygian'
      | 'Lydian'
      | 'Mixolydian'
      | 'Aeolian'
      | 'Locrian'
      | 'HarmonicMinor'
      | 'MelodicMinor'
      | 'MajorPentatonic'
      | 'MinorPentatonic'
      | 'Blues'
      | 'WholeTone'
      | 'Chromatic';
    /** @description Request to modify item instance state */
    ModifyItemInstanceRequest: {
      /**
       * Format: uuid
       * @description Instance ID to modify
       */
      instanceId: string;
      /** @description Change to durability (positive to repair, negative for damage) */
      durabilityDelta?: number | null;
      /** @description New custom stats (merges with existing) */
      customStats?: Record<string, never> | null;
      /** @description New custom name */
      customName?: string | null;
      /**
       * Format: double
       * @description Change to quantity (positive to add, negative to subtract). Only valid for stackable items.
       */
      quantityDelta?: number | null;
      /** @description New instance metadata (merges with existing) */
      instanceMetadata?: Record<string, never> | null;
      /**
       * Format: uuid
       * @description Move item to a different container. Used by inventory service for item movement.
       */
      newContainerId?: string | null;
      /** @description New slot index within the container */
      newSlotIndex?: number | null;
      /** @description New X position for grid-based containers */
      newSlotX?: number | null;
      /** @description New Y position for grid-based containers */
      newSlotY?: number | null;
    };
    /** @description Request to move item */
    MoveItemRequest: {
      /**
       * Format: uuid
       * @description Item instance ID to move
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Target container ID
       */
      targetContainerId: string;
      /** @description Target slot */
      targetSlotIndex?: number | null;
      /** @description Target grid X */
      targetSlotX?: number | null;
      /** @description Target grid Y */
      targetSlotY?: number | null;
      /** @description Rotate in target */
      rotated?: boolean | null;
    };
    /** @description Response after moving item */
    MoveItemResponse: {
      /** @description Whether move succeeded */
      success: boolean;
      /**
       * Format: uuid
       * @description Moved item ID
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Previous container
       */
      sourceContainerId: string;
      /**
       * Format: uuid
       * @description New container
       */
      targetContainerId: string;
      /** @description New slot */
      slotIndex?: number | null;
      /** @description New grid X */
      slotX?: number | null;
      /** @description New grid Y */
      slotY?: number | null;
    };
    /** @description Configuration for multipart uploads of large files */
    MultipartConfig: {
      /** @description Whether multipart upload is required for this file size */
      required?: boolean;
      /** @description Size of each part in bytes */
      partSize?: number;
      /** @description Maximum number of parts */
      maxParts?: number;
      /** @description Pre-signed URLs for each part of the multipart upload */
      uploadUrls?: components['schemas']['PartUploadInfo'][] | null;
    };
    /** @description Options for narrative-driven composition using the Storyteller engine */
    NarrativeOptions: {
      /**
       * @description Specific narrative template ID (e.g., 'journey_and_return', 'tension_and_release', 'simple_arc').
       *     If not specified, template is inferred from mood or defaults to 'simple_arc'.
       */
      templateId?: string | null;
      /** @description Starting emotional state for the composition */
      initialEmotion?: components['schemas']['EmotionalStateInput'];
      /** @description Target emotional state for the ending */
      targetEmotion?: components['schemas']['EmotionalStateInput'];
      /**
       * @description Preferred tension curve shape throughout the composition
       * @enum {string|null}
       */
      tensionProfile?:
        | 'gradual_build'
        | 'early_climax'
        | 'late_climax'
        | 'sustained'
        | 'wave'
        | null;
    };
    /** @description A navigation menu entry with optional nested children for dropdowns */
    NavigationItem: {
      /** @description Display text for the navigation link */
      label: string;
      /** @description Target URL or path for the navigation link */
      url: string;
      /** @description Sort order for the navigation item */
      order: number;
      /**
       * @description Link target attribute for opening behavior
       * @default _self
       * @enum {string}
       */
      target: '_self' | '_blank';
      /** @description Nested child navigation items for dropdowns */
      children?: components['schemas']['NavigationItem'][];
    };
    /** @description Information about a nearby object perceived by the character */
    NearbyObject: {
      /**
       * Format: uuid
       * @description Unique identifier of the object
       */
      objectId?: string;
      /** @description Type of object (boulder_cluster, tree, building, etc.) */
      objectType?: string;
      /**
       * Format: float
       * @description Distance from character in game units
       */
      distance?: number;
      /** @description Relative direction (north, south, east, west, above, below, etc.) */
      direction?: string;
      /** @description Optional absolute position */
      position?: components['schemas']['Position3D'] | null;
    } & {
      [key: string]: unknown;
    };
    /** @description A single news article or announcement entry */
    NewsItem: {
      /**
       * Format: uuid
       * @description Unique identifier for the news item
       */
      id: string;
      /** @description Headline of the news item */
      title: string;
      /** @description Brief summary or excerpt of the news content */
      summary: string;
      /** @description Full content body of the news item */
      content?: string | null;
      /** @description Name of the news item author */
      author?: string;
      /**
       * Format: date-time
       * @description Date and time when the news was published
       */
      publishedAt: string;
      /** @description Category tags associated with the news item */
      tags?: string[];
      /**
       * Format: uri
       * @description URL of the featured image for the news item
       */
      imageUrl?: string | null;
    };
    /** @description Paginated list of news items with total count */
    NewsResponse: {
      /** @description List of news items for the current page */
      items: components['schemas']['NewsItem'][];
      /** @description Total number of news items available */
      total: number;
      /** @description Whether more news items are available beyond this page */
      hasMore?: boolean;
    };
    /**
     * @description Structural node type. Indicates what kind of data the node contains,
     *     not how it will be used at runtime. Consumers interpret nodes according
     *     to their own needs via tags and annotations.
     * @enum {string}
     */
    NodeType: 'group' | 'mesh' | 'marker' | 'volume' | 'emitter' | 'reference' | 'custom';
    /**
     * @description How to handle publish attempts from non-authority sources
     * @default reject_and_alert
     * @enum {string}
     */
    NonAuthorityHandlingMode: 'reject_and_alert' | 'accept_and_alert' | 'reject_silent';
    /** @description A musical note event with timing and pitch */
    NoteEvent: {
      /** @description Note pitch */
      pitch: components['schemas']['Pitch'];
      /** @description Start position in ticks */
      startTick: number;
      /** @description Duration in ticks */
      durationTicks: number;
      /**
       * @description Note velocity
       * @default 80
       */
      velocity: number;
    };
    /** @description Request containing OAuth provider callback data to complete authentication */
    OAuthCallbackRequest: {
      /** @description Authorization code returned by the OAuth provider */
      code: string;
      /** @description State parameter for CSRF protection, must match the value sent in the init request */
      state?: string | null;
      /** @description Information about the client device (optional) */
      deviceInfo?: components['schemas']['DeviceInfo'];
    };
    /**
     * @description Type of entity that owns this save slot
     * @enum {string}
     */
    OwnerType: 'ACCOUNT' | 'CHARACTER' | 'SESSION' | 'REALM';
    /** @description Full content and metadata for a CMS-managed page */
    PageContent: {
      /** @description URL-friendly identifier for the page */
      slug: string;
      /** @description Display title of the page */
      title: string;
      /** @description HTML, Markdown, or custom template content */
      content: string;
      /**
       * @description Format of the page content
       * @enum {string}
       */
      contentType: 'html' | 'markdown' | 'blazor';
      /** @description Template name for custom layouts */
      template?: string | null;
      /** @description Whether the page is publicly visible */
      published: boolean;
      /**
       * Format: date-time
       * @description Date and time when the page was published
       */
      publishedAt?: string | null;
      /**
       * Format: date-time
       * @description Date and time of the last modification
       */
      lastModified: string;
      /** @description Name or identifier of the page author */
      author?: string | null;
      /** @description Custom metadata for the page */
      metadata?: {
        [key: string]: unknown;
      };
      /** @description Search engine optimization settings for the page */
      seo?: components['schemas']['SEOMetadata'];
    };
    /** @description Summary metadata for a CMS page without full content */
    PageMetadata: {
      /** @description URL-friendly identifier for the page */
      slug: string;
      /** @description Display title of the page */
      title: string;
      /** @description Whether the page is publicly visible */
      published: boolean;
      /**
       * Format: date-time
       * @description Date and time when the page was published
       */
      publishedAt?: string | null;
      /**
       * Format: date-time
       * @description Date and time of the last modification
       */
      lastModified: string;
      /** @description Name or identifier of the page author */
      author?: string | null;
    };
    /** @description Upload information for a single part in a multipart upload */
    PartUploadInfo: {
      /** @description Part number (1-based) */
      partNumber: number;
      /**
       * Format: uri
       * @description Pre-signed URL for uploading this part
       */
      uploadUrl: string;
      /**
       * Format: int64
       * @description Minimum size for this part
       */
      minSize?: number;
      /**
       * Format: int64
       * @description Maximum size for this part
       */
      maxSize?: number;
    };
    /** @description Paginated list of participation records */
    ParticipationListResponse: {
      /** @description List of participation records */
      participations: components['schemas']['HistoricalParticipation'][];
      /** @description Total number of matching records */
      totalCount: number;
      /** @description Current page number (1-based) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more results after this page */
      hasNextPage?: boolean;
      /** @description Whether there are results before this page */
      hasPreviousPage?: boolean;
    };
    /**
     * @description How the character participated in the historical event
     * @enum {string}
     */
    ParticipationRole:
      | 'LEADER'
      | 'COMBATANT'
      | 'VICTIM'
      | 'WITNESS'
      | 'BENEFICIARY'
      | 'CONSPIRATOR'
      | 'HERO'
      | 'SURVIVOR';
    /** @description Asset requirement status for a single party */
    PartyAssetRequirementStatus: {
      /** @description Party role (e.g., party_a, party_b) */
      partyRole: string;
      /** @description Whether all party's requirements are satisfied */
      satisfied: boolean;
      /** @description Status of each clause for this party */
      clauses: components['schemas']['ClauseAssetStatus'][];
    };
    /** @description Consent status for a single party */
    PartyConsentStatus: {
      /**
       * Format: uuid
       * @description Party ID
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Party display name */
      displayName?: string | null;
      /** @description Whether consent was given */
      consentGiven: boolean;
      /** @description Type of consent given (if any) */
      consentType?: components['schemas']['EscrowConsentType'];
      /**
       * Format: date-time
       * @description When consent was given
       */
      consentedAt?: string | null;
    };
    /** @description Information about a party member for matchmaking */
    PartyMemberInfo: {
      /**
       * Format: uuid
       * @description Account ID of the party member
       */
      accountId: string;
      /**
       * Format: uuid
       * @description WebSocket session ID for event delivery
       */
      webSocketSessionId: string;
      /** @description Pre-fetched skill rating (optional, will be looked up if not provided) */
      skillRating?: number | null;
    };
    /** @description Definition of a party role in a contract template */
    PartyRoleDefinition: {
      /** @description Role identifier (employer, employee, buyer, seller, etc.) */
      role: string;
      /** @description Minimum entities required in this role */
      minCount: number;
      /** @description Maximum entities allowed in this role */
      maxCount: number;
      /** @description Which entity types can fill this role (null for any) */
      allowedEntityTypes?: components['schemas']['EntityType'][] | null;
    };
    /**
     * @description Method for aggregating party member skills
     * @enum {string}
     */
    PartySkillAggregation: 'highest' | 'average' | 'weighted';
    /** @description Token issued to a party for deposit or release operations */
    PartyToken: {
      /**
       * Format: uuid
       * @description Party ID
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description The token */
      token: string;
    };
    /** @description Request to confirm a password reset using the emailed token and new password */
    PasswordResetConfirmRequest: {
      /** @description Password reset token received via email */
      token: string;
      /**
       * Format: password
       * @description New password to set for the account
       */
      newPassword: string;
    };
    /** @description Request to initiate a password reset by sending a reset link to the email */
    PasswordResetRequest: {
      /**
       * Format: email
       * @description Email address associated with the account to reset
       */
      email: string;
    };
    /** @description Reference to a past incarnation */
    PastLifeReference: {
      /**
       * Format: uuid
       * @description ID of the previous incarnation
       */
      characterId: string;
      /** @description Display name of the past life */
      name?: string | null;
      /**
       * Format: date-time
       * @description When the past life ended
       */
      deathDate?: string | null;
    };
    /**
     * @description When payments occur
     * @enum {string}
     */
    PaymentSchedule: 'one_time' | 'recurring' | 'milestone_based';
    /** @description Summary of pending consent */
    PendingConsentSummary: {
      /**
       * Format: uuid
       * @description Entity ID
       */
      entityId: string;
      /** @description Entity type */
      entityType: components['schemas']['EntityType'];
      /** @description Role in contract */
      role: string;
    };
    /**
     * @description Data representing a perception event for an actor.
     *
     *     Spatial context can be provided in two ways (hybrid approach):
     *     1. Typed: Use the optional spatialContext field for structured spatial data
     *     2. Schema-less: Use perceptionType="spatial" with data containing spatial info
     *
     *     The typed approach is recommended when game server has structured spatial data.
     *     The schema-less approach allows flexibility for game-specific spatial formats.
     */
    PerceptionData: {
      /**
       * @description Perception type. Common values: visual, auditory, tactile, olfactory,
       *     proprioceptive, spatial. Use "spatial" for schema-less spatial data in 'data' field.
       */
      perceptionType: string;
      /** @description ID of the entity causing this perception */
      sourceId: string;
      /** @description Type of source (character, npc, object, environment, coordinator, scheduled, message) */
      sourceType?: components['schemas']['PerceptionSourceType'] | null;
      /**
       * @description Perception-specific data. For perceptionType="spatial", this can contain
       *     game-specific spatial context in any format the game server defines.
       */
      data?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: float
       * @description How urgent this perception is (0-1)
       * @default 0.5
       */
      urgency: number;
      /**
       * @description Optional typed spatial context from game server's local spatial state.
       *     Provides structured information about terrain, nearby objects, hazards, etc.
       *     Alternative to using perceptionType="spatial" with schema-less data.
       */
      spatialContext?: components['schemas']['SpatialContext'] | null;
    };
    /**
     * @description Type of source generating a perception event
     * @enum {string}
     */
    PerceptionSourceType:
      | 'character'
      | 'npc'
      | 'object'
      | 'environment'
      | 'coordinator'
      | 'scheduled'
      | 'message'
      | 'service'
      | 'system';
    /** @description Complete personality profile for behavior system consumption */
    PersonalityResponse: {
      /**
       * Format: uuid
       * @description Character this personality belongs to
       */
      characterId: string;
      /** @description All trait axis values for this character */
      traits: components['schemas']['TraitValue'][];
      /** @description Personality version number (increments on each evolution) */
      version: number;
      /**
       * @description Optional archetype code for behavior optimization (e.g., "guardian",
       *     "merchant", "scholar", "trickster"). Allows behavior system to use
       *     pre-compiled behavior variants for common personality patterns.
       */
      archetypeHint?: string | null;
      /**
       * Format: date-time
       * @description When this personality was first created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When this personality was last modified
       */
      updatedAt?: string | null;
    };
    /** @description Snapshot of personality traits for enriched response */
    PersonalitySnapshot: {
      /** @description Trait values keyed by trait name (OPENNESS, AGREEABLENESS, etc.) */
      traits: {
        [key: string]: number;
      };
      /** @description Personality version number (increments on evolution) */
      version: number;
    };
    /** @description Response containing a perspective */
    PerspectiveResponse: {
      /** @description The character's perspective on the encounter */
      perspective: components['schemas']['EncounterPerspectiveModel'];
    };
    /** @description Request to pin a save version as a checkpoint to prevent cleanup */
    PinVersionRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Version to pin */
      versionNumber: number;
      /** @description Optional checkpoint name for easy retrieval */
      checkpointName?: string;
    };
    /** @description A specific pitch with pitch class and octave */
    Pitch: {
      /** @description Pitch class (note name) */
      pitchClass: components['schemas']['PitchClass'];
      /** @description Octave number (middle C = C4) */
      octave: number;
      /** @description MIDI note number (computed if not provided) */
      midiNumber?: number;
    };
    /**
     * @description A pitch class (note name without octave)
     * @enum {string}
     */
    PitchClass: 'C' | 'Cs' | 'D' | 'Ds' | 'E' | 'F' | 'Fs' | 'G' | 'Gs' | 'A' | 'As' | 'B';
    /** @description A pitch range from low to high */
    PitchRange: {
      /** @description Lowest pitch (inclusive) */
      low: components['schemas']['Pitch'];
      /** @description Highest pitch (inclusive) */
      high: components['schemas']['Pitch'];
    };
    /** @description Single action within a GOAP plan with position and cost information */
    PlannedActionResponse: {
      /** @description ID of the action (flow name) */
      actionId: string;
      /** @description Position in the plan sequence */
      index: number;
      /**
       * Format: float
       * @description Cost of this action
       */
      cost: number;
    };
    /**
     * @description External platform for achievement sync
     * @enum {string}
     */
    Platform: 'steam' | 'xbox' | 'playstation' | 'internal';
    /**
     * @description Role of the player in the game session
     * @enum {string}
     */
    PlayerRole: 'player' | 'spectator' | 'moderator';
    /** @description 3D position in world coordinates */
    Position3D: {
      /**
       * Format: float
       * @description X coordinate
       */
      x: number;
      /**
       * Format: float
       * @description Y coordinate (typically vertical)
       */
      y: number;
      /**
       * Format: float
       * @description Z coordinate
       */
      z: number;
    };
    /** @description Pre-configured API call to execute on contract events */
    PreboundApi: {
      /** @description Target service name */
      serviceName: string;
      /** @description Target endpoint path */
      endpoint: string;
      /** @description JSON payload with variable placeholders */
      payloadTemplate: string;
      /** @description Human-readable description */
      description?: string | null;
      /**
       * @description How to execute the API call
       * @default sync
       * @enum {string}
       */
      executionMode: 'sync' | 'async' | 'fire_and_forget';
      /** @description Optional validation rules for the response */
      responseValidation?: components['schemas']['ResponseValidation'];
    };
    /**
     * @description Preferred engagement distance. Influences positioning and
     *     ability selection in combat.
     * @enum {string}
     */
    PreferredRange: 'MELEE' | 'CLOSE' | 'MEDIUM' | 'RANGED';
    /**
     * @description Asset processing pipeline status
     * @enum {string}
     */
    ProcessingStatus: 'pending' | 'processing' | 'complete' | 'failed';
    /** @description Analysis of a chord progression */
    ProgressionAnalysis: {
      /** @description Roman numeral analysis */
      romanNumerals?: string[] | null;
      /** @description Detected cadences */
      cadences?: components['schemas']['CadenceInfo'][] | null;
      /** @description Functional analysis per chord */
      functionalAnalysis?: ('tonic' | 'subdominant' | 'dominant' | 'predominant')[] | null;
    };
    /** @description Request to promote an older save version to be the latest */
    PromoteVersionRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Name of the slot containing the version to promote */
      slotName: string;
      /** @description Old version to promote to latest */
      versionNumber: number;
      /** @description Display name for promoted version */
      displayName?: string | null;
    };
    /** @description Request to propose a contract to parties */
    ProposeContractInstanceRequest: {
      /**
       * Format: uuid
       * @description Contract instance to propose
       */
      contractId: string;
    };
    /**
     * @description Authentication provider type
     * @enum {string}
     */
    Provider: 'google' | 'discord' | 'twitch' | 'steam';
    /** @description Information about an available authentication provider */
    ProviderInfo: {
      /**
       * @description Internal identifier for the provider (matches Provider enum for OAuth)
       * @example discord
       */
      name: string;
      /**
       * @description Human-readable name for the provider
       * @example Discord
       */
      displayName: string;
      /**
       * @description Authentication mechanism (oauth = browser redirect, ticket = game client token)
       * @enum {string}
       */
      authType: 'oauth' | 'ticket';
      /**
       * Format: uri
       * @description URL to initiate OAuth authentication (null for ticket-based auth like Steam)
       * @example https://discord.com/oauth2/authorize
       */
      authUrl?: string | null;
    };
    /** @description List of available authentication providers */
    ProvidersResponse: {
      /** @description Available authentication providers */
      providers: components['schemas']['ProviderInfo'][];
    };
    /**
     * @description How quantities are tracked for this item type
     * @enum {string}
     */
    QuantityModel: 'discrete' | 'continuous' | 'unique';
    /** @description Rotation represented as a quaternion */
    Quaternion: {
      /**
       * Format: double
       * @description X component
       */
      x: number;
      /**
       * Format: double
       * @description Y component
       */
      y: number;
      /**
       * Format: double
       * @description Z component
       */
      z: number;
      /**
       * Format: double
       * @description W component (scalar)
       */
      w: number;
    };
    /** @description Request to query active contracts */
    QueryActiveContractsRequest: {
      /**
       * Format: uuid
       * @description Entity to query
       */
      entityId: string;
      /** @description Entity type */
      entityType: components['schemas']['EntityType'];
      /** @description Filter by template codes */
      templateCodes?: string[] | null;
    };
    /** @description Active contracts for entity */
    QueryActiveContractsResponse: {
      /** @description Active contracts */
      contracts: components['schemas']['ContractSummary'][];
    };
    /** @description Request to query encounters between two characters */
    QueryBetweenRequest: {
      /**
       * Format: uuid
       * @description First character
       */
      characterIdA: string;
      /**
       * Format: uuid
       * @description Second character
       */
      characterIdB: string;
      /** @description Filter by encounter type */
      encounterTypeCode?: string | null;
      /**
       * Format: float
       * @description Filter by minimum memory strength (for either character)
       */
      minimumMemoryStrength?: number | null;
      /**
       * @description Page number (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Query map data within bounds */
    QueryBoundsRequest: {
      /**
       * Format: uuid
       * @description Region to query
       */
      regionId: string;
      /** @description Bounding box to query */
      bounds: components['schemas']['Bounds'];
      /** @description Kinds to query (default all) */
      kinds?: components['schemas']['MapKind'][] | null;
      /**
       * @description Maximum objects to return
       * @default 500
       */
      maxObjects: number;
    };
    /** @description Bounds query results */
    QueryBoundsResponse: {
      /** @description Objects within bounds */
      objects?: components['schemas']['MapObject'][];
      /** @description Queried bounds */
      bounds?: components['schemas']['Bounds'];
      /** @description Whether results were truncated */
      truncated?: boolean;
    };
    /** @description Request to find bundles containing a specific asset */
    QueryBundlesByAssetRequest: {
      /** @description Platform asset ID to search for */
      assetId: string;
      /** @description Game realm to search within */
      realm: components['schemas']['GameRealm'];
      /** @description Filter by bundle type (optional, null for all types) */
      bundleType?: components['schemas']['BundleType'] | null;
      /**
       * @description Maximum results to return
       * @default 50
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description Bundles containing the requested asset */
    QueryBundlesByAssetResponse: {
      /** @description The queried asset ID */
      assetId: string;
      /** @description Bundles containing this asset */
      bundles: components['schemas']['BundleSummary'][];
      /** @description Total matching bundles */
      total: number;
      /** @description Page size */
      limit: number;
      /** @description Page offset */
      offset: number;
    };
    /** @description Advanced bundle query with filters */
    QueryBundlesRequest: {
      /** @description Filter by exact tag key-value matches */
      tags?: {
        [key: string]: string;
      } | null;
      /** @description Filter bundles that have these tag keys (any value) */
      tagExists?: string[] | null;
      /** @description Filter bundles that do NOT have these tag keys */
      tagNotExists?: string[] | null;
      /** @description Filter by lifecycle status (null for active only by default) */
      status?: components['schemas']['BundleLifecycle'] | null;
      /**
       * Format: date-time
       * @description Filter bundles created after this time
       */
      createdAfter?: string | null;
      /**
       * Format: date-time
       * @description Filter bundles created before this time
       */
      createdBefore?: string | null;
      /** @description Filter bundles with name containing this string (case-insensitive) */
      nameContains?: string | null;
      /** @description Filter by bundle owner account ID */
      owner?: string | null;
      /** @description Filter by realm */
      realm?: components['schemas']['GameRealm'] | null;
      /** @description Filter by bundle type (source or metabundle) */
      bundleType?: components['schemas']['BundleType'] | null;
      /**
       * @description Field to sort by (default created_at)
       * @enum {string|null}
       */
      sortField?: 'created_at' | 'updated_at' | 'name' | 'size' | null;
      /**
       * @description Sort order (default desc)
       * @enum {string|null}
       */
      sortOrder?: 'asc' | 'desc' | null;
      /**
       * @description Maximum results to return (max 1000)
       * @default 100
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Include soft-deleted bundles in results
       * @default false
       */
      includeDeleted: boolean;
    };
    /** @description Bundle query results */
    QueryBundlesResponse: {
      /** @description Matching bundles */
      bundles: components['schemas']['BundleInfo'][];
      /** @description Total number of matching bundles (for pagination) */
      totalCount: number;
      /** @description Page size used */
      limit: number;
      /** @description Page offset used */
      offset: number;
    };
    /** @description Request to query encounters by character */
    QueryByCharacterRequest: {
      /**
       * Format: uuid
       * @description Character to query encounters for
       */
      characterId: string;
      /** @description Filter by encounter type */
      encounterTypeCode?: string | null;
      /** @description Filter by outcome */
      outcome?: components['schemas']['EncounterOutcome'];
      /**
       * Format: float
       * @description Filter by minimum memory strength
       */
      minimumMemoryStrength?: number | null;
      /**
       * Format: date-time
       * @description Filter encounters after this time
       */
      fromTimestamp?: string | null;
      /**
       * Format: date-time
       * @description Filter encounters before this time
       */
      toTimestamp?: string | null;
      /**
       * @description Page number (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to query recent encounters at a location */
    QueryByLocationRequest: {
      /**
       * Format: uuid
       * @description Location to query
       */
      locationId: string;
      /** @description Filter by encounter type */
      encounterTypeCode?: string | null;
      /**
       * Format: date-time
       * @description Filter encounters after this time
       */
      fromTimestamp?: string | null;
      /**
       * @description Page number (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to query contract instances */
    QueryContractInstancesRequest: {
      /**
       * Format: uuid
       * @description Filter by party entity ID
       */
      partyEntityId?: string | null;
      /** @description Filter by party entity type */
      partyEntityType?: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Filter by template
       */
      templateId?: string | null;
      /** @description Filter by statuses */
      statuses?: components['schemas']['ContractStatus'][] | null;
      /**
       * @description Page number (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Paginated list of contract instances */
    QueryContractInstancesResponse: {
      /** @description List of contracts */
      contracts: components['schemas']['ContractInstanceResponse'][];
      /** @description Total matching contracts */
      totalCount: number;
      /** @description Current page number */
      page: number;
      /** @description Results per page */
      pageSize: number;
      /** @description Whether more results exist */
      hasNextPage?: boolean;
    };
    /** @description Request to search documentation using natural language queries */
    QueryDocumentationRequest: {
      /** @description Documentation namespace to search within */
      namespace: string;
      /** @description Natural language query to search for */
      query: string;
      /**
       * Format: uuid
       * @description Optional session ID for conversational context
       */
      sessionId?: string;
      /** @description Filter results to a specific category */
      category?: components['schemas']['DocumentCategory'];
      /**
       * @description Maximum number of results to return
       * @default 5
       */
      maxResults: number;
      /**
       * @description Whether to include full document content in results
       * @default false
       */
      includeContent: boolean;
      /**
       * @description Maximum length of summaries in characters
       * @default 300
       */
      maxSummaryLength: number;
      /**
       * Format: float
       * @description Minimum relevance score threshold for results
       * @default 0.3
       */
      minRelevanceScore: number;
    };
    /** @description Response containing search results and voice-friendly summaries */
    QueryDocumentationResponse: {
      /** @description The namespace that was searched */
      namespace: string;
      /** @description The original query string */
      query: string;
      /** @description List of matching documents */
      results: components['schemas']['DocumentResult'][];
      /** @description Total number of matching documents */
      totalResults?: number;
      /** @description Concise spoken summary for voice AI */
      voiceSummary?: string;
      /** @description Suggested follow-up queries */
      suggestedFollowups?: string[];
      /** @description User-friendly message when no results found */
      noResultsMessage?: string;
    };
    /** @description Request to query items */
    QueryItemsRequest: {
      /**
       * Format: uuid
       * @description Owner to search
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['ContainerOwnerType'];
      /**
       * Format: uuid
       * @description Filter by template
       */
      templateId?: string | null;
      /** @description Filter by category */
      category?: string | null;
      /** @description Filter by tags */
      tags?: string[] | null;
      /** @description Filter by container type */
      containerType?: string | null;
      /**
       * @description Exclude equipment slots
       * @default false
       */
      excludeEquipmentSlots: boolean;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Max results
       * @default 50
       */
      limit: number;
    };
    /** @description Query results */
    QueryItemsResponse: {
      /** @description Found items */
      items: components['schemas']['QueryResultItem'][];
      /** @description Total matching */
      totalCount: number;
    };
    /** @description Query objects by type */
    QueryObjectsByTypeRequest: {
      /**
       * Format: uuid
       * @description Region to query
       */
      regionId: string;
      /** @description Object type to filter by */
      objectType: string;
      /** @description Optional bounds filter */
      bounds?: components['schemas']['Bounds'];
      /**
       * @description Maximum objects to return
       * @default 500
       */
      maxObjects: number;
    };
    /** @description Object type query results */
    QueryObjectsByTypeResponse: {
      /** @description Matching objects */
      objects?: components['schemas']['MapObject'][];
      /** @description Queried object type */
      objectType?: string;
      /** @description Whether results were truncated */
      truncated?: boolean;
    };
    /** @description Query map data at a point */
    QueryPointRequest: {
      /**
       * Format: uuid
       * @description Region to query
       */
      regionId: string;
      /** @description Point to query at */
      position: components['schemas']['Position3D'];
      /** @description Kinds to query (default all) */
      kinds?: components['schemas']['MapKind'][] | null;
      /** @description Include objects within this radius */
      radius?: number | null;
    };
    /** @description Point query results */
    QueryPointResponse: {
      /** @description Objects at/near the point */
      objects?: components['schemas']['MapObject'][];
      /** @description Queried position */
      position?: components['schemas']['Position3D'];
      /** @description Applied radius filter */
      radius?: number | null;
    };
    /** @description Item in query results */
    QueryResultItem: {
      /**
       * Format: uuid
       * @description Item instance ID
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Template ID
       */
      templateId: string;
      /**
       * Format: uuid
       * @description Container ID
       */
      containerId: string;
      /** @description Container type */
      containerType?: string;
      /**
       * Format: double
       * @description Quantity
       */
      quantity: number;
      /** @description Slot position */
      slotIndex?: number | null;
    };
    /** @description Advanced query for saves across multiple owners with filtering and sorting */
    QuerySavesRequest: {
      /**
       * Format: uuid
       * @description Filter by owner ID
       */
      ownerId?: string | null;
      /** @description Filter by owner type */
      ownerType?: components['schemas']['OwnerType'] | null;
      /** @description Filter by save category */
      category?: components['schemas']['SaveCategory'] | null;
      /**
       * Format: date-time
       * @description Filter by creation date
       */
      createdAfter?: string | null;
      /**
       * Format: date-time
       * @description Filter by creation date
       */
      createdBefore?: string | null;
      /** @description Only return pinned versions */
      pinnedOnly?: boolean | null;
      /** @description Filter by schema version */
      schemaVersion?: string | null;
      /** @description Filter by metadata key-value pairs */
      metadataFilter?: {
        [key: string]: string;
      } | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results
       * @default 20
       */
      limit: number;
      /**
       * @description Sort field
       * @default created_at
       * @enum {string}
       */
      sortBy: 'created_at' | 'size' | 'version_number';
      /**
       * @description Sort order
       * @default desc
       * @enum {string}
       */
      sortOrder: 'asc' | 'desc';
    };
    /** @description Paginated results from a save query operation */
    QuerySavesResponse: {
      /** @description Query results */
      results: components['schemas']['QueryResultItem'][];
      /** @description Total matching results */
      totalCount: number;
    };
    /** @description Full configuration details of a matchmaking queue */
    QueueResponse: {
      /** @description Unique identifier for the queue */
      queueId: string;
      /** @description Game this queue is for */
      gameId: string;
      /** @description Game type for created sessions (maps to game-session service) */
      sessionGameType?: components['schemas']['SessionGameType'];
      /** @description Human-readable queue name */
      displayName: string;
      /** @description Detailed description of the queue */
      description?: string | null;
      /** @description Whether the queue is currently accepting tickets */
      enabled: boolean;
      /** @description Minimum players required for a match */
      minCount: number;
      /** @description Maximum players in a match */
      maxCount: number;
      /** @description Player count must be divisible by this (e.g., 2 for pairs) */
      countMultiple: number;
      /** @description Seconds between match processing intervals */
      intervalSeconds: number;
      /** @description Maximum intervals before relaxing to minCount */
      maxIntervals: number;
      /** @description Skill window expansion steps */
      skillExpansion?: components['schemas']['SkillExpansionStep'][] | null;
      /** @description How to calculate party skill rating */
      partySkillAggregation?: components['schemas']['PartySkillAggregation'];
      /** @description Weights for weighted party skill aggregation */
      partySkillWeights?: number[] | null;
      /** @description Maximum party size for this queue */
      partyMaxSize?: number | null;
      /**
       * @description Whether players can be in multiple queues
       * @default true
       */
      allowConcurrent: boolean;
      /** @description Exclusive group name (player can only be in one queue of the group) */
      exclusiveGroup?: string | null;
      /**
       * @description Whether to use lib-analytics skill rating for matching
       * @default true
       */
      useSkillRating: boolean;
      /** @description lib-analytics rating category to use */
      ratingCategory?: string | null;
      /**
       * @description Start match with minCount after maxIntervals (for large lobbies)
       * @default false
       */
      startWhenMinimumReached: boolean;
      /**
       * @description Whether players must be registered for a tournament
       * @default false
       */
      requiresRegistration: boolean;
      /**
       * @description Whether a tournament ID is required to join
       * @default false
       */
      tournamentIdRequired: boolean;
      /**
       * @description Seconds players have to accept/decline a formed match
       * @default 30
       */
      matchAcceptTimeoutSeconds: number;
      /**
       * Format: date-time
       * @description When the queue was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the queue was last updated
       */
      updatedAt?: string | null;
    };
    /** @description Statistics for a single matchmaking queue */
    QueueStats: {
      /** @description Queue identifier */
      queueId: string;
      /** @description Number of active tickets */
      currentTickets: number;
      /** @description Matches formed in the last hour */
      matchesFormedLastHour: number;
      /** @description Average wait time in seconds */
      averageWaitSeconds: number;
      /** @description Median wait time in seconds */
      medianWaitSeconds?: number | null;
      /** @description Percentage of tickets that timed out */
      timeoutRatePercent?: number | null;
      /** @description Percentage of tickets cancelled by user */
      cancelRatePercent?: number | null;
    };
    /** @description Summary information about a matchmaking queue */
    QueueSummary: {
      /** @description Unique identifier for the queue */
      queueId: string;
      /** @description Game this queue is for */
      gameId: string;
      /** @description Human-readable queue name */
      displayName: string;
      /** @description Whether the queue is currently accepting tickets */
      enabled: boolean;
      /** @description Minimum players required for a match */
      minCount: number;
      /** @description Maximum players in a match */
      maxCount: number;
      /** @description Current number of tickets in queue (if available) */
      currentTickets?: number | null;
      /** @description Average wait time in seconds (if available) */
      averageWaitSeconds?: number | null;
    };
    /** @description Request to re-affirm after validation failure */
    ReaffirmRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Party reaffirming
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Release token */
      releaseToken?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from party re-affirming after validation failure */
    ReaffirmResponse: {
      /** @description Reaffirmed escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Whether all parties have reaffirmed */
      allReaffirmed: boolean;
    };
    /**
     * @description Categories of historical events that realms can participate in
     * @enum {string}
     */
    RealmEventCategory:
      | 'FOUNDING'
      | 'WAR'
      | 'TREATY'
      | 'CATACLYSM'
      | 'DISCOVERY'
      | 'MIGRATION'
      | 'CULTURAL_SHIFT'
      | 'ECONOMIC_CHANGE'
      | 'POLITICAL_UPHEAVAL';
    /**
     * @description How the realm participated in the historical event
     * @enum {string}
     */
    RealmEventRole:
      | 'ORIGIN'
      | 'AGGRESSOR'
      | 'DEFENDER'
      | 'MEDIATOR'
      | 'AFFECTED'
      | 'BENEFICIARY'
      | 'INSTIGATOR'
      | 'NEUTRAL_PARTY';
    /** @description Request to check if a realm exists and is available for use */
    RealmExistsRequest: {
      /**
       * Format: uuid
       * @description ID of the realm to validate
       */
      realmId: string;
    };
    /** @description Response indicating whether a realm exists and its active status */
    RealmExistsResponse: {
      /** @description Whether the realm exists */
      exists: boolean;
      /** @description Whether the realm is active (false if deprecated or not found) */
      isActive: boolean;
      /**
       * Format: uuid
       * @description The realm ID if found
       */
      realmId?: string | null;
    };
    /** @description Record of a realm's participation in a historical event */
    RealmHistoricalParticipation: {
      /**
       * Format: uuid
       * @description Unique ID for this participation record
       */
      participationId: string;
      /**
       * Format: uuid
       * @description ID of the realm that participated
       */
      realmId: string;
      /**
       * Format: uuid
       * @description ID of the historical event
       */
      eventId: string;
      /** @description Name of the event (for display and summarization) */
      eventName: string;
      /** @description Category of the historical event */
      eventCategory: components['schemas']['RealmEventCategory'];
      /** @description How the realm participated */
      role: components['schemas']['RealmEventRole'];
      /**
       * Format: date-time
       * @description In-game date when the event occurred
       */
      eventDate: string;
      /**
       * Format: float
       * @description How significant this event was for the realm (0.0 to 1.0).
       *     Affects behavior system weighting.
       * @default 0.5
       */
      impact: number;
      /** @description Event-specific details for behavior decisions */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When this record was created
       */
      createdAt: string;
    };
    /** @description Paginated list of realms with metadata for navigation */
    RealmListResponse: {
      /** @description List of realms matching the query criteria */
      realms: components['schemas']['RealmResponse'][];
      /** @description Total number of realms matching the query (before pagination) */
      totalCount: number;
      /** @description Current page number (1-indexed) */
      page: number;
      /** @description Number of realms per page */
      pageSize: number;
      /** @description Whether there are more realms available on the next page */
      hasNextPage?: boolean;
      /** @description Whether there are realms available on the previous page */
      hasPreviousPage?: boolean;
    };
    /** @description A machine-readable lore element for behavior system consumption */
    RealmLoreElement: {
      /** @description Category of this lore element */
      elementType: components['schemas']['RealmLoreElementType'];
      /**
       * @description Machine-readable key (e.g., "founding_year", "primary_export", "capital_city").
       *     Used by behavior system to query specific aspects.
       */
      key: string;
      /**
       * @description Machine-readable value (e.g., "year_of_the_dragon", "iron_ore", "stormgate").
       *     Referenced in behavior rules.
       */
      value: string;
      /**
       * Format: float
       * @description How strongly this element affects behavior (0.0 to 1.0).
       *     Higher strength = greater influence on decisions.
       * @default 0.5
       */
      strength: number;
      /**
       * Format: uuid
       * @description Optional related entity (location, organization, character)
       */
      relatedEntityId?: string | null;
      /** @description Type of the related entity (if any) */
      relatedEntityType?: string | null;
    };
    /**
     * @description Types of lore elements. Each type represents a different aspect
     *     of the realm's background that influences behavior.
     * @enum {string}
     */
    RealmLoreElementType:
      | 'ORIGIN_MYTH'
      | 'CULTURAL_PRACTICE'
      | 'POLITICAL_SYSTEM'
      | 'ECONOMIC_BASE'
      | 'RELIGIOUS_TRADITION'
      | 'GEOGRAPHIC_FEATURE'
      | 'FAMOUS_FIGURE'
      | 'TECHNOLOGICAL_LEVEL';
    /** @description Complete lore data for a realm */
    RealmLoreResponse: {
      /**
       * Format: uuid
       * @description ID of the realm this lore belongs to
       */
      realmId: string;
      /** @description All lore elements for this realm */
      elements: components['schemas']['RealmLoreElement'][];
      /**
       * Format: date-time
       * @description When this lore was first created
       */
      createdAt?: string | null;
      /**
       * Format: date-time
       * @description When this lore was last modified
       */
      updatedAt?: string | null;
    };
    /** @description Paginated list of participation records */
    RealmParticipationListResponse: {
      /** @description List of participation records */
      participations: components['schemas']['RealmHistoricalParticipation'][];
      /** @description Total number of matching records */
      totalCount: number;
      /** @description Current page number (1-based) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more results after this page */
      hasNextPage?: boolean;
      /** @description Whether there are results before this page */
      hasPreviousPage?: boolean;
    };
    /** @description Complete realm information returned from API operations */
    RealmResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the realm
       */
      realmId: string;
      /** @description Unique code for the realm (e.g., "REALM_1", "REALM_2") */
      code: string;
      /** @description Display name for the realm */
      name: string;
      /**
       * Format: uuid
       * @description ID of the game service this realm belongs to
       */
      gameServiceId: string;
      /** @description Detailed description of the realm */
      description?: string | null;
      /** @description Category for grouping realms */
      category?: string | null;
      /** @description Whether the realm is currently active for gameplay */
      isActive: boolean;
      /** @description Whether this realm is deprecated and cannot be used for new entities */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this realm was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation */
      deprecationReason?: string | null;
      /** @description Additional custom metadata for the realm */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Timestamp when the realm was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the realm was last updated
       */
      updatedAt: string;
    };
    /** @description Status and population information for a single game realm */
    RealmStatus: {
      /**
       * Format: uuid
       * @description Unique identifier for the game realm
       */
      realmId: string;
      /** @description Display name of the game realm */
      name: string;
      /**
       * @description Current operational status of the realm
       * @enum {string}
       */
      status: 'online' | 'offline' | 'maintenance' | 'full';
      /**
       * @description Current player population level
       * @enum {string}
       */
      population: 'low' | 'medium' | 'high' | 'full';
      /** @description Current number of players online */
      playerCount?: number | null;
      /** @description Latency in milliseconds */
      ping?: number | null;
    };
    /** @description Information about a reference */
    ReferenceInfo: {
      /**
       * Format: uuid
       * @description Scene containing the reference
       */
      sceneId: string;
      /** @description Name of the referencing scene */
      sceneName: string;
      /**
       * Format: uuid
       * @description Node containing the reference
       */
      nodeId: string;
      /** @description refId of the referencing node */
      nodeRefId: string;
      /** @description Name of the referencing node */
      nodeName?: string;
    };
    /** @description Request to obtain a new access token using a valid refresh token */
    RefreshRequest: {
      /** @description Refresh token issued during authentication to obtain a new access token */
      refreshToken: string;
    };
    /** @description Request to trigger escrow refund to depositors */
    RefundRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /** @description For initiator_trusted mode */
      initiatorServiceId?: string | null;
      /** @description Reason for refund */
      reason?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from refunding escrow assets to depositors */
    RefundResponse: {
      /** @description Refunded escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Refund results per depositor */
      refunds: components['schemas']['RefundResult'][];
    };
    /** @description Result of refunding assets to a single depositor */
    RefundResult: {
      /**
       * Format: uuid
       * @description Depositor party ID
       */
      depositorPartyId: string;
      /** @description Assets refunded (null if failed) */
      assets?: components['schemas']['EscrowAssetBundle'];
      /** @description Whether refund succeeded */
      success: boolean;
      /** @description Error message if failed */
      error?: string | null;
    };
    /** @description Request to register a new user account */
    RegisterRequest: {
      /**
       * @description Unique username for the account
       * @example gameuser123
       */
      username: string;
      /**
       * Format: password
       * @description Password for the account (will be hashed)
       * @example SecurePassword123!
       */
      password: string;
      /**
       * Format: email
       * @description Email address for account recovery and notifications
       * @example user@example.com
       */
      email: string;
    };
    /** @description Response from successful user registration */
    RegisterResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the newly created account
       */
      accountId: string;
      /**
       * @description JWT access token for immediate authentication
       * @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJnYW1ldXNlcjEyMyIsImlhdCI6MTY0MDk5NTIwMCwiZXhwIjoxNjQwOTk4ODAwfQ.signature
       */
      accessToken: string;
      /**
       * @description Refresh token for obtaining new access tokens
       * @example refresh_token_abc123xyz789
       */
      refreshToken?: string | null;
      /**
       * Format: uri
       * @description WebSocket endpoint for Connect service
       */
      connectUrl: string;
    };
    /** @description Request to register a new save data schema with optional migration rules */
    RegisterSchemaRequest: {
      /** @description Schema namespace (e.g., game identifier) */
      namespace: string;
      /** @description Schema version identifier */
      schemaVersion: string;
      /** @description JSON Schema definition for validation */
      schema: Record<string, never>;
      /** @description Previous version this migrates from */
      previousVersion?: string | null;
      /**
       * @description JSON Patch (RFC 6902) operations to migrate from previousVersion.
       *     Uses JsonPatch.Net library (MIT licensed).
       */
      migrationPatch?: components['schemas']['JsonPatchOperation'][] | null;
    };
    /**
     * @description How deep to traverse related document links:
     *     - none: No related documents included
     *     - direct: Only directly linked documents (depth 1)
     *     - extended: Related documents + their related documents (depth 2)
     * @default direct
     * @enum {string}
     */
    RelatedDepth: 'none' | 'direct' | 'extended';
    /** @description Paginated list of relationships with metadata for navigation */
    RelationshipListResponse: {
      /** @description List of relationships matching the query */
      relationships: components['schemas']['RelationshipResponse'][];
      /** @description Total number of relationships matching the query */
      totalCount: number;
      /** @description Current page number (1-based) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more results on the next page */
      hasNextPage?: boolean;
      /** @description Whether there are results on the previous page */
      hasPreviousPage?: boolean;
    };
    /** @description Complete details of a relationship between two entities */
    RelationshipResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the relationship
       */
      relationshipId: string;
      /**
       * Format: uuid
       * @description ID of the first entity in the relationship
       */
      entity1Id: string;
      /** @description Type of the first entity in the relationship */
      entity1Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the second entity in the relationship
       */
      entity2Id: string;
      /** @description Type of the second entity in the relationship */
      entity2Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Relationship type ID (from RelationshipType service)
       */
      relationshipTypeId: string;
      /**
       * Format: date-time
       * @description In-game timestamp when relationship started
       */
      startedAt: string;
      /**
       * Format: date-time
       * @description In-game timestamp when relationship ended, null if still active
       */
      endedAt?: string | null;
      /** @description Type-specific relationship data */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description System timestamp when the relationship record was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description System timestamp when the relationship record was last updated
       */
      updatedAt?: string | null;
    };
    /** @description Response containing a list of relationship types with total count */
    RelationshipTypeListResponse: {
      /** @description List of relationship types matching the query */
      types: components['schemas']['RelationshipTypeResponse'][];
      /** @description Total number of relationship types returned */
      totalCount: number;
    };
    /** @description Complete representation of a relationship type including hierarchy, inverse, and deprecation information */
    RelationshipTypeResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the relationship type
       */
      relationshipTypeId: string;
      /** @description Unique code for the relationship type (e.g., "SON", "MOTHER") */
      code: string;
      /** @description Human-readable display name for the relationship type */
      name: string;
      /** @description Detailed description of the relationship type */
      description?: string | null;
      /** @description Category for grouping relationship types (e.g., "FAMILY", "SOCIAL") */
      category?: string | null;
      /**
       * Format: uuid
       * @description ID of the parent type in the hierarchy (null for root types)
       */
      parentTypeId?: string | null;
      /** @description Code of the parent type (for convenience) */
      parentTypeCode?: string | null;
      /**
       * Format: uuid
       * @description ID of the inverse relationship type (e.g., PARENT is inverse of CHILD)
       */
      inverseTypeId?: string | null;
      /** @description Code of the inverse relationship type (for convenience) */
      inverseTypeCode?: string | null;
      /** @description Whether the relationship is the same in both directions (e.g., SIBLING) */
      isBidirectional: boolean;
      /** @description Whether this type is deprecated and cannot be used for new relationships */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this type was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation */
      deprecationReason?: string | null;
      /** @description Depth in the hierarchy (0 for root types) */
      depth: number;
      /** @description Additional custom metadata for the relationship type */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Timestamp when the relationship type was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the relationship type was last updated
       */
      updatedAt: string;
    };
    /** @description Defines who gets what on release */
    ReleaseAllocation: {
      /**
       * Format: uuid
       * @description Party receiving assets
       */
      recipientPartyId: string;
      /** @description Type of the recipient party */
      recipientPartyType: components['schemas']['EntityType'];
      /** @description Assets this recipient should receive */
      assets: components['schemas']['EscrowAsset'][];
      /**
       * Format: uuid
       * @description Where to deliver currency
       */
      destinationWalletId?: string | null;
      /**
       * Format: uuid
       * @description Where to deliver items
       */
      destinationContainerId?: string | null;
    };
    /** @description Input for specifying how assets should be allocated on release */
    ReleaseAllocationInput: {
      /**
       * Format: uuid
       * @description Recipient party ID
       */
      recipientPartyId: string;
      /** @description Recipient party type */
      recipientPartyType: components['schemas']['EntityType'];
      /** @description Assets to allocate */
      assets: components['schemas']['EscrowAssetInput'][];
      /**
       * Format: uuid
       * @description Destination wallet
       */
      destinationWalletId?: string | null;
      /**
       * Format: uuid
       * @description Destination container
       */
      destinationContainerId?: string | null;
    };
    /** @description Request to release a hold */
    ReleaseHoldRequest: {
      /**
       * Format: uuid
       * @description Hold ID to release
       */
      holdId: string;
    };
    /** @description Request to trigger escrow release to recipients */
    ReleaseRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /** @description For initiator_trusted mode */
      initiatorServiceId?: string | null;
      /** @description Optional notes */
      notes?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from releasing escrow assets to recipients */
    ReleaseResponse: {
      /** @description Released escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Results of contract finalizer APIs */
      finalizerResults: components['schemas']['FinalizerResult'][];
      /** @description Release results per recipient */
      releases: components['schemas']['ReleaseResult'][];
    };
    /** @description Result of releasing assets to a single recipient */
    ReleaseResult: {
      /**
       * Format: uuid
       * @description Recipient party ID
       */
      recipientPartyId: string;
      /** @description Assets released (null if failed) */
      assets?: components['schemas']['EscrowAssetBundle'];
      /** @description Whether release succeeded */
      success: boolean;
      /** @description Error message if failed */
      error?: string | null;
    };
    /** @description Request to remove item from container */
    RemoveItemRequest: {
      /**
       * Format: uuid
       * @description Item instance ID to remove
       */
      instanceId: string;
    };
    /** @description Response after removing item */
    RemoveItemResponse: {
      /** @description Whether remove succeeded */
      success: boolean;
      /**
       * Format: uuid
       * @description Removed item ID
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Container removed from
       */
      previousContainerId: string;
    };
    /** @description Request to rename an existing save slot */
    RenameSlotRequest: {
      /** @description Game identifier */
      gameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the slot
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Current slot name */
      slotName: string;
      /** @description New slot name */
      newSlotName: string;
    };
    /** @description Request to report a breach */
    ReportBreachRequest: {
      /**
       * Format: uuid
       * @description Contract that was breached
       */
      contractId: string;
      /**
       * Format: uuid
       * @description Entity that breached
       */
      breachingEntityId: string;
      /** @description Type of breaching entity */
      breachingEntityType: components['schemas']['EntityType'];
      /** @description Type of breach */
      breachType: components['schemas']['BreachType'];
      /** @description Code of breached term or milestone */
      breachedTermOrMilestone?: string | null;
      /** @description Breach description */
      description?: string | null;
    };
    /** @description Detailed repository binding configuration and status */
    RepositoryBindingInfo: {
      /**
       * Format: uuid
       * @description Unique identifier of the repository binding
       */
      bindingId: string;
      /** @description Namespace the repository is bound to */
      namespace: string;
      /** @description URL of the bound repository */
      repositoryUrl: string;
      /** @description Branch being synced */
      branch?: string;
      /** @description Current status of the binding */
      status: components['schemas']['BindingStatus'];
      /** @description Whether automatic sync is enabled */
      syncEnabled?: boolean;
      /** @description Sync interval in minutes */
      syncIntervalMinutes?: number;
      /** @description Number of documents from this repository */
      documentCount?: number;
      /**
       * Format: date-time
       * @description Timestamp when the binding was created
       */
      createdAt?: string;
      /**
       * @description Owner of this binding. NOT a session ID.
       *     Contains either an accountId (UUID format) for user-initiated bindings
       *     or a service name for service-initiated bindings.
       */
      owner?: string;
    };
    /** @description Request to get current repository binding and sync status */
    RepositoryStatusRequest: {
      /** @description Documentation namespace to get status for */
      namespace: string;
    };
    /** @description Response containing binding configuration and recent sync information */
    RepositoryStatusResponse: {
      /** @description Current binding configuration and status */
      binding?: components['schemas']['RepositoryBindingInfo'];
      /** @description Information about the most recent sync */
      lastSync?: components['schemas']['SyncInfo'];
    };
    /** @description Request for full snapshot */
    RequestSnapshotRequest: {
      /**
       * Format: uuid
       * @description Region to snapshot
       */
      regionId: string;
      /** @description Which kinds to include (default all) */
      kinds?: components['schemas']['MapKind'][] | null;
      /** @description Optional bounds filter */
      bounds?: components['schemas']['Bounds'];
      /**
       * @description Optional authority token. If provided and valid, clears the
       *     RequiresConsumeBeforePublish flag for require_consume takeover mode.
       */
      authorityToken?: string | null;
    };
    /** @description Snapshot response */
    RequestSnapshotResponse: {
      /**
       * Format: uuid
       * @description Region ID
       */
      regionId?: string;
      /** @description All objects in snapshot */
      objects?: components['schemas']['MapObject'][];
      /** @description For large snapshots, lib-asset reference */
      payloadRef?: string | null;
      /**
       * Format: int64
       * @description Snapshot version
       */
      version?: number;
    };
    /** @description Reservation token returned when creating a matchmade session */
    ReservationInfo: {
      /**
       * Format: uuid
       * @description Account ID this reservation is for
       */
      accountId: string;
      /** @description Token to claim this reservation */
      token: string;
      /**
       * Format: date-time
       * @description When this reservation expires
       */
      expiresAt: string;
    };
    /** @description Request to resolve optimal bundle downloads for requested assets */
    ResolveBundlesRequest: {
      /** @description Platform asset IDs to resolve */
      assetIds: string[];
      /** @description Game realm to search within */
      realm: components['schemas']['GameRealm'];
      /**
       * @description Prefer metabundles when coverage is equal
       * @default true
       */
      preferMetabundles: boolean;
      /**
       * @description Include standalone assets not in any bundle
       * @default true
       */
      includeStandalone: boolean;
      /** @description Maximum number of bundles to return (optimization limit) */
      maxBundles?: number | null;
    };
    /** @description Optimal bundle set for requested assets */
    ResolveBundlesResponse: {
      /** @description Bundles to download */
      bundles: components['schemas']['ResolvedBundle'][];
      /** @description Individual assets to download */
      standaloneAssets: components['schemas']['ResolvedAsset'][];
      /** @description Coverage statistics */
      coverage: components['schemas']['CoverageAnalysis'];
      /** @description Asset IDs that couldn't be found (null if all resolved) */
      unresolved?: string[] | null;
    };
    /** @description Request for arbiter to resolve a disputed escrow */
    ResolveRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Arbiter ID
       */
      arbiterId: string;
      /** @description Arbiter type */
      arbiterType: components['schemas']['EntityType'];
      /** @description Resolution decision for the dispute */
      resolution: components['schemas']['EscrowResolution'];
      /** @description For split resolution */
      splitAllocations?: components['schemas']['SplitAllocation'][] | null;
      /** @description Resolution notes */
      notes?: string | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from arbiter resolving a disputed escrow */
    ResolveResponse: {
      /** @description Resolved escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Transfer results */
      transfers: components['schemas']['TransferResult'][];
    };
    /** @description A standalone asset selected for download */
    ResolvedAsset: {
      /** @description Asset identifier */
      assetId: string;
      /**
       * Format: uri
       * @description Pre-signed download URL
       */
      downloadUrl: string;
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Asset file size in bytes
       */
      size: number;
      /** @description SHA256 hash of asset content */
      contentHash?: string | null;
    };
    /** @description A bundle selected for download in resolution */
    ResolvedBundle: {
      /** @description Human-readable bundle identifier */
      bundleId: string;
      /** @description Whether source or metabundle */
      bundleType: components['schemas']['BundleType'];
      /** @description Bundle version */
      version?: string | null;
      /**
       * Format: uri
       * @description Pre-signed download URL
       */
      downloadUrl: string;
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Bundle file size in bytes
       */
      size: number;
      /** @description Which of the requested assets this bundle provides */
      assetsProvided: string[];
    };
    /** @description A successfully resolved scene reference */
    ResolvedReference: {
      /**
       * Format: uuid
       * @description Node ID containing the reference
       */
      nodeId: string;
      /** @description refId of the referencing node */
      refId: string;
      /**
       * Format: uuid
       * @description ID of the referenced scene
       */
      referencedSceneId: string;
      /** @description Version that was resolved */
      referencedVersion?: string | null;
      /** @description The resolved scene content */
      scene: components['schemas']['Scene'];
      /** @description Depth level of this reference */
      depth?: number;
    };
    /**
     * @description Validation rules for API responses with three-outcome model.
     *     Used by lib-contract to validate clause conditions without
     *     understanding the specific API semantics.
     */
    ResponseValidation: {
      /**
       * @description Conditions that must ALL pass for success.
       *     If any fail, checks permanent failure conditions.
       */
      successConditions?: components['schemas']['ValidationCondition'][];
      /**
       * @description Conditions that indicate permanent failure (clause violated).
       *     Checked when success conditions fail.
       */
      permanentFailureConditions?: components['schemas']['ValidationCondition'][];
      /**
       * @description HTTP status codes that indicate transient failure (retry later).
       *     Default: [408, 429, 502, 503, 504]
       */
      transientFailureStatusCodes?: number[];
    };
    /** @description Request to restore a soft-deleted bundle */
    RestoreBundleRequest: {
      /** @description Human-readable bundle identifier to restore */
      bundleId: string;
      /** @description Optional reason for restoration (recorded in version history) */
      reason?: string | null;
    };
    /** @description Result of bundle restoration */
    RestoreBundleResponse: {
      /** @description Human-readable bundle identifier that was restored */
      bundleId: string;
      /** @description Current bundle status (should be "active") */
      status: string;
      /**
       * Format: date-time
       * @description When the bundle was restored
       */
      restoredAt: string;
      /** @description Version number the bundle was restored from */
      restoredFromVersion: number;
    };
    /** @description Search engine optimization and social media sharing metadata */
    SEOMetadata: {
      /** @description Meta description for search engines */
      description?: string | null;
      /** @description Keywords for search engine indexing */
      keywords?: string[];
      /** @description Open Graph title for social media sharing */
      ogTitle?: string | null;
      /** @description Open Graph description for social media sharing */
      ogDescription?: string | null;
      /**
       * Format: uri
       * @description Open Graph image URL for social media sharing
       */
      ogImage?: string | null;
    };
    /**
     * @description Category of save with predefined behaviors.
     *     QUICK_SAVE: Single-slot fast save, overwritten frequently (max 1 version).
     *     AUTO_SAVE: System-triggered periodic saves (max 5 versions, rolling).
     *     MANUAL_SAVE: User-initiated named saves (max 10 versions, no auto-cleanup).
     *     CHECKPOINT: Progress markers (max 20 versions, rolling).
     *     STATE_SNAPSHOT: Full state captures for debugging (max 3 versions, rolling).
     * @enum {string}
     */
    SaveCategory: 'QUICK_SAVE' | 'AUTO_SAVE' | 'MANUAL_SAVE' | 'CHECKPOINT' | 'STATE_SNAPSHOT';
    /** @description Request to save incremental changes as a delta from a base version */
    SaveDeltaRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Name of the slot to save the delta to */
      slotName: string;
      /** @description Version number this delta is based on */
      baseVersion: number;
      /**
       * Format: byte
       * @description Base64-encoded delta/patch data.
       *     For JSON_PATCH: Array of RFC 6902 operations
       *     For BSDIFF/XDELTA: Binary patch data
       */
      delta: string;
      /** @description Delta computation algorithm to use (defaults to JSON_PATCH) */
      algorithm?: components['schemas']['DeltaAlgorithm'] | null;
      /** @description Schema version of this save for migration tracking */
      schemaVersion?: string | null;
      /** @description Human-readable name for this delta save */
      displayName?: string | null;
      /** @description Device identifier for cross-device sync conflict detection */
      deviceId?: string | null;
      /** @description Custom key-value metadata for this delta version */
      metadata?: {
        [key: string]: string;
      } | null;
    };
    /** @description Result of delta save operation with size and chain information */
    SaveDeltaResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the save slot
       */
      slotId: string;
      /** @description New version number */
      versionNumber: number;
      /** @description Base version this delta is relative to */
      baseVersion: number;
      /**
       * Format: int64
       * @description Size of stored delta
       */
      deltaSizeBytes: number;
      /**
       * Format: int64
       * @description Estimated size when reconstructed
       */
      estimatedFullSizeBytes: number;
      /** @description Number of deltas in chain to base snapshot */
      chainLength?: number;
      /**
       * Format: double
       * @description Storage savings vs full snapshot (0-1)
       */
      compressionSavings?: number;
      /**
       * Format: date-time
       * @description When the delta version was created
       */
      createdAt: string;
    };
    /** @description Request to save game state data to a slot with optional compression and metadata */
    SaveRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name (auto-created if doesn't exist) */
      slotName: string;
      /** @description Category for auto-created slots (defaults to MANUAL_SAVE) */
      category?: components['schemas']['SaveCategory'] | null;
      /**
       * Format: byte
       * @description Base64-encoded save data
       */
      data: string;
      /** @description Schema version identifier for migration tracking */
      schemaVersion?: string | null;
      /** @description Human-readable name for this save */
      displayName?: string | null;
      /**
       * Format: byte
       * @description Optional preview image (JPEG/WebP). Max size configurable
       *     (default 256KB). Used for save slot previews in game UI.
       */
      thumbnail?: string | null;
      /**
       * @description Optional device identifier for cloud save conflict detection.
       *     When provided, saves are prefixed/tagged with device info,
       *     enabling opt-in cross-device sync with collision awareness.
       */
      deviceId?: string | null;
      /** @description Custom metadata (e.g., level, playtime, location) */
      metadata?: {
        [key: string]: string;
      } | null;
      /** @description If provided, pin this version with checkpoint name */
      pinAsCheckpoint?: string | null;
    };
    /** @description Result of a save operation including version info and conflict detection */
    SaveResponse: {
      /**
       * Format: uuid
       * @description Slot identifier
       */
      slotId: string;
      /** @description Assigned version number */
      versionNumber: number;
      /** @description SHA-256 hash of save data */
      contentHash: string;
      /**
       * Format: int64
       * @description Size of save data in bytes
       */
      sizeBytes: number;
      /**
       * Format: int64
       * @description Compressed size (if compression applied)
       */
      compressedSizeBytes?: number;
      /**
       * Format: double
       * @description Compression ratio (0-1)
       */
      compressionRatio?: number;
      /** @description Whether version was pinned */
      pinned?: boolean;
      /** @description Checkpoint name if pinned */
      checkpointName?: string | null;
      /**
       * Format: uri
       * @description Pre-signed URL to retrieve thumbnail (if provided)
       */
      thumbnailUrl?: string | null;
      /**
       * @description True if this save overwrote a version from a different device.
       *     Only relevant when deviceId is used for cloud sync.
       */
      conflictDetected?: boolean;
      /** @description Device ID of the overwritten version (if conflict) */
      conflictingDeviceId?: string | null;
      /** @description Version number that was overwritten (if conflict) */
      conflictingVersion?: number | null;
      /**
       * Format: date-time
       * @description Save timestamp
       */
      createdAt: string;
      /** @description Number of old versions cleaned up by rolling policy */
      versionsCleanedUp?: number;
      /**
       * @description True if async upload is enabled and data is queued for MinIO upload.
       *     Save is immediately loadable from Redis cache, but not yet durable.
       */
      uploadPending?: boolean;
    };
    /** @description A complete scene document with hierarchical node structure */
    Scene: {
      /**
       * @description Schema identifier for validation
       * @default bannou://schemas/scene/v1
       */
      schema: string;
      /**
       * Format: uuid
       * @description Unique scene identifier
       */
      sceneId: string;
      /**
       * @description Game service identifier for partitioning. Treated as opaque string.
       *     Default is the nil UUID for unpartitioned scenes.
       * @default 00000000-0000-0000-0000-000000000000
       */
      gameId: string;
      /** @description Scene classification for querying and validation */
      sceneType: components['schemas']['SceneType'];
      /** @description Human-readable scene name */
      name: string;
      /** @description Optional scene description */
      description?: string | null;
      /** @description Semantic version (MAJOR.MINOR.PATCH) */
      version: string;
      /** @description Root node of the scene hierarchy */
      root: components['schemas']['SceneNode'];
      /** @description Searchable tags for filtering scenes */
      tags?: string[];
      /**
       * @description Scene-level metadata. Not interpreted by Scene service.
       *     Examples: author, thumbnail, editor preferences, generator config.
       */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When the scene was first created
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description When the scene was last modified
       */
      updatedAt?: string;
    };
    /**
     * @description A node in the scene hierarchy. Nodes can contain children to form
     *     a tree structure. Each node has a local transform relative to its parent.
     */
    SceneNode: {
      /**
       * Format: uuid
       * @description Globally unique node identifier
       */
      nodeId: string;
      /**
       * @description Scene-local reference identifier. Must be unique within the scene.
       *     Used for scripting and cross-referencing. Examples: main_door, npc_spawn_1
       */
      refId: string;
      /**
       * Format: uuid
       * @description Parent node ID. Null for the root node only.
       */
      parentNodeId?: string | null;
      /** @description Human-readable display name for the node */
      name: string;
      /** @description The structural type of this node */
      nodeType: components['schemas']['NodeType'];
      /** @description Transform relative to parent node */
      localTransform: components['schemas']['Transform'];
      /** @description Optional asset binding (mesh, sound, particle effect) */
      asset?: components['schemas']['AssetReference'];
      /** @description Child nodes in the hierarchy */
      children?: components['schemas']['SceneNode'][];
      /**
       * @description Whether this node is active in the scene definition
       * @default true
       */
      enabled: boolean;
      /**
       * @description Ordering among siblings for deterministic iteration
       * @default 0
       */
      sortOrder: number;
      /** @description Arbitrary tags for consumer filtering (e.g., entrance, spawn, interactive) */
      tags?: string[];
      /**
       * @description Consumer-specific data stored without interpretation.
       *     Use namespaced keys (e.g., render.castShadows, game.interactionType).
       */
      annotations?: {
        [key: string]: unknown;
      } | null;
      /**
       * @description Predefined locations for attaching child objects.
       *     Used by Scene Composer for furniture decoration, wall accessories, etc.
       */
      attachmentPoints?: components['schemas']['AttachmentPoint'][];
      /**
       * @description Interaction capabilities of this node.
       *     Used by AI navigation and character controllers.
       */
      affordances?: components['schemas']['Affordance'][];
      /**
       * @description Procedural asset swapping configuration.
       *     Defines which assets can substitute for this node's asset.
       */
      assetSlot?: components['schemas']['AssetSlot'];
      /**
       * @description Type of marker for marker nodes.
       *     Only relevant when nodeType is 'marker'.
       */
      markerType?: components['schemas']['MarkerType'];
      /**
       * @description Shape of volume for volume nodes.
       *     Only relevant when nodeType is 'volume'.
       */
      volumeShape?: components['schemas']['VolumeShape'];
      /**
       * @description Size/extents of the volume (interpretation depends on volumeShape).
       *     For box: full dimensions. For sphere: x=radius. For capsule: x=radius, y=height.
       */
      volumeSize?: components['schemas']['Vector3'];
      /**
       * Format: uuid
       * @description Scene ID to embed for reference nodes.
       *     Only relevant when nodeType is 'reference'.
       */
      referenceSceneId?: string | null;
    };
    /** @description Standard response containing a scene */
    SceneResponse: {
      /** @description The scene document */
      scene: components['schemas']['Scene'];
    };
    /** @description Summary of a scene for list results (excludes full node tree) */
    SceneSummary: {
      /**
       * Format: uuid
       * @description Unique scene identifier
       */
      sceneId: string;
      /** @description Game service identifier */
      gameId: string;
      /** @description Scene classification */
      sceneType: components['schemas']['SceneType'];
      /** @description Scene name */
      name: string;
      /** @description Scene description */
      description?: string | null;
      /** @description Current version */
      version: string;
      /** @description Scene tags */
      tags?: string[];
      /** @description Total number of nodes in scene */
      nodeCount?: number;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt?: string;
      /**
       * Format: date-time
       * @description Last update timestamp
       */
      updatedAt?: string;
      /** @description Whether scene is currently checked out */
      isCheckedOut?: boolean;
    };
    /**
     * @description Scene classification for querying and validation rule lookup.
     *     Different types may have different validation requirements per game.
     * @enum {string}
     */
    SceneType:
      | 'unknown'
      | 'region'
      | 'city'
      | 'district'
      | 'lot'
      | 'building'
      | 'room'
      | 'dungeon'
      | 'arena'
      | 'vehicle'
      | 'prefab'
      | 'cutscene'
      | 'other';
    /** @description Registered schema definition with version lineage information */
    SchemaResponse: {
      /** @description Schema namespace */
      namespace: string;
      /** @description Schema version */
      schemaVersion: string;
      /** @description JSON Schema definition */
      schema?: Record<string, never>;
      /** @description Previous version */
      previousVersion?: string | null;
      /** @description Whether migration script is registered */
      hasMigration?: boolean;
      /**
       * Format: date-time
       * @description Registration timestamp
       */
      createdAt: string;
    };
    /** @description Request to search documentation using keyword matching */
    SearchDocumentationRequest: {
      /** @description Documentation namespace to search within */
      namespace: string;
      /** @description Keyword or phrase to search for */
      searchTerm: string;
      /**
       * Format: uuid
       * @description Optional session ID for tracking searches (null if not tracking)
       */
      sessionId?: string | null;
      /** @description Filter results to a specific category (null for all categories) */
      category?: components['schemas']['DocumentCategory'];
      /**
       * @description Maximum number of results to return
       * @default 10
       */
      maxResults: number;
      /** @description Fields to search within (null for default fields) */
      searchIn?: components['schemas']['SearchField'][] | null;
      /**
       * @description How to sort the search results
       * @default relevance
       * @enum {string}
       */
      sortBy: 'relevance' | 'recency' | 'alphabetical';
      /**
       * @description Whether to include full document content in results
       * @default false
       */
      includeContent: boolean;
    };
    /** @description Response containing keyword search results */
    SearchDocumentationResponse: {
      /** @description The namespace that was searched */
      namespace: string;
      /** @description List of matching documents */
      results: components['schemas']['DocumentResult'][];
      /** @description Total number of matching documents */
      totalResults?: number;
      /** @description The original search term */
      searchTerm?: string;
    };
    /**
     * @description Fields that can be searched within documents
     * @enum {string}
     */
    SearchField: 'title' | 'content' | 'tags' | 'summary';
    /**
     * @description Where the search match was found
     * @enum {string}
     */
    SearchMatchType: 'name' | 'description' | 'tag' | 'node_name';
    /** @description A single search result */
    SearchResult: {
      /** @description Matching scene summary */
      scene: components['schemas']['SceneSummary'];
      /** @description Where the match was found */
      matchType: components['schemas']['SearchMatchType'];
      /** @description Context around the match */
      matchContext?: string | null;
    };
    /** @description Request for full-text search */
    SearchScenesRequest: {
      /** @description Search query text */
      query: string;
      /** @description Filter by game ID */
      gameId?: string | null;
      /** @description Filter by scene types */
      sceneTypes?: components['schemas']['SceneType'][] | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results
       * @default 50
       */
      limit: number;
    };
    /** @description Search results */
    SearchScenesResponse: {
      /** @description Matching scenes */
      results: components['schemas']['SearchResult'][];
      /** @description Total matches */
      total: number;
    };
    /** @description Season information */
    SeasonResponse: {
      /** @description ID of the leaderboard */
      leaderboardId: string;
      /** @description Season number */
      seasonNumber: number;
      /** @description Name of the season */
      seasonName?: string | null;
      /**
       * Format: date-time
       * @description When this season started
       */
      startedAt: string;
      /**
       * Format: date-time
       * @description When this season ended (null if active)
       */
      endedAt?: string | null;
      /** @description Whether this is the current season */
      isActive: boolean;
      /**
       * Format: int64
       * @description Number of entries in this season
       */
      entryCount?: number;
    };
    /** @description Response containing aggregate sentiment */
    SentimentResponse: {
      /**
       * Format: uuid
       * @description Character whose sentiment was queried
       */
      characterId: string;
      /**
       * Format: uuid
       * @description Target of the sentiment
       */
      targetCharacterId: string;
      /**
       * Format: float
       * @description Aggregate sentiment (-1.0 = hostile, +1.0 = friendly)
       */
      sentiment: number;
      /** @description Number of encounters factored in */
      encounterCount: number;
      /** @description Most common emotional impact across encounters */
      dominantEmotion?: components['schemas']['EmotionalImpact'];
    };
    /** @description Aggregated status of all game server realms */
    ServerStatusResponse: {
      /**
       * @description Overall status across all game realms
       * @enum {string}
       */
      globalStatus: 'online' | 'partial' | 'offline' | 'maintenance';
      /** @description Status information for each game realm */
      realms: components['schemas']['RealmStatus'][];
    };
    /** @description Information about a game service */
    ServiceInfo: {
      /**
       * Format: uuid
       * @description Unique identifier for the service
       */
      serviceId: string;
      /** @description URL-safe identifier (e.g., "my-game") */
      stubName: string;
      /** @description Human-readable name (e.g., "My Game Online") */
      displayName: string;
      /** @description Optional description */
      description?: string | null;
      /** @description Whether the service is currently active */
      isActive: boolean;
      /**
       * Format: date-time
       * @description When the service was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the service was last updated
       */
      updatedAt?: string | null;
    };
    /**
     * @description Game service stub name for created sessions. Use the game service's stubName property (e.g., "my-game"). Use "generic" for non-game-specific sessions.
     * @default generic
     */
    SessionGameType: string;
    /** @description Information about an active user session including device and activity details */
    SessionInfo: {
      /**
       * Format: uuid
       * @description Unique identifier for the session
       */
      sessionId: string;
      /** @description Information about the device used for this session */
      deviceInfo?: components['schemas']['DeviceInfo'];
      /**
       * Format: date-time
       * @description Timestamp when the session was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp of the last activity in this session
       */
      lastActive: string;
      /** @description IP address from which the session was initiated */
      ipAddress?: string | null;
      /** @description Geographic location derived from the IP address */
      location?: string | null;
    };
    /**
     * @description Current status of the game session
     * @enum {string}
     */
    SessionStatus: 'waiting' | 'active' | 'full' | 'finished';
    /**
     * @description Type of game session - determines join behavior
     * @enum {string}
     */
    SessionType: 'lobby' | 'matchmade';
    /** @description Response containing a list of all active sessions for an account */
    SessionsResponse: {
      /** @description List of active sessions for the account */
      sessions: components['schemas']['SessionInfo'][];
    };
    /** @description Request to set template values on a contract */
    SetTemplateValuesRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractInstanceId: string;
      /**
       * @description Key-value pairs for template substitution.
       *     Keys should follow pattern: EscrowId, PartyA_EscrowWalletId, etc.
       */
      templateValues: {
        [key: string]: string;
      };
    };
    /** @description Response from setting template values */
    SetTemplateValuesResponse: {
      /** @description Whether values were updated */
      updated: boolean;
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Number of template values set */
      valueCount?: number;
    };
    /** @description Global website configuration including branding, languages, and integrations */
    SiteSettings: {
      /** @description Display name of the website */
      siteName: string;
      /**
       * Format: uri
       * @description Base URL of the website
       */
      siteUrl: string;
      /** @description Short slogan or description of the site */
      tagline?: string | null;
      /**
       * @description Default language code for the website
       * @default en
       */
      defaultLanguage: string;
      /** @description List of supported language codes */
      supportedLanguages?: string[];
      /**
       * @description Whether the site is in maintenance mode
       * @default false
       */
      maintenanceMode: boolean;
      /** @description Message displayed during maintenance mode */
      maintenanceMessage?: string | null;
      /**
       * Format: email
       * @description Primary contact email address for the site
       */
      contactEmail?: string;
      /** @description Map of social media platform names to profile URLs */
      socialLinks?: {
        [key: string]: string;
      };
      /** @description Analytics and tracking service configuration */
      analytics?: components['schemas']['Analytics'];
      /** @description Custom JavaScript scripts to inject into pages */
      customScripts?: components['schemas']['CustomScripts'];
    };
    /** @description A step in the skill window expansion curve */
    SkillExpansionStep: {
      /** @description Number of intervals after which this step applies */
      intervals: number;
      /** @description Skill range (null means any skill level) */
      range?: number | null;
    };
    /** @description Complete metadata for a save slot including version statistics */
    SlotResponse: {
      /**
       * Format: uuid
       * @description Unique slot identifier
       */
      slotId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Save category determining retention and cleanup behavior */
      category: components['schemas']['SaveCategory'];
      /** @description Maximum versions to retain */
      maxVersions?: number;
      /** @description Days to retain versions (null = indefinite) */
      retentionDays?: number | null;
      /** @description Compression algorithm used for save data */
      compressionType?: components['schemas']['CompressionType'];
      /** @description Current number of versions in slot */
      versionCount?: number;
      /** @description Latest version number (null if empty) */
      latestVersion?: number | null;
      /**
       * Format: int64
       * @description Total storage used by all versions
       */
      totalSizeBytes?: number;
      /**
       * Format: date-time
       * @description Slot creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last modification timestamp
       */
      updatedAt?: string;
      /** @description Custom key-value metadata */
      metadata?: {
        [key: string]: string;
      };
    };
    /**
     * @description How scores are sorted
     * @enum {string}
     */
    SortOrder: 'descending' | 'ascending';
    /**
     * @description When item becomes bound to a character
     * @enum {string}
     */
    SoulboundType: 'none' | 'on_pickup' | 'on_equip' | 'on_use';
    /** @description Provenance reference to a source bundle used in metabundle creation */
    SourceBundleReference: {
      /** @description Source bundle identifier */
      bundleId: string;
      /** @description Version of source bundle at composition time */
      version: string;
      /** @description Asset IDs contributed from this source bundle */
      assetIds: string[];
      /** @description Hash of source bundle at composition time (for integrity verification) */
      contentHash: string;
    };
    /** @description Potential placement location */
    SpaceCandidate: {
      /**
       * Format: uuid
       * @description Container ID
       */
      containerId: string;
      /** @description Container type */
      containerType: string;
      /**
       * Format: double
       * @description How much can fit
       */
      canFitQuantity: number;
      /** @description Available slot */
      slotIndex?: number | null;
      /** @description Available grid X */
      slotX?: number | null;
      /** @description Available grid Y */
      slotY?: number | null;
      /**
       * Format: uuid
       * @description Stack to merge with
       */
      existingStackInstanceId?: string | null;
    };
    /**
     * @description Spatial context derived from game server's authoritative spatial state.
     *     Included in perception events to give NPC actors awareness of their environment
     *     without requiring direct map subscriptions.
     *
     *     Note: additionalProperties=true allows game-specific extensions.
     */
    SpatialContext: {
      /** @description Terrain type at character position (grass, stone, water, etc.) */
      terrainType?: string | null;
      /**
       * Format: float
       * @description Elevation at character position
       */
      elevation?: number | null;
      /** @description Objects within perception radius */
      nearbyObjects?: components['schemas']['NearbyObject'][] | null;
      /** @description Active hazards within detection range */
      hazardsInRange?: components['schemas']['HazardInfo'][] | null;
      /** @description Directions the character can move (for navigation awareness) */
      pathableDirections?: string[] | null;
      /** @description Whether cover is available within close range */
      coverNearby?: boolean | null;
      /** @description Whether character is currently indoors/under roof */
      indoors?: boolean | null;
    } & {
      [key: string]: unknown;
    };
    /** @description Request to spawn a new actor from a template */
    SpawnActorRequest: {
      /**
       * Format: uuid
       * @description Template to instantiate from
       */
      templateId: string;
      /** @description Optional custom actor ID (auto-generated if not provided) */
      actorId?: string | null;
      /** @description Override template defaults */
      configurationOverrides?: {
        [key: string]: unknown;
      } | null;
      /** @description Initial state passed to behavior */
      initialState?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: uuid
       * @description Optional character ID for NPC brain actors
       */
      characterId?: string | null;
    };
    /** @description Paginated list of species with total count for pagination */
    SpeciesListResponse: {
      /** @description List of species matching the query */
      species: components['schemas']['SpeciesResponse'][];
      /** @description Total number of species matching the query (for pagination) */
      totalCount: number;
      /** @description Current page number */
      page?: number;
      /** @description Number of items per page */
      pageSize?: number;
    };
    /** @description Complete species data including all attributes and realm associations */
    SpeciesResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the species
       */
      speciesId: string;
      /** @description Unique code for the species (e.g., "HUMAN", "ELF") */
      code: string;
      /** @description Display name for the species */
      name: string;
      /** @description Description of the species */
      description?: string | null;
      /** @description Category for grouping (e.g., "HUMANOID", "BEAST", "MAGICAL") */
      category?: string | null;
      /** @description Whether players can create characters of this species */
      isPlayable: boolean;
      /** @description Whether this species is deprecated and cannot be used for new characters */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this species was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation */
      deprecationReason?: string | null;
      /** @description Base lifespan in game years */
      baseLifespan?: number | null;
      /** @description Age at which the species reaches maturity */
      maturityAge?: number | null;
      /** @description Base trait modifiers for this species */
      traitModifiers?: {
        [key: string]: unknown;
      } | null;
      /** @description Realms where this species is available */
      realmIds?: string[];
      /** @description Additional metadata for the species */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Timestamp when the species was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the species was last updated
       */
      updatedAt: string;
    };
    /** @description Allocation of assets to a party in a split resolution */
    SplitAllocation: {
      /**
       * Format: uuid
       * @description Party ID
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Assets allocated to this party */
      assets: components['schemas']['EscrowAssetInput'][];
    };
    /** @description Request to split a stack */
    SplitStackRequest: {
      /**
       * Format: uuid
       * @description Stack to split
       */
      instanceId: string;
      /**
       * Format: double
       * @description Quantity to split off
       */
      quantity: number;
      /** @description Slot for new stack */
      targetSlotIndex?: number | null;
      /** @description Grid X for new stack */
      targetSlotX?: number | null;
      /** @description Grid Y for new stack */
      targetSlotY?: number | null;
    };
    /** @description Response after splitting */
    SplitStackResponse: {
      /** @description Whether split succeeded */
      success: boolean;
      /**
       * Format: uuid
       * @description Original stack ID
       */
      originalInstanceId: string;
      /**
       * Format: uuid
       * @description New stack ID
       */
      newInstanceId: string;
      /**
       * Format: double
       * @description Remaining quantity
       */
      originalQuantity: number;
      /**
       * Format: double
       * @description Split quantity
       */
      newQuantity: number;
    };
    /** @description Request to start an encounter managed by an Event Brain actor */
    StartEncounterRequest: {
      /** @description ID of the Event Brain actor that will manage this encounter */
      actorId: string;
      /**
       * Format: uuid
       * @description Unique identifier for this encounter
       */
      encounterId: string;
      /** @description Type of encounter (e.g., "combat", "conversation", "choreography") */
      encounterType: string;
      /** @description Character IDs of participants in the encounter */
      participants: string[];
      /** @description Optional initial data for the encounter */
      initialData?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Health and version status information for the website service */
    StatusResponse: {
      /**
       * @description Current health status of the website service
       * @enum {string}
       */
      status: 'healthy' | 'degraded' | 'maintenance';
      /**
       * @description Current version of the website service
       * @example 1.0.0
       */
      version: string;
      /** @description Uptime in seconds */
      uptime: number;
      /** @description Message displayed during maintenance mode */
      maintenanceMessage?: string | null;
    };
    /**
     * @description Request to verify a Steam Session Ticket. The ticket is obtained client-side via
     *     ISteamUser::GetAuthTicketForWebApi("bannou"). SteamID is NOT included because
     *     it must be obtained from Steam's Web API response (never trust client-provided SteamID).
     */
    SteamVerifyRequest: {
      /**
       * @description Hex-encoded Steam Session Ticket from ISteamUser::GetAuthTicketForWebApi().
       *     Client converts ticket bytes to hex string: BitConverter.ToString(ticketData).Replace("-", "")
       * @example 140000006A7B3C8E...
       */
      ticket: string;
      /** @description Information about the client device (optional) */
      deviceInfo?: components['schemas']['DeviceInfo'];
    };
    /** @description Request to stop a running actor */
    StopActorRequest: {
      /** @description ID of the actor to stop */
      actorId: string;
      /**
       * @description If true, allows behavior to complete current iteration
       * @default true
       */
      graceful: boolean;
    };
    /** @description Response confirming actor stop operation */
    StopActorResponse: {
      /** @description Whether the actor was successfully stopped */
      stopped: boolean;
      /** @description Final status of the actor after stopping */
      finalStatus: components['schemas']['ActorStatus'];
    };
    /** @description Response containing a style definition */
    StyleDefinitionResponse: {
      /** @description Unique style identifier */
      styleId: string;
      /** @description Style name */
      name: string;
      /** @description Style category */
      category: string;
      /** @description Human-readable description */
      description?: string | null;
      /** @description Mode probability distribution */
      modeDistribution?: components['schemas']['ModeDistribution'];
      /** @description Interval preferences */
      intervalPreferences?: components['schemas']['IntervalPreferences'];
      /** @description Available forms */
      formTemplates?: components['schemas']['FormTemplate'][] | null;
      /** @description Style-specific tune types */
      tuneTypes?: components['schemas']['TuneType'][] | null;
      /** @description Default tempo */
      defaultTempo?: number;
      /** @description Harmony preferences */
      harmonyStyle?: components['schemas']['HarmonyStyle'];
    };
    /** @description Brief style summary for listing */
    StyleSummary: {
      /** @description Style identifier */
      styleId: string;
      /** @description Style name */
      name: string;
      /** @description Style category */
      category: string;
      /** @description Brief description */
      description?: string | null;
    };
    /** @description Information about a subscription */
    SubscriptionInfo: {
      /**
       * Format: uuid
       * @description Unique identifier for the subscription
       */
      subscriptionId: string;
      /**
       * Format: uuid
       * @description ID of the account this subscription belongs to
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the subscribed service (game)
       */
      serviceId: string;
      /** @description Stub name of the service (denormalized for efficiency) */
      stubName: string;
      /** @description Display name of the service (denormalized for efficiency) */
      displayName?: string;
      /**
       * Format: date-time
       * @description When the subscription started
       */
      startDate: string;
      /**
       * Format: date-time
       * @description When the subscription expires (null for unlimited)
       */
      expirationDate?: string | null;
      /** @description Whether the subscription is currently active */
      isActive: boolean;
      /**
       * Format: date-time
       * @description When the subscription was cancelled (if applicable)
       */
      cancelledAt?: string | null;
      /** @description Reason for cancellation (if applicable) */
      cancellationReason?: string | null;
      /**
       * Format: date-time
       * @description When the subscription was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the subscription was last updated
       */
      updatedAt?: string | null;
    };
    /** @description Response containing list of subscriptions */
    SubscriptionListResponse: {
      /** @description List of subscriptions matching the filter criteria */
      subscriptions: components['schemas']['SubscriptionInfo'][];
      /** @description Total number of subscriptions matching the filter */
      totalCount: number;
    };
    /** @description Current subscription status and plan details for an account */
    SubscriptionResponse: {
      /**
       * @description Current state of the subscription
       * @enum {string}
       */
      status: 'active' | 'inactive' | 'trial' | 'expired';
      /**
       * @description Subscription tier or plan type
       * @enum {string}
       */
      type: 'free' | 'basic' | 'premium' | 'lifetime';
      /**
       * Format: date-time
       * @description Date and time when the subscription expires
       */
      expiresAt?: string | null;
      /** @description Whether automatic renewal is enabled */
      autoRenew?: boolean;
      /** @description List of benefits included in the subscription */
      benefits?: string[];
    };
    /** @description Request to get related topic suggestions based on a source */
    SuggestRelatedRequest: {
      /** @description Documentation namespace for suggestions */
      namespace: string;
      /** @description Type of source to base suggestions on */
      suggestionSource: components['schemas']['SuggestionSource'];
      /** @description The value for the suggestion source (document ID, slug, topic, or category) */
      sourceValue?: string;
      /**
       * Format: uuid
       * @description Optional session ID for personalized suggestions
       */
      sessionId?: string;
      /**
       * @description Maximum number of suggestions to return
       * @default 5
       */
      maxSuggestions: number;
      /**
       * @description Exclude documents viewed in current session
       * @default true
       */
      excludeRecentlyViewed: boolean;
    };
    /** @description Response containing suggested related topics for conversational flow */
    SuggestRelatedResponse: {
      /** @description The namespace suggestions are from */
      namespace: string;
      /** @description List of suggested related topics */
      suggestions: components['schemas']['TopicSuggestion'][];
      /** @description Voice-friendly prompt for presenting suggestions */
      voicePrompt?: string;
      /** @description Whether suggestions were influenced by session history */
      sessionInfluenced?: boolean;
    };
    /**
     * @description Source type for generating related topic suggestions
     * @enum {string}
     */
    SuggestionSource: 'document_id' | 'slug' | 'topic' | 'category';
    /** @description Information about a repository sync operation */
    SyncInfo: {
      /**
       * Format: uuid
       * @description Unique identifier of the sync operation
       */
      syncId?: string;
      /** @description Result status of the sync */
      status?: components['schemas']['SyncStatus'];
      /** @description What triggered the sync */
      triggeredBy?: components['schemas']['SyncTrigger'];
      /**
       * Format: date-time
       * @description Timestamp when sync started
       */
      startedAt?: string;
      /**
       * Format: date-time
       * @description Timestamp when sync completed
       */
      completedAt?: string;
      /** @description Git commit hash that was synced (null if sync failed or repo is empty) */
      commitHash?: string | null;
      /** @description Total documents processed in sync */
      documentsProcessed?: number;
    };
    /** @description Request to trigger a manual repository sync */
    SyncRepositoryRequest: {
      /** @description Documentation namespace to sync */
      namespace: string;
      /**
       * @description Force full re-sync even if commit hash unchanged
       * @default false
       */
      force: boolean;
    };
    /** @description Response containing sync operation results and statistics */
    SyncRepositoryResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of this sync operation
       */
      syncId: string;
      /** @description Result status of the sync */
      status: components['schemas']['SyncStatus'];
      /** @description Git commit hash that was synced (null if sync failed or repo is empty) */
      commitHash?: string | null;
      /** @description Number of new documents created */
      documentsCreated?: number;
      /** @description Number of existing documents updated */
      documentsUpdated?: number;
      /** @description Number of documents deleted */
      documentsDeleted?: number;
      /** @description Number of documents that failed to process */
      documentsFailed?: number;
      /** @description Time taken for sync in milliseconds */
      durationMs?: number;
      /** @description Error message if sync failed */
      errorMessage?: string | null;
    };
    /**
     * @description Status of platform synchronization
     * @enum {string}
     */
    SyncStatus: 'pending' | 'synced' | 'failed' | 'not_linked';
    /**
     * @description What triggered the sync operation
     * @enum {string}
     */
    SyncTrigger: 'manual' | 'scheduled';
    /** @description A tempo change event */
    TempoEvent: {
      /** @description Tick position */
      tick: number;
      /**
       * Format: float
       * @description Tempo in BPM
       */
      bpm: number;
    };
    /** @description A tempo range with min and max BPM */
    TempoRange: {
      /** @description Minimum tempo */
      min: number;
      /** @description Maximum tempo */
      max: number;
    };
    /** @description Request to terminate a contract */
    TerminateContractInstanceRequest: {
      /**
       * Format: uuid
       * @description Contract to terminate
       */
      contractId: string;
      /**
       * Format: uuid
       * @description Entity requesting termination
       */
      requestingEntityId: string;
      /** @description Type of requesting entity */
      requestingEntityType: components['schemas']['EntityType'];
      /** @description Reason for termination */
      reason?: string | null;
    };
    /** @description Request to terminate a specific session */
    TerminateSessionRequest: {
      /**
       * Format: uuid
       * @description ID of the session to terminate
       */
      sessionId: string;
    };
    /**
     * @description How the contract can be terminated
     * @enum {string}
     */
    TerminationPolicy:
      | 'mutual_consent'
      | 'unilateral_with_notice'
      | 'unilateral_immediate'
      | 'non_terminable';
    /** @description Visual theme configuration including colors, fonts, and navigation */
    ThemeConfig: {
      /** @description Name of the active theme */
      themeName: string;
      /** @description Primary brand color in hex format */
      primaryColor: string;
      /** @description Secondary brand color in hex format */
      secondaryColor?: string;
      /** @description Default background color in hex format */
      backgroundColor?: string;
      /** @description Default text color in hex format */
      textColor?: string;
      /** @description Primary font family for the site */
      fontFamily?: string;
      /** @description Additional custom CSS styles */
      customCSS?: string | null;
      /** @description Site logo configuration for branding */
      logo?: components['schemas']['Logo'];
      /**
       * Format: uri
       * @description URL of the site favicon
       */
      favicon?: string | null;
      /** @description Main navigation menu items */
      navigation?: components['schemas']['NavigationItem'][];
    };
    /**
     * @description Current status of a matchmaking ticket
     * @enum {string}
     */
    TicketStatus: 'searching' | 'match_found' | 'match_accepted' | 'cancelled' | 'expired';
    /** @description A time signature change event */
    TimeSignatureEvent: {
      /** @description Tick position */
      tick: number;
      /** @description Beats per measure */
      numerator: number;
      /** @description Beat unit (4 = quarter, 8 = eighth) */
      denominator: number;
    };
    /** @description A suggested related topic with relevance context */
    TopicSuggestion: {
      /**
       * Format: uuid
       * @description Unique identifier of the suggested document
       */
      documentId: string;
      /** @description URL-friendly slug of the suggested document */
      slug?: string;
      /** @description Title of the suggested document */
      title: string;
      /** @description Category of the suggested document */
      category?: components['schemas']['DocumentCategory'];
      /** @description Explanation of why this document is relevant */
      relevanceReason?: string;
    };
    /**
     * @description Core personality trait axes. Each represents a spectrum from -1.0 to +1.0.
     *     Based on psychological research (Big Five + game-relevant extensions).
     * @enum {string}
     */
    TraitAxis:
      | 'OPENNESS'
      | 'CONSCIENTIOUSNESS'
      | 'EXTRAVERSION'
      | 'AGREEABLENESS'
      | 'NEUROTICISM'
      | 'HONESTY'
      | 'AGGRESSION'
      | 'LOYALTY';
    /** @description A single personality trait with its current value and evolution history */
    TraitValue: {
      /** @description The personality axis this value represents */
      axis: components['schemas']['TraitAxis'];
      /**
       * Format: float
       * @description Current trait value on the spectrum (-1.0 to +1.0)
       */
      value: number;
      /**
       * Format: date-time
       * @description When this trait last evolved (null if never changed since creation)
       */
      lastChangedAt?: string | null;
      /**
       * @description Number of times this trait has evolved
       * @default 0
       */
      changeCount: number;
    };
    /** @description Transaction details */
    TransactionResponse: {
      /** @description Transaction record */
      transaction: components['schemas']['CurrencyTransactionRecord'];
    };
    /**
     * @description Classification of the currency transaction
     * @enum {string}
     */
    TransactionType:
      | 'mint'
      | 'quest_reward'
      | 'loot_drop'
      | 'vendor_sale'
      | 'autogain'
      | 'refund'
      | 'conversion_credit'
      | 'burn'
      | 'vendor_purchase'
      | 'fee'
      | 'expiration'
      | 'cap_overflow'
      | 'conversion_debit'
      | 'transfer'
      | 'trade'
      | 'gift'
      | 'escrow_deposit'
      | 'escrow_release'
      | 'escrow_refund';
    /** @description Request to transfer a party role to a new entity */
    TransferContractPartyRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractInstanceId: string;
      /**
       * Format: uuid
       * @description Current party entity ID
       */
      fromEntityId: string;
      /** @description Current party entity type */
      fromEntityType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description New entity ID to receive the role
       */
      toEntityId: string;
      /** @description New entity type */
      toEntityType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Guardian entity ID (must be current guardian)
       */
      guardianId: string;
      /** @description Guardian entity type */
      guardianType: string;
      /** @description Optional idempotency key for the operation */
      idempotencyKey?: string | null;
    };
    /** @description Response from transferring a party role */
    TransferContractPartyResponse: {
      /** @description Whether the transfer was successful */
      transferred: boolean;
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Role that was transferred */
      role?: string;
      /**
       * Format: uuid
       * @description Previous party entity ID
       */
      fromEntityId?: string;
      /**
       * Format: uuid
       * @description New party entity ID
       */
      toEntityId?: string;
    };
    /** @description Request to transfer currency between wallets */
    TransferCurrencyRequest: {
      /**
       * Format: uuid
       * @description Source wallet ID
       */
      sourceWalletId: string;
      /**
       * Format: uuid
       * @description Target wallet ID
       */
      targetWalletId: string;
      /**
       * Format: uuid
       * @description Currency to transfer
       */
      currencyDefinitionId: string;
      /**
       * Format: double
       * @description Amount to transfer (must be positive)
       */
      amount: number;
      /** @description Must be a transfer type (transfer, trade, gift) */
      transactionType: components['schemas']['TransactionType'];
      /** @description What triggered this transfer */
      referenceType?: string | null;
      /**
       * Format: uuid
       * @description Reference entity ID
       */
      referenceId?: string | null;
      /** @description Unique key to prevent duplicate processing */
      idempotencyKey: string;
      /** @description Free-form transaction metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Result of transfer operation */
    TransferCurrencyResponse: {
      /** @description Created transaction record */
      transaction: components['schemas']['CurrencyTransactionRecord'];
      /**
       * Format: double
       * @description Source wallet balance after transfer
       */
      sourceNewBalance: number;
      /**
       * Format: double
       * @description Target wallet balance after transfer
       */
      targetNewBalance: number;
      /** @description Whether target wallet cap was applied */
      targetCapApplied: boolean;
      /**
       * Format: double
       * @description Amount lost due to target wallet cap
       */
      targetCapAmountLost?: number | null;
    };
    /** @description Request to transfer item ownership */
    TransferItemRequest: {
      /**
       * Format: uuid
       * @description Item instance ID
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Target container ID
       */
      targetContainerId: string;
      /**
       * Format: double
       * @description Quantity to transfer (all if null)
       */
      quantity?: number | null;
    };
    /** @description Response after transfer */
    TransferItemResponse: {
      /** @description Whether transfer succeeded */
      success: boolean;
      /**
       * Format: uuid
       * @description Transferred item ID
       */
      instanceId: string;
      /**
       * Format: uuid
       * @description Previous container
       */
      sourceContainerId: string;
      /**
       * Format: uuid
       * @description New container
       */
      targetContainerId: string;
      /**
       * Format: double
       * @description Amount transferred
       */
      quantityTransferred: number;
    };
    /** @description Result of transferring assets to a party during resolution */
    TransferResult: {
      /**
       * Format: uuid
       * @description Party ID
       */
      partyId: string;
      /** @description Assets transferred (null if failed) */
      assets?: components['schemas']['EscrowAssetBundle'];
      /** @description Whether transfer succeeded */
      success: boolean;
      /** @description Error message if failed */
      error?: string | null;
    };
    /** @description Position, rotation, and scale in 3D space */
    Transform: {
      /** @description Position relative to parent */
      position: components['schemas']['Vector3'];
      /** @description Rotation relative to parent */
      rotation: components['schemas']['Quaternion'];
      /** @description Scale relative to parent */
      scale: components['schemas']['Vector3'];
    };
    /** @description A style-specific tune type definition */
    TuneType: {
      /** @description Tune type name (e.g., "reel", "jig") */
      name: string;
      /** @description Time signature for this tune type */
      meter: components['schemas']['TimeSignatureEvent'];
      /** @description Typical tempo range */
      tempoRange?: components['schemas']['TempoRange'];
      /** @description Default form for this tune type */
      defaultForm?: string | null;
      /** @description Rhythm pattern names to use */
      rhythmPatterns?: string[] | null;
    };
    /** @description Request to unlock a contract from guardian custody */
    UnlockContractRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID to unlock
       */
      contractInstanceId: string;
      /**
       * Format: uuid
       * @description Guardian entity ID (must match current guardian)
       */
      guardianId: string;
      /** @description Guardian entity type */
      guardianType: string;
      /** @description Optional idempotency key for the operation */
      idempotencyKey?: string | null;
    };
    /** @description Response from unlocking a contract */
    UnlockContractResponse: {
      /** @description Whether the contract was unlocked */
      unlocked: boolean;
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
    };
    /** @description An unlocked achievement instance */
    UnlockedAchievement: {
      /** @description Achievement identifier */
      achievementId: string;
      /** @description Achievement name */
      displayName: string;
      /** @description Achievement description */
      description?: string;
      /** @description Point value */
      points: number;
      /** @description Achievement icon */
      iconUrl?: string | null;
      /**
       * Format: date-time
       * @description When it was unlocked
       */
      unlockedAt: string;
    };
    /** @description Request to unpin a previously pinned save version */
    UnpinVersionRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Version to unpin */
      versionNumber: number;
    };
    /** @description A scene reference that could not be resolved */
    UnresolvedReference: {
      /**
       * Format: uuid
       * @description Node ID containing the reference
       */
      nodeId: string;
      /** @description refId of the referencing node */
      refId: string;
      /**
       * Format: uuid
       * @description ID of the scene that could not be resolved
       */
      referencedSceneId: string;
      /** @description Why the reference could not be resolved */
      reason: components['schemas']['UnresolvedReferenceReason'];
      /** @description For circular references, the cycle path (sceneId chain) */
      cyclePath?: string[] | null;
    };
    /**
     * @description Reason why a scene reference could not be resolved
     * @enum {string}
     */
    UnresolvedReferenceReason:
      | 'not_found'
      | 'circular_reference'
      | 'depth_exceeded'
      | 'access_denied';
    /** @description Request to update an achievement definition */
    UpdateAchievementDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the achievement to update */
      achievementId: string;
      /** @description New display name */
      displayName?: string | null;
      /** @description New description */
      description?: string | null;
      /** @description New active status */
      isActive?: boolean | null;
      /** @description Updated platform ID mappings */
      platformIds?: {
        [key: string]: string;
      } | null;
    };
    /** @description Request to update an existing actor template */
    UpdateActorTemplateRequest: {
      /**
       * Format: uuid
       * @description ID of the template to update
       */
      templateId: string;
      /** @description New behavior reference (triggers behavior.updated subscription) */
      behaviorRef?: string | null;
      /** @description Updated configuration settings */
      configuration?: {
        [key: string]: unknown;
      } | null;
      /** @description Updated auto-spawn configuration */
      autoSpawn?: components['schemas']['AutoSpawnConfig'];
      /** @description Updated tick interval in milliseconds */
      tickIntervalMs?: number | null;
      /** @description Updated auto-save interval in seconds */
      autoSaveIntervalSeconds?: number | null;
    };
    /** @description Request to update bundle metadata */
    UpdateBundleRequest: {
      /** @description Human-readable bundle identifier to update */
      bundleId: string;
      /** @description New bundle name (null to leave unchanged) */
      name?: string | null;
      /** @description New bundle description (null to leave unchanged) */
      description?: string | null;
      /** @description Replace all tags with these (null to leave unchanged) */
      tags?: {
        [key: string]: string;
      } | null;
      /** @description Tags to add (merged with existing) */
      addTags?: {
        [key: string]: string;
      } | null;
      /** @description Tag keys to remove */
      removeTags?: string[] | null;
      /** @description Optional reason for the update (recorded in version history) */
      reason?: string | null;
    };
    /** @description Result of bundle update operation */
    UpdateBundleResponse: {
      /** @description Human-readable bundle identifier that was updated */
      bundleId: string;
      /** @description New version number after update */
      version: number;
      /** @description Version number before update */
      previousVersion: number;
      /** @description List of changes made (e.g., "name changed", "tag 'env' added") */
      changes: string[];
      /**
       * Format: date-time
       * @description When the update occurred
       */
      updatedAt?: string;
    };
    /** @description Request to update container properties */
    UpdateContainerRequest: {
      /**
       * Format: uuid
       * @description Container ID to update
       */
      containerId: string;
      /** @description New max slots */
      maxSlots?: number | null;
      /**
       * Format: double
       * @description New max weight
       */
      maxWeight?: number | null;
      /** @description New grid width */
      gridWidth?: number | null;
      /** @description New grid height */
      gridHeight?: number | null;
      /**
       * Format: double
       * @description New max volume
       */
      maxVolume?: number | null;
      /** @description New allowed categories */
      allowedCategories?: string[] | null;
      /** @description New forbidden categories */
      forbiddenCategories?: string[] | null;
      /** @description New allowed tags */
      allowedTags?: string[] | null;
      /** @description New container tags */
      tags?: string[] | null;
      /** @description New metadata */
      metadata?: Record<string, never> | null;
    };
    /** @description Request to update contract metadata */
    UpdateContractMetadataRequest: {
      /**
       * Format: uuid
       * @description Contract instance ID
       */
      contractId: string;
      /** @description Which metadata to update */
      metadataType: components['schemas']['MetadataType'];
      /** @description Metadata to set or merge */
      data: {
        [key: string]: unknown;
      };
    };
    /** @description Request to update a map definition */
    UpdateDefinitionRequest: {
      /**
       * Format: uuid
       * @description Definition ID to update
       */
      definitionId: string;
      /** @description New name (optional) */
      name?: string | null;
      /** @description New description (optional) */
      description?: string | null;
      /** @description New layer configurations (replaces existing) */
      layers?: components['schemas']['LayerDefinition'][] | null;
      /** @description New default bounds */
      defaultBounds?: components['schemas']['Bounds'];
      /** @description New metadata (replaces existing) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update the phase of an active encounter */
    UpdateEncounterPhaseRequest: {
      /** @description ID of the Event Brain actor managing the encounter */
      actorId: string;
      /** @description New phase name for the encounter */
      phase: string;
    };
    /** @description Response after updating encounter phase */
    UpdateEncounterPhaseResponse: {
      /** @description ID of the actor managing the encounter */
      actorId: string;
      /** @description Previous phase name */
      previousPhase?: string | null;
      /** @description Current phase name after update */
      currentPhase: string;
    };
    /** @description Request to update mutable fields of an item template */
    UpdateItemTemplateRequest: {
      /**
       * Format: uuid
       * @description Template ID to update
       */
      templateId: string;
      /** @description New display name */
      name?: string | null;
      /** @description New description */
      description?: string | null;
      /** @description New subcategory */
      subcategory?: string | null;
      /** @description New tags (replaces existing) */
      tags?: string[] | null;
      /** @description New rarity tier */
      rarity?: components['schemas']['ItemRarity'];
      /**
       * Format: double
       * @description New weight value
       */
      weight?: number | null;
      /**
       * Format: double
       * @description New volume value
       */
      volume?: number | null;
      /** @description New grid width */
      gridWidth?: number | null;
      /** @description New grid height */
      gridHeight?: number | null;
      /** @description New rotation setting */
      canRotate?: boolean | null;
      /**
       * Format: double
       * @description New base value
       */
      baseValue?: number | null;
      /** @description New tradeable setting */
      tradeable?: boolean | null;
      /** @description New destroyable setting */
      destroyable?: boolean | null;
      /** @description New max durability */
      maxDurability?: number | null;
      /** @description New available realms */
      availableRealms?: string[] | null;
      /** @description New stats */
      stats?: Record<string, never> | null;
      /** @description New effects */
      effects?: Record<string, never> | null;
      /** @description New requirements */
      requirements?: Record<string, never> | null;
      /** @description New display properties */
      display?: Record<string, never> | null;
      /** @description New metadata */
      metadata?: Record<string, never> | null;
      /** @description Active status */
      isActive?: boolean | null;
    };
    /** @description Request to update a leaderboard definition */
    UpdateLeaderboardDefinitionRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description ID of the leaderboard to update */
      leaderboardId: string;
      /** @description New display name */
      displayName?: string | null;
      /** @description New description */
      description?: string | null;
      /** @description New visibility setting */
      isPublic?: boolean | null;
    };
    /**
     * @description How to handle score updates
     * @enum {string}
     */
    UpdateMode: 'replace' | 'increment' | 'max' | 'min';
    /** @description Request to update an account password */
    UpdatePasswordRequest: {
      /**
       * Format: uuid
       * @description ID of the account to update
       */
      accountId: string;
      /** @description New pre-hashed password from Auth service */
      passwordHash: string;
    };
    /** @description Request to update an account profile */
    UpdateProfileRequest: {
      /**
       * Format: uuid
       * @description ID of the account to update
       */
      accountId: string;
      /** @description New display name for the account */
      displayName?: string | null;
      /** @description Updated custom metadata for the account */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update repository binding configuration */
    UpdateRepositoryBindingRequest: {
      /** @description Documentation namespace of the binding to update */
      namespace: string;
      /** @description Enable or disable automatic syncing */
      syncEnabled?: boolean;
      /** @description New sync interval in minutes */
      syncIntervalMinutes?: number;
      /** @description New glob patterns for files to include (null to keep unchanged) */
      filePatterns?: string[] | null;
      /** @description New glob patterns for files to exclude (null to keep unchanged) */
      excludePatterns?: string[] | null;
      /** @description New directory-to-category mapping (null to keep unchanged) */
      categoryMapping?: {
        [key: string]: string;
      } | null;
      /** @description New default category for unmapped documents */
      defaultCategory?: components['schemas']['DocumentCategory'];
      /** @description Enable or disable archive functionality */
      archiveEnabled?: boolean;
      /** @description Enable or disable archiving after each sync */
      archiveOnSync?: boolean;
    };
    /** @description Response containing the updated binding configuration */
    UpdateRepositoryBindingResponse: {
      /** @description Updated binding configuration */
      binding: components['schemas']['RepositoryBindingInfo'];
    };
    /** @description Request to update an existing scene */
    UpdateSceneRequest: {
      /** @description The updated scene document (sceneId must match existing) */
      scene: components['schemas']['Scene'];
      /** @description Checkout token if updating via checkout workflow */
      checkoutToken?: string | null;
    };
    /** @description Request to update email verification status */
    UpdateVerificationRequest: {
      /**
       * Format: uuid
       * @description ID of the account to update
       */
      accountId: string;
      /** @description New email verification status */
      emailVerified: boolean;
    };
    /** @description Request to initiate an asset upload and receive a pre-signed URL */
    UploadRequest: {
      /**
       * @description Owner of this asset operation. NOT a session ID.
       *     For user-initiated uploads: the accountId (UUID format).
       *     For service-initiated uploads: the service name (e.g., "behavior", "orchestrator").
       */
      owner: string;
      /** @description Original filename with extension */
      filename: string;
      /**
       * Format: int64
       * @description File size in bytes
       */
      size: number;
      /** @description MIME content type (e.g., image/png, model/gltf-binary) */
      contentType: string;
      /** @description Optional metadata for asset categorization */
      metadata?: components['schemas']['AssetMetadataInput'];
    };
    /** @description Response containing pre-signed URL and configuration for uploading an asset */
    UploadResponse: {
      /**
       * Format: uuid
       * @description Unique upload session identifier
       */
      uploadId: string;
      /**
       * Format: uri
       * @description Pre-signed URL for uploading the file
       */
      uploadUrl: string;
      /**
       * Format: date-time
       * @description When the upload URL expires
       */
      expiresAt: string;
      /** @description Configuration for multipart uploads if file size requires it */
      multipart?: components['schemas']['MultipartConfig'];
      /** @description Headers the client must include when uploading to the pre-signed URL */
      requiredHeaders?: {
        [key: string]: string;
      };
    };
    /** @description Request to validate ABML YAML content against schema and semantic rules */
    ValidateAbmlRequest: {
      /** @description Raw ABML YAML content to validate */
      abmlContent: string;
      /**
       * @description Enable strict validation mode with enhanced checking
       * @default false
       */
      strictMode: boolean;
    };
    /** @description Response containing the results of ABML validation including errors and warnings */
    ValidateAbmlResponse: {
      /** @description Whether the ABML definition is valid */
      isValid: boolean;
      /** @description List of validation errors if invalid */
      validationErrors?: components['schemas']['ValidationError'][] | null;
      /** @description Semantic warnings that don't prevent compilation */
      semanticWarnings?: string[] | null;
      /** @description ABML schema version used for validation */
      schemaVersion?: string | null;
    };
    /** @description Request to validate a deposit without executing */
    ValidateDepositRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /**
       * Format: uuid
       * @description Party to validate
       */
      partyId: string;
      /** @description Type of entity (Account, Character, etc.) */
      partyType: components['schemas']['EntityType'];
      /** @description Assets to validate */
      assets: components['schemas']['EscrowAssetBundleInput'];
    };
    /** @description Response from deposit validation */
    ValidateDepositResponse: {
      /** @description Whether the deposit would be valid */
      valid: boolean;
      /** @description Validation errors */
      errors: string[];
      /** @description Validation warnings */
      warnings: string[];
    };
    /** @description Request to validate an existing GOAP plan against current world state */
    ValidateGoapPlanRequest: {
      /** @description The plan to validate */
      plan: components['schemas']['GoapPlanResult'];
      /** @description Index of the action currently being executed */
      currentActionIndex: number;
      /** @description Current world state */
      worldState: {
        [key: string]: unknown;
      };
      /** @description All active goals for priority checking */
      activeGoals?: components['schemas']['GoapGoal'][] | null;
    };
    /** @description Response indicating whether a GOAP plan is still valid and suggested next action */
    ValidateGoapPlanResponse: {
      /** @description Whether the plan is still valid */
      isValid: boolean;
      /**
       * @description Reason for the validation result
       * @enum {string}
       */
      reason:
        | 'none'
        | 'preconditionInvalidated'
        | 'actionFailed'
        | 'betterGoalAvailable'
        | 'planCompleted'
        | 'goalAlreadySatisfied'
        | 'suboptimalPlan';
      /**
       * @description Suggested action based on validation
       * @enum {string}
       */
      suggestedAction: 'continue' | 'replan' | 'abort';
      /** @description Index where plan became invalid (if applicable) */
      invalidatedAtIndex?: number;
      /** @description Additional details about the validation result. Null when no additional context is needed. */
      message?: string | null;
    };
    /** @description Request to validate MIDI-JSON structure */
    ValidateMidiJsonRequest: {
      /** @description MIDI-JSON structure to validate */
      midiJson: components['schemas']['MidiJson'];
      /**
       * @description Enable strict validation with additional checks
       * @default false
       */
      strictMode: boolean;
    };
    /** @description Response containing validation results */
    ValidateMidiJsonResponse: {
      /** @description Whether the MIDI-JSON is valid */
      isValid: boolean;
      /** @description Validation errors if invalid */
      errors?: components['schemas']['ValidationError'][] | null;
      /** @description Non-fatal warnings */
      warnings?: string[] | null;
    };
    /** @description Request to validate a scene structure */
    ValidateSceneRequest: {
      /** @description The scene to validate */
      scene: components['schemas']['Scene'];
      /**
       * @description Whether to apply registered game-specific validation rules
       * @default true
       */
      applyGameRules: boolean;
    };
    /** @description Response from token validation containing validity status and associated account details */
    ValidateTokenResponse: {
      /** @description Whether the token is valid and not expired */
      valid: boolean;
      /**
       * Format: uuid
       * @description Unique identifier for the account associated with the token
       */
      accountId: string;
      /**
       * Format: uuid
       * @description Session identifier for WebSocket connections and service routing
       */
      sessionId: string;
      /** @description List of roles assigned to the authenticated user */
      roles?: string[] | null;
      /**
       * @description Authorization strings from active subscriptions.
       *     Format: "{stubName}:{state}" (e.g., "my-game:authorized")
       */
      authorizations?: string[] | null;
      /** @description Seconds until expiration */
      remainingTime?: number;
    };
    /** @description A single condition to check against an API response */
    ValidationCondition: {
      /** @description The type of validation condition to check */
      type: components['schemas']['ValidationConditionType'];
      /**
       * @description JsonPath expression to extract value from response.
       *     Required for jsonPathEquals, jsonPathExists, jsonPathNotExists.
       *     Example: "$.balance", "$.items[0].status"
       */
      jsonPath?: string | null;
      /**
       * @description Expected value for comparison conditions.
       *     Type coercion applied: "true"/"false" for booleans, numeric strings for numbers.
       */
      expectedValue?: string | null;
      /** @description Comparison operator for numeric comparisons */
      operator?: components['schemas']['ComparisonOperator'];
      /** @description HTTP status codes for statusCodeIn condition */
      statusCodes?: number[];
    };
    /**
     * @description Type of validation condition
     * @enum {string}
     */
    ValidationConditionType:
      | 'statusCodeIn'
      | 'jsonPathEquals'
      | 'jsonPathNotEquals'
      | 'jsonPathExists'
      | 'jsonPathNotExists'
      | 'jsonPathGreaterThan'
      | 'jsonPathLessThan'
      | 'jsonPathContains';
    /** @description Detailed validation error with type, location, and message information */
    ValidationError: {
      /**
       * @description Type of validation error
       * @enum {string}
       */
      type: 'syntax' | 'semantic' | 'schema' | 'context' | 'service_dependency';
      /** @description Human-readable error message */
      message: string;
      /** @description Line number where the error occurred (if applicable) */
      lineNumber?: number;
      /** @description Column number where the error occurred (if applicable) */
      columnNumber?: number;
      /**
       * @description YAML path to the problematic element
       * @example behaviors.morning_startup.actions[0]
       */
      yamlPath?: string | null;
    };
    /** @description Records a validation check failure */
    ValidationFailure: {
      /**
       * Format: date-time
       * @description When the failure was detected
       */
      detectedAt: string;
      /** @description Type of asset affected */
      assetType: components['schemas']['AssetType'];
      /** @description Description of the affected asset */
      assetDescription: string;
      /** @description Type of validation failure */
      failureType: components['schemas']['ValidationFailureType'];
      /**
       * Format: uuid
       * @description Which party deposit is affected
       */
      affectedPartyId: string;
      /** @description Type of the affected party */
      affectedPartyType: components['schemas']['EntityType'];
      /** @description Additional failure details */
      details?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Type of validation failure detected.
     *     - asset_missing: Asset no longer exists in escrow custody
     *     - asset_mutated: Asset properties changed (e.g., item durability)
     *     - asset_expired: Asset has a time-based expiration that triggered
     *     - balance_mismatch: Wallet balance does not match expected held amount
     * @enum {string}
     */
    ValidationFailureType: 'asset_missing' | 'asset_mutated' | 'asset_expired' | 'balance_mismatch';
    /** @description Result of scene validation */
    ValidationResult: {
      /** @description Whether the scene passed all validation checks */
      valid: boolean;
      /** @description Validation errors (severity = error) */
      errors?: components['schemas']['ValidationError'][] | null;
      /** @description Validation warnings (severity = warning) */
      warnings?: components['schemas']['ValidationError'][] | null;
    };
    /** @description A validation rule definition */
    ValidationRule: {
      /** @description Unique rule identifier within the gameId+sceneType */
      ruleId: string;
      /** @description Human-readable description of the rule */
      description: string;
      /** @description Whether violation is an error or warning */
      severity: components['schemas']['ValidationSeverity'];
      /** @description Type of validation check */
      ruleType: components['schemas']['ValidationRuleType'];
      /** @description Rule-specific configuration */
      config?: components['schemas']['ValidationRuleConfig'];
    };
    /** @description Configuration for a validation rule */
    ValidationRuleConfig: {
      /** @description Filter to nodes of this type (for require_tag) */
      nodeType?: string | null;
      /** @description Tag to check for */
      tag?: string | null;
      /** @description Minimum occurrences required */
      minCount?: number | null;
      /** @description Maximum occurrences allowed */
      maxCount?: number | null;
      /** @description JSONPath to required annotation field (for require_annotation) */
      annotationPath?: string | null;
      /** @description Custom validation expression (for custom_expression) */
      expression?: string | null;
    };
    /**
     * @description Type of validation check to perform
     * @enum {string}
     */
    ValidationRuleType:
      | 'require_tag'
      | 'require_node_type'
      | 'forbid_tag'
      | 'require_annotation'
      | 'custom_expression';
    /**
     * @description Severity level of a validation issue
     * @enum {string}
     */
    ValidationSeverity: 'error' | 'warning';
    /** @description A point or direction in 3D space */
    Vector3: {
      /**
       * Format: double
       * @description X coordinate
       */
      x: number;
      /**
       * Format: double
       * @description Y coordinate
       */
      y: number;
      /**
       * Format: double
       * @description Z coordinate
       */
      z: number;
    };
    /** @description Request to verify a condition for conditional escrow */
    VerifyConditionRequest: {
      /**
       * Format: uuid
       * @description Escrow ID
       */
      escrowId: string;
      /** @description Whether the condition was met */
      conditionMet: boolean;
      /**
       * Format: uuid
       * @description Verifier entity ID
       */
      verifierId: string;
      /** @description Verifier entity type */
      verifierType: components['schemas']['EntityType'];
      /** @description Proof/evidence data */
      verificationData?: {
        [key: string]: unknown;
      } | null;
      /** @description Idempotency key */
      idempotencyKey: string;
    };
    /** @description Response from verifying a condition on an escrow */
    VerifyConditionResponse: {
      /** @description Updated escrow agreement */
      escrow: components['schemas']['EscrowAgreement'];
      /** @description Whether this triggered release/refund */
      triggered: boolean;
    };
    /** @description Request to verify data integrity of a save version via hash comparison */
    VerifyIntegrityRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Name of the slot to verify */
      slotName: string;
      /** @description Version to verify (latest if null) */
      versionNumber?: number | null;
    };
    /** @description Result of integrity verification with hash comparison details */
    VerifyIntegrityResponse: {
      /** @description Whether integrity check passed */
      valid: boolean;
      /** @description Version that was verified */
      versionNumber: number;
      /** @description Expected SHA-256 hash */
      expectedHash?: string;
      /** @description Actual hash (null if data unavailable) */
      actualHash?: string | null;
      /** @description Error details if verification failed */
      errorMessage?: string | null;
    };
    /** @description Information about a specific version */
    VersionInfo: {
      /** @description Version string */
      version: string;
      /**
       * Format: date-time
       * @description When this version was created
       */
      createdAt: string;
      /** @description Who created this version */
      createdBy?: string | null;
      /** @description Summary of changes */
      changesSummary?: string | null;
      /** @description Node count at this version */
      nodeCount?: number;
    };
    /** @description Metadata for a single save version including size and checkpoint info */
    VersionResponse: {
      /** @description Version number */
      versionNumber: number;
      /**
       * Format: uuid
       * @description Reference to asset in lib-asset
       */
      assetId?: string;
      /** @description SHA-256 hash */
      contentHash: string;
      /**
       * Format: int64
       * @description Size in bytes
       */
      sizeBytes: number;
      /**
       * Format: int64
       * @description Compressed size if applicable
       */
      compressedSizeBytes?: number;
      /** @description Schema version */
      schemaVersion?: string | null;
      /** @description Human-readable name */
      displayName?: string | null;
      /** @description Whether version is pinned */
      pinned?: boolean;
      /** @description Checkpoint name if pinned */
      checkpointName?: string | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /** @description Custom metadata */
      metadata?: {
        [key: string]: string;
      };
    };
    /** @description Request to apply voice leading to a chord sequence */
    VoiceLeadRequest: {
      /** @description Chord symbols to voice */
      chords: components['schemas']['ChordSymbol'][];
      /** @description Number of voices */
      voiceCount: number;
      /** @description Pitch range per voice (defaults based on voice count) */
      ranges?: components['schemas']['PitchRange'][] | null;
      /** @description Voice leading rules to apply */
      rules?: components['schemas']['VoiceLeadingRules'];
    };
    /** @description Response containing voiced chords */
    VoiceLeadResponse: {
      /** @description Voiced chord realizations */
      voicings: components['schemas']['VoicedChord'][];
      /** @description Voice leading rule violations (warnings) */
      violations?: components['schemas']['VoiceLeadingViolation'][] | null;
    };
    /** @description Rules for voice leading */
    VoiceLeadingRules: {
      /**
       * @description Avoid parallel perfect fifths
       * @default true
       */
      avoidParallelFifths: boolean;
      /**
       * @description Avoid parallel octaves
       * @default true
       */
      avoidParallelOctaves: boolean;
      /**
       * @description Prefer stepwise voice motion
       * @default true
       */
      preferStepwiseMotion: boolean;
      /**
       * @description Avoid voice crossing
       * @default true
       */
      avoidVoiceCrossing: boolean;
      /**
       * @description Maximum leap in semitones
       * @default 7
       */
      maxLeap: number;
    };
    /** @description A voice leading rule violation */
    VoiceLeadingViolation: {
      /** @description Type of violation */
      type: components['schemas']['VoiceLeadingViolationType'];
      /** @description Position in the progression (0-based) */
      position: number;
      /** @description Voice indices involved (0 = bass) */
      voices: number[];
      /** @description Severity (true = error, false = warning) */
      isError: boolean;
      /** @description Human-readable description */
      message: string;
    };
    /**
     * @description Type of voice leading rule violation
     * @enum {string}
     */
    VoiceLeadingViolationType:
      | 'ParallelFifths'
      | 'ParallelOctaves'
      | 'VoiceCrossing'
      | 'VoiceOverlap'
      | 'LargeLeap'
      | 'UnresolvedLeap'
      | 'DoubledLeadingTone';
    /** @description A chord with specific voice pitches */
    VoicedChord: {
      /** @description Original chord symbol */
      symbol: components['schemas']['ChordSymbol'];
      /** @description Pitches from lowest to highest voice */
      pitches: components['schemas']['Pitch'][];
    };
    /**
     * @description Shape of a volume node for spatial bounds
     * @enum {string}
     */
    VolumeShape: 'box' | 'sphere' | 'capsule' | 'cylinder';
    /**
     * @description Type of entity that owns a wallet
     * @enum {string}
     */
    WalletOwnerType: 'account' | 'character' | 'npc' | 'guild' | 'faction' | 'location' | 'system';
    /** @description Wallet details */
    WalletResponse: {
      /**
       * Format: uuid
       * @description Unique wallet identifier
       */
      walletId: string;
      /**
       * Format: uuid
       * @description Owner entity ID
       */
      ownerId: string;
      /** @description Owner type */
      ownerType: components['schemas']['WalletOwnerType'];
      /**
       * Format: uuid
       * @description Realm ID
       */
      realmId?: string | null;
      /** @description Current wallet status */
      status: components['schemas']['WalletStatus'];
      /** @description Reason wallet was frozen */
      frozenReason?: string | null;
      /**
       * Format: date-time
       * @description When wallet was frozen
       */
      frozenAt?: string | null;
      /** @description Who froze the wallet */
      frozenBy?: string | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last transaction timestamp
       */
      lastActivityAt?: string | null;
    };
    /**
     * @description Current status of a wallet
     * @enum {string}
     */
    WalletStatus: 'active' | 'frozen' | 'closed';
    /** @description Wallet with all non-zero balances */
    WalletWithBalancesResponse: {
      /** @description Wallet details */
      wallet: components['schemas']['WalletResponse'];
      /** @description All non-zero balances in this wallet */
      balances: components['schemas']['BalanceSummary'][];
    };
    /**
     * @description How container weight propagates to parent
     * @enum {string}
     */
    WeightContribution: 'none' | 'self_only' | 'self_plus_contents';
    /**
     * @description Precision for weight values (consistent with CurrencyPrecision)
     * @enum {string}
     */
    WeightPrecision: 'integer' | 'decimal_1' | 'decimal_2' | 'decimal_3';
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  updateProfile: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateProfileRequest'];
      };
    };
    responses: {
      /** @description Profile updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AccountResponse'];
        };
      };
      /** @description Account not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updatePasswordHash: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdatePasswordRequest'];
      };
    };
    responses: {
      /** @description Password hash updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Account not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateVerificationStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateVerificationRequest'];
      };
    };
    responses: {
      /** @description Verification status updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Account not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createAchievementDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateAchievementDefinitionRequest'];
      };
    };
    responses: {
      /** @description Achievement created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AchievementDefinitionResponse'];
        };
      };
      /** @description Achievement with this ID already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listAchievementDefinitions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListAchievementDefinitionsRequest'];
      };
    };
    responses: {
      /** @description Achievement definitions retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListAchievementDefinitionsResponse'];
        };
      };
    };
  };
  updateAchievementDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateAchievementDefinitionRequest'];
      };
    };
    responses: {
      /** @description Achievement updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AchievementDefinitionResponse'];
        };
      };
      /** @description Achievement not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteAchievementDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteAchievementDefinitionRequest'];
      };
    };
    responses: {
      /** @description Achievement deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Achievement not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAchievementProgress: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAchievementProgressRequest'];
      };
    };
    responses: {
      /** @description Progress retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AchievementProgressResponse'];
        };
      };
    };
  };
  listUnlockedAchievements: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListUnlockedAchievementsRequest'];
      };
    };
    responses: {
      /** @description Unlocked achievements retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListUnlockedAchievementsResponse'];
        };
      };
    };
  };
  CreateActorTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateActorTemplateRequest'];
      };
    };
    responses: {
      /** @description Template created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorTemplateResponse'];
        };
      };
    };
  };
  UpdateActorTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateActorTemplateRequest'];
      };
    };
    responses: {
      /** @description Template updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorTemplateResponse'];
        };
      };
    };
  };
  DeleteActorTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteActorTemplateRequest'];
      };
    };
    responses: {
      /** @description Template deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteActorTemplateResponse'];
        };
      };
    };
  };
  SpawnActor: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SpawnActorRequest'];
      };
    };
    responses: {
      /** @description Actor spawned successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ActorInstanceResponse'];
        };
      };
    };
  };
  StopActor: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StopActorRequest'];
      };
    };
    responses: {
      /** @description Actor stopped successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StopActorResponse'];
        };
      };
    };
  };
  InjectPerception: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InjectPerceptionRequest'];
      };
    };
    responses: {
      /** @description Perception injected successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InjectPerceptionResponse'];
        };
      };
    };
  };
  StartEncounter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StartEncounterRequest'];
      };
    };
    responses: {
      /** @description Encounter started successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateEncounterPhase: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateEncounterPhaseRequest'];
      };
    };
    responses: {
      /** @description Encounter phase updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateEncounterPhaseResponse'];
        };
      };
    };
  };
  EndEncounter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EndEncounterRequest'];
      };
    };
    responses: {
      /** @description Encounter ended successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EndEncounterResponse'];
        };
      };
    };
  };
  requestUpload: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UploadRequest'];
      };
    };
    responses: {
      /** @description Upload URL generated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UploadResponse'];
        };
      };
      /** @description Invalid request (filename, size, or content_type) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authenticated */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Insufficient permissions */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  completeUpload: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CompleteUploadRequest'];
      };
    };
    responses: {
      /** @description Asset created, processing started */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetMetadata'];
        };
      };
      /** @description Invalid upload_id or missing parts for multipart */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Upload session not found or expired */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAsset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAssetRequest'];
      };
    };
    responses: {
      /** @description Asset metadata with download URL */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetWithDownloadUrl'];
        };
      };
      /** @description Asset not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listAssetVersions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListVersionsRequest'];
      };
    };
    responses: {
      /** @description List of asset versions */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetVersionList'];
        };
      };
      /** @description Asset not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  searchAssets: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AssetSearchRequest'];
      };
    };
    responses: {
      /** @description Matching assets */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetSearchResult'];
        };
      };
    };
  };
  createBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle created immediately (small bundles) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateBundleResponse'];
        };
      };
      /** @description Bundle creation queued (large bundles) */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateBundleResponse'];
        };
      };
      /** @description Invalid asset_ids or bundle_id */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle manifest with download URL */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BundleWithDownloadUrl'];
        };
      };
      /** @description Bundle not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  requestBundleUpload: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BundleUploadRequest'];
      };
    };
    responses: {
      /** @description Upload URL generated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UploadResponse'];
        };
      };
      /** @description Invalid filename or size */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createMetabundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateMetabundleRequest'];
      };
    };
    responses: {
      /** @description Metabundle created or queued for creation */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateMetabundleResponse'];
        };
      };
      /** @description Invalid request or asset conflicts detected */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description One or more source bundles not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Metabundle ID already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getJobStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetJobStatusRequest'];
      };
    };
    responses: {
      /** @description Job status retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetJobStatusResponse'];
        };
      };
      /** @description Job not found or expired */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cancelJob: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CancelJobRequest'];
      };
    };
    responses: {
      /** @description Job cancellation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CancelJobResponse'];
        };
      };
      /** @description Job not found or expired */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Job cannot be cancelled (already completed) */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  resolveBundles: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResolveBundlesRequest'];
      };
    };
    responses: {
      /** @description Resolution complete with download URLs */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ResolveBundlesResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryBundlesByAsset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBundlesByAssetRequest'];
      };
    };
    responses: {
      /** @description Bundles containing the asset */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryBundlesByAssetResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateBundleResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to update this bundle */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle not found or deleted */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteBundleResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to delete this bundle */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  restoreBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RestoreBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle restored successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RestoreBundleResponse'];
        };
      };
      /** @description Invalid request or bundle not in deleted state */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to restore this bundle */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle not found or permanently deleted */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle retention period has expired */
      410: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryBundles: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBundlesRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryBundlesResponse'];
        };
      };
      /** @description Invalid query parameters */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listBundleVersions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListBundleVersionsRequest'];
      };
    };
    responses: {
      /** @description Version history */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListBundleVersionsResponse'];
        };
      };
      /** @description Bundle not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  bulkGetAssets: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BulkGetAssetsRequest'];
      };
    };
    responses: {
      /** @description Asset metadata retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BulkGetAssetsResponse'];
        };
      };
      /** @description Invalid request or too many asset IDs */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  login: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LoginRequest'];
      };
    };
    responses: {
      /** @description Login successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthResponse'];
        };
      };
      /** @description Invalid credentials */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Too many login attempts */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  register: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterRequest'];
      };
    };
    responses: {
      /** @description Registration successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RegisterResponse'];
        };
      };
      /** @description Invalid request data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Username already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  initOAuth: {
    parameters: {
      query: {
        redirectUri: string;
        state?: string;
      };
      header?: never;
      path: {
        provider: components['schemas']['Provider'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Redirect to OAuth provider */
      302: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  completeOAuth: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        provider: components['schemas']['Provider'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OAuthCallbackRequest'];
      };
    };
    responses: {
      /** @description OAuth authentication successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthResponse'];
        };
      };
    };
  };
  verifySteamAuth: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SteamVerifyRequest'];
      };
    };
    responses: {
      /** @description Steam authentication successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthResponse'];
        };
      };
      /** @description Invalid or expired Steam ticket */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Steam API unavailable or internal error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  refreshToken: {
    parameters: {
      query?: never;
      header: {
        /** @description Current JWT access token for refresh */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RefreshRequest'];
      };
    };
    responses: {
      /** @description Token refreshed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthResponse'];
        };
      };
    };
  };
  validateToken: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token for validation */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Token is valid */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateTokenResponse'];
        };
      };
      /** @description Invalid or missing token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Token expired or malformed */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  logout: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token for session identification */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['LogoutRequest'];
      };
    };
    responses: {
      /** @description Logged out successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSessions: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token for session identification */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Active sessions retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SessionsResponse'];
        };
      };
    };
  };
  terminateSession: {
    parameters: {
      query?: never;
      header: {
        /** @description JWT access token for session identification */
        jwt: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TerminateSessionRequest'];
      };
    };
    responses: {
      /** @description Session terminated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  requestPasswordReset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PasswordResetRequest'];
      };
    };
    responses: {
      /** @description Reset email sent if account exists */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  confirmPasswordReset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PasswordResetConfirmRequest'];
      };
    };
    responses: {
      /** @description Password reset successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listProviders: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of available providers */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ProvidersResponse'];
        };
      };
    };
  };
  CompileAbmlBehavior: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        /**
         * @example version: "1.0.0"
         *     metadata:
         *       id: "blacksmith_daily_routine"
         *       category: "profession"
         *       priority: 60
         *       description: "Daily routine for a master blacksmith NPC"
         *
         *     context:
         *       variables:
         *         energy_level: "${npc.stats.energy}"
         *         skill_level: "${npc.skills.blacksmithing}"
         *         shop_reputation: "${npc.reputation.local}"
         *
         *       services:
         *         - name: "crafting_service"
         *           required: true
         *         - name: "economy_service"
         *           required: true
         *
         *     behaviors:
         *       morning_startup:
         *         triggers:
         *           - time_range: "06:00-09:00"
         *           - condition: "${context.energy_level > 0.7}"
         *         actions:
         *           - wake_up:
         *               animation: "stretch_and_yawn"
         *               duration: 3
         *               energy_cost: -0.05
         */
        'application/yaml': string;
        'application/json': components['schemas']['CompileBehaviorRequest'];
      };
    };
    responses: {
      /** @description ABML behavior compiled successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CompileBehaviorResponse'];
        };
      };
      /** @description Invalid ABML definition or compilation error */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden - insufficient permissions */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ValidateAbml: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/yaml': string;
        'application/json': components['schemas']['ValidateAbmlRequest'];
      };
    };
    responses: {
      /** @description Validation completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateAbmlResponse'];
        };
      };
    };
  };
  GetCachedBehavior: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCachedBehaviorRequest'];
      };
    };
    responses: {
      /** @description Cached behavior retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CachedBehaviorResponse'];
        };
      };
      /** @description Behavior not found in cache */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  InvalidateCachedBehavior: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InvalidateCacheRequest'];
      };
    };
    responses: {
      /** @description Cache invalidated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Behavior not found in cache */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GenerateGoapPlan: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GoapPlanRequest'];
      };
    };
    responses: {
      /** @description Plan generated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GoapPlanResponse'];
        };
      };
      /** @description Invalid request or planning failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ValidateGoapPlan: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidateGoapPlanRequest'];
      };
    };
    responses: {
      /** @description Plan validation completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateGoapPlanResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCharacterRequest'];
      };
    };
    responses: {
      /** @description Character retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterResponse'];
        };
      };
      /** @description Character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listCharacters: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListCharactersRequest'];
      };
    };
    responses: {
      /** @description Characters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterListResponse'];
        };
      };
    };
  };
  getEnrichedCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEnrichedCharacterRequest'];
      };
    };
    responses: {
      /** @description Character retrieved with requested includes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EnrichedCharacterResponse'];
        };
      };
      /** @description Character not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCharacterArchive: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCharacterArchiveRequest'];
      };
    };
    responses: {
      /** @description Archive retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterArchive'];
        };
      };
      /** @description Archive not found (character may not be compressed yet) */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCharactersByRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCharactersByRealmRequest'];
      };
    };
    responses: {
      /** @description Characters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterListResponse'];
        };
      };
    };
  };
  getEncounterType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEncounterTypeRequest'];
      };
    };
    responses: {
      /** @description Encounter type retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterTypeResponse'];
        };
      };
      /** @description Encounter type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listEncounterTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListEncounterTypesRequest'];
      };
    };
    responses: {
      /** @description Encounter types retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterTypeListResponse'];
        };
      };
    };
  };
  queryByCharacter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryByCharacterRequest'];
      };
    };
    responses: {
      /** @description Encounters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterListResponse'];
        };
      };
    };
  };
  queryBetween: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBetweenRequest'];
      };
    };
    responses: {
      /** @description Encounters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterListResponse'];
        };
      };
    };
  };
  queryByLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryByLocationRequest'];
      };
    };
    responses: {
      /** @description Encounters retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EncounterListResponse'];
        };
      };
    };
  };
  hasMet: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HasMetRequest'];
      };
    };
    responses: {
      /** @description Check completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HasMetResponse'];
        };
      };
    };
  };
  getSentiment: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSentimentRequest'];
      };
    };
    responses: {
      /** @description Sentiment calculated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SentimentResponse'];
        };
      };
    };
  };
  getPerspective: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetPerspectiveRequest'];
      };
    };
    responses: {
      /** @description Perspective retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PerspectiveResponse'];
        };
      };
      /** @description Perspective not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getParticipation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetParticipationRequest'];
      };
    };
    responses: {
      /** @description Participation records retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ParticipationListResponse'];
        };
      };
    };
  };
  getEventParticipants: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEventParticipantsRequest'];
      };
    };
    responses: {
      /** @description Participants retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ParticipationListResponse'];
        };
      };
    };
  };
  getBackstory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBackstoryRequest'];
      };
    };
    responses: {
      /** @description Backstory retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BackstoryResponse'];
        };
      };
      /** @description No backstory defined for this character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getPersonality: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetPersonalityRequest'];
      };
    };
    responses: {
      /** @description Personality retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PersonalityResponse'];
        };
      };
      /** @description No personality defined for this character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCombatPreferences: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCombatPreferencesRequest'];
      };
    };
    responses: {
      /** @description Combat preferences retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CombatPreferencesResponse'];
        };
      };
      /** @description No combat preferences defined for this character */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getClientCapabilities: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetClientCapabilitiesRequest'];
      };
    };
    responses: {
      /** @description Client capabilities retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClientCapabilitiesResponse'];
        };
      };
      /** @description Not authenticated - requires valid session */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error retrieving capabilities */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getContractTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetContractTemplateRequest'];
      };
    };
    responses: {
      /** @description Template retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractTemplateResponse'];
        };
      };
      /** @description Neither templateId nor code provided */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listContractTemplates: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListContractTemplatesRequest'];
      };
    };
    responses: {
      /** @description Templates retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListContractTemplatesResponse'];
        };
      };
    };
  };
  createContractInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateContractInstanceRequest'];
      };
    };
    responses: {
      /** @description Instance created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractInstanceResponse'];
        };
      };
      /** @description Invalid request (missing required parties, invalid terms) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  proposeContractInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ProposeContractInstanceRequest'];
      };
    };
    responses: {
      /** @description Contract proposed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractInstanceResponse'];
        };
      };
      /** @description Contract not in draft status */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  consentToContract: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConsentToContractRequest'];
      };
    };
    responses: {
      /** @description Consent recorded successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractInstanceResponse'];
        };
      };
      /** @description Party not part of this contract or already consented */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getContractInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetContractInstanceRequest'];
      };
    };
    responses: {
      /** @description Instance retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractInstanceResponse'];
        };
      };
      /** @description Instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryContractInstances: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryContractInstancesRequest'];
      };
    };
    responses: {
      /** @description Instances retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryContractInstancesResponse'];
        };
      };
      /** @description No filter criteria provided */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  terminateContractInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TerminateContractInstanceRequest'];
      };
    };
    responses: {
      /** @description Termination processed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractInstanceResponse'];
        };
      };
      /** @description Contract cannot be terminated (policy violation) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getContractInstanceStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetContractInstanceStatusRequest'];
      };
    };
    responses: {
      /** @description Status retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractInstanceStatusResponse'];
        };
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  completeMilestone: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CompleteMilestoneRequest'];
      };
    };
    responses: {
      /** @description Milestone completed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MilestoneResponse'];
        };
      };
      /** @description Milestone not in valid state for completion */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract or milestone not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  failMilestone: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FailMilestoneRequest'];
      };
    };
    responses: {
      /** @description Milestone failure recorded */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MilestoneResponse'];
        };
      };
      /** @description Milestone not in valid state for failure */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract or milestone not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getMilestone: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetMilestoneRequest'];
      };
    };
    responses: {
      /** @description Milestone retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MilestoneResponse'];
        };
      };
      /** @description Contract or milestone not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  reportBreach: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReportBreachRequest'];
      };
    };
    responses: {
      /** @description Breach reported successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BreachResponse'];
        };
      };
      /** @description Invalid breach report */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cureBreach: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CureBreachRequest'];
      };
    };
    responses: {
      /** @description Breach cured successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BreachResponse'];
        };
      };
      /** @description Breach not in curable state */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Breach not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBreach: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBreachRequest'];
      };
    };
    responses: {
      /** @description Breach retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BreachResponse'];
        };
      };
      /** @description Breach not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateContractMetadata: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateContractMetadataRequest'];
      };
    };
    responses: {
      /** @description Metadata updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractMetadataResponse'];
        };
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getContractMetadata: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetContractMetadataRequest'];
      };
    };
    responses: {
      /** @description Metadata retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContractMetadataResponse'];
        };
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  checkContractConstraint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckConstraintRequest'];
      };
    };
    responses: {
      /** @description Constraint check completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CheckConstraintResponse'];
        };
      };
    };
  };
  queryActiveContracts: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryActiveContractsRequest'];
      };
    };
    responses: {
      /** @description Active contracts retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryActiveContractsResponse'];
        };
      };
    };
  };
  lockContract: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LockContractRequest'];
      };
    };
    responses: {
      /** @description Contract locked successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LockContractResponse'];
        };
      };
      /** @description Contract not transferable */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract already locked */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  unlockContract: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnlockContractRequest'];
      };
    };
    responses: {
      /** @description Contract unlocked successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UnlockContractResponse'];
        };
      };
      /** @description Not the current guardian */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found or not locked */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  transferContractParty: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransferContractPartyRequest'];
      };
    };
    responses: {
      /** @description Party transferred successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TransferContractPartyResponse'];
        };
      };
      /** @description Party not found in contract */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not the current guardian or contract not locked */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listClauseTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListClauseTypesRequest'];
      };
    };
    responses: {
      /** @description Clause types listed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListClauseTypesResponse'];
        };
      };
    };
  };
  setContractTemplateValues: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SetTemplateValuesRequest'];
      };
    };
    responses: {
      /** @description Template values set successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SetTemplateValuesResponse'];
        };
      };
      /** @description Invalid template key format */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  checkAssetRequirements: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckAssetRequirementsRequest'];
      };
    };
    responses: {
      /** @description Asset requirements checked */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CheckAssetRequirementsResponse'];
        };
      };
      /** @description Template values not set */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  executeContract: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExecuteContractRequest'];
      };
    };
    responses: {
      /** @description Contract executed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExecuteContractResponse'];
        };
      };
      /** @description Contract not in fulfilled status or template values missing */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Contract not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getCurrencyDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetCurrencyDefinitionRequest'];
      };
    };
    responses: {
      /** @description Currency definition retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CurrencyDefinitionResponse'];
        };
      };
      /** @description Neither definitionId nor code provided */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Currency definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listCurrencyDefinitions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListCurrencyDefinitionsRequest'];
      };
    };
    responses: {
      /** @description Currency definitions retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListCurrencyDefinitionsResponse'];
        };
      };
    };
  };
  createWallet: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateWalletRequest'];
      };
    };
    responses: {
      /** @description Wallet created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WalletResponse'];
        };
      };
      /** @description Wallet already exists for this owner/realm */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getWallet: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetWalletRequest'];
      };
    };
    responses: {
      /** @description Wallet retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WalletWithBalancesResponse'];
        };
      };
      /** @description Wallet not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getOrCreateWallet: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetOrCreateWalletRequest'];
      };
    };
    responses: {
      /** @description Wallet retrieved or created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetOrCreateWalletResponse'];
        };
      };
    };
  };
  getBalance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBalanceRequest'];
      };
    };
    responses: {
      /** @description Balance retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetBalanceResponse'];
        };
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  batchGetBalances: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BatchGetBalancesRequest'];
      };
    };
    responses: {
      /** @description Balances retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BatchGetBalancesResponse'];
        };
      };
    };
  };
  creditCurrency: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreditCurrencyRequest'];
      };
    };
    responses: {
      /** @description Currency credited successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreditCurrencyResponse'];
        };
      };
      /** @description Invalid transaction type or amount */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Idempotency key already used */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Earn cap or supply cap exceeded */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  debitCurrency: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DebitCurrencyRequest'];
      };
    };
    responses: {
      /** @description Currency debited successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DebitCurrencyResponse'];
        };
      };
      /** @description Invalid transaction type or amount */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Insufficient funds */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  transferCurrency: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransferCurrencyRequest'];
      };
    };
    responses: {
      /** @description Transfer completed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TransferCurrencyResponse'];
        };
      };
      /** @description Invalid request or currency not transferable */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Insufficient funds or cross-realm not allowed */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  batchCreditCurrency: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BatchCreditRequest'];
      };
    };
    responses: {
      /** @description Batch credit processed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BatchCreditResponse'];
        };
      };
    };
  };
  calculateConversion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CalculateConversionRequest'];
      };
    };
    responses: {
      /** @description Conversion calculated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CalculateConversionResponse'];
        };
      };
      /** @description Currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description No base currency or missing exchange rate */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  executeConversion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExecuteConversionRequest'];
      };
    };
    responses: {
      /** @description Conversion executed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExecuteConversionResponse'];
        };
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Insufficient funds or missing exchange rate */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getExchangeRate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetExchangeRateRequest'];
      };
    };
    responses: {
      /** @description Exchange rate retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetExchangeRateResponse'];
        };
      };
      /** @description Currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description No base currency or missing exchange rate */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTransaction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetTransactionRequest'];
      };
    };
    responses: {
      /** @description Transaction retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TransactionResponse'];
        };
      };
      /** @description Transaction not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTransactionHistory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetTransactionHistoryRequest'];
      };
    };
    responses: {
      /** @description Transaction history retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetTransactionHistoryResponse'];
        };
      };
      /** @description Wallet not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTransactionsByReference: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetTransactionsByReferenceRequest'];
      };
    };
    responses: {
      /** @description Transactions retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetTransactionsByReferenceResponse'];
        };
      };
    };
  };
  getGlobalSupply: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetGlobalSupplyRequest'];
      };
    };
    responses: {
      /** @description Supply statistics retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetGlobalSupplyResponse'];
        };
      };
      /** @description Currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  escrowDeposit: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EscrowDepositRequest'];
      };
    };
    responses: {
      /** @description Escrow deposit processed (wallet debited) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EscrowDepositResponse'];
        };
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Insufficient funds or wallet frozen */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  escrowRelease: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EscrowReleaseRequest'];
      };
    };
    responses: {
      /** @description Escrow release processed (recipient credited) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EscrowReleaseResponse'];
        };
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  escrowRefund: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EscrowRefundRequest'];
      };
    };
    responses: {
      /** @description Escrow refund processed (depositor credited) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EscrowRefundResponse'];
        };
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createHold: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateHoldRequest'];
      };
    };
    responses: {
      /** @description Hold created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HoldResponse'];
        };
      };
      /** @description Wallet or currency not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Insufficient effective balance for hold */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  captureHold: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CaptureHoldRequest'];
      };
    };
    responses: {
      /** @description Hold captured successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CaptureHoldResponse'];
        };
      };
      /** @description Hold is not in active status or capture amount exceeds hold */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Hold not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  releaseHold: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReleaseHoldRequest'];
      };
    };
    responses: {
      /** @description Hold released successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HoldResponse'];
        };
      };
      /** @description Hold is not in active status */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Hold not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getHold: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetHoldRequest'];
      };
    };
    responses: {
      /** @description Hold retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HoldResponse'];
        };
      };
      /** @description Hold not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryDocumentation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryDocumentationRequest'];
      };
    };
    responses: {
      /** @description Search results with voice-friendly summaries */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryDocumentationResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDocument: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetDocumentRequest'];
      };
    };
    responses: {
      /** @description Document content */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetDocumentResponse'];
        };
      };
      /** @description Document not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  searchDocumentation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SearchDocumentationRequest'];
      };
    };
    responses: {
      /** @description Matching documents */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SearchDocumentationResponse'];
        };
      };
    };
  };
  listDocuments: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListDocumentsRequest'];
      };
    };
    responses: {
      /** @description Document list */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListDocumentsResponse'];
        };
      };
    };
  };
  suggestRelatedTopics: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SuggestRelatedRequest'];
      };
    };
    responses: {
      /** @description Related topics */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SuggestRelatedResponse'];
        };
      };
    };
  };
  bindRepository: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BindRepositoryRequest'];
      };
    };
    responses: {
      /** @description Repository binding created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BindRepositoryResponse'];
        };
      };
      /** @description Invalid request (malformed URL, invalid branch) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Namespace already bound to a repository */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  syncRepository: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SyncRepositoryRequest'];
      };
    };
    responses: {
      /** @description Sync completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SyncRepositoryResponse'];
        };
      };
      /** @description No binding found for namespace */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Sync already in progress */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRepositoryStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RepositoryStatusRequest'];
      };
    };
    responses: {
      /** @description Repository binding status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RepositoryStatusResponse'];
        };
      };
      /** @description No binding found for namespace */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRepositoryBindings: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRepositoryBindingsRequest'];
      };
    };
    responses: {
      /** @description List of repository bindings */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListRepositoryBindingsResponse'];
        };
      };
    };
  };
  updateRepositoryBinding: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateRepositoryBindingRequest'];
      };
    };
    responses: {
      /** @description Repository binding updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateRepositoryBindingResponse'];
        };
      };
      /** @description No binding found for namespace */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createDocumentationArchive: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateArchiveRequest'];
      };
    };
    responses: {
      /** @description Archive created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateArchiveResponse'];
        };
      };
      /** @description Namespace not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listDocumentationArchives: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListArchivesRequest'];
      };
    };
    responses: {
      /** @description List of archives */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListArchivesResponse'];
        };
      };
    };
  };
  createEscrow: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateEscrowRequest'];
      };
    };
    responses: {
      /** @description Escrow created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateEscrowResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  getEscrow: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEscrowRequest'];
      };
    };
    responses: {
      /** @description Escrow details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetEscrowResponse'];
        };
      };
      /** @description Escrow not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  listEscrows: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListEscrowsRequest'];
      };
    };
    responses: {
      /** @description List of escrows */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListEscrowsResponse'];
        };
      };
    };
  };
  deposit: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DepositRequest'];
      };
    };
    responses: {
      /** @description Deposit successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DepositResponse'];
        };
      };
      /** @description Deposit failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  validateDeposit: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidateDepositRequest'];
      };
    };
    responses: {
      /** @description Validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateDepositResponse'];
        };
      };
    };
  };
  getDepositStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetDepositStatusRequest'];
      };
    };
    responses: {
      /** @description Deposit status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetDepositStatusResponse'];
        };
      };
    };
  };
  recordConsent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConsentRequest'];
      };
    };
    responses: {
      /** @description Consent recorded */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ConsentResponse'];
        };
      };
      /** @description Consent failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  getConsentStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetConsentStatusRequest'];
      };
    };
    responses: {
      /** @description Consent status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetConsentStatusResponse'];
        };
      };
    };
  };
  release: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReleaseRequest'];
      };
    };
    responses: {
      /** @description Release result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReleaseResponse'];
        };
      };
      /** @description Release failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  refund: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RefundRequest'];
      };
    };
    responses: {
      /** @description Refund result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RefundResponse'];
        };
      };
      /** @description Refund failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  cancel: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CancelRequest'];
      };
    };
    responses: {
      /** @description Cancel result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CancelResponse'];
        };
      };
      /** @description Cancel failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  dispute: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DisputeRequest'];
      };
    };
    responses: {
      /** @description Dispute raised */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DisputeResponse'];
        };
      };
      /** @description Dispute failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  resolve: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResolveRequest'];
      };
    };
    responses: {
      /** @description Resolution result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ResolveResponse'];
        };
      };
      /** @description Resolution failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  verifyCondition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VerifyConditionRequest'];
      };
    };
    responses: {
      /** @description Verification result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifyConditionResponse'];
        };
      };
      /** @description Verification failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  reaffirm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReaffirmRequest'];
      };
    };
    responses: {
      /** @description Reaffirmation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReaffirmResponse'];
        };
      };
      /** @description Reaffirmation failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  listServices: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListServicesRequest'];
      };
    };
    responses: {
      /** @description Services retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListServicesResponse'];
        };
      };
    };
  };
  getService: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetServiceRequest'];
      };
    };
    responses: {
      /** @description Service retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ServiceInfo'];
        };
      };
      /** @description Service not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getGameSession: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetGameSessionRequest'];
      };
    };
    responses: {
      /** @description Game session retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GameSessionResponse'];
        };
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  leaveGameSession: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveGameSessionRequest'];
      };
    };
    responses: {
      /** @description Successfully left game session */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  sendChatMessage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ChatMessageRequest'];
      };
    };
    responses: {
      /** @description Chat message sent successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  performGameAction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GameActionRequest'];
      };
    };
    responses: {
      /** @description Game action performed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GameActionResponse'];
        };
      };
      /** @description Invalid game action */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  leaveGameSessionById: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveGameSessionByIdRequest'];
      };
    };
    responses: {
      /** @description Successfully left game session */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Game session not found or player not in session */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createContainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateContainerRequest'];
      };
    };
    responses: {
      /** @description Container created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContainerResponse'];
        };
      };
      /** @description Invalid request (validation error) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getContainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetContainerRequest'];
      };
    };
    responses: {
      /** @description Container retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContainerWithContentsResponse'];
        };
      };
      /** @description Container not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getOrCreateContainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetOrCreateContainerRequest'];
      };
    };
    responses: {
      /** @description Container retrieved or created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContainerResponse'];
        };
      };
    };
  };
  listContainers: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListContainersRequest'];
      };
    };
    responses: {
      /** @description Containers retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListContainersResponse'];
        };
      };
    };
  };
  updateContainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateContainerRequest'];
      };
    };
    responses: {
      /** @description Container updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContainerResponse'];
        };
      };
      /** @description Container not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  addItemToContainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AddItemRequest'];
      };
    };
    responses: {
      /** @description Item added successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AddItemResponse'];
        };
      };
      /** @description Constraint violation (full, overweight, wrong category) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Container or item not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  removeItemFromContainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RemoveItemRequest'];
      };
    };
    responses: {
      /** @description Item removed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RemoveItemResponse'];
        };
      };
      /** @description Item not found in specified container */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  moveItem: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MoveItemRequest'];
      };
    };
    responses: {
      /** @description Item moved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MoveItemResponse'];
        };
      };
      /** @description Constraint violation at destination */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item or container not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  transferItem: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransferItemRequest'];
      };
    };
    responses: {
      /** @description Item transferred successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TransferItemResponse'];
        };
      };
      /** @description Item is bound or not tradeable */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item or container not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  splitStack: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SplitStackRequest'];
      };
    };
    responses: {
      /** @description Stack split successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SplitStackResponse'];
        };
      };
      /** @description Cannot split unique items or invalid quantity */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  mergeStacks: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MergeStacksRequest'];
      };
    };
    responses: {
      /** @description Stacks merged successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MergeStacksResponse'];
        };
      };
      /** @description Items are not the same template or target would exceed max stack */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryItems: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryItemsRequest'];
      };
    };
    responses: {
      /** @description Items found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryItemsResponse'];
        };
      };
    };
  };
  countItems: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CountItemsRequest'];
      };
    };
    responses: {
      /** @description Count completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CountItemsResponse'];
        };
      };
    };
  };
  hasItems: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HasItemsRequest'];
      };
    };
    responses: {
      /** @description Check completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HasItemsResponse'];
        };
      };
    };
  };
  findSpace: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FindSpaceRequest'];
      };
    };
    responses: {
      /** @description Space search completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FindSpaceResponse'];
        };
      };
    };
  };
  createItemTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateItemTemplateRequest'];
      };
    };
    responses: {
      /** @description Item template created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ItemTemplateResponse'];
        };
      };
      /** @description Invalid request (validation error) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Code already exists for this gameId */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getItemTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetItemTemplateRequest'];
      };
    };
    responses: {
      /** @description Item template retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ItemTemplateResponse'];
        };
      };
      /** @description Neither templateId nor code+gameId provided */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listItemTemplates: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListItemTemplatesRequest'];
      };
    };
    responses: {
      /** @description Item templates retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListItemTemplatesResponse'];
        };
      };
    };
  };
  updateItemTemplate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateItemTemplateRequest'];
      };
    };
    responses: {
      /** @description Item template updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ItemTemplateResponse'];
        };
      };
      /** @description Attempted to change immutable field */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createItemInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateItemInstanceRequest'];
      };
    };
    responses: {
      /** @description Item instance created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ItemInstanceResponse'];
        };
      };
      /** @description Invalid request (validation error) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Template not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Template is deprecated */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getItemInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetItemInstanceRequest'];
      };
    };
    responses: {
      /** @description Item instance retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ItemInstanceResponse'];
        };
      };
      /** @description Item instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  modifyItemInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ModifyItemInstanceRequest'];
      };
    };
    responses: {
      /** @description Item instance modified successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ItemInstanceResponse'];
        };
      };
      /** @description Invalid modification (e.g., negative durability) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item is corrupted/mirrored and cannot be modified */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  bindItemInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BindItemInstanceRequest'];
      };
    };
    responses: {
      /** @description Item instance bound successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ItemInstanceResponse'];
        };
      };
      /** @description Item cannot be bound (template doesn't allow binding) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item already bound */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  destroyItemInstance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DestroyItemInstanceRequest'];
      };
    };
    responses: {
      /** @description Item instance destroyed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DestroyItemInstanceResponse'];
        };
      };
      /** @description Item instance not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Item is bound and cannot be destroyed */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listItemsByContainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListItemsByContainerRequest'];
      };
    };
    responses: {
      /** @description Items retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListItemsResponse'];
        };
      };
    };
  };
  batchGetItemInstances: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BatchGetItemInstancesRequest'];
      };
    };
    responses: {
      /** @description Items retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BatchGetItemInstancesResponse'];
        };
      };
    };
  };
  createLeaderboardDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateLeaderboardDefinitionRequest'];
      };
    };
    responses: {
      /** @description Leaderboard created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeaderboardDefinitionResponse'];
        };
      };
      /** @description Leaderboard with this ID already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateLeaderboardDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateLeaderboardDefinitionRequest'];
      };
    };
    responses: {
      /** @description Leaderboard updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeaderboardDefinitionResponse'];
        };
      };
      /** @description Leaderboard not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteLeaderboardDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteLeaderboardDefinitionRequest'];
      };
    };
    responses: {
      /** @description Leaderboard deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Leaderboard not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getEntityRank: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEntityRankRequest'];
      };
    };
    responses: {
      /** @description Rank retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EntityRankResponse'];
        };
      };
      /** @description Entity not found on leaderboard */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTopRanks: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetTopRanksRequest'];
      };
    };
    responses: {
      /** @description Top ranks retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeaderboardEntriesResponse'];
        };
      };
    };
  };
  getRanksAround: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRanksAroundRequest'];
      };
    };
    responses: {
      /** @description Ranks retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LeaderboardEntriesResponse'];
        };
      };
      /** @description Entity not found on leaderboard */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSeason: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSeasonRequest'];
      };
    };
    responses: {
      /** @description Season info retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeasonResponse'];
        };
      };
      /** @description Season not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationRequest'];
      };
    };
    responses: {
      /** @description Location retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getLocationByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationByCodeRequest'];
      };
    };
    responses: {
      /** @description Location retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listLocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListLocationsRequest'];
      };
    };
    responses: {
      /** @description Locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
    };
  };
  listLocationsByRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListLocationsByRealmRequest'];
      };
    };
    responses: {
      /** @description Locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
    };
  };
  listLocationsByParent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListLocationsByParentRequest'];
      };
    };
    responses: {
      /** @description Child locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
      /** @description Parent location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRootLocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRootLocationsRequest'];
      };
    };
    responses: {
      /** @description Root locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
    };
  };
  getLocationAncestors: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationAncestorsRequest'];
      };
    };
    responses: {
      /** @description Ancestors retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getLocationDescendants: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationDescendantsRequest'];
      };
    };
    responses: {
      /** @description Descendants retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  locationExists: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LocationExistsRequest'];
      };
    };
    responses: {
      /** @description Validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationExistsResponse'];
        };
      };
    };
  };
  requestSnapshot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RequestSnapshotRequest'];
      };
    };
    responses: {
      /** @description Snapshot returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RequestSnapshotResponse'];
        };
      };
      /** @description Region not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryPoint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryPointRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryPointResponse'];
        };
      };
    };
  };
  queryBounds: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBoundsRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryBoundsResponse'];
        };
      };
    };
  };
  queryObjectsByType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryObjectsByTypeRequest'];
      };
    };
    responses: {
      /** @description Matching objects */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryObjectsByTypeResponse'];
        };
      };
    };
  };
  queryAffordance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AffordanceQueryRequest'];
      };
    };
    responses: {
      /** @description Scored locations */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AffordanceQueryResponse'];
        };
      };
    };
  };
  checkoutForAuthoring: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthoringCheckoutRequest'];
      };
    };
    responses: {
      /** @description Checkout successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthoringCheckoutResponse'];
        };
      };
      /** @description Already checked out by another editor */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  commitAuthoring: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthoringCommitRequest'];
      };
    };
    responses: {
      /** @description Changes committed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthoringCommitResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  releaseAuthoring: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthoringReleaseRequest'];
      };
    };
    responses: {
      /** @description Checkout released */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthoringReleaseResponse'];
        };
      };
    };
  };
  createDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateDefinitionRequest'];
      };
    };
    responses: {
      /** @description Definition created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MapDefinition'];
        };
      };
      /** @description Definition with this name already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetDefinitionRequest'];
      };
    };
    responses: {
      /** @description Definition found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MapDefinition'];
        };
      };
      /** @description Definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listDefinitions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListDefinitionsRequest'];
      };
    };
    responses: {
      /** @description Definitions list */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListDefinitionsResponse'];
        };
      };
    };
  };
  updateDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateDefinitionRequest'];
      };
    };
    responses: {
      /** @description Definition updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MapDefinition'];
        };
      };
      /** @description Definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listQueues: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListQueuesRequest'];
      };
    };
    responses: {
      /** @description Queues retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListQueuesResponse'];
        };
      };
    };
  };
  getQueue: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetQueueRequest'];
      };
    };
    responses: {
      /** @description Queue details retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueueResponse'];
        };
      };
      /** @description Queue not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  joinMatchmaking: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['JoinMatchmakingRequest'];
      };
    };
    responses: {
      /** @description Successfully joined matchmaking queue */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['JoinMatchmakingResponse'];
        };
      };
      /** @description Invalid query syntax or properties */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Already in queue, queue limit reached, or exclusive group conflict */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  leaveMatchmaking: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveMatchmakingRequest'];
      };
    };
    responses: {
      /** @description Successfully left matchmaking queue */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Ticket not found or not in queue */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getMatchmakingStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetMatchmakingStatusRequest'];
      };
    };
    responses: {
      /** @description Status retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MatchmakingStatusResponse'];
        };
      };
      /** @description No active matchmaking ticket */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  acceptMatch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AcceptMatchRequest'];
      };
    };
    responses: {
      /** @description Match acceptance recorded */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AcceptMatchResponse'];
        };
      };
      /** @description No pending match or already processed */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  declineMatch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeclineMatchRequest'];
      };
    };
    responses: {
      /** @description Match declined */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description No pending match or already processed */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getMatchmakingStats: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetMatchmakingStatsRequest'];
      };
    };
    responses: {
      /** @description Statistics retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MatchmakingStatsResponse'];
        };
      };
    };
  };
  GenerateComposition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateCompositionRequest'];
      };
    };
    responses: {
      /** @description Composition generated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateCompositionResponse'];
        };
      };
      /** @description Invalid request or generation constraints */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Style not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ValidateMidiJson: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidateMidiJsonRequest'];
      };
    };
    responses: {
      /** @description Validation completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidateMidiJsonResponse'];
        };
      };
    };
  };
  GetStyle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetStyleRequest'];
      };
    };
    responses: {
      /** @description Style retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StyleDefinitionResponse'];
        };
      };
      /** @description Style not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListStyles: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListStylesRequest'];
      };
    };
    responses: {
      /** @description Styles listed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListStylesResponse'];
        };
      };
    };
  };
  GenerateProgression: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateProgressionRequest'];
      };
    };
    responses: {
      /** @description Progression generated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateProgressionResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GenerateMelody: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateMelodyRequest'];
      };
    };
    responses: {
      /** @description Melody generated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerateMelodyResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ApplyVoiceLeading: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VoiceLeadRequest'];
      };
    };
    responses: {
      /** @description Voice leading applied successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VoiceLeadResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmRequest'];
      };
    };
    responses: {
      /** @description Realm retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmResponse'];
        };
      };
      /** @description Realm not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRealmByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmByCodeRequest'];
      };
    };
    responses: {
      /** @description Realm retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmResponse'];
        };
      };
      /** @description Realm not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRealms: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRealmsRequest'];
      };
    };
    responses: {
      /** @description Realms retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmListResponse'];
        };
      };
    };
  };
  realmExists: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RealmExistsRequest'];
      };
    };
    responses: {
      /** @description Validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmExistsResponse'];
        };
      };
    };
  };
  getRealmParticipation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmParticipationRequest'];
      };
    };
    responses: {
      /** @description Participation records retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmParticipationListResponse'];
        };
      };
    };
  };
  getRealmEventParticipants: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmEventParticipantsRequest'];
      };
    };
    responses: {
      /** @description Participants retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmParticipationListResponse'];
        };
      };
    };
  };
  getRealmLore: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRealmLoreRequest'];
      };
    };
    responses: {
      /** @description Lore retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RealmLoreResponse'];
        };
      };
      /** @description No lore defined for this realm */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRelationship: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipRequest'];
      };
    };
    responses: {
      /** @description Relationship retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipResponse'];
        };
      };
      /** @description Relationship not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRelationshipsByEntity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRelationshipsByEntityRequest'];
      };
    };
    responses: {
      /** @description Relationships retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipListResponse'];
        };
      };
    };
  };
  getRelationshipsBetween: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipsBetweenRequest'];
      };
    };
    responses: {
      /** @description Relationships retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipListResponse'];
        };
      };
    };
  };
  listRelationshipsByType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRelationshipsByTypeRequest'];
      };
    };
    responses: {
      /** @description Relationships retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipListResponse'];
        };
      };
    };
  };
  getRelationshipType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipTypeRequest'];
      };
    };
    responses: {
      /** @description Relationship type retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeResponse'];
        };
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRelationshipTypeByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipTypeByCodeRequest'];
      };
    };
    responses: {
      /** @description Relationship type retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeResponse'];
        };
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRelationshipTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRelationshipTypesRequest'];
      };
    };
    responses: {
      /** @description Relationship types retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeListResponse'];
        };
      };
    };
  };
  getChildRelationshipTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetChildRelationshipTypesRequest'];
      };
    };
    responses: {
      /** @description Child relationship types retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeListResponse'];
        };
      };
      /** @description Parent relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  matchesHierarchy: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MatchesHierarchyRequest'];
      };
    };
    responses: {
      /** @description Hierarchy match result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MatchesHierarchyResponse'];
        };
      };
      /** @description One or both relationship types not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAncestors: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAncestorsRequest'];
      };
    };
    responses: {
      /** @description Ancestors retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipTypeListResponse'];
        };
      };
      /** @description Relationship type not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSlotRequest'];
      };
    };
    responses: {
      /** @description Slot created or updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SlotResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Slot already exists with different owner */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSlotRequest'];
      };
    };
    responses: {
      /** @description Slot found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SlotResponse'];
        };
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListSlots: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSlotsRequest'];
      };
    };
    responses: {
      /** @description Slots listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListSlotsResponse'];
        };
      };
    };
  };
  DeleteSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteSlotRequest'];
      };
    };
    responses: {
      /** @description Slot deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteSlotResponse'];
        };
      };
      /** @description Not authorized to delete this slot */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  RenameSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RenameSlotRequest'];
      };
    };
    responses: {
      /** @description Slot renamed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SlotResponse'];
        };
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Target name already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  Save: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SaveRequest'];
      };
    };
    responses: {
      /** @description Save successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Invalid request or data validation failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to save to this slot */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Save data exceeds maximum size limit */
      413: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  Load: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LoadRequest'];
      };
    };
    responses: {
      /** @description Load successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LoadResponse'];
        };
      };
      /** @description Not authorized to load from this slot */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  SaveDelta: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SaveDeltaRequest'];
      };
    };
    responses: {
      /** @description Delta save successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveDeltaResponse'];
        };
      };
      /** @description Invalid delta or base version not found */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Base version has been deleted (cannot apply delta) */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Delta too large (consider full save instead) */
      413: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  LoadWithDeltas: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LoadRequest'];
      };
    };
    responses: {
      /** @description Load successful (reconstructed if delta) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LoadResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Delta chain broken (base version missing) */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CollapseDeltas: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CollapseDeltasRequest'];
      };
    };
    responses: {
      /** @description Delta chain collapsed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListVersions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListVersionsRequest'];
      };
    };
    responses: {
      /** @description Versions listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListVersionsResponse'];
        };
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PinVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PinVersionRequest'];
      };
    };
    responses: {
      /** @description Version pinned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VersionResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UnpinVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnpinVersionRequest'];
      };
    };
    responses: {
      /** @description Version unpinned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VersionResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteVersionRequest'];
      };
    };
    responses: {
      /** @description Version deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteVersionResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cannot delete pinned version */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  QuerySaves: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QuerySavesRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QuerySavesResponse'];
        };
      };
    };
  };
  CopySave: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CopySaveRequest'];
      };
    };
    responses: {
      /** @description Save copied */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Not authorized to copy to target */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Source slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ExportSaves: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExportSavesRequest'];
      };
    };
    responses: {
      /** @description Export prepared */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExportSavesResponse'];
        };
      };
    };
  };
  VerifyIntegrity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VerifyIntegrityRequest'];
      };
    };
    responses: {
      /** @description Verification result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifyIntegrityResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PromoteVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PromoteVersionRequest'];
      };
    };
    responses: {
      /** @description Version promoted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  MigrateSave: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MigrateSaveRequest'];
      };
    };
    responses: {
      /** @description Migration successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MigrateSaveResponse'];
        };
      };
      /** @description Migration failed or no path exists */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Save not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  RegisterSchema: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterSchemaRequest'];
      };
    };
    responses: {
      /** @description Schema registered */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SchemaResponse'];
        };
      };
    };
  };
  ListSchemas: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSchemasRequest'];
      };
    };
    responses: {
      /** @description Schemas listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListSchemasResponse'];
        };
      };
    };
  };
  createScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSceneRequest'];
      };
    };
    responses: {
      /** @description Scene created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SceneResponse'];
        };
      };
      /** @description Invalid scene structure (validation failed) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene with this sceneId already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSceneRequest'];
      };
    };
    responses: {
      /** @description Scene retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetSceneResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listScenes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListScenesRequest'];
      };
    };
    responses: {
      /** @description Scenes listed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListScenesResponse'];
        };
      };
    };
  };
  updateScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateSceneRequest'];
      };
    };
    responses: {
      /** @description Scene updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SceneResponse'];
        };
      };
      /** @description Invalid scene structure */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene is checked out by another user */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteSceneRequest'];
      };
    };
    responses: {
      /** @description Scene deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteSceneResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cannot delete - other scenes reference this scene */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  validateScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidateSceneRequest'];
      };
    };
    responses: {
      /** @description Validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidationResult'];
        };
      };
    };
  };
  checkoutScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckoutRequest'];
      };
    };
    responses: {
      /** @description Checkout successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CheckoutResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Scene already checked out by another user */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  commitScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CommitRequest'];
      };
    };
    responses: {
      /** @description Commit successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CommitResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Checkout expired */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  discardCheckout: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DiscardRequest'];
      };
    };
    responses: {
      /** @description Discard successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DiscardResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  heartbeatCheckout: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HeartbeatRequest'];
      };
    };
    responses: {
      /** @description Lock extended */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HeartbeatResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Checkout expired */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSceneHistory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HistoryRequest'];
      };
    };
    responses: {
      /** @description History retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HistoryResponse'];
        };
      };
      /** @description Scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getValidationRules: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetValidationRulesRequest'];
      };
    };
    responses: {
      /** @description Rules retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetValidationRulesResponse'];
        };
      };
    };
  };
  searchScenes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SearchScenesRequest'];
      };
    };
    responses: {
      /** @description Search results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SearchScenesResponse'];
        };
      };
    };
  };
  findReferences: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FindReferencesRequest'];
      };
    };
    responses: {
      /** @description Referencing scenes found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FindReferencesResponse'];
        };
      };
    };
  };
  findAssetUsage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FindAssetUsageRequest'];
      };
    };
    responses: {
      /** @description Asset usage found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FindAssetUsageResponse'];
        };
      };
    };
  };
  duplicateScene: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DuplicateSceneRequest'];
      };
    };
    responses: {
      /** @description Scene duplicated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SceneResponse'];
        };
      };
      /** @description Source scene not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSpecies: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSpeciesRequest'];
      };
    };
    responses: {
      /** @description Species retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SpeciesResponse'];
        };
      };
      /** @description Species not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSpeciesByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSpeciesByCodeRequest'];
      };
    };
    responses: {
      /** @description Species retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SpeciesResponse'];
        };
      };
      /** @description Species not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listSpecies: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSpeciesRequest'];
      };
    };
    responses: {
      /** @description Species retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SpeciesListResponse'];
        };
      };
    };
  };
  listSpeciesByRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSpeciesByRealmRequest'];
      };
    };
    responses: {
      /** @description Species retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SpeciesListResponse'];
        };
      };
      /** @description Realm not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAccountSubscriptions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAccountSubscriptionsRequest'];
      };
    };
    responses: {
      /** @description Subscriptions retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SubscriptionListResponse'];
        };
      };
    };
  };
  getSubscription: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSubscriptionRequest'];
      };
    };
    responses: {
      /** @description Subscription retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SubscriptionInfo'];
        };
      };
      /** @description Subscription not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cancelSubscription: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CancelSubscriptionRequest'];
      };
    };
    responses: {
      /** @description Subscription cancelled successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SubscriptionInfo'];
        };
      };
      /** @description Not authorized to cancel this subscription */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Subscription not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  answerPeer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AnswerPeerRequest'];
      };
    };
    responses: {
      /** @description SDP answer processed, peer notified */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not in voice:ringing state (no pending offers) */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Peer or room not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Website service status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StatusResponse'];
        };
      };
    };
  };
  getPageContent: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Page slug identifier */
        slug: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Page content retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PageContent'];
        };
      };
      /** @description Page not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  getNews: {
    parameters: {
      query?: {
        /** @description Number of news items to return */
        limit?: number;
        /** @description Pagination offset */
        offset?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description News items retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['NewsResponse'];
        };
      };
    };
  };
  getServerStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Server status information */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ServerStatusResponse'];
        };
      };
    };
  };
  getDownloads: {
    parameters: {
      query?: {
        /** @description Filter by platform */
        platform?: components['schemas']['Platform'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Download links retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DownloadsResponse'];
        };
      };
    };
  };
  submitContact: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ContactRequest'];
      };
    };
    responses: {
      /** @description Contact form submitted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ContactResponse'];
        };
      };
      /** @description Invalid form data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Too many requests */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  getAccountProfile: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Account profile retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AccountProfile'];
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  getAccountCharacters: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Character list retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CharacterListResponse'];
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  listPages: {
    parameters: {
      query?: {
        includeUnpublished?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Page list retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PageMetadata'][];
        };
      };
    };
  };
  createPage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PageContent'];
      };
    };
    responses: {
      /** @description Page created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PageContent'];
        };
      };
    };
  };
  updatePage: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        slug: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PageContent'];
      };
    };
    responses: {
      /** @description Page updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PageContent'];
        };
      };
    };
  };
  deletePage: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        slug: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Page deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getSiteSettings: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Site settings retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SiteSettings'];
        };
      };
    };
  };
  updateSiteSettings: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SiteSettings'];
      };
    };
    responses: {
      /** @description Settings updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SiteSettings'];
        };
      };
    };
  };
  getTheme: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Theme configuration retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ThemeConfig'];
        };
      };
    };
  };
  updateTheme: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ThemeConfig'];
      };
    };
    responses: {
      /** @description Theme updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAccountSubscription: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Subscription information retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SubscriptionResponse'];
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
}
