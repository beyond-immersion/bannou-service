/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/analytics/event/ingest': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Ingest a single analytics event
     * @description High-throughput event ingestion endpoint for recording game events.
     *     Events are buffered in memory and periodically flushed to persistent storage.
     *     Service-only endpoint - not exposed to clients.
     */
    post: operations['ingestEvent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/analytics/event/ingest-batch': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Ingest multiple analytics events
     * @description Batch event ingestion for high-volume scenarios. Accepts up to 1000 events per request.
     *     Service-only endpoint - not exposed to clients.
     */
    post: operations['ingestEventBatch'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/analytics/summary/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get entity statistics summary
     * @description Retrieve aggregated statistics for an entity. Summaries include total counts,
     *     averages, and derived metrics computed from ingested events.
     */
    post: operations['getEntitySummary'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/analytics/summary/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query entity summaries with filters
     * @description Query multiple entity summaries with filtering and sorting options.
     *     Useful for dashboards and reporting.
     */
    post: operations['queryEntitySummaries'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/analytics/rating/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get entity Glicko-2 skill rating
     * @description Retrieve the current Glicko-2 skill rating for an entity.
     *     Returns rating, rating deviation (RD), and volatility.
     */
    post: operations['getSkillRating'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/analytics/rating/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update entity skill rating after match
     * @description Update skill ratings for entities after a match result.
     *     Uses Glicko-2 algorithm to compute new ratings based on outcomes.
     *     Service-only endpoint - typically called by game-session service.
     */
    post: operations['updateSkillRating'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/analytics/controller-history/record': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Record controller possession event
     * @description Record when an account takes or releases control of an entity.
     *     Used for tracking which player controlled which character/actor at what time.
     *     Service-only endpoint.
     */
    post: operations['recordControllerEvent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/analytics/controller-history/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query controller history
     * @description Query who controlled what entity during a time range.
     *     Useful for audit trails and replays.
     */
    post: operations['queryControllerHistory'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /**
     * @description Type of entity being tracked
     * @enum {string}
     */
    EntityType: 'account' | 'character' | 'guild' | 'actor' | 'custom';
    /**
     * @description Type of controller action
     * @enum {string}
     */
    ControllerAction: 'possess' | 'release';
    /** @description Request to ingest a single analytics event */
    IngestEventRequest: {
      /**
       * Format: uuid
       * @description ID of the game service that generated this event
       */
      gameServiceId: string;
      /** @description Type of event (e.g., kill, death, score, action) */
      eventType: string;
      /**
       * Format: uuid
       * @description ID of the entity this event relates to
       */
      entityId: string;
      /** @description Entity type the event is attributed to */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: date-time
       * @description When the event occurred
       */
      timestamp: string;
      /**
       * Format: double
       * @description Numeric value associated with the event (e.g., score amount)
       */
      value?: number;
      /** @description Additional event-specific data */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response after ingesting an event */
    IngestEventResponse: {
      /**
       * Format: uuid
       * @description Unique identifier assigned to this event
       */
      eventId: string;
      /** @description Whether the event was accepted for processing */
      accepted: boolean;
    };
    /** @description Request to ingest multiple analytics events */
    IngestEventBatchRequest: {
      /** @description List of events to ingest (max 1000) */
      events: components['schemas']['IngestEventRequest'][];
    };
    /** @description Response after batch event ingestion */
    IngestEventBatchResponse: {
      /** @description Number of events accepted */
      accepted: number;
      /** @description Number of events rejected */
      rejected: number;
      /** @description Error messages for rejected events */
      errors?: string[] | null;
    };
    /** @description Request to get statistics for an entity */
    GetEntitySummaryRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type to summarize */
      entityType: components['schemas']['EntityType'];
    };
    /** @description Aggregated statistics for an entity */
    EntitySummaryResponse: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type for this summary */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: int64
       * @description Total number of events recorded
       */
      totalEvents: number;
      /**
       * Format: date-time
       * @description Timestamp of first recorded event
       */
      firstEventAt: string;
      /**
       * Format: date-time
       * @description Timestamp of most recent event
       */
      lastEventAt: string;
      /** @description Count of events by type */
      eventCounts?: {
        [key: string]: number;
      };
      /** @description Aggregated numeric values (sums, averages) */
      aggregates?: {
        [key: string]: number;
      };
    };
    /** @description Request to query multiple entity summaries */
    QueryEntitySummariesRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description Optional filter by entity type */
      entityType?: components['schemas']['EntityType'];
      /** @description Filter by event type */
      eventType?: string | null;
      /** @description Minimum number of events */
      minEvents?: number;
      /** @description Field to sort by */
      sortBy?: string | null;
      /**
       * @description Sort in descending order
       * @default true
       */
      sortDescending: boolean;
      /**
       * @description Maximum results to return
       * @default 100
       */
      limit: number;
      /**
       * @description Number of results to skip
       * @default 0
       */
      offset: number;
    };
    /** @description Response containing queried entity summaries */
    QueryEntitySummariesResponse: {
      /** @description List of matching entity summaries */
      summaries: components['schemas']['EntitySummaryResponse'][];
      /**
       * Format: int64
       * @description Total number of matching entities
       */
      total: number;
    };
    /** @description Request to get skill rating for an entity */
    GetSkillRatingRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type whose rating is requested */
      entityType: components['schemas']['EntityType'];
      /** @description Type of rating (e.g., overall, ranked, casual) */
      ratingType: string;
    };
    /** @description Glicko-2 skill rating for an entity */
    SkillRatingResponse: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type for this rating record */
      entityType: components['schemas']['EntityType'];
      /** @description Type of rating */
      ratingType: string;
      /**
       * Format: double
       * @description Current Glicko-2 rating (typically 1500 start)
       */
      rating: number;
      /**
       * Format: double
       * @description Rating deviation (uncertainty) - lower is more confident
       */
      ratingDeviation: number;
      /**
       * Format: double
       * @description Rating volatility (consistency of performance)
       */
      volatility: number;
      /** @description Number of rated matches played */
      matchesPlayed: number;
      /**
       * Format: date-time
       * @description Timestamp of last rated match
       */
      lastMatchAt?: string | null;
    };
    /** @description Request to update skill ratings after a match */
    UpdateSkillRatingRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /** @description Type of rating to update */
      ratingType: string;
      /**
       * Format: uuid
       * @description Unique identifier for this match
       */
      matchId: string;
      /** @description Results for all participants (min 2) */
      results: components['schemas']['MatchResult'][];
    };
    /** @description Individual result in a match */
    MatchResult: {
      /**
       * Format: uuid
       * @description ID of the participating entity
       */
      entityId: string;
      /** @description Entity type for this match participant */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: double
       * @description Match outcome (1.0 = win, 0.5 = draw, 0.0 = loss)
       */
      outcome: number;
      /**
       * Format: double
       * @description Optional numeric score for the match
       */
      score?: number | null;
    };
    /** @description Response after updating skill ratings */
    UpdateSkillRatingResponse: {
      /**
       * Format: uuid
       * @description ID of the processed match
       */
      matchId: string;
      /** @description Updated ratings for all participants */
      updatedRatings: components['schemas']['SkillRatingChange'][];
    };
    /** @description Rating change for a single entity */
    SkillRatingChange: {
      /**
       * Format: uuid
       * @description ID of the entity
       */
      entityId: string;
      /** @description Entity type for this rating change */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: double
       * @description Rating before this match
       */
      previousRating: number;
      /**
       * Format: double
       * @description Rating after this match
       */
      newRating: number;
      /**
       * Format: double
       * @description Change in rating (can be negative)
       */
      ratingChange: number;
    };
    /** @description Request to record a controller possession/release event */
    RecordControllerEventRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /**
       * Format: uuid
       * @description ID of the account taking/releasing control
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the entity being controlled
       */
      targetEntityId: string;
      /** @description Entity type being controlled */
      targetEntityType: components['schemas']['EntityType'];
      /** @description Whether control was possessed or released */
      action: components['schemas']['ControllerAction'];
      /**
       * Format: date-time
       * @description When the control event occurred
       */
      timestamp: string;
      /**
       * Format: uuid
       * @description Game session ID (if applicable)
       */
      sessionId?: string | null;
    };
    /** @description Request to query controller history */
    QueryControllerHistoryRequest: {
      /**
       * Format: uuid
       * @description ID of the game service
       */
      gameServiceId: string;
      /**
       * Format: uuid
       * @description Filter by controlling account
       */
      accountId?: string | null;
      /**
       * Format: uuid
       * @description Filter by controlled entity
       */
      targetEntityId?: string | null;
      /** @description Filter by entity type */
      targetEntityType?: components['schemas']['EntityType'];
      /**
       * Format: date-time
       * @description Start of time range
       */
      startTime?: string | null;
      /**
       * Format: date-time
       * @description End of time range
       */
      endTime?: string | null;
      /**
       * @description Maximum results to return
       * @default 100
       */
      limit: number;
    };
    /** @description Response containing controller history */
    QueryControllerHistoryResponse: {
      /** @description Controller events matching the query */
      events: components['schemas']['ControllerHistoryEvent'][];
    };
    /** @description A single controller possession/release event */
    ControllerHistoryEvent: {
      /**
       * Format: uuid
       * @description Unique identifier for this event
       */
      eventId: string;
      /**
       * Format: uuid
       * @description ID of the controlling account
       */
      accountId: string;
      /**
       * Format: uuid
       * @description ID of the controlled entity
       */
      targetEntityId: string;
      /** @description Entity type that was controlled */
      targetEntityType: components['schemas']['EntityType'];
      /** @description Control action that occurred (possess/release) */
      action: components['schemas']['ControllerAction'];
      /**
       * Format: date-time
       * @description When the event occurred
       */
      timestamp: string;
      /**
       * Format: uuid
       * @description Associated game session ID
       */
      sessionId?: string | null;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  ingestEvent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['IngestEventRequest'];
      };
    };
    responses: {
      /** @description Event ingested successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['IngestEventResponse'];
        };
      };
    };
  };
  ingestEventBatch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['IngestEventBatchRequest'];
      };
    };
    responses: {
      /** @description Events ingested successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['IngestEventBatchResponse'];
        };
      };
    };
  };
  getEntitySummary: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEntitySummaryRequest'];
      };
    };
    responses: {
      /** @description Entity summary retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EntitySummaryResponse'];
        };
      };
      /** @description Entity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryEntitySummaries: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryEntitySummariesRequest'];
      };
    };
    responses: {
      /** @description Query executed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryEntitySummariesResponse'];
        };
      };
    };
  };
  getSkillRating: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSkillRatingRequest'];
      };
    };
    responses: {
      /** @description Skill rating retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SkillRatingResponse'];
        };
      };
      /** @description Entity has no skill rating */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateSkillRating: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateSkillRatingRequest'];
      };
    };
    responses: {
      /** @description Skill ratings updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateSkillRatingResponse'];
        };
      };
    };
  };
  recordControllerEvent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RecordControllerEventRequest'];
      };
    };
    responses: {
      /** @description Controller event recorded successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryControllerHistory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryControllerHistoryRequest'];
      };
    };
    responses: {
      /** @description Controller history retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryControllerHistoryResponse'];
        };
      };
    };
  };
}
