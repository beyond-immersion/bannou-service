/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/mapping/create-channel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new map channel and become its authority
     * @description Creates a new region+kind channel and grants authority to caller.
     *     Returns ingestTopic for high-throughput event publishing.
     *     If channel already exists with active authority, returns Conflict.
     */
    post: operations['createChannel'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/release-authority': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Release authority over a channel
     * @description Voluntarily releases authority. Channel becomes unassigned.
     *     Only the current authority can release.
     */
    post: operations['releaseAuthority'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/authority-heartbeat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Maintain authority over channel
     * @description Keep-alive for authority. Must be called periodically (default every 30s).
     *     Failure to heartbeat results in authority expiration.
     */
    post: operations['authorityHeartbeat'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/publish': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Publish map data update (RPC path)
     * @description Game servers use this to push authoritative spatial updates.
     *     Validates authority token, stores update, and broadcasts to consumers.
     *     For high-throughput scenarios, use event publishing via ingestTopic instead.
     */
    post: operations['publishMapUpdate'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/publish-objects': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Publish metadata object changes (batch)
     * @description Game servers use this to push object state changes.
     *     Efficiently batches multiple object changes into one event.
     *     Max 100 changes per request.
     */
    post: operations['publishObjectChanges'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/request-snapshot': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request full snapshot for cold start
     * @description Consumers use this when starting up to get initial state.
     *     Returns current snapshot of requested region/kinds.
     *     For very large maps, payloadRef points to lib-asset storage.
     */
    post: operations['requestSnapshot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/point': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query map data at a specific point
     * @description Returns all map data at a point across requested kinds.
     *     Used by behavior stacks for contextual decisions.
     *     Optionally includes objects within radius.
     */
    post: operations['queryPoint'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/bounds': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query map data within bounds
     * @description Returns map data within a bounding box.
     *     For event actors needing region overview.
     *     Limited to maxObjects per kind.
     */
    post: operations['queryBounds'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/objects-by-type': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find all objects of a type in region
     * @description Returns all objects matching an objectType filter.
     *     For event actors asking "where are all the boulder clusters?"
     */
    post: operations['queryObjectsByType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/query/affordance': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find locations that afford a specific action or scene type
     * @description Affordance queries answer "where can I do X?" by combining
     *     multiple map kinds and applying game-specific scoring logic.
     *
     *     Used by Event Brain for procedural scene orchestration:
     *     - "Find ambush locations"
     *     - "Find dramatic reveal spots"
     *     - "Find sheltered rest areas"
     *
     *     Well-known types have predefined scoring; use affordanceType=custom
     *     with customAffordance for novel scenarios.
     */
    post: operations['queryAffordance'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/authoring/checkout': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Acquire exclusive edit lock for design-time editing
     * @description For level editors and design tools only.
     *     Game servers do NOT use this - they use create-channel for implicit authority.
     *     Returns authority token for publishing edits.
     */
    post: operations['checkoutForAuthoring'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/authoring/commit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Commit design-time changes
     * @description Commits pending changes and releases the checkout lock.
     *     Optionally includes a commit message for history.
     */
    post: operations['commitAuthoring'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/authoring/release': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Release authoring checkout without committing
     * @description Discards pending changes and releases the checkout lock.
     *     Use when abandoning edits.
     */
    post: operations['releaseAuthoring'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a map definition template
     * @description Creates a new map definition (template) that describes the structure
     *     of a region. Definitions are templates that can be used to bootstrap
     *     channels with predefined layer configurations.
     */
    post: operations['createDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get a map definition by ID
     * @description Returns the full map definition including all layer configurations.
     */
    post: operations['getDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List map definitions with optional filters
     * @description Returns a paginated list of map definitions.
     */
    post: operations['listDefinitions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a map definition
     * @description Updates an existing map definition. Cannot change the definition ID.
     *     Layer configurations can be modified.
     */
    post: operations['updateDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mapping/definition/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a map definition
     * @description Deletes a map definition. Cannot delete if active channels reference it.
     */
    post: operations['deleteDefinition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /**
     * @description The category of spatial data this map contains.
     *     Different kinds have different update frequencies, storage models, and TTLs.
     * @enum {string}
     */
    MapKind:
      | 'terrain'
      | 'static_geometry'
      | 'navigation'
      | 'resources'
      | 'spawn_points'
      | 'points_of_interest'
      | 'dynamic_objects'
      | 'hazards'
      | 'weather_effects'
      | 'ownership'
      | 'combat_effects'
      | 'visual_effects';
    /**
     * @description How to handle publish attempts from non-authority sources
     * @default reject_and_alert
     * @enum {string}
     */
    NonAuthorityHandlingMode: 'reject_and_alert' | 'accept_and_alert' | 'reject_silent';
    /**
     * @description Policy for handling authority takeover when creating a channel that
     *     already has expired authority. Controls what happens to existing data.
     * @default preserve_and_diff
     * @enum {string}
     */
    AuthorityTakeoverMode: 'preserve_and_diff' | 'reset' | 'require_consume';
    /**
     * @description Well-known affordance types with predefined scoring logic.
     *     Use 'custom' for novel affordance definitions.
     * @enum {string}
     */
    AffordanceType:
      | 'ambush'
      | 'shelter'
      | 'vista'
      | 'choke_point'
      | 'gathering_spot'
      | 'dramatic_reveal'
      | 'hidden_path'
      | 'defensible_position'
      | 'custom';
    /**
     * @description Controls caching behavior for affordance queries
     * @default cached
     * @enum {string}
     */
    AffordanceFreshness: 'fresh' | 'cached' | 'aggressive_cache';
    /**
     * @description Size classification affecting cover requirements and passage width
     * @default medium
     * @enum {string}
     */
    ActorSize: 'tiny' | 'small' | 'medium' | 'large' | 'huge';
    /**
     * @description Whether an update is incremental or a full snapshot
     * @default delta
     * @enum {string}
     */
    DeltaType: 'delta' | 'snapshot';
    /**
     * @description Type of change to a map object
     * @enum {string}
     */
    ObjectAction: 'created' | 'updated' | 'deleted';
    /** @description A point in 3D space */
    Position3D: {
      /**
       * Format: double
       * @description X coordinate (typically east-west)
       */
      x: number;
      /**
       * Format: double
       * @description Y coordinate (typically up-down / elevation)
       */
      y: number;
      /**
       * Format: double
       * @description Z coordinate (typically north-south)
       */
      z: number;
    };
    /** @description An axis-aligned bounding box in 3D space */
    Bounds: {
      /** @description Minimum corner (lowest x, y, z values) */
      min: components['schemas']['Position3D'];
      /** @description Maximum corner (highest x, y, z values) */
      max: components['schemas']['Position3D'];
    };
    /**
     * @description Schema-less payload. Only envelope fields are validated.
     *     The 'data' field can contain ANYTHING the publisher wants.
     *     lib-mapping does not validate contents - only publisher and consumer care.
     */
    MapPayload: {
      /**
       * Format: uuid
       * @description Unique ID for this object (generated if not provided)
       */
      objectId?: string;
      /** @description Publisher-defined type (used for indexing and filtering) */
      objectType: string;
      /** @description Position for point objects */
      position?: components['schemas']['Position3D'];
      /** @description Bounds for area objects */
      bounds?: components['schemas']['Bounds'];
      /**
       * @description SCHEMA-LESS. Can contain anything.
       *     lib-mapping does not validate this.
       *     Examples: cover_rating, health, respawn_delay, etc.
       */
      data?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description A stored map object with full metadata */
    MapObject: {
      /**
       * Format: uuid
       * @description Unique identifier for this object
       */
      objectId: string;
      /**
       * Format: uuid
       * @description Region this object belongs to
       */
      regionId: string;
      /** @description Map kind this object is stored under */
      kind: components['schemas']['MapKind'];
      /** @description Publisher-defined type */
      objectType: string;
      /** @description Position for point objects */
      position?: components['schemas']['Position3D'];
      /** @description Bounding box for area objects */
      bounds?: components['schemas']['Bounds'];
      /** @description Schema-less object data (publisher-defined) */
      data?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: int64
       * @description Monotonic version for ordering
       */
      version?: number;
      /**
       * Format: date-time
       * @description When the object was first created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the object was last updated
       */
      updatedAt: string;
    };
    /** @description A single change to a map object */
    ObjectChange: {
      /**
       * Format: uuid
       * @description ID of the object being changed
       */
      objectId: string;
      /** @description Type of change */
      action: components['schemas']['ObjectAction'];
      /** @description Object type (required for created) */
      objectType?: string | null;
      /** @description Object position (for create/update) */
      position?: components['schemas']['Position3D'];
      /** @description Object bounds (for create/update) */
      bounds?: components['schemas']['Bounds'];
      /** @description Object state (for created/updated) */
      data?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Granted authority over a map channel */
    AuthorityGrant: {
      /**
       * Format: uuid
       * @description The channel (region+kind) you have authority over
       */
      channelId: string;
      /** @description Opaque token proving your authority (include in publishes) */
      authorityToken: string;
      /** @description Topic for direct lib-messaging publishes (map.ingest.{channelId}) */
      ingestTopic: string;
      /**
       * Format: date-time
       * @description When authority expires (must heartbeat to extend)
       */
      expiresAt: string;
      /**
       * Format: uuid
       * @description Region ID for this channel
       */
      regionId: string;
      /** @description Map kind for this channel */
      kind: components['schemas']['MapKind'];
    };
    /** @description Configuration for non-authority publish alerts */
    NonAuthorityAlertConfig: {
      /**
       * @description Whether to emit warning events
       * @default true
       */
      enabled: boolean;
      /** @description Custom topic for warnings (default map.warnings.unauthorized_publish) */
      alertTopic?: string | null;
      /**
       * @description Include truncated payload in warning for debugging
       * @default false
       */
      includePayloadSummary: boolean;
    };
    /**
     * @description Actor-specific capabilities that affect affordance evaluation.
     *     Same location may afford different actions to different actor types.
     */
    ActorCapabilities: {
      /** @description Affects cover requirements and passage width */
      size?: components['schemas']['ActorSize'];
      /** @description Actor height in meters (affects cover, sightlines) */
      height?: number | null;
      /**
       * @description Can reach elevated positions
       * @default false
       */
      canClimb: boolean;
      /**
       * @description Includes water-based positions
       * @default false
       */
      canSwim: boolean;
      /**
       * @description Includes aerial positions
       * @default false
       */
      canFly: boolean;
      /** @description Affects sightline distance requirements */
      perceptionRange?: number | null;
      /** @description Affects escape route viability calculations */
      movementSpeed?: number | null;
      /** @description Affects ambush/hidden_path affordance scoring */
      stealthRating?: number | null;
    };
    /** @description Custom affordance definition for novel scenarios */
    CustomAffordance: {
      /** @description Human-readable description of this affordance */
      description?: string | null;
      /**
       * @description Required criteria. Object types, property constraints.
       *     Example: { "objectTypes": ["boulder"], "cover_rating": { "min": 0.5 } }
       */
      requires?: {
        [key: string]: unknown;
      } | null;
      /**
       * @description Preferred criteria (boost score but not required).
       *     Example: { "elevation": { "prefer_higher": true } }
       */
      prefers?: {
        [key: string]: unknown;
      } | null;
      /**
       * @description Exclusion criteria. Reject candidates matching these.
       *     Example: { "hazards": true, "contested": true }
       */
      excludes?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to create a new map channel */
    CreateChannelRequest: {
      /** @description App-id of the caller taking authority (used for event metadata) */
      sourceAppId: string;
      /**
       * Format: uuid
       * @description Region for this channel
       */
      regionId: string;
      /** @description Map kind for this channel */
      kind: components['schemas']['MapKind'];
      /** @description How to handle non-authority publishes */
      nonAuthorityHandling?: components['schemas']['NonAuthorityHandlingMode'];
      /**
       * @description Policy for authority takeover when channel exists with expired authority.
       *     preserve_and_diff (default): Keep existing data, new authority sends updates.
       *     reset: Clear all channel data before new authority takes over.
       *     require_consume: New authority must call RequestSnapshot before publishing.
       */
      takeoverMode?: components['schemas']['AuthorityTakeoverMode'];
      /** @description Configuration for non-authority publish alerts */
      alertConfig?: components['schemas']['NonAuthorityAlertConfig'];
      /** @description Optional initial data to populate channel */
      initialSnapshot?: components['schemas']['MapPayload'][] | null;
    };
    /** @description Request to release authority over a channel */
    ReleaseAuthorityRequest: {
      /**
       * Format: uuid
       * @description Channel to release
       */
      channelId: string;
      /** @description Current authority token */
      authorityToken: string;
    };
    /** @description Response to authority release */
    ReleaseAuthorityResponse: {
      /** @description Whether authority was successfully released */
      released?: boolean;
    };
    /** @description Request to maintain authority */
    AuthorityHeartbeatRequest: {
      /**
       * Format: uuid
       * @description Channel to heartbeat
       */
      channelId: string;
      /** @description Current authority token */
      authorityToken: string;
    };
    /** @description Response to authority heartbeat */
    AuthorityHeartbeatResponse: {
      /** @description Whether your authority is still valid */
      valid?: boolean;
      /**
       * Format: date-time
       * @description Updated expiration time
       */
      expiresAt?: string;
      /** @description Optional warning (e.g., "authority expiring soon") */
      warning?: string | null;
    };
    /** @description Request to publish map data update */
    PublishMapUpdateRequest: {
      /**
       * Format: uuid
       * @description Channel to publish to
       */
      channelId: string;
      /** @description Authority token for validation */
      authorityToken: string;
      /** @description App-id of caller (for warnings on non-authority attempts) */
      sourceAppId?: string | null;
      /** @description Affected area (null means entire region) */
      bounds?: components['schemas']['Bounds'];
      /** @description Whether this is incremental or full */
      deltaType?: components['schemas']['DeltaType'];
      /** @description The payload to publish */
      payload: components['schemas']['MapPayload'];
      /** @description For large payloads, lib-asset reference instead of inline */
      payloadAssetRef?: string | null;
    };
    /** @description Response to publish request */
    PublishMapUpdateResponse: {
      /** @description Whether the update was accepted */
      accepted?: boolean;
      /**
       * Format: int64
       * @description Assigned version number
       */
      version?: number;
      /** @description Optional warning message */
      warning?: string | null;
    };
    /** @description Request to publish object changes (batch) */
    PublishObjectChangesRequest: {
      /**
       * Format: uuid
       * @description Channel to publish to
       */
      channelId: string;
      /** @description Authority token for validation */
      authorityToken: string;
      /** @description App-id of caller (for warnings on non-authority attempts) */
      sourceAppId?: string | null;
      /** @description Object changes to publish */
      changes: components['schemas']['ObjectChange'][];
    };
    /** @description Response to object changes publish */
    PublishObjectChangesResponse: {
      /** @description Whether the changes were accepted */
      accepted?: boolean;
      /** @description Number of changes accepted */
      acceptedCount?: number;
      /** @description Number of changes rejected */
      rejectedCount?: number;
      /**
       * Format: int64
       * @description Assigned version number
       */
      version?: number;
      /** @description Optional warning message */
      warning?: string | null;
    };
    /** @description Request for full snapshot */
    RequestSnapshotRequest: {
      /**
       * Format: uuid
       * @description Region to snapshot
       */
      regionId: string;
      /** @description Which kinds to include (default all) */
      kinds?: components['schemas']['MapKind'][] | null;
      /** @description Optional bounds filter */
      bounds?: components['schemas']['Bounds'];
      /**
       * @description Optional authority token. If provided and valid, clears the
       *     RequiresConsumeBeforePublish flag for require_consume takeover mode.
       */
      authorityToken?: string | null;
    };
    /** @description Snapshot response */
    RequestSnapshotResponse: {
      /**
       * Format: uuid
       * @description Region ID
       */
      regionId?: string;
      /** @description All objects in snapshot */
      objects?: components['schemas']['MapObject'][];
      /** @description For large snapshots, lib-asset reference */
      payloadRef?: string | null;
      /**
       * Format: int64
       * @description Snapshot version
       */
      version?: number;
    };
    /** @description Query map data at a point */
    QueryPointRequest: {
      /**
       * Format: uuid
       * @description Region to query
       */
      regionId: string;
      /** @description Point to query at */
      position: components['schemas']['Position3D'];
      /** @description Kinds to query (default all) */
      kinds?: components['schemas']['MapKind'][] | null;
      /** @description Include objects within this radius */
      radius?: number | null;
    };
    /** @description Point query results */
    QueryPointResponse: {
      /** @description Objects at/near the point */
      objects?: components['schemas']['MapObject'][];
      /** @description Queried position */
      position?: components['schemas']['Position3D'];
      /** @description Applied radius filter */
      radius?: number | null;
    };
    /** @description Query map data within bounds */
    QueryBoundsRequest: {
      /**
       * Format: uuid
       * @description Region to query
       */
      regionId: string;
      /** @description Bounding box to query */
      bounds: components['schemas']['Bounds'];
      /** @description Kinds to query (default all) */
      kinds?: components['schemas']['MapKind'][] | null;
      /**
       * @description Maximum objects to return
       * @default 500
       */
      maxObjects: number;
    };
    /** @description Bounds query results */
    QueryBoundsResponse: {
      /** @description Objects within bounds */
      objects?: components['schemas']['MapObject'][];
      /** @description Queried bounds */
      bounds?: components['schemas']['Bounds'];
      /** @description Whether results were truncated */
      truncated?: boolean;
    };
    /** @description Query objects by type */
    QueryObjectsByTypeRequest: {
      /**
       * Format: uuid
       * @description Region to query
       */
      regionId: string;
      /** @description Object type to filter by */
      objectType: string;
      /** @description Optional bounds filter */
      bounds?: components['schemas']['Bounds'];
      /**
       * @description Maximum objects to return
       * @default 500
       */
      maxObjects: number;
    };
    /** @description Object type query results */
    QueryObjectsByTypeResponse: {
      /** @description Matching objects */
      objects?: components['schemas']['MapObject'][];
      /** @description Queried object type */
      objectType?: string;
      /** @description Whether results were truncated */
      truncated?: boolean;
    };
    /** @description Query for locations that afford a specific action */
    AffordanceQueryRequest: {
      /**
       * Format: uuid
       * @description Region to search
       */
      regionId: string;
      /** @description Type of affordance to search for */
      affordanceType: components['schemas']['AffordanceType'];
      /** @description Custom affordance definition (when affordanceType=custom) */
      customAffordance?: components['schemas']['CustomAffordance'];
      /** @description Optional bounds to search within */
      bounds?: components['schemas']['Bounds'];
      /**
       * @description Maximum locations to return
       * @default 10
       */
      maxResults: number;
      /**
       * @description Minimum affordance score to include
       * @default 0.5
       */
      minScore: number;
      /** @description Expected participants (affects space requirements) */
      participantCount?: number | null;
      /** @description Positions to exclude (e.g., player's current location) */
      excludePositions?: components['schemas']['Position3D'][] | null;
      /** @description Actor capabilities affecting evaluation */
      actorCapabilities?: components['schemas']['ActorCapabilities'];
      /** @description Cache freshness level */
      freshness?: components['schemas']['AffordanceFreshness'];
      /** @description Max age of cached results (for cached/aggressive_cache) */
      maxAgeSeconds?: number | null;
    };
    /** @description A location that affords the requested action */
    AffordanceLocation: {
      /** @description Location position */
      position?: components['schemas']['Position3D'];
      /** @description Area bounds if affordance spans an area */
      bounds?: components['schemas']['Bounds'];
      /** @description How well this location affords the action (0-1) */
      score?: number;
      /**
       * @description What makes this location suitable.
       *     Example: { "cover_rating": 0.8, "sightlines": ["north"], "terrain": "rocky" }
       */
      features?: {
        [key: string]: unknown;
      } | null;
      /** @description Map objects contributing to this affordance */
      objectIds?: string[] | null;
    };
    /** @description Metadata about the affordance query execution */
    AffordanceQueryMetadata: {
      /** @description Map kinds that were queried */
      kindsSearched?: string[] | null;
      /** @description Number of candidate objects evaluated */
      objectsEvaluated?: number;
      /** @description Number of candidate positions generated */
      candidatesGenerated?: number;
      /** @description Query execution time in milliseconds */
      searchDurationMs?: number;
      /** @description Whether results came from cache */
      cacheHit?: boolean;
    };
    /** @description Affordance query results */
    AffordanceQueryResponse: {
      /** @description Scored locations (highest score first) */
      locations?: components['schemas']['AffordanceLocation'][];
      /** @description Metadata about query execution (optional) */
      queryMetadata?: components['schemas']['AffordanceQueryMetadata'];
    };
    /** @description Request to checkout for authoring */
    AuthoringCheckoutRequest: {
      /**
       * Format: uuid
       * @description Region to checkout
       */
      regionId: string;
      /** @description Map kind to checkout */
      kind: components['schemas']['MapKind'];
      /** @description Identifier for the editor/user */
      editorId: string;
    };
    /** @description Checkout response */
    AuthoringCheckoutResponse: {
      /** @description Token for publishing changes (if successful) */
      authorityToken?: string | null;
      /**
       * Format: date-time
       * @description When the checkout expires
       */
      expiresAt?: string | null;
      /** @description Who has the lock (if checkout failed) */
      lockedBy?: string | null;
      /**
       * Format: date-time
       * @description When the lock was acquired (if checkout failed)
       */
      lockedAt?: string | null;
    };
    /** @description Request to commit authoring changes */
    AuthoringCommitRequest: {
      /**
       * Format: uuid
       * @description Region being edited
       */
      regionId: string;
      /** @description Map kind being edited */
      kind: components['schemas']['MapKind'];
      /** @description Checkout authority token */
      authorityToken: string;
      /** @description Optional commit message for history */
      commitMessage?: string | null;
    };
    /** @description Commit response */
    AuthoringCommitResponse: {
      /**
       * Format: int64
       * @description Committed version number
       */
      version?: number | null;
    };
    /** @description Request to release authoring checkout */
    AuthoringReleaseRequest: {
      /**
       * Format: uuid
       * @description Region being edited
       */
      regionId: string;
      /** @description Map kind being edited */
      kind: components['schemas']['MapKind'];
      /** @description Checkout authority token */
      authorityToken: string;
    };
    /** @description Release response */
    AuthoringReleaseResponse: {
      /** @description Whether checkout was released */
      released?: boolean;
    };
    /** @description A map definition template that describes the structure of a region */
    MapDefinition: {
      /**
       * Format: uuid
       * @description Unique identifier for this definition
       */
      definitionId: string;
      /** @description Human-readable name */
      name: string;
      /** @description Description of the map template */
      description?: string | null;
      /** @description Layer configurations for this map */
      layers?: components['schemas']['LayerDefinition'][] | null;
      /** @description Default bounds for regions using this definition */
      defaultBounds?: components['schemas']['Bounds'];
      /** @description Additional metadata (schema-less) */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description When the definition was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the definition was last updated
       */
      updatedAt?: string | null;
    };
    /** @description Configuration for a specific layer within a map definition */
    LayerDefinition: {
      /** @description The layer kind */
      kind: components['schemas']['MapKind'];
      /**
       * @description How this layer's data should be stored
       * @default cached
       * @enum {string}
       */
      storageMode: 'durable' | 'cached' | 'ephemeral';
      /** @description TTL for cached/ephemeral data (0 = no TTL) */
      ttlSeconds?: number | null;
      /** @description Default non-authority handling for channels using this layer */
      defaultNonAuthorityHandling?: components['schemas']['NonAuthorityHandlingMode'];
      /**
       * Format: double
       * @description Spatial cell size for indexing (default from config if not set)
       */
      cellSize?: number | null;
    };
    /** @description Request to create a map definition */
    CreateDefinitionRequest: {
      /** @description Human-readable name */
      name: string;
      /** @description Description of the map template */
      description?: string | null;
      /** @description Layer configurations */
      layers?: components['schemas']['LayerDefinition'][] | null;
      /** @description Default bounds for regions using this definition */
      defaultBounds?: components['schemas']['Bounds'];
      /** @description Additional metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to get a map definition */
    GetDefinitionRequest: {
      /**
       * Format: uuid
       * @description Definition ID to retrieve
       */
      definitionId: string;
    };
    /** @description Request to list map definitions */
    ListDefinitionsRequest: {
      /** @description Filter by name (partial match) */
      nameFilter?: string | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Max results to return
       * @default 50
       */
      limit: number;
    };
    /** @description Response containing list of map definitions */
    ListDefinitionsResponse: {
      /** @description List of definitions */
      definitions?: components['schemas']['MapDefinition'][];
      /** @description Total count matching filter */
      total?: number;
      /** @description Current offset */
      offset?: number;
      /** @description Results limit used */
      limit?: number;
    };
    /** @description Request to update a map definition */
    UpdateDefinitionRequest: {
      /**
       * Format: uuid
       * @description Definition ID to update
       */
      definitionId: string;
      /** @description New name (optional) */
      name?: string | null;
      /** @description New description (optional) */
      description?: string | null;
      /** @description New layer configurations (replaces existing) */
      layers?: components['schemas']['LayerDefinition'][] | null;
      /** @description New default bounds */
      defaultBounds?: components['schemas']['Bounds'];
      /** @description New metadata (replaces existing) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to delete a map definition */
    DeleteDefinitionRequest: {
      /**
       * Format: uuid
       * @description Definition ID to delete
       */
      definitionId: string;
    };
    /** @description Response to delete request */
    DeleteDefinitionResponse: {
      /** @description Whether the definition was deleted */
      deleted?: boolean;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  createChannel: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateChannelRequest'];
      };
    };
    responses: {
      /** @description Channel created, authority granted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthorityGrant'];
        };
      };
      /** @description Channel already exists with active authority */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  releaseAuthority: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReleaseAuthorityRequest'];
      };
    };
    responses: {
      /** @description Authority released successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReleaseAuthorityResponse'];
        };
      };
      /** @description Not the current authority */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  authorityHeartbeat: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthorityHeartbeatRequest'];
      };
    };
    responses: {
      /** @description Heartbeat acknowledged */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthorityHeartbeatResponse'];
        };
      };
      /** @description Invalid or expired authority token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  publishMapUpdate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PublishMapUpdateRequest'];
      };
    };
    responses: {
      /** @description Update published successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PublishMapUpdateResponse'];
        };
      };
      /** @description Not authority for this channel */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  publishObjectChanges: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PublishObjectChangesRequest'];
      };
    };
    responses: {
      /** @description Object changes published */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PublishObjectChangesResponse'];
        };
      };
      /** @description Not authority for this channel */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  requestSnapshot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RequestSnapshotRequest'];
      };
    };
    responses: {
      /** @description Snapshot returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RequestSnapshotResponse'];
        };
      };
      /** @description Region not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryPoint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryPointRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryPointResponse'];
        };
      };
    };
  };
  queryBounds: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBoundsRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryBoundsResponse'];
        };
      };
    };
  };
  queryObjectsByType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryObjectsByTypeRequest'];
      };
    };
    responses: {
      /** @description Matching objects */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryObjectsByTypeResponse'];
        };
      };
    };
  };
  queryAffordance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AffordanceQueryRequest'];
      };
    };
    responses: {
      /** @description Scored locations */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AffordanceQueryResponse'];
        };
      };
    };
  };
  checkoutForAuthoring: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthoringCheckoutRequest'];
      };
    };
    responses: {
      /** @description Checkout successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthoringCheckoutResponse'];
        };
      };
      /** @description Already checked out by another editor */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  commitAuthoring: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthoringCommitRequest'];
      };
    };
    responses: {
      /** @description Changes committed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthoringCommitResponse'];
        };
      };
      /** @description Invalid checkout token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  releaseAuthoring: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthoringReleaseRequest'];
      };
    };
    responses: {
      /** @description Checkout released */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthoringReleaseResponse'];
        };
      };
    };
  };
  createDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateDefinitionRequest'];
      };
    };
    responses: {
      /** @description Definition created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MapDefinition'];
        };
      };
      /** @description Definition with this name already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetDefinitionRequest'];
      };
    };
    responses: {
      /** @description Definition found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MapDefinition'];
        };
      };
      /** @description Definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listDefinitions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListDefinitionsRequest'];
      };
    };
    responses: {
      /** @description Definitions list */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListDefinitionsResponse'];
        };
      };
    };
  };
  updateDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateDefinitionRequest'];
      };
    };
    responses: {
      /** @description Definition updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MapDefinition'];
        };
      };
      /** @description Definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteDefinition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteDefinitionRequest'];
      };
    };
    responses: {
      /** @description Definition deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteDefinitionResponse'];
        };
      };
      /** @description Definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Definition in use by active channels */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
